// Generated by Haxe 3.4.4
(function ($hx_exports, $global) { "use strict";
$hx_exports["kha"] = $hx_exports["kha"] || {};
$hx_exports["kha"]["input"] = $hx_exports["kha"]["input"] || {};
;$hx_exports["kha"]["_Color"] = $hx_exports["kha"]["_Color"] || {};
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); };
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
$hxClasses["EReg"] = EReg;
EReg.__name__ = true;
EReg.prototype = {
	r: null
	,match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw new js__$Boot_HaxeError("EReg::matched");
		}
	}
	,__class__: EReg
};
var HxOverrides = function() { };
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = true;
HxOverrides.strDate = function(s) {
	var _g = s.length;
	switch(_g) {
	case 8:
		var k = s.split(":");
		var d = new Date();
		d["setTime"](0);
		d["setUTCHours"](k[0]);
		d["setUTCMinutes"](k[1]);
		d["setUTCSeconds"](k[2]);
		return d;
	case 10:
		var k1 = s.split("-");
		return new Date(k1[0],k1[1] - 1,k1[2],0,0,0);
	case 19:
		var k2 = s.split(" ");
		var y = k2[0].split("-");
		var t = k2[1].split(":");
		return new Date(y[0],y[1] - 1,y[2],t[0],t[1],t[2]);
	default:
		throw new js__$Boot_HaxeError("Invalid date format : " + s);
	}
};
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Lambda = function() { };
$hxClasses["Lambda"] = Lambda;
Lambda.__name__ = true;
Lambda.array = function(it) {
	var a = [];
	var i = $iterator(it)();
	while(i.hasNext()) {
		var i1 = i.next();
		a.push(i1);
	}
	return a;
};
var List = function() {
	this.length = 0;
};
$hxClasses["List"] = List;
List.__name__ = true;
List.prototype = {
	h: null
	,q: null
	,length: null
	,add: function(item) {
		var x = new _$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,iterator: function() {
		return new _$List_ListIterator(this.h);
	}
	,__class__: List
};
var _$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
$hxClasses["_List.ListNode"] = _$List_ListNode;
_$List_ListNode.__name__ = true;
_$List_ListNode.prototype = {
	item: null
	,next: null
	,__class__: _$List_ListNode
};
var _$List_ListIterator = function(head) {
	this.head = head;
};
$hxClasses["_List.ListIterator"] = _$List_ListIterator;
_$List_ListIterator.__name__ = true;
_$List_ListIterator.prototype = {
	head: null
	,hasNext: function() {
		return this.head != null;
	}
	,next: function() {
		var val = this.head.item;
		this.head = this.head.next;
		return val;
	}
	,__class__: _$List_ListIterator
};
var Main = function() {
	this.colors = [-13555421,-1812932,-8204673,-869748,-15725557,-12578032,-8828119,-9145742,-15198184];
	var this1 = trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]);
	this.triangles = this1;
	this.appColors = [-65536,-16776961,-16711936,-256,-8388480,-1,-23296];
	var stageRadius = 570;
	this.drawPanels();
	kha_System.notifyOnRender($bind(this,this.render));
	kha_Scheduler.addTimeTask($bind(this,this.update),0,0.0333333333333333329);
};
$hxClasses["Main"] = Main;
Main.__name__ = true;
Main.main = function() {
	kha_System.init({ title : "Trilateral Dot Matrix test", width : 1024, height : 768, samplesPerPixel : 4},function() {
		new Main();
	});
};
Main.prototype = {
	appColors: null
	,triangles: null
	,colors: null
	,arrDotMatrix: null
	,display: null
	,drawPanels: function() {
		var shapes = new trilateral_polys_Shapes(this.triangles,this.colors);
		var scale = 5.;
		var dw = 10 * scale;
		var dh = 14 * scale;
		var arr = [];
		var _g1 = 0;
		var _g = "Trialateral Dot Matix test, using Kha.. What message would you like to send.. you can choose between pixel shapes; Circle, Square, Portrait, LandScape, Star, RoundedPortrait, RoundedLandScape.  You can have it scrolling the other way and scale it as it's all drawn with triangles      ".length;
		while(_g1 < _g) {
			var i = _g1++;
			var charCode = HxOverrides.cca("Trialateral Dot Matix test, using Kha.. What message would you like to send.. you can choose between pixel shapes; Circle, Square, Portrait, LandScape, Star, RoundedPortrait, RoundedLandScape.  You can have it scrolling the other way and scale it as it's all drawn with triangles      ",i);
			var arr1 = [];
			switch(charCode) {
			case 32:
				var this1 = 0;
				var bs = this1;
				var l = "00000".length;
				var _g11 = 0;
				var _g2 = l;
				while(_g11 < _g2) {
					var i1 = _g11++;
					var no = "00000".charCodeAt(i1);
					if(no == null) {
						break;
					}
					var v;
					switch(no) {
					case 32:
						v = false;
						break;
					case 42:
						v = true;
						break;
					case 48:
						v = false;
						break;
					case 49:
						v = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i1)));
					}
					switch(i1 - (l - 8)) {
					case 0:
						if(v) {
							bs |= 128;
						} else {
							bs &= -129;
						}
						break;
					case 1:
						if(v) {
							bs |= 64;
						} else {
							bs &= -65;
						}
						break;
					case 2:
						if(v) {
							bs |= 32;
						} else {
							bs &= -33;
						}
						break;
					case 3:
						if(v) {
							bs |= 16;
						} else {
							bs &= -17;
						}
						break;
					case 4:
						if(v) {
							bs |= 8;
						} else {
							bs &= -9;
						}
						break;
					case 5:
						if(v) {
							bs |= 4;
						} else {
							bs &= -5;
						}
						break;
					case 6:
						if(v) {
							bs |= 2;
						} else {
							bs &= -3;
						}
						break;
					case 7:
						if(v) {
							bs |= 1;
						} else {
							bs &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs;
				var this2 = 0;
				var bs1 = this2;
				var l1 = "00000".length;
				var _g12 = 0;
				var _g3 = l1;
				while(_g12 < _g3) {
					var i2 = _g12++;
					var no1 = "00000".charCodeAt(i2);
					if(no1 == null) {
						break;
					}
					var v1;
					switch(no1) {
					case 32:
						v1 = false;
						break;
					case 42:
						v1 = true;
						break;
					case 48:
						v1 = false;
						break;
					case 49:
						v1 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i2)));
					}
					switch(i2 - (l1 - 8)) {
					case 0:
						if(v1) {
							bs1 |= 128;
						} else {
							bs1 &= -129;
						}
						break;
					case 1:
						if(v1) {
							bs1 |= 64;
						} else {
							bs1 &= -65;
						}
						break;
					case 2:
						if(v1) {
							bs1 |= 32;
						} else {
							bs1 &= -33;
						}
						break;
					case 3:
						if(v1) {
							bs1 |= 16;
						} else {
							bs1 &= -17;
						}
						break;
					case 4:
						if(v1) {
							bs1 |= 8;
						} else {
							bs1 &= -9;
						}
						break;
					case 5:
						if(v1) {
							bs1 |= 4;
						} else {
							bs1 &= -5;
						}
						break;
					case 6:
						if(v1) {
							bs1 |= 2;
						} else {
							bs1 &= -3;
						}
						break;
					case 7:
						if(v1) {
							bs1 |= 1;
						} else {
							bs1 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs1;
				var this3 = 0;
				var bs2 = this3;
				var l2 = "00000".length;
				var _g13 = 0;
				var _g4 = l2;
				while(_g13 < _g4) {
					var i3 = _g13++;
					var no2 = "00000".charCodeAt(i3);
					if(no2 == null) {
						break;
					}
					var v2;
					switch(no2) {
					case 32:
						v2 = false;
						break;
					case 42:
						v2 = true;
						break;
					case 48:
						v2 = false;
						break;
					case 49:
						v2 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i3)));
					}
					switch(i3 - (l2 - 8)) {
					case 0:
						if(v2) {
							bs2 |= 128;
						} else {
							bs2 &= -129;
						}
						break;
					case 1:
						if(v2) {
							bs2 |= 64;
						} else {
							bs2 &= -65;
						}
						break;
					case 2:
						if(v2) {
							bs2 |= 32;
						} else {
							bs2 &= -33;
						}
						break;
					case 3:
						if(v2) {
							bs2 |= 16;
						} else {
							bs2 &= -17;
						}
						break;
					case 4:
						if(v2) {
							bs2 |= 8;
						} else {
							bs2 &= -9;
						}
						break;
					case 5:
						if(v2) {
							bs2 |= 4;
						} else {
							bs2 &= -5;
						}
						break;
					case 6:
						if(v2) {
							bs2 |= 2;
						} else {
							bs2 &= -3;
						}
						break;
					case 7:
						if(v2) {
							bs2 |= 1;
						} else {
							bs2 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs2;
				var this4 = 0;
				var bs3 = this4;
				var l3 = "00000".length;
				var _g14 = 0;
				var _g5 = l3;
				while(_g14 < _g5) {
					var i4 = _g14++;
					var no3 = "00000".charCodeAt(i4);
					if(no3 == null) {
						break;
					}
					var v3;
					switch(no3) {
					case 32:
						v3 = false;
						break;
					case 42:
						v3 = true;
						break;
					case 48:
						v3 = false;
						break;
					case 49:
						v3 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i4)));
					}
					switch(i4 - (l3 - 8)) {
					case 0:
						if(v3) {
							bs3 |= 128;
						} else {
							bs3 &= -129;
						}
						break;
					case 1:
						if(v3) {
							bs3 |= 64;
						} else {
							bs3 &= -65;
						}
						break;
					case 2:
						if(v3) {
							bs3 |= 32;
						} else {
							bs3 &= -33;
						}
						break;
					case 3:
						if(v3) {
							bs3 |= 16;
						} else {
							bs3 &= -17;
						}
						break;
					case 4:
						if(v3) {
							bs3 |= 8;
						} else {
							bs3 &= -9;
						}
						break;
					case 5:
						if(v3) {
							bs3 |= 4;
						} else {
							bs3 &= -5;
						}
						break;
					case 6:
						if(v3) {
							bs3 |= 2;
						} else {
							bs3 &= -3;
						}
						break;
					case 7:
						if(v3) {
							bs3 |= 1;
						} else {
							bs3 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs3;
				var this5 = 0;
				var bs4 = this5;
				var l4 = "00000".length;
				var _g15 = 0;
				var _g6 = l4;
				while(_g15 < _g6) {
					var i5 = _g15++;
					var no4 = "00000".charCodeAt(i5);
					if(no4 == null) {
						break;
					}
					var v4;
					switch(no4) {
					case 32:
						v4 = false;
						break;
					case 42:
						v4 = true;
						break;
					case 48:
						v4 = false;
						break;
					case 49:
						v4 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i5)));
					}
					switch(i5 - (l4 - 8)) {
					case 0:
						if(v4) {
							bs4 |= 128;
						} else {
							bs4 &= -129;
						}
						break;
					case 1:
						if(v4) {
							bs4 |= 64;
						} else {
							bs4 &= -65;
						}
						break;
					case 2:
						if(v4) {
							bs4 |= 32;
						} else {
							bs4 &= -33;
						}
						break;
					case 3:
						if(v4) {
							bs4 |= 16;
						} else {
							bs4 &= -17;
						}
						break;
					case 4:
						if(v4) {
							bs4 |= 8;
						} else {
							bs4 &= -9;
						}
						break;
					case 5:
						if(v4) {
							bs4 |= 4;
						} else {
							bs4 &= -5;
						}
						break;
					case 6:
						if(v4) {
							bs4 |= 2;
						} else {
							bs4 &= -3;
						}
						break;
					case 7:
						if(v4) {
							bs4 |= 1;
						} else {
							bs4 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs4;
				var this6 = 0;
				var bs5 = this6;
				var l5 = "00000".length;
				var _g16 = 0;
				var _g7 = l5;
				while(_g16 < _g7) {
					var i6 = _g16++;
					var no5 = "00000".charCodeAt(i6);
					if(no5 == null) {
						break;
					}
					var v5;
					switch(no5) {
					case 32:
						v5 = false;
						break;
					case 42:
						v5 = true;
						break;
					case 48:
						v5 = false;
						break;
					case 49:
						v5 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i6)));
					}
					switch(i6 - (l5 - 8)) {
					case 0:
						if(v5) {
							bs5 |= 128;
						} else {
							bs5 &= -129;
						}
						break;
					case 1:
						if(v5) {
							bs5 |= 64;
						} else {
							bs5 &= -65;
						}
						break;
					case 2:
						if(v5) {
							bs5 |= 32;
						} else {
							bs5 &= -33;
						}
						break;
					case 3:
						if(v5) {
							bs5 |= 16;
						} else {
							bs5 &= -17;
						}
						break;
					case 4:
						if(v5) {
							bs5 |= 8;
						} else {
							bs5 &= -9;
						}
						break;
					case 5:
						if(v5) {
							bs5 |= 4;
						} else {
							bs5 &= -5;
						}
						break;
					case 6:
						if(v5) {
							bs5 |= 2;
						} else {
							bs5 &= -3;
						}
						break;
					case 7:
						if(v5) {
							bs5 |= 1;
						} else {
							bs5 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs5;
				var this7 = 0;
				var bs6 = this7;
				var l6 = "00000".length;
				var _g17 = 0;
				var _g8 = l6;
				while(_g17 < _g8) {
					var i7 = _g17++;
					var no6 = "00000".charCodeAt(i7);
					if(no6 == null) {
						break;
					}
					var v6;
					switch(no6) {
					case 32:
						v6 = false;
						break;
					case 42:
						v6 = true;
						break;
					case 48:
						v6 = false;
						break;
					case 49:
						v6 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i7)));
					}
					switch(i7 - (l6 - 8)) {
					case 0:
						if(v6) {
							bs6 |= 128;
						} else {
							bs6 &= -129;
						}
						break;
					case 1:
						if(v6) {
							bs6 |= 64;
						} else {
							bs6 &= -65;
						}
						break;
					case 2:
						if(v6) {
							bs6 |= 32;
						} else {
							bs6 &= -33;
						}
						break;
					case 3:
						if(v6) {
							bs6 |= 16;
						} else {
							bs6 &= -17;
						}
						break;
					case 4:
						if(v6) {
							bs6 |= 8;
						} else {
							bs6 &= -9;
						}
						break;
					case 5:
						if(v6) {
							bs6 |= 4;
						} else {
							bs6 &= -5;
						}
						break;
					case 6:
						if(v6) {
							bs6 |= 2;
						} else {
							bs6 &= -3;
						}
						break;
					case 7:
						if(v6) {
							bs6 |= 1;
						} else {
							bs6 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs6;
				break;
			case 33:
				var this8 = 0;
				var bs7 = this8;
				var l7 = "  *  ".length;
				var _g18 = 0;
				var _g9 = l7;
				while(_g18 < _g9) {
					var i8 = _g18++;
					var no7 = "  *  ".charCodeAt(i8);
					if(no7 == null) {
						break;
					}
					var v7;
					switch(no7) {
					case 32:
						v7 = false;
						break;
					case 42:
						v7 = true;
						break;
					case 48:
						v7 = false;
						break;
					case 49:
						v7 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i8)));
					}
					switch(i8 - (l7 - 8)) {
					case 0:
						if(v7) {
							bs7 |= 128;
						} else {
							bs7 &= -129;
						}
						break;
					case 1:
						if(v7) {
							bs7 |= 64;
						} else {
							bs7 &= -65;
						}
						break;
					case 2:
						if(v7) {
							bs7 |= 32;
						} else {
							bs7 &= -33;
						}
						break;
					case 3:
						if(v7) {
							bs7 |= 16;
						} else {
							bs7 &= -17;
						}
						break;
					case 4:
						if(v7) {
							bs7 |= 8;
						} else {
							bs7 &= -9;
						}
						break;
					case 5:
						if(v7) {
							bs7 |= 4;
						} else {
							bs7 &= -5;
						}
						break;
					case 6:
						if(v7) {
							bs7 |= 2;
						} else {
							bs7 &= -3;
						}
						break;
					case 7:
						if(v7) {
							bs7 |= 1;
						} else {
							bs7 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs7;
				var this9 = 0;
				var bs8 = this9;
				var l8 = "  *  ".length;
				var _g19 = 0;
				var _g10 = l8;
				while(_g19 < _g10) {
					var i9 = _g19++;
					var no8 = "  *  ".charCodeAt(i9);
					if(no8 == null) {
						break;
					}
					var v8;
					switch(no8) {
					case 32:
						v8 = false;
						break;
					case 42:
						v8 = true;
						break;
					case 48:
						v8 = false;
						break;
					case 49:
						v8 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i9)));
					}
					switch(i9 - (l8 - 8)) {
					case 0:
						if(v8) {
							bs8 |= 128;
						} else {
							bs8 &= -129;
						}
						break;
					case 1:
						if(v8) {
							bs8 |= 64;
						} else {
							bs8 &= -65;
						}
						break;
					case 2:
						if(v8) {
							bs8 |= 32;
						} else {
							bs8 &= -33;
						}
						break;
					case 3:
						if(v8) {
							bs8 |= 16;
						} else {
							bs8 &= -17;
						}
						break;
					case 4:
						if(v8) {
							bs8 |= 8;
						} else {
							bs8 &= -9;
						}
						break;
					case 5:
						if(v8) {
							bs8 |= 4;
						} else {
							bs8 &= -5;
						}
						break;
					case 6:
						if(v8) {
							bs8 |= 2;
						} else {
							bs8 &= -3;
						}
						break;
					case 7:
						if(v8) {
							bs8 |= 1;
						} else {
							bs8 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs8;
				var this10 = 0;
				var bs9 = this10;
				var l9 = "  *  ".length;
				var _g110 = 0;
				var _g20 = l9;
				while(_g110 < _g20) {
					var i10 = _g110++;
					var no9 = "  *  ".charCodeAt(i10);
					if(no9 == null) {
						break;
					}
					var v9;
					switch(no9) {
					case 32:
						v9 = false;
						break;
					case 42:
						v9 = true;
						break;
					case 48:
						v9 = false;
						break;
					case 49:
						v9 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i10)));
					}
					switch(i10 - (l9 - 8)) {
					case 0:
						if(v9) {
							bs9 |= 128;
						} else {
							bs9 &= -129;
						}
						break;
					case 1:
						if(v9) {
							bs9 |= 64;
						} else {
							bs9 &= -65;
						}
						break;
					case 2:
						if(v9) {
							bs9 |= 32;
						} else {
							bs9 &= -33;
						}
						break;
					case 3:
						if(v9) {
							bs9 |= 16;
						} else {
							bs9 &= -17;
						}
						break;
					case 4:
						if(v9) {
							bs9 |= 8;
						} else {
							bs9 &= -9;
						}
						break;
					case 5:
						if(v9) {
							bs9 |= 4;
						} else {
							bs9 &= -5;
						}
						break;
					case 6:
						if(v9) {
							bs9 |= 2;
						} else {
							bs9 &= -3;
						}
						break;
					case 7:
						if(v9) {
							bs9 |= 1;
						} else {
							bs9 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs9;
				var this11 = 0;
				var bs10 = this11;
				var l10 = "  *  ".length;
				var _g111 = 0;
				var _g21 = l10;
				while(_g111 < _g21) {
					var i11 = _g111++;
					var no10 = "  *  ".charCodeAt(i11);
					if(no10 == null) {
						break;
					}
					var v10;
					switch(no10) {
					case 32:
						v10 = false;
						break;
					case 42:
						v10 = true;
						break;
					case 48:
						v10 = false;
						break;
					case 49:
						v10 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i11)));
					}
					switch(i11 - (l10 - 8)) {
					case 0:
						if(v10) {
							bs10 |= 128;
						} else {
							bs10 &= -129;
						}
						break;
					case 1:
						if(v10) {
							bs10 |= 64;
						} else {
							bs10 &= -65;
						}
						break;
					case 2:
						if(v10) {
							bs10 |= 32;
						} else {
							bs10 &= -33;
						}
						break;
					case 3:
						if(v10) {
							bs10 |= 16;
						} else {
							bs10 &= -17;
						}
						break;
					case 4:
						if(v10) {
							bs10 |= 8;
						} else {
							bs10 &= -9;
						}
						break;
					case 5:
						if(v10) {
							bs10 |= 4;
						} else {
							bs10 &= -5;
						}
						break;
					case 6:
						if(v10) {
							bs10 |= 2;
						} else {
							bs10 &= -3;
						}
						break;
					case 7:
						if(v10) {
							bs10 |= 1;
						} else {
							bs10 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs10;
				var this12 = 0;
				var bs11 = this12;
				var l11 = "     ".length;
				var _g112 = 0;
				var _g22 = l11;
				while(_g112 < _g22) {
					var i12 = _g112++;
					var no11 = "     ".charCodeAt(i12);
					if(no11 == null) {
						break;
					}
					var v11;
					switch(no11) {
					case 32:
						v11 = false;
						break;
					case 42:
						v11 = true;
						break;
					case 48:
						v11 = false;
						break;
					case 49:
						v11 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i12)));
					}
					switch(i12 - (l11 - 8)) {
					case 0:
						if(v11) {
							bs11 |= 128;
						} else {
							bs11 &= -129;
						}
						break;
					case 1:
						if(v11) {
							bs11 |= 64;
						} else {
							bs11 &= -65;
						}
						break;
					case 2:
						if(v11) {
							bs11 |= 32;
						} else {
							bs11 &= -33;
						}
						break;
					case 3:
						if(v11) {
							bs11 |= 16;
						} else {
							bs11 &= -17;
						}
						break;
					case 4:
						if(v11) {
							bs11 |= 8;
						} else {
							bs11 &= -9;
						}
						break;
					case 5:
						if(v11) {
							bs11 |= 4;
						} else {
							bs11 &= -5;
						}
						break;
					case 6:
						if(v11) {
							bs11 |= 2;
						} else {
							bs11 &= -3;
						}
						break;
					case 7:
						if(v11) {
							bs11 |= 1;
						} else {
							bs11 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs11;
				var this13 = 0;
				var bs12 = this13;
				var l12 = "  *  ".length;
				var _g113 = 0;
				var _g23 = l12;
				while(_g113 < _g23) {
					var i13 = _g113++;
					var no12 = "  *  ".charCodeAt(i13);
					if(no12 == null) {
						break;
					}
					var v12;
					switch(no12) {
					case 32:
						v12 = false;
						break;
					case 42:
						v12 = true;
						break;
					case 48:
						v12 = false;
						break;
					case 49:
						v12 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i13)));
					}
					switch(i13 - (l12 - 8)) {
					case 0:
						if(v12) {
							bs12 |= 128;
						} else {
							bs12 &= -129;
						}
						break;
					case 1:
						if(v12) {
							bs12 |= 64;
						} else {
							bs12 &= -65;
						}
						break;
					case 2:
						if(v12) {
							bs12 |= 32;
						} else {
							bs12 &= -33;
						}
						break;
					case 3:
						if(v12) {
							bs12 |= 16;
						} else {
							bs12 &= -17;
						}
						break;
					case 4:
						if(v12) {
							bs12 |= 8;
						} else {
							bs12 &= -9;
						}
						break;
					case 5:
						if(v12) {
							bs12 |= 4;
						} else {
							bs12 &= -5;
						}
						break;
					case 6:
						if(v12) {
							bs12 |= 2;
						} else {
							bs12 &= -3;
						}
						break;
					case 7:
						if(v12) {
							bs12 |= 1;
						} else {
							bs12 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs12;
				var this14 = 0;
				var bs13 = this14;
				var l13 = "     ".length;
				var _g114 = 0;
				var _g24 = l13;
				while(_g114 < _g24) {
					var i14 = _g114++;
					var no13 = "     ".charCodeAt(i14);
					if(no13 == null) {
						break;
					}
					var v13;
					switch(no13) {
					case 32:
						v13 = false;
						break;
					case 42:
						v13 = true;
						break;
					case 48:
						v13 = false;
						break;
					case 49:
						v13 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i14)));
					}
					switch(i14 - (l13 - 8)) {
					case 0:
						if(v13) {
							bs13 |= 128;
						} else {
							bs13 &= -129;
						}
						break;
					case 1:
						if(v13) {
							bs13 |= 64;
						} else {
							bs13 &= -65;
						}
						break;
					case 2:
						if(v13) {
							bs13 |= 32;
						} else {
							bs13 &= -33;
						}
						break;
					case 3:
						if(v13) {
							bs13 |= 16;
						} else {
							bs13 &= -17;
						}
						break;
					case 4:
						if(v13) {
							bs13 |= 8;
						} else {
							bs13 &= -9;
						}
						break;
					case 5:
						if(v13) {
							bs13 |= 4;
						} else {
							bs13 &= -5;
						}
						break;
					case 6:
						if(v13) {
							bs13 |= 2;
						} else {
							bs13 &= -3;
						}
						break;
					case 7:
						if(v13) {
							bs13 |= 1;
						} else {
							bs13 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs13;
				break;
			case 34:
				var this15 = 0;
				var bs14 = this15;
				var l14 = "     ".length;
				var _g115 = 0;
				var _g25 = l14;
				while(_g115 < _g25) {
					var i15 = _g115++;
					var no14 = "     ".charCodeAt(i15);
					if(no14 == null) {
						break;
					}
					var v14;
					switch(no14) {
					case 32:
						v14 = false;
						break;
					case 42:
						v14 = true;
						break;
					case 48:
						v14 = false;
						break;
					case 49:
						v14 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i15)));
					}
					switch(i15 - (l14 - 8)) {
					case 0:
						if(v14) {
							bs14 |= 128;
						} else {
							bs14 &= -129;
						}
						break;
					case 1:
						if(v14) {
							bs14 |= 64;
						} else {
							bs14 &= -65;
						}
						break;
					case 2:
						if(v14) {
							bs14 |= 32;
						} else {
							bs14 &= -33;
						}
						break;
					case 3:
						if(v14) {
							bs14 |= 16;
						} else {
							bs14 &= -17;
						}
						break;
					case 4:
						if(v14) {
							bs14 |= 8;
						} else {
							bs14 &= -9;
						}
						break;
					case 5:
						if(v14) {
							bs14 |= 4;
						} else {
							bs14 &= -5;
						}
						break;
					case 6:
						if(v14) {
							bs14 |= 2;
						} else {
							bs14 &= -3;
						}
						break;
					case 7:
						if(v14) {
							bs14 |= 1;
						} else {
							bs14 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs14;
				var this16 = 0;
				var bs15 = this16;
				var l15 = " * * ".length;
				var _g116 = 0;
				var _g26 = l15;
				while(_g116 < _g26) {
					var i16 = _g116++;
					var no15 = " * * ".charCodeAt(i16);
					if(no15 == null) {
						break;
					}
					var v15;
					switch(no15) {
					case 32:
						v15 = false;
						break;
					case 42:
						v15 = true;
						break;
					case 48:
						v15 = false;
						break;
					case 49:
						v15 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i16)));
					}
					switch(i16 - (l15 - 8)) {
					case 0:
						if(v15) {
							bs15 |= 128;
						} else {
							bs15 &= -129;
						}
						break;
					case 1:
						if(v15) {
							bs15 |= 64;
						} else {
							bs15 &= -65;
						}
						break;
					case 2:
						if(v15) {
							bs15 |= 32;
						} else {
							bs15 &= -33;
						}
						break;
					case 3:
						if(v15) {
							bs15 |= 16;
						} else {
							bs15 &= -17;
						}
						break;
					case 4:
						if(v15) {
							bs15 |= 8;
						} else {
							bs15 &= -9;
						}
						break;
					case 5:
						if(v15) {
							bs15 |= 4;
						} else {
							bs15 &= -5;
						}
						break;
					case 6:
						if(v15) {
							bs15 |= 2;
						} else {
							bs15 &= -3;
						}
						break;
					case 7:
						if(v15) {
							bs15 |= 1;
						} else {
							bs15 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs15;
				var this17 = 0;
				var bs16 = this17;
				var l16 = " * * ".length;
				var _g117 = 0;
				var _g27 = l16;
				while(_g117 < _g27) {
					var i17 = _g117++;
					var no16 = " * * ".charCodeAt(i17);
					if(no16 == null) {
						break;
					}
					var v16;
					switch(no16) {
					case 32:
						v16 = false;
						break;
					case 42:
						v16 = true;
						break;
					case 48:
						v16 = false;
						break;
					case 49:
						v16 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i17)));
					}
					switch(i17 - (l16 - 8)) {
					case 0:
						if(v16) {
							bs16 |= 128;
						} else {
							bs16 &= -129;
						}
						break;
					case 1:
						if(v16) {
							bs16 |= 64;
						} else {
							bs16 &= -65;
						}
						break;
					case 2:
						if(v16) {
							bs16 |= 32;
						} else {
							bs16 &= -33;
						}
						break;
					case 3:
						if(v16) {
							bs16 |= 16;
						} else {
							bs16 &= -17;
						}
						break;
					case 4:
						if(v16) {
							bs16 |= 8;
						} else {
							bs16 &= -9;
						}
						break;
					case 5:
						if(v16) {
							bs16 |= 4;
						} else {
							bs16 &= -5;
						}
						break;
					case 6:
						if(v16) {
							bs16 |= 2;
						} else {
							bs16 &= -3;
						}
						break;
					case 7:
						if(v16) {
							bs16 |= 1;
						} else {
							bs16 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs16;
				var this18 = 0;
				var bs17 = this18;
				var l17 = " * * ".length;
				var _g118 = 0;
				var _g28 = l17;
				while(_g118 < _g28) {
					var i18 = _g118++;
					var no17 = " * * ".charCodeAt(i18);
					if(no17 == null) {
						break;
					}
					var v17;
					switch(no17) {
					case 32:
						v17 = false;
						break;
					case 42:
						v17 = true;
						break;
					case 48:
						v17 = false;
						break;
					case 49:
						v17 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i18)));
					}
					switch(i18 - (l17 - 8)) {
					case 0:
						if(v17) {
							bs17 |= 128;
						} else {
							bs17 &= -129;
						}
						break;
					case 1:
						if(v17) {
							bs17 |= 64;
						} else {
							bs17 &= -65;
						}
						break;
					case 2:
						if(v17) {
							bs17 |= 32;
						} else {
							bs17 &= -33;
						}
						break;
					case 3:
						if(v17) {
							bs17 |= 16;
						} else {
							bs17 &= -17;
						}
						break;
					case 4:
						if(v17) {
							bs17 |= 8;
						} else {
							bs17 &= -9;
						}
						break;
					case 5:
						if(v17) {
							bs17 |= 4;
						} else {
							bs17 &= -5;
						}
						break;
					case 6:
						if(v17) {
							bs17 |= 2;
						} else {
							bs17 &= -3;
						}
						break;
					case 7:
						if(v17) {
							bs17 |= 1;
						} else {
							bs17 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs17;
				var this19 = 0;
				var bs18 = this19;
				var l18 = "     ".length;
				var _g119 = 0;
				var _g29 = l18;
				while(_g119 < _g29) {
					var i19 = _g119++;
					var no18 = "     ".charCodeAt(i19);
					if(no18 == null) {
						break;
					}
					var v18;
					switch(no18) {
					case 32:
						v18 = false;
						break;
					case 42:
						v18 = true;
						break;
					case 48:
						v18 = false;
						break;
					case 49:
						v18 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i19)));
					}
					switch(i19 - (l18 - 8)) {
					case 0:
						if(v18) {
							bs18 |= 128;
						} else {
							bs18 &= -129;
						}
						break;
					case 1:
						if(v18) {
							bs18 |= 64;
						} else {
							bs18 &= -65;
						}
						break;
					case 2:
						if(v18) {
							bs18 |= 32;
						} else {
							bs18 &= -33;
						}
						break;
					case 3:
						if(v18) {
							bs18 |= 16;
						} else {
							bs18 &= -17;
						}
						break;
					case 4:
						if(v18) {
							bs18 |= 8;
						} else {
							bs18 &= -9;
						}
						break;
					case 5:
						if(v18) {
							bs18 |= 4;
						} else {
							bs18 &= -5;
						}
						break;
					case 6:
						if(v18) {
							bs18 |= 2;
						} else {
							bs18 &= -3;
						}
						break;
					case 7:
						if(v18) {
							bs18 |= 1;
						} else {
							bs18 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs18;
				var this20 = 0;
				var bs19 = this20;
				var l19 = "     ".length;
				var _g120 = 0;
				var _g30 = l19;
				while(_g120 < _g30) {
					var i20 = _g120++;
					var no19 = "     ".charCodeAt(i20);
					if(no19 == null) {
						break;
					}
					var v19;
					switch(no19) {
					case 32:
						v19 = false;
						break;
					case 42:
						v19 = true;
						break;
					case 48:
						v19 = false;
						break;
					case 49:
						v19 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i20)));
					}
					switch(i20 - (l19 - 8)) {
					case 0:
						if(v19) {
							bs19 |= 128;
						} else {
							bs19 &= -129;
						}
						break;
					case 1:
						if(v19) {
							bs19 |= 64;
						} else {
							bs19 &= -65;
						}
						break;
					case 2:
						if(v19) {
							bs19 |= 32;
						} else {
							bs19 &= -33;
						}
						break;
					case 3:
						if(v19) {
							bs19 |= 16;
						} else {
							bs19 &= -17;
						}
						break;
					case 4:
						if(v19) {
							bs19 |= 8;
						} else {
							bs19 &= -9;
						}
						break;
					case 5:
						if(v19) {
							bs19 |= 4;
						} else {
							bs19 &= -5;
						}
						break;
					case 6:
						if(v19) {
							bs19 |= 2;
						} else {
							bs19 &= -3;
						}
						break;
					case 7:
						if(v19) {
							bs19 |= 1;
						} else {
							bs19 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs19;
				var this21 = 0;
				var bs20 = this21;
				var l20 = "     ".length;
				var _g121 = 0;
				var _g31 = l20;
				while(_g121 < _g31) {
					var i21 = _g121++;
					var no20 = "     ".charCodeAt(i21);
					if(no20 == null) {
						break;
					}
					var v20;
					switch(no20) {
					case 32:
						v20 = false;
						break;
					case 42:
						v20 = true;
						break;
					case 48:
						v20 = false;
						break;
					case 49:
						v20 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i21)));
					}
					switch(i21 - (l20 - 8)) {
					case 0:
						if(v20) {
							bs20 |= 128;
						} else {
							bs20 &= -129;
						}
						break;
					case 1:
						if(v20) {
							bs20 |= 64;
						} else {
							bs20 &= -65;
						}
						break;
					case 2:
						if(v20) {
							bs20 |= 32;
						} else {
							bs20 &= -33;
						}
						break;
					case 3:
						if(v20) {
							bs20 |= 16;
						} else {
							bs20 &= -17;
						}
						break;
					case 4:
						if(v20) {
							bs20 |= 8;
						} else {
							bs20 &= -9;
						}
						break;
					case 5:
						if(v20) {
							bs20 |= 4;
						} else {
							bs20 &= -5;
						}
						break;
					case 6:
						if(v20) {
							bs20 |= 2;
						} else {
							bs20 &= -3;
						}
						break;
					case 7:
						if(v20) {
							bs20 |= 1;
						} else {
							bs20 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs20;
				break;
			case 35:
				var this22 = 0;
				var bs21 = this22;
				var l21 = " * * ".length;
				var _g122 = 0;
				var _g32 = l21;
				while(_g122 < _g32) {
					var i22 = _g122++;
					var no21 = " * * ".charCodeAt(i22);
					if(no21 == null) {
						break;
					}
					var v21;
					switch(no21) {
					case 32:
						v21 = false;
						break;
					case 42:
						v21 = true;
						break;
					case 48:
						v21 = false;
						break;
					case 49:
						v21 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i22)));
					}
					switch(i22 - (l21 - 8)) {
					case 0:
						if(v21) {
							bs21 |= 128;
						} else {
							bs21 &= -129;
						}
						break;
					case 1:
						if(v21) {
							bs21 |= 64;
						} else {
							bs21 &= -65;
						}
						break;
					case 2:
						if(v21) {
							bs21 |= 32;
						} else {
							bs21 &= -33;
						}
						break;
					case 3:
						if(v21) {
							bs21 |= 16;
						} else {
							bs21 &= -17;
						}
						break;
					case 4:
						if(v21) {
							bs21 |= 8;
						} else {
							bs21 &= -9;
						}
						break;
					case 5:
						if(v21) {
							bs21 |= 4;
						} else {
							bs21 &= -5;
						}
						break;
					case 6:
						if(v21) {
							bs21 |= 2;
						} else {
							bs21 &= -3;
						}
						break;
					case 7:
						if(v21) {
							bs21 |= 1;
						} else {
							bs21 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs21;
				var this23 = 0;
				var bs22 = this23;
				var l22 = " * * ".length;
				var _g123 = 0;
				var _g33 = l22;
				while(_g123 < _g33) {
					var i23 = _g123++;
					var no22 = " * * ".charCodeAt(i23);
					if(no22 == null) {
						break;
					}
					var v22;
					switch(no22) {
					case 32:
						v22 = false;
						break;
					case 42:
						v22 = true;
						break;
					case 48:
						v22 = false;
						break;
					case 49:
						v22 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i23)));
					}
					switch(i23 - (l22 - 8)) {
					case 0:
						if(v22) {
							bs22 |= 128;
						} else {
							bs22 &= -129;
						}
						break;
					case 1:
						if(v22) {
							bs22 |= 64;
						} else {
							bs22 &= -65;
						}
						break;
					case 2:
						if(v22) {
							bs22 |= 32;
						} else {
							bs22 &= -33;
						}
						break;
					case 3:
						if(v22) {
							bs22 |= 16;
						} else {
							bs22 &= -17;
						}
						break;
					case 4:
						if(v22) {
							bs22 |= 8;
						} else {
							bs22 &= -9;
						}
						break;
					case 5:
						if(v22) {
							bs22 |= 4;
						} else {
							bs22 &= -5;
						}
						break;
					case 6:
						if(v22) {
							bs22 |= 2;
						} else {
							bs22 &= -3;
						}
						break;
					case 7:
						if(v22) {
							bs22 |= 1;
						} else {
							bs22 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs22;
				var this24 = 0;
				var bs23 = this24;
				var l23 = "*****".length;
				var _g124 = 0;
				var _g34 = l23;
				while(_g124 < _g34) {
					var i24 = _g124++;
					var no23 = "*****".charCodeAt(i24);
					if(no23 == null) {
						break;
					}
					var v23;
					switch(no23) {
					case 32:
						v23 = false;
						break;
					case 42:
						v23 = true;
						break;
					case 48:
						v23 = false;
						break;
					case 49:
						v23 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i24)));
					}
					switch(i24 - (l23 - 8)) {
					case 0:
						if(v23) {
							bs23 |= 128;
						} else {
							bs23 &= -129;
						}
						break;
					case 1:
						if(v23) {
							bs23 |= 64;
						} else {
							bs23 &= -65;
						}
						break;
					case 2:
						if(v23) {
							bs23 |= 32;
						} else {
							bs23 &= -33;
						}
						break;
					case 3:
						if(v23) {
							bs23 |= 16;
						} else {
							bs23 &= -17;
						}
						break;
					case 4:
						if(v23) {
							bs23 |= 8;
						} else {
							bs23 &= -9;
						}
						break;
					case 5:
						if(v23) {
							bs23 |= 4;
						} else {
							bs23 &= -5;
						}
						break;
					case 6:
						if(v23) {
							bs23 |= 2;
						} else {
							bs23 &= -3;
						}
						break;
					case 7:
						if(v23) {
							bs23 |= 1;
						} else {
							bs23 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs23;
				var this25 = 0;
				var bs24 = this25;
				var l24 = " * * ".length;
				var _g125 = 0;
				var _g35 = l24;
				while(_g125 < _g35) {
					var i25 = _g125++;
					var no24 = " * * ".charCodeAt(i25);
					if(no24 == null) {
						break;
					}
					var v24;
					switch(no24) {
					case 32:
						v24 = false;
						break;
					case 42:
						v24 = true;
						break;
					case 48:
						v24 = false;
						break;
					case 49:
						v24 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i25)));
					}
					switch(i25 - (l24 - 8)) {
					case 0:
						if(v24) {
							bs24 |= 128;
						} else {
							bs24 &= -129;
						}
						break;
					case 1:
						if(v24) {
							bs24 |= 64;
						} else {
							bs24 &= -65;
						}
						break;
					case 2:
						if(v24) {
							bs24 |= 32;
						} else {
							bs24 &= -33;
						}
						break;
					case 3:
						if(v24) {
							bs24 |= 16;
						} else {
							bs24 &= -17;
						}
						break;
					case 4:
						if(v24) {
							bs24 |= 8;
						} else {
							bs24 &= -9;
						}
						break;
					case 5:
						if(v24) {
							bs24 |= 4;
						} else {
							bs24 &= -5;
						}
						break;
					case 6:
						if(v24) {
							bs24 |= 2;
						} else {
							bs24 &= -3;
						}
						break;
					case 7:
						if(v24) {
							bs24 |= 1;
						} else {
							bs24 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs24;
				var this26 = 0;
				var bs25 = this26;
				var l25 = "*****".length;
				var _g126 = 0;
				var _g36 = l25;
				while(_g126 < _g36) {
					var i26 = _g126++;
					var no25 = "*****".charCodeAt(i26);
					if(no25 == null) {
						break;
					}
					var v25;
					switch(no25) {
					case 32:
						v25 = false;
						break;
					case 42:
						v25 = true;
						break;
					case 48:
						v25 = false;
						break;
					case 49:
						v25 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i26)));
					}
					switch(i26 - (l25 - 8)) {
					case 0:
						if(v25) {
							bs25 |= 128;
						} else {
							bs25 &= -129;
						}
						break;
					case 1:
						if(v25) {
							bs25 |= 64;
						} else {
							bs25 &= -65;
						}
						break;
					case 2:
						if(v25) {
							bs25 |= 32;
						} else {
							bs25 &= -33;
						}
						break;
					case 3:
						if(v25) {
							bs25 |= 16;
						} else {
							bs25 &= -17;
						}
						break;
					case 4:
						if(v25) {
							bs25 |= 8;
						} else {
							bs25 &= -9;
						}
						break;
					case 5:
						if(v25) {
							bs25 |= 4;
						} else {
							bs25 &= -5;
						}
						break;
					case 6:
						if(v25) {
							bs25 |= 2;
						} else {
							bs25 &= -3;
						}
						break;
					case 7:
						if(v25) {
							bs25 |= 1;
						} else {
							bs25 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs25;
				var this27 = 0;
				var bs26 = this27;
				var l26 = " * * ".length;
				var _g127 = 0;
				var _g37 = l26;
				while(_g127 < _g37) {
					var i27 = _g127++;
					var no26 = " * * ".charCodeAt(i27);
					if(no26 == null) {
						break;
					}
					var v26;
					switch(no26) {
					case 32:
						v26 = false;
						break;
					case 42:
						v26 = true;
						break;
					case 48:
						v26 = false;
						break;
					case 49:
						v26 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i27)));
					}
					switch(i27 - (l26 - 8)) {
					case 0:
						if(v26) {
							bs26 |= 128;
						} else {
							bs26 &= -129;
						}
						break;
					case 1:
						if(v26) {
							bs26 |= 64;
						} else {
							bs26 &= -65;
						}
						break;
					case 2:
						if(v26) {
							bs26 |= 32;
						} else {
							bs26 &= -33;
						}
						break;
					case 3:
						if(v26) {
							bs26 |= 16;
						} else {
							bs26 &= -17;
						}
						break;
					case 4:
						if(v26) {
							bs26 |= 8;
						} else {
							bs26 &= -9;
						}
						break;
					case 5:
						if(v26) {
							bs26 |= 4;
						} else {
							bs26 &= -5;
						}
						break;
					case 6:
						if(v26) {
							bs26 |= 2;
						} else {
							bs26 &= -3;
						}
						break;
					case 7:
						if(v26) {
							bs26 |= 1;
						} else {
							bs26 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs26;
				var this28 = 0;
				var bs27 = this28;
				var l27 = " * * ".length;
				var _g128 = 0;
				var _g38 = l27;
				while(_g128 < _g38) {
					var i28 = _g128++;
					var no27 = " * * ".charCodeAt(i28);
					if(no27 == null) {
						break;
					}
					var v27;
					switch(no27) {
					case 32:
						v27 = false;
						break;
					case 42:
						v27 = true;
						break;
					case 48:
						v27 = false;
						break;
					case 49:
						v27 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i28)));
					}
					switch(i28 - (l27 - 8)) {
					case 0:
						if(v27) {
							bs27 |= 128;
						} else {
							bs27 &= -129;
						}
						break;
					case 1:
						if(v27) {
							bs27 |= 64;
						} else {
							bs27 &= -65;
						}
						break;
					case 2:
						if(v27) {
							bs27 |= 32;
						} else {
							bs27 &= -33;
						}
						break;
					case 3:
						if(v27) {
							bs27 |= 16;
						} else {
							bs27 &= -17;
						}
						break;
					case 4:
						if(v27) {
							bs27 |= 8;
						} else {
							bs27 &= -9;
						}
						break;
					case 5:
						if(v27) {
							bs27 |= 4;
						} else {
							bs27 &= -5;
						}
						break;
					case 6:
						if(v27) {
							bs27 |= 2;
						} else {
							bs27 &= -3;
						}
						break;
					case 7:
						if(v27) {
							bs27 |= 1;
						} else {
							bs27 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs27;
				break;
			case 36:
				var this29 = 0;
				var bs28 = this29;
				var l28 = "  *  ".length;
				var _g129 = 0;
				var _g39 = l28;
				while(_g129 < _g39) {
					var i29 = _g129++;
					var no28 = "  *  ".charCodeAt(i29);
					if(no28 == null) {
						break;
					}
					var v28;
					switch(no28) {
					case 32:
						v28 = false;
						break;
					case 42:
						v28 = true;
						break;
					case 48:
						v28 = false;
						break;
					case 49:
						v28 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i29)));
					}
					switch(i29 - (l28 - 8)) {
					case 0:
						if(v28) {
							bs28 |= 128;
						} else {
							bs28 &= -129;
						}
						break;
					case 1:
						if(v28) {
							bs28 |= 64;
						} else {
							bs28 &= -65;
						}
						break;
					case 2:
						if(v28) {
							bs28 |= 32;
						} else {
							bs28 &= -33;
						}
						break;
					case 3:
						if(v28) {
							bs28 |= 16;
						} else {
							bs28 &= -17;
						}
						break;
					case 4:
						if(v28) {
							bs28 |= 8;
						} else {
							bs28 &= -9;
						}
						break;
					case 5:
						if(v28) {
							bs28 |= 4;
						} else {
							bs28 &= -5;
						}
						break;
					case 6:
						if(v28) {
							bs28 |= 2;
						} else {
							bs28 &= -3;
						}
						break;
					case 7:
						if(v28) {
							bs28 |= 1;
						} else {
							bs28 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs28;
				var this30 = 0;
				var bs29 = this30;
				var l29 = " ****".length;
				var _g130 = 0;
				var _g40 = l29;
				while(_g130 < _g40) {
					var i30 = _g130++;
					var no29 = " ****".charCodeAt(i30);
					if(no29 == null) {
						break;
					}
					var v29;
					switch(no29) {
					case 32:
						v29 = false;
						break;
					case 42:
						v29 = true;
						break;
					case 48:
						v29 = false;
						break;
					case 49:
						v29 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i30)));
					}
					switch(i30 - (l29 - 8)) {
					case 0:
						if(v29) {
							bs29 |= 128;
						} else {
							bs29 &= -129;
						}
						break;
					case 1:
						if(v29) {
							bs29 |= 64;
						} else {
							bs29 &= -65;
						}
						break;
					case 2:
						if(v29) {
							bs29 |= 32;
						} else {
							bs29 &= -33;
						}
						break;
					case 3:
						if(v29) {
							bs29 |= 16;
						} else {
							bs29 &= -17;
						}
						break;
					case 4:
						if(v29) {
							bs29 |= 8;
						} else {
							bs29 &= -9;
						}
						break;
					case 5:
						if(v29) {
							bs29 |= 4;
						} else {
							bs29 &= -5;
						}
						break;
					case 6:
						if(v29) {
							bs29 |= 2;
						} else {
							bs29 &= -3;
						}
						break;
					case 7:
						if(v29) {
							bs29 |= 1;
						} else {
							bs29 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs29;
				var this31 = 0;
				var bs30 = this31;
				var l30 = "* *  ".length;
				var _g131 = 0;
				var _g41 = l30;
				while(_g131 < _g41) {
					var i31 = _g131++;
					var no30 = "* *  ".charCodeAt(i31);
					if(no30 == null) {
						break;
					}
					var v30;
					switch(no30) {
					case 32:
						v30 = false;
						break;
					case 42:
						v30 = true;
						break;
					case 48:
						v30 = false;
						break;
					case 49:
						v30 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i31)));
					}
					switch(i31 - (l30 - 8)) {
					case 0:
						if(v30) {
							bs30 |= 128;
						} else {
							bs30 &= -129;
						}
						break;
					case 1:
						if(v30) {
							bs30 |= 64;
						} else {
							bs30 &= -65;
						}
						break;
					case 2:
						if(v30) {
							bs30 |= 32;
						} else {
							bs30 &= -33;
						}
						break;
					case 3:
						if(v30) {
							bs30 |= 16;
						} else {
							bs30 &= -17;
						}
						break;
					case 4:
						if(v30) {
							bs30 |= 8;
						} else {
							bs30 &= -9;
						}
						break;
					case 5:
						if(v30) {
							bs30 |= 4;
						} else {
							bs30 &= -5;
						}
						break;
					case 6:
						if(v30) {
							bs30 |= 2;
						} else {
							bs30 &= -3;
						}
						break;
					case 7:
						if(v30) {
							bs30 |= 1;
						} else {
							bs30 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs30;
				var this32 = 0;
				var bs31 = this32;
				var l31 = " *** ".length;
				var _g132 = 0;
				var _g42 = l31;
				while(_g132 < _g42) {
					var i32 = _g132++;
					var no31 = " *** ".charCodeAt(i32);
					if(no31 == null) {
						break;
					}
					var v31;
					switch(no31) {
					case 32:
						v31 = false;
						break;
					case 42:
						v31 = true;
						break;
					case 48:
						v31 = false;
						break;
					case 49:
						v31 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i32)));
					}
					switch(i32 - (l31 - 8)) {
					case 0:
						if(v31) {
							bs31 |= 128;
						} else {
							bs31 &= -129;
						}
						break;
					case 1:
						if(v31) {
							bs31 |= 64;
						} else {
							bs31 &= -65;
						}
						break;
					case 2:
						if(v31) {
							bs31 |= 32;
						} else {
							bs31 &= -33;
						}
						break;
					case 3:
						if(v31) {
							bs31 |= 16;
						} else {
							bs31 &= -17;
						}
						break;
					case 4:
						if(v31) {
							bs31 |= 8;
						} else {
							bs31 &= -9;
						}
						break;
					case 5:
						if(v31) {
							bs31 |= 4;
						} else {
							bs31 &= -5;
						}
						break;
					case 6:
						if(v31) {
							bs31 |= 2;
						} else {
							bs31 &= -3;
						}
						break;
					case 7:
						if(v31) {
							bs31 |= 1;
						} else {
							bs31 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs31;
				var this33 = 0;
				var bs32 = this33;
				var l32 = "  * *".length;
				var _g133 = 0;
				var _g43 = l32;
				while(_g133 < _g43) {
					var i33 = _g133++;
					var no32 = "  * *".charCodeAt(i33);
					if(no32 == null) {
						break;
					}
					var v32;
					switch(no32) {
					case 32:
						v32 = false;
						break;
					case 42:
						v32 = true;
						break;
					case 48:
						v32 = false;
						break;
					case 49:
						v32 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  * *".charCodeAt(i33)));
					}
					switch(i33 - (l32 - 8)) {
					case 0:
						if(v32) {
							bs32 |= 128;
						} else {
							bs32 &= -129;
						}
						break;
					case 1:
						if(v32) {
							bs32 |= 64;
						} else {
							bs32 &= -65;
						}
						break;
					case 2:
						if(v32) {
							bs32 |= 32;
						} else {
							bs32 &= -33;
						}
						break;
					case 3:
						if(v32) {
							bs32 |= 16;
						} else {
							bs32 &= -17;
						}
						break;
					case 4:
						if(v32) {
							bs32 |= 8;
						} else {
							bs32 &= -9;
						}
						break;
					case 5:
						if(v32) {
							bs32 |= 4;
						} else {
							bs32 &= -5;
						}
						break;
					case 6:
						if(v32) {
							bs32 |= 2;
						} else {
							bs32 &= -3;
						}
						break;
					case 7:
						if(v32) {
							bs32 |= 1;
						} else {
							bs32 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs32;
				var this34 = 0;
				var bs33 = this34;
				var l33 = "**** ".length;
				var _g134 = 0;
				var _g44 = l33;
				while(_g134 < _g44) {
					var i34 = _g134++;
					var no33 = "**** ".charCodeAt(i34);
					if(no33 == null) {
						break;
					}
					var v33;
					switch(no33) {
					case 32:
						v33 = false;
						break;
					case 42:
						v33 = true;
						break;
					case 48:
						v33 = false;
						break;
					case 49:
						v33 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i34)));
					}
					switch(i34 - (l33 - 8)) {
					case 0:
						if(v33) {
							bs33 |= 128;
						} else {
							bs33 &= -129;
						}
						break;
					case 1:
						if(v33) {
							bs33 |= 64;
						} else {
							bs33 &= -65;
						}
						break;
					case 2:
						if(v33) {
							bs33 |= 32;
						} else {
							bs33 &= -33;
						}
						break;
					case 3:
						if(v33) {
							bs33 |= 16;
						} else {
							bs33 &= -17;
						}
						break;
					case 4:
						if(v33) {
							bs33 |= 8;
						} else {
							bs33 &= -9;
						}
						break;
					case 5:
						if(v33) {
							bs33 |= 4;
						} else {
							bs33 &= -5;
						}
						break;
					case 6:
						if(v33) {
							bs33 |= 2;
						} else {
							bs33 &= -3;
						}
						break;
					case 7:
						if(v33) {
							bs33 |= 1;
						} else {
							bs33 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs33;
				var this35 = 0;
				var bs34 = this35;
				var l34 = "  *  ".length;
				var _g135 = 0;
				var _g45 = l34;
				while(_g135 < _g45) {
					var i35 = _g135++;
					var no34 = "  *  ".charCodeAt(i35);
					if(no34 == null) {
						break;
					}
					var v34;
					switch(no34) {
					case 32:
						v34 = false;
						break;
					case 42:
						v34 = true;
						break;
					case 48:
						v34 = false;
						break;
					case 49:
						v34 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i35)));
					}
					switch(i35 - (l34 - 8)) {
					case 0:
						if(v34) {
							bs34 |= 128;
						} else {
							bs34 &= -129;
						}
						break;
					case 1:
						if(v34) {
							bs34 |= 64;
						} else {
							bs34 &= -65;
						}
						break;
					case 2:
						if(v34) {
							bs34 |= 32;
						} else {
							bs34 &= -33;
						}
						break;
					case 3:
						if(v34) {
							bs34 |= 16;
						} else {
							bs34 &= -17;
						}
						break;
					case 4:
						if(v34) {
							bs34 |= 8;
						} else {
							bs34 &= -9;
						}
						break;
					case 5:
						if(v34) {
							bs34 |= 4;
						} else {
							bs34 &= -5;
						}
						break;
					case 6:
						if(v34) {
							bs34 |= 2;
						} else {
							bs34 &= -3;
						}
						break;
					case 7:
						if(v34) {
							bs34 |= 1;
						} else {
							bs34 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs34;
				break;
			case 37:
				var this36 = 0;
				var bs35 = this36;
				var l35 = "**   ".length;
				var _g136 = 0;
				var _g46 = l35;
				while(_g136 < _g46) {
					var i36 = _g136++;
					var no35 = "**   ".charCodeAt(i36);
					if(no35 == null) {
						break;
					}
					var v35;
					switch(no35) {
					case 32:
						v35 = false;
						break;
					case 42:
						v35 = true;
						break;
					case 48:
						v35 = false;
						break;
					case 49:
						v35 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**   ".charCodeAt(i36)));
					}
					switch(i36 - (l35 - 8)) {
					case 0:
						if(v35) {
							bs35 |= 128;
						} else {
							bs35 &= -129;
						}
						break;
					case 1:
						if(v35) {
							bs35 |= 64;
						} else {
							bs35 &= -65;
						}
						break;
					case 2:
						if(v35) {
							bs35 |= 32;
						} else {
							bs35 &= -33;
						}
						break;
					case 3:
						if(v35) {
							bs35 |= 16;
						} else {
							bs35 &= -17;
						}
						break;
					case 4:
						if(v35) {
							bs35 |= 8;
						} else {
							bs35 &= -9;
						}
						break;
					case 5:
						if(v35) {
							bs35 |= 4;
						} else {
							bs35 &= -5;
						}
						break;
					case 6:
						if(v35) {
							bs35 |= 2;
						} else {
							bs35 &= -3;
						}
						break;
					case 7:
						if(v35) {
							bs35 |= 1;
						} else {
							bs35 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs35;
				var this37 = 0;
				var bs36 = this37;
				var l36 = "**  *".length;
				var _g137 = 0;
				var _g47 = l36;
				while(_g137 < _g47) {
					var i37 = _g137++;
					var no36 = "**  *".charCodeAt(i37);
					if(no36 == null) {
						break;
					}
					var v36;
					switch(no36) {
					case 32:
						v36 = false;
						break;
					case 42:
						v36 = true;
						break;
					case 48:
						v36 = false;
						break;
					case 49:
						v36 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i37)));
					}
					switch(i37 - (l36 - 8)) {
					case 0:
						if(v36) {
							bs36 |= 128;
						} else {
							bs36 &= -129;
						}
						break;
					case 1:
						if(v36) {
							bs36 |= 64;
						} else {
							bs36 &= -65;
						}
						break;
					case 2:
						if(v36) {
							bs36 |= 32;
						} else {
							bs36 &= -33;
						}
						break;
					case 3:
						if(v36) {
							bs36 |= 16;
						} else {
							bs36 &= -17;
						}
						break;
					case 4:
						if(v36) {
							bs36 |= 8;
						} else {
							bs36 &= -9;
						}
						break;
					case 5:
						if(v36) {
							bs36 |= 4;
						} else {
							bs36 &= -5;
						}
						break;
					case 6:
						if(v36) {
							bs36 |= 2;
						} else {
							bs36 &= -3;
						}
						break;
					case 7:
						if(v36) {
							bs36 |= 1;
						} else {
							bs36 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs36;
				var this38 = 0;
				var bs37 = this38;
				var l37 = "   * ".length;
				var _g138 = 0;
				var _g48 = l37;
				while(_g138 < _g48) {
					var i38 = _g138++;
					var no37 = "   * ".charCodeAt(i38);
					if(no37 == null) {
						break;
					}
					var v37;
					switch(no37) {
					case 32:
						v37 = false;
						break;
					case 42:
						v37 = true;
						break;
					case 48:
						v37 = false;
						break;
					case 49:
						v37 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i38)));
					}
					switch(i38 - (l37 - 8)) {
					case 0:
						if(v37) {
							bs37 |= 128;
						} else {
							bs37 &= -129;
						}
						break;
					case 1:
						if(v37) {
							bs37 |= 64;
						} else {
							bs37 &= -65;
						}
						break;
					case 2:
						if(v37) {
							bs37 |= 32;
						} else {
							bs37 &= -33;
						}
						break;
					case 3:
						if(v37) {
							bs37 |= 16;
						} else {
							bs37 &= -17;
						}
						break;
					case 4:
						if(v37) {
							bs37 |= 8;
						} else {
							bs37 &= -9;
						}
						break;
					case 5:
						if(v37) {
							bs37 |= 4;
						} else {
							bs37 &= -5;
						}
						break;
					case 6:
						if(v37) {
							bs37 |= 2;
						} else {
							bs37 &= -3;
						}
						break;
					case 7:
						if(v37) {
							bs37 |= 1;
						} else {
							bs37 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs37;
				var this39 = 0;
				var bs38 = this39;
				var l38 = "  *  ".length;
				var _g139 = 0;
				var _g49 = l38;
				while(_g139 < _g49) {
					var i39 = _g139++;
					var no38 = "  *  ".charCodeAt(i39);
					if(no38 == null) {
						break;
					}
					var v38;
					switch(no38) {
					case 32:
						v38 = false;
						break;
					case 42:
						v38 = true;
						break;
					case 48:
						v38 = false;
						break;
					case 49:
						v38 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i39)));
					}
					switch(i39 - (l38 - 8)) {
					case 0:
						if(v38) {
							bs38 |= 128;
						} else {
							bs38 &= -129;
						}
						break;
					case 1:
						if(v38) {
							bs38 |= 64;
						} else {
							bs38 &= -65;
						}
						break;
					case 2:
						if(v38) {
							bs38 |= 32;
						} else {
							bs38 &= -33;
						}
						break;
					case 3:
						if(v38) {
							bs38 |= 16;
						} else {
							bs38 &= -17;
						}
						break;
					case 4:
						if(v38) {
							bs38 |= 8;
						} else {
							bs38 &= -9;
						}
						break;
					case 5:
						if(v38) {
							bs38 |= 4;
						} else {
							bs38 &= -5;
						}
						break;
					case 6:
						if(v38) {
							bs38 |= 2;
						} else {
							bs38 &= -3;
						}
						break;
					case 7:
						if(v38) {
							bs38 |= 1;
						} else {
							bs38 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs38;
				var this40 = 0;
				var bs39 = this40;
				var l39 = " *   ".length;
				var _g140 = 0;
				var _g50 = l39;
				while(_g140 < _g50) {
					var i40 = _g140++;
					var no39 = " *   ".charCodeAt(i40);
					if(no39 == null) {
						break;
					}
					var v39;
					switch(no39) {
					case 32:
						v39 = false;
						break;
					case 42:
						v39 = true;
						break;
					case 48:
						v39 = false;
						break;
					case 49:
						v39 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i40)));
					}
					switch(i40 - (l39 - 8)) {
					case 0:
						if(v39) {
							bs39 |= 128;
						} else {
							bs39 &= -129;
						}
						break;
					case 1:
						if(v39) {
							bs39 |= 64;
						} else {
							bs39 &= -65;
						}
						break;
					case 2:
						if(v39) {
							bs39 |= 32;
						} else {
							bs39 &= -33;
						}
						break;
					case 3:
						if(v39) {
							bs39 |= 16;
						} else {
							bs39 &= -17;
						}
						break;
					case 4:
						if(v39) {
							bs39 |= 8;
						} else {
							bs39 &= -9;
						}
						break;
					case 5:
						if(v39) {
							bs39 |= 4;
						} else {
							bs39 &= -5;
						}
						break;
					case 6:
						if(v39) {
							bs39 |= 2;
						} else {
							bs39 &= -3;
						}
						break;
					case 7:
						if(v39) {
							bs39 |= 1;
						} else {
							bs39 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs39;
				var this41 = 0;
				var bs40 = this41;
				var l40 = "*  **".length;
				var _g141 = 0;
				var _g51 = l40;
				while(_g141 < _g51) {
					var i41 = _g141++;
					var no40 = "*  **".charCodeAt(i41);
					if(no40 == null) {
						break;
					}
					var v40;
					switch(no40) {
					case 32:
						v40 = false;
						break;
					case 42:
						v40 = true;
						break;
					case 48:
						v40 = false;
						break;
					case 49:
						v40 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  **".charCodeAt(i41)));
					}
					switch(i41 - (l40 - 8)) {
					case 0:
						if(v40) {
							bs40 |= 128;
						} else {
							bs40 &= -129;
						}
						break;
					case 1:
						if(v40) {
							bs40 |= 64;
						} else {
							bs40 &= -65;
						}
						break;
					case 2:
						if(v40) {
							bs40 |= 32;
						} else {
							bs40 &= -33;
						}
						break;
					case 3:
						if(v40) {
							bs40 |= 16;
						} else {
							bs40 &= -17;
						}
						break;
					case 4:
						if(v40) {
							bs40 |= 8;
						} else {
							bs40 &= -9;
						}
						break;
					case 5:
						if(v40) {
							bs40 |= 4;
						} else {
							bs40 &= -5;
						}
						break;
					case 6:
						if(v40) {
							bs40 |= 2;
						} else {
							bs40 &= -3;
						}
						break;
					case 7:
						if(v40) {
							bs40 |= 1;
						} else {
							bs40 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs40;
				var this42 = 0;
				var bs41 = this42;
				var l41 = "   **".length;
				var _g142 = 0;
				var _g52 = l41;
				while(_g142 < _g52) {
					var i42 = _g142++;
					var no41 = "   **".charCodeAt(i42);
					if(no41 == null) {
						break;
					}
					var v41;
					switch(no41) {
					case 32:
						v41 = false;
						break;
					case 42:
						v41 = true;
						break;
					case 48:
						v41 = false;
						break;
					case 49:
						v41 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   **".charCodeAt(i42)));
					}
					switch(i42 - (l41 - 8)) {
					case 0:
						if(v41) {
							bs41 |= 128;
						} else {
							bs41 &= -129;
						}
						break;
					case 1:
						if(v41) {
							bs41 |= 64;
						} else {
							bs41 &= -65;
						}
						break;
					case 2:
						if(v41) {
							bs41 |= 32;
						} else {
							bs41 &= -33;
						}
						break;
					case 3:
						if(v41) {
							bs41 |= 16;
						} else {
							bs41 &= -17;
						}
						break;
					case 4:
						if(v41) {
							bs41 |= 8;
						} else {
							bs41 &= -9;
						}
						break;
					case 5:
						if(v41) {
							bs41 |= 4;
						} else {
							bs41 &= -5;
						}
						break;
					case 6:
						if(v41) {
							bs41 |= 2;
						} else {
							bs41 &= -3;
						}
						break;
					case 7:
						if(v41) {
							bs41 |= 1;
						} else {
							bs41 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs41;
				break;
			case 38:
				var this43 = 0;
				var bs42 = this43;
				var l42 = " **  ".length;
				var _g143 = 0;
				var _g53 = l42;
				while(_g143 < _g53) {
					var i43 = _g143++;
					var no42 = " **  ".charCodeAt(i43);
					if(no42 == null) {
						break;
					}
					var v42;
					switch(no42) {
					case 32:
						v42 = false;
						break;
					case 42:
						v42 = true;
						break;
					case 48:
						v42 = false;
						break;
					case 49:
						v42 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i43)));
					}
					switch(i43 - (l42 - 8)) {
					case 0:
						if(v42) {
							bs42 |= 128;
						} else {
							bs42 &= -129;
						}
						break;
					case 1:
						if(v42) {
							bs42 |= 64;
						} else {
							bs42 &= -65;
						}
						break;
					case 2:
						if(v42) {
							bs42 |= 32;
						} else {
							bs42 &= -33;
						}
						break;
					case 3:
						if(v42) {
							bs42 |= 16;
						} else {
							bs42 &= -17;
						}
						break;
					case 4:
						if(v42) {
							bs42 |= 8;
						} else {
							bs42 &= -9;
						}
						break;
					case 5:
						if(v42) {
							bs42 |= 4;
						} else {
							bs42 &= -5;
						}
						break;
					case 6:
						if(v42) {
							bs42 |= 2;
						} else {
							bs42 &= -3;
						}
						break;
					case 7:
						if(v42) {
							bs42 |= 1;
						} else {
							bs42 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs42;
				var this44 = 0;
				var bs43 = this44;
				var l43 = "*  * ".length;
				var _g144 = 0;
				var _g54 = l43;
				while(_g144 < _g54) {
					var i44 = _g144++;
					var no43 = "*  * ".charCodeAt(i44);
					if(no43 == null) {
						break;
					}
					var v43;
					switch(no43) {
					case 32:
						v43 = false;
						break;
					case 42:
						v43 = true;
						break;
					case 48:
						v43 = false;
						break;
					case 49:
						v43 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i44)));
					}
					switch(i44 - (l43 - 8)) {
					case 0:
						if(v43) {
							bs43 |= 128;
						} else {
							bs43 &= -129;
						}
						break;
					case 1:
						if(v43) {
							bs43 |= 64;
						} else {
							bs43 &= -65;
						}
						break;
					case 2:
						if(v43) {
							bs43 |= 32;
						} else {
							bs43 &= -33;
						}
						break;
					case 3:
						if(v43) {
							bs43 |= 16;
						} else {
							bs43 &= -17;
						}
						break;
					case 4:
						if(v43) {
							bs43 |= 8;
						} else {
							bs43 &= -9;
						}
						break;
					case 5:
						if(v43) {
							bs43 |= 4;
						} else {
							bs43 &= -5;
						}
						break;
					case 6:
						if(v43) {
							bs43 |= 2;
						} else {
							bs43 &= -3;
						}
						break;
					case 7:
						if(v43) {
							bs43 |= 1;
						} else {
							bs43 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs43;
				var this45 = 0;
				var bs44 = this45;
				var l44 = "* *  ".length;
				var _g145 = 0;
				var _g55 = l44;
				while(_g145 < _g55) {
					var i45 = _g145++;
					var no44 = "* *  ".charCodeAt(i45);
					if(no44 == null) {
						break;
					}
					var v44;
					switch(no44) {
					case 32:
						v44 = false;
						break;
					case 42:
						v44 = true;
						break;
					case 48:
						v44 = false;
						break;
					case 49:
						v44 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i45)));
					}
					switch(i45 - (l44 - 8)) {
					case 0:
						if(v44) {
							bs44 |= 128;
						} else {
							bs44 &= -129;
						}
						break;
					case 1:
						if(v44) {
							bs44 |= 64;
						} else {
							bs44 &= -65;
						}
						break;
					case 2:
						if(v44) {
							bs44 |= 32;
						} else {
							bs44 &= -33;
						}
						break;
					case 3:
						if(v44) {
							bs44 |= 16;
						} else {
							bs44 &= -17;
						}
						break;
					case 4:
						if(v44) {
							bs44 |= 8;
						} else {
							bs44 &= -9;
						}
						break;
					case 5:
						if(v44) {
							bs44 |= 4;
						} else {
							bs44 &= -5;
						}
						break;
					case 6:
						if(v44) {
							bs44 |= 2;
						} else {
							bs44 &= -3;
						}
						break;
					case 7:
						if(v44) {
							bs44 |= 1;
						} else {
							bs44 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs44;
				var this46 = 0;
				var bs45 = this46;
				var l45 = " *   ".length;
				var _g146 = 0;
				var _g56 = l45;
				while(_g146 < _g56) {
					var i46 = _g146++;
					var no45 = " *   ".charCodeAt(i46);
					if(no45 == null) {
						break;
					}
					var v45;
					switch(no45) {
					case 32:
						v45 = false;
						break;
					case 42:
						v45 = true;
						break;
					case 48:
						v45 = false;
						break;
					case 49:
						v45 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i46)));
					}
					switch(i46 - (l45 - 8)) {
					case 0:
						if(v45) {
							bs45 |= 128;
						} else {
							bs45 &= -129;
						}
						break;
					case 1:
						if(v45) {
							bs45 |= 64;
						} else {
							bs45 &= -65;
						}
						break;
					case 2:
						if(v45) {
							bs45 |= 32;
						} else {
							bs45 &= -33;
						}
						break;
					case 3:
						if(v45) {
							bs45 |= 16;
						} else {
							bs45 &= -17;
						}
						break;
					case 4:
						if(v45) {
							bs45 |= 8;
						} else {
							bs45 &= -9;
						}
						break;
					case 5:
						if(v45) {
							bs45 |= 4;
						} else {
							bs45 &= -5;
						}
						break;
					case 6:
						if(v45) {
							bs45 |= 2;
						} else {
							bs45 &= -3;
						}
						break;
					case 7:
						if(v45) {
							bs45 |= 1;
						} else {
							bs45 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs45;
				var this47 = 0;
				var bs46 = this47;
				var l46 = "* * *".length;
				var _g147 = 0;
				var _g57 = l46;
				while(_g147 < _g57) {
					var i47 = _g147++;
					var no46 = "* * *".charCodeAt(i47);
					if(no46 == null) {
						break;
					}
					var v46;
					switch(no46) {
					case 32:
						v46 = false;
						break;
					case 42:
						v46 = true;
						break;
					case 48:
						v46 = false;
						break;
					case 49:
						v46 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i47)));
					}
					switch(i47 - (l46 - 8)) {
					case 0:
						if(v46) {
							bs46 |= 128;
						} else {
							bs46 &= -129;
						}
						break;
					case 1:
						if(v46) {
							bs46 |= 64;
						} else {
							bs46 &= -65;
						}
						break;
					case 2:
						if(v46) {
							bs46 |= 32;
						} else {
							bs46 &= -33;
						}
						break;
					case 3:
						if(v46) {
							bs46 |= 16;
						} else {
							bs46 &= -17;
						}
						break;
					case 4:
						if(v46) {
							bs46 |= 8;
						} else {
							bs46 &= -9;
						}
						break;
					case 5:
						if(v46) {
							bs46 |= 4;
						} else {
							bs46 &= -5;
						}
						break;
					case 6:
						if(v46) {
							bs46 |= 2;
						} else {
							bs46 &= -3;
						}
						break;
					case 7:
						if(v46) {
							bs46 |= 1;
						} else {
							bs46 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs46;
				var this48 = 0;
				var bs47 = this48;
				var l47 = "*  * ".length;
				var _g148 = 0;
				var _g58 = l47;
				while(_g148 < _g58) {
					var i48 = _g148++;
					var no47 = "*  * ".charCodeAt(i48);
					if(no47 == null) {
						break;
					}
					var v47;
					switch(no47) {
					case 32:
						v47 = false;
						break;
					case 42:
						v47 = true;
						break;
					case 48:
						v47 = false;
						break;
					case 49:
						v47 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i48)));
					}
					switch(i48 - (l47 - 8)) {
					case 0:
						if(v47) {
							bs47 |= 128;
						} else {
							bs47 &= -129;
						}
						break;
					case 1:
						if(v47) {
							bs47 |= 64;
						} else {
							bs47 &= -65;
						}
						break;
					case 2:
						if(v47) {
							bs47 |= 32;
						} else {
							bs47 &= -33;
						}
						break;
					case 3:
						if(v47) {
							bs47 |= 16;
						} else {
							bs47 &= -17;
						}
						break;
					case 4:
						if(v47) {
							bs47 |= 8;
						} else {
							bs47 &= -9;
						}
						break;
					case 5:
						if(v47) {
							bs47 |= 4;
						} else {
							bs47 &= -5;
						}
						break;
					case 6:
						if(v47) {
							bs47 |= 2;
						} else {
							bs47 &= -3;
						}
						break;
					case 7:
						if(v47) {
							bs47 |= 1;
						} else {
							bs47 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs47;
				var this49 = 0;
				var bs48 = this49;
				var l48 = " ** *".length;
				var _g149 = 0;
				var _g59 = l48;
				while(_g149 < _g59) {
					var i49 = _g149++;
					var no48 = " ** *".charCodeAt(i49);
					if(no48 == null) {
						break;
					}
					var v48;
					switch(no48) {
					case 32:
						v48 = false;
						break;
					case 42:
						v48 = true;
						break;
					case 48:
						v48 = false;
						break;
					case 49:
						v48 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i49)));
					}
					switch(i49 - (l48 - 8)) {
					case 0:
						if(v48) {
							bs48 |= 128;
						} else {
							bs48 &= -129;
						}
						break;
					case 1:
						if(v48) {
							bs48 |= 64;
						} else {
							bs48 &= -65;
						}
						break;
					case 2:
						if(v48) {
							bs48 |= 32;
						} else {
							bs48 &= -33;
						}
						break;
					case 3:
						if(v48) {
							bs48 |= 16;
						} else {
							bs48 &= -17;
						}
						break;
					case 4:
						if(v48) {
							bs48 |= 8;
						} else {
							bs48 &= -9;
						}
						break;
					case 5:
						if(v48) {
							bs48 |= 4;
						} else {
							bs48 &= -5;
						}
						break;
					case 6:
						if(v48) {
							bs48 |= 2;
						} else {
							bs48 &= -3;
						}
						break;
					case 7:
						if(v48) {
							bs48 |= 1;
						} else {
							bs48 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs48;
				break;
			case 39:
				var this50 = 0;
				var bs49 = this50;
				var l49 = "  ** ".length;
				var _g150 = 0;
				var _g60 = l49;
				while(_g150 < _g60) {
					var i50 = _g150++;
					var no49 = "  ** ".charCodeAt(i50);
					if(no49 == null) {
						break;
					}
					var v49;
					switch(no49) {
					case 32:
						v49 = false;
						break;
					case 42:
						v49 = true;
						break;
					case 48:
						v49 = false;
						break;
					case 49:
						v49 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i50)));
					}
					switch(i50 - (l49 - 8)) {
					case 0:
						if(v49) {
							bs49 |= 128;
						} else {
							bs49 &= -129;
						}
						break;
					case 1:
						if(v49) {
							bs49 |= 64;
						} else {
							bs49 &= -65;
						}
						break;
					case 2:
						if(v49) {
							bs49 |= 32;
						} else {
							bs49 &= -33;
						}
						break;
					case 3:
						if(v49) {
							bs49 |= 16;
						} else {
							bs49 &= -17;
						}
						break;
					case 4:
						if(v49) {
							bs49 |= 8;
						} else {
							bs49 &= -9;
						}
						break;
					case 5:
						if(v49) {
							bs49 |= 4;
						} else {
							bs49 &= -5;
						}
						break;
					case 6:
						if(v49) {
							bs49 |= 2;
						} else {
							bs49 &= -3;
						}
						break;
					case 7:
						if(v49) {
							bs49 |= 1;
						} else {
							bs49 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs49;
				var this51 = 0;
				var bs50 = this51;
				var l50 = "   * ".length;
				var _g151 = 0;
				var _g61 = l50;
				while(_g151 < _g61) {
					var i51 = _g151++;
					var no50 = "   * ".charCodeAt(i51);
					if(no50 == null) {
						break;
					}
					var v50;
					switch(no50) {
					case 32:
						v50 = false;
						break;
					case 42:
						v50 = true;
						break;
					case 48:
						v50 = false;
						break;
					case 49:
						v50 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i51)));
					}
					switch(i51 - (l50 - 8)) {
					case 0:
						if(v50) {
							bs50 |= 128;
						} else {
							bs50 &= -129;
						}
						break;
					case 1:
						if(v50) {
							bs50 |= 64;
						} else {
							bs50 &= -65;
						}
						break;
					case 2:
						if(v50) {
							bs50 |= 32;
						} else {
							bs50 &= -33;
						}
						break;
					case 3:
						if(v50) {
							bs50 |= 16;
						} else {
							bs50 &= -17;
						}
						break;
					case 4:
						if(v50) {
							bs50 |= 8;
						} else {
							bs50 &= -9;
						}
						break;
					case 5:
						if(v50) {
							bs50 |= 4;
						} else {
							bs50 &= -5;
						}
						break;
					case 6:
						if(v50) {
							bs50 |= 2;
						} else {
							bs50 &= -3;
						}
						break;
					case 7:
						if(v50) {
							bs50 |= 1;
						} else {
							bs50 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs50;
				var this52 = 0;
				var bs51 = this52;
				var l51 = "  *  ".length;
				var _g152 = 0;
				var _g62 = l51;
				while(_g152 < _g62) {
					var i52 = _g152++;
					var no51 = "  *  ".charCodeAt(i52);
					if(no51 == null) {
						break;
					}
					var v51;
					switch(no51) {
					case 32:
						v51 = false;
						break;
					case 42:
						v51 = true;
						break;
					case 48:
						v51 = false;
						break;
					case 49:
						v51 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i52)));
					}
					switch(i52 - (l51 - 8)) {
					case 0:
						if(v51) {
							bs51 |= 128;
						} else {
							bs51 &= -129;
						}
						break;
					case 1:
						if(v51) {
							bs51 |= 64;
						} else {
							bs51 &= -65;
						}
						break;
					case 2:
						if(v51) {
							bs51 |= 32;
						} else {
							bs51 &= -33;
						}
						break;
					case 3:
						if(v51) {
							bs51 |= 16;
						} else {
							bs51 &= -17;
						}
						break;
					case 4:
						if(v51) {
							bs51 |= 8;
						} else {
							bs51 &= -9;
						}
						break;
					case 5:
						if(v51) {
							bs51 |= 4;
						} else {
							bs51 &= -5;
						}
						break;
					case 6:
						if(v51) {
							bs51 |= 2;
						} else {
							bs51 &= -3;
						}
						break;
					case 7:
						if(v51) {
							bs51 |= 1;
						} else {
							bs51 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs51;
				var this53 = 0;
				var bs52 = this53;
				var l52 = "     ".length;
				var _g153 = 0;
				var _g63 = l52;
				while(_g153 < _g63) {
					var i53 = _g153++;
					var no52 = "     ".charCodeAt(i53);
					if(no52 == null) {
						break;
					}
					var v52;
					switch(no52) {
					case 32:
						v52 = false;
						break;
					case 42:
						v52 = true;
						break;
					case 48:
						v52 = false;
						break;
					case 49:
						v52 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i53)));
					}
					switch(i53 - (l52 - 8)) {
					case 0:
						if(v52) {
							bs52 |= 128;
						} else {
							bs52 &= -129;
						}
						break;
					case 1:
						if(v52) {
							bs52 |= 64;
						} else {
							bs52 &= -65;
						}
						break;
					case 2:
						if(v52) {
							bs52 |= 32;
						} else {
							bs52 &= -33;
						}
						break;
					case 3:
						if(v52) {
							bs52 |= 16;
						} else {
							bs52 &= -17;
						}
						break;
					case 4:
						if(v52) {
							bs52 |= 8;
						} else {
							bs52 &= -9;
						}
						break;
					case 5:
						if(v52) {
							bs52 |= 4;
						} else {
							bs52 &= -5;
						}
						break;
					case 6:
						if(v52) {
							bs52 |= 2;
						} else {
							bs52 &= -3;
						}
						break;
					case 7:
						if(v52) {
							bs52 |= 1;
						} else {
							bs52 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs52;
				var this54 = 0;
				var bs53 = this54;
				var l53 = "     ".length;
				var _g154 = 0;
				var _g64 = l53;
				while(_g154 < _g64) {
					var i54 = _g154++;
					var no53 = "     ".charCodeAt(i54);
					if(no53 == null) {
						break;
					}
					var v53;
					switch(no53) {
					case 32:
						v53 = false;
						break;
					case 42:
						v53 = true;
						break;
					case 48:
						v53 = false;
						break;
					case 49:
						v53 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i54)));
					}
					switch(i54 - (l53 - 8)) {
					case 0:
						if(v53) {
							bs53 |= 128;
						} else {
							bs53 &= -129;
						}
						break;
					case 1:
						if(v53) {
							bs53 |= 64;
						} else {
							bs53 &= -65;
						}
						break;
					case 2:
						if(v53) {
							bs53 |= 32;
						} else {
							bs53 &= -33;
						}
						break;
					case 3:
						if(v53) {
							bs53 |= 16;
						} else {
							bs53 &= -17;
						}
						break;
					case 4:
						if(v53) {
							bs53 |= 8;
						} else {
							bs53 &= -9;
						}
						break;
					case 5:
						if(v53) {
							bs53 |= 4;
						} else {
							bs53 &= -5;
						}
						break;
					case 6:
						if(v53) {
							bs53 |= 2;
						} else {
							bs53 &= -3;
						}
						break;
					case 7:
						if(v53) {
							bs53 |= 1;
						} else {
							bs53 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs53;
				var this55 = 0;
				var bs54 = this55;
				var l54 = "     ".length;
				var _g155 = 0;
				var _g65 = l54;
				while(_g155 < _g65) {
					var i55 = _g155++;
					var no54 = "     ".charCodeAt(i55);
					if(no54 == null) {
						break;
					}
					var v54;
					switch(no54) {
					case 32:
						v54 = false;
						break;
					case 42:
						v54 = true;
						break;
					case 48:
						v54 = false;
						break;
					case 49:
						v54 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i55)));
					}
					switch(i55 - (l54 - 8)) {
					case 0:
						if(v54) {
							bs54 |= 128;
						} else {
							bs54 &= -129;
						}
						break;
					case 1:
						if(v54) {
							bs54 |= 64;
						} else {
							bs54 &= -65;
						}
						break;
					case 2:
						if(v54) {
							bs54 |= 32;
						} else {
							bs54 &= -33;
						}
						break;
					case 3:
						if(v54) {
							bs54 |= 16;
						} else {
							bs54 &= -17;
						}
						break;
					case 4:
						if(v54) {
							bs54 |= 8;
						} else {
							bs54 &= -9;
						}
						break;
					case 5:
						if(v54) {
							bs54 |= 4;
						} else {
							bs54 &= -5;
						}
						break;
					case 6:
						if(v54) {
							bs54 |= 2;
						} else {
							bs54 &= -3;
						}
						break;
					case 7:
						if(v54) {
							bs54 |= 1;
						} else {
							bs54 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs54;
				var this56 = 0;
				var bs55 = this56;
				var l55 = "     ".length;
				var _g156 = 0;
				var _g66 = l55;
				while(_g156 < _g66) {
					var i56 = _g156++;
					var no55 = "     ".charCodeAt(i56);
					if(no55 == null) {
						break;
					}
					var v55;
					switch(no55) {
					case 32:
						v55 = false;
						break;
					case 42:
						v55 = true;
						break;
					case 48:
						v55 = false;
						break;
					case 49:
						v55 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i56)));
					}
					switch(i56 - (l55 - 8)) {
					case 0:
						if(v55) {
							bs55 |= 128;
						} else {
							bs55 &= -129;
						}
						break;
					case 1:
						if(v55) {
							bs55 |= 64;
						} else {
							bs55 &= -65;
						}
						break;
					case 2:
						if(v55) {
							bs55 |= 32;
						} else {
							bs55 &= -33;
						}
						break;
					case 3:
						if(v55) {
							bs55 |= 16;
						} else {
							bs55 &= -17;
						}
						break;
					case 4:
						if(v55) {
							bs55 |= 8;
						} else {
							bs55 &= -9;
						}
						break;
					case 5:
						if(v55) {
							bs55 |= 4;
						} else {
							bs55 &= -5;
						}
						break;
					case 6:
						if(v55) {
							bs55 |= 2;
						} else {
							bs55 &= -3;
						}
						break;
					case 7:
						if(v55) {
							bs55 |= 1;
						} else {
							bs55 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs55;
				break;
			case 40:
				var this57 = 0;
				var bs56 = this57;
				var l56 = "  *  ".length;
				var _g157 = 0;
				var _g67 = l56;
				while(_g157 < _g67) {
					var i57 = _g157++;
					var no56 = "  *  ".charCodeAt(i57);
					if(no56 == null) {
						break;
					}
					var v56;
					switch(no56) {
					case 32:
						v56 = false;
						break;
					case 42:
						v56 = true;
						break;
					case 48:
						v56 = false;
						break;
					case 49:
						v56 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i57)));
					}
					switch(i57 - (l56 - 8)) {
					case 0:
						if(v56) {
							bs56 |= 128;
						} else {
							bs56 &= -129;
						}
						break;
					case 1:
						if(v56) {
							bs56 |= 64;
						} else {
							bs56 &= -65;
						}
						break;
					case 2:
						if(v56) {
							bs56 |= 32;
						} else {
							bs56 &= -33;
						}
						break;
					case 3:
						if(v56) {
							bs56 |= 16;
						} else {
							bs56 &= -17;
						}
						break;
					case 4:
						if(v56) {
							bs56 |= 8;
						} else {
							bs56 &= -9;
						}
						break;
					case 5:
						if(v56) {
							bs56 |= 4;
						} else {
							bs56 &= -5;
						}
						break;
					case 6:
						if(v56) {
							bs56 |= 2;
						} else {
							bs56 &= -3;
						}
						break;
					case 7:
						if(v56) {
							bs56 |= 1;
						} else {
							bs56 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs56;
				var this58 = 0;
				var bs57 = this58;
				var l57 = " *   ".length;
				var _g158 = 0;
				var _g68 = l57;
				while(_g158 < _g68) {
					var i58 = _g158++;
					var no57 = " *   ".charCodeAt(i58);
					if(no57 == null) {
						break;
					}
					var v57;
					switch(no57) {
					case 32:
						v57 = false;
						break;
					case 42:
						v57 = true;
						break;
					case 48:
						v57 = false;
						break;
					case 49:
						v57 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i58)));
					}
					switch(i58 - (l57 - 8)) {
					case 0:
						if(v57) {
							bs57 |= 128;
						} else {
							bs57 &= -129;
						}
						break;
					case 1:
						if(v57) {
							bs57 |= 64;
						} else {
							bs57 &= -65;
						}
						break;
					case 2:
						if(v57) {
							bs57 |= 32;
						} else {
							bs57 &= -33;
						}
						break;
					case 3:
						if(v57) {
							bs57 |= 16;
						} else {
							bs57 &= -17;
						}
						break;
					case 4:
						if(v57) {
							bs57 |= 8;
						} else {
							bs57 &= -9;
						}
						break;
					case 5:
						if(v57) {
							bs57 |= 4;
						} else {
							bs57 &= -5;
						}
						break;
					case 6:
						if(v57) {
							bs57 |= 2;
						} else {
							bs57 &= -3;
						}
						break;
					case 7:
						if(v57) {
							bs57 |= 1;
						} else {
							bs57 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs57;
				var this59 = 0;
				var bs58 = this59;
				var l58 = "*    ".length;
				var _g159 = 0;
				var _g69 = l58;
				while(_g159 < _g69) {
					var i59 = _g159++;
					var no58 = "*    ".charCodeAt(i59);
					if(no58 == null) {
						break;
					}
					var v58;
					switch(no58) {
					case 32:
						v58 = false;
						break;
					case 42:
						v58 = true;
						break;
					case 48:
						v58 = false;
						break;
					case 49:
						v58 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i59)));
					}
					switch(i59 - (l58 - 8)) {
					case 0:
						if(v58) {
							bs58 |= 128;
						} else {
							bs58 &= -129;
						}
						break;
					case 1:
						if(v58) {
							bs58 |= 64;
						} else {
							bs58 &= -65;
						}
						break;
					case 2:
						if(v58) {
							bs58 |= 32;
						} else {
							bs58 &= -33;
						}
						break;
					case 3:
						if(v58) {
							bs58 |= 16;
						} else {
							bs58 &= -17;
						}
						break;
					case 4:
						if(v58) {
							bs58 |= 8;
						} else {
							bs58 &= -9;
						}
						break;
					case 5:
						if(v58) {
							bs58 |= 4;
						} else {
							bs58 &= -5;
						}
						break;
					case 6:
						if(v58) {
							bs58 |= 2;
						} else {
							bs58 &= -3;
						}
						break;
					case 7:
						if(v58) {
							bs58 |= 1;
						} else {
							bs58 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs58;
				var this60 = 0;
				var bs59 = this60;
				var l59 = "*    ".length;
				var _g160 = 0;
				var _g70 = l59;
				while(_g160 < _g70) {
					var i60 = _g160++;
					var no59 = "*    ".charCodeAt(i60);
					if(no59 == null) {
						break;
					}
					var v59;
					switch(no59) {
					case 32:
						v59 = false;
						break;
					case 42:
						v59 = true;
						break;
					case 48:
						v59 = false;
						break;
					case 49:
						v59 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i60)));
					}
					switch(i60 - (l59 - 8)) {
					case 0:
						if(v59) {
							bs59 |= 128;
						} else {
							bs59 &= -129;
						}
						break;
					case 1:
						if(v59) {
							bs59 |= 64;
						} else {
							bs59 &= -65;
						}
						break;
					case 2:
						if(v59) {
							bs59 |= 32;
						} else {
							bs59 &= -33;
						}
						break;
					case 3:
						if(v59) {
							bs59 |= 16;
						} else {
							bs59 &= -17;
						}
						break;
					case 4:
						if(v59) {
							bs59 |= 8;
						} else {
							bs59 &= -9;
						}
						break;
					case 5:
						if(v59) {
							bs59 |= 4;
						} else {
							bs59 &= -5;
						}
						break;
					case 6:
						if(v59) {
							bs59 |= 2;
						} else {
							bs59 &= -3;
						}
						break;
					case 7:
						if(v59) {
							bs59 |= 1;
						} else {
							bs59 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs59;
				var this61 = 0;
				var bs60 = this61;
				var l60 = "*    ".length;
				var _g161 = 0;
				var _g71 = l60;
				while(_g161 < _g71) {
					var i61 = _g161++;
					var no60 = "*    ".charCodeAt(i61);
					if(no60 == null) {
						break;
					}
					var v60;
					switch(no60) {
					case 32:
						v60 = false;
						break;
					case 42:
						v60 = true;
						break;
					case 48:
						v60 = false;
						break;
					case 49:
						v60 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i61)));
					}
					switch(i61 - (l60 - 8)) {
					case 0:
						if(v60) {
							bs60 |= 128;
						} else {
							bs60 &= -129;
						}
						break;
					case 1:
						if(v60) {
							bs60 |= 64;
						} else {
							bs60 &= -65;
						}
						break;
					case 2:
						if(v60) {
							bs60 |= 32;
						} else {
							bs60 &= -33;
						}
						break;
					case 3:
						if(v60) {
							bs60 |= 16;
						} else {
							bs60 &= -17;
						}
						break;
					case 4:
						if(v60) {
							bs60 |= 8;
						} else {
							bs60 &= -9;
						}
						break;
					case 5:
						if(v60) {
							bs60 |= 4;
						} else {
							bs60 &= -5;
						}
						break;
					case 6:
						if(v60) {
							bs60 |= 2;
						} else {
							bs60 &= -3;
						}
						break;
					case 7:
						if(v60) {
							bs60 |= 1;
						} else {
							bs60 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs60;
				var this62 = 0;
				var bs61 = this62;
				var l61 = " *   ".length;
				var _g162 = 0;
				var _g72 = l61;
				while(_g162 < _g72) {
					var i62 = _g162++;
					var no61 = " *   ".charCodeAt(i62);
					if(no61 == null) {
						break;
					}
					var v61;
					switch(no61) {
					case 32:
						v61 = false;
						break;
					case 42:
						v61 = true;
						break;
					case 48:
						v61 = false;
						break;
					case 49:
						v61 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i62)));
					}
					switch(i62 - (l61 - 8)) {
					case 0:
						if(v61) {
							bs61 |= 128;
						} else {
							bs61 &= -129;
						}
						break;
					case 1:
						if(v61) {
							bs61 |= 64;
						} else {
							bs61 &= -65;
						}
						break;
					case 2:
						if(v61) {
							bs61 |= 32;
						} else {
							bs61 &= -33;
						}
						break;
					case 3:
						if(v61) {
							bs61 |= 16;
						} else {
							bs61 &= -17;
						}
						break;
					case 4:
						if(v61) {
							bs61 |= 8;
						} else {
							bs61 &= -9;
						}
						break;
					case 5:
						if(v61) {
							bs61 |= 4;
						} else {
							bs61 &= -5;
						}
						break;
					case 6:
						if(v61) {
							bs61 |= 2;
						} else {
							bs61 &= -3;
						}
						break;
					case 7:
						if(v61) {
							bs61 |= 1;
						} else {
							bs61 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs61;
				var this63 = 0;
				var bs62 = this63;
				var l62 = "  *  ".length;
				var _g163 = 0;
				var _g73 = l62;
				while(_g163 < _g73) {
					var i63 = _g163++;
					var no62 = "  *  ".charCodeAt(i63);
					if(no62 == null) {
						break;
					}
					var v62;
					switch(no62) {
					case 32:
						v62 = false;
						break;
					case 42:
						v62 = true;
						break;
					case 48:
						v62 = false;
						break;
					case 49:
						v62 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i63)));
					}
					switch(i63 - (l62 - 8)) {
					case 0:
						if(v62) {
							bs62 |= 128;
						} else {
							bs62 &= -129;
						}
						break;
					case 1:
						if(v62) {
							bs62 |= 64;
						} else {
							bs62 &= -65;
						}
						break;
					case 2:
						if(v62) {
							bs62 |= 32;
						} else {
							bs62 &= -33;
						}
						break;
					case 3:
						if(v62) {
							bs62 |= 16;
						} else {
							bs62 &= -17;
						}
						break;
					case 4:
						if(v62) {
							bs62 |= 8;
						} else {
							bs62 &= -9;
						}
						break;
					case 5:
						if(v62) {
							bs62 |= 4;
						} else {
							bs62 &= -5;
						}
						break;
					case 6:
						if(v62) {
							bs62 |= 2;
						} else {
							bs62 &= -3;
						}
						break;
					case 7:
						if(v62) {
							bs62 |= 1;
						} else {
							bs62 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs62;
				break;
			case 41:
				var this64 = 0;
				var bs63 = this64;
				var l63 = "  *  ".length;
				var _g164 = 0;
				var _g74 = l63;
				while(_g164 < _g74) {
					var i64 = _g164++;
					var no63 = "  *  ".charCodeAt(i64);
					if(no63 == null) {
						break;
					}
					var v63;
					switch(no63) {
					case 32:
						v63 = false;
						break;
					case 42:
						v63 = true;
						break;
					case 48:
						v63 = false;
						break;
					case 49:
						v63 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i64)));
					}
					switch(i64 - (l63 - 8)) {
					case 0:
						if(v63) {
							bs63 |= 128;
						} else {
							bs63 &= -129;
						}
						break;
					case 1:
						if(v63) {
							bs63 |= 64;
						} else {
							bs63 &= -65;
						}
						break;
					case 2:
						if(v63) {
							bs63 |= 32;
						} else {
							bs63 &= -33;
						}
						break;
					case 3:
						if(v63) {
							bs63 |= 16;
						} else {
							bs63 &= -17;
						}
						break;
					case 4:
						if(v63) {
							bs63 |= 8;
						} else {
							bs63 &= -9;
						}
						break;
					case 5:
						if(v63) {
							bs63 |= 4;
						} else {
							bs63 &= -5;
						}
						break;
					case 6:
						if(v63) {
							bs63 |= 2;
						} else {
							bs63 &= -3;
						}
						break;
					case 7:
						if(v63) {
							bs63 |= 1;
						} else {
							bs63 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs63;
				var this65 = 0;
				var bs64 = this65;
				var l64 = "   * ".length;
				var _g165 = 0;
				var _g75 = l64;
				while(_g165 < _g75) {
					var i65 = _g165++;
					var no64 = "   * ".charCodeAt(i65);
					if(no64 == null) {
						break;
					}
					var v64;
					switch(no64) {
					case 32:
						v64 = false;
						break;
					case 42:
						v64 = true;
						break;
					case 48:
						v64 = false;
						break;
					case 49:
						v64 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i65)));
					}
					switch(i65 - (l64 - 8)) {
					case 0:
						if(v64) {
							bs64 |= 128;
						} else {
							bs64 &= -129;
						}
						break;
					case 1:
						if(v64) {
							bs64 |= 64;
						} else {
							bs64 &= -65;
						}
						break;
					case 2:
						if(v64) {
							bs64 |= 32;
						} else {
							bs64 &= -33;
						}
						break;
					case 3:
						if(v64) {
							bs64 |= 16;
						} else {
							bs64 &= -17;
						}
						break;
					case 4:
						if(v64) {
							bs64 |= 8;
						} else {
							bs64 &= -9;
						}
						break;
					case 5:
						if(v64) {
							bs64 |= 4;
						} else {
							bs64 &= -5;
						}
						break;
					case 6:
						if(v64) {
							bs64 |= 2;
						} else {
							bs64 &= -3;
						}
						break;
					case 7:
						if(v64) {
							bs64 |= 1;
						} else {
							bs64 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs64;
				var this66 = 0;
				var bs65 = this66;
				var l65 = "    *".length;
				var _g166 = 0;
				var _g76 = l65;
				while(_g166 < _g76) {
					var i66 = _g166++;
					var no65 = "    *".charCodeAt(i66);
					if(no65 == null) {
						break;
					}
					var v65;
					switch(no65) {
					case 32:
						v65 = false;
						break;
					case 42:
						v65 = true;
						break;
					case 48:
						v65 = false;
						break;
					case 49:
						v65 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i66)));
					}
					switch(i66 - (l65 - 8)) {
					case 0:
						if(v65) {
							bs65 |= 128;
						} else {
							bs65 &= -129;
						}
						break;
					case 1:
						if(v65) {
							bs65 |= 64;
						} else {
							bs65 &= -65;
						}
						break;
					case 2:
						if(v65) {
							bs65 |= 32;
						} else {
							bs65 &= -33;
						}
						break;
					case 3:
						if(v65) {
							bs65 |= 16;
						} else {
							bs65 &= -17;
						}
						break;
					case 4:
						if(v65) {
							bs65 |= 8;
						} else {
							bs65 &= -9;
						}
						break;
					case 5:
						if(v65) {
							bs65 |= 4;
						} else {
							bs65 &= -5;
						}
						break;
					case 6:
						if(v65) {
							bs65 |= 2;
						} else {
							bs65 &= -3;
						}
						break;
					case 7:
						if(v65) {
							bs65 |= 1;
						} else {
							bs65 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs65;
				var this67 = 0;
				var bs66 = this67;
				var l66 = "    *".length;
				var _g167 = 0;
				var _g77 = l66;
				while(_g167 < _g77) {
					var i67 = _g167++;
					var no66 = "    *".charCodeAt(i67);
					if(no66 == null) {
						break;
					}
					var v66;
					switch(no66) {
					case 32:
						v66 = false;
						break;
					case 42:
						v66 = true;
						break;
					case 48:
						v66 = false;
						break;
					case 49:
						v66 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i67)));
					}
					switch(i67 - (l66 - 8)) {
					case 0:
						if(v66) {
							bs66 |= 128;
						} else {
							bs66 &= -129;
						}
						break;
					case 1:
						if(v66) {
							bs66 |= 64;
						} else {
							bs66 &= -65;
						}
						break;
					case 2:
						if(v66) {
							bs66 |= 32;
						} else {
							bs66 &= -33;
						}
						break;
					case 3:
						if(v66) {
							bs66 |= 16;
						} else {
							bs66 &= -17;
						}
						break;
					case 4:
						if(v66) {
							bs66 |= 8;
						} else {
							bs66 &= -9;
						}
						break;
					case 5:
						if(v66) {
							bs66 |= 4;
						} else {
							bs66 &= -5;
						}
						break;
					case 6:
						if(v66) {
							bs66 |= 2;
						} else {
							bs66 &= -3;
						}
						break;
					case 7:
						if(v66) {
							bs66 |= 1;
						} else {
							bs66 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs66;
				var this68 = 0;
				var bs67 = this68;
				var l67 = "    *".length;
				var _g168 = 0;
				var _g78 = l67;
				while(_g168 < _g78) {
					var i68 = _g168++;
					var no67 = "    *".charCodeAt(i68);
					if(no67 == null) {
						break;
					}
					var v67;
					switch(no67) {
					case 32:
						v67 = false;
						break;
					case 42:
						v67 = true;
						break;
					case 48:
						v67 = false;
						break;
					case 49:
						v67 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i68)));
					}
					switch(i68 - (l67 - 8)) {
					case 0:
						if(v67) {
							bs67 |= 128;
						} else {
							bs67 &= -129;
						}
						break;
					case 1:
						if(v67) {
							bs67 |= 64;
						} else {
							bs67 &= -65;
						}
						break;
					case 2:
						if(v67) {
							bs67 |= 32;
						} else {
							bs67 &= -33;
						}
						break;
					case 3:
						if(v67) {
							bs67 |= 16;
						} else {
							bs67 &= -17;
						}
						break;
					case 4:
						if(v67) {
							bs67 |= 8;
						} else {
							bs67 &= -9;
						}
						break;
					case 5:
						if(v67) {
							bs67 |= 4;
						} else {
							bs67 &= -5;
						}
						break;
					case 6:
						if(v67) {
							bs67 |= 2;
						} else {
							bs67 &= -3;
						}
						break;
					case 7:
						if(v67) {
							bs67 |= 1;
						} else {
							bs67 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs67;
				var this69 = 0;
				var bs68 = this69;
				var l68 = "   * ".length;
				var _g169 = 0;
				var _g79 = l68;
				while(_g169 < _g79) {
					var i69 = _g169++;
					var no68 = "   * ".charCodeAt(i69);
					if(no68 == null) {
						break;
					}
					var v68;
					switch(no68) {
					case 32:
						v68 = false;
						break;
					case 42:
						v68 = true;
						break;
					case 48:
						v68 = false;
						break;
					case 49:
						v68 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i69)));
					}
					switch(i69 - (l68 - 8)) {
					case 0:
						if(v68) {
							bs68 |= 128;
						} else {
							bs68 &= -129;
						}
						break;
					case 1:
						if(v68) {
							bs68 |= 64;
						} else {
							bs68 &= -65;
						}
						break;
					case 2:
						if(v68) {
							bs68 |= 32;
						} else {
							bs68 &= -33;
						}
						break;
					case 3:
						if(v68) {
							bs68 |= 16;
						} else {
							bs68 &= -17;
						}
						break;
					case 4:
						if(v68) {
							bs68 |= 8;
						} else {
							bs68 &= -9;
						}
						break;
					case 5:
						if(v68) {
							bs68 |= 4;
						} else {
							bs68 &= -5;
						}
						break;
					case 6:
						if(v68) {
							bs68 |= 2;
						} else {
							bs68 &= -3;
						}
						break;
					case 7:
						if(v68) {
							bs68 |= 1;
						} else {
							bs68 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs68;
				var this70 = 0;
				var bs69 = this70;
				var l69 = "  *  ".length;
				var _g170 = 0;
				var _g80 = l69;
				while(_g170 < _g80) {
					var i70 = _g170++;
					var no69 = "  *  ".charCodeAt(i70);
					if(no69 == null) {
						break;
					}
					var v69;
					switch(no69) {
					case 32:
						v69 = false;
						break;
					case 42:
						v69 = true;
						break;
					case 48:
						v69 = false;
						break;
					case 49:
						v69 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i70)));
					}
					switch(i70 - (l69 - 8)) {
					case 0:
						if(v69) {
							bs69 |= 128;
						} else {
							bs69 &= -129;
						}
						break;
					case 1:
						if(v69) {
							bs69 |= 64;
						} else {
							bs69 &= -65;
						}
						break;
					case 2:
						if(v69) {
							bs69 |= 32;
						} else {
							bs69 &= -33;
						}
						break;
					case 3:
						if(v69) {
							bs69 |= 16;
						} else {
							bs69 &= -17;
						}
						break;
					case 4:
						if(v69) {
							bs69 |= 8;
						} else {
							bs69 &= -9;
						}
						break;
					case 5:
						if(v69) {
							bs69 |= 4;
						} else {
							bs69 &= -5;
						}
						break;
					case 6:
						if(v69) {
							bs69 |= 2;
						} else {
							bs69 &= -3;
						}
						break;
					case 7:
						if(v69) {
							bs69 |= 1;
						} else {
							bs69 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs69;
				break;
			case 42:
				var this71 = 0;
				var bs70 = this71;
				var l70 = "  *  ".length;
				var _g171 = 0;
				var _g81 = l70;
				while(_g171 < _g81) {
					var i71 = _g171++;
					var no70 = "  *  ".charCodeAt(i71);
					if(no70 == null) {
						break;
					}
					var v70;
					switch(no70) {
					case 32:
						v70 = false;
						break;
					case 42:
						v70 = true;
						break;
					case 48:
						v70 = false;
						break;
					case 49:
						v70 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i71)));
					}
					switch(i71 - (l70 - 8)) {
					case 0:
						if(v70) {
							bs70 |= 128;
						} else {
							bs70 &= -129;
						}
						break;
					case 1:
						if(v70) {
							bs70 |= 64;
						} else {
							bs70 &= -65;
						}
						break;
					case 2:
						if(v70) {
							bs70 |= 32;
						} else {
							bs70 &= -33;
						}
						break;
					case 3:
						if(v70) {
							bs70 |= 16;
						} else {
							bs70 &= -17;
						}
						break;
					case 4:
						if(v70) {
							bs70 |= 8;
						} else {
							bs70 &= -9;
						}
						break;
					case 5:
						if(v70) {
							bs70 |= 4;
						} else {
							bs70 &= -5;
						}
						break;
					case 6:
						if(v70) {
							bs70 |= 2;
						} else {
							bs70 &= -3;
						}
						break;
					case 7:
						if(v70) {
							bs70 |= 1;
						} else {
							bs70 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs70;
				var this72 = 0;
				var bs71 = this72;
				var l71 = "  *  ".length;
				var _g172 = 0;
				var _g82 = l71;
				while(_g172 < _g82) {
					var i72 = _g172++;
					var no71 = "  *  ".charCodeAt(i72);
					if(no71 == null) {
						break;
					}
					var v71;
					switch(no71) {
					case 32:
						v71 = false;
						break;
					case 42:
						v71 = true;
						break;
					case 48:
						v71 = false;
						break;
					case 49:
						v71 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i72)));
					}
					switch(i72 - (l71 - 8)) {
					case 0:
						if(v71) {
							bs71 |= 128;
						} else {
							bs71 &= -129;
						}
						break;
					case 1:
						if(v71) {
							bs71 |= 64;
						} else {
							bs71 &= -65;
						}
						break;
					case 2:
						if(v71) {
							bs71 |= 32;
						} else {
							bs71 &= -33;
						}
						break;
					case 3:
						if(v71) {
							bs71 |= 16;
						} else {
							bs71 &= -17;
						}
						break;
					case 4:
						if(v71) {
							bs71 |= 8;
						} else {
							bs71 &= -9;
						}
						break;
					case 5:
						if(v71) {
							bs71 |= 4;
						} else {
							bs71 &= -5;
						}
						break;
					case 6:
						if(v71) {
							bs71 |= 2;
						} else {
							bs71 &= -3;
						}
						break;
					case 7:
						if(v71) {
							bs71 |= 1;
						} else {
							bs71 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs71;
				var this73 = 0;
				var bs72 = this73;
				var l72 = "* * *".length;
				var _g173 = 0;
				var _g83 = l72;
				while(_g173 < _g83) {
					var i73 = _g173++;
					var no72 = "* * *".charCodeAt(i73);
					if(no72 == null) {
						break;
					}
					var v72;
					switch(no72) {
					case 32:
						v72 = false;
						break;
					case 42:
						v72 = true;
						break;
					case 48:
						v72 = false;
						break;
					case 49:
						v72 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i73)));
					}
					switch(i73 - (l72 - 8)) {
					case 0:
						if(v72) {
							bs72 |= 128;
						} else {
							bs72 &= -129;
						}
						break;
					case 1:
						if(v72) {
							bs72 |= 64;
						} else {
							bs72 &= -65;
						}
						break;
					case 2:
						if(v72) {
							bs72 |= 32;
						} else {
							bs72 &= -33;
						}
						break;
					case 3:
						if(v72) {
							bs72 |= 16;
						} else {
							bs72 &= -17;
						}
						break;
					case 4:
						if(v72) {
							bs72 |= 8;
						} else {
							bs72 &= -9;
						}
						break;
					case 5:
						if(v72) {
							bs72 |= 4;
						} else {
							bs72 &= -5;
						}
						break;
					case 6:
						if(v72) {
							bs72 |= 2;
						} else {
							bs72 &= -3;
						}
						break;
					case 7:
						if(v72) {
							bs72 |= 1;
						} else {
							bs72 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs72;
				var this74 = 0;
				var bs73 = this74;
				var l73 = " *** ".length;
				var _g174 = 0;
				var _g84 = l73;
				while(_g174 < _g84) {
					var i74 = _g174++;
					var no73 = " *** ".charCodeAt(i74);
					if(no73 == null) {
						break;
					}
					var v73;
					switch(no73) {
					case 32:
						v73 = false;
						break;
					case 42:
						v73 = true;
						break;
					case 48:
						v73 = false;
						break;
					case 49:
						v73 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i74)));
					}
					switch(i74 - (l73 - 8)) {
					case 0:
						if(v73) {
							bs73 |= 128;
						} else {
							bs73 &= -129;
						}
						break;
					case 1:
						if(v73) {
							bs73 |= 64;
						} else {
							bs73 &= -65;
						}
						break;
					case 2:
						if(v73) {
							bs73 |= 32;
						} else {
							bs73 &= -33;
						}
						break;
					case 3:
						if(v73) {
							bs73 |= 16;
						} else {
							bs73 &= -17;
						}
						break;
					case 4:
						if(v73) {
							bs73 |= 8;
						} else {
							bs73 &= -9;
						}
						break;
					case 5:
						if(v73) {
							bs73 |= 4;
						} else {
							bs73 &= -5;
						}
						break;
					case 6:
						if(v73) {
							bs73 |= 2;
						} else {
							bs73 &= -3;
						}
						break;
					case 7:
						if(v73) {
							bs73 |= 1;
						} else {
							bs73 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs73;
				var this75 = 0;
				var bs74 = this75;
				var l74 = "* * *".length;
				var _g175 = 0;
				var _g85 = l74;
				while(_g175 < _g85) {
					var i75 = _g175++;
					var no74 = "* * *".charCodeAt(i75);
					if(no74 == null) {
						break;
					}
					var v74;
					switch(no74) {
					case 32:
						v74 = false;
						break;
					case 42:
						v74 = true;
						break;
					case 48:
						v74 = false;
						break;
					case 49:
						v74 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i75)));
					}
					switch(i75 - (l74 - 8)) {
					case 0:
						if(v74) {
							bs74 |= 128;
						} else {
							bs74 &= -129;
						}
						break;
					case 1:
						if(v74) {
							bs74 |= 64;
						} else {
							bs74 &= -65;
						}
						break;
					case 2:
						if(v74) {
							bs74 |= 32;
						} else {
							bs74 &= -33;
						}
						break;
					case 3:
						if(v74) {
							bs74 |= 16;
						} else {
							bs74 &= -17;
						}
						break;
					case 4:
						if(v74) {
							bs74 |= 8;
						} else {
							bs74 &= -9;
						}
						break;
					case 5:
						if(v74) {
							bs74 |= 4;
						} else {
							bs74 &= -5;
						}
						break;
					case 6:
						if(v74) {
							bs74 |= 2;
						} else {
							bs74 &= -3;
						}
						break;
					case 7:
						if(v74) {
							bs74 |= 1;
						} else {
							bs74 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs74;
				var this76 = 0;
				var bs75 = this76;
				var l75 = "  *  ".length;
				var _g176 = 0;
				var _g86 = l75;
				while(_g176 < _g86) {
					var i76 = _g176++;
					var no75 = "  *  ".charCodeAt(i76);
					if(no75 == null) {
						break;
					}
					var v75;
					switch(no75) {
					case 32:
						v75 = false;
						break;
					case 42:
						v75 = true;
						break;
					case 48:
						v75 = false;
						break;
					case 49:
						v75 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i76)));
					}
					switch(i76 - (l75 - 8)) {
					case 0:
						if(v75) {
							bs75 |= 128;
						} else {
							bs75 &= -129;
						}
						break;
					case 1:
						if(v75) {
							bs75 |= 64;
						} else {
							bs75 &= -65;
						}
						break;
					case 2:
						if(v75) {
							bs75 |= 32;
						} else {
							bs75 &= -33;
						}
						break;
					case 3:
						if(v75) {
							bs75 |= 16;
						} else {
							bs75 &= -17;
						}
						break;
					case 4:
						if(v75) {
							bs75 |= 8;
						} else {
							bs75 &= -9;
						}
						break;
					case 5:
						if(v75) {
							bs75 |= 4;
						} else {
							bs75 &= -5;
						}
						break;
					case 6:
						if(v75) {
							bs75 |= 2;
						} else {
							bs75 &= -3;
						}
						break;
					case 7:
						if(v75) {
							bs75 |= 1;
						} else {
							bs75 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs75;
				var this77 = 0;
				var bs76 = this77;
				var l76 = "     ".length;
				var _g177 = 0;
				var _g87 = l76;
				while(_g177 < _g87) {
					var i77 = _g177++;
					var no76 = "     ".charCodeAt(i77);
					if(no76 == null) {
						break;
					}
					var v76;
					switch(no76) {
					case 32:
						v76 = false;
						break;
					case 42:
						v76 = true;
						break;
					case 48:
						v76 = false;
						break;
					case 49:
						v76 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i77)));
					}
					switch(i77 - (l76 - 8)) {
					case 0:
						if(v76) {
							bs76 |= 128;
						} else {
							bs76 &= -129;
						}
						break;
					case 1:
						if(v76) {
							bs76 |= 64;
						} else {
							bs76 &= -65;
						}
						break;
					case 2:
						if(v76) {
							bs76 |= 32;
						} else {
							bs76 &= -33;
						}
						break;
					case 3:
						if(v76) {
							bs76 |= 16;
						} else {
							bs76 &= -17;
						}
						break;
					case 4:
						if(v76) {
							bs76 |= 8;
						} else {
							bs76 &= -9;
						}
						break;
					case 5:
						if(v76) {
							bs76 |= 4;
						} else {
							bs76 &= -5;
						}
						break;
					case 6:
						if(v76) {
							bs76 |= 2;
						} else {
							bs76 &= -3;
						}
						break;
					case 7:
						if(v76) {
							bs76 |= 1;
						} else {
							bs76 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs76;
				break;
			case 43:
				var this78 = 0;
				var bs77 = this78;
				var l77 = "     ".length;
				var _g178 = 0;
				var _g88 = l77;
				while(_g178 < _g88) {
					var i78 = _g178++;
					var no77 = "     ".charCodeAt(i78);
					if(no77 == null) {
						break;
					}
					var v77;
					switch(no77) {
					case 32:
						v77 = false;
						break;
					case 42:
						v77 = true;
						break;
					case 48:
						v77 = false;
						break;
					case 49:
						v77 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i78)));
					}
					switch(i78 - (l77 - 8)) {
					case 0:
						if(v77) {
							bs77 |= 128;
						} else {
							bs77 &= -129;
						}
						break;
					case 1:
						if(v77) {
							bs77 |= 64;
						} else {
							bs77 &= -65;
						}
						break;
					case 2:
						if(v77) {
							bs77 |= 32;
						} else {
							bs77 &= -33;
						}
						break;
					case 3:
						if(v77) {
							bs77 |= 16;
						} else {
							bs77 &= -17;
						}
						break;
					case 4:
						if(v77) {
							bs77 |= 8;
						} else {
							bs77 &= -9;
						}
						break;
					case 5:
						if(v77) {
							bs77 |= 4;
						} else {
							bs77 &= -5;
						}
						break;
					case 6:
						if(v77) {
							bs77 |= 2;
						} else {
							bs77 &= -3;
						}
						break;
					case 7:
						if(v77) {
							bs77 |= 1;
						} else {
							bs77 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs77;
				var this79 = 0;
				var bs78 = this79;
				var l78 = "  *  ".length;
				var _g179 = 0;
				var _g89 = l78;
				while(_g179 < _g89) {
					var i79 = _g179++;
					var no78 = "  *  ".charCodeAt(i79);
					if(no78 == null) {
						break;
					}
					var v78;
					switch(no78) {
					case 32:
						v78 = false;
						break;
					case 42:
						v78 = true;
						break;
					case 48:
						v78 = false;
						break;
					case 49:
						v78 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i79)));
					}
					switch(i79 - (l78 - 8)) {
					case 0:
						if(v78) {
							bs78 |= 128;
						} else {
							bs78 &= -129;
						}
						break;
					case 1:
						if(v78) {
							bs78 |= 64;
						} else {
							bs78 &= -65;
						}
						break;
					case 2:
						if(v78) {
							bs78 |= 32;
						} else {
							bs78 &= -33;
						}
						break;
					case 3:
						if(v78) {
							bs78 |= 16;
						} else {
							bs78 &= -17;
						}
						break;
					case 4:
						if(v78) {
							bs78 |= 8;
						} else {
							bs78 &= -9;
						}
						break;
					case 5:
						if(v78) {
							bs78 |= 4;
						} else {
							bs78 &= -5;
						}
						break;
					case 6:
						if(v78) {
							bs78 |= 2;
						} else {
							bs78 &= -3;
						}
						break;
					case 7:
						if(v78) {
							bs78 |= 1;
						} else {
							bs78 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs78;
				var this80 = 0;
				var bs79 = this80;
				var l79 = "  *  ".length;
				var _g180 = 0;
				var _g90 = l79;
				while(_g180 < _g90) {
					var i80 = _g180++;
					var no79 = "  *  ".charCodeAt(i80);
					if(no79 == null) {
						break;
					}
					var v79;
					switch(no79) {
					case 32:
						v79 = false;
						break;
					case 42:
						v79 = true;
						break;
					case 48:
						v79 = false;
						break;
					case 49:
						v79 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i80)));
					}
					switch(i80 - (l79 - 8)) {
					case 0:
						if(v79) {
							bs79 |= 128;
						} else {
							bs79 &= -129;
						}
						break;
					case 1:
						if(v79) {
							bs79 |= 64;
						} else {
							bs79 &= -65;
						}
						break;
					case 2:
						if(v79) {
							bs79 |= 32;
						} else {
							bs79 &= -33;
						}
						break;
					case 3:
						if(v79) {
							bs79 |= 16;
						} else {
							bs79 &= -17;
						}
						break;
					case 4:
						if(v79) {
							bs79 |= 8;
						} else {
							bs79 &= -9;
						}
						break;
					case 5:
						if(v79) {
							bs79 |= 4;
						} else {
							bs79 &= -5;
						}
						break;
					case 6:
						if(v79) {
							bs79 |= 2;
						} else {
							bs79 &= -3;
						}
						break;
					case 7:
						if(v79) {
							bs79 |= 1;
						} else {
							bs79 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs79;
				var this81 = 0;
				var bs80 = this81;
				var l80 = "*****".length;
				var _g181 = 0;
				var _g91 = l80;
				while(_g181 < _g91) {
					var i81 = _g181++;
					var no80 = "*****".charCodeAt(i81);
					if(no80 == null) {
						break;
					}
					var v80;
					switch(no80) {
					case 32:
						v80 = false;
						break;
					case 42:
						v80 = true;
						break;
					case 48:
						v80 = false;
						break;
					case 49:
						v80 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i81)));
					}
					switch(i81 - (l80 - 8)) {
					case 0:
						if(v80) {
							bs80 |= 128;
						} else {
							bs80 &= -129;
						}
						break;
					case 1:
						if(v80) {
							bs80 |= 64;
						} else {
							bs80 &= -65;
						}
						break;
					case 2:
						if(v80) {
							bs80 |= 32;
						} else {
							bs80 &= -33;
						}
						break;
					case 3:
						if(v80) {
							bs80 |= 16;
						} else {
							bs80 &= -17;
						}
						break;
					case 4:
						if(v80) {
							bs80 |= 8;
						} else {
							bs80 &= -9;
						}
						break;
					case 5:
						if(v80) {
							bs80 |= 4;
						} else {
							bs80 &= -5;
						}
						break;
					case 6:
						if(v80) {
							bs80 |= 2;
						} else {
							bs80 &= -3;
						}
						break;
					case 7:
						if(v80) {
							bs80 |= 1;
						} else {
							bs80 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs80;
				var this82 = 0;
				var bs81 = this82;
				var l81 = "  *  ".length;
				var _g182 = 0;
				var _g92 = l81;
				while(_g182 < _g92) {
					var i82 = _g182++;
					var no81 = "  *  ".charCodeAt(i82);
					if(no81 == null) {
						break;
					}
					var v81;
					switch(no81) {
					case 32:
						v81 = false;
						break;
					case 42:
						v81 = true;
						break;
					case 48:
						v81 = false;
						break;
					case 49:
						v81 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i82)));
					}
					switch(i82 - (l81 - 8)) {
					case 0:
						if(v81) {
							bs81 |= 128;
						} else {
							bs81 &= -129;
						}
						break;
					case 1:
						if(v81) {
							bs81 |= 64;
						} else {
							bs81 &= -65;
						}
						break;
					case 2:
						if(v81) {
							bs81 |= 32;
						} else {
							bs81 &= -33;
						}
						break;
					case 3:
						if(v81) {
							bs81 |= 16;
						} else {
							bs81 &= -17;
						}
						break;
					case 4:
						if(v81) {
							bs81 |= 8;
						} else {
							bs81 &= -9;
						}
						break;
					case 5:
						if(v81) {
							bs81 |= 4;
						} else {
							bs81 &= -5;
						}
						break;
					case 6:
						if(v81) {
							bs81 |= 2;
						} else {
							bs81 &= -3;
						}
						break;
					case 7:
						if(v81) {
							bs81 |= 1;
						} else {
							bs81 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs81;
				var this83 = 0;
				var bs82 = this83;
				var l82 = "  *  ".length;
				var _g183 = 0;
				var _g93 = l82;
				while(_g183 < _g93) {
					var i83 = _g183++;
					var no82 = "  *  ".charCodeAt(i83);
					if(no82 == null) {
						break;
					}
					var v82;
					switch(no82) {
					case 32:
						v82 = false;
						break;
					case 42:
						v82 = true;
						break;
					case 48:
						v82 = false;
						break;
					case 49:
						v82 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i83)));
					}
					switch(i83 - (l82 - 8)) {
					case 0:
						if(v82) {
							bs82 |= 128;
						} else {
							bs82 &= -129;
						}
						break;
					case 1:
						if(v82) {
							bs82 |= 64;
						} else {
							bs82 &= -65;
						}
						break;
					case 2:
						if(v82) {
							bs82 |= 32;
						} else {
							bs82 &= -33;
						}
						break;
					case 3:
						if(v82) {
							bs82 |= 16;
						} else {
							bs82 &= -17;
						}
						break;
					case 4:
						if(v82) {
							bs82 |= 8;
						} else {
							bs82 &= -9;
						}
						break;
					case 5:
						if(v82) {
							bs82 |= 4;
						} else {
							bs82 &= -5;
						}
						break;
					case 6:
						if(v82) {
							bs82 |= 2;
						} else {
							bs82 &= -3;
						}
						break;
					case 7:
						if(v82) {
							bs82 |= 1;
						} else {
							bs82 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs82;
				var this84 = 0;
				var bs83 = this84;
				var l83 = "     ".length;
				var _g184 = 0;
				var _g94 = l83;
				while(_g184 < _g94) {
					var i84 = _g184++;
					var no83 = "     ".charCodeAt(i84);
					if(no83 == null) {
						break;
					}
					var v83;
					switch(no83) {
					case 32:
						v83 = false;
						break;
					case 42:
						v83 = true;
						break;
					case 48:
						v83 = false;
						break;
					case 49:
						v83 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i84)));
					}
					switch(i84 - (l83 - 8)) {
					case 0:
						if(v83) {
							bs83 |= 128;
						} else {
							bs83 &= -129;
						}
						break;
					case 1:
						if(v83) {
							bs83 |= 64;
						} else {
							bs83 &= -65;
						}
						break;
					case 2:
						if(v83) {
							bs83 |= 32;
						} else {
							bs83 &= -33;
						}
						break;
					case 3:
						if(v83) {
							bs83 |= 16;
						} else {
							bs83 &= -17;
						}
						break;
					case 4:
						if(v83) {
							bs83 |= 8;
						} else {
							bs83 &= -9;
						}
						break;
					case 5:
						if(v83) {
							bs83 |= 4;
						} else {
							bs83 &= -5;
						}
						break;
					case 6:
						if(v83) {
							bs83 |= 2;
						} else {
							bs83 &= -3;
						}
						break;
					case 7:
						if(v83) {
							bs83 |= 1;
						} else {
							bs83 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs83;
				break;
			case 44:
				var this85 = 0;
				var bs84 = this85;
				var l84 = "     ".length;
				var _g185 = 0;
				var _g95 = l84;
				while(_g185 < _g95) {
					var i85 = _g185++;
					var no84 = "     ".charCodeAt(i85);
					if(no84 == null) {
						break;
					}
					var v84;
					switch(no84) {
					case 32:
						v84 = false;
						break;
					case 42:
						v84 = true;
						break;
					case 48:
						v84 = false;
						break;
					case 49:
						v84 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i85)));
					}
					switch(i85 - (l84 - 8)) {
					case 0:
						if(v84) {
							bs84 |= 128;
						} else {
							bs84 &= -129;
						}
						break;
					case 1:
						if(v84) {
							bs84 |= 64;
						} else {
							bs84 &= -65;
						}
						break;
					case 2:
						if(v84) {
							bs84 |= 32;
						} else {
							bs84 &= -33;
						}
						break;
					case 3:
						if(v84) {
							bs84 |= 16;
						} else {
							bs84 &= -17;
						}
						break;
					case 4:
						if(v84) {
							bs84 |= 8;
						} else {
							bs84 &= -9;
						}
						break;
					case 5:
						if(v84) {
							bs84 |= 4;
						} else {
							bs84 &= -5;
						}
						break;
					case 6:
						if(v84) {
							bs84 |= 2;
						} else {
							bs84 &= -3;
						}
						break;
					case 7:
						if(v84) {
							bs84 |= 1;
						} else {
							bs84 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs84;
				var this86 = 0;
				var bs85 = this86;
				var l85 = "     ".length;
				var _g186 = 0;
				var _g96 = l85;
				while(_g186 < _g96) {
					var i86 = _g186++;
					var no85 = "     ".charCodeAt(i86);
					if(no85 == null) {
						break;
					}
					var v85;
					switch(no85) {
					case 32:
						v85 = false;
						break;
					case 42:
						v85 = true;
						break;
					case 48:
						v85 = false;
						break;
					case 49:
						v85 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i86)));
					}
					switch(i86 - (l85 - 8)) {
					case 0:
						if(v85) {
							bs85 |= 128;
						} else {
							bs85 &= -129;
						}
						break;
					case 1:
						if(v85) {
							bs85 |= 64;
						} else {
							bs85 &= -65;
						}
						break;
					case 2:
						if(v85) {
							bs85 |= 32;
						} else {
							bs85 &= -33;
						}
						break;
					case 3:
						if(v85) {
							bs85 |= 16;
						} else {
							bs85 &= -17;
						}
						break;
					case 4:
						if(v85) {
							bs85 |= 8;
						} else {
							bs85 &= -9;
						}
						break;
					case 5:
						if(v85) {
							bs85 |= 4;
						} else {
							bs85 &= -5;
						}
						break;
					case 6:
						if(v85) {
							bs85 |= 2;
						} else {
							bs85 &= -3;
						}
						break;
					case 7:
						if(v85) {
							bs85 |= 1;
						} else {
							bs85 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs85;
				var this87 = 0;
				var bs86 = this87;
				var l86 = "     ".length;
				var _g187 = 0;
				var _g97 = l86;
				while(_g187 < _g97) {
					var i87 = _g187++;
					var no86 = "     ".charCodeAt(i87);
					if(no86 == null) {
						break;
					}
					var v86;
					switch(no86) {
					case 32:
						v86 = false;
						break;
					case 42:
						v86 = true;
						break;
					case 48:
						v86 = false;
						break;
					case 49:
						v86 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i87)));
					}
					switch(i87 - (l86 - 8)) {
					case 0:
						if(v86) {
							bs86 |= 128;
						} else {
							bs86 &= -129;
						}
						break;
					case 1:
						if(v86) {
							bs86 |= 64;
						} else {
							bs86 &= -65;
						}
						break;
					case 2:
						if(v86) {
							bs86 |= 32;
						} else {
							bs86 &= -33;
						}
						break;
					case 3:
						if(v86) {
							bs86 |= 16;
						} else {
							bs86 &= -17;
						}
						break;
					case 4:
						if(v86) {
							bs86 |= 8;
						} else {
							bs86 &= -9;
						}
						break;
					case 5:
						if(v86) {
							bs86 |= 4;
						} else {
							bs86 &= -5;
						}
						break;
					case 6:
						if(v86) {
							bs86 |= 2;
						} else {
							bs86 &= -3;
						}
						break;
					case 7:
						if(v86) {
							bs86 |= 1;
						} else {
							bs86 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs86;
				var this88 = 0;
				var bs87 = this88;
				var l87 = "     ".length;
				var _g188 = 0;
				var _g98 = l87;
				while(_g188 < _g98) {
					var i88 = _g188++;
					var no87 = "     ".charCodeAt(i88);
					if(no87 == null) {
						break;
					}
					var v87;
					switch(no87) {
					case 32:
						v87 = false;
						break;
					case 42:
						v87 = true;
						break;
					case 48:
						v87 = false;
						break;
					case 49:
						v87 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i88)));
					}
					switch(i88 - (l87 - 8)) {
					case 0:
						if(v87) {
							bs87 |= 128;
						} else {
							bs87 &= -129;
						}
						break;
					case 1:
						if(v87) {
							bs87 |= 64;
						} else {
							bs87 &= -65;
						}
						break;
					case 2:
						if(v87) {
							bs87 |= 32;
						} else {
							bs87 &= -33;
						}
						break;
					case 3:
						if(v87) {
							bs87 |= 16;
						} else {
							bs87 &= -17;
						}
						break;
					case 4:
						if(v87) {
							bs87 |= 8;
						} else {
							bs87 &= -9;
						}
						break;
					case 5:
						if(v87) {
							bs87 |= 4;
						} else {
							bs87 &= -5;
						}
						break;
					case 6:
						if(v87) {
							bs87 |= 2;
						} else {
							bs87 &= -3;
						}
						break;
					case 7:
						if(v87) {
							bs87 |= 1;
						} else {
							bs87 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs87;
				var this89 = 0;
				var bs88 = this89;
				var l88 = " **  ".length;
				var _g189 = 0;
				var _g99 = l88;
				while(_g189 < _g99) {
					var i89 = _g189++;
					var no88 = " **  ".charCodeAt(i89);
					if(no88 == null) {
						break;
					}
					var v88;
					switch(no88) {
					case 32:
						v88 = false;
						break;
					case 42:
						v88 = true;
						break;
					case 48:
						v88 = false;
						break;
					case 49:
						v88 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i89)));
					}
					switch(i89 - (l88 - 8)) {
					case 0:
						if(v88) {
							bs88 |= 128;
						} else {
							bs88 &= -129;
						}
						break;
					case 1:
						if(v88) {
							bs88 |= 64;
						} else {
							bs88 &= -65;
						}
						break;
					case 2:
						if(v88) {
							bs88 |= 32;
						} else {
							bs88 &= -33;
						}
						break;
					case 3:
						if(v88) {
							bs88 |= 16;
						} else {
							bs88 &= -17;
						}
						break;
					case 4:
						if(v88) {
							bs88 |= 8;
						} else {
							bs88 &= -9;
						}
						break;
					case 5:
						if(v88) {
							bs88 |= 4;
						} else {
							bs88 &= -5;
						}
						break;
					case 6:
						if(v88) {
							bs88 |= 2;
						} else {
							bs88 &= -3;
						}
						break;
					case 7:
						if(v88) {
							bs88 |= 1;
						} else {
							bs88 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs88;
				var this90 = 0;
				var bs89 = this90;
				var l89 = "  *  ".length;
				var _g190 = 0;
				var _g100 = l89;
				while(_g190 < _g100) {
					var i90 = _g190++;
					var no89 = "  *  ".charCodeAt(i90);
					if(no89 == null) {
						break;
					}
					var v89;
					switch(no89) {
					case 32:
						v89 = false;
						break;
					case 42:
						v89 = true;
						break;
					case 48:
						v89 = false;
						break;
					case 49:
						v89 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i90)));
					}
					switch(i90 - (l89 - 8)) {
					case 0:
						if(v89) {
							bs89 |= 128;
						} else {
							bs89 &= -129;
						}
						break;
					case 1:
						if(v89) {
							bs89 |= 64;
						} else {
							bs89 &= -65;
						}
						break;
					case 2:
						if(v89) {
							bs89 |= 32;
						} else {
							bs89 &= -33;
						}
						break;
					case 3:
						if(v89) {
							bs89 |= 16;
						} else {
							bs89 &= -17;
						}
						break;
					case 4:
						if(v89) {
							bs89 |= 8;
						} else {
							bs89 &= -9;
						}
						break;
					case 5:
						if(v89) {
							bs89 |= 4;
						} else {
							bs89 &= -5;
						}
						break;
					case 6:
						if(v89) {
							bs89 |= 2;
						} else {
							bs89 &= -3;
						}
						break;
					case 7:
						if(v89) {
							bs89 |= 1;
						} else {
							bs89 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs89;
				var this91 = 0;
				var bs90 = this91;
				var l90 = " *   ".length;
				var _g191 = 0;
				var _g101 = l90;
				while(_g191 < _g101) {
					var i91 = _g191++;
					var no90 = " *   ".charCodeAt(i91);
					if(no90 == null) {
						break;
					}
					var v90;
					switch(no90) {
					case 32:
						v90 = false;
						break;
					case 42:
						v90 = true;
						break;
					case 48:
						v90 = false;
						break;
					case 49:
						v90 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i91)));
					}
					switch(i91 - (l90 - 8)) {
					case 0:
						if(v90) {
							bs90 |= 128;
						} else {
							bs90 &= -129;
						}
						break;
					case 1:
						if(v90) {
							bs90 |= 64;
						} else {
							bs90 &= -65;
						}
						break;
					case 2:
						if(v90) {
							bs90 |= 32;
						} else {
							bs90 &= -33;
						}
						break;
					case 3:
						if(v90) {
							bs90 |= 16;
						} else {
							bs90 &= -17;
						}
						break;
					case 4:
						if(v90) {
							bs90 |= 8;
						} else {
							bs90 &= -9;
						}
						break;
					case 5:
						if(v90) {
							bs90 |= 4;
						} else {
							bs90 &= -5;
						}
						break;
					case 6:
						if(v90) {
							bs90 |= 2;
						} else {
							bs90 &= -3;
						}
						break;
					case 7:
						if(v90) {
							bs90 |= 1;
						} else {
							bs90 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs90;
				break;
			case 45:
				var this92 = 0;
				var bs91 = this92;
				var l91 = "     ".length;
				var _g192 = 0;
				var _g102 = l91;
				while(_g192 < _g102) {
					var i92 = _g192++;
					var no91 = "     ".charCodeAt(i92);
					if(no91 == null) {
						break;
					}
					var v91;
					switch(no91) {
					case 32:
						v91 = false;
						break;
					case 42:
						v91 = true;
						break;
					case 48:
						v91 = false;
						break;
					case 49:
						v91 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i92)));
					}
					switch(i92 - (l91 - 8)) {
					case 0:
						if(v91) {
							bs91 |= 128;
						} else {
							bs91 &= -129;
						}
						break;
					case 1:
						if(v91) {
							bs91 |= 64;
						} else {
							bs91 &= -65;
						}
						break;
					case 2:
						if(v91) {
							bs91 |= 32;
						} else {
							bs91 &= -33;
						}
						break;
					case 3:
						if(v91) {
							bs91 |= 16;
						} else {
							bs91 &= -17;
						}
						break;
					case 4:
						if(v91) {
							bs91 |= 8;
						} else {
							bs91 &= -9;
						}
						break;
					case 5:
						if(v91) {
							bs91 |= 4;
						} else {
							bs91 &= -5;
						}
						break;
					case 6:
						if(v91) {
							bs91 |= 2;
						} else {
							bs91 &= -3;
						}
						break;
					case 7:
						if(v91) {
							bs91 |= 1;
						} else {
							bs91 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs91;
				var this93 = 0;
				var bs92 = this93;
				var l92 = "     ".length;
				var _g193 = 0;
				var _g103 = l92;
				while(_g193 < _g103) {
					var i93 = _g193++;
					var no92 = "     ".charCodeAt(i93);
					if(no92 == null) {
						break;
					}
					var v92;
					switch(no92) {
					case 32:
						v92 = false;
						break;
					case 42:
						v92 = true;
						break;
					case 48:
						v92 = false;
						break;
					case 49:
						v92 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i93)));
					}
					switch(i93 - (l92 - 8)) {
					case 0:
						if(v92) {
							bs92 |= 128;
						} else {
							bs92 &= -129;
						}
						break;
					case 1:
						if(v92) {
							bs92 |= 64;
						} else {
							bs92 &= -65;
						}
						break;
					case 2:
						if(v92) {
							bs92 |= 32;
						} else {
							bs92 &= -33;
						}
						break;
					case 3:
						if(v92) {
							bs92 |= 16;
						} else {
							bs92 &= -17;
						}
						break;
					case 4:
						if(v92) {
							bs92 |= 8;
						} else {
							bs92 &= -9;
						}
						break;
					case 5:
						if(v92) {
							bs92 |= 4;
						} else {
							bs92 &= -5;
						}
						break;
					case 6:
						if(v92) {
							bs92 |= 2;
						} else {
							bs92 &= -3;
						}
						break;
					case 7:
						if(v92) {
							bs92 |= 1;
						} else {
							bs92 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs92;
				var this94 = 0;
				var bs93 = this94;
				var l93 = "     ".length;
				var _g194 = 0;
				var _g104 = l93;
				while(_g194 < _g104) {
					var i94 = _g194++;
					var no93 = "     ".charCodeAt(i94);
					if(no93 == null) {
						break;
					}
					var v93;
					switch(no93) {
					case 32:
						v93 = false;
						break;
					case 42:
						v93 = true;
						break;
					case 48:
						v93 = false;
						break;
					case 49:
						v93 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i94)));
					}
					switch(i94 - (l93 - 8)) {
					case 0:
						if(v93) {
							bs93 |= 128;
						} else {
							bs93 &= -129;
						}
						break;
					case 1:
						if(v93) {
							bs93 |= 64;
						} else {
							bs93 &= -65;
						}
						break;
					case 2:
						if(v93) {
							bs93 |= 32;
						} else {
							bs93 &= -33;
						}
						break;
					case 3:
						if(v93) {
							bs93 |= 16;
						} else {
							bs93 &= -17;
						}
						break;
					case 4:
						if(v93) {
							bs93 |= 8;
						} else {
							bs93 &= -9;
						}
						break;
					case 5:
						if(v93) {
							bs93 |= 4;
						} else {
							bs93 &= -5;
						}
						break;
					case 6:
						if(v93) {
							bs93 |= 2;
						} else {
							bs93 &= -3;
						}
						break;
					case 7:
						if(v93) {
							bs93 |= 1;
						} else {
							bs93 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs93;
				var this95 = 0;
				var bs94 = this95;
				var l94 = "*****".length;
				var _g195 = 0;
				var _g105 = l94;
				while(_g195 < _g105) {
					var i95 = _g195++;
					var no94 = "*****".charCodeAt(i95);
					if(no94 == null) {
						break;
					}
					var v94;
					switch(no94) {
					case 32:
						v94 = false;
						break;
					case 42:
						v94 = true;
						break;
					case 48:
						v94 = false;
						break;
					case 49:
						v94 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i95)));
					}
					switch(i95 - (l94 - 8)) {
					case 0:
						if(v94) {
							bs94 |= 128;
						} else {
							bs94 &= -129;
						}
						break;
					case 1:
						if(v94) {
							bs94 |= 64;
						} else {
							bs94 &= -65;
						}
						break;
					case 2:
						if(v94) {
							bs94 |= 32;
						} else {
							bs94 &= -33;
						}
						break;
					case 3:
						if(v94) {
							bs94 |= 16;
						} else {
							bs94 &= -17;
						}
						break;
					case 4:
						if(v94) {
							bs94 |= 8;
						} else {
							bs94 &= -9;
						}
						break;
					case 5:
						if(v94) {
							bs94 |= 4;
						} else {
							bs94 &= -5;
						}
						break;
					case 6:
						if(v94) {
							bs94 |= 2;
						} else {
							bs94 &= -3;
						}
						break;
					case 7:
						if(v94) {
							bs94 |= 1;
						} else {
							bs94 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs94;
				var this96 = 0;
				var bs95 = this96;
				var l95 = "     ".length;
				var _g196 = 0;
				var _g106 = l95;
				while(_g196 < _g106) {
					var i96 = _g196++;
					var no95 = "     ".charCodeAt(i96);
					if(no95 == null) {
						break;
					}
					var v95;
					switch(no95) {
					case 32:
						v95 = false;
						break;
					case 42:
						v95 = true;
						break;
					case 48:
						v95 = false;
						break;
					case 49:
						v95 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i96)));
					}
					switch(i96 - (l95 - 8)) {
					case 0:
						if(v95) {
							bs95 |= 128;
						} else {
							bs95 &= -129;
						}
						break;
					case 1:
						if(v95) {
							bs95 |= 64;
						} else {
							bs95 &= -65;
						}
						break;
					case 2:
						if(v95) {
							bs95 |= 32;
						} else {
							bs95 &= -33;
						}
						break;
					case 3:
						if(v95) {
							bs95 |= 16;
						} else {
							bs95 &= -17;
						}
						break;
					case 4:
						if(v95) {
							bs95 |= 8;
						} else {
							bs95 &= -9;
						}
						break;
					case 5:
						if(v95) {
							bs95 |= 4;
						} else {
							bs95 &= -5;
						}
						break;
					case 6:
						if(v95) {
							bs95 |= 2;
						} else {
							bs95 &= -3;
						}
						break;
					case 7:
						if(v95) {
							bs95 |= 1;
						} else {
							bs95 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs95;
				var this97 = 0;
				var bs96 = this97;
				var l96 = "     ".length;
				var _g197 = 0;
				var _g107 = l96;
				while(_g197 < _g107) {
					var i97 = _g197++;
					var no96 = "     ".charCodeAt(i97);
					if(no96 == null) {
						break;
					}
					var v96;
					switch(no96) {
					case 32:
						v96 = false;
						break;
					case 42:
						v96 = true;
						break;
					case 48:
						v96 = false;
						break;
					case 49:
						v96 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i97)));
					}
					switch(i97 - (l96 - 8)) {
					case 0:
						if(v96) {
							bs96 |= 128;
						} else {
							bs96 &= -129;
						}
						break;
					case 1:
						if(v96) {
							bs96 |= 64;
						} else {
							bs96 &= -65;
						}
						break;
					case 2:
						if(v96) {
							bs96 |= 32;
						} else {
							bs96 &= -33;
						}
						break;
					case 3:
						if(v96) {
							bs96 |= 16;
						} else {
							bs96 &= -17;
						}
						break;
					case 4:
						if(v96) {
							bs96 |= 8;
						} else {
							bs96 &= -9;
						}
						break;
					case 5:
						if(v96) {
							bs96 |= 4;
						} else {
							bs96 &= -5;
						}
						break;
					case 6:
						if(v96) {
							bs96 |= 2;
						} else {
							bs96 &= -3;
						}
						break;
					case 7:
						if(v96) {
							bs96 |= 1;
						} else {
							bs96 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs96;
				var this98 = 0;
				var bs97 = this98;
				var l97 = "     ".length;
				var _g198 = 0;
				var _g108 = l97;
				while(_g198 < _g108) {
					var i98 = _g198++;
					var no97 = "     ".charCodeAt(i98);
					if(no97 == null) {
						break;
					}
					var v97;
					switch(no97) {
					case 32:
						v97 = false;
						break;
					case 42:
						v97 = true;
						break;
					case 48:
						v97 = false;
						break;
					case 49:
						v97 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i98)));
					}
					switch(i98 - (l97 - 8)) {
					case 0:
						if(v97) {
							bs97 |= 128;
						} else {
							bs97 &= -129;
						}
						break;
					case 1:
						if(v97) {
							bs97 |= 64;
						} else {
							bs97 &= -65;
						}
						break;
					case 2:
						if(v97) {
							bs97 |= 32;
						} else {
							bs97 &= -33;
						}
						break;
					case 3:
						if(v97) {
							bs97 |= 16;
						} else {
							bs97 &= -17;
						}
						break;
					case 4:
						if(v97) {
							bs97 |= 8;
						} else {
							bs97 &= -9;
						}
						break;
					case 5:
						if(v97) {
							bs97 |= 4;
						} else {
							bs97 &= -5;
						}
						break;
					case 6:
						if(v97) {
							bs97 |= 2;
						} else {
							bs97 &= -3;
						}
						break;
					case 7:
						if(v97) {
							bs97 |= 1;
						} else {
							bs97 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs97;
				break;
			case 46:
				var this99 = 0;
				var bs98 = this99;
				var l98 = "     ".length;
				var _g199 = 0;
				var _g109 = l98;
				while(_g199 < _g109) {
					var i99 = _g199++;
					var no98 = "     ".charCodeAt(i99);
					if(no98 == null) {
						break;
					}
					var v98;
					switch(no98) {
					case 32:
						v98 = false;
						break;
					case 42:
						v98 = true;
						break;
					case 48:
						v98 = false;
						break;
					case 49:
						v98 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i99)));
					}
					switch(i99 - (l98 - 8)) {
					case 0:
						if(v98) {
							bs98 |= 128;
						} else {
							bs98 &= -129;
						}
						break;
					case 1:
						if(v98) {
							bs98 |= 64;
						} else {
							bs98 &= -65;
						}
						break;
					case 2:
						if(v98) {
							bs98 |= 32;
						} else {
							bs98 &= -33;
						}
						break;
					case 3:
						if(v98) {
							bs98 |= 16;
						} else {
							bs98 &= -17;
						}
						break;
					case 4:
						if(v98) {
							bs98 |= 8;
						} else {
							bs98 &= -9;
						}
						break;
					case 5:
						if(v98) {
							bs98 |= 4;
						} else {
							bs98 &= -5;
						}
						break;
					case 6:
						if(v98) {
							bs98 |= 2;
						} else {
							bs98 &= -3;
						}
						break;
					case 7:
						if(v98) {
							bs98 |= 1;
						} else {
							bs98 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs98;
				var this100 = 0;
				var bs99 = this100;
				var l99 = "     ".length;
				var _g1100 = 0;
				var _g200 = l99;
				while(_g1100 < _g200) {
					var i100 = _g1100++;
					var no99 = "     ".charCodeAt(i100);
					if(no99 == null) {
						break;
					}
					var v99;
					switch(no99) {
					case 32:
						v99 = false;
						break;
					case 42:
						v99 = true;
						break;
					case 48:
						v99 = false;
						break;
					case 49:
						v99 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i100)));
					}
					switch(i100 - (l99 - 8)) {
					case 0:
						if(v99) {
							bs99 |= 128;
						} else {
							bs99 &= -129;
						}
						break;
					case 1:
						if(v99) {
							bs99 |= 64;
						} else {
							bs99 &= -65;
						}
						break;
					case 2:
						if(v99) {
							bs99 |= 32;
						} else {
							bs99 &= -33;
						}
						break;
					case 3:
						if(v99) {
							bs99 |= 16;
						} else {
							bs99 &= -17;
						}
						break;
					case 4:
						if(v99) {
							bs99 |= 8;
						} else {
							bs99 &= -9;
						}
						break;
					case 5:
						if(v99) {
							bs99 |= 4;
						} else {
							bs99 &= -5;
						}
						break;
					case 6:
						if(v99) {
							bs99 |= 2;
						} else {
							bs99 &= -3;
						}
						break;
					case 7:
						if(v99) {
							bs99 |= 1;
						} else {
							bs99 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs99;
				var this101 = 0;
				var bs100 = this101;
				var l100 = "     ".length;
				var _g1101 = 0;
				var _g201 = l100;
				while(_g1101 < _g201) {
					var i101 = _g1101++;
					var no100 = "     ".charCodeAt(i101);
					if(no100 == null) {
						break;
					}
					var v100;
					switch(no100) {
					case 32:
						v100 = false;
						break;
					case 42:
						v100 = true;
						break;
					case 48:
						v100 = false;
						break;
					case 49:
						v100 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i101)));
					}
					switch(i101 - (l100 - 8)) {
					case 0:
						if(v100) {
							bs100 |= 128;
						} else {
							bs100 &= -129;
						}
						break;
					case 1:
						if(v100) {
							bs100 |= 64;
						} else {
							bs100 &= -65;
						}
						break;
					case 2:
						if(v100) {
							bs100 |= 32;
						} else {
							bs100 &= -33;
						}
						break;
					case 3:
						if(v100) {
							bs100 |= 16;
						} else {
							bs100 &= -17;
						}
						break;
					case 4:
						if(v100) {
							bs100 |= 8;
						} else {
							bs100 &= -9;
						}
						break;
					case 5:
						if(v100) {
							bs100 |= 4;
						} else {
							bs100 &= -5;
						}
						break;
					case 6:
						if(v100) {
							bs100 |= 2;
						} else {
							bs100 &= -3;
						}
						break;
					case 7:
						if(v100) {
							bs100 |= 1;
						} else {
							bs100 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs100;
				var this102 = 0;
				var bs101 = this102;
				var l101 = "     ".length;
				var _g1102 = 0;
				var _g202 = l101;
				while(_g1102 < _g202) {
					var i102 = _g1102++;
					var no101 = "     ".charCodeAt(i102);
					if(no101 == null) {
						break;
					}
					var v101;
					switch(no101) {
					case 32:
						v101 = false;
						break;
					case 42:
						v101 = true;
						break;
					case 48:
						v101 = false;
						break;
					case 49:
						v101 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i102)));
					}
					switch(i102 - (l101 - 8)) {
					case 0:
						if(v101) {
							bs101 |= 128;
						} else {
							bs101 &= -129;
						}
						break;
					case 1:
						if(v101) {
							bs101 |= 64;
						} else {
							bs101 &= -65;
						}
						break;
					case 2:
						if(v101) {
							bs101 |= 32;
						} else {
							bs101 &= -33;
						}
						break;
					case 3:
						if(v101) {
							bs101 |= 16;
						} else {
							bs101 &= -17;
						}
						break;
					case 4:
						if(v101) {
							bs101 |= 8;
						} else {
							bs101 &= -9;
						}
						break;
					case 5:
						if(v101) {
							bs101 |= 4;
						} else {
							bs101 &= -5;
						}
						break;
					case 6:
						if(v101) {
							bs101 |= 2;
						} else {
							bs101 &= -3;
						}
						break;
					case 7:
						if(v101) {
							bs101 |= 1;
						} else {
							bs101 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs101;
				var this103 = 0;
				var bs102 = this103;
				var l102 = "     ".length;
				var _g1103 = 0;
				var _g203 = l102;
				while(_g1103 < _g203) {
					var i103 = _g1103++;
					var no102 = "     ".charCodeAt(i103);
					if(no102 == null) {
						break;
					}
					var v102;
					switch(no102) {
					case 32:
						v102 = false;
						break;
					case 42:
						v102 = true;
						break;
					case 48:
						v102 = false;
						break;
					case 49:
						v102 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i103)));
					}
					switch(i103 - (l102 - 8)) {
					case 0:
						if(v102) {
							bs102 |= 128;
						} else {
							bs102 &= -129;
						}
						break;
					case 1:
						if(v102) {
							bs102 |= 64;
						} else {
							bs102 &= -65;
						}
						break;
					case 2:
						if(v102) {
							bs102 |= 32;
						} else {
							bs102 &= -33;
						}
						break;
					case 3:
						if(v102) {
							bs102 |= 16;
						} else {
							bs102 &= -17;
						}
						break;
					case 4:
						if(v102) {
							bs102 |= 8;
						} else {
							bs102 &= -9;
						}
						break;
					case 5:
						if(v102) {
							bs102 |= 4;
						} else {
							bs102 &= -5;
						}
						break;
					case 6:
						if(v102) {
							bs102 |= 2;
						} else {
							bs102 &= -3;
						}
						break;
					case 7:
						if(v102) {
							bs102 |= 1;
						} else {
							bs102 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs102;
				var this104 = 0;
				var bs103 = this104;
				var l103 = "  ** ".length;
				var _g1104 = 0;
				var _g204 = l103;
				while(_g1104 < _g204) {
					var i104 = _g1104++;
					var no103 = "  ** ".charCodeAt(i104);
					if(no103 == null) {
						break;
					}
					var v103;
					switch(no103) {
					case 32:
						v103 = false;
						break;
					case 42:
						v103 = true;
						break;
					case 48:
						v103 = false;
						break;
					case 49:
						v103 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i104)));
					}
					switch(i104 - (l103 - 8)) {
					case 0:
						if(v103) {
							bs103 |= 128;
						} else {
							bs103 &= -129;
						}
						break;
					case 1:
						if(v103) {
							bs103 |= 64;
						} else {
							bs103 &= -65;
						}
						break;
					case 2:
						if(v103) {
							bs103 |= 32;
						} else {
							bs103 &= -33;
						}
						break;
					case 3:
						if(v103) {
							bs103 |= 16;
						} else {
							bs103 &= -17;
						}
						break;
					case 4:
						if(v103) {
							bs103 |= 8;
						} else {
							bs103 &= -9;
						}
						break;
					case 5:
						if(v103) {
							bs103 |= 4;
						} else {
							bs103 &= -5;
						}
						break;
					case 6:
						if(v103) {
							bs103 |= 2;
						} else {
							bs103 &= -3;
						}
						break;
					case 7:
						if(v103) {
							bs103 |= 1;
						} else {
							bs103 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs103;
				var this105 = 0;
				var bs104 = this105;
				var l104 = "  ** ".length;
				var _g1105 = 0;
				var _g205 = l104;
				while(_g1105 < _g205) {
					var i105 = _g1105++;
					var no104 = "  ** ".charCodeAt(i105);
					if(no104 == null) {
						break;
					}
					var v104;
					switch(no104) {
					case 32:
						v104 = false;
						break;
					case 42:
						v104 = true;
						break;
					case 48:
						v104 = false;
						break;
					case 49:
						v104 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i105)));
					}
					switch(i105 - (l104 - 8)) {
					case 0:
						if(v104) {
							bs104 |= 128;
						} else {
							bs104 &= -129;
						}
						break;
					case 1:
						if(v104) {
							bs104 |= 64;
						} else {
							bs104 &= -65;
						}
						break;
					case 2:
						if(v104) {
							bs104 |= 32;
						} else {
							bs104 &= -33;
						}
						break;
					case 3:
						if(v104) {
							bs104 |= 16;
						} else {
							bs104 &= -17;
						}
						break;
					case 4:
						if(v104) {
							bs104 |= 8;
						} else {
							bs104 &= -9;
						}
						break;
					case 5:
						if(v104) {
							bs104 |= 4;
						} else {
							bs104 &= -5;
						}
						break;
					case 6:
						if(v104) {
							bs104 |= 2;
						} else {
							bs104 &= -3;
						}
						break;
					case 7:
						if(v104) {
							bs104 |= 1;
						} else {
							bs104 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs104;
				break;
			case 47:
				var this106 = 0;
				var bs105 = this106;
				var l105 = "    *".length;
				var _g1106 = 0;
				var _g206 = l105;
				while(_g1106 < _g206) {
					var i106 = _g1106++;
					var no105 = "    *".charCodeAt(i106);
					if(no105 == null) {
						break;
					}
					var v105;
					switch(no105) {
					case 32:
						v105 = false;
						break;
					case 42:
						v105 = true;
						break;
					case 48:
						v105 = false;
						break;
					case 49:
						v105 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i106)));
					}
					switch(i106 - (l105 - 8)) {
					case 0:
						if(v105) {
							bs105 |= 128;
						} else {
							bs105 &= -129;
						}
						break;
					case 1:
						if(v105) {
							bs105 |= 64;
						} else {
							bs105 &= -65;
						}
						break;
					case 2:
						if(v105) {
							bs105 |= 32;
						} else {
							bs105 &= -33;
						}
						break;
					case 3:
						if(v105) {
							bs105 |= 16;
						} else {
							bs105 &= -17;
						}
						break;
					case 4:
						if(v105) {
							bs105 |= 8;
						} else {
							bs105 &= -9;
						}
						break;
					case 5:
						if(v105) {
							bs105 |= 4;
						} else {
							bs105 &= -5;
						}
						break;
					case 6:
						if(v105) {
							bs105 |= 2;
						} else {
							bs105 &= -3;
						}
						break;
					case 7:
						if(v105) {
							bs105 |= 1;
						} else {
							bs105 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs105;
				var this107 = 0;
				var bs106 = this107;
				var l106 = "   * ".length;
				var _g1107 = 0;
				var _g207 = l106;
				while(_g1107 < _g207) {
					var i107 = _g1107++;
					var no106 = "   * ".charCodeAt(i107);
					if(no106 == null) {
						break;
					}
					var v106;
					switch(no106) {
					case 32:
						v106 = false;
						break;
					case 42:
						v106 = true;
						break;
					case 48:
						v106 = false;
						break;
					case 49:
						v106 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i107)));
					}
					switch(i107 - (l106 - 8)) {
					case 0:
						if(v106) {
							bs106 |= 128;
						} else {
							bs106 &= -129;
						}
						break;
					case 1:
						if(v106) {
							bs106 |= 64;
						} else {
							bs106 &= -65;
						}
						break;
					case 2:
						if(v106) {
							bs106 |= 32;
						} else {
							bs106 &= -33;
						}
						break;
					case 3:
						if(v106) {
							bs106 |= 16;
						} else {
							bs106 &= -17;
						}
						break;
					case 4:
						if(v106) {
							bs106 |= 8;
						} else {
							bs106 &= -9;
						}
						break;
					case 5:
						if(v106) {
							bs106 |= 4;
						} else {
							bs106 &= -5;
						}
						break;
					case 6:
						if(v106) {
							bs106 |= 2;
						} else {
							bs106 &= -3;
						}
						break;
					case 7:
						if(v106) {
							bs106 |= 1;
						} else {
							bs106 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs106;
				var this108 = 0;
				var bs107 = this108;
				var l107 = "   * ".length;
				var _g1108 = 0;
				var _g208 = l107;
				while(_g1108 < _g208) {
					var i108 = _g1108++;
					var no107 = "   * ".charCodeAt(i108);
					if(no107 == null) {
						break;
					}
					var v107;
					switch(no107) {
					case 32:
						v107 = false;
						break;
					case 42:
						v107 = true;
						break;
					case 48:
						v107 = false;
						break;
					case 49:
						v107 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i108)));
					}
					switch(i108 - (l107 - 8)) {
					case 0:
						if(v107) {
							bs107 |= 128;
						} else {
							bs107 &= -129;
						}
						break;
					case 1:
						if(v107) {
							bs107 |= 64;
						} else {
							bs107 &= -65;
						}
						break;
					case 2:
						if(v107) {
							bs107 |= 32;
						} else {
							bs107 &= -33;
						}
						break;
					case 3:
						if(v107) {
							bs107 |= 16;
						} else {
							bs107 &= -17;
						}
						break;
					case 4:
						if(v107) {
							bs107 |= 8;
						} else {
							bs107 &= -9;
						}
						break;
					case 5:
						if(v107) {
							bs107 |= 4;
						} else {
							bs107 &= -5;
						}
						break;
					case 6:
						if(v107) {
							bs107 |= 2;
						} else {
							bs107 &= -3;
						}
						break;
					case 7:
						if(v107) {
							bs107 |= 1;
						} else {
							bs107 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs107;
				var this109 = 0;
				var bs108 = this109;
				var l108 = "  *  ".length;
				var _g1109 = 0;
				var _g209 = l108;
				while(_g1109 < _g209) {
					var i109 = _g1109++;
					var no108 = "  *  ".charCodeAt(i109);
					if(no108 == null) {
						break;
					}
					var v108;
					switch(no108) {
					case 32:
						v108 = false;
						break;
					case 42:
						v108 = true;
						break;
					case 48:
						v108 = false;
						break;
					case 49:
						v108 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i109)));
					}
					switch(i109 - (l108 - 8)) {
					case 0:
						if(v108) {
							bs108 |= 128;
						} else {
							bs108 &= -129;
						}
						break;
					case 1:
						if(v108) {
							bs108 |= 64;
						} else {
							bs108 &= -65;
						}
						break;
					case 2:
						if(v108) {
							bs108 |= 32;
						} else {
							bs108 &= -33;
						}
						break;
					case 3:
						if(v108) {
							bs108 |= 16;
						} else {
							bs108 &= -17;
						}
						break;
					case 4:
						if(v108) {
							bs108 |= 8;
						} else {
							bs108 &= -9;
						}
						break;
					case 5:
						if(v108) {
							bs108 |= 4;
						} else {
							bs108 &= -5;
						}
						break;
					case 6:
						if(v108) {
							bs108 |= 2;
						} else {
							bs108 &= -3;
						}
						break;
					case 7:
						if(v108) {
							bs108 |= 1;
						} else {
							bs108 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs108;
				var this110 = 0;
				var bs109 = this110;
				var l109 = "  *  ".length;
				var _g1110 = 0;
				var _g210 = l109;
				while(_g1110 < _g210) {
					var i110 = _g1110++;
					var no109 = "  *  ".charCodeAt(i110);
					if(no109 == null) {
						break;
					}
					var v109;
					switch(no109) {
					case 32:
						v109 = false;
						break;
					case 42:
						v109 = true;
						break;
					case 48:
						v109 = false;
						break;
					case 49:
						v109 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i110)));
					}
					switch(i110 - (l109 - 8)) {
					case 0:
						if(v109) {
							bs109 |= 128;
						} else {
							bs109 &= -129;
						}
						break;
					case 1:
						if(v109) {
							bs109 |= 64;
						} else {
							bs109 &= -65;
						}
						break;
					case 2:
						if(v109) {
							bs109 |= 32;
						} else {
							bs109 &= -33;
						}
						break;
					case 3:
						if(v109) {
							bs109 |= 16;
						} else {
							bs109 &= -17;
						}
						break;
					case 4:
						if(v109) {
							bs109 |= 8;
						} else {
							bs109 &= -9;
						}
						break;
					case 5:
						if(v109) {
							bs109 |= 4;
						} else {
							bs109 &= -5;
						}
						break;
					case 6:
						if(v109) {
							bs109 |= 2;
						} else {
							bs109 &= -3;
						}
						break;
					case 7:
						if(v109) {
							bs109 |= 1;
						} else {
							bs109 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs109;
				var this111 = 0;
				var bs110 = this111;
				var l110 = " *   ".length;
				var _g1111 = 0;
				var _g211 = l110;
				while(_g1111 < _g211) {
					var i111 = _g1111++;
					var no110 = " *   ".charCodeAt(i111);
					if(no110 == null) {
						break;
					}
					var v110;
					switch(no110) {
					case 32:
						v110 = false;
						break;
					case 42:
						v110 = true;
						break;
					case 48:
						v110 = false;
						break;
					case 49:
						v110 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i111)));
					}
					switch(i111 - (l110 - 8)) {
					case 0:
						if(v110) {
							bs110 |= 128;
						} else {
							bs110 &= -129;
						}
						break;
					case 1:
						if(v110) {
							bs110 |= 64;
						} else {
							bs110 &= -65;
						}
						break;
					case 2:
						if(v110) {
							bs110 |= 32;
						} else {
							bs110 &= -33;
						}
						break;
					case 3:
						if(v110) {
							bs110 |= 16;
						} else {
							bs110 &= -17;
						}
						break;
					case 4:
						if(v110) {
							bs110 |= 8;
						} else {
							bs110 &= -9;
						}
						break;
					case 5:
						if(v110) {
							bs110 |= 4;
						} else {
							bs110 &= -5;
						}
						break;
					case 6:
						if(v110) {
							bs110 |= 2;
						} else {
							bs110 &= -3;
						}
						break;
					case 7:
						if(v110) {
							bs110 |= 1;
						} else {
							bs110 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs110;
				var this112 = 0;
				var bs111 = this112;
				var l111 = "*    ".length;
				var _g1112 = 0;
				var _g212 = l111;
				while(_g1112 < _g212) {
					var i112 = _g1112++;
					var no111 = "*    ".charCodeAt(i112);
					if(no111 == null) {
						break;
					}
					var v111;
					switch(no111) {
					case 32:
						v111 = false;
						break;
					case 42:
						v111 = true;
						break;
					case 48:
						v111 = false;
						break;
					case 49:
						v111 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i112)));
					}
					switch(i112 - (l111 - 8)) {
					case 0:
						if(v111) {
							bs111 |= 128;
						} else {
							bs111 &= -129;
						}
						break;
					case 1:
						if(v111) {
							bs111 |= 64;
						} else {
							bs111 &= -65;
						}
						break;
					case 2:
						if(v111) {
							bs111 |= 32;
						} else {
							bs111 &= -33;
						}
						break;
					case 3:
						if(v111) {
							bs111 |= 16;
						} else {
							bs111 &= -17;
						}
						break;
					case 4:
						if(v111) {
							bs111 |= 8;
						} else {
							bs111 &= -9;
						}
						break;
					case 5:
						if(v111) {
							bs111 |= 4;
						} else {
							bs111 &= -5;
						}
						break;
					case 6:
						if(v111) {
							bs111 |= 2;
						} else {
							bs111 &= -3;
						}
						break;
					case 7:
						if(v111) {
							bs111 |= 1;
						} else {
							bs111 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs111;
				break;
			case 48:
				var this113 = 0;
				var bs112 = this113;
				var l112 = " *** ".length;
				var _g1113 = 0;
				var _g213 = l112;
				while(_g1113 < _g213) {
					var i113 = _g1113++;
					var no112 = " *** ".charCodeAt(i113);
					if(no112 == null) {
						break;
					}
					var v112;
					switch(no112) {
					case 32:
						v112 = false;
						break;
					case 42:
						v112 = true;
						break;
					case 48:
						v112 = false;
						break;
					case 49:
						v112 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i113)));
					}
					switch(i113 - (l112 - 8)) {
					case 0:
						if(v112) {
							bs112 |= 128;
						} else {
							bs112 &= -129;
						}
						break;
					case 1:
						if(v112) {
							bs112 |= 64;
						} else {
							bs112 &= -65;
						}
						break;
					case 2:
						if(v112) {
							bs112 |= 32;
						} else {
							bs112 &= -33;
						}
						break;
					case 3:
						if(v112) {
							bs112 |= 16;
						} else {
							bs112 &= -17;
						}
						break;
					case 4:
						if(v112) {
							bs112 |= 8;
						} else {
							bs112 &= -9;
						}
						break;
					case 5:
						if(v112) {
							bs112 |= 4;
						} else {
							bs112 &= -5;
						}
						break;
					case 6:
						if(v112) {
							bs112 |= 2;
						} else {
							bs112 &= -3;
						}
						break;
					case 7:
						if(v112) {
							bs112 |= 1;
						} else {
							bs112 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs112;
				var this114 = 0;
				var bs113 = this114;
				var l113 = "*   *".length;
				var _g1114 = 0;
				var _g214 = l113;
				while(_g1114 < _g214) {
					var i114 = _g1114++;
					var no113 = "*   *".charCodeAt(i114);
					if(no113 == null) {
						break;
					}
					var v113;
					switch(no113) {
					case 32:
						v113 = false;
						break;
					case 42:
						v113 = true;
						break;
					case 48:
						v113 = false;
						break;
					case 49:
						v113 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i114)));
					}
					switch(i114 - (l113 - 8)) {
					case 0:
						if(v113) {
							bs113 |= 128;
						} else {
							bs113 &= -129;
						}
						break;
					case 1:
						if(v113) {
							bs113 |= 64;
						} else {
							bs113 &= -65;
						}
						break;
					case 2:
						if(v113) {
							bs113 |= 32;
						} else {
							bs113 &= -33;
						}
						break;
					case 3:
						if(v113) {
							bs113 |= 16;
						} else {
							bs113 &= -17;
						}
						break;
					case 4:
						if(v113) {
							bs113 |= 8;
						} else {
							bs113 &= -9;
						}
						break;
					case 5:
						if(v113) {
							bs113 |= 4;
						} else {
							bs113 &= -5;
						}
						break;
					case 6:
						if(v113) {
							bs113 |= 2;
						} else {
							bs113 &= -3;
						}
						break;
					case 7:
						if(v113) {
							bs113 |= 1;
						} else {
							bs113 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs113;
				var this115 = 0;
				var bs114 = this115;
				var l114 = "*  **".length;
				var _g1115 = 0;
				var _g215 = l114;
				while(_g1115 < _g215) {
					var i115 = _g1115++;
					var no114 = "*  **".charCodeAt(i115);
					if(no114 == null) {
						break;
					}
					var v114;
					switch(no114) {
					case 32:
						v114 = false;
						break;
					case 42:
						v114 = true;
						break;
					case 48:
						v114 = false;
						break;
					case 49:
						v114 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  **".charCodeAt(i115)));
					}
					switch(i115 - (l114 - 8)) {
					case 0:
						if(v114) {
							bs114 |= 128;
						} else {
							bs114 &= -129;
						}
						break;
					case 1:
						if(v114) {
							bs114 |= 64;
						} else {
							bs114 &= -65;
						}
						break;
					case 2:
						if(v114) {
							bs114 |= 32;
						} else {
							bs114 &= -33;
						}
						break;
					case 3:
						if(v114) {
							bs114 |= 16;
						} else {
							bs114 &= -17;
						}
						break;
					case 4:
						if(v114) {
							bs114 |= 8;
						} else {
							bs114 &= -9;
						}
						break;
					case 5:
						if(v114) {
							bs114 |= 4;
						} else {
							bs114 &= -5;
						}
						break;
					case 6:
						if(v114) {
							bs114 |= 2;
						} else {
							bs114 &= -3;
						}
						break;
					case 7:
						if(v114) {
							bs114 |= 1;
						} else {
							bs114 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs114;
				var this116 = 0;
				var bs115 = this116;
				var l115 = "* * *".length;
				var _g1116 = 0;
				var _g216 = l115;
				while(_g1116 < _g216) {
					var i116 = _g1116++;
					var no115 = "* * *".charCodeAt(i116);
					if(no115 == null) {
						break;
					}
					var v115;
					switch(no115) {
					case 32:
						v115 = false;
						break;
					case 42:
						v115 = true;
						break;
					case 48:
						v115 = false;
						break;
					case 49:
						v115 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i116)));
					}
					switch(i116 - (l115 - 8)) {
					case 0:
						if(v115) {
							bs115 |= 128;
						} else {
							bs115 &= -129;
						}
						break;
					case 1:
						if(v115) {
							bs115 |= 64;
						} else {
							bs115 &= -65;
						}
						break;
					case 2:
						if(v115) {
							bs115 |= 32;
						} else {
							bs115 &= -33;
						}
						break;
					case 3:
						if(v115) {
							bs115 |= 16;
						} else {
							bs115 &= -17;
						}
						break;
					case 4:
						if(v115) {
							bs115 |= 8;
						} else {
							bs115 &= -9;
						}
						break;
					case 5:
						if(v115) {
							bs115 |= 4;
						} else {
							bs115 &= -5;
						}
						break;
					case 6:
						if(v115) {
							bs115 |= 2;
						} else {
							bs115 &= -3;
						}
						break;
					case 7:
						if(v115) {
							bs115 |= 1;
						} else {
							bs115 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs115;
				var this117 = 0;
				var bs116 = this117;
				var l116 = "**  *".length;
				var _g1117 = 0;
				var _g217 = l116;
				while(_g1117 < _g217) {
					var i117 = _g1117++;
					var no116 = "**  *".charCodeAt(i117);
					if(no116 == null) {
						break;
					}
					var v116;
					switch(no116) {
					case 32:
						v116 = false;
						break;
					case 42:
						v116 = true;
						break;
					case 48:
						v116 = false;
						break;
					case 49:
						v116 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i117)));
					}
					switch(i117 - (l116 - 8)) {
					case 0:
						if(v116) {
							bs116 |= 128;
						} else {
							bs116 &= -129;
						}
						break;
					case 1:
						if(v116) {
							bs116 |= 64;
						} else {
							bs116 &= -65;
						}
						break;
					case 2:
						if(v116) {
							bs116 |= 32;
						} else {
							bs116 &= -33;
						}
						break;
					case 3:
						if(v116) {
							bs116 |= 16;
						} else {
							bs116 &= -17;
						}
						break;
					case 4:
						if(v116) {
							bs116 |= 8;
						} else {
							bs116 &= -9;
						}
						break;
					case 5:
						if(v116) {
							bs116 |= 4;
						} else {
							bs116 &= -5;
						}
						break;
					case 6:
						if(v116) {
							bs116 |= 2;
						} else {
							bs116 &= -3;
						}
						break;
					case 7:
						if(v116) {
							bs116 |= 1;
						} else {
							bs116 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs116;
				var this118 = 0;
				var bs117 = this118;
				var l117 = "*   *".length;
				var _g1118 = 0;
				var _g218 = l117;
				while(_g1118 < _g218) {
					var i118 = _g1118++;
					var no117 = "*   *".charCodeAt(i118);
					if(no117 == null) {
						break;
					}
					var v117;
					switch(no117) {
					case 32:
						v117 = false;
						break;
					case 42:
						v117 = true;
						break;
					case 48:
						v117 = false;
						break;
					case 49:
						v117 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i118)));
					}
					switch(i118 - (l117 - 8)) {
					case 0:
						if(v117) {
							bs117 |= 128;
						} else {
							bs117 &= -129;
						}
						break;
					case 1:
						if(v117) {
							bs117 |= 64;
						} else {
							bs117 &= -65;
						}
						break;
					case 2:
						if(v117) {
							bs117 |= 32;
						} else {
							bs117 &= -33;
						}
						break;
					case 3:
						if(v117) {
							bs117 |= 16;
						} else {
							bs117 &= -17;
						}
						break;
					case 4:
						if(v117) {
							bs117 |= 8;
						} else {
							bs117 &= -9;
						}
						break;
					case 5:
						if(v117) {
							bs117 |= 4;
						} else {
							bs117 &= -5;
						}
						break;
					case 6:
						if(v117) {
							bs117 |= 2;
						} else {
							bs117 &= -3;
						}
						break;
					case 7:
						if(v117) {
							bs117 |= 1;
						} else {
							bs117 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs117;
				var this119 = 0;
				var bs118 = this119;
				var l118 = " *** ".length;
				var _g1119 = 0;
				var _g219 = l118;
				while(_g1119 < _g219) {
					var i119 = _g1119++;
					var no118 = " *** ".charCodeAt(i119);
					if(no118 == null) {
						break;
					}
					var v118;
					switch(no118) {
					case 32:
						v118 = false;
						break;
					case 42:
						v118 = true;
						break;
					case 48:
						v118 = false;
						break;
					case 49:
						v118 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i119)));
					}
					switch(i119 - (l118 - 8)) {
					case 0:
						if(v118) {
							bs118 |= 128;
						} else {
							bs118 &= -129;
						}
						break;
					case 1:
						if(v118) {
							bs118 |= 64;
						} else {
							bs118 &= -65;
						}
						break;
					case 2:
						if(v118) {
							bs118 |= 32;
						} else {
							bs118 &= -33;
						}
						break;
					case 3:
						if(v118) {
							bs118 |= 16;
						} else {
							bs118 &= -17;
						}
						break;
					case 4:
						if(v118) {
							bs118 |= 8;
						} else {
							bs118 &= -9;
						}
						break;
					case 5:
						if(v118) {
							bs118 |= 4;
						} else {
							bs118 &= -5;
						}
						break;
					case 6:
						if(v118) {
							bs118 |= 2;
						} else {
							bs118 &= -3;
						}
						break;
					case 7:
						if(v118) {
							bs118 |= 1;
						} else {
							bs118 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs118;
				break;
			case 49:
				var this120 = 0;
				var bs119 = this120;
				var l119 = "  *  ".length;
				var _g1120 = 0;
				var _g220 = l119;
				while(_g1120 < _g220) {
					var i120 = _g1120++;
					var no119 = "  *  ".charCodeAt(i120);
					if(no119 == null) {
						break;
					}
					var v119;
					switch(no119) {
					case 32:
						v119 = false;
						break;
					case 42:
						v119 = true;
						break;
					case 48:
						v119 = false;
						break;
					case 49:
						v119 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i120)));
					}
					switch(i120 - (l119 - 8)) {
					case 0:
						if(v119) {
							bs119 |= 128;
						} else {
							bs119 &= -129;
						}
						break;
					case 1:
						if(v119) {
							bs119 |= 64;
						} else {
							bs119 &= -65;
						}
						break;
					case 2:
						if(v119) {
							bs119 |= 32;
						} else {
							bs119 &= -33;
						}
						break;
					case 3:
						if(v119) {
							bs119 |= 16;
						} else {
							bs119 &= -17;
						}
						break;
					case 4:
						if(v119) {
							bs119 |= 8;
						} else {
							bs119 &= -9;
						}
						break;
					case 5:
						if(v119) {
							bs119 |= 4;
						} else {
							bs119 &= -5;
						}
						break;
					case 6:
						if(v119) {
							bs119 |= 2;
						} else {
							bs119 &= -3;
						}
						break;
					case 7:
						if(v119) {
							bs119 |= 1;
						} else {
							bs119 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs119;
				var this121 = 0;
				var bs120 = this121;
				var l120 = " **  ".length;
				var _g1121 = 0;
				var _g221 = l120;
				while(_g1121 < _g221) {
					var i121 = _g1121++;
					var no120 = " **  ".charCodeAt(i121);
					if(no120 == null) {
						break;
					}
					var v120;
					switch(no120) {
					case 32:
						v120 = false;
						break;
					case 42:
						v120 = true;
						break;
					case 48:
						v120 = false;
						break;
					case 49:
						v120 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i121)));
					}
					switch(i121 - (l120 - 8)) {
					case 0:
						if(v120) {
							bs120 |= 128;
						} else {
							bs120 &= -129;
						}
						break;
					case 1:
						if(v120) {
							bs120 |= 64;
						} else {
							bs120 &= -65;
						}
						break;
					case 2:
						if(v120) {
							bs120 |= 32;
						} else {
							bs120 &= -33;
						}
						break;
					case 3:
						if(v120) {
							bs120 |= 16;
						} else {
							bs120 &= -17;
						}
						break;
					case 4:
						if(v120) {
							bs120 |= 8;
						} else {
							bs120 &= -9;
						}
						break;
					case 5:
						if(v120) {
							bs120 |= 4;
						} else {
							bs120 &= -5;
						}
						break;
					case 6:
						if(v120) {
							bs120 |= 2;
						} else {
							bs120 &= -3;
						}
						break;
					case 7:
						if(v120) {
							bs120 |= 1;
						} else {
							bs120 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs120;
				var this122 = 0;
				var bs121 = this122;
				var l121 = "  *  ".length;
				var _g1122 = 0;
				var _g222 = l121;
				while(_g1122 < _g222) {
					var i122 = _g1122++;
					var no121 = "  *  ".charCodeAt(i122);
					if(no121 == null) {
						break;
					}
					var v121;
					switch(no121) {
					case 32:
						v121 = false;
						break;
					case 42:
						v121 = true;
						break;
					case 48:
						v121 = false;
						break;
					case 49:
						v121 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i122)));
					}
					switch(i122 - (l121 - 8)) {
					case 0:
						if(v121) {
							bs121 |= 128;
						} else {
							bs121 &= -129;
						}
						break;
					case 1:
						if(v121) {
							bs121 |= 64;
						} else {
							bs121 &= -65;
						}
						break;
					case 2:
						if(v121) {
							bs121 |= 32;
						} else {
							bs121 &= -33;
						}
						break;
					case 3:
						if(v121) {
							bs121 |= 16;
						} else {
							bs121 &= -17;
						}
						break;
					case 4:
						if(v121) {
							bs121 |= 8;
						} else {
							bs121 &= -9;
						}
						break;
					case 5:
						if(v121) {
							bs121 |= 4;
						} else {
							bs121 &= -5;
						}
						break;
					case 6:
						if(v121) {
							bs121 |= 2;
						} else {
							bs121 &= -3;
						}
						break;
					case 7:
						if(v121) {
							bs121 |= 1;
						} else {
							bs121 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs121;
				var this123 = 0;
				var bs122 = this123;
				var l122 = "  *  ".length;
				var _g1123 = 0;
				var _g223 = l122;
				while(_g1123 < _g223) {
					var i123 = _g1123++;
					var no122 = "  *  ".charCodeAt(i123);
					if(no122 == null) {
						break;
					}
					var v122;
					switch(no122) {
					case 32:
						v122 = false;
						break;
					case 42:
						v122 = true;
						break;
					case 48:
						v122 = false;
						break;
					case 49:
						v122 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i123)));
					}
					switch(i123 - (l122 - 8)) {
					case 0:
						if(v122) {
							bs122 |= 128;
						} else {
							bs122 &= -129;
						}
						break;
					case 1:
						if(v122) {
							bs122 |= 64;
						} else {
							bs122 &= -65;
						}
						break;
					case 2:
						if(v122) {
							bs122 |= 32;
						} else {
							bs122 &= -33;
						}
						break;
					case 3:
						if(v122) {
							bs122 |= 16;
						} else {
							bs122 &= -17;
						}
						break;
					case 4:
						if(v122) {
							bs122 |= 8;
						} else {
							bs122 &= -9;
						}
						break;
					case 5:
						if(v122) {
							bs122 |= 4;
						} else {
							bs122 &= -5;
						}
						break;
					case 6:
						if(v122) {
							bs122 |= 2;
						} else {
							bs122 &= -3;
						}
						break;
					case 7:
						if(v122) {
							bs122 |= 1;
						} else {
							bs122 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs122;
				var this124 = 0;
				var bs123 = this124;
				var l123 = "  *  ".length;
				var _g1124 = 0;
				var _g224 = l123;
				while(_g1124 < _g224) {
					var i124 = _g1124++;
					var no123 = "  *  ".charCodeAt(i124);
					if(no123 == null) {
						break;
					}
					var v123;
					switch(no123) {
					case 32:
						v123 = false;
						break;
					case 42:
						v123 = true;
						break;
					case 48:
						v123 = false;
						break;
					case 49:
						v123 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i124)));
					}
					switch(i124 - (l123 - 8)) {
					case 0:
						if(v123) {
							bs123 |= 128;
						} else {
							bs123 &= -129;
						}
						break;
					case 1:
						if(v123) {
							bs123 |= 64;
						} else {
							bs123 &= -65;
						}
						break;
					case 2:
						if(v123) {
							bs123 |= 32;
						} else {
							bs123 &= -33;
						}
						break;
					case 3:
						if(v123) {
							bs123 |= 16;
						} else {
							bs123 &= -17;
						}
						break;
					case 4:
						if(v123) {
							bs123 |= 8;
						} else {
							bs123 &= -9;
						}
						break;
					case 5:
						if(v123) {
							bs123 |= 4;
						} else {
							bs123 &= -5;
						}
						break;
					case 6:
						if(v123) {
							bs123 |= 2;
						} else {
							bs123 &= -3;
						}
						break;
					case 7:
						if(v123) {
							bs123 |= 1;
						} else {
							bs123 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs123;
				var this125 = 0;
				var bs124 = this125;
				var l124 = "  *  ".length;
				var _g1125 = 0;
				var _g225 = l124;
				while(_g1125 < _g225) {
					var i125 = _g1125++;
					var no124 = "  *  ".charCodeAt(i125);
					if(no124 == null) {
						break;
					}
					var v124;
					switch(no124) {
					case 32:
						v124 = false;
						break;
					case 42:
						v124 = true;
						break;
					case 48:
						v124 = false;
						break;
					case 49:
						v124 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i125)));
					}
					switch(i125 - (l124 - 8)) {
					case 0:
						if(v124) {
							bs124 |= 128;
						} else {
							bs124 &= -129;
						}
						break;
					case 1:
						if(v124) {
							bs124 |= 64;
						} else {
							bs124 &= -65;
						}
						break;
					case 2:
						if(v124) {
							bs124 |= 32;
						} else {
							bs124 &= -33;
						}
						break;
					case 3:
						if(v124) {
							bs124 |= 16;
						} else {
							bs124 &= -17;
						}
						break;
					case 4:
						if(v124) {
							bs124 |= 8;
						} else {
							bs124 &= -9;
						}
						break;
					case 5:
						if(v124) {
							bs124 |= 4;
						} else {
							bs124 &= -5;
						}
						break;
					case 6:
						if(v124) {
							bs124 |= 2;
						} else {
							bs124 &= -3;
						}
						break;
					case 7:
						if(v124) {
							bs124 |= 1;
						} else {
							bs124 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs124;
				var this126 = 0;
				var bs125 = this126;
				var l125 = " *** ".length;
				var _g1126 = 0;
				var _g226 = l125;
				while(_g1126 < _g226) {
					var i126 = _g1126++;
					var no125 = " *** ".charCodeAt(i126);
					if(no125 == null) {
						break;
					}
					var v125;
					switch(no125) {
					case 32:
						v125 = false;
						break;
					case 42:
						v125 = true;
						break;
					case 48:
						v125 = false;
						break;
					case 49:
						v125 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i126)));
					}
					switch(i126 - (l125 - 8)) {
					case 0:
						if(v125) {
							bs125 |= 128;
						} else {
							bs125 &= -129;
						}
						break;
					case 1:
						if(v125) {
							bs125 |= 64;
						} else {
							bs125 &= -65;
						}
						break;
					case 2:
						if(v125) {
							bs125 |= 32;
						} else {
							bs125 &= -33;
						}
						break;
					case 3:
						if(v125) {
							bs125 |= 16;
						} else {
							bs125 &= -17;
						}
						break;
					case 4:
						if(v125) {
							bs125 |= 8;
						} else {
							bs125 &= -9;
						}
						break;
					case 5:
						if(v125) {
							bs125 |= 4;
						} else {
							bs125 &= -5;
						}
						break;
					case 6:
						if(v125) {
							bs125 |= 2;
						} else {
							bs125 &= -3;
						}
						break;
					case 7:
						if(v125) {
							bs125 |= 1;
						} else {
							bs125 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs125;
				break;
			case 50:
				var this127 = 0;
				var bs126 = this127;
				var l126 = " *** ".length;
				var _g1127 = 0;
				var _g227 = l126;
				while(_g1127 < _g227) {
					var i127 = _g1127++;
					var no126 = " *** ".charCodeAt(i127);
					if(no126 == null) {
						break;
					}
					var v126;
					switch(no126) {
					case 32:
						v126 = false;
						break;
					case 42:
						v126 = true;
						break;
					case 48:
						v126 = false;
						break;
					case 49:
						v126 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i127)));
					}
					switch(i127 - (l126 - 8)) {
					case 0:
						if(v126) {
							bs126 |= 128;
						} else {
							bs126 &= -129;
						}
						break;
					case 1:
						if(v126) {
							bs126 |= 64;
						} else {
							bs126 &= -65;
						}
						break;
					case 2:
						if(v126) {
							bs126 |= 32;
						} else {
							bs126 &= -33;
						}
						break;
					case 3:
						if(v126) {
							bs126 |= 16;
						} else {
							bs126 &= -17;
						}
						break;
					case 4:
						if(v126) {
							bs126 |= 8;
						} else {
							bs126 &= -9;
						}
						break;
					case 5:
						if(v126) {
							bs126 |= 4;
						} else {
							bs126 &= -5;
						}
						break;
					case 6:
						if(v126) {
							bs126 |= 2;
						} else {
							bs126 &= -3;
						}
						break;
					case 7:
						if(v126) {
							bs126 |= 1;
						} else {
							bs126 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs126;
				var this128 = 0;
				var bs127 = this128;
				var l127 = "*   *".length;
				var _g1128 = 0;
				var _g228 = l127;
				while(_g1128 < _g228) {
					var i128 = _g1128++;
					var no127 = "*   *".charCodeAt(i128);
					if(no127 == null) {
						break;
					}
					var v127;
					switch(no127) {
					case 32:
						v127 = false;
						break;
					case 42:
						v127 = true;
						break;
					case 48:
						v127 = false;
						break;
					case 49:
						v127 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i128)));
					}
					switch(i128 - (l127 - 8)) {
					case 0:
						if(v127) {
							bs127 |= 128;
						} else {
							bs127 &= -129;
						}
						break;
					case 1:
						if(v127) {
							bs127 |= 64;
						} else {
							bs127 &= -65;
						}
						break;
					case 2:
						if(v127) {
							bs127 |= 32;
						} else {
							bs127 &= -33;
						}
						break;
					case 3:
						if(v127) {
							bs127 |= 16;
						} else {
							bs127 &= -17;
						}
						break;
					case 4:
						if(v127) {
							bs127 |= 8;
						} else {
							bs127 &= -9;
						}
						break;
					case 5:
						if(v127) {
							bs127 |= 4;
						} else {
							bs127 &= -5;
						}
						break;
					case 6:
						if(v127) {
							bs127 |= 2;
						} else {
							bs127 &= -3;
						}
						break;
					case 7:
						if(v127) {
							bs127 |= 1;
						} else {
							bs127 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs127;
				var this129 = 0;
				var bs128 = this129;
				var l128 = "    *".length;
				var _g1129 = 0;
				var _g229 = l128;
				while(_g1129 < _g229) {
					var i129 = _g1129++;
					var no128 = "    *".charCodeAt(i129);
					if(no128 == null) {
						break;
					}
					var v128;
					switch(no128) {
					case 32:
						v128 = false;
						break;
					case 42:
						v128 = true;
						break;
					case 48:
						v128 = false;
						break;
					case 49:
						v128 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i129)));
					}
					switch(i129 - (l128 - 8)) {
					case 0:
						if(v128) {
							bs128 |= 128;
						} else {
							bs128 &= -129;
						}
						break;
					case 1:
						if(v128) {
							bs128 |= 64;
						} else {
							bs128 &= -65;
						}
						break;
					case 2:
						if(v128) {
							bs128 |= 32;
						} else {
							bs128 &= -33;
						}
						break;
					case 3:
						if(v128) {
							bs128 |= 16;
						} else {
							bs128 &= -17;
						}
						break;
					case 4:
						if(v128) {
							bs128 |= 8;
						} else {
							bs128 &= -9;
						}
						break;
					case 5:
						if(v128) {
							bs128 |= 4;
						} else {
							bs128 &= -5;
						}
						break;
					case 6:
						if(v128) {
							bs128 |= 2;
						} else {
							bs128 &= -3;
						}
						break;
					case 7:
						if(v128) {
							bs128 |= 1;
						} else {
							bs128 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs128;
				var this130 = 0;
				var bs129 = this130;
				var l129 = "  *  ".length;
				var _g1130 = 0;
				var _g230 = l129;
				while(_g1130 < _g230) {
					var i130 = _g1130++;
					var no129 = "  *  ".charCodeAt(i130);
					if(no129 == null) {
						break;
					}
					var v129;
					switch(no129) {
					case 32:
						v129 = false;
						break;
					case 42:
						v129 = true;
						break;
					case 48:
						v129 = false;
						break;
					case 49:
						v129 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i130)));
					}
					switch(i130 - (l129 - 8)) {
					case 0:
						if(v129) {
							bs129 |= 128;
						} else {
							bs129 &= -129;
						}
						break;
					case 1:
						if(v129) {
							bs129 |= 64;
						} else {
							bs129 &= -65;
						}
						break;
					case 2:
						if(v129) {
							bs129 |= 32;
						} else {
							bs129 &= -33;
						}
						break;
					case 3:
						if(v129) {
							bs129 |= 16;
						} else {
							bs129 &= -17;
						}
						break;
					case 4:
						if(v129) {
							bs129 |= 8;
						} else {
							bs129 &= -9;
						}
						break;
					case 5:
						if(v129) {
							bs129 |= 4;
						} else {
							bs129 &= -5;
						}
						break;
					case 6:
						if(v129) {
							bs129 |= 2;
						} else {
							bs129 &= -3;
						}
						break;
					case 7:
						if(v129) {
							bs129 |= 1;
						} else {
							bs129 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs129;
				var this131 = 0;
				var bs130 = this131;
				var l130 = " *   ".length;
				var _g1131 = 0;
				var _g231 = l130;
				while(_g1131 < _g231) {
					var i131 = _g1131++;
					var no130 = " *   ".charCodeAt(i131);
					if(no130 == null) {
						break;
					}
					var v130;
					switch(no130) {
					case 32:
						v130 = false;
						break;
					case 42:
						v130 = true;
						break;
					case 48:
						v130 = false;
						break;
					case 49:
						v130 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i131)));
					}
					switch(i131 - (l130 - 8)) {
					case 0:
						if(v130) {
							bs130 |= 128;
						} else {
							bs130 &= -129;
						}
						break;
					case 1:
						if(v130) {
							bs130 |= 64;
						} else {
							bs130 &= -65;
						}
						break;
					case 2:
						if(v130) {
							bs130 |= 32;
						} else {
							bs130 &= -33;
						}
						break;
					case 3:
						if(v130) {
							bs130 |= 16;
						} else {
							bs130 &= -17;
						}
						break;
					case 4:
						if(v130) {
							bs130 |= 8;
						} else {
							bs130 &= -9;
						}
						break;
					case 5:
						if(v130) {
							bs130 |= 4;
						} else {
							bs130 &= -5;
						}
						break;
					case 6:
						if(v130) {
							bs130 |= 2;
						} else {
							bs130 &= -3;
						}
						break;
					case 7:
						if(v130) {
							bs130 |= 1;
						} else {
							bs130 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs130;
				var this132 = 0;
				var bs131 = this132;
				var l131 = "*    ".length;
				var _g1132 = 0;
				var _g232 = l131;
				while(_g1132 < _g232) {
					var i132 = _g1132++;
					var no131 = "*    ".charCodeAt(i132);
					if(no131 == null) {
						break;
					}
					var v131;
					switch(no131) {
					case 32:
						v131 = false;
						break;
					case 42:
						v131 = true;
						break;
					case 48:
						v131 = false;
						break;
					case 49:
						v131 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i132)));
					}
					switch(i132 - (l131 - 8)) {
					case 0:
						if(v131) {
							bs131 |= 128;
						} else {
							bs131 &= -129;
						}
						break;
					case 1:
						if(v131) {
							bs131 |= 64;
						} else {
							bs131 &= -65;
						}
						break;
					case 2:
						if(v131) {
							bs131 |= 32;
						} else {
							bs131 &= -33;
						}
						break;
					case 3:
						if(v131) {
							bs131 |= 16;
						} else {
							bs131 &= -17;
						}
						break;
					case 4:
						if(v131) {
							bs131 |= 8;
						} else {
							bs131 &= -9;
						}
						break;
					case 5:
						if(v131) {
							bs131 |= 4;
						} else {
							bs131 &= -5;
						}
						break;
					case 6:
						if(v131) {
							bs131 |= 2;
						} else {
							bs131 &= -3;
						}
						break;
					case 7:
						if(v131) {
							bs131 |= 1;
						} else {
							bs131 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs131;
				var this133 = 0;
				var bs132 = this133;
				var l132 = "*****".length;
				var _g1133 = 0;
				var _g233 = l132;
				while(_g1133 < _g233) {
					var i133 = _g1133++;
					var no132 = "*****".charCodeAt(i133);
					if(no132 == null) {
						break;
					}
					var v132;
					switch(no132) {
					case 32:
						v132 = false;
						break;
					case 42:
						v132 = true;
						break;
					case 48:
						v132 = false;
						break;
					case 49:
						v132 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i133)));
					}
					switch(i133 - (l132 - 8)) {
					case 0:
						if(v132) {
							bs132 |= 128;
						} else {
							bs132 &= -129;
						}
						break;
					case 1:
						if(v132) {
							bs132 |= 64;
						} else {
							bs132 &= -65;
						}
						break;
					case 2:
						if(v132) {
							bs132 |= 32;
						} else {
							bs132 &= -33;
						}
						break;
					case 3:
						if(v132) {
							bs132 |= 16;
						} else {
							bs132 &= -17;
						}
						break;
					case 4:
						if(v132) {
							bs132 |= 8;
						} else {
							bs132 &= -9;
						}
						break;
					case 5:
						if(v132) {
							bs132 |= 4;
						} else {
							bs132 &= -5;
						}
						break;
					case 6:
						if(v132) {
							bs132 |= 2;
						} else {
							bs132 &= -3;
						}
						break;
					case 7:
						if(v132) {
							bs132 |= 1;
						} else {
							bs132 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs132;
				break;
			case 51:
				var this134 = 0;
				var bs133 = this134;
				var l133 = "*****".length;
				var _g1134 = 0;
				var _g234 = l133;
				while(_g1134 < _g234) {
					var i134 = _g1134++;
					var no133 = "*****".charCodeAt(i134);
					if(no133 == null) {
						break;
					}
					var v133;
					switch(no133) {
					case 32:
						v133 = false;
						break;
					case 42:
						v133 = true;
						break;
					case 48:
						v133 = false;
						break;
					case 49:
						v133 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i134)));
					}
					switch(i134 - (l133 - 8)) {
					case 0:
						if(v133) {
							bs133 |= 128;
						} else {
							bs133 &= -129;
						}
						break;
					case 1:
						if(v133) {
							bs133 |= 64;
						} else {
							bs133 &= -65;
						}
						break;
					case 2:
						if(v133) {
							bs133 |= 32;
						} else {
							bs133 &= -33;
						}
						break;
					case 3:
						if(v133) {
							bs133 |= 16;
						} else {
							bs133 &= -17;
						}
						break;
					case 4:
						if(v133) {
							bs133 |= 8;
						} else {
							bs133 &= -9;
						}
						break;
					case 5:
						if(v133) {
							bs133 |= 4;
						} else {
							bs133 &= -5;
						}
						break;
					case 6:
						if(v133) {
							bs133 |= 2;
						} else {
							bs133 &= -3;
						}
						break;
					case 7:
						if(v133) {
							bs133 |= 1;
						} else {
							bs133 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs133;
				var this135 = 0;
				var bs134 = this135;
				var l134 = "   * ".length;
				var _g1135 = 0;
				var _g235 = l134;
				while(_g1135 < _g235) {
					var i135 = _g1135++;
					var no134 = "   * ".charCodeAt(i135);
					if(no134 == null) {
						break;
					}
					var v134;
					switch(no134) {
					case 32:
						v134 = false;
						break;
					case 42:
						v134 = true;
						break;
					case 48:
						v134 = false;
						break;
					case 49:
						v134 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i135)));
					}
					switch(i135 - (l134 - 8)) {
					case 0:
						if(v134) {
							bs134 |= 128;
						} else {
							bs134 &= -129;
						}
						break;
					case 1:
						if(v134) {
							bs134 |= 64;
						} else {
							bs134 &= -65;
						}
						break;
					case 2:
						if(v134) {
							bs134 |= 32;
						} else {
							bs134 &= -33;
						}
						break;
					case 3:
						if(v134) {
							bs134 |= 16;
						} else {
							bs134 &= -17;
						}
						break;
					case 4:
						if(v134) {
							bs134 |= 8;
						} else {
							bs134 &= -9;
						}
						break;
					case 5:
						if(v134) {
							bs134 |= 4;
						} else {
							bs134 &= -5;
						}
						break;
					case 6:
						if(v134) {
							bs134 |= 2;
						} else {
							bs134 &= -3;
						}
						break;
					case 7:
						if(v134) {
							bs134 |= 1;
						} else {
							bs134 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs134;
				var this136 = 0;
				var bs135 = this136;
				var l135 = "  *  ".length;
				var _g1136 = 0;
				var _g236 = l135;
				while(_g1136 < _g236) {
					var i136 = _g1136++;
					var no135 = "  *  ".charCodeAt(i136);
					if(no135 == null) {
						break;
					}
					var v135;
					switch(no135) {
					case 32:
						v135 = false;
						break;
					case 42:
						v135 = true;
						break;
					case 48:
						v135 = false;
						break;
					case 49:
						v135 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i136)));
					}
					switch(i136 - (l135 - 8)) {
					case 0:
						if(v135) {
							bs135 |= 128;
						} else {
							bs135 &= -129;
						}
						break;
					case 1:
						if(v135) {
							bs135 |= 64;
						} else {
							bs135 &= -65;
						}
						break;
					case 2:
						if(v135) {
							bs135 |= 32;
						} else {
							bs135 &= -33;
						}
						break;
					case 3:
						if(v135) {
							bs135 |= 16;
						} else {
							bs135 &= -17;
						}
						break;
					case 4:
						if(v135) {
							bs135 |= 8;
						} else {
							bs135 &= -9;
						}
						break;
					case 5:
						if(v135) {
							bs135 |= 4;
						} else {
							bs135 &= -5;
						}
						break;
					case 6:
						if(v135) {
							bs135 |= 2;
						} else {
							bs135 &= -3;
						}
						break;
					case 7:
						if(v135) {
							bs135 |= 1;
						} else {
							bs135 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs135;
				var this137 = 0;
				var bs136 = this137;
				var l136 = "   * ".length;
				var _g1137 = 0;
				var _g237 = l136;
				while(_g1137 < _g237) {
					var i137 = _g1137++;
					var no136 = "   * ".charCodeAt(i137);
					if(no136 == null) {
						break;
					}
					var v136;
					switch(no136) {
					case 32:
						v136 = false;
						break;
					case 42:
						v136 = true;
						break;
					case 48:
						v136 = false;
						break;
					case 49:
						v136 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i137)));
					}
					switch(i137 - (l136 - 8)) {
					case 0:
						if(v136) {
							bs136 |= 128;
						} else {
							bs136 &= -129;
						}
						break;
					case 1:
						if(v136) {
							bs136 |= 64;
						} else {
							bs136 &= -65;
						}
						break;
					case 2:
						if(v136) {
							bs136 |= 32;
						} else {
							bs136 &= -33;
						}
						break;
					case 3:
						if(v136) {
							bs136 |= 16;
						} else {
							bs136 &= -17;
						}
						break;
					case 4:
						if(v136) {
							bs136 |= 8;
						} else {
							bs136 &= -9;
						}
						break;
					case 5:
						if(v136) {
							bs136 |= 4;
						} else {
							bs136 &= -5;
						}
						break;
					case 6:
						if(v136) {
							bs136 |= 2;
						} else {
							bs136 &= -3;
						}
						break;
					case 7:
						if(v136) {
							bs136 |= 1;
						} else {
							bs136 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs136;
				var this138 = 0;
				var bs137 = this138;
				var l137 = "    *".length;
				var _g1138 = 0;
				var _g238 = l137;
				while(_g1138 < _g238) {
					var i138 = _g1138++;
					var no137 = "    *".charCodeAt(i138);
					if(no137 == null) {
						break;
					}
					var v137;
					switch(no137) {
					case 32:
						v137 = false;
						break;
					case 42:
						v137 = true;
						break;
					case 48:
						v137 = false;
						break;
					case 49:
						v137 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i138)));
					}
					switch(i138 - (l137 - 8)) {
					case 0:
						if(v137) {
							bs137 |= 128;
						} else {
							bs137 &= -129;
						}
						break;
					case 1:
						if(v137) {
							bs137 |= 64;
						} else {
							bs137 &= -65;
						}
						break;
					case 2:
						if(v137) {
							bs137 |= 32;
						} else {
							bs137 &= -33;
						}
						break;
					case 3:
						if(v137) {
							bs137 |= 16;
						} else {
							bs137 &= -17;
						}
						break;
					case 4:
						if(v137) {
							bs137 |= 8;
						} else {
							bs137 &= -9;
						}
						break;
					case 5:
						if(v137) {
							bs137 |= 4;
						} else {
							bs137 &= -5;
						}
						break;
					case 6:
						if(v137) {
							bs137 |= 2;
						} else {
							bs137 &= -3;
						}
						break;
					case 7:
						if(v137) {
							bs137 |= 1;
						} else {
							bs137 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs137;
				var this139 = 0;
				var bs138 = this139;
				var l138 = "*   *".length;
				var _g1139 = 0;
				var _g239 = l138;
				while(_g1139 < _g239) {
					var i139 = _g1139++;
					var no138 = "*   *".charCodeAt(i139);
					if(no138 == null) {
						break;
					}
					var v138;
					switch(no138) {
					case 32:
						v138 = false;
						break;
					case 42:
						v138 = true;
						break;
					case 48:
						v138 = false;
						break;
					case 49:
						v138 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i139)));
					}
					switch(i139 - (l138 - 8)) {
					case 0:
						if(v138) {
							bs138 |= 128;
						} else {
							bs138 &= -129;
						}
						break;
					case 1:
						if(v138) {
							bs138 |= 64;
						} else {
							bs138 &= -65;
						}
						break;
					case 2:
						if(v138) {
							bs138 |= 32;
						} else {
							bs138 &= -33;
						}
						break;
					case 3:
						if(v138) {
							bs138 |= 16;
						} else {
							bs138 &= -17;
						}
						break;
					case 4:
						if(v138) {
							bs138 |= 8;
						} else {
							bs138 &= -9;
						}
						break;
					case 5:
						if(v138) {
							bs138 |= 4;
						} else {
							bs138 &= -5;
						}
						break;
					case 6:
						if(v138) {
							bs138 |= 2;
						} else {
							bs138 &= -3;
						}
						break;
					case 7:
						if(v138) {
							bs138 |= 1;
						} else {
							bs138 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs138;
				var this140 = 0;
				var bs139 = this140;
				var l139 = " *** ".length;
				var _g1140 = 0;
				var _g240 = l139;
				while(_g1140 < _g240) {
					var i140 = _g1140++;
					var no139 = " *** ".charCodeAt(i140);
					if(no139 == null) {
						break;
					}
					var v139;
					switch(no139) {
					case 32:
						v139 = false;
						break;
					case 42:
						v139 = true;
						break;
					case 48:
						v139 = false;
						break;
					case 49:
						v139 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i140)));
					}
					switch(i140 - (l139 - 8)) {
					case 0:
						if(v139) {
							bs139 |= 128;
						} else {
							bs139 &= -129;
						}
						break;
					case 1:
						if(v139) {
							bs139 |= 64;
						} else {
							bs139 &= -65;
						}
						break;
					case 2:
						if(v139) {
							bs139 |= 32;
						} else {
							bs139 &= -33;
						}
						break;
					case 3:
						if(v139) {
							bs139 |= 16;
						} else {
							bs139 &= -17;
						}
						break;
					case 4:
						if(v139) {
							bs139 |= 8;
						} else {
							bs139 &= -9;
						}
						break;
					case 5:
						if(v139) {
							bs139 |= 4;
						} else {
							bs139 &= -5;
						}
						break;
					case 6:
						if(v139) {
							bs139 |= 2;
						} else {
							bs139 &= -3;
						}
						break;
					case 7:
						if(v139) {
							bs139 |= 1;
						} else {
							bs139 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs139;
				break;
			case 52:
				var this141 = 0;
				var bs140 = this141;
				var l140 = "   * ".length;
				var _g1141 = 0;
				var _g241 = l140;
				while(_g1141 < _g241) {
					var i141 = _g1141++;
					var no140 = "   * ".charCodeAt(i141);
					if(no140 == null) {
						break;
					}
					var v140;
					switch(no140) {
					case 32:
						v140 = false;
						break;
					case 42:
						v140 = true;
						break;
					case 48:
						v140 = false;
						break;
					case 49:
						v140 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i141)));
					}
					switch(i141 - (l140 - 8)) {
					case 0:
						if(v140) {
							bs140 |= 128;
						} else {
							bs140 &= -129;
						}
						break;
					case 1:
						if(v140) {
							bs140 |= 64;
						} else {
							bs140 &= -65;
						}
						break;
					case 2:
						if(v140) {
							bs140 |= 32;
						} else {
							bs140 &= -33;
						}
						break;
					case 3:
						if(v140) {
							bs140 |= 16;
						} else {
							bs140 &= -17;
						}
						break;
					case 4:
						if(v140) {
							bs140 |= 8;
						} else {
							bs140 &= -9;
						}
						break;
					case 5:
						if(v140) {
							bs140 |= 4;
						} else {
							bs140 &= -5;
						}
						break;
					case 6:
						if(v140) {
							bs140 |= 2;
						} else {
							bs140 &= -3;
						}
						break;
					case 7:
						if(v140) {
							bs140 |= 1;
						} else {
							bs140 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs140;
				var this142 = 0;
				var bs141 = this142;
				var l141 = "  ** ".length;
				var _g1142 = 0;
				var _g242 = l141;
				while(_g1142 < _g242) {
					var i142 = _g1142++;
					var no141 = "  ** ".charCodeAt(i142);
					if(no141 == null) {
						break;
					}
					var v141;
					switch(no141) {
					case 32:
						v141 = false;
						break;
					case 42:
						v141 = true;
						break;
					case 48:
						v141 = false;
						break;
					case 49:
						v141 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i142)));
					}
					switch(i142 - (l141 - 8)) {
					case 0:
						if(v141) {
							bs141 |= 128;
						} else {
							bs141 &= -129;
						}
						break;
					case 1:
						if(v141) {
							bs141 |= 64;
						} else {
							bs141 &= -65;
						}
						break;
					case 2:
						if(v141) {
							bs141 |= 32;
						} else {
							bs141 &= -33;
						}
						break;
					case 3:
						if(v141) {
							bs141 |= 16;
						} else {
							bs141 &= -17;
						}
						break;
					case 4:
						if(v141) {
							bs141 |= 8;
						} else {
							bs141 &= -9;
						}
						break;
					case 5:
						if(v141) {
							bs141 |= 4;
						} else {
							bs141 &= -5;
						}
						break;
					case 6:
						if(v141) {
							bs141 |= 2;
						} else {
							bs141 &= -3;
						}
						break;
					case 7:
						if(v141) {
							bs141 |= 1;
						} else {
							bs141 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs141;
				var this143 = 0;
				var bs142 = this143;
				var l142 = " * * ".length;
				var _g1143 = 0;
				var _g243 = l142;
				while(_g1143 < _g243) {
					var i143 = _g1143++;
					var no142 = " * * ".charCodeAt(i143);
					if(no142 == null) {
						break;
					}
					var v142;
					switch(no142) {
					case 32:
						v142 = false;
						break;
					case 42:
						v142 = true;
						break;
					case 48:
						v142 = false;
						break;
					case 49:
						v142 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i143)));
					}
					switch(i143 - (l142 - 8)) {
					case 0:
						if(v142) {
							bs142 |= 128;
						} else {
							bs142 &= -129;
						}
						break;
					case 1:
						if(v142) {
							bs142 |= 64;
						} else {
							bs142 &= -65;
						}
						break;
					case 2:
						if(v142) {
							bs142 |= 32;
						} else {
							bs142 &= -33;
						}
						break;
					case 3:
						if(v142) {
							bs142 |= 16;
						} else {
							bs142 &= -17;
						}
						break;
					case 4:
						if(v142) {
							bs142 |= 8;
						} else {
							bs142 &= -9;
						}
						break;
					case 5:
						if(v142) {
							bs142 |= 4;
						} else {
							bs142 &= -5;
						}
						break;
					case 6:
						if(v142) {
							bs142 |= 2;
						} else {
							bs142 &= -3;
						}
						break;
					case 7:
						if(v142) {
							bs142 |= 1;
						} else {
							bs142 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs142;
				var this144 = 0;
				var bs143 = this144;
				var l143 = "*  * ".length;
				var _g1144 = 0;
				var _g244 = l143;
				while(_g1144 < _g244) {
					var i144 = _g1144++;
					var no143 = "*  * ".charCodeAt(i144);
					if(no143 == null) {
						break;
					}
					var v143;
					switch(no143) {
					case 32:
						v143 = false;
						break;
					case 42:
						v143 = true;
						break;
					case 48:
						v143 = false;
						break;
					case 49:
						v143 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i144)));
					}
					switch(i144 - (l143 - 8)) {
					case 0:
						if(v143) {
							bs143 |= 128;
						} else {
							bs143 &= -129;
						}
						break;
					case 1:
						if(v143) {
							bs143 |= 64;
						} else {
							bs143 &= -65;
						}
						break;
					case 2:
						if(v143) {
							bs143 |= 32;
						} else {
							bs143 &= -33;
						}
						break;
					case 3:
						if(v143) {
							bs143 |= 16;
						} else {
							bs143 &= -17;
						}
						break;
					case 4:
						if(v143) {
							bs143 |= 8;
						} else {
							bs143 &= -9;
						}
						break;
					case 5:
						if(v143) {
							bs143 |= 4;
						} else {
							bs143 &= -5;
						}
						break;
					case 6:
						if(v143) {
							bs143 |= 2;
						} else {
							bs143 &= -3;
						}
						break;
					case 7:
						if(v143) {
							bs143 |= 1;
						} else {
							bs143 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs143;
				var this145 = 0;
				var bs144 = this145;
				var l144 = "*****".length;
				var _g1145 = 0;
				var _g245 = l144;
				while(_g1145 < _g245) {
					var i145 = _g1145++;
					var no144 = "*****".charCodeAt(i145);
					if(no144 == null) {
						break;
					}
					var v144;
					switch(no144) {
					case 32:
						v144 = false;
						break;
					case 42:
						v144 = true;
						break;
					case 48:
						v144 = false;
						break;
					case 49:
						v144 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i145)));
					}
					switch(i145 - (l144 - 8)) {
					case 0:
						if(v144) {
							bs144 |= 128;
						} else {
							bs144 &= -129;
						}
						break;
					case 1:
						if(v144) {
							bs144 |= 64;
						} else {
							bs144 &= -65;
						}
						break;
					case 2:
						if(v144) {
							bs144 |= 32;
						} else {
							bs144 &= -33;
						}
						break;
					case 3:
						if(v144) {
							bs144 |= 16;
						} else {
							bs144 &= -17;
						}
						break;
					case 4:
						if(v144) {
							bs144 |= 8;
						} else {
							bs144 &= -9;
						}
						break;
					case 5:
						if(v144) {
							bs144 |= 4;
						} else {
							bs144 &= -5;
						}
						break;
					case 6:
						if(v144) {
							bs144 |= 2;
						} else {
							bs144 &= -3;
						}
						break;
					case 7:
						if(v144) {
							bs144 |= 1;
						} else {
							bs144 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs144;
				var this146 = 0;
				var bs145 = this146;
				var l145 = "   * ".length;
				var _g1146 = 0;
				var _g246 = l145;
				while(_g1146 < _g246) {
					var i146 = _g1146++;
					var no145 = "   * ".charCodeAt(i146);
					if(no145 == null) {
						break;
					}
					var v145;
					switch(no145) {
					case 32:
						v145 = false;
						break;
					case 42:
						v145 = true;
						break;
					case 48:
						v145 = false;
						break;
					case 49:
						v145 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i146)));
					}
					switch(i146 - (l145 - 8)) {
					case 0:
						if(v145) {
							bs145 |= 128;
						} else {
							bs145 &= -129;
						}
						break;
					case 1:
						if(v145) {
							bs145 |= 64;
						} else {
							bs145 &= -65;
						}
						break;
					case 2:
						if(v145) {
							bs145 |= 32;
						} else {
							bs145 &= -33;
						}
						break;
					case 3:
						if(v145) {
							bs145 |= 16;
						} else {
							bs145 &= -17;
						}
						break;
					case 4:
						if(v145) {
							bs145 |= 8;
						} else {
							bs145 &= -9;
						}
						break;
					case 5:
						if(v145) {
							bs145 |= 4;
						} else {
							bs145 &= -5;
						}
						break;
					case 6:
						if(v145) {
							bs145 |= 2;
						} else {
							bs145 &= -3;
						}
						break;
					case 7:
						if(v145) {
							bs145 |= 1;
						} else {
							bs145 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs145;
				var this147 = 0;
				var bs146 = this147;
				var l146 = "   * ".length;
				var _g1147 = 0;
				var _g247 = l146;
				while(_g1147 < _g247) {
					var i147 = _g1147++;
					var no146 = "   * ".charCodeAt(i147);
					if(no146 == null) {
						break;
					}
					var v146;
					switch(no146) {
					case 32:
						v146 = false;
						break;
					case 42:
						v146 = true;
						break;
					case 48:
						v146 = false;
						break;
					case 49:
						v146 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i147)));
					}
					switch(i147 - (l146 - 8)) {
					case 0:
						if(v146) {
							bs146 |= 128;
						} else {
							bs146 &= -129;
						}
						break;
					case 1:
						if(v146) {
							bs146 |= 64;
						} else {
							bs146 &= -65;
						}
						break;
					case 2:
						if(v146) {
							bs146 |= 32;
						} else {
							bs146 &= -33;
						}
						break;
					case 3:
						if(v146) {
							bs146 |= 16;
						} else {
							bs146 &= -17;
						}
						break;
					case 4:
						if(v146) {
							bs146 |= 8;
						} else {
							bs146 &= -9;
						}
						break;
					case 5:
						if(v146) {
							bs146 |= 4;
						} else {
							bs146 &= -5;
						}
						break;
					case 6:
						if(v146) {
							bs146 |= 2;
						} else {
							bs146 &= -3;
						}
						break;
					case 7:
						if(v146) {
							bs146 |= 1;
						} else {
							bs146 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs146;
				break;
			case 53:
				var this148 = 0;
				var bs147 = this148;
				var l147 = "*****".length;
				var _g1148 = 0;
				var _g248 = l147;
				while(_g1148 < _g248) {
					var i148 = _g1148++;
					var no147 = "*****".charCodeAt(i148);
					if(no147 == null) {
						break;
					}
					var v147;
					switch(no147) {
					case 32:
						v147 = false;
						break;
					case 42:
						v147 = true;
						break;
					case 48:
						v147 = false;
						break;
					case 49:
						v147 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i148)));
					}
					switch(i148 - (l147 - 8)) {
					case 0:
						if(v147) {
							bs147 |= 128;
						} else {
							bs147 &= -129;
						}
						break;
					case 1:
						if(v147) {
							bs147 |= 64;
						} else {
							bs147 &= -65;
						}
						break;
					case 2:
						if(v147) {
							bs147 |= 32;
						} else {
							bs147 &= -33;
						}
						break;
					case 3:
						if(v147) {
							bs147 |= 16;
						} else {
							bs147 &= -17;
						}
						break;
					case 4:
						if(v147) {
							bs147 |= 8;
						} else {
							bs147 &= -9;
						}
						break;
					case 5:
						if(v147) {
							bs147 |= 4;
						} else {
							bs147 &= -5;
						}
						break;
					case 6:
						if(v147) {
							bs147 |= 2;
						} else {
							bs147 &= -3;
						}
						break;
					case 7:
						if(v147) {
							bs147 |= 1;
						} else {
							bs147 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs147;
				var this149 = 0;
				var bs148 = this149;
				var l148 = "*    ".length;
				var _g1149 = 0;
				var _g249 = l148;
				while(_g1149 < _g249) {
					var i149 = _g1149++;
					var no148 = "*    ".charCodeAt(i149);
					if(no148 == null) {
						break;
					}
					var v148;
					switch(no148) {
					case 32:
						v148 = false;
						break;
					case 42:
						v148 = true;
						break;
					case 48:
						v148 = false;
						break;
					case 49:
						v148 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i149)));
					}
					switch(i149 - (l148 - 8)) {
					case 0:
						if(v148) {
							bs148 |= 128;
						} else {
							bs148 &= -129;
						}
						break;
					case 1:
						if(v148) {
							bs148 |= 64;
						} else {
							bs148 &= -65;
						}
						break;
					case 2:
						if(v148) {
							bs148 |= 32;
						} else {
							bs148 &= -33;
						}
						break;
					case 3:
						if(v148) {
							bs148 |= 16;
						} else {
							bs148 &= -17;
						}
						break;
					case 4:
						if(v148) {
							bs148 |= 8;
						} else {
							bs148 &= -9;
						}
						break;
					case 5:
						if(v148) {
							bs148 |= 4;
						} else {
							bs148 &= -5;
						}
						break;
					case 6:
						if(v148) {
							bs148 |= 2;
						} else {
							bs148 &= -3;
						}
						break;
					case 7:
						if(v148) {
							bs148 |= 1;
						} else {
							bs148 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs148;
				var this150 = 0;
				var bs149 = this150;
				var l149 = "**** ".length;
				var _g1150 = 0;
				var _g250 = l149;
				while(_g1150 < _g250) {
					var i150 = _g1150++;
					var no149 = "**** ".charCodeAt(i150);
					if(no149 == null) {
						break;
					}
					var v149;
					switch(no149) {
					case 32:
						v149 = false;
						break;
					case 42:
						v149 = true;
						break;
					case 48:
						v149 = false;
						break;
					case 49:
						v149 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i150)));
					}
					switch(i150 - (l149 - 8)) {
					case 0:
						if(v149) {
							bs149 |= 128;
						} else {
							bs149 &= -129;
						}
						break;
					case 1:
						if(v149) {
							bs149 |= 64;
						} else {
							bs149 &= -65;
						}
						break;
					case 2:
						if(v149) {
							bs149 |= 32;
						} else {
							bs149 &= -33;
						}
						break;
					case 3:
						if(v149) {
							bs149 |= 16;
						} else {
							bs149 &= -17;
						}
						break;
					case 4:
						if(v149) {
							bs149 |= 8;
						} else {
							bs149 &= -9;
						}
						break;
					case 5:
						if(v149) {
							bs149 |= 4;
						} else {
							bs149 &= -5;
						}
						break;
					case 6:
						if(v149) {
							bs149 |= 2;
						} else {
							bs149 &= -3;
						}
						break;
					case 7:
						if(v149) {
							bs149 |= 1;
						} else {
							bs149 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs149;
				var this151 = 0;
				var bs150 = this151;
				var l150 = "    *".length;
				var _g1151 = 0;
				var _g251 = l150;
				while(_g1151 < _g251) {
					var i151 = _g1151++;
					var no150 = "    *".charCodeAt(i151);
					if(no150 == null) {
						break;
					}
					var v150;
					switch(no150) {
					case 32:
						v150 = false;
						break;
					case 42:
						v150 = true;
						break;
					case 48:
						v150 = false;
						break;
					case 49:
						v150 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i151)));
					}
					switch(i151 - (l150 - 8)) {
					case 0:
						if(v150) {
							bs150 |= 128;
						} else {
							bs150 &= -129;
						}
						break;
					case 1:
						if(v150) {
							bs150 |= 64;
						} else {
							bs150 &= -65;
						}
						break;
					case 2:
						if(v150) {
							bs150 |= 32;
						} else {
							bs150 &= -33;
						}
						break;
					case 3:
						if(v150) {
							bs150 |= 16;
						} else {
							bs150 &= -17;
						}
						break;
					case 4:
						if(v150) {
							bs150 |= 8;
						} else {
							bs150 &= -9;
						}
						break;
					case 5:
						if(v150) {
							bs150 |= 4;
						} else {
							bs150 &= -5;
						}
						break;
					case 6:
						if(v150) {
							bs150 |= 2;
						} else {
							bs150 &= -3;
						}
						break;
					case 7:
						if(v150) {
							bs150 |= 1;
						} else {
							bs150 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs150;
				var this152 = 0;
				var bs151 = this152;
				var l151 = "    *".length;
				var _g1152 = 0;
				var _g252 = l151;
				while(_g1152 < _g252) {
					var i152 = _g1152++;
					var no151 = "    *".charCodeAt(i152);
					if(no151 == null) {
						break;
					}
					var v151;
					switch(no151) {
					case 32:
						v151 = false;
						break;
					case 42:
						v151 = true;
						break;
					case 48:
						v151 = false;
						break;
					case 49:
						v151 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i152)));
					}
					switch(i152 - (l151 - 8)) {
					case 0:
						if(v151) {
							bs151 |= 128;
						} else {
							bs151 &= -129;
						}
						break;
					case 1:
						if(v151) {
							bs151 |= 64;
						} else {
							bs151 &= -65;
						}
						break;
					case 2:
						if(v151) {
							bs151 |= 32;
						} else {
							bs151 &= -33;
						}
						break;
					case 3:
						if(v151) {
							bs151 |= 16;
						} else {
							bs151 &= -17;
						}
						break;
					case 4:
						if(v151) {
							bs151 |= 8;
						} else {
							bs151 &= -9;
						}
						break;
					case 5:
						if(v151) {
							bs151 |= 4;
						} else {
							bs151 &= -5;
						}
						break;
					case 6:
						if(v151) {
							bs151 |= 2;
						} else {
							bs151 &= -3;
						}
						break;
					case 7:
						if(v151) {
							bs151 |= 1;
						} else {
							bs151 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs151;
				var this153 = 0;
				var bs152 = this153;
				var l152 = "*   *".length;
				var _g1153 = 0;
				var _g253 = l152;
				while(_g1153 < _g253) {
					var i153 = _g1153++;
					var no152 = "*   *".charCodeAt(i153);
					if(no152 == null) {
						break;
					}
					var v152;
					switch(no152) {
					case 32:
						v152 = false;
						break;
					case 42:
						v152 = true;
						break;
					case 48:
						v152 = false;
						break;
					case 49:
						v152 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i153)));
					}
					switch(i153 - (l152 - 8)) {
					case 0:
						if(v152) {
							bs152 |= 128;
						} else {
							bs152 &= -129;
						}
						break;
					case 1:
						if(v152) {
							bs152 |= 64;
						} else {
							bs152 &= -65;
						}
						break;
					case 2:
						if(v152) {
							bs152 |= 32;
						} else {
							bs152 &= -33;
						}
						break;
					case 3:
						if(v152) {
							bs152 |= 16;
						} else {
							bs152 &= -17;
						}
						break;
					case 4:
						if(v152) {
							bs152 |= 8;
						} else {
							bs152 &= -9;
						}
						break;
					case 5:
						if(v152) {
							bs152 |= 4;
						} else {
							bs152 &= -5;
						}
						break;
					case 6:
						if(v152) {
							bs152 |= 2;
						} else {
							bs152 &= -3;
						}
						break;
					case 7:
						if(v152) {
							bs152 |= 1;
						} else {
							bs152 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs152;
				var this154 = 0;
				var bs153 = this154;
				var l153 = " *** ".length;
				var _g1154 = 0;
				var _g254 = l153;
				while(_g1154 < _g254) {
					var i154 = _g1154++;
					var no153 = " *** ".charCodeAt(i154);
					if(no153 == null) {
						break;
					}
					var v153;
					switch(no153) {
					case 32:
						v153 = false;
						break;
					case 42:
						v153 = true;
						break;
					case 48:
						v153 = false;
						break;
					case 49:
						v153 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i154)));
					}
					switch(i154 - (l153 - 8)) {
					case 0:
						if(v153) {
							bs153 |= 128;
						} else {
							bs153 &= -129;
						}
						break;
					case 1:
						if(v153) {
							bs153 |= 64;
						} else {
							bs153 &= -65;
						}
						break;
					case 2:
						if(v153) {
							bs153 |= 32;
						} else {
							bs153 &= -33;
						}
						break;
					case 3:
						if(v153) {
							bs153 |= 16;
						} else {
							bs153 &= -17;
						}
						break;
					case 4:
						if(v153) {
							bs153 |= 8;
						} else {
							bs153 &= -9;
						}
						break;
					case 5:
						if(v153) {
							bs153 |= 4;
						} else {
							bs153 &= -5;
						}
						break;
					case 6:
						if(v153) {
							bs153 |= 2;
						} else {
							bs153 &= -3;
						}
						break;
					case 7:
						if(v153) {
							bs153 |= 1;
						} else {
							bs153 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs153;
				break;
			case 54:
				var this155 = 0;
				var bs154 = this155;
				var l154 = "  ** ".length;
				var _g1155 = 0;
				var _g255 = l154;
				while(_g1155 < _g255) {
					var i155 = _g1155++;
					var no154 = "  ** ".charCodeAt(i155);
					if(no154 == null) {
						break;
					}
					var v154;
					switch(no154) {
					case 32:
						v154 = false;
						break;
					case 42:
						v154 = true;
						break;
					case 48:
						v154 = false;
						break;
					case 49:
						v154 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i155)));
					}
					switch(i155 - (l154 - 8)) {
					case 0:
						if(v154) {
							bs154 |= 128;
						} else {
							bs154 &= -129;
						}
						break;
					case 1:
						if(v154) {
							bs154 |= 64;
						} else {
							bs154 &= -65;
						}
						break;
					case 2:
						if(v154) {
							bs154 |= 32;
						} else {
							bs154 &= -33;
						}
						break;
					case 3:
						if(v154) {
							bs154 |= 16;
						} else {
							bs154 &= -17;
						}
						break;
					case 4:
						if(v154) {
							bs154 |= 8;
						} else {
							bs154 &= -9;
						}
						break;
					case 5:
						if(v154) {
							bs154 |= 4;
						} else {
							bs154 &= -5;
						}
						break;
					case 6:
						if(v154) {
							bs154 |= 2;
						} else {
							bs154 &= -3;
						}
						break;
					case 7:
						if(v154) {
							bs154 |= 1;
						} else {
							bs154 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs154;
				var this156 = 0;
				var bs155 = this156;
				var l155 = " *   ".length;
				var _g1156 = 0;
				var _g256 = l155;
				while(_g1156 < _g256) {
					var i156 = _g1156++;
					var no155 = " *   ".charCodeAt(i156);
					if(no155 == null) {
						break;
					}
					var v155;
					switch(no155) {
					case 32:
						v155 = false;
						break;
					case 42:
						v155 = true;
						break;
					case 48:
						v155 = false;
						break;
					case 49:
						v155 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i156)));
					}
					switch(i156 - (l155 - 8)) {
					case 0:
						if(v155) {
							bs155 |= 128;
						} else {
							bs155 &= -129;
						}
						break;
					case 1:
						if(v155) {
							bs155 |= 64;
						} else {
							bs155 &= -65;
						}
						break;
					case 2:
						if(v155) {
							bs155 |= 32;
						} else {
							bs155 &= -33;
						}
						break;
					case 3:
						if(v155) {
							bs155 |= 16;
						} else {
							bs155 &= -17;
						}
						break;
					case 4:
						if(v155) {
							bs155 |= 8;
						} else {
							bs155 &= -9;
						}
						break;
					case 5:
						if(v155) {
							bs155 |= 4;
						} else {
							bs155 &= -5;
						}
						break;
					case 6:
						if(v155) {
							bs155 |= 2;
						} else {
							bs155 &= -3;
						}
						break;
					case 7:
						if(v155) {
							bs155 |= 1;
						} else {
							bs155 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs155;
				var this157 = 0;
				var bs156 = this157;
				var l156 = "*    ".length;
				var _g1157 = 0;
				var _g257 = l156;
				while(_g1157 < _g257) {
					var i157 = _g1157++;
					var no156 = "*    ".charCodeAt(i157);
					if(no156 == null) {
						break;
					}
					var v156;
					switch(no156) {
					case 32:
						v156 = false;
						break;
					case 42:
						v156 = true;
						break;
					case 48:
						v156 = false;
						break;
					case 49:
						v156 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i157)));
					}
					switch(i157 - (l156 - 8)) {
					case 0:
						if(v156) {
							bs156 |= 128;
						} else {
							bs156 &= -129;
						}
						break;
					case 1:
						if(v156) {
							bs156 |= 64;
						} else {
							bs156 &= -65;
						}
						break;
					case 2:
						if(v156) {
							bs156 |= 32;
						} else {
							bs156 &= -33;
						}
						break;
					case 3:
						if(v156) {
							bs156 |= 16;
						} else {
							bs156 &= -17;
						}
						break;
					case 4:
						if(v156) {
							bs156 |= 8;
						} else {
							bs156 &= -9;
						}
						break;
					case 5:
						if(v156) {
							bs156 |= 4;
						} else {
							bs156 &= -5;
						}
						break;
					case 6:
						if(v156) {
							bs156 |= 2;
						} else {
							bs156 &= -3;
						}
						break;
					case 7:
						if(v156) {
							bs156 |= 1;
						} else {
							bs156 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs156;
				var this158 = 0;
				var bs157 = this158;
				var l157 = "**** ".length;
				var _g1158 = 0;
				var _g258 = l157;
				while(_g1158 < _g258) {
					var i158 = _g1158++;
					var no157 = "**** ".charCodeAt(i158);
					if(no157 == null) {
						break;
					}
					var v157;
					switch(no157) {
					case 32:
						v157 = false;
						break;
					case 42:
						v157 = true;
						break;
					case 48:
						v157 = false;
						break;
					case 49:
						v157 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i158)));
					}
					switch(i158 - (l157 - 8)) {
					case 0:
						if(v157) {
							bs157 |= 128;
						} else {
							bs157 &= -129;
						}
						break;
					case 1:
						if(v157) {
							bs157 |= 64;
						} else {
							bs157 &= -65;
						}
						break;
					case 2:
						if(v157) {
							bs157 |= 32;
						} else {
							bs157 &= -33;
						}
						break;
					case 3:
						if(v157) {
							bs157 |= 16;
						} else {
							bs157 &= -17;
						}
						break;
					case 4:
						if(v157) {
							bs157 |= 8;
						} else {
							bs157 &= -9;
						}
						break;
					case 5:
						if(v157) {
							bs157 |= 4;
						} else {
							bs157 &= -5;
						}
						break;
					case 6:
						if(v157) {
							bs157 |= 2;
						} else {
							bs157 &= -3;
						}
						break;
					case 7:
						if(v157) {
							bs157 |= 1;
						} else {
							bs157 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs157;
				var this159 = 0;
				var bs158 = this159;
				var l158 = "*   *".length;
				var _g1159 = 0;
				var _g259 = l158;
				while(_g1159 < _g259) {
					var i159 = _g1159++;
					var no158 = "*   *".charCodeAt(i159);
					if(no158 == null) {
						break;
					}
					var v158;
					switch(no158) {
					case 32:
						v158 = false;
						break;
					case 42:
						v158 = true;
						break;
					case 48:
						v158 = false;
						break;
					case 49:
						v158 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i159)));
					}
					switch(i159 - (l158 - 8)) {
					case 0:
						if(v158) {
							bs158 |= 128;
						} else {
							bs158 &= -129;
						}
						break;
					case 1:
						if(v158) {
							bs158 |= 64;
						} else {
							bs158 &= -65;
						}
						break;
					case 2:
						if(v158) {
							bs158 |= 32;
						} else {
							bs158 &= -33;
						}
						break;
					case 3:
						if(v158) {
							bs158 |= 16;
						} else {
							bs158 &= -17;
						}
						break;
					case 4:
						if(v158) {
							bs158 |= 8;
						} else {
							bs158 &= -9;
						}
						break;
					case 5:
						if(v158) {
							bs158 |= 4;
						} else {
							bs158 &= -5;
						}
						break;
					case 6:
						if(v158) {
							bs158 |= 2;
						} else {
							bs158 &= -3;
						}
						break;
					case 7:
						if(v158) {
							bs158 |= 1;
						} else {
							bs158 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs158;
				var this160 = 0;
				var bs159 = this160;
				var l159 = "*   *".length;
				var _g1160 = 0;
				var _g260 = l159;
				while(_g1160 < _g260) {
					var i160 = _g1160++;
					var no159 = "*   *".charCodeAt(i160);
					if(no159 == null) {
						break;
					}
					var v159;
					switch(no159) {
					case 32:
						v159 = false;
						break;
					case 42:
						v159 = true;
						break;
					case 48:
						v159 = false;
						break;
					case 49:
						v159 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i160)));
					}
					switch(i160 - (l159 - 8)) {
					case 0:
						if(v159) {
							bs159 |= 128;
						} else {
							bs159 &= -129;
						}
						break;
					case 1:
						if(v159) {
							bs159 |= 64;
						} else {
							bs159 &= -65;
						}
						break;
					case 2:
						if(v159) {
							bs159 |= 32;
						} else {
							bs159 &= -33;
						}
						break;
					case 3:
						if(v159) {
							bs159 |= 16;
						} else {
							bs159 &= -17;
						}
						break;
					case 4:
						if(v159) {
							bs159 |= 8;
						} else {
							bs159 &= -9;
						}
						break;
					case 5:
						if(v159) {
							bs159 |= 4;
						} else {
							bs159 &= -5;
						}
						break;
					case 6:
						if(v159) {
							bs159 |= 2;
						} else {
							bs159 &= -3;
						}
						break;
					case 7:
						if(v159) {
							bs159 |= 1;
						} else {
							bs159 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs159;
				var this161 = 0;
				var bs160 = this161;
				var l160 = " *** ".length;
				var _g1161 = 0;
				var _g261 = l160;
				while(_g1161 < _g261) {
					var i161 = _g1161++;
					var no160 = " *** ".charCodeAt(i161);
					if(no160 == null) {
						break;
					}
					var v160;
					switch(no160) {
					case 32:
						v160 = false;
						break;
					case 42:
						v160 = true;
						break;
					case 48:
						v160 = false;
						break;
					case 49:
						v160 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i161)));
					}
					switch(i161 - (l160 - 8)) {
					case 0:
						if(v160) {
							bs160 |= 128;
						} else {
							bs160 &= -129;
						}
						break;
					case 1:
						if(v160) {
							bs160 |= 64;
						} else {
							bs160 &= -65;
						}
						break;
					case 2:
						if(v160) {
							bs160 |= 32;
						} else {
							bs160 &= -33;
						}
						break;
					case 3:
						if(v160) {
							bs160 |= 16;
						} else {
							bs160 &= -17;
						}
						break;
					case 4:
						if(v160) {
							bs160 |= 8;
						} else {
							bs160 &= -9;
						}
						break;
					case 5:
						if(v160) {
							bs160 |= 4;
						} else {
							bs160 &= -5;
						}
						break;
					case 6:
						if(v160) {
							bs160 |= 2;
						} else {
							bs160 &= -3;
						}
						break;
					case 7:
						if(v160) {
							bs160 |= 1;
						} else {
							bs160 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs160;
				break;
			case 55:
				var this162 = 0;
				var bs161 = this162;
				var l161 = "*****".length;
				var _g1162 = 0;
				var _g262 = l161;
				while(_g1162 < _g262) {
					var i162 = _g1162++;
					var no161 = "*****".charCodeAt(i162);
					if(no161 == null) {
						break;
					}
					var v161;
					switch(no161) {
					case 32:
						v161 = false;
						break;
					case 42:
						v161 = true;
						break;
					case 48:
						v161 = false;
						break;
					case 49:
						v161 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i162)));
					}
					switch(i162 - (l161 - 8)) {
					case 0:
						if(v161) {
							bs161 |= 128;
						} else {
							bs161 &= -129;
						}
						break;
					case 1:
						if(v161) {
							bs161 |= 64;
						} else {
							bs161 &= -65;
						}
						break;
					case 2:
						if(v161) {
							bs161 |= 32;
						} else {
							bs161 &= -33;
						}
						break;
					case 3:
						if(v161) {
							bs161 |= 16;
						} else {
							bs161 &= -17;
						}
						break;
					case 4:
						if(v161) {
							bs161 |= 8;
						} else {
							bs161 &= -9;
						}
						break;
					case 5:
						if(v161) {
							bs161 |= 4;
						} else {
							bs161 &= -5;
						}
						break;
					case 6:
						if(v161) {
							bs161 |= 2;
						} else {
							bs161 &= -3;
						}
						break;
					case 7:
						if(v161) {
							bs161 |= 1;
						} else {
							bs161 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs161;
				var this163 = 0;
				var bs162 = this163;
				var l162 = "    *".length;
				var _g1163 = 0;
				var _g263 = l162;
				while(_g1163 < _g263) {
					var i163 = _g1163++;
					var no162 = "    *".charCodeAt(i163);
					if(no162 == null) {
						break;
					}
					var v162;
					switch(no162) {
					case 32:
						v162 = false;
						break;
					case 42:
						v162 = true;
						break;
					case 48:
						v162 = false;
						break;
					case 49:
						v162 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i163)));
					}
					switch(i163 - (l162 - 8)) {
					case 0:
						if(v162) {
							bs162 |= 128;
						} else {
							bs162 &= -129;
						}
						break;
					case 1:
						if(v162) {
							bs162 |= 64;
						} else {
							bs162 &= -65;
						}
						break;
					case 2:
						if(v162) {
							bs162 |= 32;
						} else {
							bs162 &= -33;
						}
						break;
					case 3:
						if(v162) {
							bs162 |= 16;
						} else {
							bs162 &= -17;
						}
						break;
					case 4:
						if(v162) {
							bs162 |= 8;
						} else {
							bs162 &= -9;
						}
						break;
					case 5:
						if(v162) {
							bs162 |= 4;
						} else {
							bs162 &= -5;
						}
						break;
					case 6:
						if(v162) {
							bs162 |= 2;
						} else {
							bs162 &= -3;
						}
						break;
					case 7:
						if(v162) {
							bs162 |= 1;
						} else {
							bs162 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs162;
				var this164 = 0;
				var bs163 = this164;
				var l163 = "   * ".length;
				var _g1164 = 0;
				var _g264 = l163;
				while(_g1164 < _g264) {
					var i164 = _g1164++;
					var no163 = "   * ".charCodeAt(i164);
					if(no163 == null) {
						break;
					}
					var v163;
					switch(no163) {
					case 32:
						v163 = false;
						break;
					case 42:
						v163 = true;
						break;
					case 48:
						v163 = false;
						break;
					case 49:
						v163 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i164)));
					}
					switch(i164 - (l163 - 8)) {
					case 0:
						if(v163) {
							bs163 |= 128;
						} else {
							bs163 &= -129;
						}
						break;
					case 1:
						if(v163) {
							bs163 |= 64;
						} else {
							bs163 &= -65;
						}
						break;
					case 2:
						if(v163) {
							bs163 |= 32;
						} else {
							bs163 &= -33;
						}
						break;
					case 3:
						if(v163) {
							bs163 |= 16;
						} else {
							bs163 &= -17;
						}
						break;
					case 4:
						if(v163) {
							bs163 |= 8;
						} else {
							bs163 &= -9;
						}
						break;
					case 5:
						if(v163) {
							bs163 |= 4;
						} else {
							bs163 &= -5;
						}
						break;
					case 6:
						if(v163) {
							bs163 |= 2;
						} else {
							bs163 &= -3;
						}
						break;
					case 7:
						if(v163) {
							bs163 |= 1;
						} else {
							bs163 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs163;
				var this165 = 0;
				var bs164 = this165;
				var l164 = "  *  ".length;
				var _g1165 = 0;
				var _g265 = l164;
				while(_g1165 < _g265) {
					var i165 = _g1165++;
					var no164 = "  *  ".charCodeAt(i165);
					if(no164 == null) {
						break;
					}
					var v164;
					switch(no164) {
					case 32:
						v164 = false;
						break;
					case 42:
						v164 = true;
						break;
					case 48:
						v164 = false;
						break;
					case 49:
						v164 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i165)));
					}
					switch(i165 - (l164 - 8)) {
					case 0:
						if(v164) {
							bs164 |= 128;
						} else {
							bs164 &= -129;
						}
						break;
					case 1:
						if(v164) {
							bs164 |= 64;
						} else {
							bs164 &= -65;
						}
						break;
					case 2:
						if(v164) {
							bs164 |= 32;
						} else {
							bs164 &= -33;
						}
						break;
					case 3:
						if(v164) {
							bs164 |= 16;
						} else {
							bs164 &= -17;
						}
						break;
					case 4:
						if(v164) {
							bs164 |= 8;
						} else {
							bs164 &= -9;
						}
						break;
					case 5:
						if(v164) {
							bs164 |= 4;
						} else {
							bs164 &= -5;
						}
						break;
					case 6:
						if(v164) {
							bs164 |= 2;
						} else {
							bs164 &= -3;
						}
						break;
					case 7:
						if(v164) {
							bs164 |= 1;
						} else {
							bs164 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs164;
				var this166 = 0;
				var bs165 = this166;
				var l165 = " *   ".length;
				var _g1166 = 0;
				var _g266 = l165;
				while(_g1166 < _g266) {
					var i166 = _g1166++;
					var no165 = " *   ".charCodeAt(i166);
					if(no165 == null) {
						break;
					}
					var v165;
					switch(no165) {
					case 32:
						v165 = false;
						break;
					case 42:
						v165 = true;
						break;
					case 48:
						v165 = false;
						break;
					case 49:
						v165 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i166)));
					}
					switch(i166 - (l165 - 8)) {
					case 0:
						if(v165) {
							bs165 |= 128;
						} else {
							bs165 &= -129;
						}
						break;
					case 1:
						if(v165) {
							bs165 |= 64;
						} else {
							bs165 &= -65;
						}
						break;
					case 2:
						if(v165) {
							bs165 |= 32;
						} else {
							bs165 &= -33;
						}
						break;
					case 3:
						if(v165) {
							bs165 |= 16;
						} else {
							bs165 &= -17;
						}
						break;
					case 4:
						if(v165) {
							bs165 |= 8;
						} else {
							bs165 &= -9;
						}
						break;
					case 5:
						if(v165) {
							bs165 |= 4;
						} else {
							bs165 &= -5;
						}
						break;
					case 6:
						if(v165) {
							bs165 |= 2;
						} else {
							bs165 &= -3;
						}
						break;
					case 7:
						if(v165) {
							bs165 |= 1;
						} else {
							bs165 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs165;
				var this167 = 0;
				var bs166 = this167;
				var l166 = " *   ".length;
				var _g1167 = 0;
				var _g267 = l166;
				while(_g1167 < _g267) {
					var i167 = _g1167++;
					var no166 = " *   ".charCodeAt(i167);
					if(no166 == null) {
						break;
					}
					var v166;
					switch(no166) {
					case 32:
						v166 = false;
						break;
					case 42:
						v166 = true;
						break;
					case 48:
						v166 = false;
						break;
					case 49:
						v166 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i167)));
					}
					switch(i167 - (l166 - 8)) {
					case 0:
						if(v166) {
							bs166 |= 128;
						} else {
							bs166 &= -129;
						}
						break;
					case 1:
						if(v166) {
							bs166 |= 64;
						} else {
							bs166 &= -65;
						}
						break;
					case 2:
						if(v166) {
							bs166 |= 32;
						} else {
							bs166 &= -33;
						}
						break;
					case 3:
						if(v166) {
							bs166 |= 16;
						} else {
							bs166 &= -17;
						}
						break;
					case 4:
						if(v166) {
							bs166 |= 8;
						} else {
							bs166 &= -9;
						}
						break;
					case 5:
						if(v166) {
							bs166 |= 4;
						} else {
							bs166 &= -5;
						}
						break;
					case 6:
						if(v166) {
							bs166 |= 2;
						} else {
							bs166 &= -3;
						}
						break;
					case 7:
						if(v166) {
							bs166 |= 1;
						} else {
							bs166 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs166;
				var this168 = 0;
				var bs167 = this168;
				var l167 = " *   ".length;
				var _g1168 = 0;
				var _g268 = l167;
				while(_g1168 < _g268) {
					var i168 = _g1168++;
					var no167 = " *   ".charCodeAt(i168);
					if(no167 == null) {
						break;
					}
					var v167;
					switch(no167) {
					case 32:
						v167 = false;
						break;
					case 42:
						v167 = true;
						break;
					case 48:
						v167 = false;
						break;
					case 49:
						v167 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i168)));
					}
					switch(i168 - (l167 - 8)) {
					case 0:
						if(v167) {
							bs167 |= 128;
						} else {
							bs167 &= -129;
						}
						break;
					case 1:
						if(v167) {
							bs167 |= 64;
						} else {
							bs167 &= -65;
						}
						break;
					case 2:
						if(v167) {
							bs167 |= 32;
						} else {
							bs167 &= -33;
						}
						break;
					case 3:
						if(v167) {
							bs167 |= 16;
						} else {
							bs167 &= -17;
						}
						break;
					case 4:
						if(v167) {
							bs167 |= 8;
						} else {
							bs167 &= -9;
						}
						break;
					case 5:
						if(v167) {
							bs167 |= 4;
						} else {
							bs167 &= -5;
						}
						break;
					case 6:
						if(v167) {
							bs167 |= 2;
						} else {
							bs167 &= -3;
						}
						break;
					case 7:
						if(v167) {
							bs167 |= 1;
						} else {
							bs167 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs167;
				break;
			case 56:
				var this169 = 0;
				var bs168 = this169;
				var l168 = " *** ".length;
				var _g1169 = 0;
				var _g269 = l168;
				while(_g1169 < _g269) {
					var i169 = _g1169++;
					var no168 = " *** ".charCodeAt(i169);
					if(no168 == null) {
						break;
					}
					var v168;
					switch(no168) {
					case 32:
						v168 = false;
						break;
					case 42:
						v168 = true;
						break;
					case 48:
						v168 = false;
						break;
					case 49:
						v168 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i169)));
					}
					switch(i169 - (l168 - 8)) {
					case 0:
						if(v168) {
							bs168 |= 128;
						} else {
							bs168 &= -129;
						}
						break;
					case 1:
						if(v168) {
							bs168 |= 64;
						} else {
							bs168 &= -65;
						}
						break;
					case 2:
						if(v168) {
							bs168 |= 32;
						} else {
							bs168 &= -33;
						}
						break;
					case 3:
						if(v168) {
							bs168 |= 16;
						} else {
							bs168 &= -17;
						}
						break;
					case 4:
						if(v168) {
							bs168 |= 8;
						} else {
							bs168 &= -9;
						}
						break;
					case 5:
						if(v168) {
							bs168 |= 4;
						} else {
							bs168 &= -5;
						}
						break;
					case 6:
						if(v168) {
							bs168 |= 2;
						} else {
							bs168 &= -3;
						}
						break;
					case 7:
						if(v168) {
							bs168 |= 1;
						} else {
							bs168 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs168;
				var this170 = 0;
				var bs169 = this170;
				var l169 = "*   *".length;
				var _g1170 = 0;
				var _g270 = l169;
				while(_g1170 < _g270) {
					var i170 = _g1170++;
					var no169 = "*   *".charCodeAt(i170);
					if(no169 == null) {
						break;
					}
					var v169;
					switch(no169) {
					case 32:
						v169 = false;
						break;
					case 42:
						v169 = true;
						break;
					case 48:
						v169 = false;
						break;
					case 49:
						v169 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i170)));
					}
					switch(i170 - (l169 - 8)) {
					case 0:
						if(v169) {
							bs169 |= 128;
						} else {
							bs169 &= -129;
						}
						break;
					case 1:
						if(v169) {
							bs169 |= 64;
						} else {
							bs169 &= -65;
						}
						break;
					case 2:
						if(v169) {
							bs169 |= 32;
						} else {
							bs169 &= -33;
						}
						break;
					case 3:
						if(v169) {
							bs169 |= 16;
						} else {
							bs169 &= -17;
						}
						break;
					case 4:
						if(v169) {
							bs169 |= 8;
						} else {
							bs169 &= -9;
						}
						break;
					case 5:
						if(v169) {
							bs169 |= 4;
						} else {
							bs169 &= -5;
						}
						break;
					case 6:
						if(v169) {
							bs169 |= 2;
						} else {
							bs169 &= -3;
						}
						break;
					case 7:
						if(v169) {
							bs169 |= 1;
						} else {
							bs169 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs169;
				var this171 = 0;
				var bs170 = this171;
				var l170 = "*   *".length;
				var _g1171 = 0;
				var _g271 = l170;
				while(_g1171 < _g271) {
					var i171 = _g1171++;
					var no170 = "*   *".charCodeAt(i171);
					if(no170 == null) {
						break;
					}
					var v170;
					switch(no170) {
					case 32:
						v170 = false;
						break;
					case 42:
						v170 = true;
						break;
					case 48:
						v170 = false;
						break;
					case 49:
						v170 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i171)));
					}
					switch(i171 - (l170 - 8)) {
					case 0:
						if(v170) {
							bs170 |= 128;
						} else {
							bs170 &= -129;
						}
						break;
					case 1:
						if(v170) {
							bs170 |= 64;
						} else {
							bs170 &= -65;
						}
						break;
					case 2:
						if(v170) {
							bs170 |= 32;
						} else {
							bs170 &= -33;
						}
						break;
					case 3:
						if(v170) {
							bs170 |= 16;
						} else {
							bs170 &= -17;
						}
						break;
					case 4:
						if(v170) {
							bs170 |= 8;
						} else {
							bs170 &= -9;
						}
						break;
					case 5:
						if(v170) {
							bs170 |= 4;
						} else {
							bs170 &= -5;
						}
						break;
					case 6:
						if(v170) {
							bs170 |= 2;
						} else {
							bs170 &= -3;
						}
						break;
					case 7:
						if(v170) {
							bs170 |= 1;
						} else {
							bs170 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs170;
				var this172 = 0;
				var bs171 = this172;
				var l171 = " *** ".length;
				var _g1172 = 0;
				var _g272 = l171;
				while(_g1172 < _g272) {
					var i172 = _g1172++;
					var no171 = " *** ".charCodeAt(i172);
					if(no171 == null) {
						break;
					}
					var v171;
					switch(no171) {
					case 32:
						v171 = false;
						break;
					case 42:
						v171 = true;
						break;
					case 48:
						v171 = false;
						break;
					case 49:
						v171 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i172)));
					}
					switch(i172 - (l171 - 8)) {
					case 0:
						if(v171) {
							bs171 |= 128;
						} else {
							bs171 &= -129;
						}
						break;
					case 1:
						if(v171) {
							bs171 |= 64;
						} else {
							bs171 &= -65;
						}
						break;
					case 2:
						if(v171) {
							bs171 |= 32;
						} else {
							bs171 &= -33;
						}
						break;
					case 3:
						if(v171) {
							bs171 |= 16;
						} else {
							bs171 &= -17;
						}
						break;
					case 4:
						if(v171) {
							bs171 |= 8;
						} else {
							bs171 &= -9;
						}
						break;
					case 5:
						if(v171) {
							bs171 |= 4;
						} else {
							bs171 &= -5;
						}
						break;
					case 6:
						if(v171) {
							bs171 |= 2;
						} else {
							bs171 &= -3;
						}
						break;
					case 7:
						if(v171) {
							bs171 |= 1;
						} else {
							bs171 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs171;
				var this173 = 0;
				var bs172 = this173;
				var l172 = "*   *".length;
				var _g1173 = 0;
				var _g273 = l172;
				while(_g1173 < _g273) {
					var i173 = _g1173++;
					var no172 = "*   *".charCodeAt(i173);
					if(no172 == null) {
						break;
					}
					var v172;
					switch(no172) {
					case 32:
						v172 = false;
						break;
					case 42:
						v172 = true;
						break;
					case 48:
						v172 = false;
						break;
					case 49:
						v172 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i173)));
					}
					switch(i173 - (l172 - 8)) {
					case 0:
						if(v172) {
							bs172 |= 128;
						} else {
							bs172 &= -129;
						}
						break;
					case 1:
						if(v172) {
							bs172 |= 64;
						} else {
							bs172 &= -65;
						}
						break;
					case 2:
						if(v172) {
							bs172 |= 32;
						} else {
							bs172 &= -33;
						}
						break;
					case 3:
						if(v172) {
							bs172 |= 16;
						} else {
							bs172 &= -17;
						}
						break;
					case 4:
						if(v172) {
							bs172 |= 8;
						} else {
							bs172 &= -9;
						}
						break;
					case 5:
						if(v172) {
							bs172 |= 4;
						} else {
							bs172 &= -5;
						}
						break;
					case 6:
						if(v172) {
							bs172 |= 2;
						} else {
							bs172 &= -3;
						}
						break;
					case 7:
						if(v172) {
							bs172 |= 1;
						} else {
							bs172 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs172;
				var this174 = 0;
				var bs173 = this174;
				var l173 = "*   *".length;
				var _g1174 = 0;
				var _g274 = l173;
				while(_g1174 < _g274) {
					var i174 = _g1174++;
					var no173 = "*   *".charCodeAt(i174);
					if(no173 == null) {
						break;
					}
					var v173;
					switch(no173) {
					case 32:
						v173 = false;
						break;
					case 42:
						v173 = true;
						break;
					case 48:
						v173 = false;
						break;
					case 49:
						v173 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i174)));
					}
					switch(i174 - (l173 - 8)) {
					case 0:
						if(v173) {
							bs173 |= 128;
						} else {
							bs173 &= -129;
						}
						break;
					case 1:
						if(v173) {
							bs173 |= 64;
						} else {
							bs173 &= -65;
						}
						break;
					case 2:
						if(v173) {
							bs173 |= 32;
						} else {
							bs173 &= -33;
						}
						break;
					case 3:
						if(v173) {
							bs173 |= 16;
						} else {
							bs173 &= -17;
						}
						break;
					case 4:
						if(v173) {
							bs173 |= 8;
						} else {
							bs173 &= -9;
						}
						break;
					case 5:
						if(v173) {
							bs173 |= 4;
						} else {
							bs173 &= -5;
						}
						break;
					case 6:
						if(v173) {
							bs173 |= 2;
						} else {
							bs173 &= -3;
						}
						break;
					case 7:
						if(v173) {
							bs173 |= 1;
						} else {
							bs173 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs173;
				var this175 = 0;
				var bs174 = this175;
				var l174 = " *** ".length;
				var _g1175 = 0;
				var _g275 = l174;
				while(_g1175 < _g275) {
					var i175 = _g1175++;
					var no174 = " *** ".charCodeAt(i175);
					if(no174 == null) {
						break;
					}
					var v174;
					switch(no174) {
					case 32:
						v174 = false;
						break;
					case 42:
						v174 = true;
						break;
					case 48:
						v174 = false;
						break;
					case 49:
						v174 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i175)));
					}
					switch(i175 - (l174 - 8)) {
					case 0:
						if(v174) {
							bs174 |= 128;
						} else {
							bs174 &= -129;
						}
						break;
					case 1:
						if(v174) {
							bs174 |= 64;
						} else {
							bs174 &= -65;
						}
						break;
					case 2:
						if(v174) {
							bs174 |= 32;
						} else {
							bs174 &= -33;
						}
						break;
					case 3:
						if(v174) {
							bs174 |= 16;
						} else {
							bs174 &= -17;
						}
						break;
					case 4:
						if(v174) {
							bs174 |= 8;
						} else {
							bs174 &= -9;
						}
						break;
					case 5:
						if(v174) {
							bs174 |= 4;
						} else {
							bs174 &= -5;
						}
						break;
					case 6:
						if(v174) {
							bs174 |= 2;
						} else {
							bs174 &= -3;
						}
						break;
					case 7:
						if(v174) {
							bs174 |= 1;
						} else {
							bs174 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs174;
				break;
			case 57:
				var this176 = 0;
				var bs175 = this176;
				var l175 = " *** ".length;
				var _g1176 = 0;
				var _g276 = l175;
				while(_g1176 < _g276) {
					var i176 = _g1176++;
					var no175 = " *** ".charCodeAt(i176);
					if(no175 == null) {
						break;
					}
					var v175;
					switch(no175) {
					case 32:
						v175 = false;
						break;
					case 42:
						v175 = true;
						break;
					case 48:
						v175 = false;
						break;
					case 49:
						v175 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i176)));
					}
					switch(i176 - (l175 - 8)) {
					case 0:
						if(v175) {
							bs175 |= 128;
						} else {
							bs175 &= -129;
						}
						break;
					case 1:
						if(v175) {
							bs175 |= 64;
						} else {
							bs175 &= -65;
						}
						break;
					case 2:
						if(v175) {
							bs175 |= 32;
						} else {
							bs175 &= -33;
						}
						break;
					case 3:
						if(v175) {
							bs175 |= 16;
						} else {
							bs175 &= -17;
						}
						break;
					case 4:
						if(v175) {
							bs175 |= 8;
						} else {
							bs175 &= -9;
						}
						break;
					case 5:
						if(v175) {
							bs175 |= 4;
						} else {
							bs175 &= -5;
						}
						break;
					case 6:
						if(v175) {
							bs175 |= 2;
						} else {
							bs175 &= -3;
						}
						break;
					case 7:
						if(v175) {
							bs175 |= 1;
						} else {
							bs175 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs175;
				var this177 = 0;
				var bs176 = this177;
				var l176 = "*   *".length;
				var _g1177 = 0;
				var _g277 = l176;
				while(_g1177 < _g277) {
					var i177 = _g1177++;
					var no176 = "*   *".charCodeAt(i177);
					if(no176 == null) {
						break;
					}
					var v176;
					switch(no176) {
					case 32:
						v176 = false;
						break;
					case 42:
						v176 = true;
						break;
					case 48:
						v176 = false;
						break;
					case 49:
						v176 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i177)));
					}
					switch(i177 - (l176 - 8)) {
					case 0:
						if(v176) {
							bs176 |= 128;
						} else {
							bs176 &= -129;
						}
						break;
					case 1:
						if(v176) {
							bs176 |= 64;
						} else {
							bs176 &= -65;
						}
						break;
					case 2:
						if(v176) {
							bs176 |= 32;
						} else {
							bs176 &= -33;
						}
						break;
					case 3:
						if(v176) {
							bs176 |= 16;
						} else {
							bs176 &= -17;
						}
						break;
					case 4:
						if(v176) {
							bs176 |= 8;
						} else {
							bs176 &= -9;
						}
						break;
					case 5:
						if(v176) {
							bs176 |= 4;
						} else {
							bs176 &= -5;
						}
						break;
					case 6:
						if(v176) {
							bs176 |= 2;
						} else {
							bs176 &= -3;
						}
						break;
					case 7:
						if(v176) {
							bs176 |= 1;
						} else {
							bs176 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs176;
				var this178 = 0;
				var bs177 = this178;
				var l177 = "*   *".length;
				var _g1178 = 0;
				var _g278 = l177;
				while(_g1178 < _g278) {
					var i178 = _g1178++;
					var no177 = "*   *".charCodeAt(i178);
					if(no177 == null) {
						break;
					}
					var v177;
					switch(no177) {
					case 32:
						v177 = false;
						break;
					case 42:
						v177 = true;
						break;
					case 48:
						v177 = false;
						break;
					case 49:
						v177 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i178)));
					}
					switch(i178 - (l177 - 8)) {
					case 0:
						if(v177) {
							bs177 |= 128;
						} else {
							bs177 &= -129;
						}
						break;
					case 1:
						if(v177) {
							bs177 |= 64;
						} else {
							bs177 &= -65;
						}
						break;
					case 2:
						if(v177) {
							bs177 |= 32;
						} else {
							bs177 &= -33;
						}
						break;
					case 3:
						if(v177) {
							bs177 |= 16;
						} else {
							bs177 &= -17;
						}
						break;
					case 4:
						if(v177) {
							bs177 |= 8;
						} else {
							bs177 &= -9;
						}
						break;
					case 5:
						if(v177) {
							bs177 |= 4;
						} else {
							bs177 &= -5;
						}
						break;
					case 6:
						if(v177) {
							bs177 |= 2;
						} else {
							bs177 &= -3;
						}
						break;
					case 7:
						if(v177) {
							bs177 |= 1;
						} else {
							bs177 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs177;
				var this179 = 0;
				var bs178 = this179;
				var l178 = " ****".length;
				var _g1179 = 0;
				var _g279 = l178;
				while(_g1179 < _g279) {
					var i179 = _g1179++;
					var no178 = " ****".charCodeAt(i179);
					if(no178 == null) {
						break;
					}
					var v178;
					switch(no178) {
					case 32:
						v178 = false;
						break;
					case 42:
						v178 = true;
						break;
					case 48:
						v178 = false;
						break;
					case 49:
						v178 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i179)));
					}
					switch(i179 - (l178 - 8)) {
					case 0:
						if(v178) {
							bs178 |= 128;
						} else {
							bs178 &= -129;
						}
						break;
					case 1:
						if(v178) {
							bs178 |= 64;
						} else {
							bs178 &= -65;
						}
						break;
					case 2:
						if(v178) {
							bs178 |= 32;
						} else {
							bs178 &= -33;
						}
						break;
					case 3:
						if(v178) {
							bs178 |= 16;
						} else {
							bs178 &= -17;
						}
						break;
					case 4:
						if(v178) {
							bs178 |= 8;
						} else {
							bs178 &= -9;
						}
						break;
					case 5:
						if(v178) {
							bs178 |= 4;
						} else {
							bs178 &= -5;
						}
						break;
					case 6:
						if(v178) {
							bs178 |= 2;
						} else {
							bs178 &= -3;
						}
						break;
					case 7:
						if(v178) {
							bs178 |= 1;
						} else {
							bs178 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs178;
				var this180 = 0;
				var bs179 = this180;
				var l179 = "    *".length;
				var _g1180 = 0;
				var _g280 = l179;
				while(_g1180 < _g280) {
					var i180 = _g1180++;
					var no179 = "    *".charCodeAt(i180);
					if(no179 == null) {
						break;
					}
					var v179;
					switch(no179) {
					case 32:
						v179 = false;
						break;
					case 42:
						v179 = true;
						break;
					case 48:
						v179 = false;
						break;
					case 49:
						v179 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i180)));
					}
					switch(i180 - (l179 - 8)) {
					case 0:
						if(v179) {
							bs179 |= 128;
						} else {
							bs179 &= -129;
						}
						break;
					case 1:
						if(v179) {
							bs179 |= 64;
						} else {
							bs179 &= -65;
						}
						break;
					case 2:
						if(v179) {
							bs179 |= 32;
						} else {
							bs179 &= -33;
						}
						break;
					case 3:
						if(v179) {
							bs179 |= 16;
						} else {
							bs179 &= -17;
						}
						break;
					case 4:
						if(v179) {
							bs179 |= 8;
						} else {
							bs179 &= -9;
						}
						break;
					case 5:
						if(v179) {
							bs179 |= 4;
						} else {
							bs179 &= -5;
						}
						break;
					case 6:
						if(v179) {
							bs179 |= 2;
						} else {
							bs179 &= -3;
						}
						break;
					case 7:
						if(v179) {
							bs179 |= 1;
						} else {
							bs179 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs179;
				var this181 = 0;
				var bs180 = this181;
				var l180 = "   * ".length;
				var _g1181 = 0;
				var _g281 = l180;
				while(_g1181 < _g281) {
					var i181 = _g1181++;
					var no180 = "   * ".charCodeAt(i181);
					if(no180 == null) {
						break;
					}
					var v180;
					switch(no180) {
					case 32:
						v180 = false;
						break;
					case 42:
						v180 = true;
						break;
					case 48:
						v180 = false;
						break;
					case 49:
						v180 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i181)));
					}
					switch(i181 - (l180 - 8)) {
					case 0:
						if(v180) {
							bs180 |= 128;
						} else {
							bs180 &= -129;
						}
						break;
					case 1:
						if(v180) {
							bs180 |= 64;
						} else {
							bs180 &= -65;
						}
						break;
					case 2:
						if(v180) {
							bs180 |= 32;
						} else {
							bs180 &= -33;
						}
						break;
					case 3:
						if(v180) {
							bs180 |= 16;
						} else {
							bs180 &= -17;
						}
						break;
					case 4:
						if(v180) {
							bs180 |= 8;
						} else {
							bs180 &= -9;
						}
						break;
					case 5:
						if(v180) {
							bs180 |= 4;
						} else {
							bs180 &= -5;
						}
						break;
					case 6:
						if(v180) {
							bs180 |= 2;
						} else {
							bs180 &= -3;
						}
						break;
					case 7:
						if(v180) {
							bs180 |= 1;
						} else {
							bs180 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs180;
				var this182 = 0;
				var bs181 = this182;
				var l181 = " **  ".length;
				var _g1182 = 0;
				var _g282 = l181;
				while(_g1182 < _g282) {
					var i182 = _g1182++;
					var no181 = " **  ".charCodeAt(i182);
					if(no181 == null) {
						break;
					}
					var v181;
					switch(no181) {
					case 32:
						v181 = false;
						break;
					case 42:
						v181 = true;
						break;
					case 48:
						v181 = false;
						break;
					case 49:
						v181 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i182)));
					}
					switch(i182 - (l181 - 8)) {
					case 0:
						if(v181) {
							bs181 |= 128;
						} else {
							bs181 &= -129;
						}
						break;
					case 1:
						if(v181) {
							bs181 |= 64;
						} else {
							bs181 &= -65;
						}
						break;
					case 2:
						if(v181) {
							bs181 |= 32;
						} else {
							bs181 &= -33;
						}
						break;
					case 3:
						if(v181) {
							bs181 |= 16;
						} else {
							bs181 &= -17;
						}
						break;
					case 4:
						if(v181) {
							bs181 |= 8;
						} else {
							bs181 &= -9;
						}
						break;
					case 5:
						if(v181) {
							bs181 |= 4;
						} else {
							bs181 &= -5;
						}
						break;
					case 6:
						if(v181) {
							bs181 |= 2;
						} else {
							bs181 &= -3;
						}
						break;
					case 7:
						if(v181) {
							bs181 |= 1;
						} else {
							bs181 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs181;
				break;
			case 58:
				var this183 = 0;
				var bs182 = this183;
				var l182 = "     ".length;
				var _g1183 = 0;
				var _g283 = l182;
				while(_g1183 < _g283) {
					var i183 = _g1183++;
					var no182 = "     ".charCodeAt(i183);
					if(no182 == null) {
						break;
					}
					var v182;
					switch(no182) {
					case 32:
						v182 = false;
						break;
					case 42:
						v182 = true;
						break;
					case 48:
						v182 = false;
						break;
					case 49:
						v182 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i183)));
					}
					switch(i183 - (l182 - 8)) {
					case 0:
						if(v182) {
							bs182 |= 128;
						} else {
							bs182 &= -129;
						}
						break;
					case 1:
						if(v182) {
							bs182 |= 64;
						} else {
							bs182 &= -65;
						}
						break;
					case 2:
						if(v182) {
							bs182 |= 32;
						} else {
							bs182 &= -33;
						}
						break;
					case 3:
						if(v182) {
							bs182 |= 16;
						} else {
							bs182 &= -17;
						}
						break;
					case 4:
						if(v182) {
							bs182 |= 8;
						} else {
							bs182 &= -9;
						}
						break;
					case 5:
						if(v182) {
							bs182 |= 4;
						} else {
							bs182 &= -5;
						}
						break;
					case 6:
						if(v182) {
							bs182 |= 2;
						} else {
							bs182 &= -3;
						}
						break;
					case 7:
						if(v182) {
							bs182 |= 1;
						} else {
							bs182 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs182;
				var this184 = 0;
				var bs183 = this184;
				var l183 = "  ** ".length;
				var _g1184 = 0;
				var _g284 = l183;
				while(_g1184 < _g284) {
					var i184 = _g1184++;
					var no183 = "  ** ".charCodeAt(i184);
					if(no183 == null) {
						break;
					}
					var v183;
					switch(no183) {
					case 32:
						v183 = false;
						break;
					case 42:
						v183 = true;
						break;
					case 48:
						v183 = false;
						break;
					case 49:
						v183 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i184)));
					}
					switch(i184 - (l183 - 8)) {
					case 0:
						if(v183) {
							bs183 |= 128;
						} else {
							bs183 &= -129;
						}
						break;
					case 1:
						if(v183) {
							bs183 |= 64;
						} else {
							bs183 &= -65;
						}
						break;
					case 2:
						if(v183) {
							bs183 |= 32;
						} else {
							bs183 &= -33;
						}
						break;
					case 3:
						if(v183) {
							bs183 |= 16;
						} else {
							bs183 &= -17;
						}
						break;
					case 4:
						if(v183) {
							bs183 |= 8;
						} else {
							bs183 &= -9;
						}
						break;
					case 5:
						if(v183) {
							bs183 |= 4;
						} else {
							bs183 &= -5;
						}
						break;
					case 6:
						if(v183) {
							bs183 |= 2;
						} else {
							bs183 &= -3;
						}
						break;
					case 7:
						if(v183) {
							bs183 |= 1;
						} else {
							bs183 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs183;
				var this185 = 0;
				var bs184 = this185;
				var l184 = "  ** ".length;
				var _g1185 = 0;
				var _g285 = l184;
				while(_g1185 < _g285) {
					var i185 = _g1185++;
					var no184 = "  ** ".charCodeAt(i185);
					if(no184 == null) {
						break;
					}
					var v184;
					switch(no184) {
					case 32:
						v184 = false;
						break;
					case 42:
						v184 = true;
						break;
					case 48:
						v184 = false;
						break;
					case 49:
						v184 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i185)));
					}
					switch(i185 - (l184 - 8)) {
					case 0:
						if(v184) {
							bs184 |= 128;
						} else {
							bs184 &= -129;
						}
						break;
					case 1:
						if(v184) {
							bs184 |= 64;
						} else {
							bs184 &= -65;
						}
						break;
					case 2:
						if(v184) {
							bs184 |= 32;
						} else {
							bs184 &= -33;
						}
						break;
					case 3:
						if(v184) {
							bs184 |= 16;
						} else {
							bs184 &= -17;
						}
						break;
					case 4:
						if(v184) {
							bs184 |= 8;
						} else {
							bs184 &= -9;
						}
						break;
					case 5:
						if(v184) {
							bs184 |= 4;
						} else {
							bs184 &= -5;
						}
						break;
					case 6:
						if(v184) {
							bs184 |= 2;
						} else {
							bs184 &= -3;
						}
						break;
					case 7:
						if(v184) {
							bs184 |= 1;
						} else {
							bs184 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs184;
				var this186 = 0;
				var bs185 = this186;
				var l185 = "     ".length;
				var _g1186 = 0;
				var _g286 = l185;
				while(_g1186 < _g286) {
					var i186 = _g1186++;
					var no185 = "     ".charCodeAt(i186);
					if(no185 == null) {
						break;
					}
					var v185;
					switch(no185) {
					case 32:
						v185 = false;
						break;
					case 42:
						v185 = true;
						break;
					case 48:
						v185 = false;
						break;
					case 49:
						v185 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i186)));
					}
					switch(i186 - (l185 - 8)) {
					case 0:
						if(v185) {
							bs185 |= 128;
						} else {
							bs185 &= -129;
						}
						break;
					case 1:
						if(v185) {
							bs185 |= 64;
						} else {
							bs185 &= -65;
						}
						break;
					case 2:
						if(v185) {
							bs185 |= 32;
						} else {
							bs185 &= -33;
						}
						break;
					case 3:
						if(v185) {
							bs185 |= 16;
						} else {
							bs185 &= -17;
						}
						break;
					case 4:
						if(v185) {
							bs185 |= 8;
						} else {
							bs185 &= -9;
						}
						break;
					case 5:
						if(v185) {
							bs185 |= 4;
						} else {
							bs185 &= -5;
						}
						break;
					case 6:
						if(v185) {
							bs185 |= 2;
						} else {
							bs185 &= -3;
						}
						break;
					case 7:
						if(v185) {
							bs185 |= 1;
						} else {
							bs185 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs185;
				var this187 = 0;
				var bs186 = this187;
				var l186 = "  ** ".length;
				var _g1187 = 0;
				var _g287 = l186;
				while(_g1187 < _g287) {
					var i187 = _g1187++;
					var no186 = "  ** ".charCodeAt(i187);
					if(no186 == null) {
						break;
					}
					var v186;
					switch(no186) {
					case 32:
						v186 = false;
						break;
					case 42:
						v186 = true;
						break;
					case 48:
						v186 = false;
						break;
					case 49:
						v186 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i187)));
					}
					switch(i187 - (l186 - 8)) {
					case 0:
						if(v186) {
							bs186 |= 128;
						} else {
							bs186 &= -129;
						}
						break;
					case 1:
						if(v186) {
							bs186 |= 64;
						} else {
							bs186 &= -65;
						}
						break;
					case 2:
						if(v186) {
							bs186 |= 32;
						} else {
							bs186 &= -33;
						}
						break;
					case 3:
						if(v186) {
							bs186 |= 16;
						} else {
							bs186 &= -17;
						}
						break;
					case 4:
						if(v186) {
							bs186 |= 8;
						} else {
							bs186 &= -9;
						}
						break;
					case 5:
						if(v186) {
							bs186 |= 4;
						} else {
							bs186 &= -5;
						}
						break;
					case 6:
						if(v186) {
							bs186 |= 2;
						} else {
							bs186 &= -3;
						}
						break;
					case 7:
						if(v186) {
							bs186 |= 1;
						} else {
							bs186 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs186;
				var this188 = 0;
				var bs187 = this188;
				var l187 = "  ** ".length;
				var _g1188 = 0;
				var _g288 = l187;
				while(_g1188 < _g288) {
					var i188 = _g1188++;
					var no187 = "  ** ".charCodeAt(i188);
					if(no187 == null) {
						break;
					}
					var v187;
					switch(no187) {
					case 32:
						v187 = false;
						break;
					case 42:
						v187 = true;
						break;
					case 48:
						v187 = false;
						break;
					case 49:
						v187 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i188)));
					}
					switch(i188 - (l187 - 8)) {
					case 0:
						if(v187) {
							bs187 |= 128;
						} else {
							bs187 &= -129;
						}
						break;
					case 1:
						if(v187) {
							bs187 |= 64;
						} else {
							bs187 &= -65;
						}
						break;
					case 2:
						if(v187) {
							bs187 |= 32;
						} else {
							bs187 &= -33;
						}
						break;
					case 3:
						if(v187) {
							bs187 |= 16;
						} else {
							bs187 &= -17;
						}
						break;
					case 4:
						if(v187) {
							bs187 |= 8;
						} else {
							bs187 &= -9;
						}
						break;
					case 5:
						if(v187) {
							bs187 |= 4;
						} else {
							bs187 &= -5;
						}
						break;
					case 6:
						if(v187) {
							bs187 |= 2;
						} else {
							bs187 &= -3;
						}
						break;
					case 7:
						if(v187) {
							bs187 |= 1;
						} else {
							bs187 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs187;
				var this189 = 0;
				var bs188 = this189;
				var l188 = "     ".length;
				var _g1189 = 0;
				var _g289 = l188;
				while(_g1189 < _g289) {
					var i189 = _g1189++;
					var no188 = "     ".charCodeAt(i189);
					if(no188 == null) {
						break;
					}
					var v188;
					switch(no188) {
					case 32:
						v188 = false;
						break;
					case 42:
						v188 = true;
						break;
					case 48:
						v188 = false;
						break;
					case 49:
						v188 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i189)));
					}
					switch(i189 - (l188 - 8)) {
					case 0:
						if(v188) {
							bs188 |= 128;
						} else {
							bs188 &= -129;
						}
						break;
					case 1:
						if(v188) {
							bs188 |= 64;
						} else {
							bs188 &= -65;
						}
						break;
					case 2:
						if(v188) {
							bs188 |= 32;
						} else {
							bs188 &= -33;
						}
						break;
					case 3:
						if(v188) {
							bs188 |= 16;
						} else {
							bs188 &= -17;
						}
						break;
					case 4:
						if(v188) {
							bs188 |= 8;
						} else {
							bs188 &= -9;
						}
						break;
					case 5:
						if(v188) {
							bs188 |= 4;
						} else {
							bs188 &= -5;
						}
						break;
					case 6:
						if(v188) {
							bs188 |= 2;
						} else {
							bs188 &= -3;
						}
						break;
					case 7:
						if(v188) {
							bs188 |= 1;
						} else {
							bs188 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs188;
				break;
			case 59:
				var this190 = 0;
				var bs189 = this190;
				var l189 = "     ".length;
				var _g1190 = 0;
				var _g290 = l189;
				while(_g1190 < _g290) {
					var i190 = _g1190++;
					var no189 = "     ".charCodeAt(i190);
					if(no189 == null) {
						break;
					}
					var v189;
					switch(no189) {
					case 32:
						v189 = false;
						break;
					case 42:
						v189 = true;
						break;
					case 48:
						v189 = false;
						break;
					case 49:
						v189 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i190)));
					}
					switch(i190 - (l189 - 8)) {
					case 0:
						if(v189) {
							bs189 |= 128;
						} else {
							bs189 &= -129;
						}
						break;
					case 1:
						if(v189) {
							bs189 |= 64;
						} else {
							bs189 &= -65;
						}
						break;
					case 2:
						if(v189) {
							bs189 |= 32;
						} else {
							bs189 &= -33;
						}
						break;
					case 3:
						if(v189) {
							bs189 |= 16;
						} else {
							bs189 &= -17;
						}
						break;
					case 4:
						if(v189) {
							bs189 |= 8;
						} else {
							bs189 &= -9;
						}
						break;
					case 5:
						if(v189) {
							bs189 |= 4;
						} else {
							bs189 &= -5;
						}
						break;
					case 6:
						if(v189) {
							bs189 |= 2;
						} else {
							bs189 &= -3;
						}
						break;
					case 7:
						if(v189) {
							bs189 |= 1;
						} else {
							bs189 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs189;
				var this191 = 0;
				var bs190 = this191;
				var l190 = "  ** ".length;
				var _g1191 = 0;
				var _g291 = l190;
				while(_g1191 < _g291) {
					var i191 = _g1191++;
					var no190 = "  ** ".charCodeAt(i191);
					if(no190 == null) {
						break;
					}
					var v190;
					switch(no190) {
					case 32:
						v190 = false;
						break;
					case 42:
						v190 = true;
						break;
					case 48:
						v190 = false;
						break;
					case 49:
						v190 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i191)));
					}
					switch(i191 - (l190 - 8)) {
					case 0:
						if(v190) {
							bs190 |= 128;
						} else {
							bs190 &= -129;
						}
						break;
					case 1:
						if(v190) {
							bs190 |= 64;
						} else {
							bs190 &= -65;
						}
						break;
					case 2:
						if(v190) {
							bs190 |= 32;
						} else {
							bs190 &= -33;
						}
						break;
					case 3:
						if(v190) {
							bs190 |= 16;
						} else {
							bs190 &= -17;
						}
						break;
					case 4:
						if(v190) {
							bs190 |= 8;
						} else {
							bs190 &= -9;
						}
						break;
					case 5:
						if(v190) {
							bs190 |= 4;
						} else {
							bs190 &= -5;
						}
						break;
					case 6:
						if(v190) {
							bs190 |= 2;
						} else {
							bs190 &= -3;
						}
						break;
					case 7:
						if(v190) {
							bs190 |= 1;
						} else {
							bs190 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs190;
				var this192 = 0;
				var bs191 = this192;
				var l191 = "  ** ".length;
				var _g1192 = 0;
				var _g292 = l191;
				while(_g1192 < _g292) {
					var i192 = _g1192++;
					var no191 = "  ** ".charCodeAt(i192);
					if(no191 == null) {
						break;
					}
					var v191;
					switch(no191) {
					case 32:
						v191 = false;
						break;
					case 42:
						v191 = true;
						break;
					case 48:
						v191 = false;
						break;
					case 49:
						v191 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i192)));
					}
					switch(i192 - (l191 - 8)) {
					case 0:
						if(v191) {
							bs191 |= 128;
						} else {
							bs191 &= -129;
						}
						break;
					case 1:
						if(v191) {
							bs191 |= 64;
						} else {
							bs191 &= -65;
						}
						break;
					case 2:
						if(v191) {
							bs191 |= 32;
						} else {
							bs191 &= -33;
						}
						break;
					case 3:
						if(v191) {
							bs191 |= 16;
						} else {
							bs191 &= -17;
						}
						break;
					case 4:
						if(v191) {
							bs191 |= 8;
						} else {
							bs191 &= -9;
						}
						break;
					case 5:
						if(v191) {
							bs191 |= 4;
						} else {
							bs191 &= -5;
						}
						break;
					case 6:
						if(v191) {
							bs191 |= 2;
						} else {
							bs191 &= -3;
						}
						break;
					case 7:
						if(v191) {
							bs191 |= 1;
						} else {
							bs191 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs191;
				var this193 = 0;
				var bs192 = this193;
				var l192 = "     ".length;
				var _g1193 = 0;
				var _g293 = l192;
				while(_g1193 < _g293) {
					var i193 = _g1193++;
					var no192 = "     ".charCodeAt(i193);
					if(no192 == null) {
						break;
					}
					var v192;
					switch(no192) {
					case 32:
						v192 = false;
						break;
					case 42:
						v192 = true;
						break;
					case 48:
						v192 = false;
						break;
					case 49:
						v192 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i193)));
					}
					switch(i193 - (l192 - 8)) {
					case 0:
						if(v192) {
							bs192 |= 128;
						} else {
							bs192 &= -129;
						}
						break;
					case 1:
						if(v192) {
							bs192 |= 64;
						} else {
							bs192 &= -65;
						}
						break;
					case 2:
						if(v192) {
							bs192 |= 32;
						} else {
							bs192 &= -33;
						}
						break;
					case 3:
						if(v192) {
							bs192 |= 16;
						} else {
							bs192 &= -17;
						}
						break;
					case 4:
						if(v192) {
							bs192 |= 8;
						} else {
							bs192 &= -9;
						}
						break;
					case 5:
						if(v192) {
							bs192 |= 4;
						} else {
							bs192 &= -5;
						}
						break;
					case 6:
						if(v192) {
							bs192 |= 2;
						} else {
							bs192 &= -3;
						}
						break;
					case 7:
						if(v192) {
							bs192 |= 1;
						} else {
							bs192 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs192;
				var this194 = 0;
				var bs193 = this194;
				var l193 = "  ** ".length;
				var _g1194 = 0;
				var _g294 = l193;
				while(_g1194 < _g294) {
					var i194 = _g1194++;
					var no193 = "  ** ".charCodeAt(i194);
					if(no193 == null) {
						break;
					}
					var v193;
					switch(no193) {
					case 32:
						v193 = false;
						break;
					case 42:
						v193 = true;
						break;
					case 48:
						v193 = false;
						break;
					case 49:
						v193 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i194)));
					}
					switch(i194 - (l193 - 8)) {
					case 0:
						if(v193) {
							bs193 |= 128;
						} else {
							bs193 &= -129;
						}
						break;
					case 1:
						if(v193) {
							bs193 |= 64;
						} else {
							bs193 &= -65;
						}
						break;
					case 2:
						if(v193) {
							bs193 |= 32;
						} else {
							bs193 &= -33;
						}
						break;
					case 3:
						if(v193) {
							bs193 |= 16;
						} else {
							bs193 &= -17;
						}
						break;
					case 4:
						if(v193) {
							bs193 |= 8;
						} else {
							bs193 &= -9;
						}
						break;
					case 5:
						if(v193) {
							bs193 |= 4;
						} else {
							bs193 &= -5;
						}
						break;
					case 6:
						if(v193) {
							bs193 |= 2;
						} else {
							bs193 &= -3;
						}
						break;
					case 7:
						if(v193) {
							bs193 |= 1;
						} else {
							bs193 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs193;
				var this195 = 0;
				var bs194 = this195;
				var l194 = "   * ".length;
				var _g1195 = 0;
				var _g295 = l194;
				while(_g1195 < _g295) {
					var i195 = _g1195++;
					var no194 = "   * ".charCodeAt(i195);
					if(no194 == null) {
						break;
					}
					var v194;
					switch(no194) {
					case 32:
						v194 = false;
						break;
					case 42:
						v194 = true;
						break;
					case 48:
						v194 = false;
						break;
					case 49:
						v194 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i195)));
					}
					switch(i195 - (l194 - 8)) {
					case 0:
						if(v194) {
							bs194 |= 128;
						} else {
							bs194 &= -129;
						}
						break;
					case 1:
						if(v194) {
							bs194 |= 64;
						} else {
							bs194 &= -65;
						}
						break;
					case 2:
						if(v194) {
							bs194 |= 32;
						} else {
							bs194 &= -33;
						}
						break;
					case 3:
						if(v194) {
							bs194 |= 16;
						} else {
							bs194 &= -17;
						}
						break;
					case 4:
						if(v194) {
							bs194 |= 8;
						} else {
							bs194 &= -9;
						}
						break;
					case 5:
						if(v194) {
							bs194 |= 4;
						} else {
							bs194 &= -5;
						}
						break;
					case 6:
						if(v194) {
							bs194 |= 2;
						} else {
							bs194 &= -3;
						}
						break;
					case 7:
						if(v194) {
							bs194 |= 1;
						} else {
							bs194 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs194;
				var this196 = 0;
				var bs195 = this196;
				var l195 = "  *  ".length;
				var _g1196 = 0;
				var _g296 = l195;
				while(_g1196 < _g296) {
					var i196 = _g1196++;
					var no195 = "  *  ".charCodeAt(i196);
					if(no195 == null) {
						break;
					}
					var v195;
					switch(no195) {
					case 32:
						v195 = false;
						break;
					case 42:
						v195 = true;
						break;
					case 48:
						v195 = false;
						break;
					case 49:
						v195 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i196)));
					}
					switch(i196 - (l195 - 8)) {
					case 0:
						if(v195) {
							bs195 |= 128;
						} else {
							bs195 &= -129;
						}
						break;
					case 1:
						if(v195) {
							bs195 |= 64;
						} else {
							bs195 &= -65;
						}
						break;
					case 2:
						if(v195) {
							bs195 |= 32;
						} else {
							bs195 &= -33;
						}
						break;
					case 3:
						if(v195) {
							bs195 |= 16;
						} else {
							bs195 &= -17;
						}
						break;
					case 4:
						if(v195) {
							bs195 |= 8;
						} else {
							bs195 &= -9;
						}
						break;
					case 5:
						if(v195) {
							bs195 |= 4;
						} else {
							bs195 &= -5;
						}
						break;
					case 6:
						if(v195) {
							bs195 |= 2;
						} else {
							bs195 &= -3;
						}
						break;
					case 7:
						if(v195) {
							bs195 |= 1;
						} else {
							bs195 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs195;
				break;
			case 60:
				var this197 = 0;
				var bs196 = this197;
				var l196 = "   * ".length;
				var _g1197 = 0;
				var _g297 = l196;
				while(_g1197 < _g297) {
					var i197 = _g1197++;
					var no196 = "   * ".charCodeAt(i197);
					if(no196 == null) {
						break;
					}
					var v196;
					switch(no196) {
					case 32:
						v196 = false;
						break;
					case 42:
						v196 = true;
						break;
					case 48:
						v196 = false;
						break;
					case 49:
						v196 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i197)));
					}
					switch(i197 - (l196 - 8)) {
					case 0:
						if(v196) {
							bs196 |= 128;
						} else {
							bs196 &= -129;
						}
						break;
					case 1:
						if(v196) {
							bs196 |= 64;
						} else {
							bs196 &= -65;
						}
						break;
					case 2:
						if(v196) {
							bs196 |= 32;
						} else {
							bs196 &= -33;
						}
						break;
					case 3:
						if(v196) {
							bs196 |= 16;
						} else {
							bs196 &= -17;
						}
						break;
					case 4:
						if(v196) {
							bs196 |= 8;
						} else {
							bs196 &= -9;
						}
						break;
					case 5:
						if(v196) {
							bs196 |= 4;
						} else {
							bs196 &= -5;
						}
						break;
					case 6:
						if(v196) {
							bs196 |= 2;
						} else {
							bs196 &= -3;
						}
						break;
					case 7:
						if(v196) {
							bs196 |= 1;
						} else {
							bs196 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs196;
				var this198 = 0;
				var bs197 = this198;
				var l197 = "  *  ".length;
				var _g1198 = 0;
				var _g298 = l197;
				while(_g1198 < _g298) {
					var i198 = _g1198++;
					var no197 = "  *  ".charCodeAt(i198);
					if(no197 == null) {
						break;
					}
					var v197;
					switch(no197) {
					case 32:
						v197 = false;
						break;
					case 42:
						v197 = true;
						break;
					case 48:
						v197 = false;
						break;
					case 49:
						v197 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i198)));
					}
					switch(i198 - (l197 - 8)) {
					case 0:
						if(v197) {
							bs197 |= 128;
						} else {
							bs197 &= -129;
						}
						break;
					case 1:
						if(v197) {
							bs197 |= 64;
						} else {
							bs197 &= -65;
						}
						break;
					case 2:
						if(v197) {
							bs197 |= 32;
						} else {
							bs197 &= -33;
						}
						break;
					case 3:
						if(v197) {
							bs197 |= 16;
						} else {
							bs197 &= -17;
						}
						break;
					case 4:
						if(v197) {
							bs197 |= 8;
						} else {
							bs197 &= -9;
						}
						break;
					case 5:
						if(v197) {
							bs197 |= 4;
						} else {
							bs197 &= -5;
						}
						break;
					case 6:
						if(v197) {
							bs197 |= 2;
						} else {
							bs197 &= -3;
						}
						break;
					case 7:
						if(v197) {
							bs197 |= 1;
						} else {
							bs197 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs197;
				var this199 = 0;
				var bs198 = this199;
				var l198 = " *   ".length;
				var _g1199 = 0;
				var _g299 = l198;
				while(_g1199 < _g299) {
					var i199 = _g1199++;
					var no198 = " *   ".charCodeAt(i199);
					if(no198 == null) {
						break;
					}
					var v198;
					switch(no198) {
					case 32:
						v198 = false;
						break;
					case 42:
						v198 = true;
						break;
					case 48:
						v198 = false;
						break;
					case 49:
						v198 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i199)));
					}
					switch(i199 - (l198 - 8)) {
					case 0:
						if(v198) {
							bs198 |= 128;
						} else {
							bs198 &= -129;
						}
						break;
					case 1:
						if(v198) {
							bs198 |= 64;
						} else {
							bs198 &= -65;
						}
						break;
					case 2:
						if(v198) {
							bs198 |= 32;
						} else {
							bs198 &= -33;
						}
						break;
					case 3:
						if(v198) {
							bs198 |= 16;
						} else {
							bs198 &= -17;
						}
						break;
					case 4:
						if(v198) {
							bs198 |= 8;
						} else {
							bs198 &= -9;
						}
						break;
					case 5:
						if(v198) {
							bs198 |= 4;
						} else {
							bs198 &= -5;
						}
						break;
					case 6:
						if(v198) {
							bs198 |= 2;
						} else {
							bs198 &= -3;
						}
						break;
					case 7:
						if(v198) {
							bs198 |= 1;
						} else {
							bs198 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs198;
				var this200 = 0;
				var bs199 = this200;
				var l199 = "*    ".length;
				var _g1200 = 0;
				var _g300 = l199;
				while(_g1200 < _g300) {
					var i200 = _g1200++;
					var no199 = "*    ".charCodeAt(i200);
					if(no199 == null) {
						break;
					}
					var v199;
					switch(no199) {
					case 32:
						v199 = false;
						break;
					case 42:
						v199 = true;
						break;
					case 48:
						v199 = false;
						break;
					case 49:
						v199 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i200)));
					}
					switch(i200 - (l199 - 8)) {
					case 0:
						if(v199) {
							bs199 |= 128;
						} else {
							bs199 &= -129;
						}
						break;
					case 1:
						if(v199) {
							bs199 |= 64;
						} else {
							bs199 &= -65;
						}
						break;
					case 2:
						if(v199) {
							bs199 |= 32;
						} else {
							bs199 &= -33;
						}
						break;
					case 3:
						if(v199) {
							bs199 |= 16;
						} else {
							bs199 &= -17;
						}
						break;
					case 4:
						if(v199) {
							bs199 |= 8;
						} else {
							bs199 &= -9;
						}
						break;
					case 5:
						if(v199) {
							bs199 |= 4;
						} else {
							bs199 &= -5;
						}
						break;
					case 6:
						if(v199) {
							bs199 |= 2;
						} else {
							bs199 &= -3;
						}
						break;
					case 7:
						if(v199) {
							bs199 |= 1;
						} else {
							bs199 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs199;
				var this201 = 0;
				var bs200 = this201;
				var l200 = " *   ".length;
				var _g1201 = 0;
				var _g301 = l200;
				while(_g1201 < _g301) {
					var i201 = _g1201++;
					var no200 = " *   ".charCodeAt(i201);
					if(no200 == null) {
						break;
					}
					var v200;
					switch(no200) {
					case 32:
						v200 = false;
						break;
					case 42:
						v200 = true;
						break;
					case 48:
						v200 = false;
						break;
					case 49:
						v200 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i201)));
					}
					switch(i201 - (l200 - 8)) {
					case 0:
						if(v200) {
							bs200 |= 128;
						} else {
							bs200 &= -129;
						}
						break;
					case 1:
						if(v200) {
							bs200 |= 64;
						} else {
							bs200 &= -65;
						}
						break;
					case 2:
						if(v200) {
							bs200 |= 32;
						} else {
							bs200 &= -33;
						}
						break;
					case 3:
						if(v200) {
							bs200 |= 16;
						} else {
							bs200 &= -17;
						}
						break;
					case 4:
						if(v200) {
							bs200 |= 8;
						} else {
							bs200 &= -9;
						}
						break;
					case 5:
						if(v200) {
							bs200 |= 4;
						} else {
							bs200 &= -5;
						}
						break;
					case 6:
						if(v200) {
							bs200 |= 2;
						} else {
							bs200 &= -3;
						}
						break;
					case 7:
						if(v200) {
							bs200 |= 1;
						} else {
							bs200 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs200;
				var this202 = 0;
				var bs201 = this202;
				var l201 = "  *  ".length;
				var _g1202 = 0;
				var _g302 = l201;
				while(_g1202 < _g302) {
					var i202 = _g1202++;
					var no201 = "  *  ".charCodeAt(i202);
					if(no201 == null) {
						break;
					}
					var v201;
					switch(no201) {
					case 32:
						v201 = false;
						break;
					case 42:
						v201 = true;
						break;
					case 48:
						v201 = false;
						break;
					case 49:
						v201 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i202)));
					}
					switch(i202 - (l201 - 8)) {
					case 0:
						if(v201) {
							bs201 |= 128;
						} else {
							bs201 &= -129;
						}
						break;
					case 1:
						if(v201) {
							bs201 |= 64;
						} else {
							bs201 &= -65;
						}
						break;
					case 2:
						if(v201) {
							bs201 |= 32;
						} else {
							bs201 &= -33;
						}
						break;
					case 3:
						if(v201) {
							bs201 |= 16;
						} else {
							bs201 &= -17;
						}
						break;
					case 4:
						if(v201) {
							bs201 |= 8;
						} else {
							bs201 &= -9;
						}
						break;
					case 5:
						if(v201) {
							bs201 |= 4;
						} else {
							bs201 &= -5;
						}
						break;
					case 6:
						if(v201) {
							bs201 |= 2;
						} else {
							bs201 &= -3;
						}
						break;
					case 7:
						if(v201) {
							bs201 |= 1;
						} else {
							bs201 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs201;
				var this203 = 0;
				var bs202 = this203;
				var l202 = "   * ".length;
				var _g1203 = 0;
				var _g303 = l202;
				while(_g1203 < _g303) {
					var i203 = _g1203++;
					var no202 = "   * ".charCodeAt(i203);
					if(no202 == null) {
						break;
					}
					var v202;
					switch(no202) {
					case 32:
						v202 = false;
						break;
					case 42:
						v202 = true;
						break;
					case 48:
						v202 = false;
						break;
					case 49:
						v202 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i203)));
					}
					switch(i203 - (l202 - 8)) {
					case 0:
						if(v202) {
							bs202 |= 128;
						} else {
							bs202 &= -129;
						}
						break;
					case 1:
						if(v202) {
							bs202 |= 64;
						} else {
							bs202 &= -65;
						}
						break;
					case 2:
						if(v202) {
							bs202 |= 32;
						} else {
							bs202 &= -33;
						}
						break;
					case 3:
						if(v202) {
							bs202 |= 16;
						} else {
							bs202 &= -17;
						}
						break;
					case 4:
						if(v202) {
							bs202 |= 8;
						} else {
							bs202 &= -9;
						}
						break;
					case 5:
						if(v202) {
							bs202 |= 4;
						} else {
							bs202 &= -5;
						}
						break;
					case 6:
						if(v202) {
							bs202 |= 2;
						} else {
							bs202 &= -3;
						}
						break;
					case 7:
						if(v202) {
							bs202 |= 1;
						} else {
							bs202 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs202;
				break;
			case 61:
				var this204 = 0;
				var bs203 = this204;
				var l203 = "     ".length;
				var _g1204 = 0;
				var _g304 = l203;
				while(_g1204 < _g304) {
					var i204 = _g1204++;
					var no203 = "     ".charCodeAt(i204);
					if(no203 == null) {
						break;
					}
					var v203;
					switch(no203) {
					case 32:
						v203 = false;
						break;
					case 42:
						v203 = true;
						break;
					case 48:
						v203 = false;
						break;
					case 49:
						v203 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i204)));
					}
					switch(i204 - (l203 - 8)) {
					case 0:
						if(v203) {
							bs203 |= 128;
						} else {
							bs203 &= -129;
						}
						break;
					case 1:
						if(v203) {
							bs203 |= 64;
						} else {
							bs203 &= -65;
						}
						break;
					case 2:
						if(v203) {
							bs203 |= 32;
						} else {
							bs203 &= -33;
						}
						break;
					case 3:
						if(v203) {
							bs203 |= 16;
						} else {
							bs203 &= -17;
						}
						break;
					case 4:
						if(v203) {
							bs203 |= 8;
						} else {
							bs203 &= -9;
						}
						break;
					case 5:
						if(v203) {
							bs203 |= 4;
						} else {
							bs203 &= -5;
						}
						break;
					case 6:
						if(v203) {
							bs203 |= 2;
						} else {
							bs203 &= -3;
						}
						break;
					case 7:
						if(v203) {
							bs203 |= 1;
						} else {
							bs203 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs203;
				var this205 = 0;
				var bs204 = this205;
				var l204 = "     ".length;
				var _g1205 = 0;
				var _g305 = l204;
				while(_g1205 < _g305) {
					var i205 = _g1205++;
					var no204 = "     ".charCodeAt(i205);
					if(no204 == null) {
						break;
					}
					var v204;
					switch(no204) {
					case 32:
						v204 = false;
						break;
					case 42:
						v204 = true;
						break;
					case 48:
						v204 = false;
						break;
					case 49:
						v204 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i205)));
					}
					switch(i205 - (l204 - 8)) {
					case 0:
						if(v204) {
							bs204 |= 128;
						} else {
							bs204 &= -129;
						}
						break;
					case 1:
						if(v204) {
							bs204 |= 64;
						} else {
							bs204 &= -65;
						}
						break;
					case 2:
						if(v204) {
							bs204 |= 32;
						} else {
							bs204 &= -33;
						}
						break;
					case 3:
						if(v204) {
							bs204 |= 16;
						} else {
							bs204 &= -17;
						}
						break;
					case 4:
						if(v204) {
							bs204 |= 8;
						} else {
							bs204 &= -9;
						}
						break;
					case 5:
						if(v204) {
							bs204 |= 4;
						} else {
							bs204 &= -5;
						}
						break;
					case 6:
						if(v204) {
							bs204 |= 2;
						} else {
							bs204 &= -3;
						}
						break;
					case 7:
						if(v204) {
							bs204 |= 1;
						} else {
							bs204 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs204;
				var this206 = 0;
				var bs205 = this206;
				var l205 = "*****".length;
				var _g1206 = 0;
				var _g306 = l205;
				while(_g1206 < _g306) {
					var i206 = _g1206++;
					var no205 = "*****".charCodeAt(i206);
					if(no205 == null) {
						break;
					}
					var v205;
					switch(no205) {
					case 32:
						v205 = false;
						break;
					case 42:
						v205 = true;
						break;
					case 48:
						v205 = false;
						break;
					case 49:
						v205 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i206)));
					}
					switch(i206 - (l205 - 8)) {
					case 0:
						if(v205) {
							bs205 |= 128;
						} else {
							bs205 &= -129;
						}
						break;
					case 1:
						if(v205) {
							bs205 |= 64;
						} else {
							bs205 &= -65;
						}
						break;
					case 2:
						if(v205) {
							bs205 |= 32;
						} else {
							bs205 &= -33;
						}
						break;
					case 3:
						if(v205) {
							bs205 |= 16;
						} else {
							bs205 &= -17;
						}
						break;
					case 4:
						if(v205) {
							bs205 |= 8;
						} else {
							bs205 &= -9;
						}
						break;
					case 5:
						if(v205) {
							bs205 |= 4;
						} else {
							bs205 &= -5;
						}
						break;
					case 6:
						if(v205) {
							bs205 |= 2;
						} else {
							bs205 &= -3;
						}
						break;
					case 7:
						if(v205) {
							bs205 |= 1;
						} else {
							bs205 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs205;
				var this207 = 0;
				var bs206 = this207;
				var l206 = "     ".length;
				var _g1207 = 0;
				var _g307 = l206;
				while(_g1207 < _g307) {
					var i207 = _g1207++;
					var no206 = "     ".charCodeAt(i207);
					if(no206 == null) {
						break;
					}
					var v206;
					switch(no206) {
					case 32:
						v206 = false;
						break;
					case 42:
						v206 = true;
						break;
					case 48:
						v206 = false;
						break;
					case 49:
						v206 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i207)));
					}
					switch(i207 - (l206 - 8)) {
					case 0:
						if(v206) {
							bs206 |= 128;
						} else {
							bs206 &= -129;
						}
						break;
					case 1:
						if(v206) {
							bs206 |= 64;
						} else {
							bs206 &= -65;
						}
						break;
					case 2:
						if(v206) {
							bs206 |= 32;
						} else {
							bs206 &= -33;
						}
						break;
					case 3:
						if(v206) {
							bs206 |= 16;
						} else {
							bs206 &= -17;
						}
						break;
					case 4:
						if(v206) {
							bs206 |= 8;
						} else {
							bs206 &= -9;
						}
						break;
					case 5:
						if(v206) {
							bs206 |= 4;
						} else {
							bs206 &= -5;
						}
						break;
					case 6:
						if(v206) {
							bs206 |= 2;
						} else {
							bs206 &= -3;
						}
						break;
					case 7:
						if(v206) {
							bs206 |= 1;
						} else {
							bs206 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs206;
				var this208 = 0;
				var bs207 = this208;
				var l207 = "*****".length;
				var _g1208 = 0;
				var _g308 = l207;
				while(_g1208 < _g308) {
					var i208 = _g1208++;
					var no207 = "*****".charCodeAt(i208);
					if(no207 == null) {
						break;
					}
					var v207;
					switch(no207) {
					case 32:
						v207 = false;
						break;
					case 42:
						v207 = true;
						break;
					case 48:
						v207 = false;
						break;
					case 49:
						v207 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i208)));
					}
					switch(i208 - (l207 - 8)) {
					case 0:
						if(v207) {
							bs207 |= 128;
						} else {
							bs207 &= -129;
						}
						break;
					case 1:
						if(v207) {
							bs207 |= 64;
						} else {
							bs207 &= -65;
						}
						break;
					case 2:
						if(v207) {
							bs207 |= 32;
						} else {
							bs207 &= -33;
						}
						break;
					case 3:
						if(v207) {
							bs207 |= 16;
						} else {
							bs207 &= -17;
						}
						break;
					case 4:
						if(v207) {
							bs207 |= 8;
						} else {
							bs207 &= -9;
						}
						break;
					case 5:
						if(v207) {
							bs207 |= 4;
						} else {
							bs207 &= -5;
						}
						break;
					case 6:
						if(v207) {
							bs207 |= 2;
						} else {
							bs207 &= -3;
						}
						break;
					case 7:
						if(v207) {
							bs207 |= 1;
						} else {
							bs207 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs207;
				var this209 = 0;
				var bs208 = this209;
				var l208 = "     ".length;
				var _g1209 = 0;
				var _g309 = l208;
				while(_g1209 < _g309) {
					var i209 = _g1209++;
					var no208 = "     ".charCodeAt(i209);
					if(no208 == null) {
						break;
					}
					var v208;
					switch(no208) {
					case 32:
						v208 = false;
						break;
					case 42:
						v208 = true;
						break;
					case 48:
						v208 = false;
						break;
					case 49:
						v208 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i209)));
					}
					switch(i209 - (l208 - 8)) {
					case 0:
						if(v208) {
							bs208 |= 128;
						} else {
							bs208 &= -129;
						}
						break;
					case 1:
						if(v208) {
							bs208 |= 64;
						} else {
							bs208 &= -65;
						}
						break;
					case 2:
						if(v208) {
							bs208 |= 32;
						} else {
							bs208 &= -33;
						}
						break;
					case 3:
						if(v208) {
							bs208 |= 16;
						} else {
							bs208 &= -17;
						}
						break;
					case 4:
						if(v208) {
							bs208 |= 8;
						} else {
							bs208 &= -9;
						}
						break;
					case 5:
						if(v208) {
							bs208 |= 4;
						} else {
							bs208 &= -5;
						}
						break;
					case 6:
						if(v208) {
							bs208 |= 2;
						} else {
							bs208 &= -3;
						}
						break;
					case 7:
						if(v208) {
							bs208 |= 1;
						} else {
							bs208 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs208;
				var this210 = 0;
				var bs209 = this210;
				var l209 = "     ".length;
				var _g1210 = 0;
				var _g310 = l209;
				while(_g1210 < _g310) {
					var i210 = _g1210++;
					var no209 = "     ".charCodeAt(i210);
					if(no209 == null) {
						break;
					}
					var v209;
					switch(no209) {
					case 32:
						v209 = false;
						break;
					case 42:
						v209 = true;
						break;
					case 48:
						v209 = false;
						break;
					case 49:
						v209 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i210)));
					}
					switch(i210 - (l209 - 8)) {
					case 0:
						if(v209) {
							bs209 |= 128;
						} else {
							bs209 &= -129;
						}
						break;
					case 1:
						if(v209) {
							bs209 |= 64;
						} else {
							bs209 &= -65;
						}
						break;
					case 2:
						if(v209) {
							bs209 |= 32;
						} else {
							bs209 &= -33;
						}
						break;
					case 3:
						if(v209) {
							bs209 |= 16;
						} else {
							bs209 &= -17;
						}
						break;
					case 4:
						if(v209) {
							bs209 |= 8;
						} else {
							bs209 &= -9;
						}
						break;
					case 5:
						if(v209) {
							bs209 |= 4;
						} else {
							bs209 &= -5;
						}
						break;
					case 6:
						if(v209) {
							bs209 |= 2;
						} else {
							bs209 &= -3;
						}
						break;
					case 7:
						if(v209) {
							bs209 |= 1;
						} else {
							bs209 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs209;
				break;
			case 62:
				var this211 = 0;
				var bs210 = this211;
				var l210 = " *   ".length;
				var _g1211 = 0;
				var _g311 = l210;
				while(_g1211 < _g311) {
					var i211 = _g1211++;
					var no210 = " *   ".charCodeAt(i211);
					if(no210 == null) {
						break;
					}
					var v210;
					switch(no210) {
					case 32:
						v210 = false;
						break;
					case 42:
						v210 = true;
						break;
					case 48:
						v210 = false;
						break;
					case 49:
						v210 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i211)));
					}
					switch(i211 - (l210 - 8)) {
					case 0:
						if(v210) {
							bs210 |= 128;
						} else {
							bs210 &= -129;
						}
						break;
					case 1:
						if(v210) {
							bs210 |= 64;
						} else {
							bs210 &= -65;
						}
						break;
					case 2:
						if(v210) {
							bs210 |= 32;
						} else {
							bs210 &= -33;
						}
						break;
					case 3:
						if(v210) {
							bs210 |= 16;
						} else {
							bs210 &= -17;
						}
						break;
					case 4:
						if(v210) {
							bs210 |= 8;
						} else {
							bs210 &= -9;
						}
						break;
					case 5:
						if(v210) {
							bs210 |= 4;
						} else {
							bs210 &= -5;
						}
						break;
					case 6:
						if(v210) {
							bs210 |= 2;
						} else {
							bs210 &= -3;
						}
						break;
					case 7:
						if(v210) {
							bs210 |= 1;
						} else {
							bs210 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs210;
				var this212 = 0;
				var bs211 = this212;
				var l211 = "  *  ".length;
				var _g1212 = 0;
				var _g312 = l211;
				while(_g1212 < _g312) {
					var i212 = _g1212++;
					var no211 = "  *  ".charCodeAt(i212);
					if(no211 == null) {
						break;
					}
					var v211;
					switch(no211) {
					case 32:
						v211 = false;
						break;
					case 42:
						v211 = true;
						break;
					case 48:
						v211 = false;
						break;
					case 49:
						v211 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i212)));
					}
					switch(i212 - (l211 - 8)) {
					case 0:
						if(v211) {
							bs211 |= 128;
						} else {
							bs211 &= -129;
						}
						break;
					case 1:
						if(v211) {
							bs211 |= 64;
						} else {
							bs211 &= -65;
						}
						break;
					case 2:
						if(v211) {
							bs211 |= 32;
						} else {
							bs211 &= -33;
						}
						break;
					case 3:
						if(v211) {
							bs211 |= 16;
						} else {
							bs211 &= -17;
						}
						break;
					case 4:
						if(v211) {
							bs211 |= 8;
						} else {
							bs211 &= -9;
						}
						break;
					case 5:
						if(v211) {
							bs211 |= 4;
						} else {
							bs211 &= -5;
						}
						break;
					case 6:
						if(v211) {
							bs211 |= 2;
						} else {
							bs211 &= -3;
						}
						break;
					case 7:
						if(v211) {
							bs211 |= 1;
						} else {
							bs211 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs211;
				var this213 = 0;
				var bs212 = this213;
				var l212 = "   * ".length;
				var _g1213 = 0;
				var _g313 = l212;
				while(_g1213 < _g313) {
					var i213 = _g1213++;
					var no212 = "   * ".charCodeAt(i213);
					if(no212 == null) {
						break;
					}
					var v212;
					switch(no212) {
					case 32:
						v212 = false;
						break;
					case 42:
						v212 = true;
						break;
					case 48:
						v212 = false;
						break;
					case 49:
						v212 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i213)));
					}
					switch(i213 - (l212 - 8)) {
					case 0:
						if(v212) {
							bs212 |= 128;
						} else {
							bs212 &= -129;
						}
						break;
					case 1:
						if(v212) {
							bs212 |= 64;
						} else {
							bs212 &= -65;
						}
						break;
					case 2:
						if(v212) {
							bs212 |= 32;
						} else {
							bs212 &= -33;
						}
						break;
					case 3:
						if(v212) {
							bs212 |= 16;
						} else {
							bs212 &= -17;
						}
						break;
					case 4:
						if(v212) {
							bs212 |= 8;
						} else {
							bs212 &= -9;
						}
						break;
					case 5:
						if(v212) {
							bs212 |= 4;
						} else {
							bs212 &= -5;
						}
						break;
					case 6:
						if(v212) {
							bs212 |= 2;
						} else {
							bs212 &= -3;
						}
						break;
					case 7:
						if(v212) {
							bs212 |= 1;
						} else {
							bs212 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs212;
				var this214 = 0;
				var bs213 = this214;
				var l213 = "    *".length;
				var _g1214 = 0;
				var _g314 = l213;
				while(_g1214 < _g314) {
					var i214 = _g1214++;
					var no213 = "    *".charCodeAt(i214);
					if(no213 == null) {
						break;
					}
					var v213;
					switch(no213) {
					case 32:
						v213 = false;
						break;
					case 42:
						v213 = true;
						break;
					case 48:
						v213 = false;
						break;
					case 49:
						v213 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i214)));
					}
					switch(i214 - (l213 - 8)) {
					case 0:
						if(v213) {
							bs213 |= 128;
						} else {
							bs213 &= -129;
						}
						break;
					case 1:
						if(v213) {
							bs213 |= 64;
						} else {
							bs213 &= -65;
						}
						break;
					case 2:
						if(v213) {
							bs213 |= 32;
						} else {
							bs213 &= -33;
						}
						break;
					case 3:
						if(v213) {
							bs213 |= 16;
						} else {
							bs213 &= -17;
						}
						break;
					case 4:
						if(v213) {
							bs213 |= 8;
						} else {
							bs213 &= -9;
						}
						break;
					case 5:
						if(v213) {
							bs213 |= 4;
						} else {
							bs213 &= -5;
						}
						break;
					case 6:
						if(v213) {
							bs213 |= 2;
						} else {
							bs213 &= -3;
						}
						break;
					case 7:
						if(v213) {
							bs213 |= 1;
						} else {
							bs213 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs213;
				var this215 = 0;
				var bs214 = this215;
				var l214 = "   * ".length;
				var _g1215 = 0;
				var _g315 = l214;
				while(_g1215 < _g315) {
					var i215 = _g1215++;
					var no214 = "   * ".charCodeAt(i215);
					if(no214 == null) {
						break;
					}
					var v214;
					switch(no214) {
					case 32:
						v214 = false;
						break;
					case 42:
						v214 = true;
						break;
					case 48:
						v214 = false;
						break;
					case 49:
						v214 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i215)));
					}
					switch(i215 - (l214 - 8)) {
					case 0:
						if(v214) {
							bs214 |= 128;
						} else {
							bs214 &= -129;
						}
						break;
					case 1:
						if(v214) {
							bs214 |= 64;
						} else {
							bs214 &= -65;
						}
						break;
					case 2:
						if(v214) {
							bs214 |= 32;
						} else {
							bs214 &= -33;
						}
						break;
					case 3:
						if(v214) {
							bs214 |= 16;
						} else {
							bs214 &= -17;
						}
						break;
					case 4:
						if(v214) {
							bs214 |= 8;
						} else {
							bs214 &= -9;
						}
						break;
					case 5:
						if(v214) {
							bs214 |= 4;
						} else {
							bs214 &= -5;
						}
						break;
					case 6:
						if(v214) {
							bs214 |= 2;
						} else {
							bs214 &= -3;
						}
						break;
					case 7:
						if(v214) {
							bs214 |= 1;
						} else {
							bs214 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs214;
				var this216 = 0;
				var bs215 = this216;
				var l215 = "  *  ".length;
				var _g1216 = 0;
				var _g316 = l215;
				while(_g1216 < _g316) {
					var i216 = _g1216++;
					var no215 = "  *  ".charCodeAt(i216);
					if(no215 == null) {
						break;
					}
					var v215;
					switch(no215) {
					case 32:
						v215 = false;
						break;
					case 42:
						v215 = true;
						break;
					case 48:
						v215 = false;
						break;
					case 49:
						v215 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i216)));
					}
					switch(i216 - (l215 - 8)) {
					case 0:
						if(v215) {
							bs215 |= 128;
						} else {
							bs215 &= -129;
						}
						break;
					case 1:
						if(v215) {
							bs215 |= 64;
						} else {
							bs215 &= -65;
						}
						break;
					case 2:
						if(v215) {
							bs215 |= 32;
						} else {
							bs215 &= -33;
						}
						break;
					case 3:
						if(v215) {
							bs215 |= 16;
						} else {
							bs215 &= -17;
						}
						break;
					case 4:
						if(v215) {
							bs215 |= 8;
						} else {
							bs215 &= -9;
						}
						break;
					case 5:
						if(v215) {
							bs215 |= 4;
						} else {
							bs215 &= -5;
						}
						break;
					case 6:
						if(v215) {
							bs215 |= 2;
						} else {
							bs215 &= -3;
						}
						break;
					case 7:
						if(v215) {
							bs215 |= 1;
						} else {
							bs215 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs215;
				var this217 = 0;
				var bs216 = this217;
				var l216 = " *   ".length;
				var _g1217 = 0;
				var _g317 = l216;
				while(_g1217 < _g317) {
					var i217 = _g1217++;
					var no216 = " *   ".charCodeAt(i217);
					if(no216 == null) {
						break;
					}
					var v216;
					switch(no216) {
					case 32:
						v216 = false;
						break;
					case 42:
						v216 = true;
						break;
					case 48:
						v216 = false;
						break;
					case 49:
						v216 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i217)));
					}
					switch(i217 - (l216 - 8)) {
					case 0:
						if(v216) {
							bs216 |= 128;
						} else {
							bs216 &= -129;
						}
						break;
					case 1:
						if(v216) {
							bs216 |= 64;
						} else {
							bs216 &= -65;
						}
						break;
					case 2:
						if(v216) {
							bs216 |= 32;
						} else {
							bs216 &= -33;
						}
						break;
					case 3:
						if(v216) {
							bs216 |= 16;
						} else {
							bs216 &= -17;
						}
						break;
					case 4:
						if(v216) {
							bs216 |= 8;
						} else {
							bs216 &= -9;
						}
						break;
					case 5:
						if(v216) {
							bs216 |= 4;
						} else {
							bs216 &= -5;
						}
						break;
					case 6:
						if(v216) {
							bs216 |= 2;
						} else {
							bs216 &= -3;
						}
						break;
					case 7:
						if(v216) {
							bs216 |= 1;
						} else {
							bs216 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs216;
				break;
			case 63:
				var this218 = 0;
				var bs217 = this218;
				var l217 = " *** ".length;
				var _g1218 = 0;
				var _g318 = l217;
				while(_g1218 < _g318) {
					var i218 = _g1218++;
					var no217 = " *** ".charCodeAt(i218);
					if(no217 == null) {
						break;
					}
					var v217;
					switch(no217) {
					case 32:
						v217 = false;
						break;
					case 42:
						v217 = true;
						break;
					case 48:
						v217 = false;
						break;
					case 49:
						v217 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i218)));
					}
					switch(i218 - (l217 - 8)) {
					case 0:
						if(v217) {
							bs217 |= 128;
						} else {
							bs217 &= -129;
						}
						break;
					case 1:
						if(v217) {
							bs217 |= 64;
						} else {
							bs217 &= -65;
						}
						break;
					case 2:
						if(v217) {
							bs217 |= 32;
						} else {
							bs217 &= -33;
						}
						break;
					case 3:
						if(v217) {
							bs217 |= 16;
						} else {
							bs217 &= -17;
						}
						break;
					case 4:
						if(v217) {
							bs217 |= 8;
						} else {
							bs217 &= -9;
						}
						break;
					case 5:
						if(v217) {
							bs217 |= 4;
						} else {
							bs217 &= -5;
						}
						break;
					case 6:
						if(v217) {
							bs217 |= 2;
						} else {
							bs217 &= -3;
						}
						break;
					case 7:
						if(v217) {
							bs217 |= 1;
						} else {
							bs217 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs217;
				var this219 = 0;
				var bs218 = this219;
				var l218 = "*   *".length;
				var _g1219 = 0;
				var _g319 = l218;
				while(_g1219 < _g319) {
					var i219 = _g1219++;
					var no218 = "*   *".charCodeAt(i219);
					if(no218 == null) {
						break;
					}
					var v218;
					switch(no218) {
					case 32:
						v218 = false;
						break;
					case 42:
						v218 = true;
						break;
					case 48:
						v218 = false;
						break;
					case 49:
						v218 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i219)));
					}
					switch(i219 - (l218 - 8)) {
					case 0:
						if(v218) {
							bs218 |= 128;
						} else {
							bs218 &= -129;
						}
						break;
					case 1:
						if(v218) {
							bs218 |= 64;
						} else {
							bs218 &= -65;
						}
						break;
					case 2:
						if(v218) {
							bs218 |= 32;
						} else {
							bs218 &= -33;
						}
						break;
					case 3:
						if(v218) {
							bs218 |= 16;
						} else {
							bs218 &= -17;
						}
						break;
					case 4:
						if(v218) {
							bs218 |= 8;
						} else {
							bs218 &= -9;
						}
						break;
					case 5:
						if(v218) {
							bs218 |= 4;
						} else {
							bs218 &= -5;
						}
						break;
					case 6:
						if(v218) {
							bs218 |= 2;
						} else {
							bs218 &= -3;
						}
						break;
					case 7:
						if(v218) {
							bs218 |= 1;
						} else {
							bs218 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs218;
				var this220 = 0;
				var bs219 = this220;
				var l219 = "    *".length;
				var _g1220 = 0;
				var _g320 = l219;
				while(_g1220 < _g320) {
					var i220 = _g1220++;
					var no219 = "    *".charCodeAt(i220);
					if(no219 == null) {
						break;
					}
					var v219;
					switch(no219) {
					case 32:
						v219 = false;
						break;
					case 42:
						v219 = true;
						break;
					case 48:
						v219 = false;
						break;
					case 49:
						v219 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i220)));
					}
					switch(i220 - (l219 - 8)) {
					case 0:
						if(v219) {
							bs219 |= 128;
						} else {
							bs219 &= -129;
						}
						break;
					case 1:
						if(v219) {
							bs219 |= 64;
						} else {
							bs219 &= -65;
						}
						break;
					case 2:
						if(v219) {
							bs219 |= 32;
						} else {
							bs219 &= -33;
						}
						break;
					case 3:
						if(v219) {
							bs219 |= 16;
						} else {
							bs219 &= -17;
						}
						break;
					case 4:
						if(v219) {
							bs219 |= 8;
						} else {
							bs219 &= -9;
						}
						break;
					case 5:
						if(v219) {
							bs219 |= 4;
						} else {
							bs219 &= -5;
						}
						break;
					case 6:
						if(v219) {
							bs219 |= 2;
						} else {
							bs219 &= -3;
						}
						break;
					case 7:
						if(v219) {
							bs219 |= 1;
						} else {
							bs219 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs219;
				var this221 = 0;
				var bs220 = this221;
				var l220 = "   * ".length;
				var _g1221 = 0;
				var _g321 = l220;
				while(_g1221 < _g321) {
					var i221 = _g1221++;
					var no220 = "   * ".charCodeAt(i221);
					if(no220 == null) {
						break;
					}
					var v220;
					switch(no220) {
					case 32:
						v220 = false;
						break;
					case 42:
						v220 = true;
						break;
					case 48:
						v220 = false;
						break;
					case 49:
						v220 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i221)));
					}
					switch(i221 - (l220 - 8)) {
					case 0:
						if(v220) {
							bs220 |= 128;
						} else {
							bs220 &= -129;
						}
						break;
					case 1:
						if(v220) {
							bs220 |= 64;
						} else {
							bs220 &= -65;
						}
						break;
					case 2:
						if(v220) {
							bs220 |= 32;
						} else {
							bs220 &= -33;
						}
						break;
					case 3:
						if(v220) {
							bs220 |= 16;
						} else {
							bs220 &= -17;
						}
						break;
					case 4:
						if(v220) {
							bs220 |= 8;
						} else {
							bs220 &= -9;
						}
						break;
					case 5:
						if(v220) {
							bs220 |= 4;
						} else {
							bs220 &= -5;
						}
						break;
					case 6:
						if(v220) {
							bs220 |= 2;
						} else {
							bs220 &= -3;
						}
						break;
					case 7:
						if(v220) {
							bs220 |= 1;
						} else {
							bs220 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs220;
				var this222 = 0;
				var bs221 = this222;
				var l221 = "  *  ".length;
				var _g1222 = 0;
				var _g322 = l221;
				while(_g1222 < _g322) {
					var i222 = _g1222++;
					var no221 = "  *  ".charCodeAt(i222);
					if(no221 == null) {
						break;
					}
					var v221;
					switch(no221) {
					case 32:
						v221 = false;
						break;
					case 42:
						v221 = true;
						break;
					case 48:
						v221 = false;
						break;
					case 49:
						v221 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i222)));
					}
					switch(i222 - (l221 - 8)) {
					case 0:
						if(v221) {
							bs221 |= 128;
						} else {
							bs221 &= -129;
						}
						break;
					case 1:
						if(v221) {
							bs221 |= 64;
						} else {
							bs221 &= -65;
						}
						break;
					case 2:
						if(v221) {
							bs221 |= 32;
						} else {
							bs221 &= -33;
						}
						break;
					case 3:
						if(v221) {
							bs221 |= 16;
						} else {
							bs221 &= -17;
						}
						break;
					case 4:
						if(v221) {
							bs221 |= 8;
						} else {
							bs221 &= -9;
						}
						break;
					case 5:
						if(v221) {
							bs221 |= 4;
						} else {
							bs221 &= -5;
						}
						break;
					case 6:
						if(v221) {
							bs221 |= 2;
						} else {
							bs221 &= -3;
						}
						break;
					case 7:
						if(v221) {
							bs221 |= 1;
						} else {
							bs221 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs221;
				var this223 = 0;
				var bs222 = this223;
				var l222 = "     ".length;
				var _g1223 = 0;
				var _g323 = l222;
				while(_g1223 < _g323) {
					var i223 = _g1223++;
					var no222 = "     ".charCodeAt(i223);
					if(no222 == null) {
						break;
					}
					var v222;
					switch(no222) {
					case 32:
						v222 = false;
						break;
					case 42:
						v222 = true;
						break;
					case 48:
						v222 = false;
						break;
					case 49:
						v222 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i223)));
					}
					switch(i223 - (l222 - 8)) {
					case 0:
						if(v222) {
							bs222 |= 128;
						} else {
							bs222 &= -129;
						}
						break;
					case 1:
						if(v222) {
							bs222 |= 64;
						} else {
							bs222 &= -65;
						}
						break;
					case 2:
						if(v222) {
							bs222 |= 32;
						} else {
							bs222 &= -33;
						}
						break;
					case 3:
						if(v222) {
							bs222 |= 16;
						} else {
							bs222 &= -17;
						}
						break;
					case 4:
						if(v222) {
							bs222 |= 8;
						} else {
							bs222 &= -9;
						}
						break;
					case 5:
						if(v222) {
							bs222 |= 4;
						} else {
							bs222 &= -5;
						}
						break;
					case 6:
						if(v222) {
							bs222 |= 2;
						} else {
							bs222 &= -3;
						}
						break;
					case 7:
						if(v222) {
							bs222 |= 1;
						} else {
							bs222 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs222;
				var this224 = 0;
				var bs223 = this224;
				var l223 = "  *  ".length;
				var _g1224 = 0;
				var _g324 = l223;
				while(_g1224 < _g324) {
					var i224 = _g1224++;
					var no223 = "  *  ".charCodeAt(i224);
					if(no223 == null) {
						break;
					}
					var v223;
					switch(no223) {
					case 32:
						v223 = false;
						break;
					case 42:
						v223 = true;
						break;
					case 48:
						v223 = false;
						break;
					case 49:
						v223 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i224)));
					}
					switch(i224 - (l223 - 8)) {
					case 0:
						if(v223) {
							bs223 |= 128;
						} else {
							bs223 &= -129;
						}
						break;
					case 1:
						if(v223) {
							bs223 |= 64;
						} else {
							bs223 &= -65;
						}
						break;
					case 2:
						if(v223) {
							bs223 |= 32;
						} else {
							bs223 &= -33;
						}
						break;
					case 3:
						if(v223) {
							bs223 |= 16;
						} else {
							bs223 &= -17;
						}
						break;
					case 4:
						if(v223) {
							bs223 |= 8;
						} else {
							bs223 &= -9;
						}
						break;
					case 5:
						if(v223) {
							bs223 |= 4;
						} else {
							bs223 &= -5;
						}
						break;
					case 6:
						if(v223) {
							bs223 |= 2;
						} else {
							bs223 &= -3;
						}
						break;
					case 7:
						if(v223) {
							bs223 |= 1;
						} else {
							bs223 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs223;
				break;
			case 64:
				var this225 = 0;
				var bs224 = this225;
				var l224 = " *** ".length;
				var _g1225 = 0;
				var _g325 = l224;
				while(_g1225 < _g325) {
					var i225 = _g1225++;
					var no224 = " *** ".charCodeAt(i225);
					if(no224 == null) {
						break;
					}
					var v224;
					switch(no224) {
					case 32:
						v224 = false;
						break;
					case 42:
						v224 = true;
						break;
					case 48:
						v224 = false;
						break;
					case 49:
						v224 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i225)));
					}
					switch(i225 - (l224 - 8)) {
					case 0:
						if(v224) {
							bs224 |= 128;
						} else {
							bs224 &= -129;
						}
						break;
					case 1:
						if(v224) {
							bs224 |= 64;
						} else {
							bs224 &= -65;
						}
						break;
					case 2:
						if(v224) {
							bs224 |= 32;
						} else {
							bs224 &= -33;
						}
						break;
					case 3:
						if(v224) {
							bs224 |= 16;
						} else {
							bs224 &= -17;
						}
						break;
					case 4:
						if(v224) {
							bs224 |= 8;
						} else {
							bs224 &= -9;
						}
						break;
					case 5:
						if(v224) {
							bs224 |= 4;
						} else {
							bs224 &= -5;
						}
						break;
					case 6:
						if(v224) {
							bs224 |= 2;
						} else {
							bs224 &= -3;
						}
						break;
					case 7:
						if(v224) {
							bs224 |= 1;
						} else {
							bs224 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs224;
				var this226 = 0;
				var bs225 = this226;
				var l225 = "*   *".length;
				var _g1226 = 0;
				var _g326 = l225;
				while(_g1226 < _g326) {
					var i226 = _g1226++;
					var no225 = "*   *".charCodeAt(i226);
					if(no225 == null) {
						break;
					}
					var v225;
					switch(no225) {
					case 32:
						v225 = false;
						break;
					case 42:
						v225 = true;
						break;
					case 48:
						v225 = false;
						break;
					case 49:
						v225 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i226)));
					}
					switch(i226 - (l225 - 8)) {
					case 0:
						if(v225) {
							bs225 |= 128;
						} else {
							bs225 &= -129;
						}
						break;
					case 1:
						if(v225) {
							bs225 |= 64;
						} else {
							bs225 &= -65;
						}
						break;
					case 2:
						if(v225) {
							bs225 |= 32;
						} else {
							bs225 &= -33;
						}
						break;
					case 3:
						if(v225) {
							bs225 |= 16;
						} else {
							bs225 &= -17;
						}
						break;
					case 4:
						if(v225) {
							bs225 |= 8;
						} else {
							bs225 &= -9;
						}
						break;
					case 5:
						if(v225) {
							bs225 |= 4;
						} else {
							bs225 &= -5;
						}
						break;
					case 6:
						if(v225) {
							bs225 |= 2;
						} else {
							bs225 &= -3;
						}
						break;
					case 7:
						if(v225) {
							bs225 |= 1;
						} else {
							bs225 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs225;
				var this227 = 0;
				var bs226 = this227;
				var l226 = "    *".length;
				var _g1227 = 0;
				var _g327 = l226;
				while(_g1227 < _g327) {
					var i227 = _g1227++;
					var no226 = "    *".charCodeAt(i227);
					if(no226 == null) {
						break;
					}
					var v226;
					switch(no226) {
					case 32:
						v226 = false;
						break;
					case 42:
						v226 = true;
						break;
					case 48:
						v226 = false;
						break;
					case 49:
						v226 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i227)));
					}
					switch(i227 - (l226 - 8)) {
					case 0:
						if(v226) {
							bs226 |= 128;
						} else {
							bs226 &= -129;
						}
						break;
					case 1:
						if(v226) {
							bs226 |= 64;
						} else {
							bs226 &= -65;
						}
						break;
					case 2:
						if(v226) {
							bs226 |= 32;
						} else {
							bs226 &= -33;
						}
						break;
					case 3:
						if(v226) {
							bs226 |= 16;
						} else {
							bs226 &= -17;
						}
						break;
					case 4:
						if(v226) {
							bs226 |= 8;
						} else {
							bs226 &= -9;
						}
						break;
					case 5:
						if(v226) {
							bs226 |= 4;
						} else {
							bs226 &= -5;
						}
						break;
					case 6:
						if(v226) {
							bs226 |= 2;
						} else {
							bs226 &= -3;
						}
						break;
					case 7:
						if(v226) {
							bs226 |= 1;
						} else {
							bs226 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs226;
				var this228 = 0;
				var bs227 = this228;
				var l227 = " ** *".length;
				var _g1228 = 0;
				var _g328 = l227;
				while(_g1228 < _g328) {
					var i228 = _g1228++;
					var no227 = " ** *".charCodeAt(i228);
					if(no227 == null) {
						break;
					}
					var v227;
					switch(no227) {
					case 32:
						v227 = false;
						break;
					case 42:
						v227 = true;
						break;
					case 48:
						v227 = false;
						break;
					case 49:
						v227 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i228)));
					}
					switch(i228 - (l227 - 8)) {
					case 0:
						if(v227) {
							bs227 |= 128;
						} else {
							bs227 &= -129;
						}
						break;
					case 1:
						if(v227) {
							bs227 |= 64;
						} else {
							bs227 &= -65;
						}
						break;
					case 2:
						if(v227) {
							bs227 |= 32;
						} else {
							bs227 &= -33;
						}
						break;
					case 3:
						if(v227) {
							bs227 |= 16;
						} else {
							bs227 &= -17;
						}
						break;
					case 4:
						if(v227) {
							bs227 |= 8;
						} else {
							bs227 &= -9;
						}
						break;
					case 5:
						if(v227) {
							bs227 |= 4;
						} else {
							bs227 &= -5;
						}
						break;
					case 6:
						if(v227) {
							bs227 |= 2;
						} else {
							bs227 &= -3;
						}
						break;
					case 7:
						if(v227) {
							bs227 |= 1;
						} else {
							bs227 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs227;
				var this229 = 0;
				var bs228 = this229;
				var l228 = "* * *".length;
				var _g1229 = 0;
				var _g329 = l228;
				while(_g1229 < _g329) {
					var i229 = _g1229++;
					var no228 = "* * *".charCodeAt(i229);
					if(no228 == null) {
						break;
					}
					var v228;
					switch(no228) {
					case 32:
						v228 = false;
						break;
					case 42:
						v228 = true;
						break;
					case 48:
						v228 = false;
						break;
					case 49:
						v228 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i229)));
					}
					switch(i229 - (l228 - 8)) {
					case 0:
						if(v228) {
							bs228 |= 128;
						} else {
							bs228 &= -129;
						}
						break;
					case 1:
						if(v228) {
							bs228 |= 64;
						} else {
							bs228 &= -65;
						}
						break;
					case 2:
						if(v228) {
							bs228 |= 32;
						} else {
							bs228 &= -33;
						}
						break;
					case 3:
						if(v228) {
							bs228 |= 16;
						} else {
							bs228 &= -17;
						}
						break;
					case 4:
						if(v228) {
							bs228 |= 8;
						} else {
							bs228 &= -9;
						}
						break;
					case 5:
						if(v228) {
							bs228 |= 4;
						} else {
							bs228 &= -5;
						}
						break;
					case 6:
						if(v228) {
							bs228 |= 2;
						} else {
							bs228 &= -3;
						}
						break;
					case 7:
						if(v228) {
							bs228 |= 1;
						} else {
							bs228 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs228;
				var this230 = 0;
				var bs229 = this230;
				var l229 = "* * *".length;
				var _g1230 = 0;
				var _g330 = l229;
				while(_g1230 < _g330) {
					var i230 = _g1230++;
					var no229 = "* * *".charCodeAt(i230);
					if(no229 == null) {
						break;
					}
					var v229;
					switch(no229) {
					case 32:
						v229 = false;
						break;
					case 42:
						v229 = true;
						break;
					case 48:
						v229 = false;
						break;
					case 49:
						v229 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i230)));
					}
					switch(i230 - (l229 - 8)) {
					case 0:
						if(v229) {
							bs229 |= 128;
						} else {
							bs229 &= -129;
						}
						break;
					case 1:
						if(v229) {
							bs229 |= 64;
						} else {
							bs229 &= -65;
						}
						break;
					case 2:
						if(v229) {
							bs229 |= 32;
						} else {
							bs229 &= -33;
						}
						break;
					case 3:
						if(v229) {
							bs229 |= 16;
						} else {
							bs229 &= -17;
						}
						break;
					case 4:
						if(v229) {
							bs229 |= 8;
						} else {
							bs229 &= -9;
						}
						break;
					case 5:
						if(v229) {
							bs229 |= 4;
						} else {
							bs229 &= -5;
						}
						break;
					case 6:
						if(v229) {
							bs229 |= 2;
						} else {
							bs229 &= -3;
						}
						break;
					case 7:
						if(v229) {
							bs229 |= 1;
						} else {
							bs229 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs229;
				var this231 = 0;
				var bs230 = this231;
				var l230 = " *** ".length;
				var _g1231 = 0;
				var _g331 = l230;
				while(_g1231 < _g331) {
					var i231 = _g1231++;
					var no230 = " *** ".charCodeAt(i231);
					if(no230 == null) {
						break;
					}
					var v230;
					switch(no230) {
					case 32:
						v230 = false;
						break;
					case 42:
						v230 = true;
						break;
					case 48:
						v230 = false;
						break;
					case 49:
						v230 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i231)));
					}
					switch(i231 - (l230 - 8)) {
					case 0:
						if(v230) {
							bs230 |= 128;
						} else {
							bs230 &= -129;
						}
						break;
					case 1:
						if(v230) {
							bs230 |= 64;
						} else {
							bs230 &= -65;
						}
						break;
					case 2:
						if(v230) {
							bs230 |= 32;
						} else {
							bs230 &= -33;
						}
						break;
					case 3:
						if(v230) {
							bs230 |= 16;
						} else {
							bs230 &= -17;
						}
						break;
					case 4:
						if(v230) {
							bs230 |= 8;
						} else {
							bs230 &= -9;
						}
						break;
					case 5:
						if(v230) {
							bs230 |= 4;
						} else {
							bs230 &= -5;
						}
						break;
					case 6:
						if(v230) {
							bs230 |= 2;
						} else {
							bs230 &= -3;
						}
						break;
					case 7:
						if(v230) {
							bs230 |= 1;
						} else {
							bs230 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs230;
				break;
			case 65:
				var this232 = 0;
				var bs231 = this232;
				var l231 = " *** ".length;
				var _g1232 = 0;
				var _g332 = l231;
				while(_g1232 < _g332) {
					var i232 = _g1232++;
					var no231 = " *** ".charCodeAt(i232);
					if(no231 == null) {
						break;
					}
					var v231;
					switch(no231) {
					case 32:
						v231 = false;
						break;
					case 42:
						v231 = true;
						break;
					case 48:
						v231 = false;
						break;
					case 49:
						v231 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i232)));
					}
					switch(i232 - (l231 - 8)) {
					case 0:
						if(v231) {
							bs231 |= 128;
						} else {
							bs231 &= -129;
						}
						break;
					case 1:
						if(v231) {
							bs231 |= 64;
						} else {
							bs231 &= -65;
						}
						break;
					case 2:
						if(v231) {
							bs231 |= 32;
						} else {
							bs231 &= -33;
						}
						break;
					case 3:
						if(v231) {
							bs231 |= 16;
						} else {
							bs231 &= -17;
						}
						break;
					case 4:
						if(v231) {
							bs231 |= 8;
						} else {
							bs231 &= -9;
						}
						break;
					case 5:
						if(v231) {
							bs231 |= 4;
						} else {
							bs231 &= -5;
						}
						break;
					case 6:
						if(v231) {
							bs231 |= 2;
						} else {
							bs231 &= -3;
						}
						break;
					case 7:
						if(v231) {
							bs231 |= 1;
						} else {
							bs231 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs231;
				var this233 = 0;
				var bs232 = this233;
				var l232 = "*   *".length;
				var _g1233 = 0;
				var _g333 = l232;
				while(_g1233 < _g333) {
					var i233 = _g1233++;
					var no232 = "*   *".charCodeAt(i233);
					if(no232 == null) {
						break;
					}
					var v232;
					switch(no232) {
					case 32:
						v232 = false;
						break;
					case 42:
						v232 = true;
						break;
					case 48:
						v232 = false;
						break;
					case 49:
						v232 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i233)));
					}
					switch(i233 - (l232 - 8)) {
					case 0:
						if(v232) {
							bs232 |= 128;
						} else {
							bs232 &= -129;
						}
						break;
					case 1:
						if(v232) {
							bs232 |= 64;
						} else {
							bs232 &= -65;
						}
						break;
					case 2:
						if(v232) {
							bs232 |= 32;
						} else {
							bs232 &= -33;
						}
						break;
					case 3:
						if(v232) {
							bs232 |= 16;
						} else {
							bs232 &= -17;
						}
						break;
					case 4:
						if(v232) {
							bs232 |= 8;
						} else {
							bs232 &= -9;
						}
						break;
					case 5:
						if(v232) {
							bs232 |= 4;
						} else {
							bs232 &= -5;
						}
						break;
					case 6:
						if(v232) {
							bs232 |= 2;
						} else {
							bs232 &= -3;
						}
						break;
					case 7:
						if(v232) {
							bs232 |= 1;
						} else {
							bs232 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs232;
				var this234 = 0;
				var bs233 = this234;
				var l233 = "*   *".length;
				var _g1234 = 0;
				var _g334 = l233;
				while(_g1234 < _g334) {
					var i234 = _g1234++;
					var no233 = "*   *".charCodeAt(i234);
					if(no233 == null) {
						break;
					}
					var v233;
					switch(no233) {
					case 32:
						v233 = false;
						break;
					case 42:
						v233 = true;
						break;
					case 48:
						v233 = false;
						break;
					case 49:
						v233 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i234)));
					}
					switch(i234 - (l233 - 8)) {
					case 0:
						if(v233) {
							bs233 |= 128;
						} else {
							bs233 &= -129;
						}
						break;
					case 1:
						if(v233) {
							bs233 |= 64;
						} else {
							bs233 &= -65;
						}
						break;
					case 2:
						if(v233) {
							bs233 |= 32;
						} else {
							bs233 &= -33;
						}
						break;
					case 3:
						if(v233) {
							bs233 |= 16;
						} else {
							bs233 &= -17;
						}
						break;
					case 4:
						if(v233) {
							bs233 |= 8;
						} else {
							bs233 &= -9;
						}
						break;
					case 5:
						if(v233) {
							bs233 |= 4;
						} else {
							bs233 &= -5;
						}
						break;
					case 6:
						if(v233) {
							bs233 |= 2;
						} else {
							bs233 &= -3;
						}
						break;
					case 7:
						if(v233) {
							bs233 |= 1;
						} else {
							bs233 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs233;
				var this235 = 0;
				var bs234 = this235;
				var l234 = "*   *".length;
				var _g1235 = 0;
				var _g335 = l234;
				while(_g1235 < _g335) {
					var i235 = _g1235++;
					var no234 = "*   *".charCodeAt(i235);
					if(no234 == null) {
						break;
					}
					var v234;
					switch(no234) {
					case 32:
						v234 = false;
						break;
					case 42:
						v234 = true;
						break;
					case 48:
						v234 = false;
						break;
					case 49:
						v234 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i235)));
					}
					switch(i235 - (l234 - 8)) {
					case 0:
						if(v234) {
							bs234 |= 128;
						} else {
							bs234 &= -129;
						}
						break;
					case 1:
						if(v234) {
							bs234 |= 64;
						} else {
							bs234 &= -65;
						}
						break;
					case 2:
						if(v234) {
							bs234 |= 32;
						} else {
							bs234 &= -33;
						}
						break;
					case 3:
						if(v234) {
							bs234 |= 16;
						} else {
							bs234 &= -17;
						}
						break;
					case 4:
						if(v234) {
							bs234 |= 8;
						} else {
							bs234 &= -9;
						}
						break;
					case 5:
						if(v234) {
							bs234 |= 4;
						} else {
							bs234 &= -5;
						}
						break;
					case 6:
						if(v234) {
							bs234 |= 2;
						} else {
							bs234 &= -3;
						}
						break;
					case 7:
						if(v234) {
							bs234 |= 1;
						} else {
							bs234 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs234;
				var this236 = 0;
				var bs235 = this236;
				var l235 = "*****".length;
				var _g1236 = 0;
				var _g336 = l235;
				while(_g1236 < _g336) {
					var i236 = _g1236++;
					var no235 = "*****".charCodeAt(i236);
					if(no235 == null) {
						break;
					}
					var v235;
					switch(no235) {
					case 32:
						v235 = false;
						break;
					case 42:
						v235 = true;
						break;
					case 48:
						v235 = false;
						break;
					case 49:
						v235 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i236)));
					}
					switch(i236 - (l235 - 8)) {
					case 0:
						if(v235) {
							bs235 |= 128;
						} else {
							bs235 &= -129;
						}
						break;
					case 1:
						if(v235) {
							bs235 |= 64;
						} else {
							bs235 &= -65;
						}
						break;
					case 2:
						if(v235) {
							bs235 |= 32;
						} else {
							bs235 &= -33;
						}
						break;
					case 3:
						if(v235) {
							bs235 |= 16;
						} else {
							bs235 &= -17;
						}
						break;
					case 4:
						if(v235) {
							bs235 |= 8;
						} else {
							bs235 &= -9;
						}
						break;
					case 5:
						if(v235) {
							bs235 |= 4;
						} else {
							bs235 &= -5;
						}
						break;
					case 6:
						if(v235) {
							bs235 |= 2;
						} else {
							bs235 &= -3;
						}
						break;
					case 7:
						if(v235) {
							bs235 |= 1;
						} else {
							bs235 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs235;
				var this237 = 0;
				var bs236 = this237;
				var l236 = "*   *".length;
				var _g1237 = 0;
				var _g337 = l236;
				while(_g1237 < _g337) {
					var i237 = _g1237++;
					var no236 = "*   *".charCodeAt(i237);
					if(no236 == null) {
						break;
					}
					var v236;
					switch(no236) {
					case 32:
						v236 = false;
						break;
					case 42:
						v236 = true;
						break;
					case 48:
						v236 = false;
						break;
					case 49:
						v236 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i237)));
					}
					switch(i237 - (l236 - 8)) {
					case 0:
						if(v236) {
							bs236 |= 128;
						} else {
							bs236 &= -129;
						}
						break;
					case 1:
						if(v236) {
							bs236 |= 64;
						} else {
							bs236 &= -65;
						}
						break;
					case 2:
						if(v236) {
							bs236 |= 32;
						} else {
							bs236 &= -33;
						}
						break;
					case 3:
						if(v236) {
							bs236 |= 16;
						} else {
							bs236 &= -17;
						}
						break;
					case 4:
						if(v236) {
							bs236 |= 8;
						} else {
							bs236 &= -9;
						}
						break;
					case 5:
						if(v236) {
							bs236 |= 4;
						} else {
							bs236 &= -5;
						}
						break;
					case 6:
						if(v236) {
							bs236 |= 2;
						} else {
							bs236 &= -3;
						}
						break;
					case 7:
						if(v236) {
							bs236 |= 1;
						} else {
							bs236 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs236;
				var this238 = 0;
				var bs237 = this238;
				var l237 = "*   *".length;
				var _g1238 = 0;
				var _g338 = l237;
				while(_g1238 < _g338) {
					var i238 = _g1238++;
					var no237 = "*   *".charCodeAt(i238);
					if(no237 == null) {
						break;
					}
					var v237;
					switch(no237) {
					case 32:
						v237 = false;
						break;
					case 42:
						v237 = true;
						break;
					case 48:
						v237 = false;
						break;
					case 49:
						v237 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i238)));
					}
					switch(i238 - (l237 - 8)) {
					case 0:
						if(v237) {
							bs237 |= 128;
						} else {
							bs237 &= -129;
						}
						break;
					case 1:
						if(v237) {
							bs237 |= 64;
						} else {
							bs237 &= -65;
						}
						break;
					case 2:
						if(v237) {
							bs237 |= 32;
						} else {
							bs237 &= -33;
						}
						break;
					case 3:
						if(v237) {
							bs237 |= 16;
						} else {
							bs237 &= -17;
						}
						break;
					case 4:
						if(v237) {
							bs237 |= 8;
						} else {
							bs237 &= -9;
						}
						break;
					case 5:
						if(v237) {
							bs237 |= 4;
						} else {
							bs237 &= -5;
						}
						break;
					case 6:
						if(v237) {
							bs237 |= 2;
						} else {
							bs237 &= -3;
						}
						break;
					case 7:
						if(v237) {
							bs237 |= 1;
						} else {
							bs237 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs237;
				break;
			case 66:
				var this239 = 0;
				var bs238 = this239;
				var l238 = "**** ".length;
				var _g1239 = 0;
				var _g339 = l238;
				while(_g1239 < _g339) {
					var i239 = _g1239++;
					var no238 = "**** ".charCodeAt(i239);
					if(no238 == null) {
						break;
					}
					var v238;
					switch(no238) {
					case 32:
						v238 = false;
						break;
					case 42:
						v238 = true;
						break;
					case 48:
						v238 = false;
						break;
					case 49:
						v238 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i239)));
					}
					switch(i239 - (l238 - 8)) {
					case 0:
						if(v238) {
							bs238 |= 128;
						} else {
							bs238 &= -129;
						}
						break;
					case 1:
						if(v238) {
							bs238 |= 64;
						} else {
							bs238 &= -65;
						}
						break;
					case 2:
						if(v238) {
							bs238 |= 32;
						} else {
							bs238 &= -33;
						}
						break;
					case 3:
						if(v238) {
							bs238 |= 16;
						} else {
							bs238 &= -17;
						}
						break;
					case 4:
						if(v238) {
							bs238 |= 8;
						} else {
							bs238 &= -9;
						}
						break;
					case 5:
						if(v238) {
							bs238 |= 4;
						} else {
							bs238 &= -5;
						}
						break;
					case 6:
						if(v238) {
							bs238 |= 2;
						} else {
							bs238 &= -3;
						}
						break;
					case 7:
						if(v238) {
							bs238 |= 1;
						} else {
							bs238 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs238;
				var this240 = 0;
				var bs239 = this240;
				var l239 = "*   *".length;
				var _g1240 = 0;
				var _g340 = l239;
				while(_g1240 < _g340) {
					var i240 = _g1240++;
					var no239 = "*   *".charCodeAt(i240);
					if(no239 == null) {
						break;
					}
					var v239;
					switch(no239) {
					case 32:
						v239 = false;
						break;
					case 42:
						v239 = true;
						break;
					case 48:
						v239 = false;
						break;
					case 49:
						v239 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i240)));
					}
					switch(i240 - (l239 - 8)) {
					case 0:
						if(v239) {
							bs239 |= 128;
						} else {
							bs239 &= -129;
						}
						break;
					case 1:
						if(v239) {
							bs239 |= 64;
						} else {
							bs239 &= -65;
						}
						break;
					case 2:
						if(v239) {
							bs239 |= 32;
						} else {
							bs239 &= -33;
						}
						break;
					case 3:
						if(v239) {
							bs239 |= 16;
						} else {
							bs239 &= -17;
						}
						break;
					case 4:
						if(v239) {
							bs239 |= 8;
						} else {
							bs239 &= -9;
						}
						break;
					case 5:
						if(v239) {
							bs239 |= 4;
						} else {
							bs239 &= -5;
						}
						break;
					case 6:
						if(v239) {
							bs239 |= 2;
						} else {
							bs239 &= -3;
						}
						break;
					case 7:
						if(v239) {
							bs239 |= 1;
						} else {
							bs239 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs239;
				var this241 = 0;
				var bs240 = this241;
				var l240 = "*   *".length;
				var _g1241 = 0;
				var _g341 = l240;
				while(_g1241 < _g341) {
					var i241 = _g1241++;
					var no240 = "*   *".charCodeAt(i241);
					if(no240 == null) {
						break;
					}
					var v240;
					switch(no240) {
					case 32:
						v240 = false;
						break;
					case 42:
						v240 = true;
						break;
					case 48:
						v240 = false;
						break;
					case 49:
						v240 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i241)));
					}
					switch(i241 - (l240 - 8)) {
					case 0:
						if(v240) {
							bs240 |= 128;
						} else {
							bs240 &= -129;
						}
						break;
					case 1:
						if(v240) {
							bs240 |= 64;
						} else {
							bs240 &= -65;
						}
						break;
					case 2:
						if(v240) {
							bs240 |= 32;
						} else {
							bs240 &= -33;
						}
						break;
					case 3:
						if(v240) {
							bs240 |= 16;
						} else {
							bs240 &= -17;
						}
						break;
					case 4:
						if(v240) {
							bs240 |= 8;
						} else {
							bs240 &= -9;
						}
						break;
					case 5:
						if(v240) {
							bs240 |= 4;
						} else {
							bs240 &= -5;
						}
						break;
					case 6:
						if(v240) {
							bs240 |= 2;
						} else {
							bs240 &= -3;
						}
						break;
					case 7:
						if(v240) {
							bs240 |= 1;
						} else {
							bs240 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs240;
				var this242 = 0;
				var bs241 = this242;
				var l241 = "**** ".length;
				var _g1242 = 0;
				var _g342 = l241;
				while(_g1242 < _g342) {
					var i242 = _g1242++;
					var no241 = "**** ".charCodeAt(i242);
					if(no241 == null) {
						break;
					}
					var v241;
					switch(no241) {
					case 32:
						v241 = false;
						break;
					case 42:
						v241 = true;
						break;
					case 48:
						v241 = false;
						break;
					case 49:
						v241 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i242)));
					}
					switch(i242 - (l241 - 8)) {
					case 0:
						if(v241) {
							bs241 |= 128;
						} else {
							bs241 &= -129;
						}
						break;
					case 1:
						if(v241) {
							bs241 |= 64;
						} else {
							bs241 &= -65;
						}
						break;
					case 2:
						if(v241) {
							bs241 |= 32;
						} else {
							bs241 &= -33;
						}
						break;
					case 3:
						if(v241) {
							bs241 |= 16;
						} else {
							bs241 &= -17;
						}
						break;
					case 4:
						if(v241) {
							bs241 |= 8;
						} else {
							bs241 &= -9;
						}
						break;
					case 5:
						if(v241) {
							bs241 |= 4;
						} else {
							bs241 &= -5;
						}
						break;
					case 6:
						if(v241) {
							bs241 |= 2;
						} else {
							bs241 &= -3;
						}
						break;
					case 7:
						if(v241) {
							bs241 |= 1;
						} else {
							bs241 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs241;
				var this243 = 0;
				var bs242 = this243;
				var l242 = "*   *".length;
				var _g1243 = 0;
				var _g343 = l242;
				while(_g1243 < _g343) {
					var i243 = _g1243++;
					var no242 = "*   *".charCodeAt(i243);
					if(no242 == null) {
						break;
					}
					var v242;
					switch(no242) {
					case 32:
						v242 = false;
						break;
					case 42:
						v242 = true;
						break;
					case 48:
						v242 = false;
						break;
					case 49:
						v242 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i243)));
					}
					switch(i243 - (l242 - 8)) {
					case 0:
						if(v242) {
							bs242 |= 128;
						} else {
							bs242 &= -129;
						}
						break;
					case 1:
						if(v242) {
							bs242 |= 64;
						} else {
							bs242 &= -65;
						}
						break;
					case 2:
						if(v242) {
							bs242 |= 32;
						} else {
							bs242 &= -33;
						}
						break;
					case 3:
						if(v242) {
							bs242 |= 16;
						} else {
							bs242 &= -17;
						}
						break;
					case 4:
						if(v242) {
							bs242 |= 8;
						} else {
							bs242 &= -9;
						}
						break;
					case 5:
						if(v242) {
							bs242 |= 4;
						} else {
							bs242 &= -5;
						}
						break;
					case 6:
						if(v242) {
							bs242 |= 2;
						} else {
							bs242 &= -3;
						}
						break;
					case 7:
						if(v242) {
							bs242 |= 1;
						} else {
							bs242 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs242;
				var this244 = 0;
				var bs243 = this244;
				var l243 = "*   *".length;
				var _g1244 = 0;
				var _g344 = l243;
				while(_g1244 < _g344) {
					var i244 = _g1244++;
					var no243 = "*   *".charCodeAt(i244);
					if(no243 == null) {
						break;
					}
					var v243;
					switch(no243) {
					case 32:
						v243 = false;
						break;
					case 42:
						v243 = true;
						break;
					case 48:
						v243 = false;
						break;
					case 49:
						v243 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i244)));
					}
					switch(i244 - (l243 - 8)) {
					case 0:
						if(v243) {
							bs243 |= 128;
						} else {
							bs243 &= -129;
						}
						break;
					case 1:
						if(v243) {
							bs243 |= 64;
						} else {
							bs243 &= -65;
						}
						break;
					case 2:
						if(v243) {
							bs243 |= 32;
						} else {
							bs243 &= -33;
						}
						break;
					case 3:
						if(v243) {
							bs243 |= 16;
						} else {
							bs243 &= -17;
						}
						break;
					case 4:
						if(v243) {
							bs243 |= 8;
						} else {
							bs243 &= -9;
						}
						break;
					case 5:
						if(v243) {
							bs243 |= 4;
						} else {
							bs243 &= -5;
						}
						break;
					case 6:
						if(v243) {
							bs243 |= 2;
						} else {
							bs243 &= -3;
						}
						break;
					case 7:
						if(v243) {
							bs243 |= 1;
						} else {
							bs243 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs243;
				var this245 = 0;
				var bs244 = this245;
				var l244 = "**** ".length;
				var _g1245 = 0;
				var _g345 = l244;
				while(_g1245 < _g345) {
					var i245 = _g1245++;
					var no244 = "**** ".charCodeAt(i245);
					if(no244 == null) {
						break;
					}
					var v244;
					switch(no244) {
					case 32:
						v244 = false;
						break;
					case 42:
						v244 = true;
						break;
					case 48:
						v244 = false;
						break;
					case 49:
						v244 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i245)));
					}
					switch(i245 - (l244 - 8)) {
					case 0:
						if(v244) {
							bs244 |= 128;
						} else {
							bs244 &= -129;
						}
						break;
					case 1:
						if(v244) {
							bs244 |= 64;
						} else {
							bs244 &= -65;
						}
						break;
					case 2:
						if(v244) {
							bs244 |= 32;
						} else {
							bs244 &= -33;
						}
						break;
					case 3:
						if(v244) {
							bs244 |= 16;
						} else {
							bs244 &= -17;
						}
						break;
					case 4:
						if(v244) {
							bs244 |= 8;
						} else {
							bs244 &= -9;
						}
						break;
					case 5:
						if(v244) {
							bs244 |= 4;
						} else {
							bs244 &= -5;
						}
						break;
					case 6:
						if(v244) {
							bs244 |= 2;
						} else {
							bs244 &= -3;
						}
						break;
					case 7:
						if(v244) {
							bs244 |= 1;
						} else {
							bs244 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs244;
				break;
			case 67:
				var this246 = 0;
				var bs245 = this246;
				var l245 = " *** ".length;
				var _g1246 = 0;
				var _g346 = l245;
				while(_g1246 < _g346) {
					var i246 = _g1246++;
					var no245 = " *** ".charCodeAt(i246);
					if(no245 == null) {
						break;
					}
					var v245;
					switch(no245) {
					case 32:
						v245 = false;
						break;
					case 42:
						v245 = true;
						break;
					case 48:
						v245 = false;
						break;
					case 49:
						v245 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i246)));
					}
					switch(i246 - (l245 - 8)) {
					case 0:
						if(v245) {
							bs245 |= 128;
						} else {
							bs245 &= -129;
						}
						break;
					case 1:
						if(v245) {
							bs245 |= 64;
						} else {
							bs245 &= -65;
						}
						break;
					case 2:
						if(v245) {
							bs245 |= 32;
						} else {
							bs245 &= -33;
						}
						break;
					case 3:
						if(v245) {
							bs245 |= 16;
						} else {
							bs245 &= -17;
						}
						break;
					case 4:
						if(v245) {
							bs245 |= 8;
						} else {
							bs245 &= -9;
						}
						break;
					case 5:
						if(v245) {
							bs245 |= 4;
						} else {
							bs245 &= -5;
						}
						break;
					case 6:
						if(v245) {
							bs245 |= 2;
						} else {
							bs245 &= -3;
						}
						break;
					case 7:
						if(v245) {
							bs245 |= 1;
						} else {
							bs245 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs245;
				var this247 = 0;
				var bs246 = this247;
				var l246 = "*   *".length;
				var _g1247 = 0;
				var _g347 = l246;
				while(_g1247 < _g347) {
					var i247 = _g1247++;
					var no246 = "*   *".charCodeAt(i247);
					if(no246 == null) {
						break;
					}
					var v246;
					switch(no246) {
					case 32:
						v246 = false;
						break;
					case 42:
						v246 = true;
						break;
					case 48:
						v246 = false;
						break;
					case 49:
						v246 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i247)));
					}
					switch(i247 - (l246 - 8)) {
					case 0:
						if(v246) {
							bs246 |= 128;
						} else {
							bs246 &= -129;
						}
						break;
					case 1:
						if(v246) {
							bs246 |= 64;
						} else {
							bs246 &= -65;
						}
						break;
					case 2:
						if(v246) {
							bs246 |= 32;
						} else {
							bs246 &= -33;
						}
						break;
					case 3:
						if(v246) {
							bs246 |= 16;
						} else {
							bs246 &= -17;
						}
						break;
					case 4:
						if(v246) {
							bs246 |= 8;
						} else {
							bs246 &= -9;
						}
						break;
					case 5:
						if(v246) {
							bs246 |= 4;
						} else {
							bs246 &= -5;
						}
						break;
					case 6:
						if(v246) {
							bs246 |= 2;
						} else {
							bs246 &= -3;
						}
						break;
					case 7:
						if(v246) {
							bs246 |= 1;
						} else {
							bs246 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs246;
				var this248 = 0;
				var bs247 = this248;
				var l247 = "*    ".length;
				var _g1248 = 0;
				var _g348 = l247;
				while(_g1248 < _g348) {
					var i248 = _g1248++;
					var no247 = "*    ".charCodeAt(i248);
					if(no247 == null) {
						break;
					}
					var v247;
					switch(no247) {
					case 32:
						v247 = false;
						break;
					case 42:
						v247 = true;
						break;
					case 48:
						v247 = false;
						break;
					case 49:
						v247 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i248)));
					}
					switch(i248 - (l247 - 8)) {
					case 0:
						if(v247) {
							bs247 |= 128;
						} else {
							bs247 &= -129;
						}
						break;
					case 1:
						if(v247) {
							bs247 |= 64;
						} else {
							bs247 &= -65;
						}
						break;
					case 2:
						if(v247) {
							bs247 |= 32;
						} else {
							bs247 &= -33;
						}
						break;
					case 3:
						if(v247) {
							bs247 |= 16;
						} else {
							bs247 &= -17;
						}
						break;
					case 4:
						if(v247) {
							bs247 |= 8;
						} else {
							bs247 &= -9;
						}
						break;
					case 5:
						if(v247) {
							bs247 |= 4;
						} else {
							bs247 &= -5;
						}
						break;
					case 6:
						if(v247) {
							bs247 |= 2;
						} else {
							bs247 &= -3;
						}
						break;
					case 7:
						if(v247) {
							bs247 |= 1;
						} else {
							bs247 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs247;
				var this249 = 0;
				var bs248 = this249;
				var l248 = "*    ".length;
				var _g1249 = 0;
				var _g349 = l248;
				while(_g1249 < _g349) {
					var i249 = _g1249++;
					var no248 = "*    ".charCodeAt(i249);
					if(no248 == null) {
						break;
					}
					var v248;
					switch(no248) {
					case 32:
						v248 = false;
						break;
					case 42:
						v248 = true;
						break;
					case 48:
						v248 = false;
						break;
					case 49:
						v248 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i249)));
					}
					switch(i249 - (l248 - 8)) {
					case 0:
						if(v248) {
							bs248 |= 128;
						} else {
							bs248 &= -129;
						}
						break;
					case 1:
						if(v248) {
							bs248 |= 64;
						} else {
							bs248 &= -65;
						}
						break;
					case 2:
						if(v248) {
							bs248 |= 32;
						} else {
							bs248 &= -33;
						}
						break;
					case 3:
						if(v248) {
							bs248 |= 16;
						} else {
							bs248 &= -17;
						}
						break;
					case 4:
						if(v248) {
							bs248 |= 8;
						} else {
							bs248 &= -9;
						}
						break;
					case 5:
						if(v248) {
							bs248 |= 4;
						} else {
							bs248 &= -5;
						}
						break;
					case 6:
						if(v248) {
							bs248 |= 2;
						} else {
							bs248 &= -3;
						}
						break;
					case 7:
						if(v248) {
							bs248 |= 1;
						} else {
							bs248 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs248;
				var this250 = 0;
				var bs249 = this250;
				var l249 = "*    ".length;
				var _g1250 = 0;
				var _g350 = l249;
				while(_g1250 < _g350) {
					var i250 = _g1250++;
					var no249 = "*    ".charCodeAt(i250);
					if(no249 == null) {
						break;
					}
					var v249;
					switch(no249) {
					case 32:
						v249 = false;
						break;
					case 42:
						v249 = true;
						break;
					case 48:
						v249 = false;
						break;
					case 49:
						v249 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i250)));
					}
					switch(i250 - (l249 - 8)) {
					case 0:
						if(v249) {
							bs249 |= 128;
						} else {
							bs249 &= -129;
						}
						break;
					case 1:
						if(v249) {
							bs249 |= 64;
						} else {
							bs249 &= -65;
						}
						break;
					case 2:
						if(v249) {
							bs249 |= 32;
						} else {
							bs249 &= -33;
						}
						break;
					case 3:
						if(v249) {
							bs249 |= 16;
						} else {
							bs249 &= -17;
						}
						break;
					case 4:
						if(v249) {
							bs249 |= 8;
						} else {
							bs249 &= -9;
						}
						break;
					case 5:
						if(v249) {
							bs249 |= 4;
						} else {
							bs249 &= -5;
						}
						break;
					case 6:
						if(v249) {
							bs249 |= 2;
						} else {
							bs249 &= -3;
						}
						break;
					case 7:
						if(v249) {
							bs249 |= 1;
						} else {
							bs249 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs249;
				var this251 = 0;
				var bs250 = this251;
				var l250 = "*   *".length;
				var _g1251 = 0;
				var _g351 = l250;
				while(_g1251 < _g351) {
					var i251 = _g1251++;
					var no250 = "*   *".charCodeAt(i251);
					if(no250 == null) {
						break;
					}
					var v250;
					switch(no250) {
					case 32:
						v250 = false;
						break;
					case 42:
						v250 = true;
						break;
					case 48:
						v250 = false;
						break;
					case 49:
						v250 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i251)));
					}
					switch(i251 - (l250 - 8)) {
					case 0:
						if(v250) {
							bs250 |= 128;
						} else {
							bs250 &= -129;
						}
						break;
					case 1:
						if(v250) {
							bs250 |= 64;
						} else {
							bs250 &= -65;
						}
						break;
					case 2:
						if(v250) {
							bs250 |= 32;
						} else {
							bs250 &= -33;
						}
						break;
					case 3:
						if(v250) {
							bs250 |= 16;
						} else {
							bs250 &= -17;
						}
						break;
					case 4:
						if(v250) {
							bs250 |= 8;
						} else {
							bs250 &= -9;
						}
						break;
					case 5:
						if(v250) {
							bs250 |= 4;
						} else {
							bs250 &= -5;
						}
						break;
					case 6:
						if(v250) {
							bs250 |= 2;
						} else {
							bs250 &= -3;
						}
						break;
					case 7:
						if(v250) {
							bs250 |= 1;
						} else {
							bs250 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs250;
				var this252 = 0;
				var bs251 = this252;
				var l251 = " *** ".length;
				var _g1252 = 0;
				var _g352 = l251;
				while(_g1252 < _g352) {
					var i252 = _g1252++;
					var no251 = " *** ".charCodeAt(i252);
					if(no251 == null) {
						break;
					}
					var v251;
					switch(no251) {
					case 32:
						v251 = false;
						break;
					case 42:
						v251 = true;
						break;
					case 48:
						v251 = false;
						break;
					case 49:
						v251 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i252)));
					}
					switch(i252 - (l251 - 8)) {
					case 0:
						if(v251) {
							bs251 |= 128;
						} else {
							bs251 &= -129;
						}
						break;
					case 1:
						if(v251) {
							bs251 |= 64;
						} else {
							bs251 &= -65;
						}
						break;
					case 2:
						if(v251) {
							bs251 |= 32;
						} else {
							bs251 &= -33;
						}
						break;
					case 3:
						if(v251) {
							bs251 |= 16;
						} else {
							bs251 &= -17;
						}
						break;
					case 4:
						if(v251) {
							bs251 |= 8;
						} else {
							bs251 &= -9;
						}
						break;
					case 5:
						if(v251) {
							bs251 |= 4;
						} else {
							bs251 &= -5;
						}
						break;
					case 6:
						if(v251) {
							bs251 |= 2;
						} else {
							bs251 &= -3;
						}
						break;
					case 7:
						if(v251) {
							bs251 |= 1;
						} else {
							bs251 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs251;
				break;
			case 68:
				var this253 = 0;
				var bs252 = this253;
				var l252 = "***  ".length;
				var _g1253 = 0;
				var _g353 = l252;
				while(_g1253 < _g353) {
					var i253 = _g1253++;
					var no252 = "***  ".charCodeAt(i253);
					if(no252 == null) {
						break;
					}
					var v252;
					switch(no252) {
					case 32:
						v252 = false;
						break;
					case 42:
						v252 = true;
						break;
					case 48:
						v252 = false;
						break;
					case 49:
						v252 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("***  ".charCodeAt(i253)));
					}
					switch(i253 - (l252 - 8)) {
					case 0:
						if(v252) {
							bs252 |= 128;
						} else {
							bs252 &= -129;
						}
						break;
					case 1:
						if(v252) {
							bs252 |= 64;
						} else {
							bs252 &= -65;
						}
						break;
					case 2:
						if(v252) {
							bs252 |= 32;
						} else {
							bs252 &= -33;
						}
						break;
					case 3:
						if(v252) {
							bs252 |= 16;
						} else {
							bs252 &= -17;
						}
						break;
					case 4:
						if(v252) {
							bs252 |= 8;
						} else {
							bs252 &= -9;
						}
						break;
					case 5:
						if(v252) {
							bs252 |= 4;
						} else {
							bs252 &= -5;
						}
						break;
					case 6:
						if(v252) {
							bs252 |= 2;
						} else {
							bs252 &= -3;
						}
						break;
					case 7:
						if(v252) {
							bs252 |= 1;
						} else {
							bs252 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs252;
				var this254 = 0;
				var bs253 = this254;
				var l253 = "*  * ".length;
				var _g1254 = 0;
				var _g354 = l253;
				while(_g1254 < _g354) {
					var i254 = _g1254++;
					var no253 = "*  * ".charCodeAt(i254);
					if(no253 == null) {
						break;
					}
					var v253;
					switch(no253) {
					case 32:
						v253 = false;
						break;
					case 42:
						v253 = true;
						break;
					case 48:
						v253 = false;
						break;
					case 49:
						v253 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i254)));
					}
					switch(i254 - (l253 - 8)) {
					case 0:
						if(v253) {
							bs253 |= 128;
						} else {
							bs253 &= -129;
						}
						break;
					case 1:
						if(v253) {
							bs253 |= 64;
						} else {
							bs253 &= -65;
						}
						break;
					case 2:
						if(v253) {
							bs253 |= 32;
						} else {
							bs253 &= -33;
						}
						break;
					case 3:
						if(v253) {
							bs253 |= 16;
						} else {
							bs253 &= -17;
						}
						break;
					case 4:
						if(v253) {
							bs253 |= 8;
						} else {
							bs253 &= -9;
						}
						break;
					case 5:
						if(v253) {
							bs253 |= 4;
						} else {
							bs253 &= -5;
						}
						break;
					case 6:
						if(v253) {
							bs253 |= 2;
						} else {
							bs253 &= -3;
						}
						break;
					case 7:
						if(v253) {
							bs253 |= 1;
						} else {
							bs253 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs253;
				var this255 = 0;
				var bs254 = this255;
				var l254 = "*   *".length;
				var _g1255 = 0;
				var _g355 = l254;
				while(_g1255 < _g355) {
					var i255 = _g1255++;
					var no254 = "*   *".charCodeAt(i255);
					if(no254 == null) {
						break;
					}
					var v254;
					switch(no254) {
					case 32:
						v254 = false;
						break;
					case 42:
						v254 = true;
						break;
					case 48:
						v254 = false;
						break;
					case 49:
						v254 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i255)));
					}
					switch(i255 - (l254 - 8)) {
					case 0:
						if(v254) {
							bs254 |= 128;
						} else {
							bs254 &= -129;
						}
						break;
					case 1:
						if(v254) {
							bs254 |= 64;
						} else {
							bs254 &= -65;
						}
						break;
					case 2:
						if(v254) {
							bs254 |= 32;
						} else {
							bs254 &= -33;
						}
						break;
					case 3:
						if(v254) {
							bs254 |= 16;
						} else {
							bs254 &= -17;
						}
						break;
					case 4:
						if(v254) {
							bs254 |= 8;
						} else {
							bs254 &= -9;
						}
						break;
					case 5:
						if(v254) {
							bs254 |= 4;
						} else {
							bs254 &= -5;
						}
						break;
					case 6:
						if(v254) {
							bs254 |= 2;
						} else {
							bs254 &= -3;
						}
						break;
					case 7:
						if(v254) {
							bs254 |= 1;
						} else {
							bs254 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs254;
				var this256 = 0;
				var bs255 = this256;
				var l255 = "*   *".length;
				var _g1256 = 0;
				var _g356 = l255;
				while(_g1256 < _g356) {
					var i256 = _g1256++;
					var no255 = "*   *".charCodeAt(i256);
					if(no255 == null) {
						break;
					}
					var v255;
					switch(no255) {
					case 32:
						v255 = false;
						break;
					case 42:
						v255 = true;
						break;
					case 48:
						v255 = false;
						break;
					case 49:
						v255 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i256)));
					}
					switch(i256 - (l255 - 8)) {
					case 0:
						if(v255) {
							bs255 |= 128;
						} else {
							bs255 &= -129;
						}
						break;
					case 1:
						if(v255) {
							bs255 |= 64;
						} else {
							bs255 &= -65;
						}
						break;
					case 2:
						if(v255) {
							bs255 |= 32;
						} else {
							bs255 &= -33;
						}
						break;
					case 3:
						if(v255) {
							bs255 |= 16;
						} else {
							bs255 &= -17;
						}
						break;
					case 4:
						if(v255) {
							bs255 |= 8;
						} else {
							bs255 &= -9;
						}
						break;
					case 5:
						if(v255) {
							bs255 |= 4;
						} else {
							bs255 &= -5;
						}
						break;
					case 6:
						if(v255) {
							bs255 |= 2;
						} else {
							bs255 &= -3;
						}
						break;
					case 7:
						if(v255) {
							bs255 |= 1;
						} else {
							bs255 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs255;
				var this257 = 0;
				var bs256 = this257;
				var l256 = "*   *".length;
				var _g1257 = 0;
				var _g357 = l256;
				while(_g1257 < _g357) {
					var i257 = _g1257++;
					var no256 = "*   *".charCodeAt(i257);
					if(no256 == null) {
						break;
					}
					var v256;
					switch(no256) {
					case 32:
						v256 = false;
						break;
					case 42:
						v256 = true;
						break;
					case 48:
						v256 = false;
						break;
					case 49:
						v256 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i257)));
					}
					switch(i257 - (l256 - 8)) {
					case 0:
						if(v256) {
							bs256 |= 128;
						} else {
							bs256 &= -129;
						}
						break;
					case 1:
						if(v256) {
							bs256 |= 64;
						} else {
							bs256 &= -65;
						}
						break;
					case 2:
						if(v256) {
							bs256 |= 32;
						} else {
							bs256 &= -33;
						}
						break;
					case 3:
						if(v256) {
							bs256 |= 16;
						} else {
							bs256 &= -17;
						}
						break;
					case 4:
						if(v256) {
							bs256 |= 8;
						} else {
							bs256 &= -9;
						}
						break;
					case 5:
						if(v256) {
							bs256 |= 4;
						} else {
							bs256 &= -5;
						}
						break;
					case 6:
						if(v256) {
							bs256 |= 2;
						} else {
							bs256 &= -3;
						}
						break;
					case 7:
						if(v256) {
							bs256 |= 1;
						} else {
							bs256 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs256;
				var this258 = 0;
				var bs257 = this258;
				var l257 = "*  * ".length;
				var _g1258 = 0;
				var _g358 = l257;
				while(_g1258 < _g358) {
					var i258 = _g1258++;
					var no257 = "*  * ".charCodeAt(i258);
					if(no257 == null) {
						break;
					}
					var v257;
					switch(no257) {
					case 32:
						v257 = false;
						break;
					case 42:
						v257 = true;
						break;
					case 48:
						v257 = false;
						break;
					case 49:
						v257 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i258)));
					}
					switch(i258 - (l257 - 8)) {
					case 0:
						if(v257) {
							bs257 |= 128;
						} else {
							bs257 &= -129;
						}
						break;
					case 1:
						if(v257) {
							bs257 |= 64;
						} else {
							bs257 &= -65;
						}
						break;
					case 2:
						if(v257) {
							bs257 |= 32;
						} else {
							bs257 &= -33;
						}
						break;
					case 3:
						if(v257) {
							bs257 |= 16;
						} else {
							bs257 &= -17;
						}
						break;
					case 4:
						if(v257) {
							bs257 |= 8;
						} else {
							bs257 &= -9;
						}
						break;
					case 5:
						if(v257) {
							bs257 |= 4;
						} else {
							bs257 &= -5;
						}
						break;
					case 6:
						if(v257) {
							bs257 |= 2;
						} else {
							bs257 &= -3;
						}
						break;
					case 7:
						if(v257) {
							bs257 |= 1;
						} else {
							bs257 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs257;
				var this259 = 0;
				var bs258 = this259;
				var l258 = "***  ".length;
				var _g1259 = 0;
				var _g359 = l258;
				while(_g1259 < _g359) {
					var i259 = _g1259++;
					var no258 = "***  ".charCodeAt(i259);
					if(no258 == null) {
						break;
					}
					var v258;
					switch(no258) {
					case 32:
						v258 = false;
						break;
					case 42:
						v258 = true;
						break;
					case 48:
						v258 = false;
						break;
					case 49:
						v258 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("***  ".charCodeAt(i259)));
					}
					switch(i259 - (l258 - 8)) {
					case 0:
						if(v258) {
							bs258 |= 128;
						} else {
							bs258 &= -129;
						}
						break;
					case 1:
						if(v258) {
							bs258 |= 64;
						} else {
							bs258 &= -65;
						}
						break;
					case 2:
						if(v258) {
							bs258 |= 32;
						} else {
							bs258 &= -33;
						}
						break;
					case 3:
						if(v258) {
							bs258 |= 16;
						} else {
							bs258 &= -17;
						}
						break;
					case 4:
						if(v258) {
							bs258 |= 8;
						} else {
							bs258 &= -9;
						}
						break;
					case 5:
						if(v258) {
							bs258 |= 4;
						} else {
							bs258 &= -5;
						}
						break;
					case 6:
						if(v258) {
							bs258 |= 2;
						} else {
							bs258 &= -3;
						}
						break;
					case 7:
						if(v258) {
							bs258 |= 1;
						} else {
							bs258 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs258;
				break;
			case 69:
				var this260 = 0;
				var bs259 = this260;
				var l259 = "*****".length;
				var _g1260 = 0;
				var _g360 = l259;
				while(_g1260 < _g360) {
					var i260 = _g1260++;
					var no259 = "*****".charCodeAt(i260);
					if(no259 == null) {
						break;
					}
					var v259;
					switch(no259) {
					case 32:
						v259 = false;
						break;
					case 42:
						v259 = true;
						break;
					case 48:
						v259 = false;
						break;
					case 49:
						v259 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i260)));
					}
					switch(i260 - (l259 - 8)) {
					case 0:
						if(v259) {
							bs259 |= 128;
						} else {
							bs259 &= -129;
						}
						break;
					case 1:
						if(v259) {
							bs259 |= 64;
						} else {
							bs259 &= -65;
						}
						break;
					case 2:
						if(v259) {
							bs259 |= 32;
						} else {
							bs259 &= -33;
						}
						break;
					case 3:
						if(v259) {
							bs259 |= 16;
						} else {
							bs259 &= -17;
						}
						break;
					case 4:
						if(v259) {
							bs259 |= 8;
						} else {
							bs259 &= -9;
						}
						break;
					case 5:
						if(v259) {
							bs259 |= 4;
						} else {
							bs259 &= -5;
						}
						break;
					case 6:
						if(v259) {
							bs259 |= 2;
						} else {
							bs259 &= -3;
						}
						break;
					case 7:
						if(v259) {
							bs259 |= 1;
						} else {
							bs259 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs259;
				var this261 = 0;
				var bs260 = this261;
				var l260 = "*    ".length;
				var _g1261 = 0;
				var _g361 = l260;
				while(_g1261 < _g361) {
					var i261 = _g1261++;
					var no260 = "*    ".charCodeAt(i261);
					if(no260 == null) {
						break;
					}
					var v260;
					switch(no260) {
					case 32:
						v260 = false;
						break;
					case 42:
						v260 = true;
						break;
					case 48:
						v260 = false;
						break;
					case 49:
						v260 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i261)));
					}
					switch(i261 - (l260 - 8)) {
					case 0:
						if(v260) {
							bs260 |= 128;
						} else {
							bs260 &= -129;
						}
						break;
					case 1:
						if(v260) {
							bs260 |= 64;
						} else {
							bs260 &= -65;
						}
						break;
					case 2:
						if(v260) {
							bs260 |= 32;
						} else {
							bs260 &= -33;
						}
						break;
					case 3:
						if(v260) {
							bs260 |= 16;
						} else {
							bs260 &= -17;
						}
						break;
					case 4:
						if(v260) {
							bs260 |= 8;
						} else {
							bs260 &= -9;
						}
						break;
					case 5:
						if(v260) {
							bs260 |= 4;
						} else {
							bs260 &= -5;
						}
						break;
					case 6:
						if(v260) {
							bs260 |= 2;
						} else {
							bs260 &= -3;
						}
						break;
					case 7:
						if(v260) {
							bs260 |= 1;
						} else {
							bs260 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs260;
				var this262 = 0;
				var bs261 = this262;
				var l261 = "*    ".length;
				var _g1262 = 0;
				var _g362 = l261;
				while(_g1262 < _g362) {
					var i262 = _g1262++;
					var no261 = "*    ".charCodeAt(i262);
					if(no261 == null) {
						break;
					}
					var v261;
					switch(no261) {
					case 32:
						v261 = false;
						break;
					case 42:
						v261 = true;
						break;
					case 48:
						v261 = false;
						break;
					case 49:
						v261 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i262)));
					}
					switch(i262 - (l261 - 8)) {
					case 0:
						if(v261) {
							bs261 |= 128;
						} else {
							bs261 &= -129;
						}
						break;
					case 1:
						if(v261) {
							bs261 |= 64;
						} else {
							bs261 &= -65;
						}
						break;
					case 2:
						if(v261) {
							bs261 |= 32;
						} else {
							bs261 &= -33;
						}
						break;
					case 3:
						if(v261) {
							bs261 |= 16;
						} else {
							bs261 &= -17;
						}
						break;
					case 4:
						if(v261) {
							bs261 |= 8;
						} else {
							bs261 &= -9;
						}
						break;
					case 5:
						if(v261) {
							bs261 |= 4;
						} else {
							bs261 &= -5;
						}
						break;
					case 6:
						if(v261) {
							bs261 |= 2;
						} else {
							bs261 &= -3;
						}
						break;
					case 7:
						if(v261) {
							bs261 |= 1;
						} else {
							bs261 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs261;
				var this263 = 0;
				var bs262 = this263;
				var l262 = "**** ".length;
				var _g1263 = 0;
				var _g363 = l262;
				while(_g1263 < _g363) {
					var i263 = _g1263++;
					var no262 = "**** ".charCodeAt(i263);
					if(no262 == null) {
						break;
					}
					var v262;
					switch(no262) {
					case 32:
						v262 = false;
						break;
					case 42:
						v262 = true;
						break;
					case 48:
						v262 = false;
						break;
					case 49:
						v262 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i263)));
					}
					switch(i263 - (l262 - 8)) {
					case 0:
						if(v262) {
							bs262 |= 128;
						} else {
							bs262 &= -129;
						}
						break;
					case 1:
						if(v262) {
							bs262 |= 64;
						} else {
							bs262 &= -65;
						}
						break;
					case 2:
						if(v262) {
							bs262 |= 32;
						} else {
							bs262 &= -33;
						}
						break;
					case 3:
						if(v262) {
							bs262 |= 16;
						} else {
							bs262 &= -17;
						}
						break;
					case 4:
						if(v262) {
							bs262 |= 8;
						} else {
							bs262 &= -9;
						}
						break;
					case 5:
						if(v262) {
							bs262 |= 4;
						} else {
							bs262 &= -5;
						}
						break;
					case 6:
						if(v262) {
							bs262 |= 2;
						} else {
							bs262 &= -3;
						}
						break;
					case 7:
						if(v262) {
							bs262 |= 1;
						} else {
							bs262 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs262;
				var this264 = 0;
				var bs263 = this264;
				var l263 = "*    ".length;
				var _g1264 = 0;
				var _g364 = l263;
				while(_g1264 < _g364) {
					var i264 = _g1264++;
					var no263 = "*    ".charCodeAt(i264);
					if(no263 == null) {
						break;
					}
					var v263;
					switch(no263) {
					case 32:
						v263 = false;
						break;
					case 42:
						v263 = true;
						break;
					case 48:
						v263 = false;
						break;
					case 49:
						v263 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i264)));
					}
					switch(i264 - (l263 - 8)) {
					case 0:
						if(v263) {
							bs263 |= 128;
						} else {
							bs263 &= -129;
						}
						break;
					case 1:
						if(v263) {
							bs263 |= 64;
						} else {
							bs263 &= -65;
						}
						break;
					case 2:
						if(v263) {
							bs263 |= 32;
						} else {
							bs263 &= -33;
						}
						break;
					case 3:
						if(v263) {
							bs263 |= 16;
						} else {
							bs263 &= -17;
						}
						break;
					case 4:
						if(v263) {
							bs263 |= 8;
						} else {
							bs263 &= -9;
						}
						break;
					case 5:
						if(v263) {
							bs263 |= 4;
						} else {
							bs263 &= -5;
						}
						break;
					case 6:
						if(v263) {
							bs263 |= 2;
						} else {
							bs263 &= -3;
						}
						break;
					case 7:
						if(v263) {
							bs263 |= 1;
						} else {
							bs263 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs263;
				var this265 = 0;
				var bs264 = this265;
				var l264 = "*    ".length;
				var _g1265 = 0;
				var _g365 = l264;
				while(_g1265 < _g365) {
					var i265 = _g1265++;
					var no264 = "*    ".charCodeAt(i265);
					if(no264 == null) {
						break;
					}
					var v264;
					switch(no264) {
					case 32:
						v264 = false;
						break;
					case 42:
						v264 = true;
						break;
					case 48:
						v264 = false;
						break;
					case 49:
						v264 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i265)));
					}
					switch(i265 - (l264 - 8)) {
					case 0:
						if(v264) {
							bs264 |= 128;
						} else {
							bs264 &= -129;
						}
						break;
					case 1:
						if(v264) {
							bs264 |= 64;
						} else {
							bs264 &= -65;
						}
						break;
					case 2:
						if(v264) {
							bs264 |= 32;
						} else {
							bs264 &= -33;
						}
						break;
					case 3:
						if(v264) {
							bs264 |= 16;
						} else {
							bs264 &= -17;
						}
						break;
					case 4:
						if(v264) {
							bs264 |= 8;
						} else {
							bs264 &= -9;
						}
						break;
					case 5:
						if(v264) {
							bs264 |= 4;
						} else {
							bs264 &= -5;
						}
						break;
					case 6:
						if(v264) {
							bs264 |= 2;
						} else {
							bs264 &= -3;
						}
						break;
					case 7:
						if(v264) {
							bs264 |= 1;
						} else {
							bs264 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs264;
				var this266 = 0;
				var bs265 = this266;
				var l265 = "*****".length;
				var _g1266 = 0;
				var _g366 = l265;
				while(_g1266 < _g366) {
					var i266 = _g1266++;
					var no265 = "*****".charCodeAt(i266);
					if(no265 == null) {
						break;
					}
					var v265;
					switch(no265) {
					case 32:
						v265 = false;
						break;
					case 42:
						v265 = true;
						break;
					case 48:
						v265 = false;
						break;
					case 49:
						v265 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i266)));
					}
					switch(i266 - (l265 - 8)) {
					case 0:
						if(v265) {
							bs265 |= 128;
						} else {
							bs265 &= -129;
						}
						break;
					case 1:
						if(v265) {
							bs265 |= 64;
						} else {
							bs265 &= -65;
						}
						break;
					case 2:
						if(v265) {
							bs265 |= 32;
						} else {
							bs265 &= -33;
						}
						break;
					case 3:
						if(v265) {
							bs265 |= 16;
						} else {
							bs265 &= -17;
						}
						break;
					case 4:
						if(v265) {
							bs265 |= 8;
						} else {
							bs265 &= -9;
						}
						break;
					case 5:
						if(v265) {
							bs265 |= 4;
						} else {
							bs265 &= -5;
						}
						break;
					case 6:
						if(v265) {
							bs265 |= 2;
						} else {
							bs265 &= -3;
						}
						break;
					case 7:
						if(v265) {
							bs265 |= 1;
						} else {
							bs265 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs265;
				break;
			case 70:
				var this267 = 0;
				var bs266 = this267;
				var l266 = "*****".length;
				var _g1267 = 0;
				var _g367 = l266;
				while(_g1267 < _g367) {
					var i267 = _g1267++;
					var no266 = "*****".charCodeAt(i267);
					if(no266 == null) {
						break;
					}
					var v266;
					switch(no266) {
					case 32:
						v266 = false;
						break;
					case 42:
						v266 = true;
						break;
					case 48:
						v266 = false;
						break;
					case 49:
						v266 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i267)));
					}
					switch(i267 - (l266 - 8)) {
					case 0:
						if(v266) {
							bs266 |= 128;
						} else {
							bs266 &= -129;
						}
						break;
					case 1:
						if(v266) {
							bs266 |= 64;
						} else {
							bs266 &= -65;
						}
						break;
					case 2:
						if(v266) {
							bs266 |= 32;
						} else {
							bs266 &= -33;
						}
						break;
					case 3:
						if(v266) {
							bs266 |= 16;
						} else {
							bs266 &= -17;
						}
						break;
					case 4:
						if(v266) {
							bs266 |= 8;
						} else {
							bs266 &= -9;
						}
						break;
					case 5:
						if(v266) {
							bs266 |= 4;
						} else {
							bs266 &= -5;
						}
						break;
					case 6:
						if(v266) {
							bs266 |= 2;
						} else {
							bs266 &= -3;
						}
						break;
					case 7:
						if(v266) {
							bs266 |= 1;
						} else {
							bs266 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs266;
				var this268 = 0;
				var bs267 = this268;
				var l267 = "*    ".length;
				var _g1268 = 0;
				var _g368 = l267;
				while(_g1268 < _g368) {
					var i268 = _g1268++;
					var no267 = "*    ".charCodeAt(i268);
					if(no267 == null) {
						break;
					}
					var v267;
					switch(no267) {
					case 32:
						v267 = false;
						break;
					case 42:
						v267 = true;
						break;
					case 48:
						v267 = false;
						break;
					case 49:
						v267 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i268)));
					}
					switch(i268 - (l267 - 8)) {
					case 0:
						if(v267) {
							bs267 |= 128;
						} else {
							bs267 &= -129;
						}
						break;
					case 1:
						if(v267) {
							bs267 |= 64;
						} else {
							bs267 &= -65;
						}
						break;
					case 2:
						if(v267) {
							bs267 |= 32;
						} else {
							bs267 &= -33;
						}
						break;
					case 3:
						if(v267) {
							bs267 |= 16;
						} else {
							bs267 &= -17;
						}
						break;
					case 4:
						if(v267) {
							bs267 |= 8;
						} else {
							bs267 &= -9;
						}
						break;
					case 5:
						if(v267) {
							bs267 |= 4;
						} else {
							bs267 &= -5;
						}
						break;
					case 6:
						if(v267) {
							bs267 |= 2;
						} else {
							bs267 &= -3;
						}
						break;
					case 7:
						if(v267) {
							bs267 |= 1;
						} else {
							bs267 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs267;
				var this269 = 0;
				var bs268 = this269;
				var l268 = "*    ".length;
				var _g1269 = 0;
				var _g369 = l268;
				while(_g1269 < _g369) {
					var i269 = _g1269++;
					var no268 = "*    ".charCodeAt(i269);
					if(no268 == null) {
						break;
					}
					var v268;
					switch(no268) {
					case 32:
						v268 = false;
						break;
					case 42:
						v268 = true;
						break;
					case 48:
						v268 = false;
						break;
					case 49:
						v268 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i269)));
					}
					switch(i269 - (l268 - 8)) {
					case 0:
						if(v268) {
							bs268 |= 128;
						} else {
							bs268 &= -129;
						}
						break;
					case 1:
						if(v268) {
							bs268 |= 64;
						} else {
							bs268 &= -65;
						}
						break;
					case 2:
						if(v268) {
							bs268 |= 32;
						} else {
							bs268 &= -33;
						}
						break;
					case 3:
						if(v268) {
							bs268 |= 16;
						} else {
							bs268 &= -17;
						}
						break;
					case 4:
						if(v268) {
							bs268 |= 8;
						} else {
							bs268 &= -9;
						}
						break;
					case 5:
						if(v268) {
							bs268 |= 4;
						} else {
							bs268 &= -5;
						}
						break;
					case 6:
						if(v268) {
							bs268 |= 2;
						} else {
							bs268 &= -3;
						}
						break;
					case 7:
						if(v268) {
							bs268 |= 1;
						} else {
							bs268 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs268;
				var this270 = 0;
				var bs269 = this270;
				var l269 = "**** ".length;
				var _g1270 = 0;
				var _g370 = l269;
				while(_g1270 < _g370) {
					var i270 = _g1270++;
					var no269 = "**** ".charCodeAt(i270);
					if(no269 == null) {
						break;
					}
					var v269;
					switch(no269) {
					case 32:
						v269 = false;
						break;
					case 42:
						v269 = true;
						break;
					case 48:
						v269 = false;
						break;
					case 49:
						v269 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i270)));
					}
					switch(i270 - (l269 - 8)) {
					case 0:
						if(v269) {
							bs269 |= 128;
						} else {
							bs269 &= -129;
						}
						break;
					case 1:
						if(v269) {
							bs269 |= 64;
						} else {
							bs269 &= -65;
						}
						break;
					case 2:
						if(v269) {
							bs269 |= 32;
						} else {
							bs269 &= -33;
						}
						break;
					case 3:
						if(v269) {
							bs269 |= 16;
						} else {
							bs269 &= -17;
						}
						break;
					case 4:
						if(v269) {
							bs269 |= 8;
						} else {
							bs269 &= -9;
						}
						break;
					case 5:
						if(v269) {
							bs269 |= 4;
						} else {
							bs269 &= -5;
						}
						break;
					case 6:
						if(v269) {
							bs269 |= 2;
						} else {
							bs269 &= -3;
						}
						break;
					case 7:
						if(v269) {
							bs269 |= 1;
						} else {
							bs269 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs269;
				var this271 = 0;
				var bs270 = this271;
				var l270 = "*    ".length;
				var _g1271 = 0;
				var _g371 = l270;
				while(_g1271 < _g371) {
					var i271 = _g1271++;
					var no270 = "*    ".charCodeAt(i271);
					if(no270 == null) {
						break;
					}
					var v270;
					switch(no270) {
					case 32:
						v270 = false;
						break;
					case 42:
						v270 = true;
						break;
					case 48:
						v270 = false;
						break;
					case 49:
						v270 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i271)));
					}
					switch(i271 - (l270 - 8)) {
					case 0:
						if(v270) {
							bs270 |= 128;
						} else {
							bs270 &= -129;
						}
						break;
					case 1:
						if(v270) {
							bs270 |= 64;
						} else {
							bs270 &= -65;
						}
						break;
					case 2:
						if(v270) {
							bs270 |= 32;
						} else {
							bs270 &= -33;
						}
						break;
					case 3:
						if(v270) {
							bs270 |= 16;
						} else {
							bs270 &= -17;
						}
						break;
					case 4:
						if(v270) {
							bs270 |= 8;
						} else {
							bs270 &= -9;
						}
						break;
					case 5:
						if(v270) {
							bs270 |= 4;
						} else {
							bs270 &= -5;
						}
						break;
					case 6:
						if(v270) {
							bs270 |= 2;
						} else {
							bs270 &= -3;
						}
						break;
					case 7:
						if(v270) {
							bs270 |= 1;
						} else {
							bs270 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs270;
				var this272 = 0;
				var bs271 = this272;
				var l271 = "*    ".length;
				var _g1272 = 0;
				var _g372 = l271;
				while(_g1272 < _g372) {
					var i272 = _g1272++;
					var no271 = "*    ".charCodeAt(i272);
					if(no271 == null) {
						break;
					}
					var v271;
					switch(no271) {
					case 32:
						v271 = false;
						break;
					case 42:
						v271 = true;
						break;
					case 48:
						v271 = false;
						break;
					case 49:
						v271 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i272)));
					}
					switch(i272 - (l271 - 8)) {
					case 0:
						if(v271) {
							bs271 |= 128;
						} else {
							bs271 &= -129;
						}
						break;
					case 1:
						if(v271) {
							bs271 |= 64;
						} else {
							bs271 &= -65;
						}
						break;
					case 2:
						if(v271) {
							bs271 |= 32;
						} else {
							bs271 &= -33;
						}
						break;
					case 3:
						if(v271) {
							bs271 |= 16;
						} else {
							bs271 &= -17;
						}
						break;
					case 4:
						if(v271) {
							bs271 |= 8;
						} else {
							bs271 &= -9;
						}
						break;
					case 5:
						if(v271) {
							bs271 |= 4;
						} else {
							bs271 &= -5;
						}
						break;
					case 6:
						if(v271) {
							bs271 |= 2;
						} else {
							bs271 &= -3;
						}
						break;
					case 7:
						if(v271) {
							bs271 |= 1;
						} else {
							bs271 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs271;
				var this273 = 0;
				var bs272 = this273;
				var l272 = "*    ".length;
				var _g1273 = 0;
				var _g373 = l272;
				while(_g1273 < _g373) {
					var i273 = _g1273++;
					var no272 = "*    ".charCodeAt(i273);
					if(no272 == null) {
						break;
					}
					var v272;
					switch(no272) {
					case 32:
						v272 = false;
						break;
					case 42:
						v272 = true;
						break;
					case 48:
						v272 = false;
						break;
					case 49:
						v272 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i273)));
					}
					switch(i273 - (l272 - 8)) {
					case 0:
						if(v272) {
							bs272 |= 128;
						} else {
							bs272 &= -129;
						}
						break;
					case 1:
						if(v272) {
							bs272 |= 64;
						} else {
							bs272 &= -65;
						}
						break;
					case 2:
						if(v272) {
							bs272 |= 32;
						} else {
							bs272 &= -33;
						}
						break;
					case 3:
						if(v272) {
							bs272 |= 16;
						} else {
							bs272 &= -17;
						}
						break;
					case 4:
						if(v272) {
							bs272 |= 8;
						} else {
							bs272 &= -9;
						}
						break;
					case 5:
						if(v272) {
							bs272 |= 4;
						} else {
							bs272 &= -5;
						}
						break;
					case 6:
						if(v272) {
							bs272 |= 2;
						} else {
							bs272 &= -3;
						}
						break;
					case 7:
						if(v272) {
							bs272 |= 1;
						} else {
							bs272 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs272;
				break;
			case 71:
				var this274 = 0;
				var bs273 = this274;
				var l273 = " *** ".length;
				var _g1274 = 0;
				var _g374 = l273;
				while(_g1274 < _g374) {
					var i274 = _g1274++;
					var no273 = " *** ".charCodeAt(i274);
					if(no273 == null) {
						break;
					}
					var v273;
					switch(no273) {
					case 32:
						v273 = false;
						break;
					case 42:
						v273 = true;
						break;
					case 48:
						v273 = false;
						break;
					case 49:
						v273 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i274)));
					}
					switch(i274 - (l273 - 8)) {
					case 0:
						if(v273) {
							bs273 |= 128;
						} else {
							bs273 &= -129;
						}
						break;
					case 1:
						if(v273) {
							bs273 |= 64;
						} else {
							bs273 &= -65;
						}
						break;
					case 2:
						if(v273) {
							bs273 |= 32;
						} else {
							bs273 &= -33;
						}
						break;
					case 3:
						if(v273) {
							bs273 |= 16;
						} else {
							bs273 &= -17;
						}
						break;
					case 4:
						if(v273) {
							bs273 |= 8;
						} else {
							bs273 &= -9;
						}
						break;
					case 5:
						if(v273) {
							bs273 |= 4;
						} else {
							bs273 &= -5;
						}
						break;
					case 6:
						if(v273) {
							bs273 |= 2;
						} else {
							bs273 &= -3;
						}
						break;
					case 7:
						if(v273) {
							bs273 |= 1;
						} else {
							bs273 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs273;
				var this275 = 0;
				var bs274 = this275;
				var l274 = "*   *".length;
				var _g1275 = 0;
				var _g375 = l274;
				while(_g1275 < _g375) {
					var i275 = _g1275++;
					var no274 = "*   *".charCodeAt(i275);
					if(no274 == null) {
						break;
					}
					var v274;
					switch(no274) {
					case 32:
						v274 = false;
						break;
					case 42:
						v274 = true;
						break;
					case 48:
						v274 = false;
						break;
					case 49:
						v274 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i275)));
					}
					switch(i275 - (l274 - 8)) {
					case 0:
						if(v274) {
							bs274 |= 128;
						} else {
							bs274 &= -129;
						}
						break;
					case 1:
						if(v274) {
							bs274 |= 64;
						} else {
							bs274 &= -65;
						}
						break;
					case 2:
						if(v274) {
							bs274 |= 32;
						} else {
							bs274 &= -33;
						}
						break;
					case 3:
						if(v274) {
							bs274 |= 16;
						} else {
							bs274 &= -17;
						}
						break;
					case 4:
						if(v274) {
							bs274 |= 8;
						} else {
							bs274 &= -9;
						}
						break;
					case 5:
						if(v274) {
							bs274 |= 4;
						} else {
							bs274 &= -5;
						}
						break;
					case 6:
						if(v274) {
							bs274 |= 2;
						} else {
							bs274 &= -3;
						}
						break;
					case 7:
						if(v274) {
							bs274 |= 1;
						} else {
							bs274 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs274;
				var this276 = 0;
				var bs275 = this276;
				var l275 = "*    ".length;
				var _g1276 = 0;
				var _g376 = l275;
				while(_g1276 < _g376) {
					var i276 = _g1276++;
					var no275 = "*    ".charCodeAt(i276);
					if(no275 == null) {
						break;
					}
					var v275;
					switch(no275) {
					case 32:
						v275 = false;
						break;
					case 42:
						v275 = true;
						break;
					case 48:
						v275 = false;
						break;
					case 49:
						v275 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i276)));
					}
					switch(i276 - (l275 - 8)) {
					case 0:
						if(v275) {
							bs275 |= 128;
						} else {
							bs275 &= -129;
						}
						break;
					case 1:
						if(v275) {
							bs275 |= 64;
						} else {
							bs275 &= -65;
						}
						break;
					case 2:
						if(v275) {
							bs275 |= 32;
						} else {
							bs275 &= -33;
						}
						break;
					case 3:
						if(v275) {
							bs275 |= 16;
						} else {
							bs275 &= -17;
						}
						break;
					case 4:
						if(v275) {
							bs275 |= 8;
						} else {
							bs275 &= -9;
						}
						break;
					case 5:
						if(v275) {
							bs275 |= 4;
						} else {
							bs275 &= -5;
						}
						break;
					case 6:
						if(v275) {
							bs275 |= 2;
						} else {
							bs275 &= -3;
						}
						break;
					case 7:
						if(v275) {
							bs275 |= 1;
						} else {
							bs275 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs275;
				var this277 = 0;
				var bs276 = this277;
				var l276 = "* ***".length;
				var _g1277 = 0;
				var _g377 = l276;
				while(_g1277 < _g377) {
					var i277 = _g1277++;
					var no276 = "* ***".charCodeAt(i277);
					if(no276 == null) {
						break;
					}
					var v276;
					switch(no276) {
					case 32:
						v276 = false;
						break;
					case 42:
						v276 = true;
						break;
					case 48:
						v276 = false;
						break;
					case 49:
						v276 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* ***".charCodeAt(i277)));
					}
					switch(i277 - (l276 - 8)) {
					case 0:
						if(v276) {
							bs276 |= 128;
						} else {
							bs276 &= -129;
						}
						break;
					case 1:
						if(v276) {
							bs276 |= 64;
						} else {
							bs276 &= -65;
						}
						break;
					case 2:
						if(v276) {
							bs276 |= 32;
						} else {
							bs276 &= -33;
						}
						break;
					case 3:
						if(v276) {
							bs276 |= 16;
						} else {
							bs276 &= -17;
						}
						break;
					case 4:
						if(v276) {
							bs276 |= 8;
						} else {
							bs276 &= -9;
						}
						break;
					case 5:
						if(v276) {
							bs276 |= 4;
						} else {
							bs276 &= -5;
						}
						break;
					case 6:
						if(v276) {
							bs276 |= 2;
						} else {
							bs276 &= -3;
						}
						break;
					case 7:
						if(v276) {
							bs276 |= 1;
						} else {
							bs276 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs276;
				var this278 = 0;
				var bs277 = this278;
				var l277 = "*   *".length;
				var _g1278 = 0;
				var _g378 = l277;
				while(_g1278 < _g378) {
					var i278 = _g1278++;
					var no277 = "*   *".charCodeAt(i278);
					if(no277 == null) {
						break;
					}
					var v277;
					switch(no277) {
					case 32:
						v277 = false;
						break;
					case 42:
						v277 = true;
						break;
					case 48:
						v277 = false;
						break;
					case 49:
						v277 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i278)));
					}
					switch(i278 - (l277 - 8)) {
					case 0:
						if(v277) {
							bs277 |= 128;
						} else {
							bs277 &= -129;
						}
						break;
					case 1:
						if(v277) {
							bs277 |= 64;
						} else {
							bs277 &= -65;
						}
						break;
					case 2:
						if(v277) {
							bs277 |= 32;
						} else {
							bs277 &= -33;
						}
						break;
					case 3:
						if(v277) {
							bs277 |= 16;
						} else {
							bs277 &= -17;
						}
						break;
					case 4:
						if(v277) {
							bs277 |= 8;
						} else {
							bs277 &= -9;
						}
						break;
					case 5:
						if(v277) {
							bs277 |= 4;
						} else {
							bs277 &= -5;
						}
						break;
					case 6:
						if(v277) {
							bs277 |= 2;
						} else {
							bs277 &= -3;
						}
						break;
					case 7:
						if(v277) {
							bs277 |= 1;
						} else {
							bs277 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs277;
				var this279 = 0;
				var bs278 = this279;
				var l278 = "*   *".length;
				var _g1279 = 0;
				var _g379 = l278;
				while(_g1279 < _g379) {
					var i279 = _g1279++;
					var no278 = "*   *".charCodeAt(i279);
					if(no278 == null) {
						break;
					}
					var v278;
					switch(no278) {
					case 32:
						v278 = false;
						break;
					case 42:
						v278 = true;
						break;
					case 48:
						v278 = false;
						break;
					case 49:
						v278 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i279)));
					}
					switch(i279 - (l278 - 8)) {
					case 0:
						if(v278) {
							bs278 |= 128;
						} else {
							bs278 &= -129;
						}
						break;
					case 1:
						if(v278) {
							bs278 |= 64;
						} else {
							bs278 &= -65;
						}
						break;
					case 2:
						if(v278) {
							bs278 |= 32;
						} else {
							bs278 &= -33;
						}
						break;
					case 3:
						if(v278) {
							bs278 |= 16;
						} else {
							bs278 &= -17;
						}
						break;
					case 4:
						if(v278) {
							bs278 |= 8;
						} else {
							bs278 &= -9;
						}
						break;
					case 5:
						if(v278) {
							bs278 |= 4;
						} else {
							bs278 &= -5;
						}
						break;
					case 6:
						if(v278) {
							bs278 |= 2;
						} else {
							bs278 &= -3;
						}
						break;
					case 7:
						if(v278) {
							bs278 |= 1;
						} else {
							bs278 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs278;
				var this280 = 0;
				var bs279 = this280;
				var l279 = " ****".length;
				var _g1280 = 0;
				var _g380 = l279;
				while(_g1280 < _g380) {
					var i280 = _g1280++;
					var no279 = " ****".charCodeAt(i280);
					if(no279 == null) {
						break;
					}
					var v279;
					switch(no279) {
					case 32:
						v279 = false;
						break;
					case 42:
						v279 = true;
						break;
					case 48:
						v279 = false;
						break;
					case 49:
						v279 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i280)));
					}
					switch(i280 - (l279 - 8)) {
					case 0:
						if(v279) {
							bs279 |= 128;
						} else {
							bs279 &= -129;
						}
						break;
					case 1:
						if(v279) {
							bs279 |= 64;
						} else {
							bs279 &= -65;
						}
						break;
					case 2:
						if(v279) {
							bs279 |= 32;
						} else {
							bs279 &= -33;
						}
						break;
					case 3:
						if(v279) {
							bs279 |= 16;
						} else {
							bs279 &= -17;
						}
						break;
					case 4:
						if(v279) {
							bs279 |= 8;
						} else {
							bs279 &= -9;
						}
						break;
					case 5:
						if(v279) {
							bs279 |= 4;
						} else {
							bs279 &= -5;
						}
						break;
					case 6:
						if(v279) {
							bs279 |= 2;
						} else {
							bs279 &= -3;
						}
						break;
					case 7:
						if(v279) {
							bs279 |= 1;
						} else {
							bs279 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs279;
				break;
			case 72:
				var this281 = 0;
				var bs280 = this281;
				var l280 = "*   *".length;
				var _g1281 = 0;
				var _g381 = l280;
				while(_g1281 < _g381) {
					var i281 = _g1281++;
					var no280 = "*   *".charCodeAt(i281);
					if(no280 == null) {
						break;
					}
					var v280;
					switch(no280) {
					case 32:
						v280 = false;
						break;
					case 42:
						v280 = true;
						break;
					case 48:
						v280 = false;
						break;
					case 49:
						v280 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i281)));
					}
					switch(i281 - (l280 - 8)) {
					case 0:
						if(v280) {
							bs280 |= 128;
						} else {
							bs280 &= -129;
						}
						break;
					case 1:
						if(v280) {
							bs280 |= 64;
						} else {
							bs280 &= -65;
						}
						break;
					case 2:
						if(v280) {
							bs280 |= 32;
						} else {
							bs280 &= -33;
						}
						break;
					case 3:
						if(v280) {
							bs280 |= 16;
						} else {
							bs280 &= -17;
						}
						break;
					case 4:
						if(v280) {
							bs280 |= 8;
						} else {
							bs280 &= -9;
						}
						break;
					case 5:
						if(v280) {
							bs280 |= 4;
						} else {
							bs280 &= -5;
						}
						break;
					case 6:
						if(v280) {
							bs280 |= 2;
						} else {
							bs280 &= -3;
						}
						break;
					case 7:
						if(v280) {
							bs280 |= 1;
						} else {
							bs280 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs280;
				var this282 = 0;
				var bs281 = this282;
				var l281 = "*   *".length;
				var _g1282 = 0;
				var _g382 = l281;
				while(_g1282 < _g382) {
					var i282 = _g1282++;
					var no281 = "*   *".charCodeAt(i282);
					if(no281 == null) {
						break;
					}
					var v281;
					switch(no281) {
					case 32:
						v281 = false;
						break;
					case 42:
						v281 = true;
						break;
					case 48:
						v281 = false;
						break;
					case 49:
						v281 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i282)));
					}
					switch(i282 - (l281 - 8)) {
					case 0:
						if(v281) {
							bs281 |= 128;
						} else {
							bs281 &= -129;
						}
						break;
					case 1:
						if(v281) {
							bs281 |= 64;
						} else {
							bs281 &= -65;
						}
						break;
					case 2:
						if(v281) {
							bs281 |= 32;
						} else {
							bs281 &= -33;
						}
						break;
					case 3:
						if(v281) {
							bs281 |= 16;
						} else {
							bs281 &= -17;
						}
						break;
					case 4:
						if(v281) {
							bs281 |= 8;
						} else {
							bs281 &= -9;
						}
						break;
					case 5:
						if(v281) {
							bs281 |= 4;
						} else {
							bs281 &= -5;
						}
						break;
					case 6:
						if(v281) {
							bs281 |= 2;
						} else {
							bs281 &= -3;
						}
						break;
					case 7:
						if(v281) {
							bs281 |= 1;
						} else {
							bs281 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs281;
				var this283 = 0;
				var bs282 = this283;
				var l282 = "*   *".length;
				var _g1283 = 0;
				var _g383 = l282;
				while(_g1283 < _g383) {
					var i283 = _g1283++;
					var no282 = "*   *".charCodeAt(i283);
					if(no282 == null) {
						break;
					}
					var v282;
					switch(no282) {
					case 32:
						v282 = false;
						break;
					case 42:
						v282 = true;
						break;
					case 48:
						v282 = false;
						break;
					case 49:
						v282 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i283)));
					}
					switch(i283 - (l282 - 8)) {
					case 0:
						if(v282) {
							bs282 |= 128;
						} else {
							bs282 &= -129;
						}
						break;
					case 1:
						if(v282) {
							bs282 |= 64;
						} else {
							bs282 &= -65;
						}
						break;
					case 2:
						if(v282) {
							bs282 |= 32;
						} else {
							bs282 &= -33;
						}
						break;
					case 3:
						if(v282) {
							bs282 |= 16;
						} else {
							bs282 &= -17;
						}
						break;
					case 4:
						if(v282) {
							bs282 |= 8;
						} else {
							bs282 &= -9;
						}
						break;
					case 5:
						if(v282) {
							bs282 |= 4;
						} else {
							bs282 &= -5;
						}
						break;
					case 6:
						if(v282) {
							bs282 |= 2;
						} else {
							bs282 &= -3;
						}
						break;
					case 7:
						if(v282) {
							bs282 |= 1;
						} else {
							bs282 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs282;
				var this284 = 0;
				var bs283 = this284;
				var l283 = "*****".length;
				var _g1284 = 0;
				var _g384 = l283;
				while(_g1284 < _g384) {
					var i284 = _g1284++;
					var no283 = "*****".charCodeAt(i284);
					if(no283 == null) {
						break;
					}
					var v283;
					switch(no283) {
					case 32:
						v283 = false;
						break;
					case 42:
						v283 = true;
						break;
					case 48:
						v283 = false;
						break;
					case 49:
						v283 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i284)));
					}
					switch(i284 - (l283 - 8)) {
					case 0:
						if(v283) {
							bs283 |= 128;
						} else {
							bs283 &= -129;
						}
						break;
					case 1:
						if(v283) {
							bs283 |= 64;
						} else {
							bs283 &= -65;
						}
						break;
					case 2:
						if(v283) {
							bs283 |= 32;
						} else {
							bs283 &= -33;
						}
						break;
					case 3:
						if(v283) {
							bs283 |= 16;
						} else {
							bs283 &= -17;
						}
						break;
					case 4:
						if(v283) {
							bs283 |= 8;
						} else {
							bs283 &= -9;
						}
						break;
					case 5:
						if(v283) {
							bs283 |= 4;
						} else {
							bs283 &= -5;
						}
						break;
					case 6:
						if(v283) {
							bs283 |= 2;
						} else {
							bs283 &= -3;
						}
						break;
					case 7:
						if(v283) {
							bs283 |= 1;
						} else {
							bs283 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs283;
				var this285 = 0;
				var bs284 = this285;
				var l284 = "*   *".length;
				var _g1285 = 0;
				var _g385 = l284;
				while(_g1285 < _g385) {
					var i285 = _g1285++;
					var no284 = "*   *".charCodeAt(i285);
					if(no284 == null) {
						break;
					}
					var v284;
					switch(no284) {
					case 32:
						v284 = false;
						break;
					case 42:
						v284 = true;
						break;
					case 48:
						v284 = false;
						break;
					case 49:
						v284 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i285)));
					}
					switch(i285 - (l284 - 8)) {
					case 0:
						if(v284) {
							bs284 |= 128;
						} else {
							bs284 &= -129;
						}
						break;
					case 1:
						if(v284) {
							bs284 |= 64;
						} else {
							bs284 &= -65;
						}
						break;
					case 2:
						if(v284) {
							bs284 |= 32;
						} else {
							bs284 &= -33;
						}
						break;
					case 3:
						if(v284) {
							bs284 |= 16;
						} else {
							bs284 &= -17;
						}
						break;
					case 4:
						if(v284) {
							bs284 |= 8;
						} else {
							bs284 &= -9;
						}
						break;
					case 5:
						if(v284) {
							bs284 |= 4;
						} else {
							bs284 &= -5;
						}
						break;
					case 6:
						if(v284) {
							bs284 |= 2;
						} else {
							bs284 &= -3;
						}
						break;
					case 7:
						if(v284) {
							bs284 |= 1;
						} else {
							bs284 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs284;
				var this286 = 0;
				var bs285 = this286;
				var l285 = "*   *".length;
				var _g1286 = 0;
				var _g386 = l285;
				while(_g1286 < _g386) {
					var i286 = _g1286++;
					var no285 = "*   *".charCodeAt(i286);
					if(no285 == null) {
						break;
					}
					var v285;
					switch(no285) {
					case 32:
						v285 = false;
						break;
					case 42:
						v285 = true;
						break;
					case 48:
						v285 = false;
						break;
					case 49:
						v285 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i286)));
					}
					switch(i286 - (l285 - 8)) {
					case 0:
						if(v285) {
							bs285 |= 128;
						} else {
							bs285 &= -129;
						}
						break;
					case 1:
						if(v285) {
							bs285 |= 64;
						} else {
							bs285 &= -65;
						}
						break;
					case 2:
						if(v285) {
							bs285 |= 32;
						} else {
							bs285 &= -33;
						}
						break;
					case 3:
						if(v285) {
							bs285 |= 16;
						} else {
							bs285 &= -17;
						}
						break;
					case 4:
						if(v285) {
							bs285 |= 8;
						} else {
							bs285 &= -9;
						}
						break;
					case 5:
						if(v285) {
							bs285 |= 4;
						} else {
							bs285 &= -5;
						}
						break;
					case 6:
						if(v285) {
							bs285 |= 2;
						} else {
							bs285 &= -3;
						}
						break;
					case 7:
						if(v285) {
							bs285 |= 1;
						} else {
							bs285 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs285;
				var this287 = 0;
				var bs286 = this287;
				var l286 = "*   *".length;
				var _g1287 = 0;
				var _g387 = l286;
				while(_g1287 < _g387) {
					var i287 = _g1287++;
					var no286 = "*   *".charCodeAt(i287);
					if(no286 == null) {
						break;
					}
					var v286;
					switch(no286) {
					case 32:
						v286 = false;
						break;
					case 42:
						v286 = true;
						break;
					case 48:
						v286 = false;
						break;
					case 49:
						v286 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i287)));
					}
					switch(i287 - (l286 - 8)) {
					case 0:
						if(v286) {
							bs286 |= 128;
						} else {
							bs286 &= -129;
						}
						break;
					case 1:
						if(v286) {
							bs286 |= 64;
						} else {
							bs286 &= -65;
						}
						break;
					case 2:
						if(v286) {
							bs286 |= 32;
						} else {
							bs286 &= -33;
						}
						break;
					case 3:
						if(v286) {
							bs286 |= 16;
						} else {
							bs286 &= -17;
						}
						break;
					case 4:
						if(v286) {
							bs286 |= 8;
						} else {
							bs286 &= -9;
						}
						break;
					case 5:
						if(v286) {
							bs286 |= 4;
						} else {
							bs286 &= -5;
						}
						break;
					case 6:
						if(v286) {
							bs286 |= 2;
						} else {
							bs286 &= -3;
						}
						break;
					case 7:
						if(v286) {
							bs286 |= 1;
						} else {
							bs286 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs286;
				break;
			case 73:
				var this288 = 0;
				var bs287 = this288;
				var l287 = " *** ".length;
				var _g1288 = 0;
				var _g388 = l287;
				while(_g1288 < _g388) {
					var i288 = _g1288++;
					var no287 = " *** ".charCodeAt(i288);
					if(no287 == null) {
						break;
					}
					var v287;
					switch(no287) {
					case 32:
						v287 = false;
						break;
					case 42:
						v287 = true;
						break;
					case 48:
						v287 = false;
						break;
					case 49:
						v287 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i288)));
					}
					switch(i288 - (l287 - 8)) {
					case 0:
						if(v287) {
							bs287 |= 128;
						} else {
							bs287 &= -129;
						}
						break;
					case 1:
						if(v287) {
							bs287 |= 64;
						} else {
							bs287 &= -65;
						}
						break;
					case 2:
						if(v287) {
							bs287 |= 32;
						} else {
							bs287 &= -33;
						}
						break;
					case 3:
						if(v287) {
							bs287 |= 16;
						} else {
							bs287 &= -17;
						}
						break;
					case 4:
						if(v287) {
							bs287 |= 8;
						} else {
							bs287 &= -9;
						}
						break;
					case 5:
						if(v287) {
							bs287 |= 4;
						} else {
							bs287 &= -5;
						}
						break;
					case 6:
						if(v287) {
							bs287 |= 2;
						} else {
							bs287 &= -3;
						}
						break;
					case 7:
						if(v287) {
							bs287 |= 1;
						} else {
							bs287 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs287;
				var this289 = 0;
				var bs288 = this289;
				var l288 = "  *  ".length;
				var _g1289 = 0;
				var _g389 = l288;
				while(_g1289 < _g389) {
					var i289 = _g1289++;
					var no288 = "  *  ".charCodeAt(i289);
					if(no288 == null) {
						break;
					}
					var v288;
					switch(no288) {
					case 32:
						v288 = false;
						break;
					case 42:
						v288 = true;
						break;
					case 48:
						v288 = false;
						break;
					case 49:
						v288 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i289)));
					}
					switch(i289 - (l288 - 8)) {
					case 0:
						if(v288) {
							bs288 |= 128;
						} else {
							bs288 &= -129;
						}
						break;
					case 1:
						if(v288) {
							bs288 |= 64;
						} else {
							bs288 &= -65;
						}
						break;
					case 2:
						if(v288) {
							bs288 |= 32;
						} else {
							bs288 &= -33;
						}
						break;
					case 3:
						if(v288) {
							bs288 |= 16;
						} else {
							bs288 &= -17;
						}
						break;
					case 4:
						if(v288) {
							bs288 |= 8;
						} else {
							bs288 &= -9;
						}
						break;
					case 5:
						if(v288) {
							bs288 |= 4;
						} else {
							bs288 &= -5;
						}
						break;
					case 6:
						if(v288) {
							bs288 |= 2;
						} else {
							bs288 &= -3;
						}
						break;
					case 7:
						if(v288) {
							bs288 |= 1;
						} else {
							bs288 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs288;
				var this290 = 0;
				var bs289 = this290;
				var l289 = "  *  ".length;
				var _g1290 = 0;
				var _g390 = l289;
				while(_g1290 < _g390) {
					var i290 = _g1290++;
					var no289 = "  *  ".charCodeAt(i290);
					if(no289 == null) {
						break;
					}
					var v289;
					switch(no289) {
					case 32:
						v289 = false;
						break;
					case 42:
						v289 = true;
						break;
					case 48:
						v289 = false;
						break;
					case 49:
						v289 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i290)));
					}
					switch(i290 - (l289 - 8)) {
					case 0:
						if(v289) {
							bs289 |= 128;
						} else {
							bs289 &= -129;
						}
						break;
					case 1:
						if(v289) {
							bs289 |= 64;
						} else {
							bs289 &= -65;
						}
						break;
					case 2:
						if(v289) {
							bs289 |= 32;
						} else {
							bs289 &= -33;
						}
						break;
					case 3:
						if(v289) {
							bs289 |= 16;
						} else {
							bs289 &= -17;
						}
						break;
					case 4:
						if(v289) {
							bs289 |= 8;
						} else {
							bs289 &= -9;
						}
						break;
					case 5:
						if(v289) {
							bs289 |= 4;
						} else {
							bs289 &= -5;
						}
						break;
					case 6:
						if(v289) {
							bs289 |= 2;
						} else {
							bs289 &= -3;
						}
						break;
					case 7:
						if(v289) {
							bs289 |= 1;
						} else {
							bs289 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs289;
				var this291 = 0;
				var bs290 = this291;
				var l290 = "  *  ".length;
				var _g1291 = 0;
				var _g391 = l290;
				while(_g1291 < _g391) {
					var i291 = _g1291++;
					var no290 = "  *  ".charCodeAt(i291);
					if(no290 == null) {
						break;
					}
					var v290;
					switch(no290) {
					case 32:
						v290 = false;
						break;
					case 42:
						v290 = true;
						break;
					case 48:
						v290 = false;
						break;
					case 49:
						v290 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i291)));
					}
					switch(i291 - (l290 - 8)) {
					case 0:
						if(v290) {
							bs290 |= 128;
						} else {
							bs290 &= -129;
						}
						break;
					case 1:
						if(v290) {
							bs290 |= 64;
						} else {
							bs290 &= -65;
						}
						break;
					case 2:
						if(v290) {
							bs290 |= 32;
						} else {
							bs290 &= -33;
						}
						break;
					case 3:
						if(v290) {
							bs290 |= 16;
						} else {
							bs290 &= -17;
						}
						break;
					case 4:
						if(v290) {
							bs290 |= 8;
						} else {
							bs290 &= -9;
						}
						break;
					case 5:
						if(v290) {
							bs290 |= 4;
						} else {
							bs290 &= -5;
						}
						break;
					case 6:
						if(v290) {
							bs290 |= 2;
						} else {
							bs290 &= -3;
						}
						break;
					case 7:
						if(v290) {
							bs290 |= 1;
						} else {
							bs290 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs290;
				var this292 = 0;
				var bs291 = this292;
				var l291 = "  *  ".length;
				var _g1292 = 0;
				var _g392 = l291;
				while(_g1292 < _g392) {
					var i292 = _g1292++;
					var no291 = "  *  ".charCodeAt(i292);
					if(no291 == null) {
						break;
					}
					var v291;
					switch(no291) {
					case 32:
						v291 = false;
						break;
					case 42:
						v291 = true;
						break;
					case 48:
						v291 = false;
						break;
					case 49:
						v291 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i292)));
					}
					switch(i292 - (l291 - 8)) {
					case 0:
						if(v291) {
							bs291 |= 128;
						} else {
							bs291 &= -129;
						}
						break;
					case 1:
						if(v291) {
							bs291 |= 64;
						} else {
							bs291 &= -65;
						}
						break;
					case 2:
						if(v291) {
							bs291 |= 32;
						} else {
							bs291 &= -33;
						}
						break;
					case 3:
						if(v291) {
							bs291 |= 16;
						} else {
							bs291 &= -17;
						}
						break;
					case 4:
						if(v291) {
							bs291 |= 8;
						} else {
							bs291 &= -9;
						}
						break;
					case 5:
						if(v291) {
							bs291 |= 4;
						} else {
							bs291 &= -5;
						}
						break;
					case 6:
						if(v291) {
							bs291 |= 2;
						} else {
							bs291 &= -3;
						}
						break;
					case 7:
						if(v291) {
							bs291 |= 1;
						} else {
							bs291 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs291;
				var this293 = 0;
				var bs292 = this293;
				var l292 = "  *  ".length;
				var _g1293 = 0;
				var _g393 = l292;
				while(_g1293 < _g393) {
					var i293 = _g1293++;
					var no292 = "  *  ".charCodeAt(i293);
					if(no292 == null) {
						break;
					}
					var v292;
					switch(no292) {
					case 32:
						v292 = false;
						break;
					case 42:
						v292 = true;
						break;
					case 48:
						v292 = false;
						break;
					case 49:
						v292 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i293)));
					}
					switch(i293 - (l292 - 8)) {
					case 0:
						if(v292) {
							bs292 |= 128;
						} else {
							bs292 &= -129;
						}
						break;
					case 1:
						if(v292) {
							bs292 |= 64;
						} else {
							bs292 &= -65;
						}
						break;
					case 2:
						if(v292) {
							bs292 |= 32;
						} else {
							bs292 &= -33;
						}
						break;
					case 3:
						if(v292) {
							bs292 |= 16;
						} else {
							bs292 &= -17;
						}
						break;
					case 4:
						if(v292) {
							bs292 |= 8;
						} else {
							bs292 &= -9;
						}
						break;
					case 5:
						if(v292) {
							bs292 |= 4;
						} else {
							bs292 &= -5;
						}
						break;
					case 6:
						if(v292) {
							bs292 |= 2;
						} else {
							bs292 &= -3;
						}
						break;
					case 7:
						if(v292) {
							bs292 |= 1;
						} else {
							bs292 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs292;
				var this294 = 0;
				var bs293 = this294;
				var l293 = " *** ".length;
				var _g1294 = 0;
				var _g394 = l293;
				while(_g1294 < _g394) {
					var i294 = _g1294++;
					var no293 = " *** ".charCodeAt(i294);
					if(no293 == null) {
						break;
					}
					var v293;
					switch(no293) {
					case 32:
						v293 = false;
						break;
					case 42:
						v293 = true;
						break;
					case 48:
						v293 = false;
						break;
					case 49:
						v293 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i294)));
					}
					switch(i294 - (l293 - 8)) {
					case 0:
						if(v293) {
							bs293 |= 128;
						} else {
							bs293 &= -129;
						}
						break;
					case 1:
						if(v293) {
							bs293 |= 64;
						} else {
							bs293 &= -65;
						}
						break;
					case 2:
						if(v293) {
							bs293 |= 32;
						} else {
							bs293 &= -33;
						}
						break;
					case 3:
						if(v293) {
							bs293 |= 16;
						} else {
							bs293 &= -17;
						}
						break;
					case 4:
						if(v293) {
							bs293 |= 8;
						} else {
							bs293 &= -9;
						}
						break;
					case 5:
						if(v293) {
							bs293 |= 4;
						} else {
							bs293 &= -5;
						}
						break;
					case 6:
						if(v293) {
							bs293 |= 2;
						} else {
							bs293 &= -3;
						}
						break;
					case 7:
						if(v293) {
							bs293 |= 1;
						} else {
							bs293 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs293;
				break;
			case 74:
				var this295 = 0;
				var bs294 = this295;
				var l294 = " ****".length;
				var _g1295 = 0;
				var _g395 = l294;
				while(_g1295 < _g395) {
					var i295 = _g1295++;
					var no294 = " ****".charCodeAt(i295);
					if(no294 == null) {
						break;
					}
					var v294;
					switch(no294) {
					case 32:
						v294 = false;
						break;
					case 42:
						v294 = true;
						break;
					case 48:
						v294 = false;
						break;
					case 49:
						v294 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i295)));
					}
					switch(i295 - (l294 - 8)) {
					case 0:
						if(v294) {
							bs294 |= 128;
						} else {
							bs294 &= -129;
						}
						break;
					case 1:
						if(v294) {
							bs294 |= 64;
						} else {
							bs294 &= -65;
						}
						break;
					case 2:
						if(v294) {
							bs294 |= 32;
						} else {
							bs294 &= -33;
						}
						break;
					case 3:
						if(v294) {
							bs294 |= 16;
						} else {
							bs294 &= -17;
						}
						break;
					case 4:
						if(v294) {
							bs294 |= 8;
						} else {
							bs294 &= -9;
						}
						break;
					case 5:
						if(v294) {
							bs294 |= 4;
						} else {
							bs294 &= -5;
						}
						break;
					case 6:
						if(v294) {
							bs294 |= 2;
						} else {
							bs294 &= -3;
						}
						break;
					case 7:
						if(v294) {
							bs294 |= 1;
						} else {
							bs294 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs294;
				var this296 = 0;
				var bs295 = this296;
				var l295 = "   * ".length;
				var _g1296 = 0;
				var _g396 = l295;
				while(_g1296 < _g396) {
					var i296 = _g1296++;
					var no295 = "   * ".charCodeAt(i296);
					if(no295 == null) {
						break;
					}
					var v295;
					switch(no295) {
					case 32:
						v295 = false;
						break;
					case 42:
						v295 = true;
						break;
					case 48:
						v295 = false;
						break;
					case 49:
						v295 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i296)));
					}
					switch(i296 - (l295 - 8)) {
					case 0:
						if(v295) {
							bs295 |= 128;
						} else {
							bs295 &= -129;
						}
						break;
					case 1:
						if(v295) {
							bs295 |= 64;
						} else {
							bs295 &= -65;
						}
						break;
					case 2:
						if(v295) {
							bs295 |= 32;
						} else {
							bs295 &= -33;
						}
						break;
					case 3:
						if(v295) {
							bs295 |= 16;
						} else {
							bs295 &= -17;
						}
						break;
					case 4:
						if(v295) {
							bs295 |= 8;
						} else {
							bs295 &= -9;
						}
						break;
					case 5:
						if(v295) {
							bs295 |= 4;
						} else {
							bs295 &= -5;
						}
						break;
					case 6:
						if(v295) {
							bs295 |= 2;
						} else {
							bs295 &= -3;
						}
						break;
					case 7:
						if(v295) {
							bs295 |= 1;
						} else {
							bs295 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs295;
				var this297 = 0;
				var bs296 = this297;
				var l296 = "   * ".length;
				var _g1297 = 0;
				var _g397 = l296;
				while(_g1297 < _g397) {
					var i297 = _g1297++;
					var no296 = "   * ".charCodeAt(i297);
					if(no296 == null) {
						break;
					}
					var v296;
					switch(no296) {
					case 32:
						v296 = false;
						break;
					case 42:
						v296 = true;
						break;
					case 48:
						v296 = false;
						break;
					case 49:
						v296 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i297)));
					}
					switch(i297 - (l296 - 8)) {
					case 0:
						if(v296) {
							bs296 |= 128;
						} else {
							bs296 &= -129;
						}
						break;
					case 1:
						if(v296) {
							bs296 |= 64;
						} else {
							bs296 &= -65;
						}
						break;
					case 2:
						if(v296) {
							bs296 |= 32;
						} else {
							bs296 &= -33;
						}
						break;
					case 3:
						if(v296) {
							bs296 |= 16;
						} else {
							bs296 &= -17;
						}
						break;
					case 4:
						if(v296) {
							bs296 |= 8;
						} else {
							bs296 &= -9;
						}
						break;
					case 5:
						if(v296) {
							bs296 |= 4;
						} else {
							bs296 &= -5;
						}
						break;
					case 6:
						if(v296) {
							bs296 |= 2;
						} else {
							bs296 &= -3;
						}
						break;
					case 7:
						if(v296) {
							bs296 |= 1;
						} else {
							bs296 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs296;
				var this298 = 0;
				var bs297 = this298;
				var l297 = "   * ".length;
				var _g1298 = 0;
				var _g398 = l297;
				while(_g1298 < _g398) {
					var i298 = _g1298++;
					var no297 = "   * ".charCodeAt(i298);
					if(no297 == null) {
						break;
					}
					var v297;
					switch(no297) {
					case 32:
						v297 = false;
						break;
					case 42:
						v297 = true;
						break;
					case 48:
						v297 = false;
						break;
					case 49:
						v297 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i298)));
					}
					switch(i298 - (l297 - 8)) {
					case 0:
						if(v297) {
							bs297 |= 128;
						} else {
							bs297 &= -129;
						}
						break;
					case 1:
						if(v297) {
							bs297 |= 64;
						} else {
							bs297 &= -65;
						}
						break;
					case 2:
						if(v297) {
							bs297 |= 32;
						} else {
							bs297 &= -33;
						}
						break;
					case 3:
						if(v297) {
							bs297 |= 16;
						} else {
							bs297 &= -17;
						}
						break;
					case 4:
						if(v297) {
							bs297 |= 8;
						} else {
							bs297 &= -9;
						}
						break;
					case 5:
						if(v297) {
							bs297 |= 4;
						} else {
							bs297 &= -5;
						}
						break;
					case 6:
						if(v297) {
							bs297 |= 2;
						} else {
							bs297 &= -3;
						}
						break;
					case 7:
						if(v297) {
							bs297 |= 1;
						} else {
							bs297 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs297;
				var this299 = 0;
				var bs298 = this299;
				var l298 = "   * ".length;
				var _g1299 = 0;
				var _g399 = l298;
				while(_g1299 < _g399) {
					var i299 = _g1299++;
					var no298 = "   * ".charCodeAt(i299);
					if(no298 == null) {
						break;
					}
					var v298;
					switch(no298) {
					case 32:
						v298 = false;
						break;
					case 42:
						v298 = true;
						break;
					case 48:
						v298 = false;
						break;
					case 49:
						v298 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i299)));
					}
					switch(i299 - (l298 - 8)) {
					case 0:
						if(v298) {
							bs298 |= 128;
						} else {
							bs298 &= -129;
						}
						break;
					case 1:
						if(v298) {
							bs298 |= 64;
						} else {
							bs298 &= -65;
						}
						break;
					case 2:
						if(v298) {
							bs298 |= 32;
						} else {
							bs298 &= -33;
						}
						break;
					case 3:
						if(v298) {
							bs298 |= 16;
						} else {
							bs298 &= -17;
						}
						break;
					case 4:
						if(v298) {
							bs298 |= 8;
						} else {
							bs298 &= -9;
						}
						break;
					case 5:
						if(v298) {
							bs298 |= 4;
						} else {
							bs298 &= -5;
						}
						break;
					case 6:
						if(v298) {
							bs298 |= 2;
						} else {
							bs298 &= -3;
						}
						break;
					case 7:
						if(v298) {
							bs298 |= 1;
						} else {
							bs298 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs298;
				var this300 = 0;
				var bs299 = this300;
				var l299 = "*  * ".length;
				var _g1300 = 0;
				var _g400 = l299;
				while(_g1300 < _g400) {
					var i300 = _g1300++;
					var no299 = "*  * ".charCodeAt(i300);
					if(no299 == null) {
						break;
					}
					var v299;
					switch(no299) {
					case 32:
						v299 = false;
						break;
					case 42:
						v299 = true;
						break;
					case 48:
						v299 = false;
						break;
					case 49:
						v299 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i300)));
					}
					switch(i300 - (l299 - 8)) {
					case 0:
						if(v299) {
							bs299 |= 128;
						} else {
							bs299 &= -129;
						}
						break;
					case 1:
						if(v299) {
							bs299 |= 64;
						} else {
							bs299 &= -65;
						}
						break;
					case 2:
						if(v299) {
							bs299 |= 32;
						} else {
							bs299 &= -33;
						}
						break;
					case 3:
						if(v299) {
							bs299 |= 16;
						} else {
							bs299 &= -17;
						}
						break;
					case 4:
						if(v299) {
							bs299 |= 8;
						} else {
							bs299 &= -9;
						}
						break;
					case 5:
						if(v299) {
							bs299 |= 4;
						} else {
							bs299 &= -5;
						}
						break;
					case 6:
						if(v299) {
							bs299 |= 2;
						} else {
							bs299 &= -3;
						}
						break;
					case 7:
						if(v299) {
							bs299 |= 1;
						} else {
							bs299 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs299;
				var this301 = 0;
				var bs300 = this301;
				var l300 = " **  ".length;
				var _g1301 = 0;
				var _g401 = l300;
				while(_g1301 < _g401) {
					var i301 = _g1301++;
					var no300 = " **  ".charCodeAt(i301);
					if(no300 == null) {
						break;
					}
					var v300;
					switch(no300) {
					case 32:
						v300 = false;
						break;
					case 42:
						v300 = true;
						break;
					case 48:
						v300 = false;
						break;
					case 49:
						v300 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i301)));
					}
					switch(i301 - (l300 - 8)) {
					case 0:
						if(v300) {
							bs300 |= 128;
						} else {
							bs300 &= -129;
						}
						break;
					case 1:
						if(v300) {
							bs300 |= 64;
						} else {
							bs300 &= -65;
						}
						break;
					case 2:
						if(v300) {
							bs300 |= 32;
						} else {
							bs300 &= -33;
						}
						break;
					case 3:
						if(v300) {
							bs300 |= 16;
						} else {
							bs300 &= -17;
						}
						break;
					case 4:
						if(v300) {
							bs300 |= 8;
						} else {
							bs300 &= -9;
						}
						break;
					case 5:
						if(v300) {
							bs300 |= 4;
						} else {
							bs300 &= -5;
						}
						break;
					case 6:
						if(v300) {
							bs300 |= 2;
						} else {
							bs300 &= -3;
						}
						break;
					case 7:
						if(v300) {
							bs300 |= 1;
						} else {
							bs300 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs300;
				break;
			case 75:
				var this302 = 0;
				var bs301 = this302;
				var l301 = "*   *".length;
				var _g1302 = 0;
				var _g402 = l301;
				while(_g1302 < _g402) {
					var i302 = _g1302++;
					var no301 = "*   *".charCodeAt(i302);
					if(no301 == null) {
						break;
					}
					var v301;
					switch(no301) {
					case 32:
						v301 = false;
						break;
					case 42:
						v301 = true;
						break;
					case 48:
						v301 = false;
						break;
					case 49:
						v301 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i302)));
					}
					switch(i302 - (l301 - 8)) {
					case 0:
						if(v301) {
							bs301 |= 128;
						} else {
							bs301 &= -129;
						}
						break;
					case 1:
						if(v301) {
							bs301 |= 64;
						} else {
							bs301 &= -65;
						}
						break;
					case 2:
						if(v301) {
							bs301 |= 32;
						} else {
							bs301 &= -33;
						}
						break;
					case 3:
						if(v301) {
							bs301 |= 16;
						} else {
							bs301 &= -17;
						}
						break;
					case 4:
						if(v301) {
							bs301 |= 8;
						} else {
							bs301 &= -9;
						}
						break;
					case 5:
						if(v301) {
							bs301 |= 4;
						} else {
							bs301 &= -5;
						}
						break;
					case 6:
						if(v301) {
							bs301 |= 2;
						} else {
							bs301 &= -3;
						}
						break;
					case 7:
						if(v301) {
							bs301 |= 1;
						} else {
							bs301 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs301;
				var this303 = 0;
				var bs302 = this303;
				var l302 = "*  * ".length;
				var _g1303 = 0;
				var _g403 = l302;
				while(_g1303 < _g403) {
					var i303 = _g1303++;
					var no302 = "*  * ".charCodeAt(i303);
					if(no302 == null) {
						break;
					}
					var v302;
					switch(no302) {
					case 32:
						v302 = false;
						break;
					case 42:
						v302 = true;
						break;
					case 48:
						v302 = false;
						break;
					case 49:
						v302 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i303)));
					}
					switch(i303 - (l302 - 8)) {
					case 0:
						if(v302) {
							bs302 |= 128;
						} else {
							bs302 &= -129;
						}
						break;
					case 1:
						if(v302) {
							bs302 |= 64;
						} else {
							bs302 &= -65;
						}
						break;
					case 2:
						if(v302) {
							bs302 |= 32;
						} else {
							bs302 &= -33;
						}
						break;
					case 3:
						if(v302) {
							bs302 |= 16;
						} else {
							bs302 &= -17;
						}
						break;
					case 4:
						if(v302) {
							bs302 |= 8;
						} else {
							bs302 &= -9;
						}
						break;
					case 5:
						if(v302) {
							bs302 |= 4;
						} else {
							bs302 &= -5;
						}
						break;
					case 6:
						if(v302) {
							bs302 |= 2;
						} else {
							bs302 &= -3;
						}
						break;
					case 7:
						if(v302) {
							bs302 |= 1;
						} else {
							bs302 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs302;
				var this304 = 0;
				var bs303 = this304;
				var l303 = "* *  ".length;
				var _g1304 = 0;
				var _g404 = l303;
				while(_g1304 < _g404) {
					var i304 = _g1304++;
					var no303 = "* *  ".charCodeAt(i304);
					if(no303 == null) {
						break;
					}
					var v303;
					switch(no303) {
					case 32:
						v303 = false;
						break;
					case 42:
						v303 = true;
						break;
					case 48:
						v303 = false;
						break;
					case 49:
						v303 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i304)));
					}
					switch(i304 - (l303 - 8)) {
					case 0:
						if(v303) {
							bs303 |= 128;
						} else {
							bs303 &= -129;
						}
						break;
					case 1:
						if(v303) {
							bs303 |= 64;
						} else {
							bs303 &= -65;
						}
						break;
					case 2:
						if(v303) {
							bs303 |= 32;
						} else {
							bs303 &= -33;
						}
						break;
					case 3:
						if(v303) {
							bs303 |= 16;
						} else {
							bs303 &= -17;
						}
						break;
					case 4:
						if(v303) {
							bs303 |= 8;
						} else {
							bs303 &= -9;
						}
						break;
					case 5:
						if(v303) {
							bs303 |= 4;
						} else {
							bs303 &= -5;
						}
						break;
					case 6:
						if(v303) {
							bs303 |= 2;
						} else {
							bs303 &= -3;
						}
						break;
					case 7:
						if(v303) {
							bs303 |= 1;
						} else {
							bs303 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs303;
				var this305 = 0;
				var bs304 = this305;
				var l304 = "**   ".length;
				var _g1305 = 0;
				var _g405 = l304;
				while(_g1305 < _g405) {
					var i305 = _g1305++;
					var no304 = "**   ".charCodeAt(i305);
					if(no304 == null) {
						break;
					}
					var v304;
					switch(no304) {
					case 32:
						v304 = false;
						break;
					case 42:
						v304 = true;
						break;
					case 48:
						v304 = false;
						break;
					case 49:
						v304 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**   ".charCodeAt(i305)));
					}
					switch(i305 - (l304 - 8)) {
					case 0:
						if(v304) {
							bs304 |= 128;
						} else {
							bs304 &= -129;
						}
						break;
					case 1:
						if(v304) {
							bs304 |= 64;
						} else {
							bs304 &= -65;
						}
						break;
					case 2:
						if(v304) {
							bs304 |= 32;
						} else {
							bs304 &= -33;
						}
						break;
					case 3:
						if(v304) {
							bs304 |= 16;
						} else {
							bs304 &= -17;
						}
						break;
					case 4:
						if(v304) {
							bs304 |= 8;
						} else {
							bs304 &= -9;
						}
						break;
					case 5:
						if(v304) {
							bs304 |= 4;
						} else {
							bs304 &= -5;
						}
						break;
					case 6:
						if(v304) {
							bs304 |= 2;
						} else {
							bs304 &= -3;
						}
						break;
					case 7:
						if(v304) {
							bs304 |= 1;
						} else {
							bs304 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs304;
				var this306 = 0;
				var bs305 = this306;
				var l305 = "* *  ".length;
				var _g1306 = 0;
				var _g406 = l305;
				while(_g1306 < _g406) {
					var i306 = _g1306++;
					var no305 = "* *  ".charCodeAt(i306);
					if(no305 == null) {
						break;
					}
					var v305;
					switch(no305) {
					case 32:
						v305 = false;
						break;
					case 42:
						v305 = true;
						break;
					case 48:
						v305 = false;
						break;
					case 49:
						v305 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i306)));
					}
					switch(i306 - (l305 - 8)) {
					case 0:
						if(v305) {
							bs305 |= 128;
						} else {
							bs305 &= -129;
						}
						break;
					case 1:
						if(v305) {
							bs305 |= 64;
						} else {
							bs305 &= -65;
						}
						break;
					case 2:
						if(v305) {
							bs305 |= 32;
						} else {
							bs305 &= -33;
						}
						break;
					case 3:
						if(v305) {
							bs305 |= 16;
						} else {
							bs305 &= -17;
						}
						break;
					case 4:
						if(v305) {
							bs305 |= 8;
						} else {
							bs305 &= -9;
						}
						break;
					case 5:
						if(v305) {
							bs305 |= 4;
						} else {
							bs305 &= -5;
						}
						break;
					case 6:
						if(v305) {
							bs305 |= 2;
						} else {
							bs305 &= -3;
						}
						break;
					case 7:
						if(v305) {
							bs305 |= 1;
						} else {
							bs305 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs305;
				var this307 = 0;
				var bs306 = this307;
				var l306 = "*  * ".length;
				var _g1307 = 0;
				var _g407 = l306;
				while(_g1307 < _g407) {
					var i307 = _g1307++;
					var no306 = "*  * ".charCodeAt(i307);
					if(no306 == null) {
						break;
					}
					var v306;
					switch(no306) {
					case 32:
						v306 = false;
						break;
					case 42:
						v306 = true;
						break;
					case 48:
						v306 = false;
						break;
					case 49:
						v306 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i307)));
					}
					switch(i307 - (l306 - 8)) {
					case 0:
						if(v306) {
							bs306 |= 128;
						} else {
							bs306 &= -129;
						}
						break;
					case 1:
						if(v306) {
							bs306 |= 64;
						} else {
							bs306 &= -65;
						}
						break;
					case 2:
						if(v306) {
							bs306 |= 32;
						} else {
							bs306 &= -33;
						}
						break;
					case 3:
						if(v306) {
							bs306 |= 16;
						} else {
							bs306 &= -17;
						}
						break;
					case 4:
						if(v306) {
							bs306 |= 8;
						} else {
							bs306 &= -9;
						}
						break;
					case 5:
						if(v306) {
							bs306 |= 4;
						} else {
							bs306 &= -5;
						}
						break;
					case 6:
						if(v306) {
							bs306 |= 2;
						} else {
							bs306 &= -3;
						}
						break;
					case 7:
						if(v306) {
							bs306 |= 1;
						} else {
							bs306 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs306;
				var this308 = 0;
				var bs307 = this308;
				var l307 = "*   *".length;
				var _g1308 = 0;
				var _g408 = l307;
				while(_g1308 < _g408) {
					var i308 = _g1308++;
					var no307 = "*   *".charCodeAt(i308);
					if(no307 == null) {
						break;
					}
					var v307;
					switch(no307) {
					case 32:
						v307 = false;
						break;
					case 42:
						v307 = true;
						break;
					case 48:
						v307 = false;
						break;
					case 49:
						v307 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i308)));
					}
					switch(i308 - (l307 - 8)) {
					case 0:
						if(v307) {
							bs307 |= 128;
						} else {
							bs307 &= -129;
						}
						break;
					case 1:
						if(v307) {
							bs307 |= 64;
						} else {
							bs307 &= -65;
						}
						break;
					case 2:
						if(v307) {
							bs307 |= 32;
						} else {
							bs307 &= -33;
						}
						break;
					case 3:
						if(v307) {
							bs307 |= 16;
						} else {
							bs307 &= -17;
						}
						break;
					case 4:
						if(v307) {
							bs307 |= 8;
						} else {
							bs307 &= -9;
						}
						break;
					case 5:
						if(v307) {
							bs307 |= 4;
						} else {
							bs307 &= -5;
						}
						break;
					case 6:
						if(v307) {
							bs307 |= 2;
						} else {
							bs307 &= -3;
						}
						break;
					case 7:
						if(v307) {
							bs307 |= 1;
						} else {
							bs307 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs307;
				break;
			case 76:
				var this309 = 0;
				var bs308 = this309;
				var l308 = "*    ".length;
				var _g1309 = 0;
				var _g409 = l308;
				while(_g1309 < _g409) {
					var i309 = _g1309++;
					var no308 = "*    ".charCodeAt(i309);
					if(no308 == null) {
						break;
					}
					var v308;
					switch(no308) {
					case 32:
						v308 = false;
						break;
					case 42:
						v308 = true;
						break;
					case 48:
						v308 = false;
						break;
					case 49:
						v308 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i309)));
					}
					switch(i309 - (l308 - 8)) {
					case 0:
						if(v308) {
							bs308 |= 128;
						} else {
							bs308 &= -129;
						}
						break;
					case 1:
						if(v308) {
							bs308 |= 64;
						} else {
							bs308 &= -65;
						}
						break;
					case 2:
						if(v308) {
							bs308 |= 32;
						} else {
							bs308 &= -33;
						}
						break;
					case 3:
						if(v308) {
							bs308 |= 16;
						} else {
							bs308 &= -17;
						}
						break;
					case 4:
						if(v308) {
							bs308 |= 8;
						} else {
							bs308 &= -9;
						}
						break;
					case 5:
						if(v308) {
							bs308 |= 4;
						} else {
							bs308 &= -5;
						}
						break;
					case 6:
						if(v308) {
							bs308 |= 2;
						} else {
							bs308 &= -3;
						}
						break;
					case 7:
						if(v308) {
							bs308 |= 1;
						} else {
							bs308 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs308;
				var this310 = 0;
				var bs309 = this310;
				var l309 = "*    ".length;
				var _g1310 = 0;
				var _g410 = l309;
				while(_g1310 < _g410) {
					var i310 = _g1310++;
					var no309 = "*    ".charCodeAt(i310);
					if(no309 == null) {
						break;
					}
					var v309;
					switch(no309) {
					case 32:
						v309 = false;
						break;
					case 42:
						v309 = true;
						break;
					case 48:
						v309 = false;
						break;
					case 49:
						v309 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i310)));
					}
					switch(i310 - (l309 - 8)) {
					case 0:
						if(v309) {
							bs309 |= 128;
						} else {
							bs309 &= -129;
						}
						break;
					case 1:
						if(v309) {
							bs309 |= 64;
						} else {
							bs309 &= -65;
						}
						break;
					case 2:
						if(v309) {
							bs309 |= 32;
						} else {
							bs309 &= -33;
						}
						break;
					case 3:
						if(v309) {
							bs309 |= 16;
						} else {
							bs309 &= -17;
						}
						break;
					case 4:
						if(v309) {
							bs309 |= 8;
						} else {
							bs309 &= -9;
						}
						break;
					case 5:
						if(v309) {
							bs309 |= 4;
						} else {
							bs309 &= -5;
						}
						break;
					case 6:
						if(v309) {
							bs309 |= 2;
						} else {
							bs309 &= -3;
						}
						break;
					case 7:
						if(v309) {
							bs309 |= 1;
						} else {
							bs309 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs309;
				var this311 = 0;
				var bs310 = this311;
				var l310 = "*    ".length;
				var _g1311 = 0;
				var _g411 = l310;
				while(_g1311 < _g411) {
					var i311 = _g1311++;
					var no310 = "*    ".charCodeAt(i311);
					if(no310 == null) {
						break;
					}
					var v310;
					switch(no310) {
					case 32:
						v310 = false;
						break;
					case 42:
						v310 = true;
						break;
					case 48:
						v310 = false;
						break;
					case 49:
						v310 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i311)));
					}
					switch(i311 - (l310 - 8)) {
					case 0:
						if(v310) {
							bs310 |= 128;
						} else {
							bs310 &= -129;
						}
						break;
					case 1:
						if(v310) {
							bs310 |= 64;
						} else {
							bs310 &= -65;
						}
						break;
					case 2:
						if(v310) {
							bs310 |= 32;
						} else {
							bs310 &= -33;
						}
						break;
					case 3:
						if(v310) {
							bs310 |= 16;
						} else {
							bs310 &= -17;
						}
						break;
					case 4:
						if(v310) {
							bs310 |= 8;
						} else {
							bs310 &= -9;
						}
						break;
					case 5:
						if(v310) {
							bs310 |= 4;
						} else {
							bs310 &= -5;
						}
						break;
					case 6:
						if(v310) {
							bs310 |= 2;
						} else {
							bs310 &= -3;
						}
						break;
					case 7:
						if(v310) {
							bs310 |= 1;
						} else {
							bs310 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs310;
				var this312 = 0;
				var bs311 = this312;
				var l311 = "*    ".length;
				var _g1312 = 0;
				var _g412 = l311;
				while(_g1312 < _g412) {
					var i312 = _g1312++;
					var no311 = "*    ".charCodeAt(i312);
					if(no311 == null) {
						break;
					}
					var v311;
					switch(no311) {
					case 32:
						v311 = false;
						break;
					case 42:
						v311 = true;
						break;
					case 48:
						v311 = false;
						break;
					case 49:
						v311 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i312)));
					}
					switch(i312 - (l311 - 8)) {
					case 0:
						if(v311) {
							bs311 |= 128;
						} else {
							bs311 &= -129;
						}
						break;
					case 1:
						if(v311) {
							bs311 |= 64;
						} else {
							bs311 &= -65;
						}
						break;
					case 2:
						if(v311) {
							bs311 |= 32;
						} else {
							bs311 &= -33;
						}
						break;
					case 3:
						if(v311) {
							bs311 |= 16;
						} else {
							bs311 &= -17;
						}
						break;
					case 4:
						if(v311) {
							bs311 |= 8;
						} else {
							bs311 &= -9;
						}
						break;
					case 5:
						if(v311) {
							bs311 |= 4;
						} else {
							bs311 &= -5;
						}
						break;
					case 6:
						if(v311) {
							bs311 |= 2;
						} else {
							bs311 &= -3;
						}
						break;
					case 7:
						if(v311) {
							bs311 |= 1;
						} else {
							bs311 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs311;
				var this313 = 0;
				var bs312 = this313;
				var l312 = "*    ".length;
				var _g1313 = 0;
				var _g413 = l312;
				while(_g1313 < _g413) {
					var i313 = _g1313++;
					var no312 = "*    ".charCodeAt(i313);
					if(no312 == null) {
						break;
					}
					var v312;
					switch(no312) {
					case 32:
						v312 = false;
						break;
					case 42:
						v312 = true;
						break;
					case 48:
						v312 = false;
						break;
					case 49:
						v312 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i313)));
					}
					switch(i313 - (l312 - 8)) {
					case 0:
						if(v312) {
							bs312 |= 128;
						} else {
							bs312 &= -129;
						}
						break;
					case 1:
						if(v312) {
							bs312 |= 64;
						} else {
							bs312 &= -65;
						}
						break;
					case 2:
						if(v312) {
							bs312 |= 32;
						} else {
							bs312 &= -33;
						}
						break;
					case 3:
						if(v312) {
							bs312 |= 16;
						} else {
							bs312 &= -17;
						}
						break;
					case 4:
						if(v312) {
							bs312 |= 8;
						} else {
							bs312 &= -9;
						}
						break;
					case 5:
						if(v312) {
							bs312 |= 4;
						} else {
							bs312 &= -5;
						}
						break;
					case 6:
						if(v312) {
							bs312 |= 2;
						} else {
							bs312 &= -3;
						}
						break;
					case 7:
						if(v312) {
							bs312 |= 1;
						} else {
							bs312 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs312;
				var this314 = 0;
				var bs313 = this314;
				var l313 = "*    ".length;
				var _g1314 = 0;
				var _g414 = l313;
				while(_g1314 < _g414) {
					var i314 = _g1314++;
					var no313 = "*    ".charCodeAt(i314);
					if(no313 == null) {
						break;
					}
					var v313;
					switch(no313) {
					case 32:
						v313 = false;
						break;
					case 42:
						v313 = true;
						break;
					case 48:
						v313 = false;
						break;
					case 49:
						v313 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i314)));
					}
					switch(i314 - (l313 - 8)) {
					case 0:
						if(v313) {
							bs313 |= 128;
						} else {
							bs313 &= -129;
						}
						break;
					case 1:
						if(v313) {
							bs313 |= 64;
						} else {
							bs313 &= -65;
						}
						break;
					case 2:
						if(v313) {
							bs313 |= 32;
						} else {
							bs313 &= -33;
						}
						break;
					case 3:
						if(v313) {
							bs313 |= 16;
						} else {
							bs313 &= -17;
						}
						break;
					case 4:
						if(v313) {
							bs313 |= 8;
						} else {
							bs313 &= -9;
						}
						break;
					case 5:
						if(v313) {
							bs313 |= 4;
						} else {
							bs313 &= -5;
						}
						break;
					case 6:
						if(v313) {
							bs313 |= 2;
						} else {
							bs313 &= -3;
						}
						break;
					case 7:
						if(v313) {
							bs313 |= 1;
						} else {
							bs313 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs313;
				var this315 = 0;
				var bs314 = this315;
				var l314 = "*****".length;
				var _g1315 = 0;
				var _g415 = l314;
				while(_g1315 < _g415) {
					var i315 = _g1315++;
					var no314 = "*****".charCodeAt(i315);
					if(no314 == null) {
						break;
					}
					var v314;
					switch(no314) {
					case 32:
						v314 = false;
						break;
					case 42:
						v314 = true;
						break;
					case 48:
						v314 = false;
						break;
					case 49:
						v314 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i315)));
					}
					switch(i315 - (l314 - 8)) {
					case 0:
						if(v314) {
							bs314 |= 128;
						} else {
							bs314 &= -129;
						}
						break;
					case 1:
						if(v314) {
							bs314 |= 64;
						} else {
							bs314 &= -65;
						}
						break;
					case 2:
						if(v314) {
							bs314 |= 32;
						} else {
							bs314 &= -33;
						}
						break;
					case 3:
						if(v314) {
							bs314 |= 16;
						} else {
							bs314 &= -17;
						}
						break;
					case 4:
						if(v314) {
							bs314 |= 8;
						} else {
							bs314 &= -9;
						}
						break;
					case 5:
						if(v314) {
							bs314 |= 4;
						} else {
							bs314 &= -5;
						}
						break;
					case 6:
						if(v314) {
							bs314 |= 2;
						} else {
							bs314 &= -3;
						}
						break;
					case 7:
						if(v314) {
							bs314 |= 1;
						} else {
							bs314 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs314;
				break;
			case 77:
				var this316 = 0;
				var bs315 = this316;
				var l315 = "*   *".length;
				var _g1316 = 0;
				var _g416 = l315;
				while(_g1316 < _g416) {
					var i316 = _g1316++;
					var no315 = "*   *".charCodeAt(i316);
					if(no315 == null) {
						break;
					}
					var v315;
					switch(no315) {
					case 32:
						v315 = false;
						break;
					case 42:
						v315 = true;
						break;
					case 48:
						v315 = false;
						break;
					case 49:
						v315 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i316)));
					}
					switch(i316 - (l315 - 8)) {
					case 0:
						if(v315) {
							bs315 |= 128;
						} else {
							bs315 &= -129;
						}
						break;
					case 1:
						if(v315) {
							bs315 |= 64;
						} else {
							bs315 &= -65;
						}
						break;
					case 2:
						if(v315) {
							bs315 |= 32;
						} else {
							bs315 &= -33;
						}
						break;
					case 3:
						if(v315) {
							bs315 |= 16;
						} else {
							bs315 &= -17;
						}
						break;
					case 4:
						if(v315) {
							bs315 |= 8;
						} else {
							bs315 &= -9;
						}
						break;
					case 5:
						if(v315) {
							bs315 |= 4;
						} else {
							bs315 &= -5;
						}
						break;
					case 6:
						if(v315) {
							bs315 |= 2;
						} else {
							bs315 &= -3;
						}
						break;
					case 7:
						if(v315) {
							bs315 |= 1;
						} else {
							bs315 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs315;
				var this317 = 0;
				var bs316 = this317;
				var l316 = "** **".length;
				var _g1317 = 0;
				var _g417 = l316;
				while(_g1317 < _g417) {
					var i317 = _g1317++;
					var no316 = "** **".charCodeAt(i317);
					if(no316 == null) {
						break;
					}
					var v316;
					switch(no316) {
					case 32:
						v316 = false;
						break;
					case 42:
						v316 = true;
						break;
					case 48:
						v316 = false;
						break;
					case 49:
						v316 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("** **".charCodeAt(i317)));
					}
					switch(i317 - (l316 - 8)) {
					case 0:
						if(v316) {
							bs316 |= 128;
						} else {
							bs316 &= -129;
						}
						break;
					case 1:
						if(v316) {
							bs316 |= 64;
						} else {
							bs316 &= -65;
						}
						break;
					case 2:
						if(v316) {
							bs316 |= 32;
						} else {
							bs316 &= -33;
						}
						break;
					case 3:
						if(v316) {
							bs316 |= 16;
						} else {
							bs316 &= -17;
						}
						break;
					case 4:
						if(v316) {
							bs316 |= 8;
						} else {
							bs316 &= -9;
						}
						break;
					case 5:
						if(v316) {
							bs316 |= 4;
						} else {
							bs316 &= -5;
						}
						break;
					case 6:
						if(v316) {
							bs316 |= 2;
						} else {
							bs316 &= -3;
						}
						break;
					case 7:
						if(v316) {
							bs316 |= 1;
						} else {
							bs316 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs316;
				var this318 = 0;
				var bs317 = this318;
				var l317 = "* * *".length;
				var _g1318 = 0;
				var _g418 = l317;
				while(_g1318 < _g418) {
					var i318 = _g1318++;
					var no317 = "* * *".charCodeAt(i318);
					if(no317 == null) {
						break;
					}
					var v317;
					switch(no317) {
					case 32:
						v317 = false;
						break;
					case 42:
						v317 = true;
						break;
					case 48:
						v317 = false;
						break;
					case 49:
						v317 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i318)));
					}
					switch(i318 - (l317 - 8)) {
					case 0:
						if(v317) {
							bs317 |= 128;
						} else {
							bs317 &= -129;
						}
						break;
					case 1:
						if(v317) {
							bs317 |= 64;
						} else {
							bs317 &= -65;
						}
						break;
					case 2:
						if(v317) {
							bs317 |= 32;
						} else {
							bs317 &= -33;
						}
						break;
					case 3:
						if(v317) {
							bs317 |= 16;
						} else {
							bs317 &= -17;
						}
						break;
					case 4:
						if(v317) {
							bs317 |= 8;
						} else {
							bs317 &= -9;
						}
						break;
					case 5:
						if(v317) {
							bs317 |= 4;
						} else {
							bs317 &= -5;
						}
						break;
					case 6:
						if(v317) {
							bs317 |= 2;
						} else {
							bs317 &= -3;
						}
						break;
					case 7:
						if(v317) {
							bs317 |= 1;
						} else {
							bs317 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs317;
				var this319 = 0;
				var bs318 = this319;
				var l318 = "* * *".length;
				var _g1319 = 0;
				var _g419 = l318;
				while(_g1319 < _g419) {
					var i319 = _g1319++;
					var no318 = "* * *".charCodeAt(i319);
					if(no318 == null) {
						break;
					}
					var v318;
					switch(no318) {
					case 32:
						v318 = false;
						break;
					case 42:
						v318 = true;
						break;
					case 48:
						v318 = false;
						break;
					case 49:
						v318 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i319)));
					}
					switch(i319 - (l318 - 8)) {
					case 0:
						if(v318) {
							bs318 |= 128;
						} else {
							bs318 &= -129;
						}
						break;
					case 1:
						if(v318) {
							bs318 |= 64;
						} else {
							bs318 &= -65;
						}
						break;
					case 2:
						if(v318) {
							bs318 |= 32;
						} else {
							bs318 &= -33;
						}
						break;
					case 3:
						if(v318) {
							bs318 |= 16;
						} else {
							bs318 &= -17;
						}
						break;
					case 4:
						if(v318) {
							bs318 |= 8;
						} else {
							bs318 &= -9;
						}
						break;
					case 5:
						if(v318) {
							bs318 |= 4;
						} else {
							bs318 &= -5;
						}
						break;
					case 6:
						if(v318) {
							bs318 |= 2;
						} else {
							bs318 &= -3;
						}
						break;
					case 7:
						if(v318) {
							bs318 |= 1;
						} else {
							bs318 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs318;
				var this320 = 0;
				var bs319 = this320;
				var l319 = "*   *".length;
				var _g1320 = 0;
				var _g420 = l319;
				while(_g1320 < _g420) {
					var i320 = _g1320++;
					var no319 = "*   *".charCodeAt(i320);
					if(no319 == null) {
						break;
					}
					var v319;
					switch(no319) {
					case 32:
						v319 = false;
						break;
					case 42:
						v319 = true;
						break;
					case 48:
						v319 = false;
						break;
					case 49:
						v319 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i320)));
					}
					switch(i320 - (l319 - 8)) {
					case 0:
						if(v319) {
							bs319 |= 128;
						} else {
							bs319 &= -129;
						}
						break;
					case 1:
						if(v319) {
							bs319 |= 64;
						} else {
							bs319 &= -65;
						}
						break;
					case 2:
						if(v319) {
							bs319 |= 32;
						} else {
							bs319 &= -33;
						}
						break;
					case 3:
						if(v319) {
							bs319 |= 16;
						} else {
							bs319 &= -17;
						}
						break;
					case 4:
						if(v319) {
							bs319 |= 8;
						} else {
							bs319 &= -9;
						}
						break;
					case 5:
						if(v319) {
							bs319 |= 4;
						} else {
							bs319 &= -5;
						}
						break;
					case 6:
						if(v319) {
							bs319 |= 2;
						} else {
							bs319 &= -3;
						}
						break;
					case 7:
						if(v319) {
							bs319 |= 1;
						} else {
							bs319 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs319;
				var this321 = 0;
				var bs320 = this321;
				var l320 = "*   *".length;
				var _g1321 = 0;
				var _g421 = l320;
				while(_g1321 < _g421) {
					var i321 = _g1321++;
					var no320 = "*   *".charCodeAt(i321);
					if(no320 == null) {
						break;
					}
					var v320;
					switch(no320) {
					case 32:
						v320 = false;
						break;
					case 42:
						v320 = true;
						break;
					case 48:
						v320 = false;
						break;
					case 49:
						v320 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i321)));
					}
					switch(i321 - (l320 - 8)) {
					case 0:
						if(v320) {
							bs320 |= 128;
						} else {
							bs320 &= -129;
						}
						break;
					case 1:
						if(v320) {
							bs320 |= 64;
						} else {
							bs320 &= -65;
						}
						break;
					case 2:
						if(v320) {
							bs320 |= 32;
						} else {
							bs320 &= -33;
						}
						break;
					case 3:
						if(v320) {
							bs320 |= 16;
						} else {
							bs320 &= -17;
						}
						break;
					case 4:
						if(v320) {
							bs320 |= 8;
						} else {
							bs320 &= -9;
						}
						break;
					case 5:
						if(v320) {
							bs320 |= 4;
						} else {
							bs320 &= -5;
						}
						break;
					case 6:
						if(v320) {
							bs320 |= 2;
						} else {
							bs320 &= -3;
						}
						break;
					case 7:
						if(v320) {
							bs320 |= 1;
						} else {
							bs320 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs320;
				var this322 = 0;
				var bs321 = this322;
				var l321 = "*   *".length;
				var _g1322 = 0;
				var _g422 = l321;
				while(_g1322 < _g422) {
					var i322 = _g1322++;
					var no321 = "*   *".charCodeAt(i322);
					if(no321 == null) {
						break;
					}
					var v321;
					switch(no321) {
					case 32:
						v321 = false;
						break;
					case 42:
						v321 = true;
						break;
					case 48:
						v321 = false;
						break;
					case 49:
						v321 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i322)));
					}
					switch(i322 - (l321 - 8)) {
					case 0:
						if(v321) {
							bs321 |= 128;
						} else {
							bs321 &= -129;
						}
						break;
					case 1:
						if(v321) {
							bs321 |= 64;
						} else {
							bs321 &= -65;
						}
						break;
					case 2:
						if(v321) {
							bs321 |= 32;
						} else {
							bs321 &= -33;
						}
						break;
					case 3:
						if(v321) {
							bs321 |= 16;
						} else {
							bs321 &= -17;
						}
						break;
					case 4:
						if(v321) {
							bs321 |= 8;
						} else {
							bs321 &= -9;
						}
						break;
					case 5:
						if(v321) {
							bs321 |= 4;
						} else {
							bs321 &= -5;
						}
						break;
					case 6:
						if(v321) {
							bs321 |= 2;
						} else {
							bs321 &= -3;
						}
						break;
					case 7:
						if(v321) {
							bs321 |= 1;
						} else {
							bs321 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs321;
				break;
			case 78:
				var this323 = 0;
				var bs322 = this323;
				var l322 = "*   *".length;
				var _g1323 = 0;
				var _g423 = l322;
				while(_g1323 < _g423) {
					var i323 = _g1323++;
					var no322 = "*   *".charCodeAt(i323);
					if(no322 == null) {
						break;
					}
					var v322;
					switch(no322) {
					case 32:
						v322 = false;
						break;
					case 42:
						v322 = true;
						break;
					case 48:
						v322 = false;
						break;
					case 49:
						v322 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i323)));
					}
					switch(i323 - (l322 - 8)) {
					case 0:
						if(v322) {
							bs322 |= 128;
						} else {
							bs322 &= -129;
						}
						break;
					case 1:
						if(v322) {
							bs322 |= 64;
						} else {
							bs322 &= -65;
						}
						break;
					case 2:
						if(v322) {
							bs322 |= 32;
						} else {
							bs322 &= -33;
						}
						break;
					case 3:
						if(v322) {
							bs322 |= 16;
						} else {
							bs322 &= -17;
						}
						break;
					case 4:
						if(v322) {
							bs322 |= 8;
						} else {
							bs322 &= -9;
						}
						break;
					case 5:
						if(v322) {
							bs322 |= 4;
						} else {
							bs322 &= -5;
						}
						break;
					case 6:
						if(v322) {
							bs322 |= 2;
						} else {
							bs322 &= -3;
						}
						break;
					case 7:
						if(v322) {
							bs322 |= 1;
						} else {
							bs322 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs322;
				var this324 = 0;
				var bs323 = this324;
				var l323 = "*   *".length;
				var _g1324 = 0;
				var _g424 = l323;
				while(_g1324 < _g424) {
					var i324 = _g1324++;
					var no323 = "*   *".charCodeAt(i324);
					if(no323 == null) {
						break;
					}
					var v323;
					switch(no323) {
					case 32:
						v323 = false;
						break;
					case 42:
						v323 = true;
						break;
					case 48:
						v323 = false;
						break;
					case 49:
						v323 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i324)));
					}
					switch(i324 - (l323 - 8)) {
					case 0:
						if(v323) {
							bs323 |= 128;
						} else {
							bs323 &= -129;
						}
						break;
					case 1:
						if(v323) {
							bs323 |= 64;
						} else {
							bs323 &= -65;
						}
						break;
					case 2:
						if(v323) {
							bs323 |= 32;
						} else {
							bs323 &= -33;
						}
						break;
					case 3:
						if(v323) {
							bs323 |= 16;
						} else {
							bs323 &= -17;
						}
						break;
					case 4:
						if(v323) {
							bs323 |= 8;
						} else {
							bs323 &= -9;
						}
						break;
					case 5:
						if(v323) {
							bs323 |= 4;
						} else {
							bs323 &= -5;
						}
						break;
					case 6:
						if(v323) {
							bs323 |= 2;
						} else {
							bs323 &= -3;
						}
						break;
					case 7:
						if(v323) {
							bs323 |= 1;
						} else {
							bs323 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs323;
				var this325 = 0;
				var bs324 = this325;
				var l324 = "**  *".length;
				var _g1325 = 0;
				var _g425 = l324;
				while(_g1325 < _g425) {
					var i325 = _g1325++;
					var no324 = "**  *".charCodeAt(i325);
					if(no324 == null) {
						break;
					}
					var v324;
					switch(no324) {
					case 32:
						v324 = false;
						break;
					case 42:
						v324 = true;
						break;
					case 48:
						v324 = false;
						break;
					case 49:
						v324 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i325)));
					}
					switch(i325 - (l324 - 8)) {
					case 0:
						if(v324) {
							bs324 |= 128;
						} else {
							bs324 &= -129;
						}
						break;
					case 1:
						if(v324) {
							bs324 |= 64;
						} else {
							bs324 &= -65;
						}
						break;
					case 2:
						if(v324) {
							bs324 |= 32;
						} else {
							bs324 &= -33;
						}
						break;
					case 3:
						if(v324) {
							bs324 |= 16;
						} else {
							bs324 &= -17;
						}
						break;
					case 4:
						if(v324) {
							bs324 |= 8;
						} else {
							bs324 &= -9;
						}
						break;
					case 5:
						if(v324) {
							bs324 |= 4;
						} else {
							bs324 &= -5;
						}
						break;
					case 6:
						if(v324) {
							bs324 |= 2;
						} else {
							bs324 &= -3;
						}
						break;
					case 7:
						if(v324) {
							bs324 |= 1;
						} else {
							bs324 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs324;
				var this326 = 0;
				var bs325 = this326;
				var l325 = "* * *".length;
				var _g1326 = 0;
				var _g426 = l325;
				while(_g1326 < _g426) {
					var i326 = _g1326++;
					var no325 = "* * *".charCodeAt(i326);
					if(no325 == null) {
						break;
					}
					var v325;
					switch(no325) {
					case 32:
						v325 = false;
						break;
					case 42:
						v325 = true;
						break;
					case 48:
						v325 = false;
						break;
					case 49:
						v325 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i326)));
					}
					switch(i326 - (l325 - 8)) {
					case 0:
						if(v325) {
							bs325 |= 128;
						} else {
							bs325 &= -129;
						}
						break;
					case 1:
						if(v325) {
							bs325 |= 64;
						} else {
							bs325 &= -65;
						}
						break;
					case 2:
						if(v325) {
							bs325 |= 32;
						} else {
							bs325 &= -33;
						}
						break;
					case 3:
						if(v325) {
							bs325 |= 16;
						} else {
							bs325 &= -17;
						}
						break;
					case 4:
						if(v325) {
							bs325 |= 8;
						} else {
							bs325 &= -9;
						}
						break;
					case 5:
						if(v325) {
							bs325 |= 4;
						} else {
							bs325 &= -5;
						}
						break;
					case 6:
						if(v325) {
							bs325 |= 2;
						} else {
							bs325 &= -3;
						}
						break;
					case 7:
						if(v325) {
							bs325 |= 1;
						} else {
							bs325 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs325;
				var this327 = 0;
				var bs326 = this327;
				var l326 = "*  **".length;
				var _g1327 = 0;
				var _g427 = l326;
				while(_g1327 < _g427) {
					var i327 = _g1327++;
					var no326 = "*  **".charCodeAt(i327);
					if(no326 == null) {
						break;
					}
					var v326;
					switch(no326) {
					case 32:
						v326 = false;
						break;
					case 42:
						v326 = true;
						break;
					case 48:
						v326 = false;
						break;
					case 49:
						v326 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  **".charCodeAt(i327)));
					}
					switch(i327 - (l326 - 8)) {
					case 0:
						if(v326) {
							bs326 |= 128;
						} else {
							bs326 &= -129;
						}
						break;
					case 1:
						if(v326) {
							bs326 |= 64;
						} else {
							bs326 &= -65;
						}
						break;
					case 2:
						if(v326) {
							bs326 |= 32;
						} else {
							bs326 &= -33;
						}
						break;
					case 3:
						if(v326) {
							bs326 |= 16;
						} else {
							bs326 &= -17;
						}
						break;
					case 4:
						if(v326) {
							bs326 |= 8;
						} else {
							bs326 &= -9;
						}
						break;
					case 5:
						if(v326) {
							bs326 |= 4;
						} else {
							bs326 &= -5;
						}
						break;
					case 6:
						if(v326) {
							bs326 |= 2;
						} else {
							bs326 &= -3;
						}
						break;
					case 7:
						if(v326) {
							bs326 |= 1;
						} else {
							bs326 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs326;
				var this328 = 0;
				var bs327 = this328;
				var l327 = "*   *".length;
				var _g1328 = 0;
				var _g428 = l327;
				while(_g1328 < _g428) {
					var i328 = _g1328++;
					var no327 = "*   *".charCodeAt(i328);
					if(no327 == null) {
						break;
					}
					var v327;
					switch(no327) {
					case 32:
						v327 = false;
						break;
					case 42:
						v327 = true;
						break;
					case 48:
						v327 = false;
						break;
					case 49:
						v327 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i328)));
					}
					switch(i328 - (l327 - 8)) {
					case 0:
						if(v327) {
							bs327 |= 128;
						} else {
							bs327 &= -129;
						}
						break;
					case 1:
						if(v327) {
							bs327 |= 64;
						} else {
							bs327 &= -65;
						}
						break;
					case 2:
						if(v327) {
							bs327 |= 32;
						} else {
							bs327 &= -33;
						}
						break;
					case 3:
						if(v327) {
							bs327 |= 16;
						} else {
							bs327 &= -17;
						}
						break;
					case 4:
						if(v327) {
							bs327 |= 8;
						} else {
							bs327 &= -9;
						}
						break;
					case 5:
						if(v327) {
							bs327 |= 4;
						} else {
							bs327 &= -5;
						}
						break;
					case 6:
						if(v327) {
							bs327 |= 2;
						} else {
							bs327 &= -3;
						}
						break;
					case 7:
						if(v327) {
							bs327 |= 1;
						} else {
							bs327 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs327;
				var this329 = 0;
				var bs328 = this329;
				var l328 = "*   *".length;
				var _g1329 = 0;
				var _g429 = l328;
				while(_g1329 < _g429) {
					var i329 = _g1329++;
					var no328 = "*   *".charCodeAt(i329);
					if(no328 == null) {
						break;
					}
					var v328;
					switch(no328) {
					case 32:
						v328 = false;
						break;
					case 42:
						v328 = true;
						break;
					case 48:
						v328 = false;
						break;
					case 49:
						v328 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i329)));
					}
					switch(i329 - (l328 - 8)) {
					case 0:
						if(v328) {
							bs328 |= 128;
						} else {
							bs328 &= -129;
						}
						break;
					case 1:
						if(v328) {
							bs328 |= 64;
						} else {
							bs328 &= -65;
						}
						break;
					case 2:
						if(v328) {
							bs328 |= 32;
						} else {
							bs328 &= -33;
						}
						break;
					case 3:
						if(v328) {
							bs328 |= 16;
						} else {
							bs328 &= -17;
						}
						break;
					case 4:
						if(v328) {
							bs328 |= 8;
						} else {
							bs328 &= -9;
						}
						break;
					case 5:
						if(v328) {
							bs328 |= 4;
						} else {
							bs328 &= -5;
						}
						break;
					case 6:
						if(v328) {
							bs328 |= 2;
						} else {
							bs328 &= -3;
						}
						break;
					case 7:
						if(v328) {
							bs328 |= 1;
						} else {
							bs328 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs328;
				break;
			case 79:
				var this330 = 0;
				var bs329 = this330;
				var l329 = " *** ".length;
				var _g1330 = 0;
				var _g430 = l329;
				while(_g1330 < _g430) {
					var i330 = _g1330++;
					var no329 = " *** ".charCodeAt(i330);
					if(no329 == null) {
						break;
					}
					var v329;
					switch(no329) {
					case 32:
						v329 = false;
						break;
					case 42:
						v329 = true;
						break;
					case 48:
						v329 = false;
						break;
					case 49:
						v329 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i330)));
					}
					switch(i330 - (l329 - 8)) {
					case 0:
						if(v329) {
							bs329 |= 128;
						} else {
							bs329 &= -129;
						}
						break;
					case 1:
						if(v329) {
							bs329 |= 64;
						} else {
							bs329 &= -65;
						}
						break;
					case 2:
						if(v329) {
							bs329 |= 32;
						} else {
							bs329 &= -33;
						}
						break;
					case 3:
						if(v329) {
							bs329 |= 16;
						} else {
							bs329 &= -17;
						}
						break;
					case 4:
						if(v329) {
							bs329 |= 8;
						} else {
							bs329 &= -9;
						}
						break;
					case 5:
						if(v329) {
							bs329 |= 4;
						} else {
							bs329 &= -5;
						}
						break;
					case 6:
						if(v329) {
							bs329 |= 2;
						} else {
							bs329 &= -3;
						}
						break;
					case 7:
						if(v329) {
							bs329 |= 1;
						} else {
							bs329 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs329;
				var this331 = 0;
				var bs330 = this331;
				var l330 = "*   *".length;
				var _g1331 = 0;
				var _g431 = l330;
				while(_g1331 < _g431) {
					var i331 = _g1331++;
					var no330 = "*   *".charCodeAt(i331);
					if(no330 == null) {
						break;
					}
					var v330;
					switch(no330) {
					case 32:
						v330 = false;
						break;
					case 42:
						v330 = true;
						break;
					case 48:
						v330 = false;
						break;
					case 49:
						v330 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i331)));
					}
					switch(i331 - (l330 - 8)) {
					case 0:
						if(v330) {
							bs330 |= 128;
						} else {
							bs330 &= -129;
						}
						break;
					case 1:
						if(v330) {
							bs330 |= 64;
						} else {
							bs330 &= -65;
						}
						break;
					case 2:
						if(v330) {
							bs330 |= 32;
						} else {
							bs330 &= -33;
						}
						break;
					case 3:
						if(v330) {
							bs330 |= 16;
						} else {
							bs330 &= -17;
						}
						break;
					case 4:
						if(v330) {
							bs330 |= 8;
						} else {
							bs330 &= -9;
						}
						break;
					case 5:
						if(v330) {
							bs330 |= 4;
						} else {
							bs330 &= -5;
						}
						break;
					case 6:
						if(v330) {
							bs330 |= 2;
						} else {
							bs330 &= -3;
						}
						break;
					case 7:
						if(v330) {
							bs330 |= 1;
						} else {
							bs330 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs330;
				var this332 = 0;
				var bs331 = this332;
				var l331 = "*   *".length;
				var _g1332 = 0;
				var _g432 = l331;
				while(_g1332 < _g432) {
					var i332 = _g1332++;
					var no331 = "*   *".charCodeAt(i332);
					if(no331 == null) {
						break;
					}
					var v331;
					switch(no331) {
					case 32:
						v331 = false;
						break;
					case 42:
						v331 = true;
						break;
					case 48:
						v331 = false;
						break;
					case 49:
						v331 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i332)));
					}
					switch(i332 - (l331 - 8)) {
					case 0:
						if(v331) {
							bs331 |= 128;
						} else {
							bs331 &= -129;
						}
						break;
					case 1:
						if(v331) {
							bs331 |= 64;
						} else {
							bs331 &= -65;
						}
						break;
					case 2:
						if(v331) {
							bs331 |= 32;
						} else {
							bs331 &= -33;
						}
						break;
					case 3:
						if(v331) {
							bs331 |= 16;
						} else {
							bs331 &= -17;
						}
						break;
					case 4:
						if(v331) {
							bs331 |= 8;
						} else {
							bs331 &= -9;
						}
						break;
					case 5:
						if(v331) {
							bs331 |= 4;
						} else {
							bs331 &= -5;
						}
						break;
					case 6:
						if(v331) {
							bs331 |= 2;
						} else {
							bs331 &= -3;
						}
						break;
					case 7:
						if(v331) {
							bs331 |= 1;
						} else {
							bs331 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs331;
				var this333 = 0;
				var bs332 = this333;
				var l332 = "*   *".length;
				var _g1333 = 0;
				var _g433 = l332;
				while(_g1333 < _g433) {
					var i333 = _g1333++;
					var no332 = "*   *".charCodeAt(i333);
					if(no332 == null) {
						break;
					}
					var v332;
					switch(no332) {
					case 32:
						v332 = false;
						break;
					case 42:
						v332 = true;
						break;
					case 48:
						v332 = false;
						break;
					case 49:
						v332 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i333)));
					}
					switch(i333 - (l332 - 8)) {
					case 0:
						if(v332) {
							bs332 |= 128;
						} else {
							bs332 &= -129;
						}
						break;
					case 1:
						if(v332) {
							bs332 |= 64;
						} else {
							bs332 &= -65;
						}
						break;
					case 2:
						if(v332) {
							bs332 |= 32;
						} else {
							bs332 &= -33;
						}
						break;
					case 3:
						if(v332) {
							bs332 |= 16;
						} else {
							bs332 &= -17;
						}
						break;
					case 4:
						if(v332) {
							bs332 |= 8;
						} else {
							bs332 &= -9;
						}
						break;
					case 5:
						if(v332) {
							bs332 |= 4;
						} else {
							bs332 &= -5;
						}
						break;
					case 6:
						if(v332) {
							bs332 |= 2;
						} else {
							bs332 &= -3;
						}
						break;
					case 7:
						if(v332) {
							bs332 |= 1;
						} else {
							bs332 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs332;
				var this334 = 0;
				var bs333 = this334;
				var l333 = "*   *".length;
				var _g1334 = 0;
				var _g434 = l333;
				while(_g1334 < _g434) {
					var i334 = _g1334++;
					var no333 = "*   *".charCodeAt(i334);
					if(no333 == null) {
						break;
					}
					var v333;
					switch(no333) {
					case 32:
						v333 = false;
						break;
					case 42:
						v333 = true;
						break;
					case 48:
						v333 = false;
						break;
					case 49:
						v333 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i334)));
					}
					switch(i334 - (l333 - 8)) {
					case 0:
						if(v333) {
							bs333 |= 128;
						} else {
							bs333 &= -129;
						}
						break;
					case 1:
						if(v333) {
							bs333 |= 64;
						} else {
							bs333 &= -65;
						}
						break;
					case 2:
						if(v333) {
							bs333 |= 32;
						} else {
							bs333 &= -33;
						}
						break;
					case 3:
						if(v333) {
							bs333 |= 16;
						} else {
							bs333 &= -17;
						}
						break;
					case 4:
						if(v333) {
							bs333 |= 8;
						} else {
							bs333 &= -9;
						}
						break;
					case 5:
						if(v333) {
							bs333 |= 4;
						} else {
							bs333 &= -5;
						}
						break;
					case 6:
						if(v333) {
							bs333 |= 2;
						} else {
							bs333 &= -3;
						}
						break;
					case 7:
						if(v333) {
							bs333 |= 1;
						} else {
							bs333 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs333;
				var this335 = 0;
				var bs334 = this335;
				var l334 = "*   *".length;
				var _g1335 = 0;
				var _g435 = l334;
				while(_g1335 < _g435) {
					var i335 = _g1335++;
					var no334 = "*   *".charCodeAt(i335);
					if(no334 == null) {
						break;
					}
					var v334;
					switch(no334) {
					case 32:
						v334 = false;
						break;
					case 42:
						v334 = true;
						break;
					case 48:
						v334 = false;
						break;
					case 49:
						v334 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i335)));
					}
					switch(i335 - (l334 - 8)) {
					case 0:
						if(v334) {
							bs334 |= 128;
						} else {
							bs334 &= -129;
						}
						break;
					case 1:
						if(v334) {
							bs334 |= 64;
						} else {
							bs334 &= -65;
						}
						break;
					case 2:
						if(v334) {
							bs334 |= 32;
						} else {
							bs334 &= -33;
						}
						break;
					case 3:
						if(v334) {
							bs334 |= 16;
						} else {
							bs334 &= -17;
						}
						break;
					case 4:
						if(v334) {
							bs334 |= 8;
						} else {
							bs334 &= -9;
						}
						break;
					case 5:
						if(v334) {
							bs334 |= 4;
						} else {
							bs334 &= -5;
						}
						break;
					case 6:
						if(v334) {
							bs334 |= 2;
						} else {
							bs334 &= -3;
						}
						break;
					case 7:
						if(v334) {
							bs334 |= 1;
						} else {
							bs334 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs334;
				var this336 = 0;
				var bs335 = this336;
				var l335 = " *** ".length;
				var _g1336 = 0;
				var _g436 = l335;
				while(_g1336 < _g436) {
					var i336 = _g1336++;
					var no335 = " *** ".charCodeAt(i336);
					if(no335 == null) {
						break;
					}
					var v335;
					switch(no335) {
					case 32:
						v335 = false;
						break;
					case 42:
						v335 = true;
						break;
					case 48:
						v335 = false;
						break;
					case 49:
						v335 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i336)));
					}
					switch(i336 - (l335 - 8)) {
					case 0:
						if(v335) {
							bs335 |= 128;
						} else {
							bs335 &= -129;
						}
						break;
					case 1:
						if(v335) {
							bs335 |= 64;
						} else {
							bs335 &= -65;
						}
						break;
					case 2:
						if(v335) {
							bs335 |= 32;
						} else {
							bs335 &= -33;
						}
						break;
					case 3:
						if(v335) {
							bs335 |= 16;
						} else {
							bs335 &= -17;
						}
						break;
					case 4:
						if(v335) {
							bs335 |= 8;
						} else {
							bs335 &= -9;
						}
						break;
					case 5:
						if(v335) {
							bs335 |= 4;
						} else {
							bs335 &= -5;
						}
						break;
					case 6:
						if(v335) {
							bs335 |= 2;
						} else {
							bs335 &= -3;
						}
						break;
					case 7:
						if(v335) {
							bs335 |= 1;
						} else {
							bs335 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs335;
				break;
			case 80:
				var this337 = 0;
				var bs336 = this337;
				var l336 = "**** ".length;
				var _g1337 = 0;
				var _g437 = l336;
				while(_g1337 < _g437) {
					var i337 = _g1337++;
					var no336 = "**** ".charCodeAt(i337);
					if(no336 == null) {
						break;
					}
					var v336;
					switch(no336) {
					case 32:
						v336 = false;
						break;
					case 42:
						v336 = true;
						break;
					case 48:
						v336 = false;
						break;
					case 49:
						v336 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i337)));
					}
					switch(i337 - (l336 - 8)) {
					case 0:
						if(v336) {
							bs336 |= 128;
						} else {
							bs336 &= -129;
						}
						break;
					case 1:
						if(v336) {
							bs336 |= 64;
						} else {
							bs336 &= -65;
						}
						break;
					case 2:
						if(v336) {
							bs336 |= 32;
						} else {
							bs336 &= -33;
						}
						break;
					case 3:
						if(v336) {
							bs336 |= 16;
						} else {
							bs336 &= -17;
						}
						break;
					case 4:
						if(v336) {
							bs336 |= 8;
						} else {
							bs336 &= -9;
						}
						break;
					case 5:
						if(v336) {
							bs336 |= 4;
						} else {
							bs336 &= -5;
						}
						break;
					case 6:
						if(v336) {
							bs336 |= 2;
						} else {
							bs336 &= -3;
						}
						break;
					case 7:
						if(v336) {
							bs336 |= 1;
						} else {
							bs336 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs336;
				var this338 = 0;
				var bs337 = this338;
				var l337 = "*   *".length;
				var _g1338 = 0;
				var _g438 = l337;
				while(_g1338 < _g438) {
					var i338 = _g1338++;
					var no337 = "*   *".charCodeAt(i338);
					if(no337 == null) {
						break;
					}
					var v337;
					switch(no337) {
					case 32:
						v337 = false;
						break;
					case 42:
						v337 = true;
						break;
					case 48:
						v337 = false;
						break;
					case 49:
						v337 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i338)));
					}
					switch(i338 - (l337 - 8)) {
					case 0:
						if(v337) {
							bs337 |= 128;
						} else {
							bs337 &= -129;
						}
						break;
					case 1:
						if(v337) {
							bs337 |= 64;
						} else {
							bs337 &= -65;
						}
						break;
					case 2:
						if(v337) {
							bs337 |= 32;
						} else {
							bs337 &= -33;
						}
						break;
					case 3:
						if(v337) {
							bs337 |= 16;
						} else {
							bs337 &= -17;
						}
						break;
					case 4:
						if(v337) {
							bs337 |= 8;
						} else {
							bs337 &= -9;
						}
						break;
					case 5:
						if(v337) {
							bs337 |= 4;
						} else {
							bs337 &= -5;
						}
						break;
					case 6:
						if(v337) {
							bs337 |= 2;
						} else {
							bs337 &= -3;
						}
						break;
					case 7:
						if(v337) {
							bs337 |= 1;
						} else {
							bs337 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs337;
				var this339 = 0;
				var bs338 = this339;
				var l338 = "*   *".length;
				var _g1339 = 0;
				var _g439 = l338;
				while(_g1339 < _g439) {
					var i339 = _g1339++;
					var no338 = "*   *".charCodeAt(i339);
					if(no338 == null) {
						break;
					}
					var v338;
					switch(no338) {
					case 32:
						v338 = false;
						break;
					case 42:
						v338 = true;
						break;
					case 48:
						v338 = false;
						break;
					case 49:
						v338 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i339)));
					}
					switch(i339 - (l338 - 8)) {
					case 0:
						if(v338) {
							bs338 |= 128;
						} else {
							bs338 &= -129;
						}
						break;
					case 1:
						if(v338) {
							bs338 |= 64;
						} else {
							bs338 &= -65;
						}
						break;
					case 2:
						if(v338) {
							bs338 |= 32;
						} else {
							bs338 &= -33;
						}
						break;
					case 3:
						if(v338) {
							bs338 |= 16;
						} else {
							bs338 &= -17;
						}
						break;
					case 4:
						if(v338) {
							bs338 |= 8;
						} else {
							bs338 &= -9;
						}
						break;
					case 5:
						if(v338) {
							bs338 |= 4;
						} else {
							bs338 &= -5;
						}
						break;
					case 6:
						if(v338) {
							bs338 |= 2;
						} else {
							bs338 &= -3;
						}
						break;
					case 7:
						if(v338) {
							bs338 |= 1;
						} else {
							bs338 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs338;
				var this340 = 0;
				var bs339 = this340;
				var l339 = "**** ".length;
				var _g1340 = 0;
				var _g440 = l339;
				while(_g1340 < _g440) {
					var i340 = _g1340++;
					var no339 = "**** ".charCodeAt(i340);
					if(no339 == null) {
						break;
					}
					var v339;
					switch(no339) {
					case 32:
						v339 = false;
						break;
					case 42:
						v339 = true;
						break;
					case 48:
						v339 = false;
						break;
					case 49:
						v339 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i340)));
					}
					switch(i340 - (l339 - 8)) {
					case 0:
						if(v339) {
							bs339 |= 128;
						} else {
							bs339 &= -129;
						}
						break;
					case 1:
						if(v339) {
							bs339 |= 64;
						} else {
							bs339 &= -65;
						}
						break;
					case 2:
						if(v339) {
							bs339 |= 32;
						} else {
							bs339 &= -33;
						}
						break;
					case 3:
						if(v339) {
							bs339 |= 16;
						} else {
							bs339 &= -17;
						}
						break;
					case 4:
						if(v339) {
							bs339 |= 8;
						} else {
							bs339 &= -9;
						}
						break;
					case 5:
						if(v339) {
							bs339 |= 4;
						} else {
							bs339 &= -5;
						}
						break;
					case 6:
						if(v339) {
							bs339 |= 2;
						} else {
							bs339 &= -3;
						}
						break;
					case 7:
						if(v339) {
							bs339 |= 1;
						} else {
							bs339 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs339;
				var this341 = 0;
				var bs340 = this341;
				var l340 = "*    ".length;
				var _g1341 = 0;
				var _g441 = l340;
				while(_g1341 < _g441) {
					var i341 = _g1341++;
					var no340 = "*    ".charCodeAt(i341);
					if(no340 == null) {
						break;
					}
					var v340;
					switch(no340) {
					case 32:
						v340 = false;
						break;
					case 42:
						v340 = true;
						break;
					case 48:
						v340 = false;
						break;
					case 49:
						v340 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i341)));
					}
					switch(i341 - (l340 - 8)) {
					case 0:
						if(v340) {
							bs340 |= 128;
						} else {
							bs340 &= -129;
						}
						break;
					case 1:
						if(v340) {
							bs340 |= 64;
						} else {
							bs340 &= -65;
						}
						break;
					case 2:
						if(v340) {
							bs340 |= 32;
						} else {
							bs340 &= -33;
						}
						break;
					case 3:
						if(v340) {
							bs340 |= 16;
						} else {
							bs340 &= -17;
						}
						break;
					case 4:
						if(v340) {
							bs340 |= 8;
						} else {
							bs340 &= -9;
						}
						break;
					case 5:
						if(v340) {
							bs340 |= 4;
						} else {
							bs340 &= -5;
						}
						break;
					case 6:
						if(v340) {
							bs340 |= 2;
						} else {
							bs340 &= -3;
						}
						break;
					case 7:
						if(v340) {
							bs340 |= 1;
						} else {
							bs340 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs340;
				var this342 = 0;
				var bs341 = this342;
				var l341 = "*    ".length;
				var _g1342 = 0;
				var _g442 = l341;
				while(_g1342 < _g442) {
					var i342 = _g1342++;
					var no341 = "*    ".charCodeAt(i342);
					if(no341 == null) {
						break;
					}
					var v341;
					switch(no341) {
					case 32:
						v341 = false;
						break;
					case 42:
						v341 = true;
						break;
					case 48:
						v341 = false;
						break;
					case 49:
						v341 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i342)));
					}
					switch(i342 - (l341 - 8)) {
					case 0:
						if(v341) {
							bs341 |= 128;
						} else {
							bs341 &= -129;
						}
						break;
					case 1:
						if(v341) {
							bs341 |= 64;
						} else {
							bs341 &= -65;
						}
						break;
					case 2:
						if(v341) {
							bs341 |= 32;
						} else {
							bs341 &= -33;
						}
						break;
					case 3:
						if(v341) {
							bs341 |= 16;
						} else {
							bs341 &= -17;
						}
						break;
					case 4:
						if(v341) {
							bs341 |= 8;
						} else {
							bs341 &= -9;
						}
						break;
					case 5:
						if(v341) {
							bs341 |= 4;
						} else {
							bs341 &= -5;
						}
						break;
					case 6:
						if(v341) {
							bs341 |= 2;
						} else {
							bs341 &= -3;
						}
						break;
					case 7:
						if(v341) {
							bs341 |= 1;
						} else {
							bs341 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs341;
				var this343 = 0;
				var bs342 = this343;
				var l342 = "*    ".length;
				var _g1343 = 0;
				var _g443 = l342;
				while(_g1343 < _g443) {
					var i343 = _g1343++;
					var no342 = "*    ".charCodeAt(i343);
					if(no342 == null) {
						break;
					}
					var v342;
					switch(no342) {
					case 32:
						v342 = false;
						break;
					case 42:
						v342 = true;
						break;
					case 48:
						v342 = false;
						break;
					case 49:
						v342 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i343)));
					}
					switch(i343 - (l342 - 8)) {
					case 0:
						if(v342) {
							bs342 |= 128;
						} else {
							bs342 &= -129;
						}
						break;
					case 1:
						if(v342) {
							bs342 |= 64;
						} else {
							bs342 &= -65;
						}
						break;
					case 2:
						if(v342) {
							bs342 |= 32;
						} else {
							bs342 &= -33;
						}
						break;
					case 3:
						if(v342) {
							bs342 |= 16;
						} else {
							bs342 &= -17;
						}
						break;
					case 4:
						if(v342) {
							bs342 |= 8;
						} else {
							bs342 &= -9;
						}
						break;
					case 5:
						if(v342) {
							bs342 |= 4;
						} else {
							bs342 &= -5;
						}
						break;
					case 6:
						if(v342) {
							bs342 |= 2;
						} else {
							bs342 &= -3;
						}
						break;
					case 7:
						if(v342) {
							bs342 |= 1;
						} else {
							bs342 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs342;
				break;
			case 81:
				var this344 = 0;
				var bs343 = this344;
				var l343 = " *** ".length;
				var _g1344 = 0;
				var _g444 = l343;
				while(_g1344 < _g444) {
					var i344 = _g1344++;
					var no343 = " *** ".charCodeAt(i344);
					if(no343 == null) {
						break;
					}
					var v343;
					switch(no343) {
					case 32:
						v343 = false;
						break;
					case 42:
						v343 = true;
						break;
					case 48:
						v343 = false;
						break;
					case 49:
						v343 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i344)));
					}
					switch(i344 - (l343 - 8)) {
					case 0:
						if(v343) {
							bs343 |= 128;
						} else {
							bs343 &= -129;
						}
						break;
					case 1:
						if(v343) {
							bs343 |= 64;
						} else {
							bs343 &= -65;
						}
						break;
					case 2:
						if(v343) {
							bs343 |= 32;
						} else {
							bs343 &= -33;
						}
						break;
					case 3:
						if(v343) {
							bs343 |= 16;
						} else {
							bs343 &= -17;
						}
						break;
					case 4:
						if(v343) {
							bs343 |= 8;
						} else {
							bs343 &= -9;
						}
						break;
					case 5:
						if(v343) {
							bs343 |= 4;
						} else {
							bs343 &= -5;
						}
						break;
					case 6:
						if(v343) {
							bs343 |= 2;
						} else {
							bs343 &= -3;
						}
						break;
					case 7:
						if(v343) {
							bs343 |= 1;
						} else {
							bs343 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs343;
				var this345 = 0;
				var bs344 = this345;
				var l344 = "*   *".length;
				var _g1345 = 0;
				var _g445 = l344;
				while(_g1345 < _g445) {
					var i345 = _g1345++;
					var no344 = "*   *".charCodeAt(i345);
					if(no344 == null) {
						break;
					}
					var v344;
					switch(no344) {
					case 32:
						v344 = false;
						break;
					case 42:
						v344 = true;
						break;
					case 48:
						v344 = false;
						break;
					case 49:
						v344 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i345)));
					}
					switch(i345 - (l344 - 8)) {
					case 0:
						if(v344) {
							bs344 |= 128;
						} else {
							bs344 &= -129;
						}
						break;
					case 1:
						if(v344) {
							bs344 |= 64;
						} else {
							bs344 &= -65;
						}
						break;
					case 2:
						if(v344) {
							bs344 |= 32;
						} else {
							bs344 &= -33;
						}
						break;
					case 3:
						if(v344) {
							bs344 |= 16;
						} else {
							bs344 &= -17;
						}
						break;
					case 4:
						if(v344) {
							bs344 |= 8;
						} else {
							bs344 &= -9;
						}
						break;
					case 5:
						if(v344) {
							bs344 |= 4;
						} else {
							bs344 &= -5;
						}
						break;
					case 6:
						if(v344) {
							bs344 |= 2;
						} else {
							bs344 &= -3;
						}
						break;
					case 7:
						if(v344) {
							bs344 |= 1;
						} else {
							bs344 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs344;
				var this346 = 0;
				var bs345 = this346;
				var l345 = "*   *".length;
				var _g1346 = 0;
				var _g446 = l345;
				while(_g1346 < _g446) {
					var i346 = _g1346++;
					var no345 = "*   *".charCodeAt(i346);
					if(no345 == null) {
						break;
					}
					var v345;
					switch(no345) {
					case 32:
						v345 = false;
						break;
					case 42:
						v345 = true;
						break;
					case 48:
						v345 = false;
						break;
					case 49:
						v345 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i346)));
					}
					switch(i346 - (l345 - 8)) {
					case 0:
						if(v345) {
							bs345 |= 128;
						} else {
							bs345 &= -129;
						}
						break;
					case 1:
						if(v345) {
							bs345 |= 64;
						} else {
							bs345 &= -65;
						}
						break;
					case 2:
						if(v345) {
							bs345 |= 32;
						} else {
							bs345 &= -33;
						}
						break;
					case 3:
						if(v345) {
							bs345 |= 16;
						} else {
							bs345 &= -17;
						}
						break;
					case 4:
						if(v345) {
							bs345 |= 8;
						} else {
							bs345 &= -9;
						}
						break;
					case 5:
						if(v345) {
							bs345 |= 4;
						} else {
							bs345 &= -5;
						}
						break;
					case 6:
						if(v345) {
							bs345 |= 2;
						} else {
							bs345 &= -3;
						}
						break;
					case 7:
						if(v345) {
							bs345 |= 1;
						} else {
							bs345 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs345;
				var this347 = 0;
				var bs346 = this347;
				var l346 = "*   *".length;
				var _g1347 = 0;
				var _g447 = l346;
				while(_g1347 < _g447) {
					var i347 = _g1347++;
					var no346 = "*   *".charCodeAt(i347);
					if(no346 == null) {
						break;
					}
					var v346;
					switch(no346) {
					case 32:
						v346 = false;
						break;
					case 42:
						v346 = true;
						break;
					case 48:
						v346 = false;
						break;
					case 49:
						v346 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i347)));
					}
					switch(i347 - (l346 - 8)) {
					case 0:
						if(v346) {
							bs346 |= 128;
						} else {
							bs346 &= -129;
						}
						break;
					case 1:
						if(v346) {
							bs346 |= 64;
						} else {
							bs346 &= -65;
						}
						break;
					case 2:
						if(v346) {
							bs346 |= 32;
						} else {
							bs346 &= -33;
						}
						break;
					case 3:
						if(v346) {
							bs346 |= 16;
						} else {
							bs346 &= -17;
						}
						break;
					case 4:
						if(v346) {
							bs346 |= 8;
						} else {
							bs346 &= -9;
						}
						break;
					case 5:
						if(v346) {
							bs346 |= 4;
						} else {
							bs346 &= -5;
						}
						break;
					case 6:
						if(v346) {
							bs346 |= 2;
						} else {
							bs346 &= -3;
						}
						break;
					case 7:
						if(v346) {
							bs346 |= 1;
						} else {
							bs346 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs346;
				var this348 = 0;
				var bs347 = this348;
				var l347 = "* * *".length;
				var _g1348 = 0;
				var _g448 = l347;
				while(_g1348 < _g448) {
					var i348 = _g1348++;
					var no347 = "* * *".charCodeAt(i348);
					if(no347 == null) {
						break;
					}
					var v347;
					switch(no347) {
					case 32:
						v347 = false;
						break;
					case 42:
						v347 = true;
						break;
					case 48:
						v347 = false;
						break;
					case 49:
						v347 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i348)));
					}
					switch(i348 - (l347 - 8)) {
					case 0:
						if(v347) {
							bs347 |= 128;
						} else {
							bs347 &= -129;
						}
						break;
					case 1:
						if(v347) {
							bs347 |= 64;
						} else {
							bs347 &= -65;
						}
						break;
					case 2:
						if(v347) {
							bs347 |= 32;
						} else {
							bs347 &= -33;
						}
						break;
					case 3:
						if(v347) {
							bs347 |= 16;
						} else {
							bs347 &= -17;
						}
						break;
					case 4:
						if(v347) {
							bs347 |= 8;
						} else {
							bs347 &= -9;
						}
						break;
					case 5:
						if(v347) {
							bs347 |= 4;
						} else {
							bs347 &= -5;
						}
						break;
					case 6:
						if(v347) {
							bs347 |= 2;
						} else {
							bs347 &= -3;
						}
						break;
					case 7:
						if(v347) {
							bs347 |= 1;
						} else {
							bs347 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs347;
				var this349 = 0;
				var bs348 = this349;
				var l348 = "*  * ".length;
				var _g1349 = 0;
				var _g449 = l348;
				while(_g1349 < _g449) {
					var i349 = _g1349++;
					var no348 = "*  * ".charCodeAt(i349);
					if(no348 == null) {
						break;
					}
					var v348;
					switch(no348) {
					case 32:
						v348 = false;
						break;
					case 42:
						v348 = true;
						break;
					case 48:
						v348 = false;
						break;
					case 49:
						v348 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i349)));
					}
					switch(i349 - (l348 - 8)) {
					case 0:
						if(v348) {
							bs348 |= 128;
						} else {
							bs348 &= -129;
						}
						break;
					case 1:
						if(v348) {
							bs348 |= 64;
						} else {
							bs348 &= -65;
						}
						break;
					case 2:
						if(v348) {
							bs348 |= 32;
						} else {
							bs348 &= -33;
						}
						break;
					case 3:
						if(v348) {
							bs348 |= 16;
						} else {
							bs348 &= -17;
						}
						break;
					case 4:
						if(v348) {
							bs348 |= 8;
						} else {
							bs348 &= -9;
						}
						break;
					case 5:
						if(v348) {
							bs348 |= 4;
						} else {
							bs348 &= -5;
						}
						break;
					case 6:
						if(v348) {
							bs348 |= 2;
						} else {
							bs348 &= -3;
						}
						break;
					case 7:
						if(v348) {
							bs348 |= 1;
						} else {
							bs348 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs348;
				var this350 = 0;
				var bs349 = this350;
				var l349 = " ** *".length;
				var _g1350 = 0;
				var _g450 = l349;
				while(_g1350 < _g450) {
					var i350 = _g1350++;
					var no349 = " ** *".charCodeAt(i350);
					if(no349 == null) {
						break;
					}
					var v349;
					switch(no349) {
					case 32:
						v349 = false;
						break;
					case 42:
						v349 = true;
						break;
					case 48:
						v349 = false;
						break;
					case 49:
						v349 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i350)));
					}
					switch(i350 - (l349 - 8)) {
					case 0:
						if(v349) {
							bs349 |= 128;
						} else {
							bs349 &= -129;
						}
						break;
					case 1:
						if(v349) {
							bs349 |= 64;
						} else {
							bs349 &= -65;
						}
						break;
					case 2:
						if(v349) {
							bs349 |= 32;
						} else {
							bs349 &= -33;
						}
						break;
					case 3:
						if(v349) {
							bs349 |= 16;
						} else {
							bs349 &= -17;
						}
						break;
					case 4:
						if(v349) {
							bs349 |= 8;
						} else {
							bs349 &= -9;
						}
						break;
					case 5:
						if(v349) {
							bs349 |= 4;
						} else {
							bs349 &= -5;
						}
						break;
					case 6:
						if(v349) {
							bs349 |= 2;
						} else {
							bs349 &= -3;
						}
						break;
					case 7:
						if(v349) {
							bs349 |= 1;
						} else {
							bs349 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs349;
				break;
			case 82:
				var this351 = 0;
				var bs350 = this351;
				var l350 = "**** ".length;
				var _g1351 = 0;
				var _g451 = l350;
				while(_g1351 < _g451) {
					var i351 = _g1351++;
					var no350 = "**** ".charCodeAt(i351);
					if(no350 == null) {
						break;
					}
					var v350;
					switch(no350) {
					case 32:
						v350 = false;
						break;
					case 42:
						v350 = true;
						break;
					case 48:
						v350 = false;
						break;
					case 49:
						v350 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i351)));
					}
					switch(i351 - (l350 - 8)) {
					case 0:
						if(v350) {
							bs350 |= 128;
						} else {
							bs350 &= -129;
						}
						break;
					case 1:
						if(v350) {
							bs350 |= 64;
						} else {
							bs350 &= -65;
						}
						break;
					case 2:
						if(v350) {
							bs350 |= 32;
						} else {
							bs350 &= -33;
						}
						break;
					case 3:
						if(v350) {
							bs350 |= 16;
						} else {
							bs350 &= -17;
						}
						break;
					case 4:
						if(v350) {
							bs350 |= 8;
						} else {
							bs350 &= -9;
						}
						break;
					case 5:
						if(v350) {
							bs350 |= 4;
						} else {
							bs350 &= -5;
						}
						break;
					case 6:
						if(v350) {
							bs350 |= 2;
						} else {
							bs350 &= -3;
						}
						break;
					case 7:
						if(v350) {
							bs350 |= 1;
						} else {
							bs350 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs350;
				var this352 = 0;
				var bs351 = this352;
				var l351 = "*   *".length;
				var _g1352 = 0;
				var _g452 = l351;
				while(_g1352 < _g452) {
					var i352 = _g1352++;
					var no351 = "*   *".charCodeAt(i352);
					if(no351 == null) {
						break;
					}
					var v351;
					switch(no351) {
					case 32:
						v351 = false;
						break;
					case 42:
						v351 = true;
						break;
					case 48:
						v351 = false;
						break;
					case 49:
						v351 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i352)));
					}
					switch(i352 - (l351 - 8)) {
					case 0:
						if(v351) {
							bs351 |= 128;
						} else {
							bs351 &= -129;
						}
						break;
					case 1:
						if(v351) {
							bs351 |= 64;
						} else {
							bs351 &= -65;
						}
						break;
					case 2:
						if(v351) {
							bs351 |= 32;
						} else {
							bs351 &= -33;
						}
						break;
					case 3:
						if(v351) {
							bs351 |= 16;
						} else {
							bs351 &= -17;
						}
						break;
					case 4:
						if(v351) {
							bs351 |= 8;
						} else {
							bs351 &= -9;
						}
						break;
					case 5:
						if(v351) {
							bs351 |= 4;
						} else {
							bs351 &= -5;
						}
						break;
					case 6:
						if(v351) {
							bs351 |= 2;
						} else {
							bs351 &= -3;
						}
						break;
					case 7:
						if(v351) {
							bs351 |= 1;
						} else {
							bs351 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs351;
				var this353 = 0;
				var bs352 = this353;
				var l352 = "*   *".length;
				var _g1353 = 0;
				var _g453 = l352;
				while(_g1353 < _g453) {
					var i353 = _g1353++;
					var no352 = "*   *".charCodeAt(i353);
					if(no352 == null) {
						break;
					}
					var v352;
					switch(no352) {
					case 32:
						v352 = false;
						break;
					case 42:
						v352 = true;
						break;
					case 48:
						v352 = false;
						break;
					case 49:
						v352 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i353)));
					}
					switch(i353 - (l352 - 8)) {
					case 0:
						if(v352) {
							bs352 |= 128;
						} else {
							bs352 &= -129;
						}
						break;
					case 1:
						if(v352) {
							bs352 |= 64;
						} else {
							bs352 &= -65;
						}
						break;
					case 2:
						if(v352) {
							bs352 |= 32;
						} else {
							bs352 &= -33;
						}
						break;
					case 3:
						if(v352) {
							bs352 |= 16;
						} else {
							bs352 &= -17;
						}
						break;
					case 4:
						if(v352) {
							bs352 |= 8;
						} else {
							bs352 &= -9;
						}
						break;
					case 5:
						if(v352) {
							bs352 |= 4;
						} else {
							bs352 &= -5;
						}
						break;
					case 6:
						if(v352) {
							bs352 |= 2;
						} else {
							bs352 &= -3;
						}
						break;
					case 7:
						if(v352) {
							bs352 |= 1;
						} else {
							bs352 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs352;
				var this354 = 0;
				var bs353 = this354;
				var l353 = "**** ".length;
				var _g1354 = 0;
				var _g454 = l353;
				while(_g1354 < _g454) {
					var i354 = _g1354++;
					var no353 = "**** ".charCodeAt(i354);
					if(no353 == null) {
						break;
					}
					var v353;
					switch(no353) {
					case 32:
						v353 = false;
						break;
					case 42:
						v353 = true;
						break;
					case 48:
						v353 = false;
						break;
					case 49:
						v353 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i354)));
					}
					switch(i354 - (l353 - 8)) {
					case 0:
						if(v353) {
							bs353 |= 128;
						} else {
							bs353 &= -129;
						}
						break;
					case 1:
						if(v353) {
							bs353 |= 64;
						} else {
							bs353 &= -65;
						}
						break;
					case 2:
						if(v353) {
							bs353 |= 32;
						} else {
							bs353 &= -33;
						}
						break;
					case 3:
						if(v353) {
							bs353 |= 16;
						} else {
							bs353 &= -17;
						}
						break;
					case 4:
						if(v353) {
							bs353 |= 8;
						} else {
							bs353 &= -9;
						}
						break;
					case 5:
						if(v353) {
							bs353 |= 4;
						} else {
							bs353 &= -5;
						}
						break;
					case 6:
						if(v353) {
							bs353 |= 2;
						} else {
							bs353 &= -3;
						}
						break;
					case 7:
						if(v353) {
							bs353 |= 1;
						} else {
							bs353 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs353;
				var this355 = 0;
				var bs354 = this355;
				var l354 = "* *  ".length;
				var _g1355 = 0;
				var _g455 = l354;
				while(_g1355 < _g455) {
					var i355 = _g1355++;
					var no354 = "* *  ".charCodeAt(i355);
					if(no354 == null) {
						break;
					}
					var v354;
					switch(no354) {
					case 32:
						v354 = false;
						break;
					case 42:
						v354 = true;
						break;
					case 48:
						v354 = false;
						break;
					case 49:
						v354 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i355)));
					}
					switch(i355 - (l354 - 8)) {
					case 0:
						if(v354) {
							bs354 |= 128;
						} else {
							bs354 &= -129;
						}
						break;
					case 1:
						if(v354) {
							bs354 |= 64;
						} else {
							bs354 &= -65;
						}
						break;
					case 2:
						if(v354) {
							bs354 |= 32;
						} else {
							bs354 &= -33;
						}
						break;
					case 3:
						if(v354) {
							bs354 |= 16;
						} else {
							bs354 &= -17;
						}
						break;
					case 4:
						if(v354) {
							bs354 |= 8;
						} else {
							bs354 &= -9;
						}
						break;
					case 5:
						if(v354) {
							bs354 |= 4;
						} else {
							bs354 &= -5;
						}
						break;
					case 6:
						if(v354) {
							bs354 |= 2;
						} else {
							bs354 &= -3;
						}
						break;
					case 7:
						if(v354) {
							bs354 |= 1;
						} else {
							bs354 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs354;
				var this356 = 0;
				var bs355 = this356;
				var l355 = "*  * ".length;
				var _g1356 = 0;
				var _g456 = l355;
				while(_g1356 < _g456) {
					var i356 = _g1356++;
					var no355 = "*  * ".charCodeAt(i356);
					if(no355 == null) {
						break;
					}
					var v355;
					switch(no355) {
					case 32:
						v355 = false;
						break;
					case 42:
						v355 = true;
						break;
					case 48:
						v355 = false;
						break;
					case 49:
						v355 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i356)));
					}
					switch(i356 - (l355 - 8)) {
					case 0:
						if(v355) {
							bs355 |= 128;
						} else {
							bs355 &= -129;
						}
						break;
					case 1:
						if(v355) {
							bs355 |= 64;
						} else {
							bs355 &= -65;
						}
						break;
					case 2:
						if(v355) {
							bs355 |= 32;
						} else {
							bs355 &= -33;
						}
						break;
					case 3:
						if(v355) {
							bs355 |= 16;
						} else {
							bs355 &= -17;
						}
						break;
					case 4:
						if(v355) {
							bs355 |= 8;
						} else {
							bs355 &= -9;
						}
						break;
					case 5:
						if(v355) {
							bs355 |= 4;
						} else {
							bs355 &= -5;
						}
						break;
					case 6:
						if(v355) {
							bs355 |= 2;
						} else {
							bs355 &= -3;
						}
						break;
					case 7:
						if(v355) {
							bs355 |= 1;
						} else {
							bs355 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs355;
				var this357 = 0;
				var bs356 = this357;
				var l356 = "*   *".length;
				var _g1357 = 0;
				var _g457 = l356;
				while(_g1357 < _g457) {
					var i357 = _g1357++;
					var no356 = "*   *".charCodeAt(i357);
					if(no356 == null) {
						break;
					}
					var v356;
					switch(no356) {
					case 32:
						v356 = false;
						break;
					case 42:
						v356 = true;
						break;
					case 48:
						v356 = false;
						break;
					case 49:
						v356 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i357)));
					}
					switch(i357 - (l356 - 8)) {
					case 0:
						if(v356) {
							bs356 |= 128;
						} else {
							bs356 &= -129;
						}
						break;
					case 1:
						if(v356) {
							bs356 |= 64;
						} else {
							bs356 &= -65;
						}
						break;
					case 2:
						if(v356) {
							bs356 |= 32;
						} else {
							bs356 &= -33;
						}
						break;
					case 3:
						if(v356) {
							bs356 |= 16;
						} else {
							bs356 &= -17;
						}
						break;
					case 4:
						if(v356) {
							bs356 |= 8;
						} else {
							bs356 &= -9;
						}
						break;
					case 5:
						if(v356) {
							bs356 |= 4;
						} else {
							bs356 &= -5;
						}
						break;
					case 6:
						if(v356) {
							bs356 |= 2;
						} else {
							bs356 &= -3;
						}
						break;
					case 7:
						if(v356) {
							bs356 |= 1;
						} else {
							bs356 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs356;
				break;
			case 83:
				var this358 = 0;
				var bs357 = this358;
				var l357 = " ****".length;
				var _g1358 = 0;
				var _g458 = l357;
				while(_g1358 < _g458) {
					var i358 = _g1358++;
					var no357 = " ****".charCodeAt(i358);
					if(no357 == null) {
						break;
					}
					var v357;
					switch(no357) {
					case 32:
						v357 = false;
						break;
					case 42:
						v357 = true;
						break;
					case 48:
						v357 = false;
						break;
					case 49:
						v357 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i358)));
					}
					switch(i358 - (l357 - 8)) {
					case 0:
						if(v357) {
							bs357 |= 128;
						} else {
							bs357 &= -129;
						}
						break;
					case 1:
						if(v357) {
							bs357 |= 64;
						} else {
							bs357 &= -65;
						}
						break;
					case 2:
						if(v357) {
							bs357 |= 32;
						} else {
							bs357 &= -33;
						}
						break;
					case 3:
						if(v357) {
							bs357 |= 16;
						} else {
							bs357 &= -17;
						}
						break;
					case 4:
						if(v357) {
							bs357 |= 8;
						} else {
							bs357 &= -9;
						}
						break;
					case 5:
						if(v357) {
							bs357 |= 4;
						} else {
							bs357 &= -5;
						}
						break;
					case 6:
						if(v357) {
							bs357 |= 2;
						} else {
							bs357 &= -3;
						}
						break;
					case 7:
						if(v357) {
							bs357 |= 1;
						} else {
							bs357 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs357;
				var this359 = 0;
				var bs358 = this359;
				var l358 = "*    ".length;
				var _g1359 = 0;
				var _g459 = l358;
				while(_g1359 < _g459) {
					var i359 = _g1359++;
					var no358 = "*    ".charCodeAt(i359);
					if(no358 == null) {
						break;
					}
					var v358;
					switch(no358) {
					case 32:
						v358 = false;
						break;
					case 42:
						v358 = true;
						break;
					case 48:
						v358 = false;
						break;
					case 49:
						v358 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i359)));
					}
					switch(i359 - (l358 - 8)) {
					case 0:
						if(v358) {
							bs358 |= 128;
						} else {
							bs358 &= -129;
						}
						break;
					case 1:
						if(v358) {
							bs358 |= 64;
						} else {
							bs358 &= -65;
						}
						break;
					case 2:
						if(v358) {
							bs358 |= 32;
						} else {
							bs358 &= -33;
						}
						break;
					case 3:
						if(v358) {
							bs358 |= 16;
						} else {
							bs358 &= -17;
						}
						break;
					case 4:
						if(v358) {
							bs358 |= 8;
						} else {
							bs358 &= -9;
						}
						break;
					case 5:
						if(v358) {
							bs358 |= 4;
						} else {
							bs358 &= -5;
						}
						break;
					case 6:
						if(v358) {
							bs358 |= 2;
						} else {
							bs358 &= -3;
						}
						break;
					case 7:
						if(v358) {
							bs358 |= 1;
						} else {
							bs358 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs358;
				var this360 = 0;
				var bs359 = this360;
				var l359 = "*    ".length;
				var _g1360 = 0;
				var _g460 = l359;
				while(_g1360 < _g460) {
					var i360 = _g1360++;
					var no359 = "*    ".charCodeAt(i360);
					if(no359 == null) {
						break;
					}
					var v359;
					switch(no359) {
					case 32:
						v359 = false;
						break;
					case 42:
						v359 = true;
						break;
					case 48:
						v359 = false;
						break;
					case 49:
						v359 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i360)));
					}
					switch(i360 - (l359 - 8)) {
					case 0:
						if(v359) {
							bs359 |= 128;
						} else {
							bs359 &= -129;
						}
						break;
					case 1:
						if(v359) {
							bs359 |= 64;
						} else {
							bs359 &= -65;
						}
						break;
					case 2:
						if(v359) {
							bs359 |= 32;
						} else {
							bs359 &= -33;
						}
						break;
					case 3:
						if(v359) {
							bs359 |= 16;
						} else {
							bs359 &= -17;
						}
						break;
					case 4:
						if(v359) {
							bs359 |= 8;
						} else {
							bs359 &= -9;
						}
						break;
					case 5:
						if(v359) {
							bs359 |= 4;
						} else {
							bs359 &= -5;
						}
						break;
					case 6:
						if(v359) {
							bs359 |= 2;
						} else {
							bs359 &= -3;
						}
						break;
					case 7:
						if(v359) {
							bs359 |= 1;
						} else {
							bs359 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs359;
				var this361 = 0;
				var bs360 = this361;
				var l360 = " *** ".length;
				var _g1361 = 0;
				var _g461 = l360;
				while(_g1361 < _g461) {
					var i361 = _g1361++;
					var no360 = " *** ".charCodeAt(i361);
					if(no360 == null) {
						break;
					}
					var v360;
					switch(no360) {
					case 32:
						v360 = false;
						break;
					case 42:
						v360 = true;
						break;
					case 48:
						v360 = false;
						break;
					case 49:
						v360 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i361)));
					}
					switch(i361 - (l360 - 8)) {
					case 0:
						if(v360) {
							bs360 |= 128;
						} else {
							bs360 &= -129;
						}
						break;
					case 1:
						if(v360) {
							bs360 |= 64;
						} else {
							bs360 &= -65;
						}
						break;
					case 2:
						if(v360) {
							bs360 |= 32;
						} else {
							bs360 &= -33;
						}
						break;
					case 3:
						if(v360) {
							bs360 |= 16;
						} else {
							bs360 &= -17;
						}
						break;
					case 4:
						if(v360) {
							bs360 |= 8;
						} else {
							bs360 &= -9;
						}
						break;
					case 5:
						if(v360) {
							bs360 |= 4;
						} else {
							bs360 &= -5;
						}
						break;
					case 6:
						if(v360) {
							bs360 |= 2;
						} else {
							bs360 &= -3;
						}
						break;
					case 7:
						if(v360) {
							bs360 |= 1;
						} else {
							bs360 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs360;
				var this362 = 0;
				var bs361 = this362;
				var l361 = "    *".length;
				var _g1362 = 0;
				var _g462 = l361;
				while(_g1362 < _g462) {
					var i362 = _g1362++;
					var no361 = "    *".charCodeAt(i362);
					if(no361 == null) {
						break;
					}
					var v361;
					switch(no361) {
					case 32:
						v361 = false;
						break;
					case 42:
						v361 = true;
						break;
					case 48:
						v361 = false;
						break;
					case 49:
						v361 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i362)));
					}
					switch(i362 - (l361 - 8)) {
					case 0:
						if(v361) {
							bs361 |= 128;
						} else {
							bs361 &= -129;
						}
						break;
					case 1:
						if(v361) {
							bs361 |= 64;
						} else {
							bs361 &= -65;
						}
						break;
					case 2:
						if(v361) {
							bs361 |= 32;
						} else {
							bs361 &= -33;
						}
						break;
					case 3:
						if(v361) {
							bs361 |= 16;
						} else {
							bs361 &= -17;
						}
						break;
					case 4:
						if(v361) {
							bs361 |= 8;
						} else {
							bs361 &= -9;
						}
						break;
					case 5:
						if(v361) {
							bs361 |= 4;
						} else {
							bs361 &= -5;
						}
						break;
					case 6:
						if(v361) {
							bs361 |= 2;
						} else {
							bs361 &= -3;
						}
						break;
					case 7:
						if(v361) {
							bs361 |= 1;
						} else {
							bs361 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs361;
				var this363 = 0;
				var bs362 = this363;
				var l362 = "    *".length;
				var _g1363 = 0;
				var _g463 = l362;
				while(_g1363 < _g463) {
					var i363 = _g1363++;
					var no362 = "    *".charCodeAt(i363);
					if(no362 == null) {
						break;
					}
					var v362;
					switch(no362) {
					case 32:
						v362 = false;
						break;
					case 42:
						v362 = true;
						break;
					case 48:
						v362 = false;
						break;
					case 49:
						v362 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i363)));
					}
					switch(i363 - (l362 - 8)) {
					case 0:
						if(v362) {
							bs362 |= 128;
						} else {
							bs362 &= -129;
						}
						break;
					case 1:
						if(v362) {
							bs362 |= 64;
						} else {
							bs362 &= -65;
						}
						break;
					case 2:
						if(v362) {
							bs362 |= 32;
						} else {
							bs362 &= -33;
						}
						break;
					case 3:
						if(v362) {
							bs362 |= 16;
						} else {
							bs362 &= -17;
						}
						break;
					case 4:
						if(v362) {
							bs362 |= 8;
						} else {
							bs362 &= -9;
						}
						break;
					case 5:
						if(v362) {
							bs362 |= 4;
						} else {
							bs362 &= -5;
						}
						break;
					case 6:
						if(v362) {
							bs362 |= 2;
						} else {
							bs362 &= -3;
						}
						break;
					case 7:
						if(v362) {
							bs362 |= 1;
						} else {
							bs362 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs362;
				var this364 = 0;
				var bs363 = this364;
				var l363 = "**** ".length;
				var _g1364 = 0;
				var _g464 = l363;
				while(_g1364 < _g464) {
					var i364 = _g1364++;
					var no363 = "**** ".charCodeAt(i364);
					if(no363 == null) {
						break;
					}
					var v363;
					switch(no363) {
					case 32:
						v363 = false;
						break;
					case 42:
						v363 = true;
						break;
					case 48:
						v363 = false;
						break;
					case 49:
						v363 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i364)));
					}
					switch(i364 - (l363 - 8)) {
					case 0:
						if(v363) {
							bs363 |= 128;
						} else {
							bs363 &= -129;
						}
						break;
					case 1:
						if(v363) {
							bs363 |= 64;
						} else {
							bs363 &= -65;
						}
						break;
					case 2:
						if(v363) {
							bs363 |= 32;
						} else {
							bs363 &= -33;
						}
						break;
					case 3:
						if(v363) {
							bs363 |= 16;
						} else {
							bs363 &= -17;
						}
						break;
					case 4:
						if(v363) {
							bs363 |= 8;
						} else {
							bs363 &= -9;
						}
						break;
					case 5:
						if(v363) {
							bs363 |= 4;
						} else {
							bs363 &= -5;
						}
						break;
					case 6:
						if(v363) {
							bs363 |= 2;
						} else {
							bs363 &= -3;
						}
						break;
					case 7:
						if(v363) {
							bs363 |= 1;
						} else {
							bs363 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs363;
				break;
			case 84:
				var this365 = 0;
				var bs364 = this365;
				var l364 = "*****".length;
				var _g1365 = 0;
				var _g465 = l364;
				while(_g1365 < _g465) {
					var i365 = _g1365++;
					var no364 = "*****".charCodeAt(i365);
					if(no364 == null) {
						break;
					}
					var v364;
					switch(no364) {
					case 32:
						v364 = false;
						break;
					case 42:
						v364 = true;
						break;
					case 48:
						v364 = false;
						break;
					case 49:
						v364 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i365)));
					}
					switch(i365 - (l364 - 8)) {
					case 0:
						if(v364) {
							bs364 |= 128;
						} else {
							bs364 &= -129;
						}
						break;
					case 1:
						if(v364) {
							bs364 |= 64;
						} else {
							bs364 &= -65;
						}
						break;
					case 2:
						if(v364) {
							bs364 |= 32;
						} else {
							bs364 &= -33;
						}
						break;
					case 3:
						if(v364) {
							bs364 |= 16;
						} else {
							bs364 &= -17;
						}
						break;
					case 4:
						if(v364) {
							bs364 |= 8;
						} else {
							bs364 &= -9;
						}
						break;
					case 5:
						if(v364) {
							bs364 |= 4;
						} else {
							bs364 &= -5;
						}
						break;
					case 6:
						if(v364) {
							bs364 |= 2;
						} else {
							bs364 &= -3;
						}
						break;
					case 7:
						if(v364) {
							bs364 |= 1;
						} else {
							bs364 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs364;
				var this366 = 0;
				var bs365 = this366;
				var l365 = "  *  ".length;
				var _g1366 = 0;
				var _g466 = l365;
				while(_g1366 < _g466) {
					var i366 = _g1366++;
					var no365 = "  *  ".charCodeAt(i366);
					if(no365 == null) {
						break;
					}
					var v365;
					switch(no365) {
					case 32:
						v365 = false;
						break;
					case 42:
						v365 = true;
						break;
					case 48:
						v365 = false;
						break;
					case 49:
						v365 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i366)));
					}
					switch(i366 - (l365 - 8)) {
					case 0:
						if(v365) {
							bs365 |= 128;
						} else {
							bs365 &= -129;
						}
						break;
					case 1:
						if(v365) {
							bs365 |= 64;
						} else {
							bs365 &= -65;
						}
						break;
					case 2:
						if(v365) {
							bs365 |= 32;
						} else {
							bs365 &= -33;
						}
						break;
					case 3:
						if(v365) {
							bs365 |= 16;
						} else {
							bs365 &= -17;
						}
						break;
					case 4:
						if(v365) {
							bs365 |= 8;
						} else {
							bs365 &= -9;
						}
						break;
					case 5:
						if(v365) {
							bs365 |= 4;
						} else {
							bs365 &= -5;
						}
						break;
					case 6:
						if(v365) {
							bs365 |= 2;
						} else {
							bs365 &= -3;
						}
						break;
					case 7:
						if(v365) {
							bs365 |= 1;
						} else {
							bs365 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs365;
				var this367 = 0;
				var bs366 = this367;
				var l366 = "  *  ".length;
				var _g1367 = 0;
				var _g467 = l366;
				while(_g1367 < _g467) {
					var i367 = _g1367++;
					var no366 = "  *  ".charCodeAt(i367);
					if(no366 == null) {
						break;
					}
					var v366;
					switch(no366) {
					case 32:
						v366 = false;
						break;
					case 42:
						v366 = true;
						break;
					case 48:
						v366 = false;
						break;
					case 49:
						v366 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i367)));
					}
					switch(i367 - (l366 - 8)) {
					case 0:
						if(v366) {
							bs366 |= 128;
						} else {
							bs366 &= -129;
						}
						break;
					case 1:
						if(v366) {
							bs366 |= 64;
						} else {
							bs366 &= -65;
						}
						break;
					case 2:
						if(v366) {
							bs366 |= 32;
						} else {
							bs366 &= -33;
						}
						break;
					case 3:
						if(v366) {
							bs366 |= 16;
						} else {
							bs366 &= -17;
						}
						break;
					case 4:
						if(v366) {
							bs366 |= 8;
						} else {
							bs366 &= -9;
						}
						break;
					case 5:
						if(v366) {
							bs366 |= 4;
						} else {
							bs366 &= -5;
						}
						break;
					case 6:
						if(v366) {
							bs366 |= 2;
						} else {
							bs366 &= -3;
						}
						break;
					case 7:
						if(v366) {
							bs366 |= 1;
						} else {
							bs366 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs366;
				var this368 = 0;
				var bs367 = this368;
				var l367 = "  *  ".length;
				var _g1368 = 0;
				var _g468 = l367;
				while(_g1368 < _g468) {
					var i368 = _g1368++;
					var no367 = "  *  ".charCodeAt(i368);
					if(no367 == null) {
						break;
					}
					var v367;
					switch(no367) {
					case 32:
						v367 = false;
						break;
					case 42:
						v367 = true;
						break;
					case 48:
						v367 = false;
						break;
					case 49:
						v367 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i368)));
					}
					switch(i368 - (l367 - 8)) {
					case 0:
						if(v367) {
							bs367 |= 128;
						} else {
							bs367 &= -129;
						}
						break;
					case 1:
						if(v367) {
							bs367 |= 64;
						} else {
							bs367 &= -65;
						}
						break;
					case 2:
						if(v367) {
							bs367 |= 32;
						} else {
							bs367 &= -33;
						}
						break;
					case 3:
						if(v367) {
							bs367 |= 16;
						} else {
							bs367 &= -17;
						}
						break;
					case 4:
						if(v367) {
							bs367 |= 8;
						} else {
							bs367 &= -9;
						}
						break;
					case 5:
						if(v367) {
							bs367 |= 4;
						} else {
							bs367 &= -5;
						}
						break;
					case 6:
						if(v367) {
							bs367 |= 2;
						} else {
							bs367 &= -3;
						}
						break;
					case 7:
						if(v367) {
							bs367 |= 1;
						} else {
							bs367 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs367;
				var this369 = 0;
				var bs368 = this369;
				var l368 = "  *  ".length;
				var _g1369 = 0;
				var _g469 = l368;
				while(_g1369 < _g469) {
					var i369 = _g1369++;
					var no368 = "  *  ".charCodeAt(i369);
					if(no368 == null) {
						break;
					}
					var v368;
					switch(no368) {
					case 32:
						v368 = false;
						break;
					case 42:
						v368 = true;
						break;
					case 48:
						v368 = false;
						break;
					case 49:
						v368 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i369)));
					}
					switch(i369 - (l368 - 8)) {
					case 0:
						if(v368) {
							bs368 |= 128;
						} else {
							bs368 &= -129;
						}
						break;
					case 1:
						if(v368) {
							bs368 |= 64;
						} else {
							bs368 &= -65;
						}
						break;
					case 2:
						if(v368) {
							bs368 |= 32;
						} else {
							bs368 &= -33;
						}
						break;
					case 3:
						if(v368) {
							bs368 |= 16;
						} else {
							bs368 &= -17;
						}
						break;
					case 4:
						if(v368) {
							bs368 |= 8;
						} else {
							bs368 &= -9;
						}
						break;
					case 5:
						if(v368) {
							bs368 |= 4;
						} else {
							bs368 &= -5;
						}
						break;
					case 6:
						if(v368) {
							bs368 |= 2;
						} else {
							bs368 &= -3;
						}
						break;
					case 7:
						if(v368) {
							bs368 |= 1;
						} else {
							bs368 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs368;
				var this370 = 0;
				var bs369 = this370;
				var l369 = "  *  ".length;
				var _g1370 = 0;
				var _g470 = l369;
				while(_g1370 < _g470) {
					var i370 = _g1370++;
					var no369 = "  *  ".charCodeAt(i370);
					if(no369 == null) {
						break;
					}
					var v369;
					switch(no369) {
					case 32:
						v369 = false;
						break;
					case 42:
						v369 = true;
						break;
					case 48:
						v369 = false;
						break;
					case 49:
						v369 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i370)));
					}
					switch(i370 - (l369 - 8)) {
					case 0:
						if(v369) {
							bs369 |= 128;
						} else {
							bs369 &= -129;
						}
						break;
					case 1:
						if(v369) {
							bs369 |= 64;
						} else {
							bs369 &= -65;
						}
						break;
					case 2:
						if(v369) {
							bs369 |= 32;
						} else {
							bs369 &= -33;
						}
						break;
					case 3:
						if(v369) {
							bs369 |= 16;
						} else {
							bs369 &= -17;
						}
						break;
					case 4:
						if(v369) {
							bs369 |= 8;
						} else {
							bs369 &= -9;
						}
						break;
					case 5:
						if(v369) {
							bs369 |= 4;
						} else {
							bs369 &= -5;
						}
						break;
					case 6:
						if(v369) {
							bs369 |= 2;
						} else {
							bs369 &= -3;
						}
						break;
					case 7:
						if(v369) {
							bs369 |= 1;
						} else {
							bs369 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs369;
				var this371 = 0;
				var bs370 = this371;
				var l370 = "  *  ".length;
				var _g1371 = 0;
				var _g471 = l370;
				while(_g1371 < _g471) {
					var i371 = _g1371++;
					var no370 = "  *  ".charCodeAt(i371);
					if(no370 == null) {
						break;
					}
					var v370;
					switch(no370) {
					case 32:
						v370 = false;
						break;
					case 42:
						v370 = true;
						break;
					case 48:
						v370 = false;
						break;
					case 49:
						v370 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i371)));
					}
					switch(i371 - (l370 - 8)) {
					case 0:
						if(v370) {
							bs370 |= 128;
						} else {
							bs370 &= -129;
						}
						break;
					case 1:
						if(v370) {
							bs370 |= 64;
						} else {
							bs370 &= -65;
						}
						break;
					case 2:
						if(v370) {
							bs370 |= 32;
						} else {
							bs370 &= -33;
						}
						break;
					case 3:
						if(v370) {
							bs370 |= 16;
						} else {
							bs370 &= -17;
						}
						break;
					case 4:
						if(v370) {
							bs370 |= 8;
						} else {
							bs370 &= -9;
						}
						break;
					case 5:
						if(v370) {
							bs370 |= 4;
						} else {
							bs370 &= -5;
						}
						break;
					case 6:
						if(v370) {
							bs370 |= 2;
						} else {
							bs370 &= -3;
						}
						break;
					case 7:
						if(v370) {
							bs370 |= 1;
						} else {
							bs370 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs370;
				break;
			case 85:
				var this372 = 0;
				var bs371 = this372;
				var l371 = "*   *".length;
				var _g1372 = 0;
				var _g472 = l371;
				while(_g1372 < _g472) {
					var i372 = _g1372++;
					var no371 = "*   *".charCodeAt(i372);
					if(no371 == null) {
						break;
					}
					var v371;
					switch(no371) {
					case 32:
						v371 = false;
						break;
					case 42:
						v371 = true;
						break;
					case 48:
						v371 = false;
						break;
					case 49:
						v371 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i372)));
					}
					switch(i372 - (l371 - 8)) {
					case 0:
						if(v371) {
							bs371 |= 128;
						} else {
							bs371 &= -129;
						}
						break;
					case 1:
						if(v371) {
							bs371 |= 64;
						} else {
							bs371 &= -65;
						}
						break;
					case 2:
						if(v371) {
							bs371 |= 32;
						} else {
							bs371 &= -33;
						}
						break;
					case 3:
						if(v371) {
							bs371 |= 16;
						} else {
							bs371 &= -17;
						}
						break;
					case 4:
						if(v371) {
							bs371 |= 8;
						} else {
							bs371 &= -9;
						}
						break;
					case 5:
						if(v371) {
							bs371 |= 4;
						} else {
							bs371 &= -5;
						}
						break;
					case 6:
						if(v371) {
							bs371 |= 2;
						} else {
							bs371 &= -3;
						}
						break;
					case 7:
						if(v371) {
							bs371 |= 1;
						} else {
							bs371 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs371;
				var this373 = 0;
				var bs372 = this373;
				var l372 = "*   *".length;
				var _g1373 = 0;
				var _g473 = l372;
				while(_g1373 < _g473) {
					var i373 = _g1373++;
					var no372 = "*   *".charCodeAt(i373);
					if(no372 == null) {
						break;
					}
					var v372;
					switch(no372) {
					case 32:
						v372 = false;
						break;
					case 42:
						v372 = true;
						break;
					case 48:
						v372 = false;
						break;
					case 49:
						v372 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i373)));
					}
					switch(i373 - (l372 - 8)) {
					case 0:
						if(v372) {
							bs372 |= 128;
						} else {
							bs372 &= -129;
						}
						break;
					case 1:
						if(v372) {
							bs372 |= 64;
						} else {
							bs372 &= -65;
						}
						break;
					case 2:
						if(v372) {
							bs372 |= 32;
						} else {
							bs372 &= -33;
						}
						break;
					case 3:
						if(v372) {
							bs372 |= 16;
						} else {
							bs372 &= -17;
						}
						break;
					case 4:
						if(v372) {
							bs372 |= 8;
						} else {
							bs372 &= -9;
						}
						break;
					case 5:
						if(v372) {
							bs372 |= 4;
						} else {
							bs372 &= -5;
						}
						break;
					case 6:
						if(v372) {
							bs372 |= 2;
						} else {
							bs372 &= -3;
						}
						break;
					case 7:
						if(v372) {
							bs372 |= 1;
						} else {
							bs372 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs372;
				var this374 = 0;
				var bs373 = this374;
				var l373 = "*   *".length;
				var _g1374 = 0;
				var _g474 = l373;
				while(_g1374 < _g474) {
					var i374 = _g1374++;
					var no373 = "*   *".charCodeAt(i374);
					if(no373 == null) {
						break;
					}
					var v373;
					switch(no373) {
					case 32:
						v373 = false;
						break;
					case 42:
						v373 = true;
						break;
					case 48:
						v373 = false;
						break;
					case 49:
						v373 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i374)));
					}
					switch(i374 - (l373 - 8)) {
					case 0:
						if(v373) {
							bs373 |= 128;
						} else {
							bs373 &= -129;
						}
						break;
					case 1:
						if(v373) {
							bs373 |= 64;
						} else {
							bs373 &= -65;
						}
						break;
					case 2:
						if(v373) {
							bs373 |= 32;
						} else {
							bs373 &= -33;
						}
						break;
					case 3:
						if(v373) {
							bs373 |= 16;
						} else {
							bs373 &= -17;
						}
						break;
					case 4:
						if(v373) {
							bs373 |= 8;
						} else {
							bs373 &= -9;
						}
						break;
					case 5:
						if(v373) {
							bs373 |= 4;
						} else {
							bs373 &= -5;
						}
						break;
					case 6:
						if(v373) {
							bs373 |= 2;
						} else {
							bs373 &= -3;
						}
						break;
					case 7:
						if(v373) {
							bs373 |= 1;
						} else {
							bs373 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs373;
				var this375 = 0;
				var bs374 = this375;
				var l374 = "*   *".length;
				var _g1375 = 0;
				var _g475 = l374;
				while(_g1375 < _g475) {
					var i375 = _g1375++;
					var no374 = "*   *".charCodeAt(i375);
					if(no374 == null) {
						break;
					}
					var v374;
					switch(no374) {
					case 32:
						v374 = false;
						break;
					case 42:
						v374 = true;
						break;
					case 48:
						v374 = false;
						break;
					case 49:
						v374 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i375)));
					}
					switch(i375 - (l374 - 8)) {
					case 0:
						if(v374) {
							bs374 |= 128;
						} else {
							bs374 &= -129;
						}
						break;
					case 1:
						if(v374) {
							bs374 |= 64;
						} else {
							bs374 &= -65;
						}
						break;
					case 2:
						if(v374) {
							bs374 |= 32;
						} else {
							bs374 &= -33;
						}
						break;
					case 3:
						if(v374) {
							bs374 |= 16;
						} else {
							bs374 &= -17;
						}
						break;
					case 4:
						if(v374) {
							bs374 |= 8;
						} else {
							bs374 &= -9;
						}
						break;
					case 5:
						if(v374) {
							bs374 |= 4;
						} else {
							bs374 &= -5;
						}
						break;
					case 6:
						if(v374) {
							bs374 |= 2;
						} else {
							bs374 &= -3;
						}
						break;
					case 7:
						if(v374) {
							bs374 |= 1;
						} else {
							bs374 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs374;
				var this376 = 0;
				var bs375 = this376;
				var l375 = "*   *".length;
				var _g1376 = 0;
				var _g476 = l375;
				while(_g1376 < _g476) {
					var i376 = _g1376++;
					var no375 = "*   *".charCodeAt(i376);
					if(no375 == null) {
						break;
					}
					var v375;
					switch(no375) {
					case 32:
						v375 = false;
						break;
					case 42:
						v375 = true;
						break;
					case 48:
						v375 = false;
						break;
					case 49:
						v375 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i376)));
					}
					switch(i376 - (l375 - 8)) {
					case 0:
						if(v375) {
							bs375 |= 128;
						} else {
							bs375 &= -129;
						}
						break;
					case 1:
						if(v375) {
							bs375 |= 64;
						} else {
							bs375 &= -65;
						}
						break;
					case 2:
						if(v375) {
							bs375 |= 32;
						} else {
							bs375 &= -33;
						}
						break;
					case 3:
						if(v375) {
							bs375 |= 16;
						} else {
							bs375 &= -17;
						}
						break;
					case 4:
						if(v375) {
							bs375 |= 8;
						} else {
							bs375 &= -9;
						}
						break;
					case 5:
						if(v375) {
							bs375 |= 4;
						} else {
							bs375 &= -5;
						}
						break;
					case 6:
						if(v375) {
							bs375 |= 2;
						} else {
							bs375 &= -3;
						}
						break;
					case 7:
						if(v375) {
							bs375 |= 1;
						} else {
							bs375 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs375;
				var this377 = 0;
				var bs376 = this377;
				var l376 = "*   *".length;
				var _g1377 = 0;
				var _g477 = l376;
				while(_g1377 < _g477) {
					var i377 = _g1377++;
					var no376 = "*   *".charCodeAt(i377);
					if(no376 == null) {
						break;
					}
					var v376;
					switch(no376) {
					case 32:
						v376 = false;
						break;
					case 42:
						v376 = true;
						break;
					case 48:
						v376 = false;
						break;
					case 49:
						v376 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i377)));
					}
					switch(i377 - (l376 - 8)) {
					case 0:
						if(v376) {
							bs376 |= 128;
						} else {
							bs376 &= -129;
						}
						break;
					case 1:
						if(v376) {
							bs376 |= 64;
						} else {
							bs376 &= -65;
						}
						break;
					case 2:
						if(v376) {
							bs376 |= 32;
						} else {
							bs376 &= -33;
						}
						break;
					case 3:
						if(v376) {
							bs376 |= 16;
						} else {
							bs376 &= -17;
						}
						break;
					case 4:
						if(v376) {
							bs376 |= 8;
						} else {
							bs376 &= -9;
						}
						break;
					case 5:
						if(v376) {
							bs376 |= 4;
						} else {
							bs376 &= -5;
						}
						break;
					case 6:
						if(v376) {
							bs376 |= 2;
						} else {
							bs376 &= -3;
						}
						break;
					case 7:
						if(v376) {
							bs376 |= 1;
						} else {
							bs376 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs376;
				var this378 = 0;
				var bs377 = this378;
				var l377 = " *** ".length;
				var _g1378 = 0;
				var _g478 = l377;
				while(_g1378 < _g478) {
					var i378 = _g1378++;
					var no377 = " *** ".charCodeAt(i378);
					if(no377 == null) {
						break;
					}
					var v377;
					switch(no377) {
					case 32:
						v377 = false;
						break;
					case 42:
						v377 = true;
						break;
					case 48:
						v377 = false;
						break;
					case 49:
						v377 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i378)));
					}
					switch(i378 - (l377 - 8)) {
					case 0:
						if(v377) {
							bs377 |= 128;
						} else {
							bs377 &= -129;
						}
						break;
					case 1:
						if(v377) {
							bs377 |= 64;
						} else {
							bs377 &= -65;
						}
						break;
					case 2:
						if(v377) {
							bs377 |= 32;
						} else {
							bs377 &= -33;
						}
						break;
					case 3:
						if(v377) {
							bs377 |= 16;
						} else {
							bs377 &= -17;
						}
						break;
					case 4:
						if(v377) {
							bs377 |= 8;
						} else {
							bs377 &= -9;
						}
						break;
					case 5:
						if(v377) {
							bs377 |= 4;
						} else {
							bs377 &= -5;
						}
						break;
					case 6:
						if(v377) {
							bs377 |= 2;
						} else {
							bs377 &= -3;
						}
						break;
					case 7:
						if(v377) {
							bs377 |= 1;
						} else {
							bs377 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs377;
				break;
			case 86:
				var this379 = 0;
				var bs378 = this379;
				var l378 = "*   *".length;
				var _g1379 = 0;
				var _g479 = l378;
				while(_g1379 < _g479) {
					var i379 = _g1379++;
					var no378 = "*   *".charCodeAt(i379);
					if(no378 == null) {
						break;
					}
					var v378;
					switch(no378) {
					case 32:
						v378 = false;
						break;
					case 42:
						v378 = true;
						break;
					case 48:
						v378 = false;
						break;
					case 49:
						v378 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i379)));
					}
					switch(i379 - (l378 - 8)) {
					case 0:
						if(v378) {
							bs378 |= 128;
						} else {
							bs378 &= -129;
						}
						break;
					case 1:
						if(v378) {
							bs378 |= 64;
						} else {
							bs378 &= -65;
						}
						break;
					case 2:
						if(v378) {
							bs378 |= 32;
						} else {
							bs378 &= -33;
						}
						break;
					case 3:
						if(v378) {
							bs378 |= 16;
						} else {
							bs378 &= -17;
						}
						break;
					case 4:
						if(v378) {
							bs378 |= 8;
						} else {
							bs378 &= -9;
						}
						break;
					case 5:
						if(v378) {
							bs378 |= 4;
						} else {
							bs378 &= -5;
						}
						break;
					case 6:
						if(v378) {
							bs378 |= 2;
						} else {
							bs378 &= -3;
						}
						break;
					case 7:
						if(v378) {
							bs378 |= 1;
						} else {
							bs378 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs378;
				var this380 = 0;
				var bs379 = this380;
				var l379 = "*   *".length;
				var _g1380 = 0;
				var _g480 = l379;
				while(_g1380 < _g480) {
					var i380 = _g1380++;
					var no379 = "*   *".charCodeAt(i380);
					if(no379 == null) {
						break;
					}
					var v379;
					switch(no379) {
					case 32:
						v379 = false;
						break;
					case 42:
						v379 = true;
						break;
					case 48:
						v379 = false;
						break;
					case 49:
						v379 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i380)));
					}
					switch(i380 - (l379 - 8)) {
					case 0:
						if(v379) {
							bs379 |= 128;
						} else {
							bs379 &= -129;
						}
						break;
					case 1:
						if(v379) {
							bs379 |= 64;
						} else {
							bs379 &= -65;
						}
						break;
					case 2:
						if(v379) {
							bs379 |= 32;
						} else {
							bs379 &= -33;
						}
						break;
					case 3:
						if(v379) {
							bs379 |= 16;
						} else {
							bs379 &= -17;
						}
						break;
					case 4:
						if(v379) {
							bs379 |= 8;
						} else {
							bs379 &= -9;
						}
						break;
					case 5:
						if(v379) {
							bs379 |= 4;
						} else {
							bs379 &= -5;
						}
						break;
					case 6:
						if(v379) {
							bs379 |= 2;
						} else {
							bs379 &= -3;
						}
						break;
					case 7:
						if(v379) {
							bs379 |= 1;
						} else {
							bs379 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs379;
				var this381 = 0;
				var bs380 = this381;
				var l380 = "*   *".length;
				var _g1381 = 0;
				var _g481 = l380;
				while(_g1381 < _g481) {
					var i381 = _g1381++;
					var no380 = "*   *".charCodeAt(i381);
					if(no380 == null) {
						break;
					}
					var v380;
					switch(no380) {
					case 32:
						v380 = false;
						break;
					case 42:
						v380 = true;
						break;
					case 48:
						v380 = false;
						break;
					case 49:
						v380 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i381)));
					}
					switch(i381 - (l380 - 8)) {
					case 0:
						if(v380) {
							bs380 |= 128;
						} else {
							bs380 &= -129;
						}
						break;
					case 1:
						if(v380) {
							bs380 |= 64;
						} else {
							bs380 &= -65;
						}
						break;
					case 2:
						if(v380) {
							bs380 |= 32;
						} else {
							bs380 &= -33;
						}
						break;
					case 3:
						if(v380) {
							bs380 |= 16;
						} else {
							bs380 &= -17;
						}
						break;
					case 4:
						if(v380) {
							bs380 |= 8;
						} else {
							bs380 &= -9;
						}
						break;
					case 5:
						if(v380) {
							bs380 |= 4;
						} else {
							bs380 &= -5;
						}
						break;
					case 6:
						if(v380) {
							bs380 |= 2;
						} else {
							bs380 &= -3;
						}
						break;
					case 7:
						if(v380) {
							bs380 |= 1;
						} else {
							bs380 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs380;
				var this382 = 0;
				var bs381 = this382;
				var l381 = "*   *".length;
				var _g1382 = 0;
				var _g482 = l381;
				while(_g1382 < _g482) {
					var i382 = _g1382++;
					var no381 = "*   *".charCodeAt(i382);
					if(no381 == null) {
						break;
					}
					var v381;
					switch(no381) {
					case 32:
						v381 = false;
						break;
					case 42:
						v381 = true;
						break;
					case 48:
						v381 = false;
						break;
					case 49:
						v381 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i382)));
					}
					switch(i382 - (l381 - 8)) {
					case 0:
						if(v381) {
							bs381 |= 128;
						} else {
							bs381 &= -129;
						}
						break;
					case 1:
						if(v381) {
							bs381 |= 64;
						} else {
							bs381 &= -65;
						}
						break;
					case 2:
						if(v381) {
							bs381 |= 32;
						} else {
							bs381 &= -33;
						}
						break;
					case 3:
						if(v381) {
							bs381 |= 16;
						} else {
							bs381 &= -17;
						}
						break;
					case 4:
						if(v381) {
							bs381 |= 8;
						} else {
							bs381 &= -9;
						}
						break;
					case 5:
						if(v381) {
							bs381 |= 4;
						} else {
							bs381 &= -5;
						}
						break;
					case 6:
						if(v381) {
							bs381 |= 2;
						} else {
							bs381 &= -3;
						}
						break;
					case 7:
						if(v381) {
							bs381 |= 1;
						} else {
							bs381 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs381;
				var this383 = 0;
				var bs382 = this383;
				var l382 = "*   *".length;
				var _g1383 = 0;
				var _g483 = l382;
				while(_g1383 < _g483) {
					var i383 = _g1383++;
					var no382 = "*   *".charCodeAt(i383);
					if(no382 == null) {
						break;
					}
					var v382;
					switch(no382) {
					case 32:
						v382 = false;
						break;
					case 42:
						v382 = true;
						break;
					case 48:
						v382 = false;
						break;
					case 49:
						v382 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i383)));
					}
					switch(i383 - (l382 - 8)) {
					case 0:
						if(v382) {
							bs382 |= 128;
						} else {
							bs382 &= -129;
						}
						break;
					case 1:
						if(v382) {
							bs382 |= 64;
						} else {
							bs382 &= -65;
						}
						break;
					case 2:
						if(v382) {
							bs382 |= 32;
						} else {
							bs382 &= -33;
						}
						break;
					case 3:
						if(v382) {
							bs382 |= 16;
						} else {
							bs382 &= -17;
						}
						break;
					case 4:
						if(v382) {
							bs382 |= 8;
						} else {
							bs382 &= -9;
						}
						break;
					case 5:
						if(v382) {
							bs382 |= 4;
						} else {
							bs382 &= -5;
						}
						break;
					case 6:
						if(v382) {
							bs382 |= 2;
						} else {
							bs382 &= -3;
						}
						break;
					case 7:
						if(v382) {
							bs382 |= 1;
						} else {
							bs382 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs382;
				var this384 = 0;
				var bs383 = this384;
				var l383 = " * * ".length;
				var _g1384 = 0;
				var _g484 = l383;
				while(_g1384 < _g484) {
					var i384 = _g1384++;
					var no383 = " * * ".charCodeAt(i384);
					if(no383 == null) {
						break;
					}
					var v383;
					switch(no383) {
					case 32:
						v383 = false;
						break;
					case 42:
						v383 = true;
						break;
					case 48:
						v383 = false;
						break;
					case 49:
						v383 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i384)));
					}
					switch(i384 - (l383 - 8)) {
					case 0:
						if(v383) {
							bs383 |= 128;
						} else {
							bs383 &= -129;
						}
						break;
					case 1:
						if(v383) {
							bs383 |= 64;
						} else {
							bs383 &= -65;
						}
						break;
					case 2:
						if(v383) {
							bs383 |= 32;
						} else {
							bs383 &= -33;
						}
						break;
					case 3:
						if(v383) {
							bs383 |= 16;
						} else {
							bs383 &= -17;
						}
						break;
					case 4:
						if(v383) {
							bs383 |= 8;
						} else {
							bs383 &= -9;
						}
						break;
					case 5:
						if(v383) {
							bs383 |= 4;
						} else {
							bs383 &= -5;
						}
						break;
					case 6:
						if(v383) {
							bs383 |= 2;
						} else {
							bs383 &= -3;
						}
						break;
					case 7:
						if(v383) {
							bs383 |= 1;
						} else {
							bs383 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs383;
				var this385 = 0;
				var bs384 = this385;
				var l384 = "  *  ".length;
				var _g1385 = 0;
				var _g485 = l384;
				while(_g1385 < _g485) {
					var i385 = _g1385++;
					var no384 = "  *  ".charCodeAt(i385);
					if(no384 == null) {
						break;
					}
					var v384;
					switch(no384) {
					case 32:
						v384 = false;
						break;
					case 42:
						v384 = true;
						break;
					case 48:
						v384 = false;
						break;
					case 49:
						v384 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i385)));
					}
					switch(i385 - (l384 - 8)) {
					case 0:
						if(v384) {
							bs384 |= 128;
						} else {
							bs384 &= -129;
						}
						break;
					case 1:
						if(v384) {
							bs384 |= 64;
						} else {
							bs384 &= -65;
						}
						break;
					case 2:
						if(v384) {
							bs384 |= 32;
						} else {
							bs384 &= -33;
						}
						break;
					case 3:
						if(v384) {
							bs384 |= 16;
						} else {
							bs384 &= -17;
						}
						break;
					case 4:
						if(v384) {
							bs384 |= 8;
						} else {
							bs384 &= -9;
						}
						break;
					case 5:
						if(v384) {
							bs384 |= 4;
						} else {
							bs384 &= -5;
						}
						break;
					case 6:
						if(v384) {
							bs384 |= 2;
						} else {
							bs384 &= -3;
						}
						break;
					case 7:
						if(v384) {
							bs384 |= 1;
						} else {
							bs384 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs384;
				break;
			case 87:
				var this386 = 0;
				var bs385 = this386;
				var l385 = "*   *".length;
				var _g1386 = 0;
				var _g486 = l385;
				while(_g1386 < _g486) {
					var i386 = _g1386++;
					var no385 = "*   *".charCodeAt(i386);
					if(no385 == null) {
						break;
					}
					var v385;
					switch(no385) {
					case 32:
						v385 = false;
						break;
					case 42:
						v385 = true;
						break;
					case 48:
						v385 = false;
						break;
					case 49:
						v385 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i386)));
					}
					switch(i386 - (l385 - 8)) {
					case 0:
						if(v385) {
							bs385 |= 128;
						} else {
							bs385 &= -129;
						}
						break;
					case 1:
						if(v385) {
							bs385 |= 64;
						} else {
							bs385 &= -65;
						}
						break;
					case 2:
						if(v385) {
							bs385 |= 32;
						} else {
							bs385 &= -33;
						}
						break;
					case 3:
						if(v385) {
							bs385 |= 16;
						} else {
							bs385 &= -17;
						}
						break;
					case 4:
						if(v385) {
							bs385 |= 8;
						} else {
							bs385 &= -9;
						}
						break;
					case 5:
						if(v385) {
							bs385 |= 4;
						} else {
							bs385 &= -5;
						}
						break;
					case 6:
						if(v385) {
							bs385 |= 2;
						} else {
							bs385 &= -3;
						}
						break;
					case 7:
						if(v385) {
							bs385 |= 1;
						} else {
							bs385 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs385;
				var this387 = 0;
				var bs386 = this387;
				var l386 = "*   *".length;
				var _g1387 = 0;
				var _g487 = l386;
				while(_g1387 < _g487) {
					var i387 = _g1387++;
					var no386 = "*   *".charCodeAt(i387);
					if(no386 == null) {
						break;
					}
					var v386;
					switch(no386) {
					case 32:
						v386 = false;
						break;
					case 42:
						v386 = true;
						break;
					case 48:
						v386 = false;
						break;
					case 49:
						v386 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i387)));
					}
					switch(i387 - (l386 - 8)) {
					case 0:
						if(v386) {
							bs386 |= 128;
						} else {
							bs386 &= -129;
						}
						break;
					case 1:
						if(v386) {
							bs386 |= 64;
						} else {
							bs386 &= -65;
						}
						break;
					case 2:
						if(v386) {
							bs386 |= 32;
						} else {
							bs386 &= -33;
						}
						break;
					case 3:
						if(v386) {
							bs386 |= 16;
						} else {
							bs386 &= -17;
						}
						break;
					case 4:
						if(v386) {
							bs386 |= 8;
						} else {
							bs386 &= -9;
						}
						break;
					case 5:
						if(v386) {
							bs386 |= 4;
						} else {
							bs386 &= -5;
						}
						break;
					case 6:
						if(v386) {
							bs386 |= 2;
						} else {
							bs386 &= -3;
						}
						break;
					case 7:
						if(v386) {
							bs386 |= 1;
						} else {
							bs386 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs386;
				var this388 = 0;
				var bs387 = this388;
				var l387 = "*   *".length;
				var _g1388 = 0;
				var _g488 = l387;
				while(_g1388 < _g488) {
					var i388 = _g1388++;
					var no387 = "*   *".charCodeAt(i388);
					if(no387 == null) {
						break;
					}
					var v387;
					switch(no387) {
					case 32:
						v387 = false;
						break;
					case 42:
						v387 = true;
						break;
					case 48:
						v387 = false;
						break;
					case 49:
						v387 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i388)));
					}
					switch(i388 - (l387 - 8)) {
					case 0:
						if(v387) {
							bs387 |= 128;
						} else {
							bs387 &= -129;
						}
						break;
					case 1:
						if(v387) {
							bs387 |= 64;
						} else {
							bs387 &= -65;
						}
						break;
					case 2:
						if(v387) {
							bs387 |= 32;
						} else {
							bs387 &= -33;
						}
						break;
					case 3:
						if(v387) {
							bs387 |= 16;
						} else {
							bs387 &= -17;
						}
						break;
					case 4:
						if(v387) {
							bs387 |= 8;
						} else {
							bs387 &= -9;
						}
						break;
					case 5:
						if(v387) {
							bs387 |= 4;
						} else {
							bs387 &= -5;
						}
						break;
					case 6:
						if(v387) {
							bs387 |= 2;
						} else {
							bs387 &= -3;
						}
						break;
					case 7:
						if(v387) {
							bs387 |= 1;
						} else {
							bs387 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs387;
				var this389 = 0;
				var bs388 = this389;
				var l388 = "* * *".length;
				var _g1389 = 0;
				var _g489 = l388;
				while(_g1389 < _g489) {
					var i389 = _g1389++;
					var no388 = "* * *".charCodeAt(i389);
					if(no388 == null) {
						break;
					}
					var v388;
					switch(no388) {
					case 32:
						v388 = false;
						break;
					case 42:
						v388 = true;
						break;
					case 48:
						v388 = false;
						break;
					case 49:
						v388 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i389)));
					}
					switch(i389 - (l388 - 8)) {
					case 0:
						if(v388) {
							bs388 |= 128;
						} else {
							bs388 &= -129;
						}
						break;
					case 1:
						if(v388) {
							bs388 |= 64;
						} else {
							bs388 &= -65;
						}
						break;
					case 2:
						if(v388) {
							bs388 |= 32;
						} else {
							bs388 &= -33;
						}
						break;
					case 3:
						if(v388) {
							bs388 |= 16;
						} else {
							bs388 &= -17;
						}
						break;
					case 4:
						if(v388) {
							bs388 |= 8;
						} else {
							bs388 &= -9;
						}
						break;
					case 5:
						if(v388) {
							bs388 |= 4;
						} else {
							bs388 &= -5;
						}
						break;
					case 6:
						if(v388) {
							bs388 |= 2;
						} else {
							bs388 &= -3;
						}
						break;
					case 7:
						if(v388) {
							bs388 |= 1;
						} else {
							bs388 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs388;
				var this390 = 0;
				var bs389 = this390;
				var l389 = "* * *".length;
				var _g1390 = 0;
				var _g490 = l389;
				while(_g1390 < _g490) {
					var i390 = _g1390++;
					var no389 = "* * *".charCodeAt(i390);
					if(no389 == null) {
						break;
					}
					var v389;
					switch(no389) {
					case 32:
						v389 = false;
						break;
					case 42:
						v389 = true;
						break;
					case 48:
						v389 = false;
						break;
					case 49:
						v389 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i390)));
					}
					switch(i390 - (l389 - 8)) {
					case 0:
						if(v389) {
							bs389 |= 128;
						} else {
							bs389 &= -129;
						}
						break;
					case 1:
						if(v389) {
							bs389 |= 64;
						} else {
							bs389 &= -65;
						}
						break;
					case 2:
						if(v389) {
							bs389 |= 32;
						} else {
							bs389 &= -33;
						}
						break;
					case 3:
						if(v389) {
							bs389 |= 16;
						} else {
							bs389 &= -17;
						}
						break;
					case 4:
						if(v389) {
							bs389 |= 8;
						} else {
							bs389 &= -9;
						}
						break;
					case 5:
						if(v389) {
							bs389 |= 4;
						} else {
							bs389 &= -5;
						}
						break;
					case 6:
						if(v389) {
							bs389 |= 2;
						} else {
							bs389 &= -3;
						}
						break;
					case 7:
						if(v389) {
							bs389 |= 1;
						} else {
							bs389 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs389;
				var this391 = 0;
				var bs390 = this391;
				var l390 = "* * *".length;
				var _g1391 = 0;
				var _g491 = l390;
				while(_g1391 < _g491) {
					var i391 = _g1391++;
					var no390 = "* * *".charCodeAt(i391);
					if(no390 == null) {
						break;
					}
					var v390;
					switch(no390) {
					case 32:
						v390 = false;
						break;
					case 42:
						v390 = true;
						break;
					case 48:
						v390 = false;
						break;
					case 49:
						v390 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i391)));
					}
					switch(i391 - (l390 - 8)) {
					case 0:
						if(v390) {
							bs390 |= 128;
						} else {
							bs390 &= -129;
						}
						break;
					case 1:
						if(v390) {
							bs390 |= 64;
						} else {
							bs390 &= -65;
						}
						break;
					case 2:
						if(v390) {
							bs390 |= 32;
						} else {
							bs390 &= -33;
						}
						break;
					case 3:
						if(v390) {
							bs390 |= 16;
						} else {
							bs390 &= -17;
						}
						break;
					case 4:
						if(v390) {
							bs390 |= 8;
						} else {
							bs390 &= -9;
						}
						break;
					case 5:
						if(v390) {
							bs390 |= 4;
						} else {
							bs390 &= -5;
						}
						break;
					case 6:
						if(v390) {
							bs390 |= 2;
						} else {
							bs390 &= -3;
						}
						break;
					case 7:
						if(v390) {
							bs390 |= 1;
						} else {
							bs390 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs390;
				var this392 = 0;
				var bs391 = this392;
				var l391 = " * * ".length;
				var _g1392 = 0;
				var _g492 = l391;
				while(_g1392 < _g492) {
					var i392 = _g1392++;
					var no391 = " * * ".charCodeAt(i392);
					if(no391 == null) {
						break;
					}
					var v391;
					switch(no391) {
					case 32:
						v391 = false;
						break;
					case 42:
						v391 = true;
						break;
					case 48:
						v391 = false;
						break;
					case 49:
						v391 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i392)));
					}
					switch(i392 - (l391 - 8)) {
					case 0:
						if(v391) {
							bs391 |= 128;
						} else {
							bs391 &= -129;
						}
						break;
					case 1:
						if(v391) {
							bs391 |= 64;
						} else {
							bs391 &= -65;
						}
						break;
					case 2:
						if(v391) {
							bs391 |= 32;
						} else {
							bs391 &= -33;
						}
						break;
					case 3:
						if(v391) {
							bs391 |= 16;
						} else {
							bs391 &= -17;
						}
						break;
					case 4:
						if(v391) {
							bs391 |= 8;
						} else {
							bs391 &= -9;
						}
						break;
					case 5:
						if(v391) {
							bs391 |= 4;
						} else {
							bs391 &= -5;
						}
						break;
					case 6:
						if(v391) {
							bs391 |= 2;
						} else {
							bs391 &= -3;
						}
						break;
					case 7:
						if(v391) {
							bs391 |= 1;
						} else {
							bs391 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs391;
				break;
			case 88:
				var this393 = 0;
				var bs392 = this393;
				var l392 = "*   *".length;
				var _g1393 = 0;
				var _g493 = l392;
				while(_g1393 < _g493) {
					var i393 = _g1393++;
					var no392 = "*   *".charCodeAt(i393);
					if(no392 == null) {
						break;
					}
					var v392;
					switch(no392) {
					case 32:
						v392 = false;
						break;
					case 42:
						v392 = true;
						break;
					case 48:
						v392 = false;
						break;
					case 49:
						v392 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i393)));
					}
					switch(i393 - (l392 - 8)) {
					case 0:
						if(v392) {
							bs392 |= 128;
						} else {
							bs392 &= -129;
						}
						break;
					case 1:
						if(v392) {
							bs392 |= 64;
						} else {
							bs392 &= -65;
						}
						break;
					case 2:
						if(v392) {
							bs392 |= 32;
						} else {
							bs392 &= -33;
						}
						break;
					case 3:
						if(v392) {
							bs392 |= 16;
						} else {
							bs392 &= -17;
						}
						break;
					case 4:
						if(v392) {
							bs392 |= 8;
						} else {
							bs392 &= -9;
						}
						break;
					case 5:
						if(v392) {
							bs392 |= 4;
						} else {
							bs392 &= -5;
						}
						break;
					case 6:
						if(v392) {
							bs392 |= 2;
						} else {
							bs392 &= -3;
						}
						break;
					case 7:
						if(v392) {
							bs392 |= 1;
						} else {
							bs392 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs392;
				var this394 = 0;
				var bs393 = this394;
				var l393 = "*   *".length;
				var _g1394 = 0;
				var _g494 = l393;
				while(_g1394 < _g494) {
					var i394 = _g1394++;
					var no393 = "*   *".charCodeAt(i394);
					if(no393 == null) {
						break;
					}
					var v393;
					switch(no393) {
					case 32:
						v393 = false;
						break;
					case 42:
						v393 = true;
						break;
					case 48:
						v393 = false;
						break;
					case 49:
						v393 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i394)));
					}
					switch(i394 - (l393 - 8)) {
					case 0:
						if(v393) {
							bs393 |= 128;
						} else {
							bs393 &= -129;
						}
						break;
					case 1:
						if(v393) {
							bs393 |= 64;
						} else {
							bs393 &= -65;
						}
						break;
					case 2:
						if(v393) {
							bs393 |= 32;
						} else {
							bs393 &= -33;
						}
						break;
					case 3:
						if(v393) {
							bs393 |= 16;
						} else {
							bs393 &= -17;
						}
						break;
					case 4:
						if(v393) {
							bs393 |= 8;
						} else {
							bs393 &= -9;
						}
						break;
					case 5:
						if(v393) {
							bs393 |= 4;
						} else {
							bs393 &= -5;
						}
						break;
					case 6:
						if(v393) {
							bs393 |= 2;
						} else {
							bs393 &= -3;
						}
						break;
					case 7:
						if(v393) {
							bs393 |= 1;
						} else {
							bs393 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs393;
				var this395 = 0;
				var bs394 = this395;
				var l394 = " * * ".length;
				var _g1395 = 0;
				var _g495 = l394;
				while(_g1395 < _g495) {
					var i395 = _g1395++;
					var no394 = " * * ".charCodeAt(i395);
					if(no394 == null) {
						break;
					}
					var v394;
					switch(no394) {
					case 32:
						v394 = false;
						break;
					case 42:
						v394 = true;
						break;
					case 48:
						v394 = false;
						break;
					case 49:
						v394 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i395)));
					}
					switch(i395 - (l394 - 8)) {
					case 0:
						if(v394) {
							bs394 |= 128;
						} else {
							bs394 &= -129;
						}
						break;
					case 1:
						if(v394) {
							bs394 |= 64;
						} else {
							bs394 &= -65;
						}
						break;
					case 2:
						if(v394) {
							bs394 |= 32;
						} else {
							bs394 &= -33;
						}
						break;
					case 3:
						if(v394) {
							bs394 |= 16;
						} else {
							bs394 &= -17;
						}
						break;
					case 4:
						if(v394) {
							bs394 |= 8;
						} else {
							bs394 &= -9;
						}
						break;
					case 5:
						if(v394) {
							bs394 |= 4;
						} else {
							bs394 &= -5;
						}
						break;
					case 6:
						if(v394) {
							bs394 |= 2;
						} else {
							bs394 &= -3;
						}
						break;
					case 7:
						if(v394) {
							bs394 |= 1;
						} else {
							bs394 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs394;
				var this396 = 0;
				var bs395 = this396;
				var l395 = "  *  ".length;
				var _g1396 = 0;
				var _g496 = l395;
				while(_g1396 < _g496) {
					var i396 = _g1396++;
					var no395 = "  *  ".charCodeAt(i396);
					if(no395 == null) {
						break;
					}
					var v395;
					switch(no395) {
					case 32:
						v395 = false;
						break;
					case 42:
						v395 = true;
						break;
					case 48:
						v395 = false;
						break;
					case 49:
						v395 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i396)));
					}
					switch(i396 - (l395 - 8)) {
					case 0:
						if(v395) {
							bs395 |= 128;
						} else {
							bs395 &= -129;
						}
						break;
					case 1:
						if(v395) {
							bs395 |= 64;
						} else {
							bs395 &= -65;
						}
						break;
					case 2:
						if(v395) {
							bs395 |= 32;
						} else {
							bs395 &= -33;
						}
						break;
					case 3:
						if(v395) {
							bs395 |= 16;
						} else {
							bs395 &= -17;
						}
						break;
					case 4:
						if(v395) {
							bs395 |= 8;
						} else {
							bs395 &= -9;
						}
						break;
					case 5:
						if(v395) {
							bs395 |= 4;
						} else {
							bs395 &= -5;
						}
						break;
					case 6:
						if(v395) {
							bs395 |= 2;
						} else {
							bs395 &= -3;
						}
						break;
					case 7:
						if(v395) {
							bs395 |= 1;
						} else {
							bs395 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs395;
				var this397 = 0;
				var bs396 = this397;
				var l396 = " * * ".length;
				var _g1397 = 0;
				var _g497 = l396;
				while(_g1397 < _g497) {
					var i397 = _g1397++;
					var no396 = " * * ".charCodeAt(i397);
					if(no396 == null) {
						break;
					}
					var v396;
					switch(no396) {
					case 32:
						v396 = false;
						break;
					case 42:
						v396 = true;
						break;
					case 48:
						v396 = false;
						break;
					case 49:
						v396 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i397)));
					}
					switch(i397 - (l396 - 8)) {
					case 0:
						if(v396) {
							bs396 |= 128;
						} else {
							bs396 &= -129;
						}
						break;
					case 1:
						if(v396) {
							bs396 |= 64;
						} else {
							bs396 &= -65;
						}
						break;
					case 2:
						if(v396) {
							bs396 |= 32;
						} else {
							bs396 &= -33;
						}
						break;
					case 3:
						if(v396) {
							bs396 |= 16;
						} else {
							bs396 &= -17;
						}
						break;
					case 4:
						if(v396) {
							bs396 |= 8;
						} else {
							bs396 &= -9;
						}
						break;
					case 5:
						if(v396) {
							bs396 |= 4;
						} else {
							bs396 &= -5;
						}
						break;
					case 6:
						if(v396) {
							bs396 |= 2;
						} else {
							bs396 &= -3;
						}
						break;
					case 7:
						if(v396) {
							bs396 |= 1;
						} else {
							bs396 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs396;
				var this398 = 0;
				var bs397 = this398;
				var l397 = "*   *".length;
				var _g1398 = 0;
				var _g498 = l397;
				while(_g1398 < _g498) {
					var i398 = _g1398++;
					var no397 = "*   *".charCodeAt(i398);
					if(no397 == null) {
						break;
					}
					var v397;
					switch(no397) {
					case 32:
						v397 = false;
						break;
					case 42:
						v397 = true;
						break;
					case 48:
						v397 = false;
						break;
					case 49:
						v397 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i398)));
					}
					switch(i398 - (l397 - 8)) {
					case 0:
						if(v397) {
							bs397 |= 128;
						} else {
							bs397 &= -129;
						}
						break;
					case 1:
						if(v397) {
							bs397 |= 64;
						} else {
							bs397 &= -65;
						}
						break;
					case 2:
						if(v397) {
							bs397 |= 32;
						} else {
							bs397 &= -33;
						}
						break;
					case 3:
						if(v397) {
							bs397 |= 16;
						} else {
							bs397 &= -17;
						}
						break;
					case 4:
						if(v397) {
							bs397 |= 8;
						} else {
							bs397 &= -9;
						}
						break;
					case 5:
						if(v397) {
							bs397 |= 4;
						} else {
							bs397 &= -5;
						}
						break;
					case 6:
						if(v397) {
							bs397 |= 2;
						} else {
							bs397 &= -3;
						}
						break;
					case 7:
						if(v397) {
							bs397 |= 1;
						} else {
							bs397 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs397;
				var this399 = 0;
				var bs398 = this399;
				var l398 = "*   *".length;
				var _g1399 = 0;
				var _g499 = l398;
				while(_g1399 < _g499) {
					var i399 = _g1399++;
					var no398 = "*   *".charCodeAt(i399);
					if(no398 == null) {
						break;
					}
					var v398;
					switch(no398) {
					case 32:
						v398 = false;
						break;
					case 42:
						v398 = true;
						break;
					case 48:
						v398 = false;
						break;
					case 49:
						v398 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i399)));
					}
					switch(i399 - (l398 - 8)) {
					case 0:
						if(v398) {
							bs398 |= 128;
						} else {
							bs398 &= -129;
						}
						break;
					case 1:
						if(v398) {
							bs398 |= 64;
						} else {
							bs398 &= -65;
						}
						break;
					case 2:
						if(v398) {
							bs398 |= 32;
						} else {
							bs398 &= -33;
						}
						break;
					case 3:
						if(v398) {
							bs398 |= 16;
						} else {
							bs398 &= -17;
						}
						break;
					case 4:
						if(v398) {
							bs398 |= 8;
						} else {
							bs398 &= -9;
						}
						break;
					case 5:
						if(v398) {
							bs398 |= 4;
						} else {
							bs398 &= -5;
						}
						break;
					case 6:
						if(v398) {
							bs398 |= 2;
						} else {
							bs398 &= -3;
						}
						break;
					case 7:
						if(v398) {
							bs398 |= 1;
						} else {
							bs398 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs398;
				break;
			case 89:
				var this400 = 0;
				var bs399 = this400;
				var l399 = "*   *".length;
				var _g1400 = 0;
				var _g500 = l399;
				while(_g1400 < _g500) {
					var i400 = _g1400++;
					var no399 = "*   *".charCodeAt(i400);
					if(no399 == null) {
						break;
					}
					var v399;
					switch(no399) {
					case 32:
						v399 = false;
						break;
					case 42:
						v399 = true;
						break;
					case 48:
						v399 = false;
						break;
					case 49:
						v399 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i400)));
					}
					switch(i400 - (l399 - 8)) {
					case 0:
						if(v399) {
							bs399 |= 128;
						} else {
							bs399 &= -129;
						}
						break;
					case 1:
						if(v399) {
							bs399 |= 64;
						} else {
							bs399 &= -65;
						}
						break;
					case 2:
						if(v399) {
							bs399 |= 32;
						} else {
							bs399 &= -33;
						}
						break;
					case 3:
						if(v399) {
							bs399 |= 16;
						} else {
							bs399 &= -17;
						}
						break;
					case 4:
						if(v399) {
							bs399 |= 8;
						} else {
							bs399 &= -9;
						}
						break;
					case 5:
						if(v399) {
							bs399 |= 4;
						} else {
							bs399 &= -5;
						}
						break;
					case 6:
						if(v399) {
							bs399 |= 2;
						} else {
							bs399 &= -3;
						}
						break;
					case 7:
						if(v399) {
							bs399 |= 1;
						} else {
							bs399 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs399;
				var this401 = 0;
				var bs400 = this401;
				var l400 = "*   *".length;
				var _g1401 = 0;
				var _g501 = l400;
				while(_g1401 < _g501) {
					var i401 = _g1401++;
					var no400 = "*   *".charCodeAt(i401);
					if(no400 == null) {
						break;
					}
					var v400;
					switch(no400) {
					case 32:
						v400 = false;
						break;
					case 42:
						v400 = true;
						break;
					case 48:
						v400 = false;
						break;
					case 49:
						v400 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i401)));
					}
					switch(i401 - (l400 - 8)) {
					case 0:
						if(v400) {
							bs400 |= 128;
						} else {
							bs400 &= -129;
						}
						break;
					case 1:
						if(v400) {
							bs400 |= 64;
						} else {
							bs400 &= -65;
						}
						break;
					case 2:
						if(v400) {
							bs400 |= 32;
						} else {
							bs400 &= -33;
						}
						break;
					case 3:
						if(v400) {
							bs400 |= 16;
						} else {
							bs400 &= -17;
						}
						break;
					case 4:
						if(v400) {
							bs400 |= 8;
						} else {
							bs400 &= -9;
						}
						break;
					case 5:
						if(v400) {
							bs400 |= 4;
						} else {
							bs400 &= -5;
						}
						break;
					case 6:
						if(v400) {
							bs400 |= 2;
						} else {
							bs400 &= -3;
						}
						break;
					case 7:
						if(v400) {
							bs400 |= 1;
						} else {
							bs400 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs400;
				var this402 = 0;
				var bs401 = this402;
				var l401 = "*   *".length;
				var _g1402 = 0;
				var _g502 = l401;
				while(_g1402 < _g502) {
					var i402 = _g1402++;
					var no401 = "*   *".charCodeAt(i402);
					if(no401 == null) {
						break;
					}
					var v401;
					switch(no401) {
					case 32:
						v401 = false;
						break;
					case 42:
						v401 = true;
						break;
					case 48:
						v401 = false;
						break;
					case 49:
						v401 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i402)));
					}
					switch(i402 - (l401 - 8)) {
					case 0:
						if(v401) {
							bs401 |= 128;
						} else {
							bs401 &= -129;
						}
						break;
					case 1:
						if(v401) {
							bs401 |= 64;
						} else {
							bs401 &= -65;
						}
						break;
					case 2:
						if(v401) {
							bs401 |= 32;
						} else {
							bs401 &= -33;
						}
						break;
					case 3:
						if(v401) {
							bs401 |= 16;
						} else {
							bs401 &= -17;
						}
						break;
					case 4:
						if(v401) {
							bs401 |= 8;
						} else {
							bs401 &= -9;
						}
						break;
					case 5:
						if(v401) {
							bs401 |= 4;
						} else {
							bs401 &= -5;
						}
						break;
					case 6:
						if(v401) {
							bs401 |= 2;
						} else {
							bs401 &= -3;
						}
						break;
					case 7:
						if(v401) {
							bs401 |= 1;
						} else {
							bs401 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs401;
				var this403 = 0;
				var bs402 = this403;
				var l402 = " * * ".length;
				var _g1403 = 0;
				var _g503 = l402;
				while(_g1403 < _g503) {
					var i403 = _g1403++;
					var no402 = " * * ".charCodeAt(i403);
					if(no402 == null) {
						break;
					}
					var v402;
					switch(no402) {
					case 32:
						v402 = false;
						break;
					case 42:
						v402 = true;
						break;
					case 48:
						v402 = false;
						break;
					case 49:
						v402 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i403)));
					}
					switch(i403 - (l402 - 8)) {
					case 0:
						if(v402) {
							bs402 |= 128;
						} else {
							bs402 &= -129;
						}
						break;
					case 1:
						if(v402) {
							bs402 |= 64;
						} else {
							bs402 &= -65;
						}
						break;
					case 2:
						if(v402) {
							bs402 |= 32;
						} else {
							bs402 &= -33;
						}
						break;
					case 3:
						if(v402) {
							bs402 |= 16;
						} else {
							bs402 &= -17;
						}
						break;
					case 4:
						if(v402) {
							bs402 |= 8;
						} else {
							bs402 &= -9;
						}
						break;
					case 5:
						if(v402) {
							bs402 |= 4;
						} else {
							bs402 &= -5;
						}
						break;
					case 6:
						if(v402) {
							bs402 |= 2;
						} else {
							bs402 &= -3;
						}
						break;
					case 7:
						if(v402) {
							bs402 |= 1;
						} else {
							bs402 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs402;
				var this404 = 0;
				var bs403 = this404;
				var l403 = "  *  ".length;
				var _g1404 = 0;
				var _g504 = l403;
				while(_g1404 < _g504) {
					var i404 = _g1404++;
					var no403 = "  *  ".charCodeAt(i404);
					if(no403 == null) {
						break;
					}
					var v403;
					switch(no403) {
					case 32:
						v403 = false;
						break;
					case 42:
						v403 = true;
						break;
					case 48:
						v403 = false;
						break;
					case 49:
						v403 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i404)));
					}
					switch(i404 - (l403 - 8)) {
					case 0:
						if(v403) {
							bs403 |= 128;
						} else {
							bs403 &= -129;
						}
						break;
					case 1:
						if(v403) {
							bs403 |= 64;
						} else {
							bs403 &= -65;
						}
						break;
					case 2:
						if(v403) {
							bs403 |= 32;
						} else {
							bs403 &= -33;
						}
						break;
					case 3:
						if(v403) {
							bs403 |= 16;
						} else {
							bs403 &= -17;
						}
						break;
					case 4:
						if(v403) {
							bs403 |= 8;
						} else {
							bs403 &= -9;
						}
						break;
					case 5:
						if(v403) {
							bs403 |= 4;
						} else {
							bs403 &= -5;
						}
						break;
					case 6:
						if(v403) {
							bs403 |= 2;
						} else {
							bs403 &= -3;
						}
						break;
					case 7:
						if(v403) {
							bs403 |= 1;
						} else {
							bs403 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs403;
				var this405 = 0;
				var bs404 = this405;
				var l404 = "  *  ".length;
				var _g1405 = 0;
				var _g505 = l404;
				while(_g1405 < _g505) {
					var i405 = _g1405++;
					var no404 = "  *  ".charCodeAt(i405);
					if(no404 == null) {
						break;
					}
					var v404;
					switch(no404) {
					case 32:
						v404 = false;
						break;
					case 42:
						v404 = true;
						break;
					case 48:
						v404 = false;
						break;
					case 49:
						v404 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i405)));
					}
					switch(i405 - (l404 - 8)) {
					case 0:
						if(v404) {
							bs404 |= 128;
						} else {
							bs404 &= -129;
						}
						break;
					case 1:
						if(v404) {
							bs404 |= 64;
						} else {
							bs404 &= -65;
						}
						break;
					case 2:
						if(v404) {
							bs404 |= 32;
						} else {
							bs404 &= -33;
						}
						break;
					case 3:
						if(v404) {
							bs404 |= 16;
						} else {
							bs404 &= -17;
						}
						break;
					case 4:
						if(v404) {
							bs404 |= 8;
						} else {
							bs404 &= -9;
						}
						break;
					case 5:
						if(v404) {
							bs404 |= 4;
						} else {
							bs404 &= -5;
						}
						break;
					case 6:
						if(v404) {
							bs404 |= 2;
						} else {
							bs404 &= -3;
						}
						break;
					case 7:
						if(v404) {
							bs404 |= 1;
						} else {
							bs404 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs404;
				var this406 = 0;
				var bs405 = this406;
				var l405 = "  *  ".length;
				var _g1406 = 0;
				var _g506 = l405;
				while(_g1406 < _g506) {
					var i406 = _g1406++;
					var no405 = "  *  ".charCodeAt(i406);
					if(no405 == null) {
						break;
					}
					var v405;
					switch(no405) {
					case 32:
						v405 = false;
						break;
					case 42:
						v405 = true;
						break;
					case 48:
						v405 = false;
						break;
					case 49:
						v405 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i406)));
					}
					switch(i406 - (l405 - 8)) {
					case 0:
						if(v405) {
							bs405 |= 128;
						} else {
							bs405 &= -129;
						}
						break;
					case 1:
						if(v405) {
							bs405 |= 64;
						} else {
							bs405 &= -65;
						}
						break;
					case 2:
						if(v405) {
							bs405 |= 32;
						} else {
							bs405 &= -33;
						}
						break;
					case 3:
						if(v405) {
							bs405 |= 16;
						} else {
							bs405 &= -17;
						}
						break;
					case 4:
						if(v405) {
							bs405 |= 8;
						} else {
							bs405 &= -9;
						}
						break;
					case 5:
						if(v405) {
							bs405 |= 4;
						} else {
							bs405 &= -5;
						}
						break;
					case 6:
						if(v405) {
							bs405 |= 2;
						} else {
							bs405 &= -3;
						}
						break;
					case 7:
						if(v405) {
							bs405 |= 1;
						} else {
							bs405 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs405;
				break;
			case 90:
				var this407 = 0;
				var bs406 = this407;
				var l406 = "*****".length;
				var _g1407 = 0;
				var _g507 = l406;
				while(_g1407 < _g507) {
					var i407 = _g1407++;
					var no406 = "*****".charCodeAt(i407);
					if(no406 == null) {
						break;
					}
					var v406;
					switch(no406) {
					case 32:
						v406 = false;
						break;
					case 42:
						v406 = true;
						break;
					case 48:
						v406 = false;
						break;
					case 49:
						v406 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i407)));
					}
					switch(i407 - (l406 - 8)) {
					case 0:
						if(v406) {
							bs406 |= 128;
						} else {
							bs406 &= -129;
						}
						break;
					case 1:
						if(v406) {
							bs406 |= 64;
						} else {
							bs406 &= -65;
						}
						break;
					case 2:
						if(v406) {
							bs406 |= 32;
						} else {
							bs406 &= -33;
						}
						break;
					case 3:
						if(v406) {
							bs406 |= 16;
						} else {
							bs406 &= -17;
						}
						break;
					case 4:
						if(v406) {
							bs406 |= 8;
						} else {
							bs406 &= -9;
						}
						break;
					case 5:
						if(v406) {
							bs406 |= 4;
						} else {
							bs406 &= -5;
						}
						break;
					case 6:
						if(v406) {
							bs406 |= 2;
						} else {
							bs406 &= -3;
						}
						break;
					case 7:
						if(v406) {
							bs406 |= 1;
						} else {
							bs406 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs406;
				var this408 = 0;
				var bs407 = this408;
				var l407 = "    *".length;
				var _g1408 = 0;
				var _g508 = l407;
				while(_g1408 < _g508) {
					var i408 = _g1408++;
					var no407 = "    *".charCodeAt(i408);
					if(no407 == null) {
						break;
					}
					var v407;
					switch(no407) {
					case 32:
						v407 = false;
						break;
					case 42:
						v407 = true;
						break;
					case 48:
						v407 = false;
						break;
					case 49:
						v407 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i408)));
					}
					switch(i408 - (l407 - 8)) {
					case 0:
						if(v407) {
							bs407 |= 128;
						} else {
							bs407 &= -129;
						}
						break;
					case 1:
						if(v407) {
							bs407 |= 64;
						} else {
							bs407 &= -65;
						}
						break;
					case 2:
						if(v407) {
							bs407 |= 32;
						} else {
							bs407 &= -33;
						}
						break;
					case 3:
						if(v407) {
							bs407 |= 16;
						} else {
							bs407 &= -17;
						}
						break;
					case 4:
						if(v407) {
							bs407 |= 8;
						} else {
							bs407 &= -9;
						}
						break;
					case 5:
						if(v407) {
							bs407 |= 4;
						} else {
							bs407 &= -5;
						}
						break;
					case 6:
						if(v407) {
							bs407 |= 2;
						} else {
							bs407 &= -3;
						}
						break;
					case 7:
						if(v407) {
							bs407 |= 1;
						} else {
							bs407 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs407;
				var this409 = 0;
				var bs408 = this409;
				var l408 = "   * ".length;
				var _g1409 = 0;
				var _g509 = l408;
				while(_g1409 < _g509) {
					var i409 = _g1409++;
					var no408 = "   * ".charCodeAt(i409);
					if(no408 == null) {
						break;
					}
					var v408;
					switch(no408) {
					case 32:
						v408 = false;
						break;
					case 42:
						v408 = true;
						break;
					case 48:
						v408 = false;
						break;
					case 49:
						v408 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i409)));
					}
					switch(i409 - (l408 - 8)) {
					case 0:
						if(v408) {
							bs408 |= 128;
						} else {
							bs408 &= -129;
						}
						break;
					case 1:
						if(v408) {
							bs408 |= 64;
						} else {
							bs408 &= -65;
						}
						break;
					case 2:
						if(v408) {
							bs408 |= 32;
						} else {
							bs408 &= -33;
						}
						break;
					case 3:
						if(v408) {
							bs408 |= 16;
						} else {
							bs408 &= -17;
						}
						break;
					case 4:
						if(v408) {
							bs408 |= 8;
						} else {
							bs408 &= -9;
						}
						break;
					case 5:
						if(v408) {
							bs408 |= 4;
						} else {
							bs408 &= -5;
						}
						break;
					case 6:
						if(v408) {
							bs408 |= 2;
						} else {
							bs408 &= -3;
						}
						break;
					case 7:
						if(v408) {
							bs408 |= 1;
						} else {
							bs408 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs408;
				var this410 = 0;
				var bs409 = this410;
				var l409 = "  *  ".length;
				var _g1410 = 0;
				var _g510 = l409;
				while(_g1410 < _g510) {
					var i410 = _g1410++;
					var no409 = "  *  ".charCodeAt(i410);
					if(no409 == null) {
						break;
					}
					var v409;
					switch(no409) {
					case 32:
						v409 = false;
						break;
					case 42:
						v409 = true;
						break;
					case 48:
						v409 = false;
						break;
					case 49:
						v409 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i410)));
					}
					switch(i410 - (l409 - 8)) {
					case 0:
						if(v409) {
							bs409 |= 128;
						} else {
							bs409 &= -129;
						}
						break;
					case 1:
						if(v409) {
							bs409 |= 64;
						} else {
							bs409 &= -65;
						}
						break;
					case 2:
						if(v409) {
							bs409 |= 32;
						} else {
							bs409 &= -33;
						}
						break;
					case 3:
						if(v409) {
							bs409 |= 16;
						} else {
							bs409 &= -17;
						}
						break;
					case 4:
						if(v409) {
							bs409 |= 8;
						} else {
							bs409 &= -9;
						}
						break;
					case 5:
						if(v409) {
							bs409 |= 4;
						} else {
							bs409 &= -5;
						}
						break;
					case 6:
						if(v409) {
							bs409 |= 2;
						} else {
							bs409 &= -3;
						}
						break;
					case 7:
						if(v409) {
							bs409 |= 1;
						} else {
							bs409 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs409;
				var this411 = 0;
				var bs410 = this411;
				var l410 = " *   ".length;
				var _g1411 = 0;
				var _g511 = l410;
				while(_g1411 < _g511) {
					var i411 = _g1411++;
					var no410 = " *   ".charCodeAt(i411);
					if(no410 == null) {
						break;
					}
					var v410;
					switch(no410) {
					case 32:
						v410 = false;
						break;
					case 42:
						v410 = true;
						break;
					case 48:
						v410 = false;
						break;
					case 49:
						v410 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i411)));
					}
					switch(i411 - (l410 - 8)) {
					case 0:
						if(v410) {
							bs410 |= 128;
						} else {
							bs410 &= -129;
						}
						break;
					case 1:
						if(v410) {
							bs410 |= 64;
						} else {
							bs410 &= -65;
						}
						break;
					case 2:
						if(v410) {
							bs410 |= 32;
						} else {
							bs410 &= -33;
						}
						break;
					case 3:
						if(v410) {
							bs410 |= 16;
						} else {
							bs410 &= -17;
						}
						break;
					case 4:
						if(v410) {
							bs410 |= 8;
						} else {
							bs410 &= -9;
						}
						break;
					case 5:
						if(v410) {
							bs410 |= 4;
						} else {
							bs410 &= -5;
						}
						break;
					case 6:
						if(v410) {
							bs410 |= 2;
						} else {
							bs410 &= -3;
						}
						break;
					case 7:
						if(v410) {
							bs410 |= 1;
						} else {
							bs410 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs410;
				var this412 = 0;
				var bs411 = this412;
				var l411 = "*    ".length;
				var _g1412 = 0;
				var _g512 = l411;
				while(_g1412 < _g512) {
					var i412 = _g1412++;
					var no411 = "*    ".charCodeAt(i412);
					if(no411 == null) {
						break;
					}
					var v411;
					switch(no411) {
					case 32:
						v411 = false;
						break;
					case 42:
						v411 = true;
						break;
					case 48:
						v411 = false;
						break;
					case 49:
						v411 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i412)));
					}
					switch(i412 - (l411 - 8)) {
					case 0:
						if(v411) {
							bs411 |= 128;
						} else {
							bs411 &= -129;
						}
						break;
					case 1:
						if(v411) {
							bs411 |= 64;
						} else {
							bs411 &= -65;
						}
						break;
					case 2:
						if(v411) {
							bs411 |= 32;
						} else {
							bs411 &= -33;
						}
						break;
					case 3:
						if(v411) {
							bs411 |= 16;
						} else {
							bs411 &= -17;
						}
						break;
					case 4:
						if(v411) {
							bs411 |= 8;
						} else {
							bs411 &= -9;
						}
						break;
					case 5:
						if(v411) {
							bs411 |= 4;
						} else {
							bs411 &= -5;
						}
						break;
					case 6:
						if(v411) {
							bs411 |= 2;
						} else {
							bs411 &= -3;
						}
						break;
					case 7:
						if(v411) {
							bs411 |= 1;
						} else {
							bs411 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs411;
				var this413 = 0;
				var bs412 = this413;
				var l412 = "*****".length;
				var _g1413 = 0;
				var _g513 = l412;
				while(_g1413 < _g513) {
					var i413 = _g1413++;
					var no412 = "*****".charCodeAt(i413);
					if(no412 == null) {
						break;
					}
					var v412;
					switch(no412) {
					case 32:
						v412 = false;
						break;
					case 42:
						v412 = true;
						break;
					case 48:
						v412 = false;
						break;
					case 49:
						v412 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i413)));
					}
					switch(i413 - (l412 - 8)) {
					case 0:
						if(v412) {
							bs412 |= 128;
						} else {
							bs412 &= -129;
						}
						break;
					case 1:
						if(v412) {
							bs412 |= 64;
						} else {
							bs412 &= -65;
						}
						break;
					case 2:
						if(v412) {
							bs412 |= 32;
						} else {
							bs412 &= -33;
						}
						break;
					case 3:
						if(v412) {
							bs412 |= 16;
						} else {
							bs412 &= -17;
						}
						break;
					case 4:
						if(v412) {
							bs412 |= 8;
						} else {
							bs412 &= -9;
						}
						break;
					case 5:
						if(v412) {
							bs412 |= 4;
						} else {
							bs412 &= -5;
						}
						break;
					case 6:
						if(v412) {
							bs412 |= 2;
						} else {
							bs412 &= -3;
						}
						break;
					case 7:
						if(v412) {
							bs412 |= 1;
						} else {
							bs412 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs412;
				break;
			case 91:
				var this414 = 0;
				var bs413 = this414;
				var l413 = " *** ".length;
				var _g1414 = 0;
				var _g514 = l413;
				while(_g1414 < _g514) {
					var i414 = _g1414++;
					var no413 = " *** ".charCodeAt(i414);
					if(no413 == null) {
						break;
					}
					var v413;
					switch(no413) {
					case 32:
						v413 = false;
						break;
					case 42:
						v413 = true;
						break;
					case 48:
						v413 = false;
						break;
					case 49:
						v413 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i414)));
					}
					switch(i414 - (l413 - 8)) {
					case 0:
						if(v413) {
							bs413 |= 128;
						} else {
							bs413 &= -129;
						}
						break;
					case 1:
						if(v413) {
							bs413 |= 64;
						} else {
							bs413 &= -65;
						}
						break;
					case 2:
						if(v413) {
							bs413 |= 32;
						} else {
							bs413 &= -33;
						}
						break;
					case 3:
						if(v413) {
							bs413 |= 16;
						} else {
							bs413 &= -17;
						}
						break;
					case 4:
						if(v413) {
							bs413 |= 8;
						} else {
							bs413 &= -9;
						}
						break;
					case 5:
						if(v413) {
							bs413 |= 4;
						} else {
							bs413 &= -5;
						}
						break;
					case 6:
						if(v413) {
							bs413 |= 2;
						} else {
							bs413 &= -3;
						}
						break;
					case 7:
						if(v413) {
							bs413 |= 1;
						} else {
							bs413 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs413;
				var this415 = 0;
				var bs414 = this415;
				var l414 = " *   ".length;
				var _g1415 = 0;
				var _g515 = l414;
				while(_g1415 < _g515) {
					var i415 = _g1415++;
					var no414 = " *   ".charCodeAt(i415);
					if(no414 == null) {
						break;
					}
					var v414;
					switch(no414) {
					case 32:
						v414 = false;
						break;
					case 42:
						v414 = true;
						break;
					case 48:
						v414 = false;
						break;
					case 49:
						v414 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i415)));
					}
					switch(i415 - (l414 - 8)) {
					case 0:
						if(v414) {
							bs414 |= 128;
						} else {
							bs414 &= -129;
						}
						break;
					case 1:
						if(v414) {
							bs414 |= 64;
						} else {
							bs414 &= -65;
						}
						break;
					case 2:
						if(v414) {
							bs414 |= 32;
						} else {
							bs414 &= -33;
						}
						break;
					case 3:
						if(v414) {
							bs414 |= 16;
						} else {
							bs414 &= -17;
						}
						break;
					case 4:
						if(v414) {
							bs414 |= 8;
						} else {
							bs414 &= -9;
						}
						break;
					case 5:
						if(v414) {
							bs414 |= 4;
						} else {
							bs414 &= -5;
						}
						break;
					case 6:
						if(v414) {
							bs414 |= 2;
						} else {
							bs414 &= -3;
						}
						break;
					case 7:
						if(v414) {
							bs414 |= 1;
						} else {
							bs414 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs414;
				var this416 = 0;
				var bs415 = this416;
				var l415 = " *   ".length;
				var _g1416 = 0;
				var _g516 = l415;
				while(_g1416 < _g516) {
					var i416 = _g1416++;
					var no415 = " *   ".charCodeAt(i416);
					if(no415 == null) {
						break;
					}
					var v415;
					switch(no415) {
					case 32:
						v415 = false;
						break;
					case 42:
						v415 = true;
						break;
					case 48:
						v415 = false;
						break;
					case 49:
						v415 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i416)));
					}
					switch(i416 - (l415 - 8)) {
					case 0:
						if(v415) {
							bs415 |= 128;
						} else {
							bs415 &= -129;
						}
						break;
					case 1:
						if(v415) {
							bs415 |= 64;
						} else {
							bs415 &= -65;
						}
						break;
					case 2:
						if(v415) {
							bs415 |= 32;
						} else {
							bs415 &= -33;
						}
						break;
					case 3:
						if(v415) {
							bs415 |= 16;
						} else {
							bs415 &= -17;
						}
						break;
					case 4:
						if(v415) {
							bs415 |= 8;
						} else {
							bs415 &= -9;
						}
						break;
					case 5:
						if(v415) {
							bs415 |= 4;
						} else {
							bs415 &= -5;
						}
						break;
					case 6:
						if(v415) {
							bs415 |= 2;
						} else {
							bs415 &= -3;
						}
						break;
					case 7:
						if(v415) {
							bs415 |= 1;
						} else {
							bs415 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs415;
				var this417 = 0;
				var bs416 = this417;
				var l416 = " *   ".length;
				var _g1417 = 0;
				var _g517 = l416;
				while(_g1417 < _g517) {
					var i417 = _g1417++;
					var no416 = " *   ".charCodeAt(i417);
					if(no416 == null) {
						break;
					}
					var v416;
					switch(no416) {
					case 32:
						v416 = false;
						break;
					case 42:
						v416 = true;
						break;
					case 48:
						v416 = false;
						break;
					case 49:
						v416 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i417)));
					}
					switch(i417 - (l416 - 8)) {
					case 0:
						if(v416) {
							bs416 |= 128;
						} else {
							bs416 &= -129;
						}
						break;
					case 1:
						if(v416) {
							bs416 |= 64;
						} else {
							bs416 &= -65;
						}
						break;
					case 2:
						if(v416) {
							bs416 |= 32;
						} else {
							bs416 &= -33;
						}
						break;
					case 3:
						if(v416) {
							bs416 |= 16;
						} else {
							bs416 &= -17;
						}
						break;
					case 4:
						if(v416) {
							bs416 |= 8;
						} else {
							bs416 &= -9;
						}
						break;
					case 5:
						if(v416) {
							bs416 |= 4;
						} else {
							bs416 &= -5;
						}
						break;
					case 6:
						if(v416) {
							bs416 |= 2;
						} else {
							bs416 &= -3;
						}
						break;
					case 7:
						if(v416) {
							bs416 |= 1;
						} else {
							bs416 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs416;
				var this418 = 0;
				var bs417 = this418;
				var l417 = " *   ".length;
				var _g1418 = 0;
				var _g518 = l417;
				while(_g1418 < _g518) {
					var i418 = _g1418++;
					var no417 = " *   ".charCodeAt(i418);
					if(no417 == null) {
						break;
					}
					var v417;
					switch(no417) {
					case 32:
						v417 = false;
						break;
					case 42:
						v417 = true;
						break;
					case 48:
						v417 = false;
						break;
					case 49:
						v417 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i418)));
					}
					switch(i418 - (l417 - 8)) {
					case 0:
						if(v417) {
							bs417 |= 128;
						} else {
							bs417 &= -129;
						}
						break;
					case 1:
						if(v417) {
							bs417 |= 64;
						} else {
							bs417 &= -65;
						}
						break;
					case 2:
						if(v417) {
							bs417 |= 32;
						} else {
							bs417 &= -33;
						}
						break;
					case 3:
						if(v417) {
							bs417 |= 16;
						} else {
							bs417 &= -17;
						}
						break;
					case 4:
						if(v417) {
							bs417 |= 8;
						} else {
							bs417 &= -9;
						}
						break;
					case 5:
						if(v417) {
							bs417 |= 4;
						} else {
							bs417 &= -5;
						}
						break;
					case 6:
						if(v417) {
							bs417 |= 2;
						} else {
							bs417 &= -3;
						}
						break;
					case 7:
						if(v417) {
							bs417 |= 1;
						} else {
							bs417 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs417;
				var this419 = 0;
				var bs418 = this419;
				var l418 = " *   ".length;
				var _g1419 = 0;
				var _g519 = l418;
				while(_g1419 < _g519) {
					var i419 = _g1419++;
					var no418 = " *   ".charCodeAt(i419);
					if(no418 == null) {
						break;
					}
					var v418;
					switch(no418) {
					case 32:
						v418 = false;
						break;
					case 42:
						v418 = true;
						break;
					case 48:
						v418 = false;
						break;
					case 49:
						v418 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i419)));
					}
					switch(i419 - (l418 - 8)) {
					case 0:
						if(v418) {
							bs418 |= 128;
						} else {
							bs418 &= -129;
						}
						break;
					case 1:
						if(v418) {
							bs418 |= 64;
						} else {
							bs418 &= -65;
						}
						break;
					case 2:
						if(v418) {
							bs418 |= 32;
						} else {
							bs418 &= -33;
						}
						break;
					case 3:
						if(v418) {
							bs418 |= 16;
						} else {
							bs418 &= -17;
						}
						break;
					case 4:
						if(v418) {
							bs418 |= 8;
						} else {
							bs418 &= -9;
						}
						break;
					case 5:
						if(v418) {
							bs418 |= 4;
						} else {
							bs418 &= -5;
						}
						break;
					case 6:
						if(v418) {
							bs418 |= 2;
						} else {
							bs418 &= -3;
						}
						break;
					case 7:
						if(v418) {
							bs418 |= 1;
						} else {
							bs418 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs418;
				var this420 = 0;
				var bs419 = this420;
				var l419 = " *** ".length;
				var _g1420 = 0;
				var _g520 = l419;
				while(_g1420 < _g520) {
					var i420 = _g1420++;
					var no419 = " *** ".charCodeAt(i420);
					if(no419 == null) {
						break;
					}
					var v419;
					switch(no419) {
					case 32:
						v419 = false;
						break;
					case 42:
						v419 = true;
						break;
					case 48:
						v419 = false;
						break;
					case 49:
						v419 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i420)));
					}
					switch(i420 - (l419 - 8)) {
					case 0:
						if(v419) {
							bs419 |= 128;
						} else {
							bs419 &= -129;
						}
						break;
					case 1:
						if(v419) {
							bs419 |= 64;
						} else {
							bs419 &= -65;
						}
						break;
					case 2:
						if(v419) {
							bs419 |= 32;
						} else {
							bs419 &= -33;
						}
						break;
					case 3:
						if(v419) {
							bs419 |= 16;
						} else {
							bs419 &= -17;
						}
						break;
					case 4:
						if(v419) {
							bs419 |= 8;
						} else {
							bs419 &= -9;
						}
						break;
					case 5:
						if(v419) {
							bs419 |= 4;
						} else {
							bs419 &= -5;
						}
						break;
					case 6:
						if(v419) {
							bs419 |= 2;
						} else {
							bs419 &= -3;
						}
						break;
					case 7:
						if(v419) {
							bs419 |= 1;
						} else {
							bs419 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs419;
				break;
			case 92:
				var this421 = 0;
				var bs420 = this421;
				var l420 = "*    ".length;
				var _g1421 = 0;
				var _g521 = l420;
				while(_g1421 < _g521) {
					var i421 = _g1421++;
					var no420 = "*    ".charCodeAt(i421);
					if(no420 == null) {
						break;
					}
					var v420;
					switch(no420) {
					case 32:
						v420 = false;
						break;
					case 42:
						v420 = true;
						break;
					case 48:
						v420 = false;
						break;
					case 49:
						v420 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i421)));
					}
					switch(i421 - (l420 - 8)) {
					case 0:
						if(v420) {
							bs420 |= 128;
						} else {
							bs420 &= -129;
						}
						break;
					case 1:
						if(v420) {
							bs420 |= 64;
						} else {
							bs420 &= -65;
						}
						break;
					case 2:
						if(v420) {
							bs420 |= 32;
						} else {
							bs420 &= -33;
						}
						break;
					case 3:
						if(v420) {
							bs420 |= 16;
						} else {
							bs420 &= -17;
						}
						break;
					case 4:
						if(v420) {
							bs420 |= 8;
						} else {
							bs420 &= -9;
						}
						break;
					case 5:
						if(v420) {
							bs420 |= 4;
						} else {
							bs420 &= -5;
						}
						break;
					case 6:
						if(v420) {
							bs420 |= 2;
						} else {
							bs420 &= -3;
						}
						break;
					case 7:
						if(v420) {
							bs420 |= 1;
						} else {
							bs420 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs420;
				var this422 = 0;
				var bs421 = this422;
				var l421 = " *   ".length;
				var _g1422 = 0;
				var _g522 = l421;
				while(_g1422 < _g522) {
					var i422 = _g1422++;
					var no421 = " *   ".charCodeAt(i422);
					if(no421 == null) {
						break;
					}
					var v421;
					switch(no421) {
					case 32:
						v421 = false;
						break;
					case 42:
						v421 = true;
						break;
					case 48:
						v421 = false;
						break;
					case 49:
						v421 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i422)));
					}
					switch(i422 - (l421 - 8)) {
					case 0:
						if(v421) {
							bs421 |= 128;
						} else {
							bs421 &= -129;
						}
						break;
					case 1:
						if(v421) {
							bs421 |= 64;
						} else {
							bs421 &= -65;
						}
						break;
					case 2:
						if(v421) {
							bs421 |= 32;
						} else {
							bs421 &= -33;
						}
						break;
					case 3:
						if(v421) {
							bs421 |= 16;
						} else {
							bs421 &= -17;
						}
						break;
					case 4:
						if(v421) {
							bs421 |= 8;
						} else {
							bs421 &= -9;
						}
						break;
					case 5:
						if(v421) {
							bs421 |= 4;
						} else {
							bs421 &= -5;
						}
						break;
					case 6:
						if(v421) {
							bs421 |= 2;
						} else {
							bs421 &= -3;
						}
						break;
					case 7:
						if(v421) {
							bs421 |= 1;
						} else {
							bs421 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs421;
				var this423 = 0;
				var bs422 = this423;
				var l422 = "  *  ".length;
				var _g1423 = 0;
				var _g523 = l422;
				while(_g1423 < _g523) {
					var i423 = _g1423++;
					var no422 = "  *  ".charCodeAt(i423);
					if(no422 == null) {
						break;
					}
					var v422;
					switch(no422) {
					case 32:
						v422 = false;
						break;
					case 42:
						v422 = true;
						break;
					case 48:
						v422 = false;
						break;
					case 49:
						v422 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i423)));
					}
					switch(i423 - (l422 - 8)) {
					case 0:
						if(v422) {
							bs422 |= 128;
						} else {
							bs422 &= -129;
						}
						break;
					case 1:
						if(v422) {
							bs422 |= 64;
						} else {
							bs422 &= -65;
						}
						break;
					case 2:
						if(v422) {
							bs422 |= 32;
						} else {
							bs422 &= -33;
						}
						break;
					case 3:
						if(v422) {
							bs422 |= 16;
						} else {
							bs422 &= -17;
						}
						break;
					case 4:
						if(v422) {
							bs422 |= 8;
						} else {
							bs422 &= -9;
						}
						break;
					case 5:
						if(v422) {
							bs422 |= 4;
						} else {
							bs422 &= -5;
						}
						break;
					case 6:
						if(v422) {
							bs422 |= 2;
						} else {
							bs422 &= -3;
						}
						break;
					case 7:
						if(v422) {
							bs422 |= 1;
						} else {
							bs422 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs422;
				var this424 = 0;
				var bs423 = this424;
				var l423 = "  *  ".length;
				var _g1424 = 0;
				var _g524 = l423;
				while(_g1424 < _g524) {
					var i424 = _g1424++;
					var no423 = "  *  ".charCodeAt(i424);
					if(no423 == null) {
						break;
					}
					var v423;
					switch(no423) {
					case 32:
						v423 = false;
						break;
					case 42:
						v423 = true;
						break;
					case 48:
						v423 = false;
						break;
					case 49:
						v423 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i424)));
					}
					switch(i424 - (l423 - 8)) {
					case 0:
						if(v423) {
							bs423 |= 128;
						} else {
							bs423 &= -129;
						}
						break;
					case 1:
						if(v423) {
							bs423 |= 64;
						} else {
							bs423 &= -65;
						}
						break;
					case 2:
						if(v423) {
							bs423 |= 32;
						} else {
							bs423 &= -33;
						}
						break;
					case 3:
						if(v423) {
							bs423 |= 16;
						} else {
							bs423 &= -17;
						}
						break;
					case 4:
						if(v423) {
							bs423 |= 8;
						} else {
							bs423 &= -9;
						}
						break;
					case 5:
						if(v423) {
							bs423 |= 4;
						} else {
							bs423 &= -5;
						}
						break;
					case 6:
						if(v423) {
							bs423 |= 2;
						} else {
							bs423 &= -3;
						}
						break;
					case 7:
						if(v423) {
							bs423 |= 1;
						} else {
							bs423 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs423;
				var this425 = 0;
				var bs424 = this425;
				var l424 = "   * ".length;
				var _g1425 = 0;
				var _g525 = l424;
				while(_g1425 < _g525) {
					var i425 = _g1425++;
					var no424 = "   * ".charCodeAt(i425);
					if(no424 == null) {
						break;
					}
					var v424;
					switch(no424) {
					case 32:
						v424 = false;
						break;
					case 42:
						v424 = true;
						break;
					case 48:
						v424 = false;
						break;
					case 49:
						v424 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i425)));
					}
					switch(i425 - (l424 - 8)) {
					case 0:
						if(v424) {
							bs424 |= 128;
						} else {
							bs424 &= -129;
						}
						break;
					case 1:
						if(v424) {
							bs424 |= 64;
						} else {
							bs424 &= -65;
						}
						break;
					case 2:
						if(v424) {
							bs424 |= 32;
						} else {
							bs424 &= -33;
						}
						break;
					case 3:
						if(v424) {
							bs424 |= 16;
						} else {
							bs424 &= -17;
						}
						break;
					case 4:
						if(v424) {
							bs424 |= 8;
						} else {
							bs424 &= -9;
						}
						break;
					case 5:
						if(v424) {
							bs424 |= 4;
						} else {
							bs424 &= -5;
						}
						break;
					case 6:
						if(v424) {
							bs424 |= 2;
						} else {
							bs424 &= -3;
						}
						break;
					case 7:
						if(v424) {
							bs424 |= 1;
						} else {
							bs424 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs424;
				var this426 = 0;
				var bs425 = this426;
				var l425 = "   * ".length;
				var _g1426 = 0;
				var _g526 = l425;
				while(_g1426 < _g526) {
					var i426 = _g1426++;
					var no425 = "   * ".charCodeAt(i426);
					if(no425 == null) {
						break;
					}
					var v425;
					switch(no425) {
					case 32:
						v425 = false;
						break;
					case 42:
						v425 = true;
						break;
					case 48:
						v425 = false;
						break;
					case 49:
						v425 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i426)));
					}
					switch(i426 - (l425 - 8)) {
					case 0:
						if(v425) {
							bs425 |= 128;
						} else {
							bs425 &= -129;
						}
						break;
					case 1:
						if(v425) {
							bs425 |= 64;
						} else {
							bs425 &= -65;
						}
						break;
					case 2:
						if(v425) {
							bs425 |= 32;
						} else {
							bs425 &= -33;
						}
						break;
					case 3:
						if(v425) {
							bs425 |= 16;
						} else {
							bs425 &= -17;
						}
						break;
					case 4:
						if(v425) {
							bs425 |= 8;
						} else {
							bs425 &= -9;
						}
						break;
					case 5:
						if(v425) {
							bs425 |= 4;
						} else {
							bs425 &= -5;
						}
						break;
					case 6:
						if(v425) {
							bs425 |= 2;
						} else {
							bs425 &= -3;
						}
						break;
					case 7:
						if(v425) {
							bs425 |= 1;
						} else {
							bs425 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs425;
				var this427 = 0;
				var bs426 = this427;
				var l426 = "    *".length;
				var _g1427 = 0;
				var _g527 = l426;
				while(_g1427 < _g527) {
					var i427 = _g1427++;
					var no426 = "    *".charCodeAt(i427);
					if(no426 == null) {
						break;
					}
					var v426;
					switch(no426) {
					case 32:
						v426 = false;
						break;
					case 42:
						v426 = true;
						break;
					case 48:
						v426 = false;
						break;
					case 49:
						v426 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i427)));
					}
					switch(i427 - (l426 - 8)) {
					case 0:
						if(v426) {
							bs426 |= 128;
						} else {
							bs426 &= -129;
						}
						break;
					case 1:
						if(v426) {
							bs426 |= 64;
						} else {
							bs426 &= -65;
						}
						break;
					case 2:
						if(v426) {
							bs426 |= 32;
						} else {
							bs426 &= -33;
						}
						break;
					case 3:
						if(v426) {
							bs426 |= 16;
						} else {
							bs426 &= -17;
						}
						break;
					case 4:
						if(v426) {
							bs426 |= 8;
						} else {
							bs426 &= -9;
						}
						break;
					case 5:
						if(v426) {
							bs426 |= 4;
						} else {
							bs426 &= -5;
						}
						break;
					case 6:
						if(v426) {
							bs426 |= 2;
						} else {
							bs426 &= -3;
						}
						break;
					case 7:
						if(v426) {
							bs426 |= 1;
						} else {
							bs426 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs426;
				break;
			case 93:
				var this428 = 0;
				var bs427 = this428;
				var l427 = " *** ".length;
				var _g1428 = 0;
				var _g528 = l427;
				while(_g1428 < _g528) {
					var i428 = _g1428++;
					var no427 = " *** ".charCodeAt(i428);
					if(no427 == null) {
						break;
					}
					var v427;
					switch(no427) {
					case 32:
						v427 = false;
						break;
					case 42:
						v427 = true;
						break;
					case 48:
						v427 = false;
						break;
					case 49:
						v427 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i428)));
					}
					switch(i428 - (l427 - 8)) {
					case 0:
						if(v427) {
							bs427 |= 128;
						} else {
							bs427 &= -129;
						}
						break;
					case 1:
						if(v427) {
							bs427 |= 64;
						} else {
							bs427 &= -65;
						}
						break;
					case 2:
						if(v427) {
							bs427 |= 32;
						} else {
							bs427 &= -33;
						}
						break;
					case 3:
						if(v427) {
							bs427 |= 16;
						} else {
							bs427 &= -17;
						}
						break;
					case 4:
						if(v427) {
							bs427 |= 8;
						} else {
							bs427 &= -9;
						}
						break;
					case 5:
						if(v427) {
							bs427 |= 4;
						} else {
							bs427 &= -5;
						}
						break;
					case 6:
						if(v427) {
							bs427 |= 2;
						} else {
							bs427 &= -3;
						}
						break;
					case 7:
						if(v427) {
							bs427 |= 1;
						} else {
							bs427 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs427;
				var this429 = 0;
				var bs428 = this429;
				var l428 = "   * ".length;
				var _g1429 = 0;
				var _g529 = l428;
				while(_g1429 < _g529) {
					var i429 = _g1429++;
					var no428 = "   * ".charCodeAt(i429);
					if(no428 == null) {
						break;
					}
					var v428;
					switch(no428) {
					case 32:
						v428 = false;
						break;
					case 42:
						v428 = true;
						break;
					case 48:
						v428 = false;
						break;
					case 49:
						v428 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i429)));
					}
					switch(i429 - (l428 - 8)) {
					case 0:
						if(v428) {
							bs428 |= 128;
						} else {
							bs428 &= -129;
						}
						break;
					case 1:
						if(v428) {
							bs428 |= 64;
						} else {
							bs428 &= -65;
						}
						break;
					case 2:
						if(v428) {
							bs428 |= 32;
						} else {
							bs428 &= -33;
						}
						break;
					case 3:
						if(v428) {
							bs428 |= 16;
						} else {
							bs428 &= -17;
						}
						break;
					case 4:
						if(v428) {
							bs428 |= 8;
						} else {
							bs428 &= -9;
						}
						break;
					case 5:
						if(v428) {
							bs428 |= 4;
						} else {
							bs428 &= -5;
						}
						break;
					case 6:
						if(v428) {
							bs428 |= 2;
						} else {
							bs428 &= -3;
						}
						break;
					case 7:
						if(v428) {
							bs428 |= 1;
						} else {
							bs428 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs428;
				var this430 = 0;
				var bs429 = this430;
				var l429 = "   * ".length;
				var _g1430 = 0;
				var _g530 = l429;
				while(_g1430 < _g530) {
					var i430 = _g1430++;
					var no429 = "   * ".charCodeAt(i430);
					if(no429 == null) {
						break;
					}
					var v429;
					switch(no429) {
					case 32:
						v429 = false;
						break;
					case 42:
						v429 = true;
						break;
					case 48:
						v429 = false;
						break;
					case 49:
						v429 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i430)));
					}
					switch(i430 - (l429 - 8)) {
					case 0:
						if(v429) {
							bs429 |= 128;
						} else {
							bs429 &= -129;
						}
						break;
					case 1:
						if(v429) {
							bs429 |= 64;
						} else {
							bs429 &= -65;
						}
						break;
					case 2:
						if(v429) {
							bs429 |= 32;
						} else {
							bs429 &= -33;
						}
						break;
					case 3:
						if(v429) {
							bs429 |= 16;
						} else {
							bs429 &= -17;
						}
						break;
					case 4:
						if(v429) {
							bs429 |= 8;
						} else {
							bs429 &= -9;
						}
						break;
					case 5:
						if(v429) {
							bs429 |= 4;
						} else {
							bs429 &= -5;
						}
						break;
					case 6:
						if(v429) {
							bs429 |= 2;
						} else {
							bs429 &= -3;
						}
						break;
					case 7:
						if(v429) {
							bs429 |= 1;
						} else {
							bs429 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs429;
				var this431 = 0;
				var bs430 = this431;
				var l430 = "   * ".length;
				var _g1431 = 0;
				var _g531 = l430;
				while(_g1431 < _g531) {
					var i431 = _g1431++;
					var no430 = "   * ".charCodeAt(i431);
					if(no430 == null) {
						break;
					}
					var v430;
					switch(no430) {
					case 32:
						v430 = false;
						break;
					case 42:
						v430 = true;
						break;
					case 48:
						v430 = false;
						break;
					case 49:
						v430 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i431)));
					}
					switch(i431 - (l430 - 8)) {
					case 0:
						if(v430) {
							bs430 |= 128;
						} else {
							bs430 &= -129;
						}
						break;
					case 1:
						if(v430) {
							bs430 |= 64;
						} else {
							bs430 &= -65;
						}
						break;
					case 2:
						if(v430) {
							bs430 |= 32;
						} else {
							bs430 &= -33;
						}
						break;
					case 3:
						if(v430) {
							bs430 |= 16;
						} else {
							bs430 &= -17;
						}
						break;
					case 4:
						if(v430) {
							bs430 |= 8;
						} else {
							bs430 &= -9;
						}
						break;
					case 5:
						if(v430) {
							bs430 |= 4;
						} else {
							bs430 &= -5;
						}
						break;
					case 6:
						if(v430) {
							bs430 |= 2;
						} else {
							bs430 &= -3;
						}
						break;
					case 7:
						if(v430) {
							bs430 |= 1;
						} else {
							bs430 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs430;
				var this432 = 0;
				var bs431 = this432;
				var l431 = "   * ".length;
				var _g1432 = 0;
				var _g532 = l431;
				while(_g1432 < _g532) {
					var i432 = _g1432++;
					var no431 = "   * ".charCodeAt(i432);
					if(no431 == null) {
						break;
					}
					var v431;
					switch(no431) {
					case 32:
						v431 = false;
						break;
					case 42:
						v431 = true;
						break;
					case 48:
						v431 = false;
						break;
					case 49:
						v431 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i432)));
					}
					switch(i432 - (l431 - 8)) {
					case 0:
						if(v431) {
							bs431 |= 128;
						} else {
							bs431 &= -129;
						}
						break;
					case 1:
						if(v431) {
							bs431 |= 64;
						} else {
							bs431 &= -65;
						}
						break;
					case 2:
						if(v431) {
							bs431 |= 32;
						} else {
							bs431 &= -33;
						}
						break;
					case 3:
						if(v431) {
							bs431 |= 16;
						} else {
							bs431 &= -17;
						}
						break;
					case 4:
						if(v431) {
							bs431 |= 8;
						} else {
							bs431 &= -9;
						}
						break;
					case 5:
						if(v431) {
							bs431 |= 4;
						} else {
							bs431 &= -5;
						}
						break;
					case 6:
						if(v431) {
							bs431 |= 2;
						} else {
							bs431 &= -3;
						}
						break;
					case 7:
						if(v431) {
							bs431 |= 1;
						} else {
							bs431 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs431;
				var this433 = 0;
				var bs432 = this433;
				var l432 = "   * ".length;
				var _g1433 = 0;
				var _g533 = l432;
				while(_g1433 < _g533) {
					var i433 = _g1433++;
					var no432 = "   * ".charCodeAt(i433);
					if(no432 == null) {
						break;
					}
					var v432;
					switch(no432) {
					case 32:
						v432 = false;
						break;
					case 42:
						v432 = true;
						break;
					case 48:
						v432 = false;
						break;
					case 49:
						v432 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i433)));
					}
					switch(i433 - (l432 - 8)) {
					case 0:
						if(v432) {
							bs432 |= 128;
						} else {
							bs432 &= -129;
						}
						break;
					case 1:
						if(v432) {
							bs432 |= 64;
						} else {
							bs432 &= -65;
						}
						break;
					case 2:
						if(v432) {
							bs432 |= 32;
						} else {
							bs432 &= -33;
						}
						break;
					case 3:
						if(v432) {
							bs432 |= 16;
						} else {
							bs432 &= -17;
						}
						break;
					case 4:
						if(v432) {
							bs432 |= 8;
						} else {
							bs432 &= -9;
						}
						break;
					case 5:
						if(v432) {
							bs432 |= 4;
						} else {
							bs432 &= -5;
						}
						break;
					case 6:
						if(v432) {
							bs432 |= 2;
						} else {
							bs432 &= -3;
						}
						break;
					case 7:
						if(v432) {
							bs432 |= 1;
						} else {
							bs432 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs432;
				var this434 = 0;
				var bs433 = this434;
				var l433 = " *** ".length;
				var _g1434 = 0;
				var _g534 = l433;
				while(_g1434 < _g534) {
					var i434 = _g1434++;
					var no433 = " *** ".charCodeAt(i434);
					if(no433 == null) {
						break;
					}
					var v433;
					switch(no433) {
					case 32:
						v433 = false;
						break;
					case 42:
						v433 = true;
						break;
					case 48:
						v433 = false;
						break;
					case 49:
						v433 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i434)));
					}
					switch(i434 - (l433 - 8)) {
					case 0:
						if(v433) {
							bs433 |= 128;
						} else {
							bs433 &= -129;
						}
						break;
					case 1:
						if(v433) {
							bs433 |= 64;
						} else {
							bs433 &= -65;
						}
						break;
					case 2:
						if(v433) {
							bs433 |= 32;
						} else {
							bs433 &= -33;
						}
						break;
					case 3:
						if(v433) {
							bs433 |= 16;
						} else {
							bs433 &= -17;
						}
						break;
					case 4:
						if(v433) {
							bs433 |= 8;
						} else {
							bs433 &= -9;
						}
						break;
					case 5:
						if(v433) {
							bs433 |= 4;
						} else {
							bs433 &= -5;
						}
						break;
					case 6:
						if(v433) {
							bs433 |= 2;
						} else {
							bs433 &= -3;
						}
						break;
					case 7:
						if(v433) {
							bs433 |= 1;
						} else {
							bs433 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs433;
				break;
			case 94:
				var this435 = 0;
				var bs434 = this435;
				var l434 = "  *  ".length;
				var _g1435 = 0;
				var _g535 = l434;
				while(_g1435 < _g535) {
					var i435 = _g1435++;
					var no434 = "  *  ".charCodeAt(i435);
					if(no434 == null) {
						break;
					}
					var v434;
					switch(no434) {
					case 32:
						v434 = false;
						break;
					case 42:
						v434 = true;
						break;
					case 48:
						v434 = false;
						break;
					case 49:
						v434 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i435)));
					}
					switch(i435 - (l434 - 8)) {
					case 0:
						if(v434) {
							bs434 |= 128;
						} else {
							bs434 &= -129;
						}
						break;
					case 1:
						if(v434) {
							bs434 |= 64;
						} else {
							bs434 &= -65;
						}
						break;
					case 2:
						if(v434) {
							bs434 |= 32;
						} else {
							bs434 &= -33;
						}
						break;
					case 3:
						if(v434) {
							bs434 |= 16;
						} else {
							bs434 &= -17;
						}
						break;
					case 4:
						if(v434) {
							bs434 |= 8;
						} else {
							bs434 &= -9;
						}
						break;
					case 5:
						if(v434) {
							bs434 |= 4;
						} else {
							bs434 &= -5;
						}
						break;
					case 6:
						if(v434) {
							bs434 |= 2;
						} else {
							bs434 &= -3;
						}
						break;
					case 7:
						if(v434) {
							bs434 |= 1;
						} else {
							bs434 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs434;
				var this436 = 0;
				var bs435 = this436;
				var l435 = " * * ".length;
				var _g1436 = 0;
				var _g536 = l435;
				while(_g1436 < _g536) {
					var i436 = _g1436++;
					var no435 = " * * ".charCodeAt(i436);
					if(no435 == null) {
						break;
					}
					var v435;
					switch(no435) {
					case 32:
						v435 = false;
						break;
					case 42:
						v435 = true;
						break;
					case 48:
						v435 = false;
						break;
					case 49:
						v435 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i436)));
					}
					switch(i436 - (l435 - 8)) {
					case 0:
						if(v435) {
							bs435 |= 128;
						} else {
							bs435 &= -129;
						}
						break;
					case 1:
						if(v435) {
							bs435 |= 64;
						} else {
							bs435 &= -65;
						}
						break;
					case 2:
						if(v435) {
							bs435 |= 32;
						} else {
							bs435 &= -33;
						}
						break;
					case 3:
						if(v435) {
							bs435 |= 16;
						} else {
							bs435 &= -17;
						}
						break;
					case 4:
						if(v435) {
							bs435 |= 8;
						} else {
							bs435 &= -9;
						}
						break;
					case 5:
						if(v435) {
							bs435 |= 4;
						} else {
							bs435 &= -5;
						}
						break;
					case 6:
						if(v435) {
							bs435 |= 2;
						} else {
							bs435 &= -3;
						}
						break;
					case 7:
						if(v435) {
							bs435 |= 1;
						} else {
							bs435 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs435;
				var this437 = 0;
				var bs436 = this437;
				var l436 = "*   *".length;
				var _g1437 = 0;
				var _g537 = l436;
				while(_g1437 < _g537) {
					var i437 = _g1437++;
					var no436 = "*   *".charCodeAt(i437);
					if(no436 == null) {
						break;
					}
					var v436;
					switch(no436) {
					case 32:
						v436 = false;
						break;
					case 42:
						v436 = true;
						break;
					case 48:
						v436 = false;
						break;
					case 49:
						v436 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i437)));
					}
					switch(i437 - (l436 - 8)) {
					case 0:
						if(v436) {
							bs436 |= 128;
						} else {
							bs436 &= -129;
						}
						break;
					case 1:
						if(v436) {
							bs436 |= 64;
						} else {
							bs436 &= -65;
						}
						break;
					case 2:
						if(v436) {
							bs436 |= 32;
						} else {
							bs436 &= -33;
						}
						break;
					case 3:
						if(v436) {
							bs436 |= 16;
						} else {
							bs436 &= -17;
						}
						break;
					case 4:
						if(v436) {
							bs436 |= 8;
						} else {
							bs436 &= -9;
						}
						break;
					case 5:
						if(v436) {
							bs436 |= 4;
						} else {
							bs436 &= -5;
						}
						break;
					case 6:
						if(v436) {
							bs436 |= 2;
						} else {
							bs436 &= -3;
						}
						break;
					case 7:
						if(v436) {
							bs436 |= 1;
						} else {
							bs436 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs436;
				var this438 = 0;
				var bs437 = this438;
				var l437 = "     ".length;
				var _g1438 = 0;
				var _g538 = l437;
				while(_g1438 < _g538) {
					var i438 = _g1438++;
					var no437 = "     ".charCodeAt(i438);
					if(no437 == null) {
						break;
					}
					var v437;
					switch(no437) {
					case 32:
						v437 = false;
						break;
					case 42:
						v437 = true;
						break;
					case 48:
						v437 = false;
						break;
					case 49:
						v437 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i438)));
					}
					switch(i438 - (l437 - 8)) {
					case 0:
						if(v437) {
							bs437 |= 128;
						} else {
							bs437 &= -129;
						}
						break;
					case 1:
						if(v437) {
							bs437 |= 64;
						} else {
							bs437 &= -65;
						}
						break;
					case 2:
						if(v437) {
							bs437 |= 32;
						} else {
							bs437 &= -33;
						}
						break;
					case 3:
						if(v437) {
							bs437 |= 16;
						} else {
							bs437 &= -17;
						}
						break;
					case 4:
						if(v437) {
							bs437 |= 8;
						} else {
							bs437 &= -9;
						}
						break;
					case 5:
						if(v437) {
							bs437 |= 4;
						} else {
							bs437 &= -5;
						}
						break;
					case 6:
						if(v437) {
							bs437 |= 2;
						} else {
							bs437 &= -3;
						}
						break;
					case 7:
						if(v437) {
							bs437 |= 1;
						} else {
							bs437 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs437;
				var this439 = 0;
				var bs438 = this439;
				var l438 = "     ".length;
				var _g1439 = 0;
				var _g539 = l438;
				while(_g1439 < _g539) {
					var i439 = _g1439++;
					var no438 = "     ".charCodeAt(i439);
					if(no438 == null) {
						break;
					}
					var v438;
					switch(no438) {
					case 32:
						v438 = false;
						break;
					case 42:
						v438 = true;
						break;
					case 48:
						v438 = false;
						break;
					case 49:
						v438 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i439)));
					}
					switch(i439 - (l438 - 8)) {
					case 0:
						if(v438) {
							bs438 |= 128;
						} else {
							bs438 &= -129;
						}
						break;
					case 1:
						if(v438) {
							bs438 |= 64;
						} else {
							bs438 &= -65;
						}
						break;
					case 2:
						if(v438) {
							bs438 |= 32;
						} else {
							bs438 &= -33;
						}
						break;
					case 3:
						if(v438) {
							bs438 |= 16;
						} else {
							bs438 &= -17;
						}
						break;
					case 4:
						if(v438) {
							bs438 |= 8;
						} else {
							bs438 &= -9;
						}
						break;
					case 5:
						if(v438) {
							bs438 |= 4;
						} else {
							bs438 &= -5;
						}
						break;
					case 6:
						if(v438) {
							bs438 |= 2;
						} else {
							bs438 &= -3;
						}
						break;
					case 7:
						if(v438) {
							bs438 |= 1;
						} else {
							bs438 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs438;
				var this440 = 0;
				var bs439 = this440;
				var l439 = "     ".length;
				var _g1440 = 0;
				var _g540 = l439;
				while(_g1440 < _g540) {
					var i440 = _g1440++;
					var no439 = "     ".charCodeAt(i440);
					if(no439 == null) {
						break;
					}
					var v439;
					switch(no439) {
					case 32:
						v439 = false;
						break;
					case 42:
						v439 = true;
						break;
					case 48:
						v439 = false;
						break;
					case 49:
						v439 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i440)));
					}
					switch(i440 - (l439 - 8)) {
					case 0:
						if(v439) {
							bs439 |= 128;
						} else {
							bs439 &= -129;
						}
						break;
					case 1:
						if(v439) {
							bs439 |= 64;
						} else {
							bs439 &= -65;
						}
						break;
					case 2:
						if(v439) {
							bs439 |= 32;
						} else {
							bs439 &= -33;
						}
						break;
					case 3:
						if(v439) {
							bs439 |= 16;
						} else {
							bs439 &= -17;
						}
						break;
					case 4:
						if(v439) {
							bs439 |= 8;
						} else {
							bs439 &= -9;
						}
						break;
					case 5:
						if(v439) {
							bs439 |= 4;
						} else {
							bs439 &= -5;
						}
						break;
					case 6:
						if(v439) {
							bs439 |= 2;
						} else {
							bs439 &= -3;
						}
						break;
					case 7:
						if(v439) {
							bs439 |= 1;
						} else {
							bs439 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs439;
				var this441 = 0;
				var bs440 = this441;
				var l440 = "     ".length;
				var _g1441 = 0;
				var _g541 = l440;
				while(_g1441 < _g541) {
					var i441 = _g1441++;
					var no440 = "     ".charCodeAt(i441);
					if(no440 == null) {
						break;
					}
					var v440;
					switch(no440) {
					case 32:
						v440 = false;
						break;
					case 42:
						v440 = true;
						break;
					case 48:
						v440 = false;
						break;
					case 49:
						v440 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i441)));
					}
					switch(i441 - (l440 - 8)) {
					case 0:
						if(v440) {
							bs440 |= 128;
						} else {
							bs440 &= -129;
						}
						break;
					case 1:
						if(v440) {
							bs440 |= 64;
						} else {
							bs440 &= -65;
						}
						break;
					case 2:
						if(v440) {
							bs440 |= 32;
						} else {
							bs440 &= -33;
						}
						break;
					case 3:
						if(v440) {
							bs440 |= 16;
						} else {
							bs440 &= -17;
						}
						break;
					case 4:
						if(v440) {
							bs440 |= 8;
						} else {
							bs440 &= -9;
						}
						break;
					case 5:
						if(v440) {
							bs440 |= 4;
						} else {
							bs440 &= -5;
						}
						break;
					case 6:
						if(v440) {
							bs440 |= 2;
						} else {
							bs440 &= -3;
						}
						break;
					case 7:
						if(v440) {
							bs440 |= 1;
						} else {
							bs440 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs440;
				break;
			case 95:
				var this442 = 0;
				var bs441 = this442;
				var l441 = "     ".length;
				var _g1442 = 0;
				var _g542 = l441;
				while(_g1442 < _g542) {
					var i442 = _g1442++;
					var no441 = "     ".charCodeAt(i442);
					if(no441 == null) {
						break;
					}
					var v441;
					switch(no441) {
					case 32:
						v441 = false;
						break;
					case 42:
						v441 = true;
						break;
					case 48:
						v441 = false;
						break;
					case 49:
						v441 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i442)));
					}
					switch(i442 - (l441 - 8)) {
					case 0:
						if(v441) {
							bs441 |= 128;
						} else {
							bs441 &= -129;
						}
						break;
					case 1:
						if(v441) {
							bs441 |= 64;
						} else {
							bs441 &= -65;
						}
						break;
					case 2:
						if(v441) {
							bs441 |= 32;
						} else {
							bs441 &= -33;
						}
						break;
					case 3:
						if(v441) {
							bs441 |= 16;
						} else {
							bs441 &= -17;
						}
						break;
					case 4:
						if(v441) {
							bs441 |= 8;
						} else {
							bs441 &= -9;
						}
						break;
					case 5:
						if(v441) {
							bs441 |= 4;
						} else {
							bs441 &= -5;
						}
						break;
					case 6:
						if(v441) {
							bs441 |= 2;
						} else {
							bs441 &= -3;
						}
						break;
					case 7:
						if(v441) {
							bs441 |= 1;
						} else {
							bs441 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs441;
				var this443 = 0;
				var bs442 = this443;
				var l442 = "     ".length;
				var _g1443 = 0;
				var _g543 = l442;
				while(_g1443 < _g543) {
					var i443 = _g1443++;
					var no442 = "     ".charCodeAt(i443);
					if(no442 == null) {
						break;
					}
					var v442;
					switch(no442) {
					case 32:
						v442 = false;
						break;
					case 42:
						v442 = true;
						break;
					case 48:
						v442 = false;
						break;
					case 49:
						v442 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i443)));
					}
					switch(i443 - (l442 - 8)) {
					case 0:
						if(v442) {
							bs442 |= 128;
						} else {
							bs442 &= -129;
						}
						break;
					case 1:
						if(v442) {
							bs442 |= 64;
						} else {
							bs442 &= -65;
						}
						break;
					case 2:
						if(v442) {
							bs442 |= 32;
						} else {
							bs442 &= -33;
						}
						break;
					case 3:
						if(v442) {
							bs442 |= 16;
						} else {
							bs442 &= -17;
						}
						break;
					case 4:
						if(v442) {
							bs442 |= 8;
						} else {
							bs442 &= -9;
						}
						break;
					case 5:
						if(v442) {
							bs442 |= 4;
						} else {
							bs442 &= -5;
						}
						break;
					case 6:
						if(v442) {
							bs442 |= 2;
						} else {
							bs442 &= -3;
						}
						break;
					case 7:
						if(v442) {
							bs442 |= 1;
						} else {
							bs442 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs442;
				var this444 = 0;
				var bs443 = this444;
				var l443 = "     ".length;
				var _g1444 = 0;
				var _g544 = l443;
				while(_g1444 < _g544) {
					var i444 = _g1444++;
					var no443 = "     ".charCodeAt(i444);
					if(no443 == null) {
						break;
					}
					var v443;
					switch(no443) {
					case 32:
						v443 = false;
						break;
					case 42:
						v443 = true;
						break;
					case 48:
						v443 = false;
						break;
					case 49:
						v443 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i444)));
					}
					switch(i444 - (l443 - 8)) {
					case 0:
						if(v443) {
							bs443 |= 128;
						} else {
							bs443 &= -129;
						}
						break;
					case 1:
						if(v443) {
							bs443 |= 64;
						} else {
							bs443 &= -65;
						}
						break;
					case 2:
						if(v443) {
							bs443 |= 32;
						} else {
							bs443 &= -33;
						}
						break;
					case 3:
						if(v443) {
							bs443 |= 16;
						} else {
							bs443 &= -17;
						}
						break;
					case 4:
						if(v443) {
							bs443 |= 8;
						} else {
							bs443 &= -9;
						}
						break;
					case 5:
						if(v443) {
							bs443 |= 4;
						} else {
							bs443 &= -5;
						}
						break;
					case 6:
						if(v443) {
							bs443 |= 2;
						} else {
							bs443 &= -3;
						}
						break;
					case 7:
						if(v443) {
							bs443 |= 1;
						} else {
							bs443 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs443;
				var this445 = 0;
				var bs444 = this445;
				var l444 = "     ".length;
				var _g1445 = 0;
				var _g545 = l444;
				while(_g1445 < _g545) {
					var i445 = _g1445++;
					var no444 = "     ".charCodeAt(i445);
					if(no444 == null) {
						break;
					}
					var v444;
					switch(no444) {
					case 32:
						v444 = false;
						break;
					case 42:
						v444 = true;
						break;
					case 48:
						v444 = false;
						break;
					case 49:
						v444 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i445)));
					}
					switch(i445 - (l444 - 8)) {
					case 0:
						if(v444) {
							bs444 |= 128;
						} else {
							bs444 &= -129;
						}
						break;
					case 1:
						if(v444) {
							bs444 |= 64;
						} else {
							bs444 &= -65;
						}
						break;
					case 2:
						if(v444) {
							bs444 |= 32;
						} else {
							bs444 &= -33;
						}
						break;
					case 3:
						if(v444) {
							bs444 |= 16;
						} else {
							bs444 &= -17;
						}
						break;
					case 4:
						if(v444) {
							bs444 |= 8;
						} else {
							bs444 &= -9;
						}
						break;
					case 5:
						if(v444) {
							bs444 |= 4;
						} else {
							bs444 &= -5;
						}
						break;
					case 6:
						if(v444) {
							bs444 |= 2;
						} else {
							bs444 &= -3;
						}
						break;
					case 7:
						if(v444) {
							bs444 |= 1;
						} else {
							bs444 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs444;
				var this446 = 0;
				var bs445 = this446;
				var l445 = "     ".length;
				var _g1446 = 0;
				var _g546 = l445;
				while(_g1446 < _g546) {
					var i446 = _g1446++;
					var no445 = "     ".charCodeAt(i446);
					if(no445 == null) {
						break;
					}
					var v445;
					switch(no445) {
					case 32:
						v445 = false;
						break;
					case 42:
						v445 = true;
						break;
					case 48:
						v445 = false;
						break;
					case 49:
						v445 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i446)));
					}
					switch(i446 - (l445 - 8)) {
					case 0:
						if(v445) {
							bs445 |= 128;
						} else {
							bs445 &= -129;
						}
						break;
					case 1:
						if(v445) {
							bs445 |= 64;
						} else {
							bs445 &= -65;
						}
						break;
					case 2:
						if(v445) {
							bs445 |= 32;
						} else {
							bs445 &= -33;
						}
						break;
					case 3:
						if(v445) {
							bs445 |= 16;
						} else {
							bs445 &= -17;
						}
						break;
					case 4:
						if(v445) {
							bs445 |= 8;
						} else {
							bs445 &= -9;
						}
						break;
					case 5:
						if(v445) {
							bs445 |= 4;
						} else {
							bs445 &= -5;
						}
						break;
					case 6:
						if(v445) {
							bs445 |= 2;
						} else {
							bs445 &= -3;
						}
						break;
					case 7:
						if(v445) {
							bs445 |= 1;
						} else {
							bs445 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs445;
				var this447 = 0;
				var bs446 = this447;
				var l446 = "     ".length;
				var _g1447 = 0;
				var _g547 = l446;
				while(_g1447 < _g547) {
					var i447 = _g1447++;
					var no446 = "     ".charCodeAt(i447);
					if(no446 == null) {
						break;
					}
					var v446;
					switch(no446) {
					case 32:
						v446 = false;
						break;
					case 42:
						v446 = true;
						break;
					case 48:
						v446 = false;
						break;
					case 49:
						v446 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i447)));
					}
					switch(i447 - (l446 - 8)) {
					case 0:
						if(v446) {
							bs446 |= 128;
						} else {
							bs446 &= -129;
						}
						break;
					case 1:
						if(v446) {
							bs446 |= 64;
						} else {
							bs446 &= -65;
						}
						break;
					case 2:
						if(v446) {
							bs446 |= 32;
						} else {
							bs446 &= -33;
						}
						break;
					case 3:
						if(v446) {
							bs446 |= 16;
						} else {
							bs446 &= -17;
						}
						break;
					case 4:
						if(v446) {
							bs446 |= 8;
						} else {
							bs446 &= -9;
						}
						break;
					case 5:
						if(v446) {
							bs446 |= 4;
						} else {
							bs446 &= -5;
						}
						break;
					case 6:
						if(v446) {
							bs446 |= 2;
						} else {
							bs446 &= -3;
						}
						break;
					case 7:
						if(v446) {
							bs446 |= 1;
						} else {
							bs446 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs446;
				var this448 = 0;
				var bs447 = this448;
				var l447 = "*****".length;
				var _g1448 = 0;
				var _g548 = l447;
				while(_g1448 < _g548) {
					var i448 = _g1448++;
					var no447 = "*****".charCodeAt(i448);
					if(no447 == null) {
						break;
					}
					var v447;
					switch(no447) {
					case 32:
						v447 = false;
						break;
					case 42:
						v447 = true;
						break;
					case 48:
						v447 = false;
						break;
					case 49:
						v447 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i448)));
					}
					switch(i448 - (l447 - 8)) {
					case 0:
						if(v447) {
							bs447 |= 128;
						} else {
							bs447 &= -129;
						}
						break;
					case 1:
						if(v447) {
							bs447 |= 64;
						} else {
							bs447 &= -65;
						}
						break;
					case 2:
						if(v447) {
							bs447 |= 32;
						} else {
							bs447 &= -33;
						}
						break;
					case 3:
						if(v447) {
							bs447 |= 16;
						} else {
							bs447 &= -17;
						}
						break;
					case 4:
						if(v447) {
							bs447 |= 8;
						} else {
							bs447 &= -9;
						}
						break;
					case 5:
						if(v447) {
							bs447 |= 4;
						} else {
							bs447 &= -5;
						}
						break;
					case 6:
						if(v447) {
							bs447 |= 2;
						} else {
							bs447 &= -3;
						}
						break;
					case 7:
						if(v447) {
							bs447 |= 1;
						} else {
							bs447 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs447;
				break;
			case 96:
				var this449 = 0;
				var bs448 = this449;
				var l448 = "*    ".length;
				var _g1449 = 0;
				var _g549 = l448;
				while(_g1449 < _g549) {
					var i449 = _g1449++;
					var no448 = "*    ".charCodeAt(i449);
					if(no448 == null) {
						break;
					}
					var v448;
					switch(no448) {
					case 32:
						v448 = false;
						break;
					case 42:
						v448 = true;
						break;
					case 48:
						v448 = false;
						break;
					case 49:
						v448 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i449)));
					}
					switch(i449 - (l448 - 8)) {
					case 0:
						if(v448) {
							bs448 |= 128;
						} else {
							bs448 &= -129;
						}
						break;
					case 1:
						if(v448) {
							bs448 |= 64;
						} else {
							bs448 &= -65;
						}
						break;
					case 2:
						if(v448) {
							bs448 |= 32;
						} else {
							bs448 &= -33;
						}
						break;
					case 3:
						if(v448) {
							bs448 |= 16;
						} else {
							bs448 &= -17;
						}
						break;
					case 4:
						if(v448) {
							bs448 |= 8;
						} else {
							bs448 &= -9;
						}
						break;
					case 5:
						if(v448) {
							bs448 |= 4;
						} else {
							bs448 &= -5;
						}
						break;
					case 6:
						if(v448) {
							bs448 |= 2;
						} else {
							bs448 &= -3;
						}
						break;
					case 7:
						if(v448) {
							bs448 |= 1;
						} else {
							bs448 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs448;
				var this450 = 0;
				var bs449 = this450;
				var l449 = " *   ".length;
				var _g1450 = 0;
				var _g550 = l449;
				while(_g1450 < _g550) {
					var i450 = _g1450++;
					var no449 = " *   ".charCodeAt(i450);
					if(no449 == null) {
						break;
					}
					var v449;
					switch(no449) {
					case 32:
						v449 = false;
						break;
					case 42:
						v449 = true;
						break;
					case 48:
						v449 = false;
						break;
					case 49:
						v449 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i450)));
					}
					switch(i450 - (l449 - 8)) {
					case 0:
						if(v449) {
							bs449 |= 128;
						} else {
							bs449 &= -129;
						}
						break;
					case 1:
						if(v449) {
							bs449 |= 64;
						} else {
							bs449 &= -65;
						}
						break;
					case 2:
						if(v449) {
							bs449 |= 32;
						} else {
							bs449 &= -33;
						}
						break;
					case 3:
						if(v449) {
							bs449 |= 16;
						} else {
							bs449 &= -17;
						}
						break;
					case 4:
						if(v449) {
							bs449 |= 8;
						} else {
							bs449 &= -9;
						}
						break;
					case 5:
						if(v449) {
							bs449 |= 4;
						} else {
							bs449 &= -5;
						}
						break;
					case 6:
						if(v449) {
							bs449 |= 2;
						} else {
							bs449 &= -3;
						}
						break;
					case 7:
						if(v449) {
							bs449 |= 1;
						} else {
							bs449 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs449;
				var this451 = 0;
				var bs450 = this451;
				var l450 = "     ".length;
				var _g1451 = 0;
				var _g551 = l450;
				while(_g1451 < _g551) {
					var i451 = _g1451++;
					var no450 = "     ".charCodeAt(i451);
					if(no450 == null) {
						break;
					}
					var v450;
					switch(no450) {
					case 32:
						v450 = false;
						break;
					case 42:
						v450 = true;
						break;
					case 48:
						v450 = false;
						break;
					case 49:
						v450 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i451)));
					}
					switch(i451 - (l450 - 8)) {
					case 0:
						if(v450) {
							bs450 |= 128;
						} else {
							bs450 &= -129;
						}
						break;
					case 1:
						if(v450) {
							bs450 |= 64;
						} else {
							bs450 &= -65;
						}
						break;
					case 2:
						if(v450) {
							bs450 |= 32;
						} else {
							bs450 &= -33;
						}
						break;
					case 3:
						if(v450) {
							bs450 |= 16;
						} else {
							bs450 &= -17;
						}
						break;
					case 4:
						if(v450) {
							bs450 |= 8;
						} else {
							bs450 &= -9;
						}
						break;
					case 5:
						if(v450) {
							bs450 |= 4;
						} else {
							bs450 &= -5;
						}
						break;
					case 6:
						if(v450) {
							bs450 |= 2;
						} else {
							bs450 &= -3;
						}
						break;
					case 7:
						if(v450) {
							bs450 |= 1;
						} else {
							bs450 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs450;
				var this452 = 0;
				var bs451 = this452;
				var l451 = "     ".length;
				var _g1452 = 0;
				var _g552 = l451;
				while(_g1452 < _g552) {
					var i452 = _g1452++;
					var no451 = "     ".charCodeAt(i452);
					if(no451 == null) {
						break;
					}
					var v451;
					switch(no451) {
					case 32:
						v451 = false;
						break;
					case 42:
						v451 = true;
						break;
					case 48:
						v451 = false;
						break;
					case 49:
						v451 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i452)));
					}
					switch(i452 - (l451 - 8)) {
					case 0:
						if(v451) {
							bs451 |= 128;
						} else {
							bs451 &= -129;
						}
						break;
					case 1:
						if(v451) {
							bs451 |= 64;
						} else {
							bs451 &= -65;
						}
						break;
					case 2:
						if(v451) {
							bs451 |= 32;
						} else {
							bs451 &= -33;
						}
						break;
					case 3:
						if(v451) {
							bs451 |= 16;
						} else {
							bs451 &= -17;
						}
						break;
					case 4:
						if(v451) {
							bs451 |= 8;
						} else {
							bs451 &= -9;
						}
						break;
					case 5:
						if(v451) {
							bs451 |= 4;
						} else {
							bs451 &= -5;
						}
						break;
					case 6:
						if(v451) {
							bs451 |= 2;
						} else {
							bs451 &= -3;
						}
						break;
					case 7:
						if(v451) {
							bs451 |= 1;
						} else {
							bs451 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs451;
				var this453 = 0;
				var bs452 = this453;
				var l452 = "     ".length;
				var _g1453 = 0;
				var _g553 = l452;
				while(_g1453 < _g553) {
					var i453 = _g1453++;
					var no452 = "     ".charCodeAt(i453);
					if(no452 == null) {
						break;
					}
					var v452;
					switch(no452) {
					case 32:
						v452 = false;
						break;
					case 42:
						v452 = true;
						break;
					case 48:
						v452 = false;
						break;
					case 49:
						v452 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i453)));
					}
					switch(i453 - (l452 - 8)) {
					case 0:
						if(v452) {
							bs452 |= 128;
						} else {
							bs452 &= -129;
						}
						break;
					case 1:
						if(v452) {
							bs452 |= 64;
						} else {
							bs452 &= -65;
						}
						break;
					case 2:
						if(v452) {
							bs452 |= 32;
						} else {
							bs452 &= -33;
						}
						break;
					case 3:
						if(v452) {
							bs452 |= 16;
						} else {
							bs452 &= -17;
						}
						break;
					case 4:
						if(v452) {
							bs452 |= 8;
						} else {
							bs452 &= -9;
						}
						break;
					case 5:
						if(v452) {
							bs452 |= 4;
						} else {
							bs452 &= -5;
						}
						break;
					case 6:
						if(v452) {
							bs452 |= 2;
						} else {
							bs452 &= -3;
						}
						break;
					case 7:
						if(v452) {
							bs452 |= 1;
						} else {
							bs452 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs452;
				var this454 = 0;
				var bs453 = this454;
				var l453 = "     ".length;
				var _g1454 = 0;
				var _g554 = l453;
				while(_g1454 < _g554) {
					var i454 = _g1454++;
					var no453 = "     ".charCodeAt(i454);
					if(no453 == null) {
						break;
					}
					var v453;
					switch(no453) {
					case 32:
						v453 = false;
						break;
					case 42:
						v453 = true;
						break;
					case 48:
						v453 = false;
						break;
					case 49:
						v453 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i454)));
					}
					switch(i454 - (l453 - 8)) {
					case 0:
						if(v453) {
							bs453 |= 128;
						} else {
							bs453 &= -129;
						}
						break;
					case 1:
						if(v453) {
							bs453 |= 64;
						} else {
							bs453 &= -65;
						}
						break;
					case 2:
						if(v453) {
							bs453 |= 32;
						} else {
							bs453 &= -33;
						}
						break;
					case 3:
						if(v453) {
							bs453 |= 16;
						} else {
							bs453 &= -17;
						}
						break;
					case 4:
						if(v453) {
							bs453 |= 8;
						} else {
							bs453 &= -9;
						}
						break;
					case 5:
						if(v453) {
							bs453 |= 4;
						} else {
							bs453 &= -5;
						}
						break;
					case 6:
						if(v453) {
							bs453 |= 2;
						} else {
							bs453 &= -3;
						}
						break;
					case 7:
						if(v453) {
							bs453 |= 1;
						} else {
							bs453 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs453;
				var this455 = 0;
				var bs454 = this455;
				var l454 = "     ".length;
				var _g1455 = 0;
				var _g555 = l454;
				while(_g1455 < _g555) {
					var i455 = _g1455++;
					var no454 = "     ".charCodeAt(i455);
					if(no454 == null) {
						break;
					}
					var v454;
					switch(no454) {
					case 32:
						v454 = false;
						break;
					case 42:
						v454 = true;
						break;
					case 48:
						v454 = false;
						break;
					case 49:
						v454 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i455)));
					}
					switch(i455 - (l454 - 8)) {
					case 0:
						if(v454) {
							bs454 |= 128;
						} else {
							bs454 &= -129;
						}
						break;
					case 1:
						if(v454) {
							bs454 |= 64;
						} else {
							bs454 &= -65;
						}
						break;
					case 2:
						if(v454) {
							bs454 |= 32;
						} else {
							bs454 &= -33;
						}
						break;
					case 3:
						if(v454) {
							bs454 |= 16;
						} else {
							bs454 &= -17;
						}
						break;
					case 4:
						if(v454) {
							bs454 |= 8;
						} else {
							bs454 &= -9;
						}
						break;
					case 5:
						if(v454) {
							bs454 |= 4;
						} else {
							bs454 &= -5;
						}
						break;
					case 6:
						if(v454) {
							bs454 |= 2;
						} else {
							bs454 &= -3;
						}
						break;
					case 7:
						if(v454) {
							bs454 |= 1;
						} else {
							bs454 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs454;
				break;
			case 97:
				var this456 = 0;
				var bs455 = this456;
				var l455 = "     ".length;
				var _g1456 = 0;
				var _g556 = l455;
				while(_g1456 < _g556) {
					var i456 = _g1456++;
					var no455 = "     ".charCodeAt(i456);
					if(no455 == null) {
						break;
					}
					var v455;
					switch(no455) {
					case 32:
						v455 = false;
						break;
					case 42:
						v455 = true;
						break;
					case 48:
						v455 = false;
						break;
					case 49:
						v455 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i456)));
					}
					switch(i456 - (l455 - 8)) {
					case 0:
						if(v455) {
							bs455 |= 128;
						} else {
							bs455 &= -129;
						}
						break;
					case 1:
						if(v455) {
							bs455 |= 64;
						} else {
							bs455 &= -65;
						}
						break;
					case 2:
						if(v455) {
							bs455 |= 32;
						} else {
							bs455 &= -33;
						}
						break;
					case 3:
						if(v455) {
							bs455 |= 16;
						} else {
							bs455 &= -17;
						}
						break;
					case 4:
						if(v455) {
							bs455 |= 8;
						} else {
							bs455 &= -9;
						}
						break;
					case 5:
						if(v455) {
							bs455 |= 4;
						} else {
							bs455 &= -5;
						}
						break;
					case 6:
						if(v455) {
							bs455 |= 2;
						} else {
							bs455 &= -3;
						}
						break;
					case 7:
						if(v455) {
							bs455 |= 1;
						} else {
							bs455 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs455;
				var this457 = 0;
				var bs456 = this457;
				var l456 = "     ".length;
				var _g1457 = 0;
				var _g557 = l456;
				while(_g1457 < _g557) {
					var i457 = _g1457++;
					var no456 = "     ".charCodeAt(i457);
					if(no456 == null) {
						break;
					}
					var v456;
					switch(no456) {
					case 32:
						v456 = false;
						break;
					case 42:
						v456 = true;
						break;
					case 48:
						v456 = false;
						break;
					case 49:
						v456 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i457)));
					}
					switch(i457 - (l456 - 8)) {
					case 0:
						if(v456) {
							bs456 |= 128;
						} else {
							bs456 &= -129;
						}
						break;
					case 1:
						if(v456) {
							bs456 |= 64;
						} else {
							bs456 &= -65;
						}
						break;
					case 2:
						if(v456) {
							bs456 |= 32;
						} else {
							bs456 &= -33;
						}
						break;
					case 3:
						if(v456) {
							bs456 |= 16;
						} else {
							bs456 &= -17;
						}
						break;
					case 4:
						if(v456) {
							bs456 |= 8;
						} else {
							bs456 &= -9;
						}
						break;
					case 5:
						if(v456) {
							bs456 |= 4;
						} else {
							bs456 &= -5;
						}
						break;
					case 6:
						if(v456) {
							bs456 |= 2;
						} else {
							bs456 &= -3;
						}
						break;
					case 7:
						if(v456) {
							bs456 |= 1;
						} else {
							bs456 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs456;
				var this458 = 0;
				var bs457 = this458;
				var l457 = " *** ".length;
				var _g1458 = 0;
				var _g558 = l457;
				while(_g1458 < _g558) {
					var i458 = _g1458++;
					var no457 = " *** ".charCodeAt(i458);
					if(no457 == null) {
						break;
					}
					var v457;
					switch(no457) {
					case 32:
						v457 = false;
						break;
					case 42:
						v457 = true;
						break;
					case 48:
						v457 = false;
						break;
					case 49:
						v457 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i458)));
					}
					switch(i458 - (l457 - 8)) {
					case 0:
						if(v457) {
							bs457 |= 128;
						} else {
							bs457 &= -129;
						}
						break;
					case 1:
						if(v457) {
							bs457 |= 64;
						} else {
							bs457 &= -65;
						}
						break;
					case 2:
						if(v457) {
							bs457 |= 32;
						} else {
							bs457 &= -33;
						}
						break;
					case 3:
						if(v457) {
							bs457 |= 16;
						} else {
							bs457 &= -17;
						}
						break;
					case 4:
						if(v457) {
							bs457 |= 8;
						} else {
							bs457 &= -9;
						}
						break;
					case 5:
						if(v457) {
							bs457 |= 4;
						} else {
							bs457 &= -5;
						}
						break;
					case 6:
						if(v457) {
							bs457 |= 2;
						} else {
							bs457 &= -3;
						}
						break;
					case 7:
						if(v457) {
							bs457 |= 1;
						} else {
							bs457 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs457;
				var this459 = 0;
				var bs458 = this459;
				var l458 = "    *".length;
				var _g1459 = 0;
				var _g559 = l458;
				while(_g1459 < _g559) {
					var i459 = _g1459++;
					var no458 = "    *".charCodeAt(i459);
					if(no458 == null) {
						break;
					}
					var v458;
					switch(no458) {
					case 32:
						v458 = false;
						break;
					case 42:
						v458 = true;
						break;
					case 48:
						v458 = false;
						break;
					case 49:
						v458 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i459)));
					}
					switch(i459 - (l458 - 8)) {
					case 0:
						if(v458) {
							bs458 |= 128;
						} else {
							bs458 &= -129;
						}
						break;
					case 1:
						if(v458) {
							bs458 |= 64;
						} else {
							bs458 &= -65;
						}
						break;
					case 2:
						if(v458) {
							bs458 |= 32;
						} else {
							bs458 &= -33;
						}
						break;
					case 3:
						if(v458) {
							bs458 |= 16;
						} else {
							bs458 &= -17;
						}
						break;
					case 4:
						if(v458) {
							bs458 |= 8;
						} else {
							bs458 &= -9;
						}
						break;
					case 5:
						if(v458) {
							bs458 |= 4;
						} else {
							bs458 &= -5;
						}
						break;
					case 6:
						if(v458) {
							bs458 |= 2;
						} else {
							bs458 &= -3;
						}
						break;
					case 7:
						if(v458) {
							bs458 |= 1;
						} else {
							bs458 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs458;
				var this460 = 0;
				var bs459 = this460;
				var l459 = " ****".length;
				var _g1460 = 0;
				var _g560 = l459;
				while(_g1460 < _g560) {
					var i460 = _g1460++;
					var no459 = " ****".charCodeAt(i460);
					if(no459 == null) {
						break;
					}
					var v459;
					switch(no459) {
					case 32:
						v459 = false;
						break;
					case 42:
						v459 = true;
						break;
					case 48:
						v459 = false;
						break;
					case 49:
						v459 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i460)));
					}
					switch(i460 - (l459 - 8)) {
					case 0:
						if(v459) {
							bs459 |= 128;
						} else {
							bs459 &= -129;
						}
						break;
					case 1:
						if(v459) {
							bs459 |= 64;
						} else {
							bs459 &= -65;
						}
						break;
					case 2:
						if(v459) {
							bs459 |= 32;
						} else {
							bs459 &= -33;
						}
						break;
					case 3:
						if(v459) {
							bs459 |= 16;
						} else {
							bs459 &= -17;
						}
						break;
					case 4:
						if(v459) {
							bs459 |= 8;
						} else {
							bs459 &= -9;
						}
						break;
					case 5:
						if(v459) {
							bs459 |= 4;
						} else {
							bs459 &= -5;
						}
						break;
					case 6:
						if(v459) {
							bs459 |= 2;
						} else {
							bs459 &= -3;
						}
						break;
					case 7:
						if(v459) {
							bs459 |= 1;
						} else {
							bs459 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs459;
				var this461 = 0;
				var bs460 = this461;
				var l460 = "*   *".length;
				var _g1461 = 0;
				var _g561 = l460;
				while(_g1461 < _g561) {
					var i461 = _g1461++;
					var no460 = "*   *".charCodeAt(i461);
					if(no460 == null) {
						break;
					}
					var v460;
					switch(no460) {
					case 32:
						v460 = false;
						break;
					case 42:
						v460 = true;
						break;
					case 48:
						v460 = false;
						break;
					case 49:
						v460 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i461)));
					}
					switch(i461 - (l460 - 8)) {
					case 0:
						if(v460) {
							bs460 |= 128;
						} else {
							bs460 &= -129;
						}
						break;
					case 1:
						if(v460) {
							bs460 |= 64;
						} else {
							bs460 &= -65;
						}
						break;
					case 2:
						if(v460) {
							bs460 |= 32;
						} else {
							bs460 &= -33;
						}
						break;
					case 3:
						if(v460) {
							bs460 |= 16;
						} else {
							bs460 &= -17;
						}
						break;
					case 4:
						if(v460) {
							bs460 |= 8;
						} else {
							bs460 &= -9;
						}
						break;
					case 5:
						if(v460) {
							bs460 |= 4;
						} else {
							bs460 &= -5;
						}
						break;
					case 6:
						if(v460) {
							bs460 |= 2;
						} else {
							bs460 &= -3;
						}
						break;
					case 7:
						if(v460) {
							bs460 |= 1;
						} else {
							bs460 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs460;
				var this462 = 0;
				var bs461 = this462;
				var l461 = " ****".length;
				var _g1462 = 0;
				var _g562 = l461;
				while(_g1462 < _g562) {
					var i462 = _g1462++;
					var no461 = " ****".charCodeAt(i462);
					if(no461 == null) {
						break;
					}
					var v461;
					switch(no461) {
					case 32:
						v461 = false;
						break;
					case 42:
						v461 = true;
						break;
					case 48:
						v461 = false;
						break;
					case 49:
						v461 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i462)));
					}
					switch(i462 - (l461 - 8)) {
					case 0:
						if(v461) {
							bs461 |= 128;
						} else {
							bs461 &= -129;
						}
						break;
					case 1:
						if(v461) {
							bs461 |= 64;
						} else {
							bs461 &= -65;
						}
						break;
					case 2:
						if(v461) {
							bs461 |= 32;
						} else {
							bs461 &= -33;
						}
						break;
					case 3:
						if(v461) {
							bs461 |= 16;
						} else {
							bs461 &= -17;
						}
						break;
					case 4:
						if(v461) {
							bs461 |= 8;
						} else {
							bs461 &= -9;
						}
						break;
					case 5:
						if(v461) {
							bs461 |= 4;
						} else {
							bs461 &= -5;
						}
						break;
					case 6:
						if(v461) {
							bs461 |= 2;
						} else {
							bs461 &= -3;
						}
						break;
					case 7:
						if(v461) {
							bs461 |= 1;
						} else {
							bs461 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs461;
				break;
			case 98:
				var this463 = 0;
				var bs462 = this463;
				var l462 = "*    ".length;
				var _g1463 = 0;
				var _g563 = l462;
				while(_g1463 < _g563) {
					var i463 = _g1463++;
					var no462 = "*    ".charCodeAt(i463);
					if(no462 == null) {
						break;
					}
					var v462;
					switch(no462) {
					case 32:
						v462 = false;
						break;
					case 42:
						v462 = true;
						break;
					case 48:
						v462 = false;
						break;
					case 49:
						v462 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i463)));
					}
					switch(i463 - (l462 - 8)) {
					case 0:
						if(v462) {
							bs462 |= 128;
						} else {
							bs462 &= -129;
						}
						break;
					case 1:
						if(v462) {
							bs462 |= 64;
						} else {
							bs462 &= -65;
						}
						break;
					case 2:
						if(v462) {
							bs462 |= 32;
						} else {
							bs462 &= -33;
						}
						break;
					case 3:
						if(v462) {
							bs462 |= 16;
						} else {
							bs462 &= -17;
						}
						break;
					case 4:
						if(v462) {
							bs462 |= 8;
						} else {
							bs462 &= -9;
						}
						break;
					case 5:
						if(v462) {
							bs462 |= 4;
						} else {
							bs462 &= -5;
						}
						break;
					case 6:
						if(v462) {
							bs462 |= 2;
						} else {
							bs462 &= -3;
						}
						break;
					case 7:
						if(v462) {
							bs462 |= 1;
						} else {
							bs462 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs462;
				var this464 = 0;
				var bs463 = this464;
				var l463 = "*    ".length;
				var _g1464 = 0;
				var _g564 = l463;
				while(_g1464 < _g564) {
					var i464 = _g1464++;
					var no463 = "*    ".charCodeAt(i464);
					if(no463 == null) {
						break;
					}
					var v463;
					switch(no463) {
					case 32:
						v463 = false;
						break;
					case 42:
						v463 = true;
						break;
					case 48:
						v463 = false;
						break;
					case 49:
						v463 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i464)));
					}
					switch(i464 - (l463 - 8)) {
					case 0:
						if(v463) {
							bs463 |= 128;
						} else {
							bs463 &= -129;
						}
						break;
					case 1:
						if(v463) {
							bs463 |= 64;
						} else {
							bs463 &= -65;
						}
						break;
					case 2:
						if(v463) {
							bs463 |= 32;
						} else {
							bs463 &= -33;
						}
						break;
					case 3:
						if(v463) {
							bs463 |= 16;
						} else {
							bs463 &= -17;
						}
						break;
					case 4:
						if(v463) {
							bs463 |= 8;
						} else {
							bs463 &= -9;
						}
						break;
					case 5:
						if(v463) {
							bs463 |= 4;
						} else {
							bs463 &= -5;
						}
						break;
					case 6:
						if(v463) {
							bs463 |= 2;
						} else {
							bs463 &= -3;
						}
						break;
					case 7:
						if(v463) {
							bs463 |= 1;
						} else {
							bs463 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs463;
				var this465 = 0;
				var bs464 = this465;
				var l464 = "* ** ".length;
				var _g1465 = 0;
				var _g565 = l464;
				while(_g1465 < _g565) {
					var i465 = _g1465++;
					var no464 = "* ** ".charCodeAt(i465);
					if(no464 == null) {
						break;
					}
					var v464;
					switch(no464) {
					case 32:
						v464 = false;
						break;
					case 42:
						v464 = true;
						break;
					case 48:
						v464 = false;
						break;
					case 49:
						v464 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* ** ".charCodeAt(i465)));
					}
					switch(i465 - (l464 - 8)) {
					case 0:
						if(v464) {
							bs464 |= 128;
						} else {
							bs464 &= -129;
						}
						break;
					case 1:
						if(v464) {
							bs464 |= 64;
						} else {
							bs464 &= -65;
						}
						break;
					case 2:
						if(v464) {
							bs464 |= 32;
						} else {
							bs464 &= -33;
						}
						break;
					case 3:
						if(v464) {
							bs464 |= 16;
						} else {
							bs464 &= -17;
						}
						break;
					case 4:
						if(v464) {
							bs464 |= 8;
						} else {
							bs464 &= -9;
						}
						break;
					case 5:
						if(v464) {
							bs464 |= 4;
						} else {
							bs464 &= -5;
						}
						break;
					case 6:
						if(v464) {
							bs464 |= 2;
						} else {
							bs464 &= -3;
						}
						break;
					case 7:
						if(v464) {
							bs464 |= 1;
						} else {
							bs464 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs464;
				var this466 = 0;
				var bs465 = this466;
				var l465 = "**  *".length;
				var _g1466 = 0;
				var _g566 = l465;
				while(_g1466 < _g566) {
					var i466 = _g1466++;
					var no465 = "**  *".charCodeAt(i466);
					if(no465 == null) {
						break;
					}
					var v465;
					switch(no465) {
					case 32:
						v465 = false;
						break;
					case 42:
						v465 = true;
						break;
					case 48:
						v465 = false;
						break;
					case 49:
						v465 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i466)));
					}
					switch(i466 - (l465 - 8)) {
					case 0:
						if(v465) {
							bs465 |= 128;
						} else {
							bs465 &= -129;
						}
						break;
					case 1:
						if(v465) {
							bs465 |= 64;
						} else {
							bs465 &= -65;
						}
						break;
					case 2:
						if(v465) {
							bs465 |= 32;
						} else {
							bs465 &= -33;
						}
						break;
					case 3:
						if(v465) {
							bs465 |= 16;
						} else {
							bs465 &= -17;
						}
						break;
					case 4:
						if(v465) {
							bs465 |= 8;
						} else {
							bs465 &= -9;
						}
						break;
					case 5:
						if(v465) {
							bs465 |= 4;
						} else {
							bs465 &= -5;
						}
						break;
					case 6:
						if(v465) {
							bs465 |= 2;
						} else {
							bs465 &= -3;
						}
						break;
					case 7:
						if(v465) {
							bs465 |= 1;
						} else {
							bs465 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs465;
				var this467 = 0;
				var bs466 = this467;
				var l466 = "*   *".length;
				var _g1467 = 0;
				var _g567 = l466;
				while(_g1467 < _g567) {
					var i467 = _g1467++;
					var no466 = "*   *".charCodeAt(i467);
					if(no466 == null) {
						break;
					}
					var v466;
					switch(no466) {
					case 32:
						v466 = false;
						break;
					case 42:
						v466 = true;
						break;
					case 48:
						v466 = false;
						break;
					case 49:
						v466 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i467)));
					}
					switch(i467 - (l466 - 8)) {
					case 0:
						if(v466) {
							bs466 |= 128;
						} else {
							bs466 &= -129;
						}
						break;
					case 1:
						if(v466) {
							bs466 |= 64;
						} else {
							bs466 &= -65;
						}
						break;
					case 2:
						if(v466) {
							bs466 |= 32;
						} else {
							bs466 &= -33;
						}
						break;
					case 3:
						if(v466) {
							bs466 |= 16;
						} else {
							bs466 &= -17;
						}
						break;
					case 4:
						if(v466) {
							bs466 |= 8;
						} else {
							bs466 &= -9;
						}
						break;
					case 5:
						if(v466) {
							bs466 |= 4;
						} else {
							bs466 &= -5;
						}
						break;
					case 6:
						if(v466) {
							bs466 |= 2;
						} else {
							bs466 &= -3;
						}
						break;
					case 7:
						if(v466) {
							bs466 |= 1;
						} else {
							bs466 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs466;
				var this468 = 0;
				var bs467 = this468;
				var l467 = "*   *".length;
				var _g1468 = 0;
				var _g568 = l467;
				while(_g1468 < _g568) {
					var i468 = _g1468++;
					var no467 = "*   *".charCodeAt(i468);
					if(no467 == null) {
						break;
					}
					var v467;
					switch(no467) {
					case 32:
						v467 = false;
						break;
					case 42:
						v467 = true;
						break;
					case 48:
						v467 = false;
						break;
					case 49:
						v467 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i468)));
					}
					switch(i468 - (l467 - 8)) {
					case 0:
						if(v467) {
							bs467 |= 128;
						} else {
							bs467 &= -129;
						}
						break;
					case 1:
						if(v467) {
							bs467 |= 64;
						} else {
							bs467 &= -65;
						}
						break;
					case 2:
						if(v467) {
							bs467 |= 32;
						} else {
							bs467 &= -33;
						}
						break;
					case 3:
						if(v467) {
							bs467 |= 16;
						} else {
							bs467 &= -17;
						}
						break;
					case 4:
						if(v467) {
							bs467 |= 8;
						} else {
							bs467 &= -9;
						}
						break;
					case 5:
						if(v467) {
							bs467 |= 4;
						} else {
							bs467 &= -5;
						}
						break;
					case 6:
						if(v467) {
							bs467 |= 2;
						} else {
							bs467 &= -3;
						}
						break;
					case 7:
						if(v467) {
							bs467 |= 1;
						} else {
							bs467 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs467;
				var this469 = 0;
				var bs468 = this469;
				var l468 = "**** ".length;
				var _g1469 = 0;
				var _g569 = l468;
				while(_g1469 < _g569) {
					var i469 = _g1469++;
					var no468 = "**** ".charCodeAt(i469);
					if(no468 == null) {
						break;
					}
					var v468;
					switch(no468) {
					case 32:
						v468 = false;
						break;
					case 42:
						v468 = true;
						break;
					case 48:
						v468 = false;
						break;
					case 49:
						v468 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i469)));
					}
					switch(i469 - (l468 - 8)) {
					case 0:
						if(v468) {
							bs468 |= 128;
						} else {
							bs468 &= -129;
						}
						break;
					case 1:
						if(v468) {
							bs468 |= 64;
						} else {
							bs468 &= -65;
						}
						break;
					case 2:
						if(v468) {
							bs468 |= 32;
						} else {
							bs468 &= -33;
						}
						break;
					case 3:
						if(v468) {
							bs468 |= 16;
						} else {
							bs468 &= -17;
						}
						break;
					case 4:
						if(v468) {
							bs468 |= 8;
						} else {
							bs468 &= -9;
						}
						break;
					case 5:
						if(v468) {
							bs468 |= 4;
						} else {
							bs468 &= -5;
						}
						break;
					case 6:
						if(v468) {
							bs468 |= 2;
						} else {
							bs468 &= -3;
						}
						break;
					case 7:
						if(v468) {
							bs468 |= 1;
						} else {
							bs468 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs468;
				break;
			case 99:
				var this470 = 0;
				var bs469 = this470;
				var l469 = "     ".length;
				var _g1470 = 0;
				var _g570 = l469;
				while(_g1470 < _g570) {
					var i470 = _g1470++;
					var no469 = "     ".charCodeAt(i470);
					if(no469 == null) {
						break;
					}
					var v469;
					switch(no469) {
					case 32:
						v469 = false;
						break;
					case 42:
						v469 = true;
						break;
					case 48:
						v469 = false;
						break;
					case 49:
						v469 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i470)));
					}
					switch(i470 - (l469 - 8)) {
					case 0:
						if(v469) {
							bs469 |= 128;
						} else {
							bs469 &= -129;
						}
						break;
					case 1:
						if(v469) {
							bs469 |= 64;
						} else {
							bs469 &= -65;
						}
						break;
					case 2:
						if(v469) {
							bs469 |= 32;
						} else {
							bs469 &= -33;
						}
						break;
					case 3:
						if(v469) {
							bs469 |= 16;
						} else {
							bs469 &= -17;
						}
						break;
					case 4:
						if(v469) {
							bs469 |= 8;
						} else {
							bs469 &= -9;
						}
						break;
					case 5:
						if(v469) {
							bs469 |= 4;
						} else {
							bs469 &= -5;
						}
						break;
					case 6:
						if(v469) {
							bs469 |= 2;
						} else {
							bs469 &= -3;
						}
						break;
					case 7:
						if(v469) {
							bs469 |= 1;
						} else {
							bs469 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs469;
				var this471 = 0;
				var bs470 = this471;
				var l470 = "     ".length;
				var _g1471 = 0;
				var _g571 = l470;
				while(_g1471 < _g571) {
					var i471 = _g1471++;
					var no470 = "     ".charCodeAt(i471);
					if(no470 == null) {
						break;
					}
					var v470;
					switch(no470) {
					case 32:
						v470 = false;
						break;
					case 42:
						v470 = true;
						break;
					case 48:
						v470 = false;
						break;
					case 49:
						v470 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i471)));
					}
					switch(i471 - (l470 - 8)) {
					case 0:
						if(v470) {
							bs470 |= 128;
						} else {
							bs470 &= -129;
						}
						break;
					case 1:
						if(v470) {
							bs470 |= 64;
						} else {
							bs470 &= -65;
						}
						break;
					case 2:
						if(v470) {
							bs470 |= 32;
						} else {
							bs470 &= -33;
						}
						break;
					case 3:
						if(v470) {
							bs470 |= 16;
						} else {
							bs470 &= -17;
						}
						break;
					case 4:
						if(v470) {
							bs470 |= 8;
						} else {
							bs470 &= -9;
						}
						break;
					case 5:
						if(v470) {
							bs470 |= 4;
						} else {
							bs470 &= -5;
						}
						break;
					case 6:
						if(v470) {
							bs470 |= 2;
						} else {
							bs470 &= -3;
						}
						break;
					case 7:
						if(v470) {
							bs470 |= 1;
						} else {
							bs470 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs470;
				var this472 = 0;
				var bs471 = this472;
				var l471 = " *** ".length;
				var _g1472 = 0;
				var _g572 = l471;
				while(_g1472 < _g572) {
					var i472 = _g1472++;
					var no471 = " *** ".charCodeAt(i472);
					if(no471 == null) {
						break;
					}
					var v471;
					switch(no471) {
					case 32:
						v471 = false;
						break;
					case 42:
						v471 = true;
						break;
					case 48:
						v471 = false;
						break;
					case 49:
						v471 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i472)));
					}
					switch(i472 - (l471 - 8)) {
					case 0:
						if(v471) {
							bs471 |= 128;
						} else {
							bs471 &= -129;
						}
						break;
					case 1:
						if(v471) {
							bs471 |= 64;
						} else {
							bs471 &= -65;
						}
						break;
					case 2:
						if(v471) {
							bs471 |= 32;
						} else {
							bs471 &= -33;
						}
						break;
					case 3:
						if(v471) {
							bs471 |= 16;
						} else {
							bs471 &= -17;
						}
						break;
					case 4:
						if(v471) {
							bs471 |= 8;
						} else {
							bs471 &= -9;
						}
						break;
					case 5:
						if(v471) {
							bs471 |= 4;
						} else {
							bs471 &= -5;
						}
						break;
					case 6:
						if(v471) {
							bs471 |= 2;
						} else {
							bs471 &= -3;
						}
						break;
					case 7:
						if(v471) {
							bs471 |= 1;
						} else {
							bs471 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs471;
				var this473 = 0;
				var bs472 = this473;
				var l472 = "*    ".length;
				var _g1473 = 0;
				var _g573 = l472;
				while(_g1473 < _g573) {
					var i473 = _g1473++;
					var no472 = "*    ".charCodeAt(i473);
					if(no472 == null) {
						break;
					}
					var v472;
					switch(no472) {
					case 32:
						v472 = false;
						break;
					case 42:
						v472 = true;
						break;
					case 48:
						v472 = false;
						break;
					case 49:
						v472 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i473)));
					}
					switch(i473 - (l472 - 8)) {
					case 0:
						if(v472) {
							bs472 |= 128;
						} else {
							bs472 &= -129;
						}
						break;
					case 1:
						if(v472) {
							bs472 |= 64;
						} else {
							bs472 &= -65;
						}
						break;
					case 2:
						if(v472) {
							bs472 |= 32;
						} else {
							bs472 &= -33;
						}
						break;
					case 3:
						if(v472) {
							bs472 |= 16;
						} else {
							bs472 &= -17;
						}
						break;
					case 4:
						if(v472) {
							bs472 |= 8;
						} else {
							bs472 &= -9;
						}
						break;
					case 5:
						if(v472) {
							bs472 |= 4;
						} else {
							bs472 &= -5;
						}
						break;
					case 6:
						if(v472) {
							bs472 |= 2;
						} else {
							bs472 &= -3;
						}
						break;
					case 7:
						if(v472) {
							bs472 |= 1;
						} else {
							bs472 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs472;
				var this474 = 0;
				var bs473 = this474;
				var l473 = "*    ".length;
				var _g1474 = 0;
				var _g574 = l473;
				while(_g1474 < _g574) {
					var i474 = _g1474++;
					var no473 = "*    ".charCodeAt(i474);
					if(no473 == null) {
						break;
					}
					var v473;
					switch(no473) {
					case 32:
						v473 = false;
						break;
					case 42:
						v473 = true;
						break;
					case 48:
						v473 = false;
						break;
					case 49:
						v473 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i474)));
					}
					switch(i474 - (l473 - 8)) {
					case 0:
						if(v473) {
							bs473 |= 128;
						} else {
							bs473 &= -129;
						}
						break;
					case 1:
						if(v473) {
							bs473 |= 64;
						} else {
							bs473 &= -65;
						}
						break;
					case 2:
						if(v473) {
							bs473 |= 32;
						} else {
							bs473 &= -33;
						}
						break;
					case 3:
						if(v473) {
							bs473 |= 16;
						} else {
							bs473 &= -17;
						}
						break;
					case 4:
						if(v473) {
							bs473 |= 8;
						} else {
							bs473 &= -9;
						}
						break;
					case 5:
						if(v473) {
							bs473 |= 4;
						} else {
							bs473 &= -5;
						}
						break;
					case 6:
						if(v473) {
							bs473 |= 2;
						} else {
							bs473 &= -3;
						}
						break;
					case 7:
						if(v473) {
							bs473 |= 1;
						} else {
							bs473 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs473;
				var this475 = 0;
				var bs474 = this475;
				var l474 = "*   *".length;
				var _g1475 = 0;
				var _g575 = l474;
				while(_g1475 < _g575) {
					var i475 = _g1475++;
					var no474 = "*   *".charCodeAt(i475);
					if(no474 == null) {
						break;
					}
					var v474;
					switch(no474) {
					case 32:
						v474 = false;
						break;
					case 42:
						v474 = true;
						break;
					case 48:
						v474 = false;
						break;
					case 49:
						v474 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i475)));
					}
					switch(i475 - (l474 - 8)) {
					case 0:
						if(v474) {
							bs474 |= 128;
						} else {
							bs474 &= -129;
						}
						break;
					case 1:
						if(v474) {
							bs474 |= 64;
						} else {
							bs474 &= -65;
						}
						break;
					case 2:
						if(v474) {
							bs474 |= 32;
						} else {
							bs474 &= -33;
						}
						break;
					case 3:
						if(v474) {
							bs474 |= 16;
						} else {
							bs474 &= -17;
						}
						break;
					case 4:
						if(v474) {
							bs474 |= 8;
						} else {
							bs474 &= -9;
						}
						break;
					case 5:
						if(v474) {
							bs474 |= 4;
						} else {
							bs474 &= -5;
						}
						break;
					case 6:
						if(v474) {
							bs474 |= 2;
						} else {
							bs474 &= -3;
						}
						break;
					case 7:
						if(v474) {
							bs474 |= 1;
						} else {
							bs474 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs474;
				var this476 = 0;
				var bs475 = this476;
				var l475 = " *** ".length;
				var _g1476 = 0;
				var _g576 = l475;
				while(_g1476 < _g576) {
					var i476 = _g1476++;
					var no475 = " *** ".charCodeAt(i476);
					if(no475 == null) {
						break;
					}
					var v475;
					switch(no475) {
					case 32:
						v475 = false;
						break;
					case 42:
						v475 = true;
						break;
					case 48:
						v475 = false;
						break;
					case 49:
						v475 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i476)));
					}
					switch(i476 - (l475 - 8)) {
					case 0:
						if(v475) {
							bs475 |= 128;
						} else {
							bs475 &= -129;
						}
						break;
					case 1:
						if(v475) {
							bs475 |= 64;
						} else {
							bs475 &= -65;
						}
						break;
					case 2:
						if(v475) {
							bs475 |= 32;
						} else {
							bs475 &= -33;
						}
						break;
					case 3:
						if(v475) {
							bs475 |= 16;
						} else {
							bs475 &= -17;
						}
						break;
					case 4:
						if(v475) {
							bs475 |= 8;
						} else {
							bs475 &= -9;
						}
						break;
					case 5:
						if(v475) {
							bs475 |= 4;
						} else {
							bs475 &= -5;
						}
						break;
					case 6:
						if(v475) {
							bs475 |= 2;
						} else {
							bs475 &= -3;
						}
						break;
					case 7:
						if(v475) {
							bs475 |= 1;
						} else {
							bs475 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs475;
				break;
			case 100:
				var this477 = 0;
				var bs476 = this477;
				var l476 = "    *".length;
				var _g1477 = 0;
				var _g577 = l476;
				while(_g1477 < _g577) {
					var i477 = _g1477++;
					var no476 = "    *".charCodeAt(i477);
					if(no476 == null) {
						break;
					}
					var v476;
					switch(no476) {
					case 32:
						v476 = false;
						break;
					case 42:
						v476 = true;
						break;
					case 48:
						v476 = false;
						break;
					case 49:
						v476 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i477)));
					}
					switch(i477 - (l476 - 8)) {
					case 0:
						if(v476) {
							bs476 |= 128;
						} else {
							bs476 &= -129;
						}
						break;
					case 1:
						if(v476) {
							bs476 |= 64;
						} else {
							bs476 &= -65;
						}
						break;
					case 2:
						if(v476) {
							bs476 |= 32;
						} else {
							bs476 &= -33;
						}
						break;
					case 3:
						if(v476) {
							bs476 |= 16;
						} else {
							bs476 &= -17;
						}
						break;
					case 4:
						if(v476) {
							bs476 |= 8;
						} else {
							bs476 &= -9;
						}
						break;
					case 5:
						if(v476) {
							bs476 |= 4;
						} else {
							bs476 &= -5;
						}
						break;
					case 6:
						if(v476) {
							bs476 |= 2;
						} else {
							bs476 &= -3;
						}
						break;
					case 7:
						if(v476) {
							bs476 |= 1;
						} else {
							bs476 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs476;
				var this478 = 0;
				var bs477 = this478;
				var l477 = "    *".length;
				var _g1478 = 0;
				var _g578 = l477;
				while(_g1478 < _g578) {
					var i478 = _g1478++;
					var no477 = "    *".charCodeAt(i478);
					if(no477 == null) {
						break;
					}
					var v477;
					switch(no477) {
					case 32:
						v477 = false;
						break;
					case 42:
						v477 = true;
						break;
					case 48:
						v477 = false;
						break;
					case 49:
						v477 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i478)));
					}
					switch(i478 - (l477 - 8)) {
					case 0:
						if(v477) {
							bs477 |= 128;
						} else {
							bs477 &= -129;
						}
						break;
					case 1:
						if(v477) {
							bs477 |= 64;
						} else {
							bs477 &= -65;
						}
						break;
					case 2:
						if(v477) {
							bs477 |= 32;
						} else {
							bs477 &= -33;
						}
						break;
					case 3:
						if(v477) {
							bs477 |= 16;
						} else {
							bs477 &= -17;
						}
						break;
					case 4:
						if(v477) {
							bs477 |= 8;
						} else {
							bs477 &= -9;
						}
						break;
					case 5:
						if(v477) {
							bs477 |= 4;
						} else {
							bs477 &= -5;
						}
						break;
					case 6:
						if(v477) {
							bs477 |= 2;
						} else {
							bs477 &= -3;
						}
						break;
					case 7:
						if(v477) {
							bs477 |= 1;
						} else {
							bs477 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs477;
				var this479 = 0;
				var bs478 = this479;
				var l478 = " ** *".length;
				var _g1479 = 0;
				var _g579 = l478;
				while(_g1479 < _g579) {
					var i479 = _g1479++;
					var no478 = " ** *".charCodeAt(i479);
					if(no478 == null) {
						break;
					}
					var v478;
					switch(no478) {
					case 32:
						v478 = false;
						break;
					case 42:
						v478 = true;
						break;
					case 48:
						v478 = false;
						break;
					case 49:
						v478 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i479)));
					}
					switch(i479 - (l478 - 8)) {
					case 0:
						if(v478) {
							bs478 |= 128;
						} else {
							bs478 &= -129;
						}
						break;
					case 1:
						if(v478) {
							bs478 |= 64;
						} else {
							bs478 &= -65;
						}
						break;
					case 2:
						if(v478) {
							bs478 |= 32;
						} else {
							bs478 &= -33;
						}
						break;
					case 3:
						if(v478) {
							bs478 |= 16;
						} else {
							bs478 &= -17;
						}
						break;
					case 4:
						if(v478) {
							bs478 |= 8;
						} else {
							bs478 &= -9;
						}
						break;
					case 5:
						if(v478) {
							bs478 |= 4;
						} else {
							bs478 &= -5;
						}
						break;
					case 6:
						if(v478) {
							bs478 |= 2;
						} else {
							bs478 &= -3;
						}
						break;
					case 7:
						if(v478) {
							bs478 |= 1;
						} else {
							bs478 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs478;
				var this480 = 0;
				var bs479 = this480;
				var l479 = "*  **".length;
				var _g1480 = 0;
				var _g580 = l479;
				while(_g1480 < _g580) {
					var i480 = _g1480++;
					var no479 = "*  **".charCodeAt(i480);
					if(no479 == null) {
						break;
					}
					var v479;
					switch(no479) {
					case 32:
						v479 = false;
						break;
					case 42:
						v479 = true;
						break;
					case 48:
						v479 = false;
						break;
					case 49:
						v479 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  **".charCodeAt(i480)));
					}
					switch(i480 - (l479 - 8)) {
					case 0:
						if(v479) {
							bs479 |= 128;
						} else {
							bs479 &= -129;
						}
						break;
					case 1:
						if(v479) {
							bs479 |= 64;
						} else {
							bs479 &= -65;
						}
						break;
					case 2:
						if(v479) {
							bs479 |= 32;
						} else {
							bs479 &= -33;
						}
						break;
					case 3:
						if(v479) {
							bs479 |= 16;
						} else {
							bs479 &= -17;
						}
						break;
					case 4:
						if(v479) {
							bs479 |= 8;
						} else {
							bs479 &= -9;
						}
						break;
					case 5:
						if(v479) {
							bs479 |= 4;
						} else {
							bs479 &= -5;
						}
						break;
					case 6:
						if(v479) {
							bs479 |= 2;
						} else {
							bs479 &= -3;
						}
						break;
					case 7:
						if(v479) {
							bs479 |= 1;
						} else {
							bs479 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs479;
				var this481 = 0;
				var bs480 = this481;
				var l480 = "*   *".length;
				var _g1481 = 0;
				var _g581 = l480;
				while(_g1481 < _g581) {
					var i481 = _g1481++;
					var no480 = "*   *".charCodeAt(i481);
					if(no480 == null) {
						break;
					}
					var v480;
					switch(no480) {
					case 32:
						v480 = false;
						break;
					case 42:
						v480 = true;
						break;
					case 48:
						v480 = false;
						break;
					case 49:
						v480 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i481)));
					}
					switch(i481 - (l480 - 8)) {
					case 0:
						if(v480) {
							bs480 |= 128;
						} else {
							bs480 &= -129;
						}
						break;
					case 1:
						if(v480) {
							bs480 |= 64;
						} else {
							bs480 &= -65;
						}
						break;
					case 2:
						if(v480) {
							bs480 |= 32;
						} else {
							bs480 &= -33;
						}
						break;
					case 3:
						if(v480) {
							bs480 |= 16;
						} else {
							bs480 &= -17;
						}
						break;
					case 4:
						if(v480) {
							bs480 |= 8;
						} else {
							bs480 &= -9;
						}
						break;
					case 5:
						if(v480) {
							bs480 |= 4;
						} else {
							bs480 &= -5;
						}
						break;
					case 6:
						if(v480) {
							bs480 |= 2;
						} else {
							bs480 &= -3;
						}
						break;
					case 7:
						if(v480) {
							bs480 |= 1;
						} else {
							bs480 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs480;
				var this482 = 0;
				var bs481 = this482;
				var l481 = "*   *".length;
				var _g1482 = 0;
				var _g582 = l481;
				while(_g1482 < _g582) {
					var i482 = _g1482++;
					var no481 = "*   *".charCodeAt(i482);
					if(no481 == null) {
						break;
					}
					var v481;
					switch(no481) {
					case 32:
						v481 = false;
						break;
					case 42:
						v481 = true;
						break;
					case 48:
						v481 = false;
						break;
					case 49:
						v481 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i482)));
					}
					switch(i482 - (l481 - 8)) {
					case 0:
						if(v481) {
							bs481 |= 128;
						} else {
							bs481 &= -129;
						}
						break;
					case 1:
						if(v481) {
							bs481 |= 64;
						} else {
							bs481 &= -65;
						}
						break;
					case 2:
						if(v481) {
							bs481 |= 32;
						} else {
							bs481 &= -33;
						}
						break;
					case 3:
						if(v481) {
							bs481 |= 16;
						} else {
							bs481 &= -17;
						}
						break;
					case 4:
						if(v481) {
							bs481 |= 8;
						} else {
							bs481 &= -9;
						}
						break;
					case 5:
						if(v481) {
							bs481 |= 4;
						} else {
							bs481 &= -5;
						}
						break;
					case 6:
						if(v481) {
							bs481 |= 2;
						} else {
							bs481 &= -3;
						}
						break;
					case 7:
						if(v481) {
							bs481 |= 1;
						} else {
							bs481 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs481;
				var this483 = 0;
				var bs482 = this483;
				var l482 = " ****".length;
				var _g1483 = 0;
				var _g583 = l482;
				while(_g1483 < _g583) {
					var i483 = _g1483++;
					var no482 = " ****".charCodeAt(i483);
					if(no482 == null) {
						break;
					}
					var v482;
					switch(no482) {
					case 32:
						v482 = false;
						break;
					case 42:
						v482 = true;
						break;
					case 48:
						v482 = false;
						break;
					case 49:
						v482 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i483)));
					}
					switch(i483 - (l482 - 8)) {
					case 0:
						if(v482) {
							bs482 |= 128;
						} else {
							bs482 &= -129;
						}
						break;
					case 1:
						if(v482) {
							bs482 |= 64;
						} else {
							bs482 &= -65;
						}
						break;
					case 2:
						if(v482) {
							bs482 |= 32;
						} else {
							bs482 &= -33;
						}
						break;
					case 3:
						if(v482) {
							bs482 |= 16;
						} else {
							bs482 &= -17;
						}
						break;
					case 4:
						if(v482) {
							bs482 |= 8;
						} else {
							bs482 &= -9;
						}
						break;
					case 5:
						if(v482) {
							bs482 |= 4;
						} else {
							bs482 &= -5;
						}
						break;
					case 6:
						if(v482) {
							bs482 |= 2;
						} else {
							bs482 &= -3;
						}
						break;
					case 7:
						if(v482) {
							bs482 |= 1;
						} else {
							bs482 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs482;
				break;
			case 101:
				var this484 = 0;
				var bs483 = this484;
				var l483 = "     ".length;
				var _g1484 = 0;
				var _g584 = l483;
				while(_g1484 < _g584) {
					var i484 = _g1484++;
					var no483 = "     ".charCodeAt(i484);
					if(no483 == null) {
						break;
					}
					var v483;
					switch(no483) {
					case 32:
						v483 = false;
						break;
					case 42:
						v483 = true;
						break;
					case 48:
						v483 = false;
						break;
					case 49:
						v483 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i484)));
					}
					switch(i484 - (l483 - 8)) {
					case 0:
						if(v483) {
							bs483 |= 128;
						} else {
							bs483 &= -129;
						}
						break;
					case 1:
						if(v483) {
							bs483 |= 64;
						} else {
							bs483 &= -65;
						}
						break;
					case 2:
						if(v483) {
							bs483 |= 32;
						} else {
							bs483 &= -33;
						}
						break;
					case 3:
						if(v483) {
							bs483 |= 16;
						} else {
							bs483 &= -17;
						}
						break;
					case 4:
						if(v483) {
							bs483 |= 8;
						} else {
							bs483 &= -9;
						}
						break;
					case 5:
						if(v483) {
							bs483 |= 4;
						} else {
							bs483 &= -5;
						}
						break;
					case 6:
						if(v483) {
							bs483 |= 2;
						} else {
							bs483 &= -3;
						}
						break;
					case 7:
						if(v483) {
							bs483 |= 1;
						} else {
							bs483 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs483;
				var this485 = 0;
				var bs484 = this485;
				var l484 = "     ".length;
				var _g1485 = 0;
				var _g585 = l484;
				while(_g1485 < _g585) {
					var i485 = _g1485++;
					var no484 = "     ".charCodeAt(i485);
					if(no484 == null) {
						break;
					}
					var v484;
					switch(no484) {
					case 32:
						v484 = false;
						break;
					case 42:
						v484 = true;
						break;
					case 48:
						v484 = false;
						break;
					case 49:
						v484 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i485)));
					}
					switch(i485 - (l484 - 8)) {
					case 0:
						if(v484) {
							bs484 |= 128;
						} else {
							bs484 &= -129;
						}
						break;
					case 1:
						if(v484) {
							bs484 |= 64;
						} else {
							bs484 &= -65;
						}
						break;
					case 2:
						if(v484) {
							bs484 |= 32;
						} else {
							bs484 &= -33;
						}
						break;
					case 3:
						if(v484) {
							bs484 |= 16;
						} else {
							bs484 &= -17;
						}
						break;
					case 4:
						if(v484) {
							bs484 |= 8;
						} else {
							bs484 &= -9;
						}
						break;
					case 5:
						if(v484) {
							bs484 |= 4;
						} else {
							bs484 &= -5;
						}
						break;
					case 6:
						if(v484) {
							bs484 |= 2;
						} else {
							bs484 &= -3;
						}
						break;
					case 7:
						if(v484) {
							bs484 |= 1;
						} else {
							bs484 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs484;
				var this486 = 0;
				var bs485 = this486;
				var l485 = " *** ".length;
				var _g1486 = 0;
				var _g586 = l485;
				while(_g1486 < _g586) {
					var i486 = _g1486++;
					var no485 = " *** ".charCodeAt(i486);
					if(no485 == null) {
						break;
					}
					var v485;
					switch(no485) {
					case 32:
						v485 = false;
						break;
					case 42:
						v485 = true;
						break;
					case 48:
						v485 = false;
						break;
					case 49:
						v485 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i486)));
					}
					switch(i486 - (l485 - 8)) {
					case 0:
						if(v485) {
							bs485 |= 128;
						} else {
							bs485 &= -129;
						}
						break;
					case 1:
						if(v485) {
							bs485 |= 64;
						} else {
							bs485 &= -65;
						}
						break;
					case 2:
						if(v485) {
							bs485 |= 32;
						} else {
							bs485 &= -33;
						}
						break;
					case 3:
						if(v485) {
							bs485 |= 16;
						} else {
							bs485 &= -17;
						}
						break;
					case 4:
						if(v485) {
							bs485 |= 8;
						} else {
							bs485 &= -9;
						}
						break;
					case 5:
						if(v485) {
							bs485 |= 4;
						} else {
							bs485 &= -5;
						}
						break;
					case 6:
						if(v485) {
							bs485 |= 2;
						} else {
							bs485 &= -3;
						}
						break;
					case 7:
						if(v485) {
							bs485 |= 1;
						} else {
							bs485 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs485;
				var this487 = 0;
				var bs486 = this487;
				var l486 = "*   *".length;
				var _g1487 = 0;
				var _g587 = l486;
				while(_g1487 < _g587) {
					var i487 = _g1487++;
					var no486 = "*   *".charCodeAt(i487);
					if(no486 == null) {
						break;
					}
					var v486;
					switch(no486) {
					case 32:
						v486 = false;
						break;
					case 42:
						v486 = true;
						break;
					case 48:
						v486 = false;
						break;
					case 49:
						v486 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i487)));
					}
					switch(i487 - (l486 - 8)) {
					case 0:
						if(v486) {
							bs486 |= 128;
						} else {
							bs486 &= -129;
						}
						break;
					case 1:
						if(v486) {
							bs486 |= 64;
						} else {
							bs486 &= -65;
						}
						break;
					case 2:
						if(v486) {
							bs486 |= 32;
						} else {
							bs486 &= -33;
						}
						break;
					case 3:
						if(v486) {
							bs486 |= 16;
						} else {
							bs486 &= -17;
						}
						break;
					case 4:
						if(v486) {
							bs486 |= 8;
						} else {
							bs486 &= -9;
						}
						break;
					case 5:
						if(v486) {
							bs486 |= 4;
						} else {
							bs486 &= -5;
						}
						break;
					case 6:
						if(v486) {
							bs486 |= 2;
						} else {
							bs486 &= -3;
						}
						break;
					case 7:
						if(v486) {
							bs486 |= 1;
						} else {
							bs486 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs486;
				var this488 = 0;
				var bs487 = this488;
				var l487 = "*****".length;
				var _g1488 = 0;
				var _g588 = l487;
				while(_g1488 < _g588) {
					var i488 = _g1488++;
					var no487 = "*****".charCodeAt(i488);
					if(no487 == null) {
						break;
					}
					var v487;
					switch(no487) {
					case 32:
						v487 = false;
						break;
					case 42:
						v487 = true;
						break;
					case 48:
						v487 = false;
						break;
					case 49:
						v487 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i488)));
					}
					switch(i488 - (l487 - 8)) {
					case 0:
						if(v487) {
							bs487 |= 128;
						} else {
							bs487 &= -129;
						}
						break;
					case 1:
						if(v487) {
							bs487 |= 64;
						} else {
							bs487 &= -65;
						}
						break;
					case 2:
						if(v487) {
							bs487 |= 32;
						} else {
							bs487 &= -33;
						}
						break;
					case 3:
						if(v487) {
							bs487 |= 16;
						} else {
							bs487 &= -17;
						}
						break;
					case 4:
						if(v487) {
							bs487 |= 8;
						} else {
							bs487 &= -9;
						}
						break;
					case 5:
						if(v487) {
							bs487 |= 4;
						} else {
							bs487 &= -5;
						}
						break;
					case 6:
						if(v487) {
							bs487 |= 2;
						} else {
							bs487 &= -3;
						}
						break;
					case 7:
						if(v487) {
							bs487 |= 1;
						} else {
							bs487 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs487;
				var this489 = 0;
				var bs488 = this489;
				var l488 = "*    ".length;
				var _g1489 = 0;
				var _g589 = l488;
				while(_g1489 < _g589) {
					var i489 = _g1489++;
					var no488 = "*    ".charCodeAt(i489);
					if(no488 == null) {
						break;
					}
					var v488;
					switch(no488) {
					case 32:
						v488 = false;
						break;
					case 42:
						v488 = true;
						break;
					case 48:
						v488 = false;
						break;
					case 49:
						v488 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i489)));
					}
					switch(i489 - (l488 - 8)) {
					case 0:
						if(v488) {
							bs488 |= 128;
						} else {
							bs488 &= -129;
						}
						break;
					case 1:
						if(v488) {
							bs488 |= 64;
						} else {
							bs488 &= -65;
						}
						break;
					case 2:
						if(v488) {
							bs488 |= 32;
						} else {
							bs488 &= -33;
						}
						break;
					case 3:
						if(v488) {
							bs488 |= 16;
						} else {
							bs488 &= -17;
						}
						break;
					case 4:
						if(v488) {
							bs488 |= 8;
						} else {
							bs488 &= -9;
						}
						break;
					case 5:
						if(v488) {
							bs488 |= 4;
						} else {
							bs488 &= -5;
						}
						break;
					case 6:
						if(v488) {
							bs488 |= 2;
						} else {
							bs488 &= -3;
						}
						break;
					case 7:
						if(v488) {
							bs488 |= 1;
						} else {
							bs488 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs488;
				var this490 = 0;
				var bs489 = this490;
				var l489 = " *** ".length;
				var _g1490 = 0;
				var _g590 = l489;
				while(_g1490 < _g590) {
					var i490 = _g1490++;
					var no489 = " *** ".charCodeAt(i490);
					if(no489 == null) {
						break;
					}
					var v489;
					switch(no489) {
					case 32:
						v489 = false;
						break;
					case 42:
						v489 = true;
						break;
					case 48:
						v489 = false;
						break;
					case 49:
						v489 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i490)));
					}
					switch(i490 - (l489 - 8)) {
					case 0:
						if(v489) {
							bs489 |= 128;
						} else {
							bs489 &= -129;
						}
						break;
					case 1:
						if(v489) {
							bs489 |= 64;
						} else {
							bs489 &= -65;
						}
						break;
					case 2:
						if(v489) {
							bs489 |= 32;
						} else {
							bs489 &= -33;
						}
						break;
					case 3:
						if(v489) {
							bs489 |= 16;
						} else {
							bs489 &= -17;
						}
						break;
					case 4:
						if(v489) {
							bs489 |= 8;
						} else {
							bs489 &= -9;
						}
						break;
					case 5:
						if(v489) {
							bs489 |= 4;
						} else {
							bs489 &= -5;
						}
						break;
					case 6:
						if(v489) {
							bs489 |= 2;
						} else {
							bs489 &= -3;
						}
						break;
					case 7:
						if(v489) {
							bs489 |= 1;
						} else {
							bs489 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs489;
				break;
			case 102:
				var this491 = 0;
				var bs490 = this491;
				var l490 = "  ** ".length;
				var _g1491 = 0;
				var _g591 = l490;
				while(_g1491 < _g591) {
					var i491 = _g1491++;
					var no490 = "  ** ".charCodeAt(i491);
					if(no490 == null) {
						break;
					}
					var v490;
					switch(no490) {
					case 32:
						v490 = false;
						break;
					case 42:
						v490 = true;
						break;
					case 48:
						v490 = false;
						break;
					case 49:
						v490 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i491)));
					}
					switch(i491 - (l490 - 8)) {
					case 0:
						if(v490) {
							bs490 |= 128;
						} else {
							bs490 &= -129;
						}
						break;
					case 1:
						if(v490) {
							bs490 |= 64;
						} else {
							bs490 &= -65;
						}
						break;
					case 2:
						if(v490) {
							bs490 |= 32;
						} else {
							bs490 &= -33;
						}
						break;
					case 3:
						if(v490) {
							bs490 |= 16;
						} else {
							bs490 &= -17;
						}
						break;
					case 4:
						if(v490) {
							bs490 |= 8;
						} else {
							bs490 &= -9;
						}
						break;
					case 5:
						if(v490) {
							bs490 |= 4;
						} else {
							bs490 &= -5;
						}
						break;
					case 6:
						if(v490) {
							bs490 |= 2;
						} else {
							bs490 &= -3;
						}
						break;
					case 7:
						if(v490) {
							bs490 |= 1;
						} else {
							bs490 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs490;
				var this492 = 0;
				var bs491 = this492;
				var l491 = " *  *".length;
				var _g1492 = 0;
				var _g592 = l491;
				while(_g1492 < _g592) {
					var i492 = _g1492++;
					var no491 = " *  *".charCodeAt(i492);
					if(no491 == null) {
						break;
					}
					var v491;
					switch(no491) {
					case 32:
						v491 = false;
						break;
					case 42:
						v491 = true;
						break;
					case 48:
						v491 = false;
						break;
					case 49:
						v491 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *  *".charCodeAt(i492)));
					}
					switch(i492 - (l491 - 8)) {
					case 0:
						if(v491) {
							bs491 |= 128;
						} else {
							bs491 &= -129;
						}
						break;
					case 1:
						if(v491) {
							bs491 |= 64;
						} else {
							bs491 &= -65;
						}
						break;
					case 2:
						if(v491) {
							bs491 |= 32;
						} else {
							bs491 &= -33;
						}
						break;
					case 3:
						if(v491) {
							bs491 |= 16;
						} else {
							bs491 &= -17;
						}
						break;
					case 4:
						if(v491) {
							bs491 |= 8;
						} else {
							bs491 &= -9;
						}
						break;
					case 5:
						if(v491) {
							bs491 |= 4;
						} else {
							bs491 &= -5;
						}
						break;
					case 6:
						if(v491) {
							bs491 |= 2;
						} else {
							bs491 &= -3;
						}
						break;
					case 7:
						if(v491) {
							bs491 |= 1;
						} else {
							bs491 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs491;
				var this493 = 0;
				var bs492 = this493;
				var l492 = " *   ".length;
				var _g1493 = 0;
				var _g593 = l492;
				while(_g1493 < _g593) {
					var i493 = _g1493++;
					var no492 = " *   ".charCodeAt(i493);
					if(no492 == null) {
						break;
					}
					var v492;
					switch(no492) {
					case 32:
						v492 = false;
						break;
					case 42:
						v492 = true;
						break;
					case 48:
						v492 = false;
						break;
					case 49:
						v492 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i493)));
					}
					switch(i493 - (l492 - 8)) {
					case 0:
						if(v492) {
							bs492 |= 128;
						} else {
							bs492 &= -129;
						}
						break;
					case 1:
						if(v492) {
							bs492 |= 64;
						} else {
							bs492 &= -65;
						}
						break;
					case 2:
						if(v492) {
							bs492 |= 32;
						} else {
							bs492 &= -33;
						}
						break;
					case 3:
						if(v492) {
							bs492 |= 16;
						} else {
							bs492 &= -17;
						}
						break;
					case 4:
						if(v492) {
							bs492 |= 8;
						} else {
							bs492 &= -9;
						}
						break;
					case 5:
						if(v492) {
							bs492 |= 4;
						} else {
							bs492 &= -5;
						}
						break;
					case 6:
						if(v492) {
							bs492 |= 2;
						} else {
							bs492 &= -3;
						}
						break;
					case 7:
						if(v492) {
							bs492 |= 1;
						} else {
							bs492 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs492;
				var this494 = 0;
				var bs493 = this494;
				var l493 = "***  ".length;
				var _g1494 = 0;
				var _g594 = l493;
				while(_g1494 < _g594) {
					var i494 = _g1494++;
					var no493 = "***  ".charCodeAt(i494);
					if(no493 == null) {
						break;
					}
					var v493;
					switch(no493) {
					case 32:
						v493 = false;
						break;
					case 42:
						v493 = true;
						break;
					case 48:
						v493 = false;
						break;
					case 49:
						v493 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("***  ".charCodeAt(i494)));
					}
					switch(i494 - (l493 - 8)) {
					case 0:
						if(v493) {
							bs493 |= 128;
						} else {
							bs493 &= -129;
						}
						break;
					case 1:
						if(v493) {
							bs493 |= 64;
						} else {
							bs493 &= -65;
						}
						break;
					case 2:
						if(v493) {
							bs493 |= 32;
						} else {
							bs493 &= -33;
						}
						break;
					case 3:
						if(v493) {
							bs493 |= 16;
						} else {
							bs493 &= -17;
						}
						break;
					case 4:
						if(v493) {
							bs493 |= 8;
						} else {
							bs493 &= -9;
						}
						break;
					case 5:
						if(v493) {
							bs493 |= 4;
						} else {
							bs493 &= -5;
						}
						break;
					case 6:
						if(v493) {
							bs493 |= 2;
						} else {
							bs493 &= -3;
						}
						break;
					case 7:
						if(v493) {
							bs493 |= 1;
						} else {
							bs493 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs493;
				var this495 = 0;
				var bs494 = this495;
				var l494 = " *   ".length;
				var _g1495 = 0;
				var _g595 = l494;
				while(_g1495 < _g595) {
					var i495 = _g1495++;
					var no494 = " *   ".charCodeAt(i495);
					if(no494 == null) {
						break;
					}
					var v494;
					switch(no494) {
					case 32:
						v494 = false;
						break;
					case 42:
						v494 = true;
						break;
					case 48:
						v494 = false;
						break;
					case 49:
						v494 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i495)));
					}
					switch(i495 - (l494 - 8)) {
					case 0:
						if(v494) {
							bs494 |= 128;
						} else {
							bs494 &= -129;
						}
						break;
					case 1:
						if(v494) {
							bs494 |= 64;
						} else {
							bs494 &= -65;
						}
						break;
					case 2:
						if(v494) {
							bs494 |= 32;
						} else {
							bs494 &= -33;
						}
						break;
					case 3:
						if(v494) {
							bs494 |= 16;
						} else {
							bs494 &= -17;
						}
						break;
					case 4:
						if(v494) {
							bs494 |= 8;
						} else {
							bs494 &= -9;
						}
						break;
					case 5:
						if(v494) {
							bs494 |= 4;
						} else {
							bs494 &= -5;
						}
						break;
					case 6:
						if(v494) {
							bs494 |= 2;
						} else {
							bs494 &= -3;
						}
						break;
					case 7:
						if(v494) {
							bs494 |= 1;
						} else {
							bs494 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs494;
				var this496 = 0;
				var bs495 = this496;
				var l495 = " *   ".length;
				var _g1496 = 0;
				var _g596 = l495;
				while(_g1496 < _g596) {
					var i496 = _g1496++;
					var no495 = " *   ".charCodeAt(i496);
					if(no495 == null) {
						break;
					}
					var v495;
					switch(no495) {
					case 32:
						v495 = false;
						break;
					case 42:
						v495 = true;
						break;
					case 48:
						v495 = false;
						break;
					case 49:
						v495 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i496)));
					}
					switch(i496 - (l495 - 8)) {
					case 0:
						if(v495) {
							bs495 |= 128;
						} else {
							bs495 &= -129;
						}
						break;
					case 1:
						if(v495) {
							bs495 |= 64;
						} else {
							bs495 &= -65;
						}
						break;
					case 2:
						if(v495) {
							bs495 |= 32;
						} else {
							bs495 &= -33;
						}
						break;
					case 3:
						if(v495) {
							bs495 |= 16;
						} else {
							bs495 &= -17;
						}
						break;
					case 4:
						if(v495) {
							bs495 |= 8;
						} else {
							bs495 &= -9;
						}
						break;
					case 5:
						if(v495) {
							bs495 |= 4;
						} else {
							bs495 &= -5;
						}
						break;
					case 6:
						if(v495) {
							bs495 |= 2;
						} else {
							bs495 &= -3;
						}
						break;
					case 7:
						if(v495) {
							bs495 |= 1;
						} else {
							bs495 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs495;
				var this497 = 0;
				var bs496 = this497;
				var l496 = " *   ".length;
				var _g1497 = 0;
				var _g597 = l496;
				while(_g1497 < _g597) {
					var i497 = _g1497++;
					var no496 = " *   ".charCodeAt(i497);
					if(no496 == null) {
						break;
					}
					var v496;
					switch(no496) {
					case 32:
						v496 = false;
						break;
					case 42:
						v496 = true;
						break;
					case 48:
						v496 = false;
						break;
					case 49:
						v496 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i497)));
					}
					switch(i497 - (l496 - 8)) {
					case 0:
						if(v496) {
							bs496 |= 128;
						} else {
							bs496 &= -129;
						}
						break;
					case 1:
						if(v496) {
							bs496 |= 64;
						} else {
							bs496 &= -65;
						}
						break;
					case 2:
						if(v496) {
							bs496 |= 32;
						} else {
							bs496 &= -33;
						}
						break;
					case 3:
						if(v496) {
							bs496 |= 16;
						} else {
							bs496 &= -17;
						}
						break;
					case 4:
						if(v496) {
							bs496 |= 8;
						} else {
							bs496 &= -9;
						}
						break;
					case 5:
						if(v496) {
							bs496 |= 4;
						} else {
							bs496 &= -5;
						}
						break;
					case 6:
						if(v496) {
							bs496 |= 2;
						} else {
							bs496 &= -3;
						}
						break;
					case 7:
						if(v496) {
							bs496 |= 1;
						} else {
							bs496 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs496;
				break;
			case 103:
				var this498 = 0;
				var bs497 = this498;
				var l497 = "     ".length;
				var _g1498 = 0;
				var _g598 = l497;
				while(_g1498 < _g598) {
					var i498 = _g1498++;
					var no497 = "     ".charCodeAt(i498);
					if(no497 == null) {
						break;
					}
					var v497;
					switch(no497) {
					case 32:
						v497 = false;
						break;
					case 42:
						v497 = true;
						break;
					case 48:
						v497 = false;
						break;
					case 49:
						v497 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i498)));
					}
					switch(i498 - (l497 - 8)) {
					case 0:
						if(v497) {
							bs497 |= 128;
						} else {
							bs497 &= -129;
						}
						break;
					case 1:
						if(v497) {
							bs497 |= 64;
						} else {
							bs497 &= -65;
						}
						break;
					case 2:
						if(v497) {
							bs497 |= 32;
						} else {
							bs497 &= -33;
						}
						break;
					case 3:
						if(v497) {
							bs497 |= 16;
						} else {
							bs497 &= -17;
						}
						break;
					case 4:
						if(v497) {
							bs497 |= 8;
						} else {
							bs497 &= -9;
						}
						break;
					case 5:
						if(v497) {
							bs497 |= 4;
						} else {
							bs497 &= -5;
						}
						break;
					case 6:
						if(v497) {
							bs497 |= 2;
						} else {
							bs497 &= -3;
						}
						break;
					case 7:
						if(v497) {
							bs497 |= 1;
						} else {
							bs497 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs497;
				var this499 = 0;
				var bs498 = this499;
				var l498 = " ****".length;
				var _g1499 = 0;
				var _g599 = l498;
				while(_g1499 < _g599) {
					var i499 = _g1499++;
					var no498 = " ****".charCodeAt(i499);
					if(no498 == null) {
						break;
					}
					var v498;
					switch(no498) {
					case 32:
						v498 = false;
						break;
					case 42:
						v498 = true;
						break;
					case 48:
						v498 = false;
						break;
					case 49:
						v498 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i499)));
					}
					switch(i499 - (l498 - 8)) {
					case 0:
						if(v498) {
							bs498 |= 128;
						} else {
							bs498 &= -129;
						}
						break;
					case 1:
						if(v498) {
							bs498 |= 64;
						} else {
							bs498 &= -65;
						}
						break;
					case 2:
						if(v498) {
							bs498 |= 32;
						} else {
							bs498 &= -33;
						}
						break;
					case 3:
						if(v498) {
							bs498 |= 16;
						} else {
							bs498 &= -17;
						}
						break;
					case 4:
						if(v498) {
							bs498 |= 8;
						} else {
							bs498 &= -9;
						}
						break;
					case 5:
						if(v498) {
							bs498 |= 4;
						} else {
							bs498 &= -5;
						}
						break;
					case 6:
						if(v498) {
							bs498 |= 2;
						} else {
							bs498 &= -3;
						}
						break;
					case 7:
						if(v498) {
							bs498 |= 1;
						} else {
							bs498 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs498;
				var this500 = 0;
				var bs499 = this500;
				var l499 = "*   *".length;
				var _g1500 = 0;
				var _g600 = l499;
				while(_g1500 < _g600) {
					var i500 = _g1500++;
					var no499 = "*   *".charCodeAt(i500);
					if(no499 == null) {
						break;
					}
					var v499;
					switch(no499) {
					case 32:
						v499 = false;
						break;
					case 42:
						v499 = true;
						break;
					case 48:
						v499 = false;
						break;
					case 49:
						v499 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i500)));
					}
					switch(i500 - (l499 - 8)) {
					case 0:
						if(v499) {
							bs499 |= 128;
						} else {
							bs499 &= -129;
						}
						break;
					case 1:
						if(v499) {
							bs499 |= 64;
						} else {
							bs499 &= -65;
						}
						break;
					case 2:
						if(v499) {
							bs499 |= 32;
						} else {
							bs499 &= -33;
						}
						break;
					case 3:
						if(v499) {
							bs499 |= 16;
						} else {
							bs499 &= -17;
						}
						break;
					case 4:
						if(v499) {
							bs499 |= 8;
						} else {
							bs499 &= -9;
						}
						break;
					case 5:
						if(v499) {
							bs499 |= 4;
						} else {
							bs499 &= -5;
						}
						break;
					case 6:
						if(v499) {
							bs499 |= 2;
						} else {
							bs499 &= -3;
						}
						break;
					case 7:
						if(v499) {
							bs499 |= 1;
						} else {
							bs499 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs499;
				var this501 = 0;
				var bs500 = this501;
				var l500 = "*   *".length;
				var _g1501 = 0;
				var _g601 = l500;
				while(_g1501 < _g601) {
					var i501 = _g1501++;
					var no500 = "*   *".charCodeAt(i501);
					if(no500 == null) {
						break;
					}
					var v500;
					switch(no500) {
					case 32:
						v500 = false;
						break;
					case 42:
						v500 = true;
						break;
					case 48:
						v500 = false;
						break;
					case 49:
						v500 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i501)));
					}
					switch(i501 - (l500 - 8)) {
					case 0:
						if(v500) {
							bs500 |= 128;
						} else {
							bs500 &= -129;
						}
						break;
					case 1:
						if(v500) {
							bs500 |= 64;
						} else {
							bs500 &= -65;
						}
						break;
					case 2:
						if(v500) {
							bs500 |= 32;
						} else {
							bs500 &= -33;
						}
						break;
					case 3:
						if(v500) {
							bs500 |= 16;
						} else {
							bs500 &= -17;
						}
						break;
					case 4:
						if(v500) {
							bs500 |= 8;
						} else {
							bs500 &= -9;
						}
						break;
					case 5:
						if(v500) {
							bs500 |= 4;
						} else {
							bs500 &= -5;
						}
						break;
					case 6:
						if(v500) {
							bs500 |= 2;
						} else {
							bs500 &= -3;
						}
						break;
					case 7:
						if(v500) {
							bs500 |= 1;
						} else {
							bs500 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs500;
				var this502 = 0;
				var bs501 = this502;
				var l501 = " ****".length;
				var _g1502 = 0;
				var _g602 = l501;
				while(_g1502 < _g602) {
					var i502 = _g1502++;
					var no501 = " ****".charCodeAt(i502);
					if(no501 == null) {
						break;
					}
					var v501;
					switch(no501) {
					case 32:
						v501 = false;
						break;
					case 42:
						v501 = true;
						break;
					case 48:
						v501 = false;
						break;
					case 49:
						v501 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i502)));
					}
					switch(i502 - (l501 - 8)) {
					case 0:
						if(v501) {
							bs501 |= 128;
						} else {
							bs501 &= -129;
						}
						break;
					case 1:
						if(v501) {
							bs501 |= 64;
						} else {
							bs501 &= -65;
						}
						break;
					case 2:
						if(v501) {
							bs501 |= 32;
						} else {
							bs501 &= -33;
						}
						break;
					case 3:
						if(v501) {
							bs501 |= 16;
						} else {
							bs501 &= -17;
						}
						break;
					case 4:
						if(v501) {
							bs501 |= 8;
						} else {
							bs501 &= -9;
						}
						break;
					case 5:
						if(v501) {
							bs501 |= 4;
						} else {
							bs501 &= -5;
						}
						break;
					case 6:
						if(v501) {
							bs501 |= 2;
						} else {
							bs501 &= -3;
						}
						break;
					case 7:
						if(v501) {
							bs501 |= 1;
						} else {
							bs501 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs501;
				var this503 = 0;
				var bs502 = this503;
				var l502 = "    *".length;
				var _g1503 = 0;
				var _g603 = l502;
				while(_g1503 < _g603) {
					var i503 = _g1503++;
					var no502 = "    *".charCodeAt(i503);
					if(no502 == null) {
						break;
					}
					var v502;
					switch(no502) {
					case 32:
						v502 = false;
						break;
					case 42:
						v502 = true;
						break;
					case 48:
						v502 = false;
						break;
					case 49:
						v502 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i503)));
					}
					switch(i503 - (l502 - 8)) {
					case 0:
						if(v502) {
							bs502 |= 128;
						} else {
							bs502 &= -129;
						}
						break;
					case 1:
						if(v502) {
							bs502 |= 64;
						} else {
							bs502 &= -65;
						}
						break;
					case 2:
						if(v502) {
							bs502 |= 32;
						} else {
							bs502 &= -33;
						}
						break;
					case 3:
						if(v502) {
							bs502 |= 16;
						} else {
							bs502 &= -17;
						}
						break;
					case 4:
						if(v502) {
							bs502 |= 8;
						} else {
							bs502 &= -9;
						}
						break;
					case 5:
						if(v502) {
							bs502 |= 4;
						} else {
							bs502 &= -5;
						}
						break;
					case 6:
						if(v502) {
							bs502 |= 2;
						} else {
							bs502 &= -3;
						}
						break;
					case 7:
						if(v502) {
							bs502 |= 1;
						} else {
							bs502 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs502;
				var this504 = 0;
				var bs503 = this504;
				var l503 = " *** ".length;
				var _g1504 = 0;
				var _g604 = l503;
				while(_g1504 < _g604) {
					var i504 = _g1504++;
					var no503 = " *** ".charCodeAt(i504);
					if(no503 == null) {
						break;
					}
					var v503;
					switch(no503) {
					case 32:
						v503 = false;
						break;
					case 42:
						v503 = true;
						break;
					case 48:
						v503 = false;
						break;
					case 49:
						v503 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i504)));
					}
					switch(i504 - (l503 - 8)) {
					case 0:
						if(v503) {
							bs503 |= 128;
						} else {
							bs503 &= -129;
						}
						break;
					case 1:
						if(v503) {
							bs503 |= 64;
						} else {
							bs503 &= -65;
						}
						break;
					case 2:
						if(v503) {
							bs503 |= 32;
						} else {
							bs503 &= -33;
						}
						break;
					case 3:
						if(v503) {
							bs503 |= 16;
						} else {
							bs503 &= -17;
						}
						break;
					case 4:
						if(v503) {
							bs503 |= 8;
						} else {
							bs503 &= -9;
						}
						break;
					case 5:
						if(v503) {
							bs503 |= 4;
						} else {
							bs503 &= -5;
						}
						break;
					case 6:
						if(v503) {
							bs503 |= 2;
						} else {
							bs503 &= -3;
						}
						break;
					case 7:
						if(v503) {
							bs503 |= 1;
						} else {
							bs503 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs503;
				break;
			case 104:
				var this505 = 0;
				var bs504 = this505;
				var l504 = "*    ".length;
				var _g1505 = 0;
				var _g605 = l504;
				while(_g1505 < _g605) {
					var i505 = _g1505++;
					var no504 = "*    ".charCodeAt(i505);
					if(no504 == null) {
						break;
					}
					var v504;
					switch(no504) {
					case 32:
						v504 = false;
						break;
					case 42:
						v504 = true;
						break;
					case 48:
						v504 = false;
						break;
					case 49:
						v504 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i505)));
					}
					switch(i505 - (l504 - 8)) {
					case 0:
						if(v504) {
							bs504 |= 128;
						} else {
							bs504 &= -129;
						}
						break;
					case 1:
						if(v504) {
							bs504 |= 64;
						} else {
							bs504 &= -65;
						}
						break;
					case 2:
						if(v504) {
							bs504 |= 32;
						} else {
							bs504 &= -33;
						}
						break;
					case 3:
						if(v504) {
							bs504 |= 16;
						} else {
							bs504 &= -17;
						}
						break;
					case 4:
						if(v504) {
							bs504 |= 8;
						} else {
							bs504 &= -9;
						}
						break;
					case 5:
						if(v504) {
							bs504 |= 4;
						} else {
							bs504 &= -5;
						}
						break;
					case 6:
						if(v504) {
							bs504 |= 2;
						} else {
							bs504 &= -3;
						}
						break;
					case 7:
						if(v504) {
							bs504 |= 1;
						} else {
							bs504 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs504;
				var this506 = 0;
				var bs505 = this506;
				var l505 = "*    ".length;
				var _g1506 = 0;
				var _g606 = l505;
				while(_g1506 < _g606) {
					var i506 = _g1506++;
					var no505 = "*    ".charCodeAt(i506);
					if(no505 == null) {
						break;
					}
					var v505;
					switch(no505) {
					case 32:
						v505 = false;
						break;
					case 42:
						v505 = true;
						break;
					case 48:
						v505 = false;
						break;
					case 49:
						v505 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i506)));
					}
					switch(i506 - (l505 - 8)) {
					case 0:
						if(v505) {
							bs505 |= 128;
						} else {
							bs505 &= -129;
						}
						break;
					case 1:
						if(v505) {
							bs505 |= 64;
						} else {
							bs505 &= -65;
						}
						break;
					case 2:
						if(v505) {
							bs505 |= 32;
						} else {
							bs505 &= -33;
						}
						break;
					case 3:
						if(v505) {
							bs505 |= 16;
						} else {
							bs505 &= -17;
						}
						break;
					case 4:
						if(v505) {
							bs505 |= 8;
						} else {
							bs505 &= -9;
						}
						break;
					case 5:
						if(v505) {
							bs505 |= 4;
						} else {
							bs505 &= -5;
						}
						break;
					case 6:
						if(v505) {
							bs505 |= 2;
						} else {
							bs505 &= -3;
						}
						break;
					case 7:
						if(v505) {
							bs505 |= 1;
						} else {
							bs505 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs505;
				var this507 = 0;
				var bs506 = this507;
				var l506 = "* ** ".length;
				var _g1507 = 0;
				var _g607 = l506;
				while(_g1507 < _g607) {
					var i507 = _g1507++;
					var no506 = "* ** ".charCodeAt(i507);
					if(no506 == null) {
						break;
					}
					var v506;
					switch(no506) {
					case 32:
						v506 = false;
						break;
					case 42:
						v506 = true;
						break;
					case 48:
						v506 = false;
						break;
					case 49:
						v506 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* ** ".charCodeAt(i507)));
					}
					switch(i507 - (l506 - 8)) {
					case 0:
						if(v506) {
							bs506 |= 128;
						} else {
							bs506 &= -129;
						}
						break;
					case 1:
						if(v506) {
							bs506 |= 64;
						} else {
							bs506 &= -65;
						}
						break;
					case 2:
						if(v506) {
							bs506 |= 32;
						} else {
							bs506 &= -33;
						}
						break;
					case 3:
						if(v506) {
							bs506 |= 16;
						} else {
							bs506 &= -17;
						}
						break;
					case 4:
						if(v506) {
							bs506 |= 8;
						} else {
							bs506 &= -9;
						}
						break;
					case 5:
						if(v506) {
							bs506 |= 4;
						} else {
							bs506 &= -5;
						}
						break;
					case 6:
						if(v506) {
							bs506 |= 2;
						} else {
							bs506 &= -3;
						}
						break;
					case 7:
						if(v506) {
							bs506 |= 1;
						} else {
							bs506 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs506;
				var this508 = 0;
				var bs507 = this508;
				var l507 = "**  *".length;
				var _g1508 = 0;
				var _g608 = l507;
				while(_g1508 < _g608) {
					var i508 = _g1508++;
					var no507 = "**  *".charCodeAt(i508);
					if(no507 == null) {
						break;
					}
					var v507;
					switch(no507) {
					case 32:
						v507 = false;
						break;
					case 42:
						v507 = true;
						break;
					case 48:
						v507 = false;
						break;
					case 49:
						v507 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i508)));
					}
					switch(i508 - (l507 - 8)) {
					case 0:
						if(v507) {
							bs507 |= 128;
						} else {
							bs507 &= -129;
						}
						break;
					case 1:
						if(v507) {
							bs507 |= 64;
						} else {
							bs507 &= -65;
						}
						break;
					case 2:
						if(v507) {
							bs507 |= 32;
						} else {
							bs507 &= -33;
						}
						break;
					case 3:
						if(v507) {
							bs507 |= 16;
						} else {
							bs507 &= -17;
						}
						break;
					case 4:
						if(v507) {
							bs507 |= 8;
						} else {
							bs507 &= -9;
						}
						break;
					case 5:
						if(v507) {
							bs507 |= 4;
						} else {
							bs507 &= -5;
						}
						break;
					case 6:
						if(v507) {
							bs507 |= 2;
						} else {
							bs507 &= -3;
						}
						break;
					case 7:
						if(v507) {
							bs507 |= 1;
						} else {
							bs507 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs507;
				var this509 = 0;
				var bs508 = this509;
				var l508 = "*   *".length;
				var _g1509 = 0;
				var _g609 = l508;
				while(_g1509 < _g609) {
					var i509 = _g1509++;
					var no508 = "*   *".charCodeAt(i509);
					if(no508 == null) {
						break;
					}
					var v508;
					switch(no508) {
					case 32:
						v508 = false;
						break;
					case 42:
						v508 = true;
						break;
					case 48:
						v508 = false;
						break;
					case 49:
						v508 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i509)));
					}
					switch(i509 - (l508 - 8)) {
					case 0:
						if(v508) {
							bs508 |= 128;
						} else {
							bs508 &= -129;
						}
						break;
					case 1:
						if(v508) {
							bs508 |= 64;
						} else {
							bs508 &= -65;
						}
						break;
					case 2:
						if(v508) {
							bs508 |= 32;
						} else {
							bs508 &= -33;
						}
						break;
					case 3:
						if(v508) {
							bs508 |= 16;
						} else {
							bs508 &= -17;
						}
						break;
					case 4:
						if(v508) {
							bs508 |= 8;
						} else {
							bs508 &= -9;
						}
						break;
					case 5:
						if(v508) {
							bs508 |= 4;
						} else {
							bs508 &= -5;
						}
						break;
					case 6:
						if(v508) {
							bs508 |= 2;
						} else {
							bs508 &= -3;
						}
						break;
					case 7:
						if(v508) {
							bs508 |= 1;
						} else {
							bs508 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs508;
				var this510 = 0;
				var bs509 = this510;
				var l509 = "*   *".length;
				var _g1510 = 0;
				var _g610 = l509;
				while(_g1510 < _g610) {
					var i510 = _g1510++;
					var no509 = "*   *".charCodeAt(i510);
					if(no509 == null) {
						break;
					}
					var v509;
					switch(no509) {
					case 32:
						v509 = false;
						break;
					case 42:
						v509 = true;
						break;
					case 48:
						v509 = false;
						break;
					case 49:
						v509 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i510)));
					}
					switch(i510 - (l509 - 8)) {
					case 0:
						if(v509) {
							bs509 |= 128;
						} else {
							bs509 &= -129;
						}
						break;
					case 1:
						if(v509) {
							bs509 |= 64;
						} else {
							bs509 &= -65;
						}
						break;
					case 2:
						if(v509) {
							bs509 |= 32;
						} else {
							bs509 &= -33;
						}
						break;
					case 3:
						if(v509) {
							bs509 |= 16;
						} else {
							bs509 &= -17;
						}
						break;
					case 4:
						if(v509) {
							bs509 |= 8;
						} else {
							bs509 &= -9;
						}
						break;
					case 5:
						if(v509) {
							bs509 |= 4;
						} else {
							bs509 &= -5;
						}
						break;
					case 6:
						if(v509) {
							bs509 |= 2;
						} else {
							bs509 &= -3;
						}
						break;
					case 7:
						if(v509) {
							bs509 |= 1;
						} else {
							bs509 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs509;
				var this511 = 0;
				var bs510 = this511;
				var l510 = "*   *".length;
				var _g1511 = 0;
				var _g611 = l510;
				while(_g1511 < _g611) {
					var i511 = _g1511++;
					var no510 = "*   *".charCodeAt(i511);
					if(no510 == null) {
						break;
					}
					var v510;
					switch(no510) {
					case 32:
						v510 = false;
						break;
					case 42:
						v510 = true;
						break;
					case 48:
						v510 = false;
						break;
					case 49:
						v510 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i511)));
					}
					switch(i511 - (l510 - 8)) {
					case 0:
						if(v510) {
							bs510 |= 128;
						} else {
							bs510 &= -129;
						}
						break;
					case 1:
						if(v510) {
							bs510 |= 64;
						} else {
							bs510 &= -65;
						}
						break;
					case 2:
						if(v510) {
							bs510 |= 32;
						} else {
							bs510 &= -33;
						}
						break;
					case 3:
						if(v510) {
							bs510 |= 16;
						} else {
							bs510 &= -17;
						}
						break;
					case 4:
						if(v510) {
							bs510 |= 8;
						} else {
							bs510 &= -9;
						}
						break;
					case 5:
						if(v510) {
							bs510 |= 4;
						} else {
							bs510 &= -5;
						}
						break;
					case 6:
						if(v510) {
							bs510 |= 2;
						} else {
							bs510 &= -3;
						}
						break;
					case 7:
						if(v510) {
							bs510 |= 1;
						} else {
							bs510 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs510;
				break;
			case 105:
				var this512 = 0;
				var bs511 = this512;
				var l511 = "  *  ".length;
				var _g1512 = 0;
				var _g612 = l511;
				while(_g1512 < _g612) {
					var i512 = _g1512++;
					var no511 = "  *  ".charCodeAt(i512);
					if(no511 == null) {
						break;
					}
					var v511;
					switch(no511) {
					case 32:
						v511 = false;
						break;
					case 42:
						v511 = true;
						break;
					case 48:
						v511 = false;
						break;
					case 49:
						v511 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i512)));
					}
					switch(i512 - (l511 - 8)) {
					case 0:
						if(v511) {
							bs511 |= 128;
						} else {
							bs511 &= -129;
						}
						break;
					case 1:
						if(v511) {
							bs511 |= 64;
						} else {
							bs511 &= -65;
						}
						break;
					case 2:
						if(v511) {
							bs511 |= 32;
						} else {
							bs511 &= -33;
						}
						break;
					case 3:
						if(v511) {
							bs511 |= 16;
						} else {
							bs511 &= -17;
						}
						break;
					case 4:
						if(v511) {
							bs511 |= 8;
						} else {
							bs511 &= -9;
						}
						break;
					case 5:
						if(v511) {
							bs511 |= 4;
						} else {
							bs511 &= -5;
						}
						break;
					case 6:
						if(v511) {
							bs511 |= 2;
						} else {
							bs511 &= -3;
						}
						break;
					case 7:
						if(v511) {
							bs511 |= 1;
						} else {
							bs511 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs511;
				var this513 = 0;
				var bs512 = this513;
				var l512 = "     ".length;
				var _g1513 = 0;
				var _g613 = l512;
				while(_g1513 < _g613) {
					var i513 = _g1513++;
					var no512 = "     ".charCodeAt(i513);
					if(no512 == null) {
						break;
					}
					var v512;
					switch(no512) {
					case 32:
						v512 = false;
						break;
					case 42:
						v512 = true;
						break;
					case 48:
						v512 = false;
						break;
					case 49:
						v512 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i513)));
					}
					switch(i513 - (l512 - 8)) {
					case 0:
						if(v512) {
							bs512 |= 128;
						} else {
							bs512 &= -129;
						}
						break;
					case 1:
						if(v512) {
							bs512 |= 64;
						} else {
							bs512 &= -65;
						}
						break;
					case 2:
						if(v512) {
							bs512 |= 32;
						} else {
							bs512 &= -33;
						}
						break;
					case 3:
						if(v512) {
							bs512 |= 16;
						} else {
							bs512 &= -17;
						}
						break;
					case 4:
						if(v512) {
							bs512 |= 8;
						} else {
							bs512 &= -9;
						}
						break;
					case 5:
						if(v512) {
							bs512 |= 4;
						} else {
							bs512 &= -5;
						}
						break;
					case 6:
						if(v512) {
							bs512 |= 2;
						} else {
							bs512 &= -3;
						}
						break;
					case 7:
						if(v512) {
							bs512 |= 1;
						} else {
							bs512 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs512;
				var this514 = 0;
				var bs513 = this514;
				var l513 = " **  ".length;
				var _g1514 = 0;
				var _g614 = l513;
				while(_g1514 < _g614) {
					var i514 = _g1514++;
					var no513 = " **  ".charCodeAt(i514);
					if(no513 == null) {
						break;
					}
					var v513;
					switch(no513) {
					case 32:
						v513 = false;
						break;
					case 42:
						v513 = true;
						break;
					case 48:
						v513 = false;
						break;
					case 49:
						v513 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i514)));
					}
					switch(i514 - (l513 - 8)) {
					case 0:
						if(v513) {
							bs513 |= 128;
						} else {
							bs513 &= -129;
						}
						break;
					case 1:
						if(v513) {
							bs513 |= 64;
						} else {
							bs513 &= -65;
						}
						break;
					case 2:
						if(v513) {
							bs513 |= 32;
						} else {
							bs513 &= -33;
						}
						break;
					case 3:
						if(v513) {
							bs513 |= 16;
						} else {
							bs513 &= -17;
						}
						break;
					case 4:
						if(v513) {
							bs513 |= 8;
						} else {
							bs513 &= -9;
						}
						break;
					case 5:
						if(v513) {
							bs513 |= 4;
						} else {
							bs513 &= -5;
						}
						break;
					case 6:
						if(v513) {
							bs513 |= 2;
						} else {
							bs513 &= -3;
						}
						break;
					case 7:
						if(v513) {
							bs513 |= 1;
						} else {
							bs513 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs513;
				var this515 = 0;
				var bs514 = this515;
				var l514 = "  *  ".length;
				var _g1515 = 0;
				var _g615 = l514;
				while(_g1515 < _g615) {
					var i515 = _g1515++;
					var no514 = "  *  ".charCodeAt(i515);
					if(no514 == null) {
						break;
					}
					var v514;
					switch(no514) {
					case 32:
						v514 = false;
						break;
					case 42:
						v514 = true;
						break;
					case 48:
						v514 = false;
						break;
					case 49:
						v514 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i515)));
					}
					switch(i515 - (l514 - 8)) {
					case 0:
						if(v514) {
							bs514 |= 128;
						} else {
							bs514 &= -129;
						}
						break;
					case 1:
						if(v514) {
							bs514 |= 64;
						} else {
							bs514 &= -65;
						}
						break;
					case 2:
						if(v514) {
							bs514 |= 32;
						} else {
							bs514 &= -33;
						}
						break;
					case 3:
						if(v514) {
							bs514 |= 16;
						} else {
							bs514 &= -17;
						}
						break;
					case 4:
						if(v514) {
							bs514 |= 8;
						} else {
							bs514 &= -9;
						}
						break;
					case 5:
						if(v514) {
							bs514 |= 4;
						} else {
							bs514 &= -5;
						}
						break;
					case 6:
						if(v514) {
							bs514 |= 2;
						} else {
							bs514 &= -3;
						}
						break;
					case 7:
						if(v514) {
							bs514 |= 1;
						} else {
							bs514 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs514;
				var this516 = 0;
				var bs515 = this516;
				var l515 = "  *  ".length;
				var _g1516 = 0;
				var _g616 = l515;
				while(_g1516 < _g616) {
					var i516 = _g1516++;
					var no515 = "  *  ".charCodeAt(i516);
					if(no515 == null) {
						break;
					}
					var v515;
					switch(no515) {
					case 32:
						v515 = false;
						break;
					case 42:
						v515 = true;
						break;
					case 48:
						v515 = false;
						break;
					case 49:
						v515 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i516)));
					}
					switch(i516 - (l515 - 8)) {
					case 0:
						if(v515) {
							bs515 |= 128;
						} else {
							bs515 &= -129;
						}
						break;
					case 1:
						if(v515) {
							bs515 |= 64;
						} else {
							bs515 &= -65;
						}
						break;
					case 2:
						if(v515) {
							bs515 |= 32;
						} else {
							bs515 &= -33;
						}
						break;
					case 3:
						if(v515) {
							bs515 |= 16;
						} else {
							bs515 &= -17;
						}
						break;
					case 4:
						if(v515) {
							bs515 |= 8;
						} else {
							bs515 &= -9;
						}
						break;
					case 5:
						if(v515) {
							bs515 |= 4;
						} else {
							bs515 &= -5;
						}
						break;
					case 6:
						if(v515) {
							bs515 |= 2;
						} else {
							bs515 &= -3;
						}
						break;
					case 7:
						if(v515) {
							bs515 |= 1;
						} else {
							bs515 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs515;
				var this517 = 0;
				var bs516 = this517;
				var l516 = "  *  ".length;
				var _g1517 = 0;
				var _g617 = l516;
				while(_g1517 < _g617) {
					var i517 = _g1517++;
					var no516 = "  *  ".charCodeAt(i517);
					if(no516 == null) {
						break;
					}
					var v516;
					switch(no516) {
					case 32:
						v516 = false;
						break;
					case 42:
						v516 = true;
						break;
					case 48:
						v516 = false;
						break;
					case 49:
						v516 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i517)));
					}
					switch(i517 - (l516 - 8)) {
					case 0:
						if(v516) {
							bs516 |= 128;
						} else {
							bs516 &= -129;
						}
						break;
					case 1:
						if(v516) {
							bs516 |= 64;
						} else {
							bs516 &= -65;
						}
						break;
					case 2:
						if(v516) {
							bs516 |= 32;
						} else {
							bs516 &= -33;
						}
						break;
					case 3:
						if(v516) {
							bs516 |= 16;
						} else {
							bs516 &= -17;
						}
						break;
					case 4:
						if(v516) {
							bs516 |= 8;
						} else {
							bs516 &= -9;
						}
						break;
					case 5:
						if(v516) {
							bs516 |= 4;
						} else {
							bs516 &= -5;
						}
						break;
					case 6:
						if(v516) {
							bs516 |= 2;
						} else {
							bs516 &= -3;
						}
						break;
					case 7:
						if(v516) {
							bs516 |= 1;
						} else {
							bs516 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs516;
				var this518 = 0;
				var bs517 = this518;
				var l517 = " *** ".length;
				var _g1518 = 0;
				var _g618 = l517;
				while(_g1518 < _g618) {
					var i518 = _g1518++;
					var no517 = " *** ".charCodeAt(i518);
					if(no517 == null) {
						break;
					}
					var v517;
					switch(no517) {
					case 32:
						v517 = false;
						break;
					case 42:
						v517 = true;
						break;
					case 48:
						v517 = false;
						break;
					case 49:
						v517 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i518)));
					}
					switch(i518 - (l517 - 8)) {
					case 0:
						if(v517) {
							bs517 |= 128;
						} else {
							bs517 &= -129;
						}
						break;
					case 1:
						if(v517) {
							bs517 |= 64;
						} else {
							bs517 &= -65;
						}
						break;
					case 2:
						if(v517) {
							bs517 |= 32;
						} else {
							bs517 &= -33;
						}
						break;
					case 3:
						if(v517) {
							bs517 |= 16;
						} else {
							bs517 &= -17;
						}
						break;
					case 4:
						if(v517) {
							bs517 |= 8;
						} else {
							bs517 &= -9;
						}
						break;
					case 5:
						if(v517) {
							bs517 |= 4;
						} else {
							bs517 &= -5;
						}
						break;
					case 6:
						if(v517) {
							bs517 |= 2;
						} else {
							bs517 &= -3;
						}
						break;
					case 7:
						if(v517) {
							bs517 |= 1;
						} else {
							bs517 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs517;
				break;
			case 106:
				var this519 = 0;
				var bs518 = this519;
				var l518 = "   * ".length;
				var _g1519 = 0;
				var _g619 = l518;
				while(_g1519 < _g619) {
					var i519 = _g1519++;
					var no518 = "   * ".charCodeAt(i519);
					if(no518 == null) {
						break;
					}
					var v518;
					switch(no518) {
					case 32:
						v518 = false;
						break;
					case 42:
						v518 = true;
						break;
					case 48:
						v518 = false;
						break;
					case 49:
						v518 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i519)));
					}
					switch(i519 - (l518 - 8)) {
					case 0:
						if(v518) {
							bs518 |= 128;
						} else {
							bs518 &= -129;
						}
						break;
					case 1:
						if(v518) {
							bs518 |= 64;
						} else {
							bs518 &= -65;
						}
						break;
					case 2:
						if(v518) {
							bs518 |= 32;
						} else {
							bs518 &= -33;
						}
						break;
					case 3:
						if(v518) {
							bs518 |= 16;
						} else {
							bs518 &= -17;
						}
						break;
					case 4:
						if(v518) {
							bs518 |= 8;
						} else {
							bs518 &= -9;
						}
						break;
					case 5:
						if(v518) {
							bs518 |= 4;
						} else {
							bs518 &= -5;
						}
						break;
					case 6:
						if(v518) {
							bs518 |= 2;
						} else {
							bs518 &= -3;
						}
						break;
					case 7:
						if(v518) {
							bs518 |= 1;
						} else {
							bs518 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs518;
				var this520 = 0;
				var bs519 = this520;
				var l519 = "     ".length;
				var _g1520 = 0;
				var _g620 = l519;
				while(_g1520 < _g620) {
					var i520 = _g1520++;
					var no519 = "     ".charCodeAt(i520);
					if(no519 == null) {
						break;
					}
					var v519;
					switch(no519) {
					case 32:
						v519 = false;
						break;
					case 42:
						v519 = true;
						break;
					case 48:
						v519 = false;
						break;
					case 49:
						v519 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i520)));
					}
					switch(i520 - (l519 - 8)) {
					case 0:
						if(v519) {
							bs519 |= 128;
						} else {
							bs519 &= -129;
						}
						break;
					case 1:
						if(v519) {
							bs519 |= 64;
						} else {
							bs519 &= -65;
						}
						break;
					case 2:
						if(v519) {
							bs519 |= 32;
						} else {
							bs519 &= -33;
						}
						break;
					case 3:
						if(v519) {
							bs519 |= 16;
						} else {
							bs519 &= -17;
						}
						break;
					case 4:
						if(v519) {
							bs519 |= 8;
						} else {
							bs519 &= -9;
						}
						break;
					case 5:
						if(v519) {
							bs519 |= 4;
						} else {
							bs519 &= -5;
						}
						break;
					case 6:
						if(v519) {
							bs519 |= 2;
						} else {
							bs519 &= -3;
						}
						break;
					case 7:
						if(v519) {
							bs519 |= 1;
						} else {
							bs519 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs519;
				var this521 = 0;
				var bs520 = this521;
				var l520 = "  ** ".length;
				var _g1521 = 0;
				var _g621 = l520;
				while(_g1521 < _g621) {
					var i521 = _g1521++;
					var no520 = "  ** ".charCodeAt(i521);
					if(no520 == null) {
						break;
					}
					var v520;
					switch(no520) {
					case 32:
						v520 = false;
						break;
					case 42:
						v520 = true;
						break;
					case 48:
						v520 = false;
						break;
					case 49:
						v520 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i521)));
					}
					switch(i521 - (l520 - 8)) {
					case 0:
						if(v520) {
							bs520 |= 128;
						} else {
							bs520 &= -129;
						}
						break;
					case 1:
						if(v520) {
							bs520 |= 64;
						} else {
							bs520 &= -65;
						}
						break;
					case 2:
						if(v520) {
							bs520 |= 32;
						} else {
							bs520 &= -33;
						}
						break;
					case 3:
						if(v520) {
							bs520 |= 16;
						} else {
							bs520 &= -17;
						}
						break;
					case 4:
						if(v520) {
							bs520 |= 8;
						} else {
							bs520 &= -9;
						}
						break;
					case 5:
						if(v520) {
							bs520 |= 4;
						} else {
							bs520 &= -5;
						}
						break;
					case 6:
						if(v520) {
							bs520 |= 2;
						} else {
							bs520 &= -3;
						}
						break;
					case 7:
						if(v520) {
							bs520 |= 1;
						} else {
							bs520 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs520;
				var this522 = 0;
				var bs521 = this522;
				var l521 = "   * ".length;
				var _g1522 = 0;
				var _g622 = l521;
				while(_g1522 < _g622) {
					var i522 = _g1522++;
					var no521 = "   * ".charCodeAt(i522);
					if(no521 == null) {
						break;
					}
					var v521;
					switch(no521) {
					case 32:
						v521 = false;
						break;
					case 42:
						v521 = true;
						break;
					case 48:
						v521 = false;
						break;
					case 49:
						v521 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i522)));
					}
					switch(i522 - (l521 - 8)) {
					case 0:
						if(v521) {
							bs521 |= 128;
						} else {
							bs521 &= -129;
						}
						break;
					case 1:
						if(v521) {
							bs521 |= 64;
						} else {
							bs521 &= -65;
						}
						break;
					case 2:
						if(v521) {
							bs521 |= 32;
						} else {
							bs521 &= -33;
						}
						break;
					case 3:
						if(v521) {
							bs521 |= 16;
						} else {
							bs521 &= -17;
						}
						break;
					case 4:
						if(v521) {
							bs521 |= 8;
						} else {
							bs521 &= -9;
						}
						break;
					case 5:
						if(v521) {
							bs521 |= 4;
						} else {
							bs521 &= -5;
						}
						break;
					case 6:
						if(v521) {
							bs521 |= 2;
						} else {
							bs521 &= -3;
						}
						break;
					case 7:
						if(v521) {
							bs521 |= 1;
						} else {
							bs521 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs521;
				var this523 = 0;
				var bs522 = this523;
				var l522 = "   * ".length;
				var _g1523 = 0;
				var _g623 = l522;
				while(_g1523 < _g623) {
					var i523 = _g1523++;
					var no522 = "   * ".charCodeAt(i523);
					if(no522 == null) {
						break;
					}
					var v522;
					switch(no522) {
					case 32:
						v522 = false;
						break;
					case 42:
						v522 = true;
						break;
					case 48:
						v522 = false;
						break;
					case 49:
						v522 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i523)));
					}
					switch(i523 - (l522 - 8)) {
					case 0:
						if(v522) {
							bs522 |= 128;
						} else {
							bs522 &= -129;
						}
						break;
					case 1:
						if(v522) {
							bs522 |= 64;
						} else {
							bs522 &= -65;
						}
						break;
					case 2:
						if(v522) {
							bs522 |= 32;
						} else {
							bs522 &= -33;
						}
						break;
					case 3:
						if(v522) {
							bs522 |= 16;
						} else {
							bs522 &= -17;
						}
						break;
					case 4:
						if(v522) {
							bs522 |= 8;
						} else {
							bs522 &= -9;
						}
						break;
					case 5:
						if(v522) {
							bs522 |= 4;
						} else {
							bs522 &= -5;
						}
						break;
					case 6:
						if(v522) {
							bs522 |= 2;
						} else {
							bs522 &= -3;
						}
						break;
					case 7:
						if(v522) {
							bs522 |= 1;
						} else {
							bs522 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs522;
				var this524 = 0;
				var bs523 = this524;
				var l523 = "*  * ".length;
				var _g1524 = 0;
				var _g624 = l523;
				while(_g1524 < _g624) {
					var i524 = _g1524++;
					var no523 = "*  * ".charCodeAt(i524);
					if(no523 == null) {
						break;
					}
					var v523;
					switch(no523) {
					case 32:
						v523 = false;
						break;
					case 42:
						v523 = true;
						break;
					case 48:
						v523 = false;
						break;
					case 49:
						v523 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i524)));
					}
					switch(i524 - (l523 - 8)) {
					case 0:
						if(v523) {
							bs523 |= 128;
						} else {
							bs523 &= -129;
						}
						break;
					case 1:
						if(v523) {
							bs523 |= 64;
						} else {
							bs523 &= -65;
						}
						break;
					case 2:
						if(v523) {
							bs523 |= 32;
						} else {
							bs523 &= -33;
						}
						break;
					case 3:
						if(v523) {
							bs523 |= 16;
						} else {
							bs523 &= -17;
						}
						break;
					case 4:
						if(v523) {
							bs523 |= 8;
						} else {
							bs523 &= -9;
						}
						break;
					case 5:
						if(v523) {
							bs523 |= 4;
						} else {
							bs523 &= -5;
						}
						break;
					case 6:
						if(v523) {
							bs523 |= 2;
						} else {
							bs523 &= -3;
						}
						break;
					case 7:
						if(v523) {
							bs523 |= 1;
						} else {
							bs523 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs523;
				var this525 = 0;
				var bs524 = this525;
				var l524 = " **  ".length;
				var _g1525 = 0;
				var _g625 = l524;
				while(_g1525 < _g625) {
					var i525 = _g1525++;
					var no524 = " **  ".charCodeAt(i525);
					if(no524 == null) {
						break;
					}
					var v524;
					switch(no524) {
					case 32:
						v524 = false;
						break;
					case 42:
						v524 = true;
						break;
					case 48:
						v524 = false;
						break;
					case 49:
						v524 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i525)));
					}
					switch(i525 - (l524 - 8)) {
					case 0:
						if(v524) {
							bs524 |= 128;
						} else {
							bs524 &= -129;
						}
						break;
					case 1:
						if(v524) {
							bs524 |= 64;
						} else {
							bs524 &= -65;
						}
						break;
					case 2:
						if(v524) {
							bs524 |= 32;
						} else {
							bs524 &= -33;
						}
						break;
					case 3:
						if(v524) {
							bs524 |= 16;
						} else {
							bs524 &= -17;
						}
						break;
					case 4:
						if(v524) {
							bs524 |= 8;
						} else {
							bs524 &= -9;
						}
						break;
					case 5:
						if(v524) {
							bs524 |= 4;
						} else {
							bs524 &= -5;
						}
						break;
					case 6:
						if(v524) {
							bs524 |= 2;
						} else {
							bs524 &= -3;
						}
						break;
					case 7:
						if(v524) {
							bs524 |= 1;
						} else {
							bs524 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs524;
				break;
			case 107:
				var this526 = 0;
				var bs525 = this526;
				var l525 = "*    ".length;
				var _g1526 = 0;
				var _g626 = l525;
				while(_g1526 < _g626) {
					var i526 = _g1526++;
					var no525 = "*    ".charCodeAt(i526);
					if(no525 == null) {
						break;
					}
					var v525;
					switch(no525) {
					case 32:
						v525 = false;
						break;
					case 42:
						v525 = true;
						break;
					case 48:
						v525 = false;
						break;
					case 49:
						v525 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i526)));
					}
					switch(i526 - (l525 - 8)) {
					case 0:
						if(v525) {
							bs525 |= 128;
						} else {
							bs525 &= -129;
						}
						break;
					case 1:
						if(v525) {
							bs525 |= 64;
						} else {
							bs525 &= -65;
						}
						break;
					case 2:
						if(v525) {
							bs525 |= 32;
						} else {
							bs525 &= -33;
						}
						break;
					case 3:
						if(v525) {
							bs525 |= 16;
						} else {
							bs525 &= -17;
						}
						break;
					case 4:
						if(v525) {
							bs525 |= 8;
						} else {
							bs525 &= -9;
						}
						break;
					case 5:
						if(v525) {
							bs525 |= 4;
						} else {
							bs525 &= -5;
						}
						break;
					case 6:
						if(v525) {
							bs525 |= 2;
						} else {
							bs525 &= -3;
						}
						break;
					case 7:
						if(v525) {
							bs525 |= 1;
						} else {
							bs525 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs525;
				var this527 = 0;
				var bs526 = this527;
				var l526 = "*    ".length;
				var _g1527 = 0;
				var _g627 = l526;
				while(_g1527 < _g627) {
					var i527 = _g1527++;
					var no526 = "*    ".charCodeAt(i527);
					if(no526 == null) {
						break;
					}
					var v526;
					switch(no526) {
					case 32:
						v526 = false;
						break;
					case 42:
						v526 = true;
						break;
					case 48:
						v526 = false;
						break;
					case 49:
						v526 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i527)));
					}
					switch(i527 - (l526 - 8)) {
					case 0:
						if(v526) {
							bs526 |= 128;
						} else {
							bs526 &= -129;
						}
						break;
					case 1:
						if(v526) {
							bs526 |= 64;
						} else {
							bs526 &= -65;
						}
						break;
					case 2:
						if(v526) {
							bs526 |= 32;
						} else {
							bs526 &= -33;
						}
						break;
					case 3:
						if(v526) {
							bs526 |= 16;
						} else {
							bs526 &= -17;
						}
						break;
					case 4:
						if(v526) {
							bs526 |= 8;
						} else {
							bs526 &= -9;
						}
						break;
					case 5:
						if(v526) {
							bs526 |= 4;
						} else {
							bs526 &= -5;
						}
						break;
					case 6:
						if(v526) {
							bs526 |= 2;
						} else {
							bs526 &= -3;
						}
						break;
					case 7:
						if(v526) {
							bs526 |= 1;
						} else {
							bs526 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs526;
				var this528 = 0;
				var bs527 = this528;
				var l527 = "*  * ".length;
				var _g1528 = 0;
				var _g628 = l527;
				while(_g1528 < _g628) {
					var i528 = _g1528++;
					var no527 = "*  * ".charCodeAt(i528);
					if(no527 == null) {
						break;
					}
					var v527;
					switch(no527) {
					case 32:
						v527 = false;
						break;
					case 42:
						v527 = true;
						break;
					case 48:
						v527 = false;
						break;
					case 49:
						v527 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i528)));
					}
					switch(i528 - (l527 - 8)) {
					case 0:
						if(v527) {
							bs527 |= 128;
						} else {
							bs527 &= -129;
						}
						break;
					case 1:
						if(v527) {
							bs527 |= 64;
						} else {
							bs527 &= -65;
						}
						break;
					case 2:
						if(v527) {
							bs527 |= 32;
						} else {
							bs527 &= -33;
						}
						break;
					case 3:
						if(v527) {
							bs527 |= 16;
						} else {
							bs527 &= -17;
						}
						break;
					case 4:
						if(v527) {
							bs527 |= 8;
						} else {
							bs527 &= -9;
						}
						break;
					case 5:
						if(v527) {
							bs527 |= 4;
						} else {
							bs527 &= -5;
						}
						break;
					case 6:
						if(v527) {
							bs527 |= 2;
						} else {
							bs527 &= -3;
						}
						break;
					case 7:
						if(v527) {
							bs527 |= 1;
						} else {
							bs527 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs527;
				var this529 = 0;
				var bs528 = this529;
				var l528 = "* *  ".length;
				var _g1529 = 0;
				var _g629 = l528;
				while(_g1529 < _g629) {
					var i529 = _g1529++;
					var no528 = "* *  ".charCodeAt(i529);
					if(no528 == null) {
						break;
					}
					var v528;
					switch(no528) {
					case 32:
						v528 = false;
						break;
					case 42:
						v528 = true;
						break;
					case 48:
						v528 = false;
						break;
					case 49:
						v528 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i529)));
					}
					switch(i529 - (l528 - 8)) {
					case 0:
						if(v528) {
							bs528 |= 128;
						} else {
							bs528 &= -129;
						}
						break;
					case 1:
						if(v528) {
							bs528 |= 64;
						} else {
							bs528 &= -65;
						}
						break;
					case 2:
						if(v528) {
							bs528 |= 32;
						} else {
							bs528 &= -33;
						}
						break;
					case 3:
						if(v528) {
							bs528 |= 16;
						} else {
							bs528 &= -17;
						}
						break;
					case 4:
						if(v528) {
							bs528 |= 8;
						} else {
							bs528 &= -9;
						}
						break;
					case 5:
						if(v528) {
							bs528 |= 4;
						} else {
							bs528 &= -5;
						}
						break;
					case 6:
						if(v528) {
							bs528 |= 2;
						} else {
							bs528 &= -3;
						}
						break;
					case 7:
						if(v528) {
							bs528 |= 1;
						} else {
							bs528 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs528;
				var this530 = 0;
				var bs529 = this530;
				var l529 = "**   ".length;
				var _g1530 = 0;
				var _g630 = l529;
				while(_g1530 < _g630) {
					var i530 = _g1530++;
					var no529 = "**   ".charCodeAt(i530);
					if(no529 == null) {
						break;
					}
					var v529;
					switch(no529) {
					case 32:
						v529 = false;
						break;
					case 42:
						v529 = true;
						break;
					case 48:
						v529 = false;
						break;
					case 49:
						v529 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**   ".charCodeAt(i530)));
					}
					switch(i530 - (l529 - 8)) {
					case 0:
						if(v529) {
							bs529 |= 128;
						} else {
							bs529 &= -129;
						}
						break;
					case 1:
						if(v529) {
							bs529 |= 64;
						} else {
							bs529 &= -65;
						}
						break;
					case 2:
						if(v529) {
							bs529 |= 32;
						} else {
							bs529 &= -33;
						}
						break;
					case 3:
						if(v529) {
							bs529 |= 16;
						} else {
							bs529 &= -17;
						}
						break;
					case 4:
						if(v529) {
							bs529 |= 8;
						} else {
							bs529 &= -9;
						}
						break;
					case 5:
						if(v529) {
							bs529 |= 4;
						} else {
							bs529 &= -5;
						}
						break;
					case 6:
						if(v529) {
							bs529 |= 2;
						} else {
							bs529 &= -3;
						}
						break;
					case 7:
						if(v529) {
							bs529 |= 1;
						} else {
							bs529 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs529;
				var this531 = 0;
				var bs530 = this531;
				var l530 = "* *  ".length;
				var _g1531 = 0;
				var _g631 = l530;
				while(_g1531 < _g631) {
					var i531 = _g1531++;
					var no530 = "* *  ".charCodeAt(i531);
					if(no530 == null) {
						break;
					}
					var v530;
					switch(no530) {
					case 32:
						v530 = false;
						break;
					case 42:
						v530 = true;
						break;
					case 48:
						v530 = false;
						break;
					case 49:
						v530 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i531)));
					}
					switch(i531 - (l530 - 8)) {
					case 0:
						if(v530) {
							bs530 |= 128;
						} else {
							bs530 &= -129;
						}
						break;
					case 1:
						if(v530) {
							bs530 |= 64;
						} else {
							bs530 &= -65;
						}
						break;
					case 2:
						if(v530) {
							bs530 |= 32;
						} else {
							bs530 &= -33;
						}
						break;
					case 3:
						if(v530) {
							bs530 |= 16;
						} else {
							bs530 &= -17;
						}
						break;
					case 4:
						if(v530) {
							bs530 |= 8;
						} else {
							bs530 &= -9;
						}
						break;
					case 5:
						if(v530) {
							bs530 |= 4;
						} else {
							bs530 &= -5;
						}
						break;
					case 6:
						if(v530) {
							bs530 |= 2;
						} else {
							bs530 &= -3;
						}
						break;
					case 7:
						if(v530) {
							bs530 |= 1;
						} else {
							bs530 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs530;
				var this532 = 0;
				var bs531 = this532;
				var l531 = "*   *".length;
				var _g1532 = 0;
				var _g632 = l531;
				while(_g1532 < _g632) {
					var i532 = _g1532++;
					var no531 = "*   *".charCodeAt(i532);
					if(no531 == null) {
						break;
					}
					var v531;
					switch(no531) {
					case 32:
						v531 = false;
						break;
					case 42:
						v531 = true;
						break;
					case 48:
						v531 = false;
						break;
					case 49:
						v531 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i532)));
					}
					switch(i532 - (l531 - 8)) {
					case 0:
						if(v531) {
							bs531 |= 128;
						} else {
							bs531 &= -129;
						}
						break;
					case 1:
						if(v531) {
							bs531 |= 64;
						} else {
							bs531 &= -65;
						}
						break;
					case 2:
						if(v531) {
							bs531 |= 32;
						} else {
							bs531 &= -33;
						}
						break;
					case 3:
						if(v531) {
							bs531 |= 16;
						} else {
							bs531 &= -17;
						}
						break;
					case 4:
						if(v531) {
							bs531 |= 8;
						} else {
							bs531 &= -9;
						}
						break;
					case 5:
						if(v531) {
							bs531 |= 4;
						} else {
							bs531 &= -5;
						}
						break;
					case 6:
						if(v531) {
							bs531 |= 2;
						} else {
							bs531 &= -3;
						}
						break;
					case 7:
						if(v531) {
							bs531 |= 1;
						} else {
							bs531 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs531;
				break;
			case 108:
				var this533 = 0;
				var bs532 = this533;
				var l532 = " **  ".length;
				var _g1533 = 0;
				var _g633 = l532;
				while(_g1533 < _g633) {
					var i533 = _g1533++;
					var no532 = " **  ".charCodeAt(i533);
					if(no532 == null) {
						break;
					}
					var v532;
					switch(no532) {
					case 32:
						v532 = false;
						break;
					case 42:
						v532 = true;
						break;
					case 48:
						v532 = false;
						break;
					case 49:
						v532 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i533)));
					}
					switch(i533 - (l532 - 8)) {
					case 0:
						if(v532) {
							bs532 |= 128;
						} else {
							bs532 &= -129;
						}
						break;
					case 1:
						if(v532) {
							bs532 |= 64;
						} else {
							bs532 &= -65;
						}
						break;
					case 2:
						if(v532) {
							bs532 |= 32;
						} else {
							bs532 &= -33;
						}
						break;
					case 3:
						if(v532) {
							bs532 |= 16;
						} else {
							bs532 &= -17;
						}
						break;
					case 4:
						if(v532) {
							bs532 |= 8;
						} else {
							bs532 &= -9;
						}
						break;
					case 5:
						if(v532) {
							bs532 |= 4;
						} else {
							bs532 &= -5;
						}
						break;
					case 6:
						if(v532) {
							bs532 |= 2;
						} else {
							bs532 &= -3;
						}
						break;
					case 7:
						if(v532) {
							bs532 |= 1;
						} else {
							bs532 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs532;
				var this534 = 0;
				var bs533 = this534;
				var l533 = "  *  ".length;
				var _g1534 = 0;
				var _g634 = l533;
				while(_g1534 < _g634) {
					var i534 = _g1534++;
					var no533 = "  *  ".charCodeAt(i534);
					if(no533 == null) {
						break;
					}
					var v533;
					switch(no533) {
					case 32:
						v533 = false;
						break;
					case 42:
						v533 = true;
						break;
					case 48:
						v533 = false;
						break;
					case 49:
						v533 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i534)));
					}
					switch(i534 - (l533 - 8)) {
					case 0:
						if(v533) {
							bs533 |= 128;
						} else {
							bs533 &= -129;
						}
						break;
					case 1:
						if(v533) {
							bs533 |= 64;
						} else {
							bs533 &= -65;
						}
						break;
					case 2:
						if(v533) {
							bs533 |= 32;
						} else {
							bs533 &= -33;
						}
						break;
					case 3:
						if(v533) {
							bs533 |= 16;
						} else {
							bs533 &= -17;
						}
						break;
					case 4:
						if(v533) {
							bs533 |= 8;
						} else {
							bs533 &= -9;
						}
						break;
					case 5:
						if(v533) {
							bs533 |= 4;
						} else {
							bs533 &= -5;
						}
						break;
					case 6:
						if(v533) {
							bs533 |= 2;
						} else {
							bs533 &= -3;
						}
						break;
					case 7:
						if(v533) {
							bs533 |= 1;
						} else {
							bs533 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs533;
				var this535 = 0;
				var bs534 = this535;
				var l534 = "  *  ".length;
				var _g1535 = 0;
				var _g635 = l534;
				while(_g1535 < _g635) {
					var i535 = _g1535++;
					var no534 = "  *  ".charCodeAt(i535);
					if(no534 == null) {
						break;
					}
					var v534;
					switch(no534) {
					case 32:
						v534 = false;
						break;
					case 42:
						v534 = true;
						break;
					case 48:
						v534 = false;
						break;
					case 49:
						v534 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i535)));
					}
					switch(i535 - (l534 - 8)) {
					case 0:
						if(v534) {
							bs534 |= 128;
						} else {
							bs534 &= -129;
						}
						break;
					case 1:
						if(v534) {
							bs534 |= 64;
						} else {
							bs534 &= -65;
						}
						break;
					case 2:
						if(v534) {
							bs534 |= 32;
						} else {
							bs534 &= -33;
						}
						break;
					case 3:
						if(v534) {
							bs534 |= 16;
						} else {
							bs534 &= -17;
						}
						break;
					case 4:
						if(v534) {
							bs534 |= 8;
						} else {
							bs534 &= -9;
						}
						break;
					case 5:
						if(v534) {
							bs534 |= 4;
						} else {
							bs534 &= -5;
						}
						break;
					case 6:
						if(v534) {
							bs534 |= 2;
						} else {
							bs534 &= -3;
						}
						break;
					case 7:
						if(v534) {
							bs534 |= 1;
						} else {
							bs534 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs534;
				var this536 = 0;
				var bs535 = this536;
				var l535 = "  *  ".length;
				var _g1536 = 0;
				var _g636 = l535;
				while(_g1536 < _g636) {
					var i536 = _g1536++;
					var no535 = "  *  ".charCodeAt(i536);
					if(no535 == null) {
						break;
					}
					var v535;
					switch(no535) {
					case 32:
						v535 = false;
						break;
					case 42:
						v535 = true;
						break;
					case 48:
						v535 = false;
						break;
					case 49:
						v535 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i536)));
					}
					switch(i536 - (l535 - 8)) {
					case 0:
						if(v535) {
							bs535 |= 128;
						} else {
							bs535 &= -129;
						}
						break;
					case 1:
						if(v535) {
							bs535 |= 64;
						} else {
							bs535 &= -65;
						}
						break;
					case 2:
						if(v535) {
							bs535 |= 32;
						} else {
							bs535 &= -33;
						}
						break;
					case 3:
						if(v535) {
							bs535 |= 16;
						} else {
							bs535 &= -17;
						}
						break;
					case 4:
						if(v535) {
							bs535 |= 8;
						} else {
							bs535 &= -9;
						}
						break;
					case 5:
						if(v535) {
							bs535 |= 4;
						} else {
							bs535 &= -5;
						}
						break;
					case 6:
						if(v535) {
							bs535 |= 2;
						} else {
							bs535 &= -3;
						}
						break;
					case 7:
						if(v535) {
							bs535 |= 1;
						} else {
							bs535 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs535;
				var this537 = 0;
				var bs536 = this537;
				var l536 = "  *  ".length;
				var _g1537 = 0;
				var _g637 = l536;
				while(_g1537 < _g637) {
					var i537 = _g1537++;
					var no536 = "  *  ".charCodeAt(i537);
					if(no536 == null) {
						break;
					}
					var v536;
					switch(no536) {
					case 32:
						v536 = false;
						break;
					case 42:
						v536 = true;
						break;
					case 48:
						v536 = false;
						break;
					case 49:
						v536 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i537)));
					}
					switch(i537 - (l536 - 8)) {
					case 0:
						if(v536) {
							bs536 |= 128;
						} else {
							bs536 &= -129;
						}
						break;
					case 1:
						if(v536) {
							bs536 |= 64;
						} else {
							bs536 &= -65;
						}
						break;
					case 2:
						if(v536) {
							bs536 |= 32;
						} else {
							bs536 &= -33;
						}
						break;
					case 3:
						if(v536) {
							bs536 |= 16;
						} else {
							bs536 &= -17;
						}
						break;
					case 4:
						if(v536) {
							bs536 |= 8;
						} else {
							bs536 &= -9;
						}
						break;
					case 5:
						if(v536) {
							bs536 |= 4;
						} else {
							bs536 &= -5;
						}
						break;
					case 6:
						if(v536) {
							bs536 |= 2;
						} else {
							bs536 &= -3;
						}
						break;
					case 7:
						if(v536) {
							bs536 |= 1;
						} else {
							bs536 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs536;
				var this538 = 0;
				var bs537 = this538;
				var l537 = "  *  ".length;
				var _g1538 = 0;
				var _g638 = l537;
				while(_g1538 < _g638) {
					var i538 = _g1538++;
					var no537 = "  *  ".charCodeAt(i538);
					if(no537 == null) {
						break;
					}
					var v537;
					switch(no537) {
					case 32:
						v537 = false;
						break;
					case 42:
						v537 = true;
						break;
					case 48:
						v537 = false;
						break;
					case 49:
						v537 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i538)));
					}
					switch(i538 - (l537 - 8)) {
					case 0:
						if(v537) {
							bs537 |= 128;
						} else {
							bs537 &= -129;
						}
						break;
					case 1:
						if(v537) {
							bs537 |= 64;
						} else {
							bs537 &= -65;
						}
						break;
					case 2:
						if(v537) {
							bs537 |= 32;
						} else {
							bs537 &= -33;
						}
						break;
					case 3:
						if(v537) {
							bs537 |= 16;
						} else {
							bs537 &= -17;
						}
						break;
					case 4:
						if(v537) {
							bs537 |= 8;
						} else {
							bs537 &= -9;
						}
						break;
					case 5:
						if(v537) {
							bs537 |= 4;
						} else {
							bs537 &= -5;
						}
						break;
					case 6:
						if(v537) {
							bs537 |= 2;
						} else {
							bs537 &= -3;
						}
						break;
					case 7:
						if(v537) {
							bs537 |= 1;
						} else {
							bs537 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs537;
				var this539 = 0;
				var bs538 = this539;
				var l538 = " ***".length;
				var _g1539 = 0;
				var _g639 = l538;
				while(_g1539 < _g639) {
					var i539 = _g1539++;
					var no538 = " ***".charCodeAt(i539);
					if(no538 == null) {
						break;
					}
					var v538;
					switch(no538) {
					case 32:
						v538 = false;
						break;
					case 42:
						v538 = true;
						break;
					case 48:
						v538 = false;
						break;
					case 49:
						v538 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ***".charCodeAt(i539)));
					}
					switch(i539 - (l538 - 8)) {
					case 0:
						if(v538) {
							bs538 |= 128;
						} else {
							bs538 &= -129;
						}
						break;
					case 1:
						if(v538) {
							bs538 |= 64;
						} else {
							bs538 &= -65;
						}
						break;
					case 2:
						if(v538) {
							bs538 |= 32;
						} else {
							bs538 &= -33;
						}
						break;
					case 3:
						if(v538) {
							bs538 |= 16;
						} else {
							bs538 &= -17;
						}
						break;
					case 4:
						if(v538) {
							bs538 |= 8;
						} else {
							bs538 &= -9;
						}
						break;
					case 5:
						if(v538) {
							bs538 |= 4;
						} else {
							bs538 &= -5;
						}
						break;
					case 6:
						if(v538) {
							bs538 |= 2;
						} else {
							bs538 &= -3;
						}
						break;
					case 7:
						if(v538) {
							bs538 |= 1;
						} else {
							bs538 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs538;
				break;
			case 109:
				var this540 = 0;
				var bs539 = this540;
				var l539 = "     ".length;
				var _g1540 = 0;
				var _g640 = l539;
				while(_g1540 < _g640) {
					var i540 = _g1540++;
					var no539 = "     ".charCodeAt(i540);
					if(no539 == null) {
						break;
					}
					var v539;
					switch(no539) {
					case 32:
						v539 = false;
						break;
					case 42:
						v539 = true;
						break;
					case 48:
						v539 = false;
						break;
					case 49:
						v539 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i540)));
					}
					switch(i540 - (l539 - 8)) {
					case 0:
						if(v539) {
							bs539 |= 128;
						} else {
							bs539 &= -129;
						}
						break;
					case 1:
						if(v539) {
							bs539 |= 64;
						} else {
							bs539 &= -65;
						}
						break;
					case 2:
						if(v539) {
							bs539 |= 32;
						} else {
							bs539 &= -33;
						}
						break;
					case 3:
						if(v539) {
							bs539 |= 16;
						} else {
							bs539 &= -17;
						}
						break;
					case 4:
						if(v539) {
							bs539 |= 8;
						} else {
							bs539 &= -9;
						}
						break;
					case 5:
						if(v539) {
							bs539 |= 4;
						} else {
							bs539 &= -5;
						}
						break;
					case 6:
						if(v539) {
							bs539 |= 2;
						} else {
							bs539 &= -3;
						}
						break;
					case 7:
						if(v539) {
							bs539 |= 1;
						} else {
							bs539 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs539;
				var this541 = 0;
				var bs540 = this541;
				var l540 = "     ".length;
				var _g1541 = 0;
				var _g641 = l540;
				while(_g1541 < _g641) {
					var i541 = _g1541++;
					var no540 = "     ".charCodeAt(i541);
					if(no540 == null) {
						break;
					}
					var v540;
					switch(no540) {
					case 32:
						v540 = false;
						break;
					case 42:
						v540 = true;
						break;
					case 48:
						v540 = false;
						break;
					case 49:
						v540 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i541)));
					}
					switch(i541 - (l540 - 8)) {
					case 0:
						if(v540) {
							bs540 |= 128;
						} else {
							bs540 &= -129;
						}
						break;
					case 1:
						if(v540) {
							bs540 |= 64;
						} else {
							bs540 &= -65;
						}
						break;
					case 2:
						if(v540) {
							bs540 |= 32;
						} else {
							bs540 &= -33;
						}
						break;
					case 3:
						if(v540) {
							bs540 |= 16;
						} else {
							bs540 &= -17;
						}
						break;
					case 4:
						if(v540) {
							bs540 |= 8;
						} else {
							bs540 &= -9;
						}
						break;
					case 5:
						if(v540) {
							bs540 |= 4;
						} else {
							bs540 &= -5;
						}
						break;
					case 6:
						if(v540) {
							bs540 |= 2;
						} else {
							bs540 &= -3;
						}
						break;
					case 7:
						if(v540) {
							bs540 |= 1;
						} else {
							bs540 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs540;
				var this542 = 0;
				var bs541 = this542;
				var l541 = "** * ".length;
				var _g1542 = 0;
				var _g642 = l541;
				while(_g1542 < _g642) {
					var i542 = _g1542++;
					var no541 = "** * ".charCodeAt(i542);
					if(no541 == null) {
						break;
					}
					var v541;
					switch(no541) {
					case 32:
						v541 = false;
						break;
					case 42:
						v541 = true;
						break;
					case 48:
						v541 = false;
						break;
					case 49:
						v541 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("** * ".charCodeAt(i542)));
					}
					switch(i542 - (l541 - 8)) {
					case 0:
						if(v541) {
							bs541 |= 128;
						} else {
							bs541 &= -129;
						}
						break;
					case 1:
						if(v541) {
							bs541 |= 64;
						} else {
							bs541 &= -65;
						}
						break;
					case 2:
						if(v541) {
							bs541 |= 32;
						} else {
							bs541 &= -33;
						}
						break;
					case 3:
						if(v541) {
							bs541 |= 16;
						} else {
							bs541 &= -17;
						}
						break;
					case 4:
						if(v541) {
							bs541 |= 8;
						} else {
							bs541 &= -9;
						}
						break;
					case 5:
						if(v541) {
							bs541 |= 4;
						} else {
							bs541 &= -5;
						}
						break;
					case 6:
						if(v541) {
							bs541 |= 2;
						} else {
							bs541 &= -3;
						}
						break;
					case 7:
						if(v541) {
							bs541 |= 1;
						} else {
							bs541 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs541;
				var this543 = 0;
				var bs542 = this543;
				var l542 = "* * *".length;
				var _g1543 = 0;
				var _g643 = l542;
				while(_g1543 < _g643) {
					var i543 = _g1543++;
					var no542 = "* * *".charCodeAt(i543);
					if(no542 == null) {
						break;
					}
					var v542;
					switch(no542) {
					case 32:
						v542 = false;
						break;
					case 42:
						v542 = true;
						break;
					case 48:
						v542 = false;
						break;
					case 49:
						v542 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i543)));
					}
					switch(i543 - (l542 - 8)) {
					case 0:
						if(v542) {
							bs542 |= 128;
						} else {
							bs542 &= -129;
						}
						break;
					case 1:
						if(v542) {
							bs542 |= 64;
						} else {
							bs542 &= -65;
						}
						break;
					case 2:
						if(v542) {
							bs542 |= 32;
						} else {
							bs542 &= -33;
						}
						break;
					case 3:
						if(v542) {
							bs542 |= 16;
						} else {
							bs542 &= -17;
						}
						break;
					case 4:
						if(v542) {
							bs542 |= 8;
						} else {
							bs542 &= -9;
						}
						break;
					case 5:
						if(v542) {
							bs542 |= 4;
						} else {
							bs542 &= -5;
						}
						break;
					case 6:
						if(v542) {
							bs542 |= 2;
						} else {
							bs542 &= -3;
						}
						break;
					case 7:
						if(v542) {
							bs542 |= 1;
						} else {
							bs542 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs542;
				var this544 = 0;
				var bs543 = this544;
				var l543 = "* * *".length;
				var _g1544 = 0;
				var _g644 = l543;
				while(_g1544 < _g644) {
					var i544 = _g1544++;
					var no543 = "* * *".charCodeAt(i544);
					if(no543 == null) {
						break;
					}
					var v543;
					switch(no543) {
					case 32:
						v543 = false;
						break;
					case 42:
						v543 = true;
						break;
					case 48:
						v543 = false;
						break;
					case 49:
						v543 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i544)));
					}
					switch(i544 - (l543 - 8)) {
					case 0:
						if(v543) {
							bs543 |= 128;
						} else {
							bs543 &= -129;
						}
						break;
					case 1:
						if(v543) {
							bs543 |= 64;
						} else {
							bs543 &= -65;
						}
						break;
					case 2:
						if(v543) {
							bs543 |= 32;
						} else {
							bs543 &= -33;
						}
						break;
					case 3:
						if(v543) {
							bs543 |= 16;
						} else {
							bs543 &= -17;
						}
						break;
					case 4:
						if(v543) {
							bs543 |= 8;
						} else {
							bs543 &= -9;
						}
						break;
					case 5:
						if(v543) {
							bs543 |= 4;
						} else {
							bs543 &= -5;
						}
						break;
					case 6:
						if(v543) {
							bs543 |= 2;
						} else {
							bs543 &= -3;
						}
						break;
					case 7:
						if(v543) {
							bs543 |= 1;
						} else {
							bs543 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs543;
				var this545 = 0;
				var bs544 = this545;
				var l544 = "*   *".length;
				var _g1545 = 0;
				var _g645 = l544;
				while(_g1545 < _g645) {
					var i545 = _g1545++;
					var no544 = "*   *".charCodeAt(i545);
					if(no544 == null) {
						break;
					}
					var v544;
					switch(no544) {
					case 32:
						v544 = false;
						break;
					case 42:
						v544 = true;
						break;
					case 48:
						v544 = false;
						break;
					case 49:
						v544 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i545)));
					}
					switch(i545 - (l544 - 8)) {
					case 0:
						if(v544) {
							bs544 |= 128;
						} else {
							bs544 &= -129;
						}
						break;
					case 1:
						if(v544) {
							bs544 |= 64;
						} else {
							bs544 &= -65;
						}
						break;
					case 2:
						if(v544) {
							bs544 |= 32;
						} else {
							bs544 &= -33;
						}
						break;
					case 3:
						if(v544) {
							bs544 |= 16;
						} else {
							bs544 &= -17;
						}
						break;
					case 4:
						if(v544) {
							bs544 |= 8;
						} else {
							bs544 &= -9;
						}
						break;
					case 5:
						if(v544) {
							bs544 |= 4;
						} else {
							bs544 &= -5;
						}
						break;
					case 6:
						if(v544) {
							bs544 |= 2;
						} else {
							bs544 &= -3;
						}
						break;
					case 7:
						if(v544) {
							bs544 |= 1;
						} else {
							bs544 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs544;
				var this546 = 0;
				var bs545 = this546;
				var l545 = "*   *".length;
				var _g1546 = 0;
				var _g646 = l545;
				while(_g1546 < _g646) {
					var i546 = _g1546++;
					var no545 = "*   *".charCodeAt(i546);
					if(no545 == null) {
						break;
					}
					var v545;
					switch(no545) {
					case 32:
						v545 = false;
						break;
					case 42:
						v545 = true;
						break;
					case 48:
						v545 = false;
						break;
					case 49:
						v545 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i546)));
					}
					switch(i546 - (l545 - 8)) {
					case 0:
						if(v545) {
							bs545 |= 128;
						} else {
							bs545 &= -129;
						}
						break;
					case 1:
						if(v545) {
							bs545 |= 64;
						} else {
							bs545 &= -65;
						}
						break;
					case 2:
						if(v545) {
							bs545 |= 32;
						} else {
							bs545 &= -33;
						}
						break;
					case 3:
						if(v545) {
							bs545 |= 16;
						} else {
							bs545 &= -17;
						}
						break;
					case 4:
						if(v545) {
							bs545 |= 8;
						} else {
							bs545 &= -9;
						}
						break;
					case 5:
						if(v545) {
							bs545 |= 4;
						} else {
							bs545 &= -5;
						}
						break;
					case 6:
						if(v545) {
							bs545 |= 2;
						} else {
							bs545 &= -3;
						}
						break;
					case 7:
						if(v545) {
							bs545 |= 1;
						} else {
							bs545 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs545;
				break;
			case 110:
				var this547 = 0;
				var bs546 = this547;
				var l546 = "     ".length;
				var _g1547 = 0;
				var _g647 = l546;
				while(_g1547 < _g647) {
					var i547 = _g1547++;
					var no546 = "     ".charCodeAt(i547);
					if(no546 == null) {
						break;
					}
					var v546;
					switch(no546) {
					case 32:
						v546 = false;
						break;
					case 42:
						v546 = true;
						break;
					case 48:
						v546 = false;
						break;
					case 49:
						v546 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i547)));
					}
					switch(i547 - (l546 - 8)) {
					case 0:
						if(v546) {
							bs546 |= 128;
						} else {
							bs546 &= -129;
						}
						break;
					case 1:
						if(v546) {
							bs546 |= 64;
						} else {
							bs546 &= -65;
						}
						break;
					case 2:
						if(v546) {
							bs546 |= 32;
						} else {
							bs546 &= -33;
						}
						break;
					case 3:
						if(v546) {
							bs546 |= 16;
						} else {
							bs546 &= -17;
						}
						break;
					case 4:
						if(v546) {
							bs546 |= 8;
						} else {
							bs546 &= -9;
						}
						break;
					case 5:
						if(v546) {
							bs546 |= 4;
						} else {
							bs546 &= -5;
						}
						break;
					case 6:
						if(v546) {
							bs546 |= 2;
						} else {
							bs546 &= -3;
						}
						break;
					case 7:
						if(v546) {
							bs546 |= 1;
						} else {
							bs546 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs546;
				var this548 = 0;
				var bs547 = this548;
				var l547 = "     ".length;
				var _g1548 = 0;
				var _g648 = l547;
				while(_g1548 < _g648) {
					var i548 = _g1548++;
					var no547 = "     ".charCodeAt(i548);
					if(no547 == null) {
						break;
					}
					var v547;
					switch(no547) {
					case 32:
						v547 = false;
						break;
					case 42:
						v547 = true;
						break;
					case 48:
						v547 = false;
						break;
					case 49:
						v547 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i548)));
					}
					switch(i548 - (l547 - 8)) {
					case 0:
						if(v547) {
							bs547 |= 128;
						} else {
							bs547 &= -129;
						}
						break;
					case 1:
						if(v547) {
							bs547 |= 64;
						} else {
							bs547 &= -65;
						}
						break;
					case 2:
						if(v547) {
							bs547 |= 32;
						} else {
							bs547 &= -33;
						}
						break;
					case 3:
						if(v547) {
							bs547 |= 16;
						} else {
							bs547 &= -17;
						}
						break;
					case 4:
						if(v547) {
							bs547 |= 8;
						} else {
							bs547 &= -9;
						}
						break;
					case 5:
						if(v547) {
							bs547 |= 4;
						} else {
							bs547 &= -5;
						}
						break;
					case 6:
						if(v547) {
							bs547 |= 2;
						} else {
							bs547 &= -3;
						}
						break;
					case 7:
						if(v547) {
							bs547 |= 1;
						} else {
							bs547 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs547;
				var this549 = 0;
				var bs548 = this549;
				var l548 = "* ** ".length;
				var _g1549 = 0;
				var _g649 = l548;
				while(_g1549 < _g649) {
					var i549 = _g1549++;
					var no548 = "* ** ".charCodeAt(i549);
					if(no548 == null) {
						break;
					}
					var v548;
					switch(no548) {
					case 32:
						v548 = false;
						break;
					case 42:
						v548 = true;
						break;
					case 48:
						v548 = false;
						break;
					case 49:
						v548 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* ** ".charCodeAt(i549)));
					}
					switch(i549 - (l548 - 8)) {
					case 0:
						if(v548) {
							bs548 |= 128;
						} else {
							bs548 &= -129;
						}
						break;
					case 1:
						if(v548) {
							bs548 |= 64;
						} else {
							bs548 &= -65;
						}
						break;
					case 2:
						if(v548) {
							bs548 |= 32;
						} else {
							bs548 &= -33;
						}
						break;
					case 3:
						if(v548) {
							bs548 |= 16;
						} else {
							bs548 &= -17;
						}
						break;
					case 4:
						if(v548) {
							bs548 |= 8;
						} else {
							bs548 &= -9;
						}
						break;
					case 5:
						if(v548) {
							bs548 |= 4;
						} else {
							bs548 &= -5;
						}
						break;
					case 6:
						if(v548) {
							bs548 |= 2;
						} else {
							bs548 &= -3;
						}
						break;
					case 7:
						if(v548) {
							bs548 |= 1;
						} else {
							bs548 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs548;
				var this550 = 0;
				var bs549 = this550;
				var l549 = "**  *".length;
				var _g1550 = 0;
				var _g650 = l549;
				while(_g1550 < _g650) {
					var i550 = _g1550++;
					var no549 = "**  *".charCodeAt(i550);
					if(no549 == null) {
						break;
					}
					var v549;
					switch(no549) {
					case 32:
						v549 = false;
						break;
					case 42:
						v549 = true;
						break;
					case 48:
						v549 = false;
						break;
					case 49:
						v549 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i550)));
					}
					switch(i550 - (l549 - 8)) {
					case 0:
						if(v549) {
							bs549 |= 128;
						} else {
							bs549 &= -129;
						}
						break;
					case 1:
						if(v549) {
							bs549 |= 64;
						} else {
							bs549 &= -65;
						}
						break;
					case 2:
						if(v549) {
							bs549 |= 32;
						} else {
							bs549 &= -33;
						}
						break;
					case 3:
						if(v549) {
							bs549 |= 16;
						} else {
							bs549 &= -17;
						}
						break;
					case 4:
						if(v549) {
							bs549 |= 8;
						} else {
							bs549 &= -9;
						}
						break;
					case 5:
						if(v549) {
							bs549 |= 4;
						} else {
							bs549 &= -5;
						}
						break;
					case 6:
						if(v549) {
							bs549 |= 2;
						} else {
							bs549 &= -3;
						}
						break;
					case 7:
						if(v549) {
							bs549 |= 1;
						} else {
							bs549 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs549;
				var this551 = 0;
				var bs550 = this551;
				var l550 = "*   *".length;
				var _g1551 = 0;
				var _g651 = l550;
				while(_g1551 < _g651) {
					var i551 = _g1551++;
					var no550 = "*   *".charCodeAt(i551);
					if(no550 == null) {
						break;
					}
					var v550;
					switch(no550) {
					case 32:
						v550 = false;
						break;
					case 42:
						v550 = true;
						break;
					case 48:
						v550 = false;
						break;
					case 49:
						v550 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i551)));
					}
					switch(i551 - (l550 - 8)) {
					case 0:
						if(v550) {
							bs550 |= 128;
						} else {
							bs550 &= -129;
						}
						break;
					case 1:
						if(v550) {
							bs550 |= 64;
						} else {
							bs550 &= -65;
						}
						break;
					case 2:
						if(v550) {
							bs550 |= 32;
						} else {
							bs550 &= -33;
						}
						break;
					case 3:
						if(v550) {
							bs550 |= 16;
						} else {
							bs550 &= -17;
						}
						break;
					case 4:
						if(v550) {
							bs550 |= 8;
						} else {
							bs550 &= -9;
						}
						break;
					case 5:
						if(v550) {
							bs550 |= 4;
						} else {
							bs550 &= -5;
						}
						break;
					case 6:
						if(v550) {
							bs550 |= 2;
						} else {
							bs550 &= -3;
						}
						break;
					case 7:
						if(v550) {
							bs550 |= 1;
						} else {
							bs550 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs550;
				var this552 = 0;
				var bs551 = this552;
				var l551 = "*   *".length;
				var _g1552 = 0;
				var _g652 = l551;
				while(_g1552 < _g652) {
					var i552 = _g1552++;
					var no551 = "*   *".charCodeAt(i552);
					if(no551 == null) {
						break;
					}
					var v551;
					switch(no551) {
					case 32:
						v551 = false;
						break;
					case 42:
						v551 = true;
						break;
					case 48:
						v551 = false;
						break;
					case 49:
						v551 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i552)));
					}
					switch(i552 - (l551 - 8)) {
					case 0:
						if(v551) {
							bs551 |= 128;
						} else {
							bs551 &= -129;
						}
						break;
					case 1:
						if(v551) {
							bs551 |= 64;
						} else {
							bs551 &= -65;
						}
						break;
					case 2:
						if(v551) {
							bs551 |= 32;
						} else {
							bs551 &= -33;
						}
						break;
					case 3:
						if(v551) {
							bs551 |= 16;
						} else {
							bs551 &= -17;
						}
						break;
					case 4:
						if(v551) {
							bs551 |= 8;
						} else {
							bs551 &= -9;
						}
						break;
					case 5:
						if(v551) {
							bs551 |= 4;
						} else {
							bs551 &= -5;
						}
						break;
					case 6:
						if(v551) {
							bs551 |= 2;
						} else {
							bs551 &= -3;
						}
						break;
					case 7:
						if(v551) {
							bs551 |= 1;
						} else {
							bs551 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs551;
				var this553 = 0;
				var bs552 = this553;
				var l552 = "*   *".length;
				var _g1553 = 0;
				var _g653 = l552;
				while(_g1553 < _g653) {
					var i553 = _g1553++;
					var no552 = "*   *".charCodeAt(i553);
					if(no552 == null) {
						break;
					}
					var v552;
					switch(no552) {
					case 32:
						v552 = false;
						break;
					case 42:
						v552 = true;
						break;
					case 48:
						v552 = false;
						break;
					case 49:
						v552 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i553)));
					}
					switch(i553 - (l552 - 8)) {
					case 0:
						if(v552) {
							bs552 |= 128;
						} else {
							bs552 &= -129;
						}
						break;
					case 1:
						if(v552) {
							bs552 |= 64;
						} else {
							bs552 &= -65;
						}
						break;
					case 2:
						if(v552) {
							bs552 |= 32;
						} else {
							bs552 &= -33;
						}
						break;
					case 3:
						if(v552) {
							bs552 |= 16;
						} else {
							bs552 &= -17;
						}
						break;
					case 4:
						if(v552) {
							bs552 |= 8;
						} else {
							bs552 &= -9;
						}
						break;
					case 5:
						if(v552) {
							bs552 |= 4;
						} else {
							bs552 &= -5;
						}
						break;
					case 6:
						if(v552) {
							bs552 |= 2;
						} else {
							bs552 &= -3;
						}
						break;
					case 7:
						if(v552) {
							bs552 |= 1;
						} else {
							bs552 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs552;
				break;
			case 111:
				var this554 = 0;
				var bs553 = this554;
				var l553 = "     ".length;
				var _g1554 = 0;
				var _g654 = l553;
				while(_g1554 < _g654) {
					var i554 = _g1554++;
					var no553 = "     ".charCodeAt(i554);
					if(no553 == null) {
						break;
					}
					var v553;
					switch(no553) {
					case 32:
						v553 = false;
						break;
					case 42:
						v553 = true;
						break;
					case 48:
						v553 = false;
						break;
					case 49:
						v553 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i554)));
					}
					switch(i554 - (l553 - 8)) {
					case 0:
						if(v553) {
							bs553 |= 128;
						} else {
							bs553 &= -129;
						}
						break;
					case 1:
						if(v553) {
							bs553 |= 64;
						} else {
							bs553 &= -65;
						}
						break;
					case 2:
						if(v553) {
							bs553 |= 32;
						} else {
							bs553 &= -33;
						}
						break;
					case 3:
						if(v553) {
							bs553 |= 16;
						} else {
							bs553 &= -17;
						}
						break;
					case 4:
						if(v553) {
							bs553 |= 8;
						} else {
							bs553 &= -9;
						}
						break;
					case 5:
						if(v553) {
							bs553 |= 4;
						} else {
							bs553 &= -5;
						}
						break;
					case 6:
						if(v553) {
							bs553 |= 2;
						} else {
							bs553 &= -3;
						}
						break;
					case 7:
						if(v553) {
							bs553 |= 1;
						} else {
							bs553 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs553;
				var this555 = 0;
				var bs554 = this555;
				var l554 = "     ".length;
				var _g1555 = 0;
				var _g655 = l554;
				while(_g1555 < _g655) {
					var i555 = _g1555++;
					var no554 = "     ".charCodeAt(i555);
					if(no554 == null) {
						break;
					}
					var v554;
					switch(no554) {
					case 32:
						v554 = false;
						break;
					case 42:
						v554 = true;
						break;
					case 48:
						v554 = false;
						break;
					case 49:
						v554 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i555)));
					}
					switch(i555 - (l554 - 8)) {
					case 0:
						if(v554) {
							bs554 |= 128;
						} else {
							bs554 &= -129;
						}
						break;
					case 1:
						if(v554) {
							bs554 |= 64;
						} else {
							bs554 &= -65;
						}
						break;
					case 2:
						if(v554) {
							bs554 |= 32;
						} else {
							bs554 &= -33;
						}
						break;
					case 3:
						if(v554) {
							bs554 |= 16;
						} else {
							bs554 &= -17;
						}
						break;
					case 4:
						if(v554) {
							bs554 |= 8;
						} else {
							bs554 &= -9;
						}
						break;
					case 5:
						if(v554) {
							bs554 |= 4;
						} else {
							bs554 &= -5;
						}
						break;
					case 6:
						if(v554) {
							bs554 |= 2;
						} else {
							bs554 &= -3;
						}
						break;
					case 7:
						if(v554) {
							bs554 |= 1;
						} else {
							bs554 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs554;
				var this556 = 0;
				var bs555 = this556;
				var l555 = " *** ".length;
				var _g1556 = 0;
				var _g656 = l555;
				while(_g1556 < _g656) {
					var i556 = _g1556++;
					var no555 = " *** ".charCodeAt(i556);
					if(no555 == null) {
						break;
					}
					var v555;
					switch(no555) {
					case 32:
						v555 = false;
						break;
					case 42:
						v555 = true;
						break;
					case 48:
						v555 = false;
						break;
					case 49:
						v555 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i556)));
					}
					switch(i556 - (l555 - 8)) {
					case 0:
						if(v555) {
							bs555 |= 128;
						} else {
							bs555 &= -129;
						}
						break;
					case 1:
						if(v555) {
							bs555 |= 64;
						} else {
							bs555 &= -65;
						}
						break;
					case 2:
						if(v555) {
							bs555 |= 32;
						} else {
							bs555 &= -33;
						}
						break;
					case 3:
						if(v555) {
							bs555 |= 16;
						} else {
							bs555 &= -17;
						}
						break;
					case 4:
						if(v555) {
							bs555 |= 8;
						} else {
							bs555 &= -9;
						}
						break;
					case 5:
						if(v555) {
							bs555 |= 4;
						} else {
							bs555 &= -5;
						}
						break;
					case 6:
						if(v555) {
							bs555 |= 2;
						} else {
							bs555 &= -3;
						}
						break;
					case 7:
						if(v555) {
							bs555 |= 1;
						} else {
							bs555 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs555;
				var this557 = 0;
				var bs556 = this557;
				var l556 = "*   *".length;
				var _g1557 = 0;
				var _g657 = l556;
				while(_g1557 < _g657) {
					var i557 = _g1557++;
					var no556 = "*   *".charCodeAt(i557);
					if(no556 == null) {
						break;
					}
					var v556;
					switch(no556) {
					case 32:
						v556 = false;
						break;
					case 42:
						v556 = true;
						break;
					case 48:
						v556 = false;
						break;
					case 49:
						v556 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i557)));
					}
					switch(i557 - (l556 - 8)) {
					case 0:
						if(v556) {
							bs556 |= 128;
						} else {
							bs556 &= -129;
						}
						break;
					case 1:
						if(v556) {
							bs556 |= 64;
						} else {
							bs556 &= -65;
						}
						break;
					case 2:
						if(v556) {
							bs556 |= 32;
						} else {
							bs556 &= -33;
						}
						break;
					case 3:
						if(v556) {
							bs556 |= 16;
						} else {
							bs556 &= -17;
						}
						break;
					case 4:
						if(v556) {
							bs556 |= 8;
						} else {
							bs556 &= -9;
						}
						break;
					case 5:
						if(v556) {
							bs556 |= 4;
						} else {
							bs556 &= -5;
						}
						break;
					case 6:
						if(v556) {
							bs556 |= 2;
						} else {
							bs556 &= -3;
						}
						break;
					case 7:
						if(v556) {
							bs556 |= 1;
						} else {
							bs556 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs556;
				var this558 = 0;
				var bs557 = this558;
				var l557 = "*   *".length;
				var _g1558 = 0;
				var _g658 = l557;
				while(_g1558 < _g658) {
					var i558 = _g1558++;
					var no557 = "*   *".charCodeAt(i558);
					if(no557 == null) {
						break;
					}
					var v557;
					switch(no557) {
					case 32:
						v557 = false;
						break;
					case 42:
						v557 = true;
						break;
					case 48:
						v557 = false;
						break;
					case 49:
						v557 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i558)));
					}
					switch(i558 - (l557 - 8)) {
					case 0:
						if(v557) {
							bs557 |= 128;
						} else {
							bs557 &= -129;
						}
						break;
					case 1:
						if(v557) {
							bs557 |= 64;
						} else {
							bs557 &= -65;
						}
						break;
					case 2:
						if(v557) {
							bs557 |= 32;
						} else {
							bs557 &= -33;
						}
						break;
					case 3:
						if(v557) {
							bs557 |= 16;
						} else {
							bs557 &= -17;
						}
						break;
					case 4:
						if(v557) {
							bs557 |= 8;
						} else {
							bs557 &= -9;
						}
						break;
					case 5:
						if(v557) {
							bs557 |= 4;
						} else {
							bs557 &= -5;
						}
						break;
					case 6:
						if(v557) {
							bs557 |= 2;
						} else {
							bs557 &= -3;
						}
						break;
					case 7:
						if(v557) {
							bs557 |= 1;
						} else {
							bs557 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs557;
				var this559 = 0;
				var bs558 = this559;
				var l558 = "*   *".length;
				var _g1559 = 0;
				var _g659 = l558;
				while(_g1559 < _g659) {
					var i559 = _g1559++;
					var no558 = "*   *".charCodeAt(i559);
					if(no558 == null) {
						break;
					}
					var v558;
					switch(no558) {
					case 32:
						v558 = false;
						break;
					case 42:
						v558 = true;
						break;
					case 48:
						v558 = false;
						break;
					case 49:
						v558 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i559)));
					}
					switch(i559 - (l558 - 8)) {
					case 0:
						if(v558) {
							bs558 |= 128;
						} else {
							bs558 &= -129;
						}
						break;
					case 1:
						if(v558) {
							bs558 |= 64;
						} else {
							bs558 &= -65;
						}
						break;
					case 2:
						if(v558) {
							bs558 |= 32;
						} else {
							bs558 &= -33;
						}
						break;
					case 3:
						if(v558) {
							bs558 |= 16;
						} else {
							bs558 &= -17;
						}
						break;
					case 4:
						if(v558) {
							bs558 |= 8;
						} else {
							bs558 &= -9;
						}
						break;
					case 5:
						if(v558) {
							bs558 |= 4;
						} else {
							bs558 &= -5;
						}
						break;
					case 6:
						if(v558) {
							bs558 |= 2;
						} else {
							bs558 &= -3;
						}
						break;
					case 7:
						if(v558) {
							bs558 |= 1;
						} else {
							bs558 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs558;
				var this560 = 0;
				var bs559 = this560;
				var l559 = " *** ".length;
				var _g1560 = 0;
				var _g660 = l559;
				while(_g1560 < _g660) {
					var i560 = _g1560++;
					var no559 = " *** ".charCodeAt(i560);
					if(no559 == null) {
						break;
					}
					var v559;
					switch(no559) {
					case 32:
						v559 = false;
						break;
					case 42:
						v559 = true;
						break;
					case 48:
						v559 = false;
						break;
					case 49:
						v559 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i560)));
					}
					switch(i560 - (l559 - 8)) {
					case 0:
						if(v559) {
							bs559 |= 128;
						} else {
							bs559 &= -129;
						}
						break;
					case 1:
						if(v559) {
							bs559 |= 64;
						} else {
							bs559 &= -65;
						}
						break;
					case 2:
						if(v559) {
							bs559 |= 32;
						} else {
							bs559 &= -33;
						}
						break;
					case 3:
						if(v559) {
							bs559 |= 16;
						} else {
							bs559 &= -17;
						}
						break;
					case 4:
						if(v559) {
							bs559 |= 8;
						} else {
							bs559 &= -9;
						}
						break;
					case 5:
						if(v559) {
							bs559 |= 4;
						} else {
							bs559 &= -5;
						}
						break;
					case 6:
						if(v559) {
							bs559 |= 2;
						} else {
							bs559 &= -3;
						}
						break;
					case 7:
						if(v559) {
							bs559 |= 1;
						} else {
							bs559 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs559;
				break;
			case 112:
				var this561 = 0;
				var bs560 = this561;
				var l560 = "     ".length;
				var _g1561 = 0;
				var _g661 = l560;
				while(_g1561 < _g661) {
					var i561 = _g1561++;
					var no560 = "     ".charCodeAt(i561);
					if(no560 == null) {
						break;
					}
					var v560;
					switch(no560) {
					case 32:
						v560 = false;
						break;
					case 42:
						v560 = true;
						break;
					case 48:
						v560 = false;
						break;
					case 49:
						v560 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i561)));
					}
					switch(i561 - (l560 - 8)) {
					case 0:
						if(v560) {
							bs560 |= 128;
						} else {
							bs560 &= -129;
						}
						break;
					case 1:
						if(v560) {
							bs560 |= 64;
						} else {
							bs560 &= -65;
						}
						break;
					case 2:
						if(v560) {
							bs560 |= 32;
						} else {
							bs560 &= -33;
						}
						break;
					case 3:
						if(v560) {
							bs560 |= 16;
						} else {
							bs560 &= -17;
						}
						break;
					case 4:
						if(v560) {
							bs560 |= 8;
						} else {
							bs560 &= -9;
						}
						break;
					case 5:
						if(v560) {
							bs560 |= 4;
						} else {
							bs560 &= -5;
						}
						break;
					case 6:
						if(v560) {
							bs560 |= 2;
						} else {
							bs560 &= -3;
						}
						break;
					case 7:
						if(v560) {
							bs560 |= 1;
						} else {
							bs560 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs560;
				var this562 = 0;
				var bs561 = this562;
				var l561 = "     ".length;
				var _g1562 = 0;
				var _g662 = l561;
				while(_g1562 < _g662) {
					var i562 = _g1562++;
					var no561 = "     ".charCodeAt(i562);
					if(no561 == null) {
						break;
					}
					var v561;
					switch(no561) {
					case 32:
						v561 = false;
						break;
					case 42:
						v561 = true;
						break;
					case 48:
						v561 = false;
						break;
					case 49:
						v561 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i562)));
					}
					switch(i562 - (l561 - 8)) {
					case 0:
						if(v561) {
							bs561 |= 128;
						} else {
							bs561 &= -129;
						}
						break;
					case 1:
						if(v561) {
							bs561 |= 64;
						} else {
							bs561 &= -65;
						}
						break;
					case 2:
						if(v561) {
							bs561 |= 32;
						} else {
							bs561 &= -33;
						}
						break;
					case 3:
						if(v561) {
							bs561 |= 16;
						} else {
							bs561 &= -17;
						}
						break;
					case 4:
						if(v561) {
							bs561 |= 8;
						} else {
							bs561 &= -9;
						}
						break;
					case 5:
						if(v561) {
							bs561 |= 4;
						} else {
							bs561 &= -5;
						}
						break;
					case 6:
						if(v561) {
							bs561 |= 2;
						} else {
							bs561 &= -3;
						}
						break;
					case 7:
						if(v561) {
							bs561 |= 1;
						} else {
							bs561 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs561;
				var this563 = 0;
				var bs562 = this563;
				var l562 = "**** ".length;
				var _g1563 = 0;
				var _g663 = l562;
				while(_g1563 < _g663) {
					var i563 = _g1563++;
					var no562 = "**** ".charCodeAt(i563);
					if(no562 == null) {
						break;
					}
					var v562;
					switch(no562) {
					case 32:
						v562 = false;
						break;
					case 42:
						v562 = true;
						break;
					case 48:
						v562 = false;
						break;
					case 49:
						v562 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i563)));
					}
					switch(i563 - (l562 - 8)) {
					case 0:
						if(v562) {
							bs562 |= 128;
						} else {
							bs562 &= -129;
						}
						break;
					case 1:
						if(v562) {
							bs562 |= 64;
						} else {
							bs562 &= -65;
						}
						break;
					case 2:
						if(v562) {
							bs562 |= 32;
						} else {
							bs562 &= -33;
						}
						break;
					case 3:
						if(v562) {
							bs562 |= 16;
						} else {
							bs562 &= -17;
						}
						break;
					case 4:
						if(v562) {
							bs562 |= 8;
						} else {
							bs562 &= -9;
						}
						break;
					case 5:
						if(v562) {
							bs562 |= 4;
						} else {
							bs562 &= -5;
						}
						break;
					case 6:
						if(v562) {
							bs562 |= 2;
						} else {
							bs562 &= -3;
						}
						break;
					case 7:
						if(v562) {
							bs562 |= 1;
						} else {
							bs562 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs562;
				var this564 = 0;
				var bs563 = this564;
				var l563 = "*   *".length;
				var _g1564 = 0;
				var _g664 = l563;
				while(_g1564 < _g664) {
					var i564 = _g1564++;
					var no563 = "*   *".charCodeAt(i564);
					if(no563 == null) {
						break;
					}
					var v563;
					switch(no563) {
					case 32:
						v563 = false;
						break;
					case 42:
						v563 = true;
						break;
					case 48:
						v563 = false;
						break;
					case 49:
						v563 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i564)));
					}
					switch(i564 - (l563 - 8)) {
					case 0:
						if(v563) {
							bs563 |= 128;
						} else {
							bs563 &= -129;
						}
						break;
					case 1:
						if(v563) {
							bs563 |= 64;
						} else {
							bs563 &= -65;
						}
						break;
					case 2:
						if(v563) {
							bs563 |= 32;
						} else {
							bs563 &= -33;
						}
						break;
					case 3:
						if(v563) {
							bs563 |= 16;
						} else {
							bs563 &= -17;
						}
						break;
					case 4:
						if(v563) {
							bs563 |= 8;
						} else {
							bs563 &= -9;
						}
						break;
					case 5:
						if(v563) {
							bs563 |= 4;
						} else {
							bs563 &= -5;
						}
						break;
					case 6:
						if(v563) {
							bs563 |= 2;
						} else {
							bs563 &= -3;
						}
						break;
					case 7:
						if(v563) {
							bs563 |= 1;
						} else {
							bs563 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs563;
				var this565 = 0;
				var bs564 = this565;
				var l564 = "**** ".length;
				var _g1565 = 0;
				var _g665 = l564;
				while(_g1565 < _g665) {
					var i565 = _g1565++;
					var no564 = "**** ".charCodeAt(i565);
					if(no564 == null) {
						break;
					}
					var v564;
					switch(no564) {
					case 32:
						v564 = false;
						break;
					case 42:
						v564 = true;
						break;
					case 48:
						v564 = false;
						break;
					case 49:
						v564 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i565)));
					}
					switch(i565 - (l564 - 8)) {
					case 0:
						if(v564) {
							bs564 |= 128;
						} else {
							bs564 &= -129;
						}
						break;
					case 1:
						if(v564) {
							bs564 |= 64;
						} else {
							bs564 &= -65;
						}
						break;
					case 2:
						if(v564) {
							bs564 |= 32;
						} else {
							bs564 &= -33;
						}
						break;
					case 3:
						if(v564) {
							bs564 |= 16;
						} else {
							bs564 &= -17;
						}
						break;
					case 4:
						if(v564) {
							bs564 |= 8;
						} else {
							bs564 &= -9;
						}
						break;
					case 5:
						if(v564) {
							bs564 |= 4;
						} else {
							bs564 &= -5;
						}
						break;
					case 6:
						if(v564) {
							bs564 |= 2;
						} else {
							bs564 &= -3;
						}
						break;
					case 7:
						if(v564) {
							bs564 |= 1;
						} else {
							bs564 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs564;
				var this566 = 0;
				var bs565 = this566;
				var l565 = "*    ".length;
				var _g1566 = 0;
				var _g666 = l565;
				while(_g1566 < _g666) {
					var i566 = _g1566++;
					var no565 = "*    ".charCodeAt(i566);
					if(no565 == null) {
						break;
					}
					var v565;
					switch(no565) {
					case 32:
						v565 = false;
						break;
					case 42:
						v565 = true;
						break;
					case 48:
						v565 = false;
						break;
					case 49:
						v565 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i566)));
					}
					switch(i566 - (l565 - 8)) {
					case 0:
						if(v565) {
							bs565 |= 128;
						} else {
							bs565 &= -129;
						}
						break;
					case 1:
						if(v565) {
							bs565 |= 64;
						} else {
							bs565 &= -65;
						}
						break;
					case 2:
						if(v565) {
							bs565 |= 32;
						} else {
							bs565 &= -33;
						}
						break;
					case 3:
						if(v565) {
							bs565 |= 16;
						} else {
							bs565 &= -17;
						}
						break;
					case 4:
						if(v565) {
							bs565 |= 8;
						} else {
							bs565 &= -9;
						}
						break;
					case 5:
						if(v565) {
							bs565 |= 4;
						} else {
							bs565 &= -5;
						}
						break;
					case 6:
						if(v565) {
							bs565 |= 2;
						} else {
							bs565 &= -3;
						}
						break;
					case 7:
						if(v565) {
							bs565 |= 1;
						} else {
							bs565 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs565;
				var this567 = 0;
				var bs566 = this567;
				var l566 = "*    ".length;
				var _g1567 = 0;
				var _g667 = l566;
				while(_g1567 < _g667) {
					var i567 = _g1567++;
					var no566 = "*    ".charCodeAt(i567);
					if(no566 == null) {
						break;
					}
					var v566;
					switch(no566) {
					case 32:
						v566 = false;
						break;
					case 42:
						v566 = true;
						break;
					case 48:
						v566 = false;
						break;
					case 49:
						v566 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i567)));
					}
					switch(i567 - (l566 - 8)) {
					case 0:
						if(v566) {
							bs566 |= 128;
						} else {
							bs566 &= -129;
						}
						break;
					case 1:
						if(v566) {
							bs566 |= 64;
						} else {
							bs566 &= -65;
						}
						break;
					case 2:
						if(v566) {
							bs566 |= 32;
						} else {
							bs566 &= -33;
						}
						break;
					case 3:
						if(v566) {
							bs566 |= 16;
						} else {
							bs566 &= -17;
						}
						break;
					case 4:
						if(v566) {
							bs566 |= 8;
						} else {
							bs566 &= -9;
						}
						break;
					case 5:
						if(v566) {
							bs566 |= 4;
						} else {
							bs566 &= -5;
						}
						break;
					case 6:
						if(v566) {
							bs566 |= 2;
						} else {
							bs566 &= -3;
						}
						break;
					case 7:
						if(v566) {
							bs566 |= 1;
						} else {
							bs566 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs566;
				break;
			case 113:
				var this568 = 0;
				var bs567 = this568;
				var l567 = "     ".length;
				var _g1568 = 0;
				var _g668 = l567;
				while(_g1568 < _g668) {
					var i568 = _g1568++;
					var no567 = "     ".charCodeAt(i568);
					if(no567 == null) {
						break;
					}
					var v567;
					switch(no567) {
					case 32:
						v567 = false;
						break;
					case 42:
						v567 = true;
						break;
					case 48:
						v567 = false;
						break;
					case 49:
						v567 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i568)));
					}
					switch(i568 - (l567 - 8)) {
					case 0:
						if(v567) {
							bs567 |= 128;
						} else {
							bs567 &= -129;
						}
						break;
					case 1:
						if(v567) {
							bs567 |= 64;
						} else {
							bs567 &= -65;
						}
						break;
					case 2:
						if(v567) {
							bs567 |= 32;
						} else {
							bs567 &= -33;
						}
						break;
					case 3:
						if(v567) {
							bs567 |= 16;
						} else {
							bs567 &= -17;
						}
						break;
					case 4:
						if(v567) {
							bs567 |= 8;
						} else {
							bs567 &= -9;
						}
						break;
					case 5:
						if(v567) {
							bs567 |= 4;
						} else {
							bs567 &= -5;
						}
						break;
					case 6:
						if(v567) {
							bs567 |= 2;
						} else {
							bs567 &= -3;
						}
						break;
					case 7:
						if(v567) {
							bs567 |= 1;
						} else {
							bs567 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs567;
				var this569 = 0;
				var bs568 = this569;
				var l568 = "     ".length;
				var _g1569 = 0;
				var _g669 = l568;
				while(_g1569 < _g669) {
					var i569 = _g1569++;
					var no568 = "     ".charCodeAt(i569);
					if(no568 == null) {
						break;
					}
					var v568;
					switch(no568) {
					case 32:
						v568 = false;
						break;
					case 42:
						v568 = true;
						break;
					case 48:
						v568 = false;
						break;
					case 49:
						v568 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i569)));
					}
					switch(i569 - (l568 - 8)) {
					case 0:
						if(v568) {
							bs568 |= 128;
						} else {
							bs568 &= -129;
						}
						break;
					case 1:
						if(v568) {
							bs568 |= 64;
						} else {
							bs568 &= -65;
						}
						break;
					case 2:
						if(v568) {
							bs568 |= 32;
						} else {
							bs568 &= -33;
						}
						break;
					case 3:
						if(v568) {
							bs568 |= 16;
						} else {
							bs568 &= -17;
						}
						break;
					case 4:
						if(v568) {
							bs568 |= 8;
						} else {
							bs568 &= -9;
						}
						break;
					case 5:
						if(v568) {
							bs568 |= 4;
						} else {
							bs568 &= -5;
						}
						break;
					case 6:
						if(v568) {
							bs568 |= 2;
						} else {
							bs568 &= -3;
						}
						break;
					case 7:
						if(v568) {
							bs568 |= 1;
						} else {
							bs568 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs568;
				var this570 = 0;
				var bs569 = this570;
				var l569 = " ** *".length;
				var _g1570 = 0;
				var _g670 = l569;
				while(_g1570 < _g670) {
					var i570 = _g1570++;
					var no569 = " ** *".charCodeAt(i570);
					if(no569 == null) {
						break;
					}
					var v569;
					switch(no569) {
					case 32:
						v569 = false;
						break;
					case 42:
						v569 = true;
						break;
					case 48:
						v569 = false;
						break;
					case 49:
						v569 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i570)));
					}
					switch(i570 - (l569 - 8)) {
					case 0:
						if(v569) {
							bs569 |= 128;
						} else {
							bs569 &= -129;
						}
						break;
					case 1:
						if(v569) {
							bs569 |= 64;
						} else {
							bs569 &= -65;
						}
						break;
					case 2:
						if(v569) {
							bs569 |= 32;
						} else {
							bs569 &= -33;
						}
						break;
					case 3:
						if(v569) {
							bs569 |= 16;
						} else {
							bs569 &= -17;
						}
						break;
					case 4:
						if(v569) {
							bs569 |= 8;
						} else {
							bs569 &= -9;
						}
						break;
					case 5:
						if(v569) {
							bs569 |= 4;
						} else {
							bs569 &= -5;
						}
						break;
					case 6:
						if(v569) {
							bs569 |= 2;
						} else {
							bs569 &= -3;
						}
						break;
					case 7:
						if(v569) {
							bs569 |= 1;
						} else {
							bs569 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs569;
				var this571 = 0;
				var bs570 = this571;
				var l570 = "*  **".length;
				var _g1571 = 0;
				var _g671 = l570;
				while(_g1571 < _g671) {
					var i571 = _g1571++;
					var no570 = "*  **".charCodeAt(i571);
					if(no570 == null) {
						break;
					}
					var v570;
					switch(no570) {
					case 32:
						v570 = false;
						break;
					case 42:
						v570 = true;
						break;
					case 48:
						v570 = false;
						break;
					case 49:
						v570 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  **".charCodeAt(i571)));
					}
					switch(i571 - (l570 - 8)) {
					case 0:
						if(v570) {
							bs570 |= 128;
						} else {
							bs570 &= -129;
						}
						break;
					case 1:
						if(v570) {
							bs570 |= 64;
						} else {
							bs570 &= -65;
						}
						break;
					case 2:
						if(v570) {
							bs570 |= 32;
						} else {
							bs570 &= -33;
						}
						break;
					case 3:
						if(v570) {
							bs570 |= 16;
						} else {
							bs570 &= -17;
						}
						break;
					case 4:
						if(v570) {
							bs570 |= 8;
						} else {
							bs570 &= -9;
						}
						break;
					case 5:
						if(v570) {
							bs570 |= 4;
						} else {
							bs570 &= -5;
						}
						break;
					case 6:
						if(v570) {
							bs570 |= 2;
						} else {
							bs570 &= -3;
						}
						break;
					case 7:
						if(v570) {
							bs570 |= 1;
						} else {
							bs570 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs570;
				var this572 = 0;
				var bs571 = this572;
				var l571 = " ****".length;
				var _g1572 = 0;
				var _g672 = l571;
				while(_g1572 < _g672) {
					var i572 = _g1572++;
					var no571 = " ****".charCodeAt(i572);
					if(no571 == null) {
						break;
					}
					var v571;
					switch(no571) {
					case 32:
						v571 = false;
						break;
					case 42:
						v571 = true;
						break;
					case 48:
						v571 = false;
						break;
					case 49:
						v571 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i572)));
					}
					switch(i572 - (l571 - 8)) {
					case 0:
						if(v571) {
							bs571 |= 128;
						} else {
							bs571 &= -129;
						}
						break;
					case 1:
						if(v571) {
							bs571 |= 64;
						} else {
							bs571 &= -65;
						}
						break;
					case 2:
						if(v571) {
							bs571 |= 32;
						} else {
							bs571 &= -33;
						}
						break;
					case 3:
						if(v571) {
							bs571 |= 16;
						} else {
							bs571 &= -17;
						}
						break;
					case 4:
						if(v571) {
							bs571 |= 8;
						} else {
							bs571 &= -9;
						}
						break;
					case 5:
						if(v571) {
							bs571 |= 4;
						} else {
							bs571 &= -5;
						}
						break;
					case 6:
						if(v571) {
							bs571 |= 2;
						} else {
							bs571 &= -3;
						}
						break;
					case 7:
						if(v571) {
							bs571 |= 1;
						} else {
							bs571 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs571;
				var this573 = 0;
				var bs572 = this573;
				var l572 = "    *".length;
				var _g1573 = 0;
				var _g673 = l572;
				while(_g1573 < _g673) {
					var i573 = _g1573++;
					var no572 = "    *".charCodeAt(i573);
					if(no572 == null) {
						break;
					}
					var v572;
					switch(no572) {
					case 32:
						v572 = false;
						break;
					case 42:
						v572 = true;
						break;
					case 48:
						v572 = false;
						break;
					case 49:
						v572 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i573)));
					}
					switch(i573 - (l572 - 8)) {
					case 0:
						if(v572) {
							bs572 |= 128;
						} else {
							bs572 &= -129;
						}
						break;
					case 1:
						if(v572) {
							bs572 |= 64;
						} else {
							bs572 &= -65;
						}
						break;
					case 2:
						if(v572) {
							bs572 |= 32;
						} else {
							bs572 &= -33;
						}
						break;
					case 3:
						if(v572) {
							bs572 |= 16;
						} else {
							bs572 &= -17;
						}
						break;
					case 4:
						if(v572) {
							bs572 |= 8;
						} else {
							bs572 &= -9;
						}
						break;
					case 5:
						if(v572) {
							bs572 |= 4;
						} else {
							bs572 &= -5;
						}
						break;
					case 6:
						if(v572) {
							bs572 |= 2;
						} else {
							bs572 &= -3;
						}
						break;
					case 7:
						if(v572) {
							bs572 |= 1;
						} else {
							bs572 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs572;
				var this574 = 0;
				var bs573 = this574;
				var l573 = "    *".length;
				var _g1574 = 0;
				var _g674 = l573;
				while(_g1574 < _g674) {
					var i574 = _g1574++;
					var no573 = "    *".charCodeAt(i574);
					if(no573 == null) {
						break;
					}
					var v573;
					switch(no573) {
					case 32:
						v573 = false;
						break;
					case 42:
						v573 = true;
						break;
					case 48:
						v573 = false;
						break;
					case 49:
						v573 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i574)));
					}
					switch(i574 - (l573 - 8)) {
					case 0:
						if(v573) {
							bs573 |= 128;
						} else {
							bs573 &= -129;
						}
						break;
					case 1:
						if(v573) {
							bs573 |= 64;
						} else {
							bs573 &= -65;
						}
						break;
					case 2:
						if(v573) {
							bs573 |= 32;
						} else {
							bs573 &= -33;
						}
						break;
					case 3:
						if(v573) {
							bs573 |= 16;
						} else {
							bs573 &= -17;
						}
						break;
					case 4:
						if(v573) {
							bs573 |= 8;
						} else {
							bs573 &= -9;
						}
						break;
					case 5:
						if(v573) {
							bs573 |= 4;
						} else {
							bs573 &= -5;
						}
						break;
					case 6:
						if(v573) {
							bs573 |= 2;
						} else {
							bs573 &= -3;
						}
						break;
					case 7:
						if(v573) {
							bs573 |= 1;
						} else {
							bs573 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs573;
				break;
			case 114:
				var this575 = 0;
				var bs574 = this575;
				var l574 = "     ".length;
				var _g1575 = 0;
				var _g675 = l574;
				while(_g1575 < _g675) {
					var i575 = _g1575++;
					var no574 = "     ".charCodeAt(i575);
					if(no574 == null) {
						break;
					}
					var v574;
					switch(no574) {
					case 32:
						v574 = false;
						break;
					case 42:
						v574 = true;
						break;
					case 48:
						v574 = false;
						break;
					case 49:
						v574 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i575)));
					}
					switch(i575 - (l574 - 8)) {
					case 0:
						if(v574) {
							bs574 |= 128;
						} else {
							bs574 &= -129;
						}
						break;
					case 1:
						if(v574) {
							bs574 |= 64;
						} else {
							bs574 &= -65;
						}
						break;
					case 2:
						if(v574) {
							bs574 |= 32;
						} else {
							bs574 &= -33;
						}
						break;
					case 3:
						if(v574) {
							bs574 |= 16;
						} else {
							bs574 &= -17;
						}
						break;
					case 4:
						if(v574) {
							bs574 |= 8;
						} else {
							bs574 &= -9;
						}
						break;
					case 5:
						if(v574) {
							bs574 |= 4;
						} else {
							bs574 &= -5;
						}
						break;
					case 6:
						if(v574) {
							bs574 |= 2;
						} else {
							bs574 &= -3;
						}
						break;
					case 7:
						if(v574) {
							bs574 |= 1;
						} else {
							bs574 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs574;
				var this576 = 0;
				var bs575 = this576;
				var l575 = "     ".length;
				var _g1576 = 0;
				var _g676 = l575;
				while(_g1576 < _g676) {
					var i576 = _g1576++;
					var no575 = "     ".charCodeAt(i576);
					if(no575 == null) {
						break;
					}
					var v575;
					switch(no575) {
					case 32:
						v575 = false;
						break;
					case 42:
						v575 = true;
						break;
					case 48:
						v575 = false;
						break;
					case 49:
						v575 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i576)));
					}
					switch(i576 - (l575 - 8)) {
					case 0:
						if(v575) {
							bs575 |= 128;
						} else {
							bs575 &= -129;
						}
						break;
					case 1:
						if(v575) {
							bs575 |= 64;
						} else {
							bs575 &= -65;
						}
						break;
					case 2:
						if(v575) {
							bs575 |= 32;
						} else {
							bs575 &= -33;
						}
						break;
					case 3:
						if(v575) {
							bs575 |= 16;
						} else {
							bs575 &= -17;
						}
						break;
					case 4:
						if(v575) {
							bs575 |= 8;
						} else {
							bs575 &= -9;
						}
						break;
					case 5:
						if(v575) {
							bs575 |= 4;
						} else {
							bs575 &= -5;
						}
						break;
					case 6:
						if(v575) {
							bs575 |= 2;
						} else {
							bs575 &= -3;
						}
						break;
					case 7:
						if(v575) {
							bs575 |= 1;
						} else {
							bs575 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs575;
				var this577 = 0;
				var bs576 = this577;
				var l576 = "* ** ".length;
				var _g1577 = 0;
				var _g677 = l576;
				while(_g1577 < _g677) {
					var i577 = _g1577++;
					var no576 = "* ** ".charCodeAt(i577);
					if(no576 == null) {
						break;
					}
					var v576;
					switch(no576) {
					case 32:
						v576 = false;
						break;
					case 42:
						v576 = true;
						break;
					case 48:
						v576 = false;
						break;
					case 49:
						v576 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* ** ".charCodeAt(i577)));
					}
					switch(i577 - (l576 - 8)) {
					case 0:
						if(v576) {
							bs576 |= 128;
						} else {
							bs576 &= -129;
						}
						break;
					case 1:
						if(v576) {
							bs576 |= 64;
						} else {
							bs576 &= -65;
						}
						break;
					case 2:
						if(v576) {
							bs576 |= 32;
						} else {
							bs576 &= -33;
						}
						break;
					case 3:
						if(v576) {
							bs576 |= 16;
						} else {
							bs576 &= -17;
						}
						break;
					case 4:
						if(v576) {
							bs576 |= 8;
						} else {
							bs576 &= -9;
						}
						break;
					case 5:
						if(v576) {
							bs576 |= 4;
						} else {
							bs576 &= -5;
						}
						break;
					case 6:
						if(v576) {
							bs576 |= 2;
						} else {
							bs576 &= -3;
						}
						break;
					case 7:
						if(v576) {
							bs576 |= 1;
						} else {
							bs576 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs576;
				var this578 = 0;
				var bs577 = this578;
				var l577 = "**  *".length;
				var _g1578 = 0;
				var _g678 = l577;
				while(_g1578 < _g678) {
					var i578 = _g1578++;
					var no577 = "**  *".charCodeAt(i578);
					if(no577 == null) {
						break;
					}
					var v577;
					switch(no577) {
					case 32:
						v577 = false;
						break;
					case 42:
						v577 = true;
						break;
					case 48:
						v577 = false;
						break;
					case 49:
						v577 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i578)));
					}
					switch(i578 - (l577 - 8)) {
					case 0:
						if(v577) {
							bs577 |= 128;
						} else {
							bs577 &= -129;
						}
						break;
					case 1:
						if(v577) {
							bs577 |= 64;
						} else {
							bs577 &= -65;
						}
						break;
					case 2:
						if(v577) {
							bs577 |= 32;
						} else {
							bs577 &= -33;
						}
						break;
					case 3:
						if(v577) {
							bs577 |= 16;
						} else {
							bs577 &= -17;
						}
						break;
					case 4:
						if(v577) {
							bs577 |= 8;
						} else {
							bs577 &= -9;
						}
						break;
					case 5:
						if(v577) {
							bs577 |= 4;
						} else {
							bs577 &= -5;
						}
						break;
					case 6:
						if(v577) {
							bs577 |= 2;
						} else {
							bs577 &= -3;
						}
						break;
					case 7:
						if(v577) {
							bs577 |= 1;
						} else {
							bs577 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs577;
				var this579 = 0;
				var bs578 = this579;
				var l578 = "*    ".length;
				var _g1579 = 0;
				var _g679 = l578;
				while(_g1579 < _g679) {
					var i579 = _g1579++;
					var no578 = "*    ".charCodeAt(i579);
					if(no578 == null) {
						break;
					}
					var v578;
					switch(no578) {
					case 32:
						v578 = false;
						break;
					case 42:
						v578 = true;
						break;
					case 48:
						v578 = false;
						break;
					case 49:
						v578 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i579)));
					}
					switch(i579 - (l578 - 8)) {
					case 0:
						if(v578) {
							bs578 |= 128;
						} else {
							bs578 &= -129;
						}
						break;
					case 1:
						if(v578) {
							bs578 |= 64;
						} else {
							bs578 &= -65;
						}
						break;
					case 2:
						if(v578) {
							bs578 |= 32;
						} else {
							bs578 &= -33;
						}
						break;
					case 3:
						if(v578) {
							bs578 |= 16;
						} else {
							bs578 &= -17;
						}
						break;
					case 4:
						if(v578) {
							bs578 |= 8;
						} else {
							bs578 &= -9;
						}
						break;
					case 5:
						if(v578) {
							bs578 |= 4;
						} else {
							bs578 &= -5;
						}
						break;
					case 6:
						if(v578) {
							bs578 |= 2;
						} else {
							bs578 &= -3;
						}
						break;
					case 7:
						if(v578) {
							bs578 |= 1;
						} else {
							bs578 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs578;
				var this580 = 0;
				var bs579 = this580;
				var l579 = "*    ".length;
				var _g1580 = 0;
				var _g680 = l579;
				while(_g1580 < _g680) {
					var i580 = _g1580++;
					var no579 = "*    ".charCodeAt(i580);
					if(no579 == null) {
						break;
					}
					var v579;
					switch(no579) {
					case 32:
						v579 = false;
						break;
					case 42:
						v579 = true;
						break;
					case 48:
						v579 = false;
						break;
					case 49:
						v579 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i580)));
					}
					switch(i580 - (l579 - 8)) {
					case 0:
						if(v579) {
							bs579 |= 128;
						} else {
							bs579 &= -129;
						}
						break;
					case 1:
						if(v579) {
							bs579 |= 64;
						} else {
							bs579 &= -65;
						}
						break;
					case 2:
						if(v579) {
							bs579 |= 32;
						} else {
							bs579 &= -33;
						}
						break;
					case 3:
						if(v579) {
							bs579 |= 16;
						} else {
							bs579 &= -17;
						}
						break;
					case 4:
						if(v579) {
							bs579 |= 8;
						} else {
							bs579 &= -9;
						}
						break;
					case 5:
						if(v579) {
							bs579 |= 4;
						} else {
							bs579 &= -5;
						}
						break;
					case 6:
						if(v579) {
							bs579 |= 2;
						} else {
							bs579 &= -3;
						}
						break;
					case 7:
						if(v579) {
							bs579 |= 1;
						} else {
							bs579 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs579;
				var this581 = 0;
				var bs580 = this581;
				var l580 = "*    ".length;
				var _g1581 = 0;
				var _g681 = l580;
				while(_g1581 < _g681) {
					var i581 = _g1581++;
					var no580 = "*    ".charCodeAt(i581);
					if(no580 == null) {
						break;
					}
					var v580;
					switch(no580) {
					case 32:
						v580 = false;
						break;
					case 42:
						v580 = true;
						break;
					case 48:
						v580 = false;
						break;
					case 49:
						v580 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i581)));
					}
					switch(i581 - (l580 - 8)) {
					case 0:
						if(v580) {
							bs580 |= 128;
						} else {
							bs580 &= -129;
						}
						break;
					case 1:
						if(v580) {
							bs580 |= 64;
						} else {
							bs580 &= -65;
						}
						break;
					case 2:
						if(v580) {
							bs580 |= 32;
						} else {
							bs580 &= -33;
						}
						break;
					case 3:
						if(v580) {
							bs580 |= 16;
						} else {
							bs580 &= -17;
						}
						break;
					case 4:
						if(v580) {
							bs580 |= 8;
						} else {
							bs580 &= -9;
						}
						break;
					case 5:
						if(v580) {
							bs580 |= 4;
						} else {
							bs580 &= -5;
						}
						break;
					case 6:
						if(v580) {
							bs580 |= 2;
						} else {
							bs580 &= -3;
						}
						break;
					case 7:
						if(v580) {
							bs580 |= 1;
						} else {
							bs580 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs580;
				break;
			case 115:
				var this582 = 0;
				var bs581 = this582;
				var l581 = "     ".length;
				var _g1582 = 0;
				var _g682 = l581;
				while(_g1582 < _g682) {
					var i582 = _g1582++;
					var no581 = "     ".charCodeAt(i582);
					if(no581 == null) {
						break;
					}
					var v581;
					switch(no581) {
					case 32:
						v581 = false;
						break;
					case 42:
						v581 = true;
						break;
					case 48:
						v581 = false;
						break;
					case 49:
						v581 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i582)));
					}
					switch(i582 - (l581 - 8)) {
					case 0:
						if(v581) {
							bs581 |= 128;
						} else {
							bs581 &= -129;
						}
						break;
					case 1:
						if(v581) {
							bs581 |= 64;
						} else {
							bs581 &= -65;
						}
						break;
					case 2:
						if(v581) {
							bs581 |= 32;
						} else {
							bs581 &= -33;
						}
						break;
					case 3:
						if(v581) {
							bs581 |= 16;
						} else {
							bs581 &= -17;
						}
						break;
					case 4:
						if(v581) {
							bs581 |= 8;
						} else {
							bs581 &= -9;
						}
						break;
					case 5:
						if(v581) {
							bs581 |= 4;
						} else {
							bs581 &= -5;
						}
						break;
					case 6:
						if(v581) {
							bs581 |= 2;
						} else {
							bs581 &= -3;
						}
						break;
					case 7:
						if(v581) {
							bs581 |= 1;
						} else {
							bs581 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs581;
				var this583 = 0;
				var bs582 = this583;
				var l582 = "     ".length;
				var _g1583 = 0;
				var _g683 = l582;
				while(_g1583 < _g683) {
					var i583 = _g1583++;
					var no582 = "     ".charCodeAt(i583);
					if(no582 == null) {
						break;
					}
					var v582;
					switch(no582) {
					case 32:
						v582 = false;
						break;
					case 42:
						v582 = true;
						break;
					case 48:
						v582 = false;
						break;
					case 49:
						v582 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i583)));
					}
					switch(i583 - (l582 - 8)) {
					case 0:
						if(v582) {
							bs582 |= 128;
						} else {
							bs582 &= -129;
						}
						break;
					case 1:
						if(v582) {
							bs582 |= 64;
						} else {
							bs582 &= -65;
						}
						break;
					case 2:
						if(v582) {
							bs582 |= 32;
						} else {
							bs582 &= -33;
						}
						break;
					case 3:
						if(v582) {
							bs582 |= 16;
						} else {
							bs582 &= -17;
						}
						break;
					case 4:
						if(v582) {
							bs582 |= 8;
						} else {
							bs582 &= -9;
						}
						break;
					case 5:
						if(v582) {
							bs582 |= 4;
						} else {
							bs582 &= -5;
						}
						break;
					case 6:
						if(v582) {
							bs582 |= 2;
						} else {
							bs582 &= -3;
						}
						break;
					case 7:
						if(v582) {
							bs582 |= 1;
						} else {
							bs582 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs582;
				var this584 = 0;
				var bs583 = this584;
				var l583 = " *** ".length;
				var _g1584 = 0;
				var _g684 = l583;
				while(_g1584 < _g684) {
					var i584 = _g1584++;
					var no583 = " *** ".charCodeAt(i584);
					if(no583 == null) {
						break;
					}
					var v583;
					switch(no583) {
					case 32:
						v583 = false;
						break;
					case 42:
						v583 = true;
						break;
					case 48:
						v583 = false;
						break;
					case 49:
						v583 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i584)));
					}
					switch(i584 - (l583 - 8)) {
					case 0:
						if(v583) {
							bs583 |= 128;
						} else {
							bs583 &= -129;
						}
						break;
					case 1:
						if(v583) {
							bs583 |= 64;
						} else {
							bs583 &= -65;
						}
						break;
					case 2:
						if(v583) {
							bs583 |= 32;
						} else {
							bs583 &= -33;
						}
						break;
					case 3:
						if(v583) {
							bs583 |= 16;
						} else {
							bs583 &= -17;
						}
						break;
					case 4:
						if(v583) {
							bs583 |= 8;
						} else {
							bs583 &= -9;
						}
						break;
					case 5:
						if(v583) {
							bs583 |= 4;
						} else {
							bs583 &= -5;
						}
						break;
					case 6:
						if(v583) {
							bs583 |= 2;
						} else {
							bs583 &= -3;
						}
						break;
					case 7:
						if(v583) {
							bs583 |= 1;
						} else {
							bs583 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs583;
				var this585 = 0;
				var bs584 = this585;
				var l584 = "*    ".length;
				var _g1585 = 0;
				var _g685 = l584;
				while(_g1585 < _g685) {
					var i585 = _g1585++;
					var no584 = "*    ".charCodeAt(i585);
					if(no584 == null) {
						break;
					}
					var v584;
					switch(no584) {
					case 32:
						v584 = false;
						break;
					case 42:
						v584 = true;
						break;
					case 48:
						v584 = false;
						break;
					case 49:
						v584 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i585)));
					}
					switch(i585 - (l584 - 8)) {
					case 0:
						if(v584) {
							bs584 |= 128;
						} else {
							bs584 &= -129;
						}
						break;
					case 1:
						if(v584) {
							bs584 |= 64;
						} else {
							bs584 &= -65;
						}
						break;
					case 2:
						if(v584) {
							bs584 |= 32;
						} else {
							bs584 &= -33;
						}
						break;
					case 3:
						if(v584) {
							bs584 |= 16;
						} else {
							bs584 &= -17;
						}
						break;
					case 4:
						if(v584) {
							bs584 |= 8;
						} else {
							bs584 &= -9;
						}
						break;
					case 5:
						if(v584) {
							bs584 |= 4;
						} else {
							bs584 &= -5;
						}
						break;
					case 6:
						if(v584) {
							bs584 |= 2;
						} else {
							bs584 &= -3;
						}
						break;
					case 7:
						if(v584) {
							bs584 |= 1;
						} else {
							bs584 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs584;
				var this586 = 0;
				var bs585 = this586;
				var l585 = " *** ".length;
				var _g1586 = 0;
				var _g686 = l585;
				while(_g1586 < _g686) {
					var i586 = _g1586++;
					var no585 = " *** ".charCodeAt(i586);
					if(no585 == null) {
						break;
					}
					var v585;
					switch(no585) {
					case 32:
						v585 = false;
						break;
					case 42:
						v585 = true;
						break;
					case 48:
						v585 = false;
						break;
					case 49:
						v585 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i586)));
					}
					switch(i586 - (l585 - 8)) {
					case 0:
						if(v585) {
							bs585 |= 128;
						} else {
							bs585 &= -129;
						}
						break;
					case 1:
						if(v585) {
							bs585 |= 64;
						} else {
							bs585 &= -65;
						}
						break;
					case 2:
						if(v585) {
							bs585 |= 32;
						} else {
							bs585 &= -33;
						}
						break;
					case 3:
						if(v585) {
							bs585 |= 16;
						} else {
							bs585 &= -17;
						}
						break;
					case 4:
						if(v585) {
							bs585 |= 8;
						} else {
							bs585 &= -9;
						}
						break;
					case 5:
						if(v585) {
							bs585 |= 4;
						} else {
							bs585 &= -5;
						}
						break;
					case 6:
						if(v585) {
							bs585 |= 2;
						} else {
							bs585 &= -3;
						}
						break;
					case 7:
						if(v585) {
							bs585 |= 1;
						} else {
							bs585 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs585;
				var this587 = 0;
				var bs586 = this587;
				var l586 = "    *".length;
				var _g1587 = 0;
				var _g687 = l586;
				while(_g1587 < _g687) {
					var i587 = _g1587++;
					var no586 = "    *".charCodeAt(i587);
					if(no586 == null) {
						break;
					}
					var v586;
					switch(no586) {
					case 32:
						v586 = false;
						break;
					case 42:
						v586 = true;
						break;
					case 48:
						v586 = false;
						break;
					case 49:
						v586 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i587)));
					}
					switch(i587 - (l586 - 8)) {
					case 0:
						if(v586) {
							bs586 |= 128;
						} else {
							bs586 &= -129;
						}
						break;
					case 1:
						if(v586) {
							bs586 |= 64;
						} else {
							bs586 &= -65;
						}
						break;
					case 2:
						if(v586) {
							bs586 |= 32;
						} else {
							bs586 &= -33;
						}
						break;
					case 3:
						if(v586) {
							bs586 |= 16;
						} else {
							bs586 &= -17;
						}
						break;
					case 4:
						if(v586) {
							bs586 |= 8;
						} else {
							bs586 &= -9;
						}
						break;
					case 5:
						if(v586) {
							bs586 |= 4;
						} else {
							bs586 &= -5;
						}
						break;
					case 6:
						if(v586) {
							bs586 |= 2;
						} else {
							bs586 &= -3;
						}
						break;
					case 7:
						if(v586) {
							bs586 |= 1;
						} else {
							bs586 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs586;
				var this588 = 0;
				var bs587 = this588;
				var l587 = "**** ".length;
				var _g1588 = 0;
				var _g688 = l587;
				while(_g1588 < _g688) {
					var i588 = _g1588++;
					var no587 = "**** ".charCodeAt(i588);
					if(no587 == null) {
						break;
					}
					var v587;
					switch(no587) {
					case 32:
						v587 = false;
						break;
					case 42:
						v587 = true;
						break;
					case 48:
						v587 = false;
						break;
					case 49:
						v587 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i588)));
					}
					switch(i588 - (l587 - 8)) {
					case 0:
						if(v587) {
							bs587 |= 128;
						} else {
							bs587 &= -129;
						}
						break;
					case 1:
						if(v587) {
							bs587 |= 64;
						} else {
							bs587 &= -65;
						}
						break;
					case 2:
						if(v587) {
							bs587 |= 32;
						} else {
							bs587 &= -33;
						}
						break;
					case 3:
						if(v587) {
							bs587 |= 16;
						} else {
							bs587 &= -17;
						}
						break;
					case 4:
						if(v587) {
							bs587 |= 8;
						} else {
							bs587 &= -9;
						}
						break;
					case 5:
						if(v587) {
							bs587 |= 4;
						} else {
							bs587 &= -5;
						}
						break;
					case 6:
						if(v587) {
							bs587 |= 2;
						} else {
							bs587 &= -3;
						}
						break;
					case 7:
						if(v587) {
							bs587 |= 1;
						} else {
							bs587 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs587;
				break;
			case 116:
				var this589 = 0;
				var bs588 = this589;
				var l588 = "     ".length;
				var _g1589 = 0;
				var _g689 = l588;
				while(_g1589 < _g689) {
					var i589 = _g1589++;
					var no588 = "     ".charCodeAt(i589);
					if(no588 == null) {
						break;
					}
					var v588;
					switch(no588) {
					case 32:
						v588 = false;
						break;
					case 42:
						v588 = true;
						break;
					case 48:
						v588 = false;
						break;
					case 49:
						v588 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i589)));
					}
					switch(i589 - (l588 - 8)) {
					case 0:
						if(v588) {
							bs588 |= 128;
						} else {
							bs588 &= -129;
						}
						break;
					case 1:
						if(v588) {
							bs588 |= 64;
						} else {
							bs588 &= -65;
						}
						break;
					case 2:
						if(v588) {
							bs588 |= 32;
						} else {
							bs588 &= -33;
						}
						break;
					case 3:
						if(v588) {
							bs588 |= 16;
						} else {
							bs588 &= -17;
						}
						break;
					case 4:
						if(v588) {
							bs588 |= 8;
						} else {
							bs588 &= -9;
						}
						break;
					case 5:
						if(v588) {
							bs588 |= 4;
						} else {
							bs588 &= -5;
						}
						break;
					case 6:
						if(v588) {
							bs588 |= 2;
						} else {
							bs588 &= -3;
						}
						break;
					case 7:
						if(v588) {
							bs588 |= 1;
						} else {
							bs588 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs588;
				var this590 = 0;
				var bs589 = this590;
				var l589 = " *   ".length;
				var _g1590 = 0;
				var _g690 = l589;
				while(_g1590 < _g690) {
					var i590 = _g1590++;
					var no589 = " *   ".charCodeAt(i590);
					if(no589 == null) {
						break;
					}
					var v589;
					switch(no589) {
					case 32:
						v589 = false;
						break;
					case 42:
						v589 = true;
						break;
					case 48:
						v589 = false;
						break;
					case 49:
						v589 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i590)));
					}
					switch(i590 - (l589 - 8)) {
					case 0:
						if(v589) {
							bs589 |= 128;
						} else {
							bs589 &= -129;
						}
						break;
					case 1:
						if(v589) {
							bs589 |= 64;
						} else {
							bs589 &= -65;
						}
						break;
					case 2:
						if(v589) {
							bs589 |= 32;
						} else {
							bs589 &= -33;
						}
						break;
					case 3:
						if(v589) {
							bs589 |= 16;
						} else {
							bs589 &= -17;
						}
						break;
					case 4:
						if(v589) {
							bs589 |= 8;
						} else {
							bs589 &= -9;
						}
						break;
					case 5:
						if(v589) {
							bs589 |= 4;
						} else {
							bs589 &= -5;
						}
						break;
					case 6:
						if(v589) {
							bs589 |= 2;
						} else {
							bs589 &= -3;
						}
						break;
					case 7:
						if(v589) {
							bs589 |= 1;
						} else {
							bs589 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs589;
				var this591 = 0;
				var bs590 = this591;
				var l590 = "***  ".length;
				var _g1591 = 0;
				var _g691 = l590;
				while(_g1591 < _g691) {
					var i591 = _g1591++;
					var no590 = "***  ".charCodeAt(i591);
					if(no590 == null) {
						break;
					}
					var v590;
					switch(no590) {
					case 32:
						v590 = false;
						break;
					case 42:
						v590 = true;
						break;
					case 48:
						v590 = false;
						break;
					case 49:
						v590 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("***  ".charCodeAt(i591)));
					}
					switch(i591 - (l590 - 8)) {
					case 0:
						if(v590) {
							bs590 |= 128;
						} else {
							bs590 &= -129;
						}
						break;
					case 1:
						if(v590) {
							bs590 |= 64;
						} else {
							bs590 &= -65;
						}
						break;
					case 2:
						if(v590) {
							bs590 |= 32;
						} else {
							bs590 &= -33;
						}
						break;
					case 3:
						if(v590) {
							bs590 |= 16;
						} else {
							bs590 &= -17;
						}
						break;
					case 4:
						if(v590) {
							bs590 |= 8;
						} else {
							bs590 &= -9;
						}
						break;
					case 5:
						if(v590) {
							bs590 |= 4;
						} else {
							bs590 &= -5;
						}
						break;
					case 6:
						if(v590) {
							bs590 |= 2;
						} else {
							bs590 &= -3;
						}
						break;
					case 7:
						if(v590) {
							bs590 |= 1;
						} else {
							bs590 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs590;
				var this592 = 0;
				var bs591 = this592;
				var l591 = " *   ".length;
				var _g1592 = 0;
				var _g692 = l591;
				while(_g1592 < _g692) {
					var i592 = _g1592++;
					var no591 = " *   ".charCodeAt(i592);
					if(no591 == null) {
						break;
					}
					var v591;
					switch(no591) {
					case 32:
						v591 = false;
						break;
					case 42:
						v591 = true;
						break;
					case 48:
						v591 = false;
						break;
					case 49:
						v591 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i592)));
					}
					switch(i592 - (l591 - 8)) {
					case 0:
						if(v591) {
							bs591 |= 128;
						} else {
							bs591 &= -129;
						}
						break;
					case 1:
						if(v591) {
							bs591 |= 64;
						} else {
							bs591 &= -65;
						}
						break;
					case 2:
						if(v591) {
							bs591 |= 32;
						} else {
							bs591 &= -33;
						}
						break;
					case 3:
						if(v591) {
							bs591 |= 16;
						} else {
							bs591 &= -17;
						}
						break;
					case 4:
						if(v591) {
							bs591 |= 8;
						} else {
							bs591 &= -9;
						}
						break;
					case 5:
						if(v591) {
							bs591 |= 4;
						} else {
							bs591 &= -5;
						}
						break;
					case 6:
						if(v591) {
							bs591 |= 2;
						} else {
							bs591 &= -3;
						}
						break;
					case 7:
						if(v591) {
							bs591 |= 1;
						} else {
							bs591 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs591;
				var this593 = 0;
				var bs592 = this593;
				var l592 = " *   ".length;
				var _g1593 = 0;
				var _g693 = l592;
				while(_g1593 < _g693) {
					var i593 = _g1593++;
					var no592 = " *   ".charCodeAt(i593);
					if(no592 == null) {
						break;
					}
					var v592;
					switch(no592) {
					case 32:
						v592 = false;
						break;
					case 42:
						v592 = true;
						break;
					case 48:
						v592 = false;
						break;
					case 49:
						v592 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i593)));
					}
					switch(i593 - (l592 - 8)) {
					case 0:
						if(v592) {
							bs592 |= 128;
						} else {
							bs592 &= -129;
						}
						break;
					case 1:
						if(v592) {
							bs592 |= 64;
						} else {
							bs592 &= -65;
						}
						break;
					case 2:
						if(v592) {
							bs592 |= 32;
						} else {
							bs592 &= -33;
						}
						break;
					case 3:
						if(v592) {
							bs592 |= 16;
						} else {
							bs592 &= -17;
						}
						break;
					case 4:
						if(v592) {
							bs592 |= 8;
						} else {
							bs592 &= -9;
						}
						break;
					case 5:
						if(v592) {
							bs592 |= 4;
						} else {
							bs592 &= -5;
						}
						break;
					case 6:
						if(v592) {
							bs592 |= 2;
						} else {
							bs592 &= -3;
						}
						break;
					case 7:
						if(v592) {
							bs592 |= 1;
						} else {
							bs592 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs592;
				var this594 = 0;
				var bs593 = this594;
				var l593 = " *  *".length;
				var _g1594 = 0;
				var _g694 = l593;
				while(_g1594 < _g694) {
					var i594 = _g1594++;
					var no593 = " *  *".charCodeAt(i594);
					if(no593 == null) {
						break;
					}
					var v593;
					switch(no593) {
					case 32:
						v593 = false;
						break;
					case 42:
						v593 = true;
						break;
					case 48:
						v593 = false;
						break;
					case 49:
						v593 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *  *".charCodeAt(i594)));
					}
					switch(i594 - (l593 - 8)) {
					case 0:
						if(v593) {
							bs593 |= 128;
						} else {
							bs593 &= -129;
						}
						break;
					case 1:
						if(v593) {
							bs593 |= 64;
						} else {
							bs593 &= -65;
						}
						break;
					case 2:
						if(v593) {
							bs593 |= 32;
						} else {
							bs593 &= -33;
						}
						break;
					case 3:
						if(v593) {
							bs593 |= 16;
						} else {
							bs593 &= -17;
						}
						break;
					case 4:
						if(v593) {
							bs593 |= 8;
						} else {
							bs593 &= -9;
						}
						break;
					case 5:
						if(v593) {
							bs593 |= 4;
						} else {
							bs593 &= -5;
						}
						break;
					case 6:
						if(v593) {
							bs593 |= 2;
						} else {
							bs593 &= -3;
						}
						break;
					case 7:
						if(v593) {
							bs593 |= 1;
						} else {
							bs593 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs593;
				var this595 = 0;
				var bs594 = this595;
				var l594 = "  ** ".length;
				var _g1595 = 0;
				var _g695 = l594;
				while(_g1595 < _g695) {
					var i595 = _g1595++;
					var no594 = "  ** ".charCodeAt(i595);
					if(no594 == null) {
						break;
					}
					var v594;
					switch(no594) {
					case 32:
						v594 = false;
						break;
					case 42:
						v594 = true;
						break;
					case 48:
						v594 = false;
						break;
					case 49:
						v594 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i595)));
					}
					switch(i595 - (l594 - 8)) {
					case 0:
						if(v594) {
							bs594 |= 128;
						} else {
							bs594 &= -129;
						}
						break;
					case 1:
						if(v594) {
							bs594 |= 64;
						} else {
							bs594 &= -65;
						}
						break;
					case 2:
						if(v594) {
							bs594 |= 32;
						} else {
							bs594 &= -33;
						}
						break;
					case 3:
						if(v594) {
							bs594 |= 16;
						} else {
							bs594 &= -17;
						}
						break;
					case 4:
						if(v594) {
							bs594 |= 8;
						} else {
							bs594 &= -9;
						}
						break;
					case 5:
						if(v594) {
							bs594 |= 4;
						} else {
							bs594 &= -5;
						}
						break;
					case 6:
						if(v594) {
							bs594 |= 2;
						} else {
							bs594 &= -3;
						}
						break;
					case 7:
						if(v594) {
							bs594 |= 1;
						} else {
							bs594 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs594;
				break;
			case 117:
				var this596 = 0;
				var bs595 = this596;
				var l595 = "     ".length;
				var _g1596 = 0;
				var _g696 = l595;
				while(_g1596 < _g696) {
					var i596 = _g1596++;
					var no595 = "     ".charCodeAt(i596);
					if(no595 == null) {
						break;
					}
					var v595;
					switch(no595) {
					case 32:
						v595 = false;
						break;
					case 42:
						v595 = true;
						break;
					case 48:
						v595 = false;
						break;
					case 49:
						v595 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i596)));
					}
					switch(i596 - (l595 - 8)) {
					case 0:
						if(v595) {
							bs595 |= 128;
						} else {
							bs595 &= -129;
						}
						break;
					case 1:
						if(v595) {
							bs595 |= 64;
						} else {
							bs595 &= -65;
						}
						break;
					case 2:
						if(v595) {
							bs595 |= 32;
						} else {
							bs595 &= -33;
						}
						break;
					case 3:
						if(v595) {
							bs595 |= 16;
						} else {
							bs595 &= -17;
						}
						break;
					case 4:
						if(v595) {
							bs595 |= 8;
						} else {
							bs595 &= -9;
						}
						break;
					case 5:
						if(v595) {
							bs595 |= 4;
						} else {
							bs595 &= -5;
						}
						break;
					case 6:
						if(v595) {
							bs595 |= 2;
						} else {
							bs595 &= -3;
						}
						break;
					case 7:
						if(v595) {
							bs595 |= 1;
						} else {
							bs595 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs595;
				var this597 = 0;
				var bs596 = this597;
				var l596 = "     ".length;
				var _g1597 = 0;
				var _g697 = l596;
				while(_g1597 < _g697) {
					var i597 = _g1597++;
					var no596 = "     ".charCodeAt(i597);
					if(no596 == null) {
						break;
					}
					var v596;
					switch(no596) {
					case 32:
						v596 = false;
						break;
					case 42:
						v596 = true;
						break;
					case 48:
						v596 = false;
						break;
					case 49:
						v596 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i597)));
					}
					switch(i597 - (l596 - 8)) {
					case 0:
						if(v596) {
							bs596 |= 128;
						} else {
							bs596 &= -129;
						}
						break;
					case 1:
						if(v596) {
							bs596 |= 64;
						} else {
							bs596 &= -65;
						}
						break;
					case 2:
						if(v596) {
							bs596 |= 32;
						} else {
							bs596 &= -33;
						}
						break;
					case 3:
						if(v596) {
							bs596 |= 16;
						} else {
							bs596 &= -17;
						}
						break;
					case 4:
						if(v596) {
							bs596 |= 8;
						} else {
							bs596 &= -9;
						}
						break;
					case 5:
						if(v596) {
							bs596 |= 4;
						} else {
							bs596 &= -5;
						}
						break;
					case 6:
						if(v596) {
							bs596 |= 2;
						} else {
							bs596 &= -3;
						}
						break;
					case 7:
						if(v596) {
							bs596 |= 1;
						} else {
							bs596 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs596;
				var this598 = 0;
				var bs597 = this598;
				var l597 = "*   *".length;
				var _g1598 = 0;
				var _g698 = l597;
				while(_g1598 < _g698) {
					var i598 = _g1598++;
					var no597 = "*   *".charCodeAt(i598);
					if(no597 == null) {
						break;
					}
					var v597;
					switch(no597) {
					case 32:
						v597 = false;
						break;
					case 42:
						v597 = true;
						break;
					case 48:
						v597 = false;
						break;
					case 49:
						v597 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i598)));
					}
					switch(i598 - (l597 - 8)) {
					case 0:
						if(v597) {
							bs597 |= 128;
						} else {
							bs597 &= -129;
						}
						break;
					case 1:
						if(v597) {
							bs597 |= 64;
						} else {
							bs597 &= -65;
						}
						break;
					case 2:
						if(v597) {
							bs597 |= 32;
						} else {
							bs597 &= -33;
						}
						break;
					case 3:
						if(v597) {
							bs597 |= 16;
						} else {
							bs597 &= -17;
						}
						break;
					case 4:
						if(v597) {
							bs597 |= 8;
						} else {
							bs597 &= -9;
						}
						break;
					case 5:
						if(v597) {
							bs597 |= 4;
						} else {
							bs597 &= -5;
						}
						break;
					case 6:
						if(v597) {
							bs597 |= 2;
						} else {
							bs597 &= -3;
						}
						break;
					case 7:
						if(v597) {
							bs597 |= 1;
						} else {
							bs597 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs597;
				var this599 = 0;
				var bs598 = this599;
				var l598 = "*   *".length;
				var _g1599 = 0;
				var _g699 = l598;
				while(_g1599 < _g699) {
					var i599 = _g1599++;
					var no598 = "*   *".charCodeAt(i599);
					if(no598 == null) {
						break;
					}
					var v598;
					switch(no598) {
					case 32:
						v598 = false;
						break;
					case 42:
						v598 = true;
						break;
					case 48:
						v598 = false;
						break;
					case 49:
						v598 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i599)));
					}
					switch(i599 - (l598 - 8)) {
					case 0:
						if(v598) {
							bs598 |= 128;
						} else {
							bs598 &= -129;
						}
						break;
					case 1:
						if(v598) {
							bs598 |= 64;
						} else {
							bs598 &= -65;
						}
						break;
					case 2:
						if(v598) {
							bs598 |= 32;
						} else {
							bs598 &= -33;
						}
						break;
					case 3:
						if(v598) {
							bs598 |= 16;
						} else {
							bs598 &= -17;
						}
						break;
					case 4:
						if(v598) {
							bs598 |= 8;
						} else {
							bs598 &= -9;
						}
						break;
					case 5:
						if(v598) {
							bs598 |= 4;
						} else {
							bs598 &= -5;
						}
						break;
					case 6:
						if(v598) {
							bs598 |= 2;
						} else {
							bs598 &= -3;
						}
						break;
					case 7:
						if(v598) {
							bs598 |= 1;
						} else {
							bs598 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs598;
				var this600 = 0;
				var bs599 = this600;
				var l599 = "*   *".length;
				var _g1600 = 0;
				var _g700 = l599;
				while(_g1600 < _g700) {
					var i600 = _g1600++;
					var no599 = "*   *".charCodeAt(i600);
					if(no599 == null) {
						break;
					}
					var v599;
					switch(no599) {
					case 32:
						v599 = false;
						break;
					case 42:
						v599 = true;
						break;
					case 48:
						v599 = false;
						break;
					case 49:
						v599 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i600)));
					}
					switch(i600 - (l599 - 8)) {
					case 0:
						if(v599) {
							bs599 |= 128;
						} else {
							bs599 &= -129;
						}
						break;
					case 1:
						if(v599) {
							bs599 |= 64;
						} else {
							bs599 &= -65;
						}
						break;
					case 2:
						if(v599) {
							bs599 |= 32;
						} else {
							bs599 &= -33;
						}
						break;
					case 3:
						if(v599) {
							bs599 |= 16;
						} else {
							bs599 &= -17;
						}
						break;
					case 4:
						if(v599) {
							bs599 |= 8;
						} else {
							bs599 &= -9;
						}
						break;
					case 5:
						if(v599) {
							bs599 |= 4;
						} else {
							bs599 &= -5;
						}
						break;
					case 6:
						if(v599) {
							bs599 |= 2;
						} else {
							bs599 &= -3;
						}
						break;
					case 7:
						if(v599) {
							bs599 |= 1;
						} else {
							bs599 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs599;
				var this601 = 0;
				var bs600 = this601;
				var l600 = "*  **".length;
				var _g1601 = 0;
				var _g701 = l600;
				while(_g1601 < _g701) {
					var i601 = _g1601++;
					var no600 = "*  **".charCodeAt(i601);
					if(no600 == null) {
						break;
					}
					var v600;
					switch(no600) {
					case 32:
						v600 = false;
						break;
					case 42:
						v600 = true;
						break;
					case 48:
						v600 = false;
						break;
					case 49:
						v600 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  **".charCodeAt(i601)));
					}
					switch(i601 - (l600 - 8)) {
					case 0:
						if(v600) {
							bs600 |= 128;
						} else {
							bs600 &= -129;
						}
						break;
					case 1:
						if(v600) {
							bs600 |= 64;
						} else {
							bs600 &= -65;
						}
						break;
					case 2:
						if(v600) {
							bs600 |= 32;
						} else {
							bs600 &= -33;
						}
						break;
					case 3:
						if(v600) {
							bs600 |= 16;
						} else {
							bs600 &= -17;
						}
						break;
					case 4:
						if(v600) {
							bs600 |= 8;
						} else {
							bs600 &= -9;
						}
						break;
					case 5:
						if(v600) {
							bs600 |= 4;
						} else {
							bs600 &= -5;
						}
						break;
					case 6:
						if(v600) {
							bs600 |= 2;
						} else {
							bs600 &= -3;
						}
						break;
					case 7:
						if(v600) {
							bs600 |= 1;
						} else {
							bs600 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs600;
				var this602 = 0;
				var bs601 = this602;
				var l601 = " ** *".length;
				var _g1602 = 0;
				var _g702 = l601;
				while(_g1602 < _g702) {
					var i602 = _g1602++;
					var no601 = " ** *".charCodeAt(i602);
					if(no601 == null) {
						break;
					}
					var v601;
					switch(no601) {
					case 32:
						v601 = false;
						break;
					case 42:
						v601 = true;
						break;
					case 48:
						v601 = false;
						break;
					case 49:
						v601 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i602)));
					}
					switch(i602 - (l601 - 8)) {
					case 0:
						if(v601) {
							bs601 |= 128;
						} else {
							bs601 &= -129;
						}
						break;
					case 1:
						if(v601) {
							bs601 |= 64;
						} else {
							bs601 &= -65;
						}
						break;
					case 2:
						if(v601) {
							bs601 |= 32;
						} else {
							bs601 &= -33;
						}
						break;
					case 3:
						if(v601) {
							bs601 |= 16;
						} else {
							bs601 &= -17;
						}
						break;
					case 4:
						if(v601) {
							bs601 |= 8;
						} else {
							bs601 &= -9;
						}
						break;
					case 5:
						if(v601) {
							bs601 |= 4;
						} else {
							bs601 &= -5;
						}
						break;
					case 6:
						if(v601) {
							bs601 |= 2;
						} else {
							bs601 &= -3;
						}
						break;
					case 7:
						if(v601) {
							bs601 |= 1;
						} else {
							bs601 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs601;
				break;
			case 118:
				var this603 = 0;
				var bs602 = this603;
				var l602 = "     ".length;
				var _g1603 = 0;
				var _g703 = l602;
				while(_g1603 < _g703) {
					var i603 = _g1603++;
					var no602 = "     ".charCodeAt(i603);
					if(no602 == null) {
						break;
					}
					var v602;
					switch(no602) {
					case 32:
						v602 = false;
						break;
					case 42:
						v602 = true;
						break;
					case 48:
						v602 = false;
						break;
					case 49:
						v602 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i603)));
					}
					switch(i603 - (l602 - 8)) {
					case 0:
						if(v602) {
							bs602 |= 128;
						} else {
							bs602 &= -129;
						}
						break;
					case 1:
						if(v602) {
							bs602 |= 64;
						} else {
							bs602 &= -65;
						}
						break;
					case 2:
						if(v602) {
							bs602 |= 32;
						} else {
							bs602 &= -33;
						}
						break;
					case 3:
						if(v602) {
							bs602 |= 16;
						} else {
							bs602 &= -17;
						}
						break;
					case 4:
						if(v602) {
							bs602 |= 8;
						} else {
							bs602 &= -9;
						}
						break;
					case 5:
						if(v602) {
							bs602 |= 4;
						} else {
							bs602 &= -5;
						}
						break;
					case 6:
						if(v602) {
							bs602 |= 2;
						} else {
							bs602 &= -3;
						}
						break;
					case 7:
						if(v602) {
							bs602 |= 1;
						} else {
							bs602 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs602;
				var this604 = 0;
				var bs603 = this604;
				var l603 = "     ".length;
				var _g1604 = 0;
				var _g704 = l603;
				while(_g1604 < _g704) {
					var i604 = _g1604++;
					var no603 = "     ".charCodeAt(i604);
					if(no603 == null) {
						break;
					}
					var v603;
					switch(no603) {
					case 32:
						v603 = false;
						break;
					case 42:
						v603 = true;
						break;
					case 48:
						v603 = false;
						break;
					case 49:
						v603 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i604)));
					}
					switch(i604 - (l603 - 8)) {
					case 0:
						if(v603) {
							bs603 |= 128;
						} else {
							bs603 &= -129;
						}
						break;
					case 1:
						if(v603) {
							bs603 |= 64;
						} else {
							bs603 &= -65;
						}
						break;
					case 2:
						if(v603) {
							bs603 |= 32;
						} else {
							bs603 &= -33;
						}
						break;
					case 3:
						if(v603) {
							bs603 |= 16;
						} else {
							bs603 &= -17;
						}
						break;
					case 4:
						if(v603) {
							bs603 |= 8;
						} else {
							bs603 &= -9;
						}
						break;
					case 5:
						if(v603) {
							bs603 |= 4;
						} else {
							bs603 &= -5;
						}
						break;
					case 6:
						if(v603) {
							bs603 |= 2;
						} else {
							bs603 &= -3;
						}
						break;
					case 7:
						if(v603) {
							bs603 |= 1;
						} else {
							bs603 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs603;
				var this605 = 0;
				var bs604 = this605;
				var l604 = "*   *".length;
				var _g1605 = 0;
				var _g705 = l604;
				while(_g1605 < _g705) {
					var i605 = _g1605++;
					var no604 = "*   *".charCodeAt(i605);
					if(no604 == null) {
						break;
					}
					var v604;
					switch(no604) {
					case 32:
						v604 = false;
						break;
					case 42:
						v604 = true;
						break;
					case 48:
						v604 = false;
						break;
					case 49:
						v604 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i605)));
					}
					switch(i605 - (l604 - 8)) {
					case 0:
						if(v604) {
							bs604 |= 128;
						} else {
							bs604 &= -129;
						}
						break;
					case 1:
						if(v604) {
							bs604 |= 64;
						} else {
							bs604 &= -65;
						}
						break;
					case 2:
						if(v604) {
							bs604 |= 32;
						} else {
							bs604 &= -33;
						}
						break;
					case 3:
						if(v604) {
							bs604 |= 16;
						} else {
							bs604 &= -17;
						}
						break;
					case 4:
						if(v604) {
							bs604 |= 8;
						} else {
							bs604 &= -9;
						}
						break;
					case 5:
						if(v604) {
							bs604 |= 4;
						} else {
							bs604 &= -5;
						}
						break;
					case 6:
						if(v604) {
							bs604 |= 2;
						} else {
							bs604 &= -3;
						}
						break;
					case 7:
						if(v604) {
							bs604 |= 1;
						} else {
							bs604 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs604;
				var this606 = 0;
				var bs605 = this606;
				var l605 = "*   *".length;
				var _g1606 = 0;
				var _g706 = l605;
				while(_g1606 < _g706) {
					var i606 = _g1606++;
					var no605 = "*   *".charCodeAt(i606);
					if(no605 == null) {
						break;
					}
					var v605;
					switch(no605) {
					case 32:
						v605 = false;
						break;
					case 42:
						v605 = true;
						break;
					case 48:
						v605 = false;
						break;
					case 49:
						v605 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i606)));
					}
					switch(i606 - (l605 - 8)) {
					case 0:
						if(v605) {
							bs605 |= 128;
						} else {
							bs605 &= -129;
						}
						break;
					case 1:
						if(v605) {
							bs605 |= 64;
						} else {
							bs605 &= -65;
						}
						break;
					case 2:
						if(v605) {
							bs605 |= 32;
						} else {
							bs605 &= -33;
						}
						break;
					case 3:
						if(v605) {
							bs605 |= 16;
						} else {
							bs605 &= -17;
						}
						break;
					case 4:
						if(v605) {
							bs605 |= 8;
						} else {
							bs605 &= -9;
						}
						break;
					case 5:
						if(v605) {
							bs605 |= 4;
						} else {
							bs605 &= -5;
						}
						break;
					case 6:
						if(v605) {
							bs605 |= 2;
						} else {
							bs605 &= -3;
						}
						break;
					case 7:
						if(v605) {
							bs605 |= 1;
						} else {
							bs605 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs605;
				var this607 = 0;
				var bs606 = this607;
				var l606 = "*   *".length;
				var _g1607 = 0;
				var _g707 = l606;
				while(_g1607 < _g707) {
					var i607 = _g1607++;
					var no606 = "*   *".charCodeAt(i607);
					if(no606 == null) {
						break;
					}
					var v606;
					switch(no606) {
					case 32:
						v606 = false;
						break;
					case 42:
						v606 = true;
						break;
					case 48:
						v606 = false;
						break;
					case 49:
						v606 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i607)));
					}
					switch(i607 - (l606 - 8)) {
					case 0:
						if(v606) {
							bs606 |= 128;
						} else {
							bs606 &= -129;
						}
						break;
					case 1:
						if(v606) {
							bs606 |= 64;
						} else {
							bs606 &= -65;
						}
						break;
					case 2:
						if(v606) {
							bs606 |= 32;
						} else {
							bs606 &= -33;
						}
						break;
					case 3:
						if(v606) {
							bs606 |= 16;
						} else {
							bs606 &= -17;
						}
						break;
					case 4:
						if(v606) {
							bs606 |= 8;
						} else {
							bs606 &= -9;
						}
						break;
					case 5:
						if(v606) {
							bs606 |= 4;
						} else {
							bs606 &= -5;
						}
						break;
					case 6:
						if(v606) {
							bs606 |= 2;
						} else {
							bs606 &= -3;
						}
						break;
					case 7:
						if(v606) {
							bs606 |= 1;
						} else {
							bs606 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs606;
				var this608 = 0;
				var bs607 = this608;
				var l607 = " * * ".length;
				var _g1608 = 0;
				var _g708 = l607;
				while(_g1608 < _g708) {
					var i608 = _g1608++;
					var no607 = " * * ".charCodeAt(i608);
					if(no607 == null) {
						break;
					}
					var v607;
					switch(no607) {
					case 32:
						v607 = false;
						break;
					case 42:
						v607 = true;
						break;
					case 48:
						v607 = false;
						break;
					case 49:
						v607 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i608)));
					}
					switch(i608 - (l607 - 8)) {
					case 0:
						if(v607) {
							bs607 |= 128;
						} else {
							bs607 &= -129;
						}
						break;
					case 1:
						if(v607) {
							bs607 |= 64;
						} else {
							bs607 &= -65;
						}
						break;
					case 2:
						if(v607) {
							bs607 |= 32;
						} else {
							bs607 &= -33;
						}
						break;
					case 3:
						if(v607) {
							bs607 |= 16;
						} else {
							bs607 &= -17;
						}
						break;
					case 4:
						if(v607) {
							bs607 |= 8;
						} else {
							bs607 &= -9;
						}
						break;
					case 5:
						if(v607) {
							bs607 |= 4;
						} else {
							bs607 &= -5;
						}
						break;
					case 6:
						if(v607) {
							bs607 |= 2;
						} else {
							bs607 &= -3;
						}
						break;
					case 7:
						if(v607) {
							bs607 |= 1;
						} else {
							bs607 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs607;
				var this609 = 0;
				var bs608 = this609;
				var l608 = "  *  ".length;
				var _g1609 = 0;
				var _g709 = l608;
				while(_g1609 < _g709) {
					var i609 = _g1609++;
					var no608 = "  *  ".charCodeAt(i609);
					if(no608 == null) {
						break;
					}
					var v608;
					switch(no608) {
					case 32:
						v608 = false;
						break;
					case 42:
						v608 = true;
						break;
					case 48:
						v608 = false;
						break;
					case 49:
						v608 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i609)));
					}
					switch(i609 - (l608 - 8)) {
					case 0:
						if(v608) {
							bs608 |= 128;
						} else {
							bs608 &= -129;
						}
						break;
					case 1:
						if(v608) {
							bs608 |= 64;
						} else {
							bs608 &= -65;
						}
						break;
					case 2:
						if(v608) {
							bs608 |= 32;
						} else {
							bs608 &= -33;
						}
						break;
					case 3:
						if(v608) {
							bs608 |= 16;
						} else {
							bs608 &= -17;
						}
						break;
					case 4:
						if(v608) {
							bs608 |= 8;
						} else {
							bs608 &= -9;
						}
						break;
					case 5:
						if(v608) {
							bs608 |= 4;
						} else {
							bs608 &= -5;
						}
						break;
					case 6:
						if(v608) {
							bs608 |= 2;
						} else {
							bs608 &= -3;
						}
						break;
					case 7:
						if(v608) {
							bs608 |= 1;
						} else {
							bs608 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs608;
				break;
			case 119:
				var this610 = 0;
				var bs609 = this610;
				var l609 = "     ".length;
				var _g1610 = 0;
				var _g710 = l609;
				while(_g1610 < _g710) {
					var i610 = _g1610++;
					var no609 = "     ".charCodeAt(i610);
					if(no609 == null) {
						break;
					}
					var v609;
					switch(no609) {
					case 32:
						v609 = false;
						break;
					case 42:
						v609 = true;
						break;
					case 48:
						v609 = false;
						break;
					case 49:
						v609 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i610)));
					}
					switch(i610 - (l609 - 8)) {
					case 0:
						if(v609) {
							bs609 |= 128;
						} else {
							bs609 &= -129;
						}
						break;
					case 1:
						if(v609) {
							bs609 |= 64;
						} else {
							bs609 &= -65;
						}
						break;
					case 2:
						if(v609) {
							bs609 |= 32;
						} else {
							bs609 &= -33;
						}
						break;
					case 3:
						if(v609) {
							bs609 |= 16;
						} else {
							bs609 &= -17;
						}
						break;
					case 4:
						if(v609) {
							bs609 |= 8;
						} else {
							bs609 &= -9;
						}
						break;
					case 5:
						if(v609) {
							bs609 |= 4;
						} else {
							bs609 &= -5;
						}
						break;
					case 6:
						if(v609) {
							bs609 |= 2;
						} else {
							bs609 &= -3;
						}
						break;
					case 7:
						if(v609) {
							bs609 |= 1;
						} else {
							bs609 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs609;
				var this611 = 0;
				var bs610 = this611;
				var l610 = "     ".length;
				var _g1611 = 0;
				var _g711 = l610;
				while(_g1611 < _g711) {
					var i611 = _g1611++;
					var no610 = "     ".charCodeAt(i611);
					if(no610 == null) {
						break;
					}
					var v610;
					switch(no610) {
					case 32:
						v610 = false;
						break;
					case 42:
						v610 = true;
						break;
					case 48:
						v610 = false;
						break;
					case 49:
						v610 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i611)));
					}
					switch(i611 - (l610 - 8)) {
					case 0:
						if(v610) {
							bs610 |= 128;
						} else {
							bs610 &= -129;
						}
						break;
					case 1:
						if(v610) {
							bs610 |= 64;
						} else {
							bs610 &= -65;
						}
						break;
					case 2:
						if(v610) {
							bs610 |= 32;
						} else {
							bs610 &= -33;
						}
						break;
					case 3:
						if(v610) {
							bs610 |= 16;
						} else {
							bs610 &= -17;
						}
						break;
					case 4:
						if(v610) {
							bs610 |= 8;
						} else {
							bs610 &= -9;
						}
						break;
					case 5:
						if(v610) {
							bs610 |= 4;
						} else {
							bs610 &= -5;
						}
						break;
					case 6:
						if(v610) {
							bs610 |= 2;
						} else {
							bs610 &= -3;
						}
						break;
					case 7:
						if(v610) {
							bs610 |= 1;
						} else {
							bs610 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs610;
				var this612 = 0;
				var bs611 = this612;
				var l611 = "*   *".length;
				var _g1612 = 0;
				var _g712 = l611;
				while(_g1612 < _g712) {
					var i612 = _g1612++;
					var no611 = "*   *".charCodeAt(i612);
					if(no611 == null) {
						break;
					}
					var v611;
					switch(no611) {
					case 32:
						v611 = false;
						break;
					case 42:
						v611 = true;
						break;
					case 48:
						v611 = false;
						break;
					case 49:
						v611 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i612)));
					}
					switch(i612 - (l611 - 8)) {
					case 0:
						if(v611) {
							bs611 |= 128;
						} else {
							bs611 &= -129;
						}
						break;
					case 1:
						if(v611) {
							bs611 |= 64;
						} else {
							bs611 &= -65;
						}
						break;
					case 2:
						if(v611) {
							bs611 |= 32;
						} else {
							bs611 &= -33;
						}
						break;
					case 3:
						if(v611) {
							bs611 |= 16;
						} else {
							bs611 &= -17;
						}
						break;
					case 4:
						if(v611) {
							bs611 |= 8;
						} else {
							bs611 &= -9;
						}
						break;
					case 5:
						if(v611) {
							bs611 |= 4;
						} else {
							bs611 &= -5;
						}
						break;
					case 6:
						if(v611) {
							bs611 |= 2;
						} else {
							bs611 &= -3;
						}
						break;
					case 7:
						if(v611) {
							bs611 |= 1;
						} else {
							bs611 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs611;
				var this613 = 0;
				var bs612 = this613;
				var l612 = "*   *".length;
				var _g1613 = 0;
				var _g713 = l612;
				while(_g1613 < _g713) {
					var i613 = _g1613++;
					var no612 = "*   *".charCodeAt(i613);
					if(no612 == null) {
						break;
					}
					var v612;
					switch(no612) {
					case 32:
						v612 = false;
						break;
					case 42:
						v612 = true;
						break;
					case 48:
						v612 = false;
						break;
					case 49:
						v612 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i613)));
					}
					switch(i613 - (l612 - 8)) {
					case 0:
						if(v612) {
							bs612 |= 128;
						} else {
							bs612 &= -129;
						}
						break;
					case 1:
						if(v612) {
							bs612 |= 64;
						} else {
							bs612 &= -65;
						}
						break;
					case 2:
						if(v612) {
							bs612 |= 32;
						} else {
							bs612 &= -33;
						}
						break;
					case 3:
						if(v612) {
							bs612 |= 16;
						} else {
							bs612 &= -17;
						}
						break;
					case 4:
						if(v612) {
							bs612 |= 8;
						} else {
							bs612 &= -9;
						}
						break;
					case 5:
						if(v612) {
							bs612 |= 4;
						} else {
							bs612 &= -5;
						}
						break;
					case 6:
						if(v612) {
							bs612 |= 2;
						} else {
							bs612 &= -3;
						}
						break;
					case 7:
						if(v612) {
							bs612 |= 1;
						} else {
							bs612 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs612;
				var this614 = 0;
				var bs613 = this614;
				var l613 = "* * *".length;
				var _g1614 = 0;
				var _g714 = l613;
				while(_g1614 < _g714) {
					var i614 = _g1614++;
					var no613 = "* * *".charCodeAt(i614);
					if(no613 == null) {
						break;
					}
					var v613;
					switch(no613) {
					case 32:
						v613 = false;
						break;
					case 42:
						v613 = true;
						break;
					case 48:
						v613 = false;
						break;
					case 49:
						v613 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i614)));
					}
					switch(i614 - (l613 - 8)) {
					case 0:
						if(v613) {
							bs613 |= 128;
						} else {
							bs613 &= -129;
						}
						break;
					case 1:
						if(v613) {
							bs613 |= 64;
						} else {
							bs613 &= -65;
						}
						break;
					case 2:
						if(v613) {
							bs613 |= 32;
						} else {
							bs613 &= -33;
						}
						break;
					case 3:
						if(v613) {
							bs613 |= 16;
						} else {
							bs613 &= -17;
						}
						break;
					case 4:
						if(v613) {
							bs613 |= 8;
						} else {
							bs613 &= -9;
						}
						break;
					case 5:
						if(v613) {
							bs613 |= 4;
						} else {
							bs613 &= -5;
						}
						break;
					case 6:
						if(v613) {
							bs613 |= 2;
						} else {
							bs613 &= -3;
						}
						break;
					case 7:
						if(v613) {
							bs613 |= 1;
						} else {
							bs613 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs613;
				var this615 = 0;
				var bs614 = this615;
				var l614 = "* * *".length;
				var _g1615 = 0;
				var _g715 = l614;
				while(_g1615 < _g715) {
					var i615 = _g1615++;
					var no614 = "* * *".charCodeAt(i615);
					if(no614 == null) {
						break;
					}
					var v614;
					switch(no614) {
					case 32:
						v614 = false;
						break;
					case 42:
						v614 = true;
						break;
					case 48:
						v614 = false;
						break;
					case 49:
						v614 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i615)));
					}
					switch(i615 - (l614 - 8)) {
					case 0:
						if(v614) {
							bs614 |= 128;
						} else {
							bs614 &= -129;
						}
						break;
					case 1:
						if(v614) {
							bs614 |= 64;
						} else {
							bs614 &= -65;
						}
						break;
					case 2:
						if(v614) {
							bs614 |= 32;
						} else {
							bs614 &= -33;
						}
						break;
					case 3:
						if(v614) {
							bs614 |= 16;
						} else {
							bs614 &= -17;
						}
						break;
					case 4:
						if(v614) {
							bs614 |= 8;
						} else {
							bs614 &= -9;
						}
						break;
					case 5:
						if(v614) {
							bs614 |= 4;
						} else {
							bs614 &= -5;
						}
						break;
					case 6:
						if(v614) {
							bs614 |= 2;
						} else {
							bs614 &= -3;
						}
						break;
					case 7:
						if(v614) {
							bs614 |= 1;
						} else {
							bs614 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs614;
				var this616 = 0;
				var bs615 = this616;
				var l615 = " * * ".length;
				var _g1616 = 0;
				var _g716 = l615;
				while(_g1616 < _g716) {
					var i616 = _g1616++;
					var no615 = " * * ".charCodeAt(i616);
					if(no615 == null) {
						break;
					}
					var v615;
					switch(no615) {
					case 32:
						v615 = false;
						break;
					case 42:
						v615 = true;
						break;
					case 48:
						v615 = false;
						break;
					case 49:
						v615 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i616)));
					}
					switch(i616 - (l615 - 8)) {
					case 0:
						if(v615) {
							bs615 |= 128;
						} else {
							bs615 &= -129;
						}
						break;
					case 1:
						if(v615) {
							bs615 |= 64;
						} else {
							bs615 &= -65;
						}
						break;
					case 2:
						if(v615) {
							bs615 |= 32;
						} else {
							bs615 &= -33;
						}
						break;
					case 3:
						if(v615) {
							bs615 |= 16;
						} else {
							bs615 &= -17;
						}
						break;
					case 4:
						if(v615) {
							bs615 |= 8;
						} else {
							bs615 &= -9;
						}
						break;
					case 5:
						if(v615) {
							bs615 |= 4;
						} else {
							bs615 &= -5;
						}
						break;
					case 6:
						if(v615) {
							bs615 |= 2;
						} else {
							bs615 &= -3;
						}
						break;
					case 7:
						if(v615) {
							bs615 |= 1;
						} else {
							bs615 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs615;
				break;
			case 120:
				var this617 = 0;
				var bs616 = this617;
				var l616 = "     ".length;
				var _g1617 = 0;
				var _g717 = l616;
				while(_g1617 < _g717) {
					var i617 = _g1617++;
					var no616 = "     ".charCodeAt(i617);
					if(no616 == null) {
						break;
					}
					var v616;
					switch(no616) {
					case 32:
						v616 = false;
						break;
					case 42:
						v616 = true;
						break;
					case 48:
						v616 = false;
						break;
					case 49:
						v616 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i617)));
					}
					switch(i617 - (l616 - 8)) {
					case 0:
						if(v616) {
							bs616 |= 128;
						} else {
							bs616 &= -129;
						}
						break;
					case 1:
						if(v616) {
							bs616 |= 64;
						} else {
							bs616 &= -65;
						}
						break;
					case 2:
						if(v616) {
							bs616 |= 32;
						} else {
							bs616 &= -33;
						}
						break;
					case 3:
						if(v616) {
							bs616 |= 16;
						} else {
							bs616 &= -17;
						}
						break;
					case 4:
						if(v616) {
							bs616 |= 8;
						} else {
							bs616 &= -9;
						}
						break;
					case 5:
						if(v616) {
							bs616 |= 4;
						} else {
							bs616 &= -5;
						}
						break;
					case 6:
						if(v616) {
							bs616 |= 2;
						} else {
							bs616 &= -3;
						}
						break;
					case 7:
						if(v616) {
							bs616 |= 1;
						} else {
							bs616 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs616;
				var this618 = 0;
				var bs617 = this618;
				var l617 = "     ".length;
				var _g1618 = 0;
				var _g718 = l617;
				while(_g1618 < _g718) {
					var i618 = _g1618++;
					var no617 = "     ".charCodeAt(i618);
					if(no617 == null) {
						break;
					}
					var v617;
					switch(no617) {
					case 32:
						v617 = false;
						break;
					case 42:
						v617 = true;
						break;
					case 48:
						v617 = false;
						break;
					case 49:
						v617 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i618)));
					}
					switch(i618 - (l617 - 8)) {
					case 0:
						if(v617) {
							bs617 |= 128;
						} else {
							bs617 &= -129;
						}
						break;
					case 1:
						if(v617) {
							bs617 |= 64;
						} else {
							bs617 &= -65;
						}
						break;
					case 2:
						if(v617) {
							bs617 |= 32;
						} else {
							bs617 &= -33;
						}
						break;
					case 3:
						if(v617) {
							bs617 |= 16;
						} else {
							bs617 &= -17;
						}
						break;
					case 4:
						if(v617) {
							bs617 |= 8;
						} else {
							bs617 &= -9;
						}
						break;
					case 5:
						if(v617) {
							bs617 |= 4;
						} else {
							bs617 &= -5;
						}
						break;
					case 6:
						if(v617) {
							bs617 |= 2;
						} else {
							bs617 &= -3;
						}
						break;
					case 7:
						if(v617) {
							bs617 |= 1;
						} else {
							bs617 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs617;
				var this619 = 0;
				var bs618 = this619;
				var l618 = "*   *".length;
				var _g1619 = 0;
				var _g719 = l618;
				while(_g1619 < _g719) {
					var i619 = _g1619++;
					var no618 = "*   *".charCodeAt(i619);
					if(no618 == null) {
						break;
					}
					var v618;
					switch(no618) {
					case 32:
						v618 = false;
						break;
					case 42:
						v618 = true;
						break;
					case 48:
						v618 = false;
						break;
					case 49:
						v618 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i619)));
					}
					switch(i619 - (l618 - 8)) {
					case 0:
						if(v618) {
							bs618 |= 128;
						} else {
							bs618 &= -129;
						}
						break;
					case 1:
						if(v618) {
							bs618 |= 64;
						} else {
							bs618 &= -65;
						}
						break;
					case 2:
						if(v618) {
							bs618 |= 32;
						} else {
							bs618 &= -33;
						}
						break;
					case 3:
						if(v618) {
							bs618 |= 16;
						} else {
							bs618 &= -17;
						}
						break;
					case 4:
						if(v618) {
							bs618 |= 8;
						} else {
							bs618 &= -9;
						}
						break;
					case 5:
						if(v618) {
							bs618 |= 4;
						} else {
							bs618 &= -5;
						}
						break;
					case 6:
						if(v618) {
							bs618 |= 2;
						} else {
							bs618 &= -3;
						}
						break;
					case 7:
						if(v618) {
							bs618 |= 1;
						} else {
							bs618 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs618;
				var this620 = 0;
				var bs619 = this620;
				var l619 = " * * ".length;
				var _g1620 = 0;
				var _g720 = l619;
				while(_g1620 < _g720) {
					var i620 = _g1620++;
					var no619 = " * * ".charCodeAt(i620);
					if(no619 == null) {
						break;
					}
					var v619;
					switch(no619) {
					case 32:
						v619 = false;
						break;
					case 42:
						v619 = true;
						break;
					case 48:
						v619 = false;
						break;
					case 49:
						v619 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i620)));
					}
					switch(i620 - (l619 - 8)) {
					case 0:
						if(v619) {
							bs619 |= 128;
						} else {
							bs619 &= -129;
						}
						break;
					case 1:
						if(v619) {
							bs619 |= 64;
						} else {
							bs619 &= -65;
						}
						break;
					case 2:
						if(v619) {
							bs619 |= 32;
						} else {
							bs619 &= -33;
						}
						break;
					case 3:
						if(v619) {
							bs619 |= 16;
						} else {
							bs619 &= -17;
						}
						break;
					case 4:
						if(v619) {
							bs619 |= 8;
						} else {
							bs619 &= -9;
						}
						break;
					case 5:
						if(v619) {
							bs619 |= 4;
						} else {
							bs619 &= -5;
						}
						break;
					case 6:
						if(v619) {
							bs619 |= 2;
						} else {
							bs619 &= -3;
						}
						break;
					case 7:
						if(v619) {
							bs619 |= 1;
						} else {
							bs619 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs619;
				var this621 = 0;
				var bs620 = this621;
				var l620 = "  *  ".length;
				var _g1621 = 0;
				var _g721 = l620;
				while(_g1621 < _g721) {
					var i621 = _g1621++;
					var no620 = "  *  ".charCodeAt(i621);
					if(no620 == null) {
						break;
					}
					var v620;
					switch(no620) {
					case 32:
						v620 = false;
						break;
					case 42:
						v620 = true;
						break;
					case 48:
						v620 = false;
						break;
					case 49:
						v620 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i621)));
					}
					switch(i621 - (l620 - 8)) {
					case 0:
						if(v620) {
							bs620 |= 128;
						} else {
							bs620 &= -129;
						}
						break;
					case 1:
						if(v620) {
							bs620 |= 64;
						} else {
							bs620 &= -65;
						}
						break;
					case 2:
						if(v620) {
							bs620 |= 32;
						} else {
							bs620 &= -33;
						}
						break;
					case 3:
						if(v620) {
							bs620 |= 16;
						} else {
							bs620 &= -17;
						}
						break;
					case 4:
						if(v620) {
							bs620 |= 8;
						} else {
							bs620 &= -9;
						}
						break;
					case 5:
						if(v620) {
							bs620 |= 4;
						} else {
							bs620 &= -5;
						}
						break;
					case 6:
						if(v620) {
							bs620 |= 2;
						} else {
							bs620 &= -3;
						}
						break;
					case 7:
						if(v620) {
							bs620 |= 1;
						} else {
							bs620 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs620;
				var this622 = 0;
				var bs621 = this622;
				var l621 = " * * ".length;
				var _g1622 = 0;
				var _g722 = l621;
				while(_g1622 < _g722) {
					var i622 = _g1622++;
					var no621 = " * * ".charCodeAt(i622);
					if(no621 == null) {
						break;
					}
					var v621;
					switch(no621) {
					case 32:
						v621 = false;
						break;
					case 42:
						v621 = true;
						break;
					case 48:
						v621 = false;
						break;
					case 49:
						v621 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i622)));
					}
					switch(i622 - (l621 - 8)) {
					case 0:
						if(v621) {
							bs621 |= 128;
						} else {
							bs621 &= -129;
						}
						break;
					case 1:
						if(v621) {
							bs621 |= 64;
						} else {
							bs621 &= -65;
						}
						break;
					case 2:
						if(v621) {
							bs621 |= 32;
						} else {
							bs621 &= -33;
						}
						break;
					case 3:
						if(v621) {
							bs621 |= 16;
						} else {
							bs621 &= -17;
						}
						break;
					case 4:
						if(v621) {
							bs621 |= 8;
						} else {
							bs621 &= -9;
						}
						break;
					case 5:
						if(v621) {
							bs621 |= 4;
						} else {
							bs621 &= -5;
						}
						break;
					case 6:
						if(v621) {
							bs621 |= 2;
						} else {
							bs621 &= -3;
						}
						break;
					case 7:
						if(v621) {
							bs621 |= 1;
						} else {
							bs621 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs621;
				var this623 = 0;
				var bs622 = this623;
				var l622 = "*   *".length;
				var _g1623 = 0;
				var _g723 = l622;
				while(_g1623 < _g723) {
					var i623 = _g1623++;
					var no622 = "*   *".charCodeAt(i623);
					if(no622 == null) {
						break;
					}
					var v622;
					switch(no622) {
					case 32:
						v622 = false;
						break;
					case 42:
						v622 = true;
						break;
					case 48:
						v622 = false;
						break;
					case 49:
						v622 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i623)));
					}
					switch(i623 - (l622 - 8)) {
					case 0:
						if(v622) {
							bs622 |= 128;
						} else {
							bs622 &= -129;
						}
						break;
					case 1:
						if(v622) {
							bs622 |= 64;
						} else {
							bs622 &= -65;
						}
						break;
					case 2:
						if(v622) {
							bs622 |= 32;
						} else {
							bs622 &= -33;
						}
						break;
					case 3:
						if(v622) {
							bs622 |= 16;
						} else {
							bs622 &= -17;
						}
						break;
					case 4:
						if(v622) {
							bs622 |= 8;
						} else {
							bs622 &= -9;
						}
						break;
					case 5:
						if(v622) {
							bs622 |= 4;
						} else {
							bs622 &= -5;
						}
						break;
					case 6:
						if(v622) {
							bs622 |= 2;
						} else {
							bs622 &= -3;
						}
						break;
					case 7:
						if(v622) {
							bs622 |= 1;
						} else {
							bs622 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs622;
				break;
			case 121:
				var this624 = 0;
				var bs623 = this624;
				var l623 = "     ".length;
				var _g1624 = 0;
				var _g724 = l623;
				while(_g1624 < _g724) {
					var i624 = _g1624++;
					var no623 = "     ".charCodeAt(i624);
					if(no623 == null) {
						break;
					}
					var v623;
					switch(no623) {
					case 32:
						v623 = false;
						break;
					case 42:
						v623 = true;
						break;
					case 48:
						v623 = false;
						break;
					case 49:
						v623 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i624)));
					}
					switch(i624 - (l623 - 8)) {
					case 0:
						if(v623) {
							bs623 |= 128;
						} else {
							bs623 &= -129;
						}
						break;
					case 1:
						if(v623) {
							bs623 |= 64;
						} else {
							bs623 &= -65;
						}
						break;
					case 2:
						if(v623) {
							bs623 |= 32;
						} else {
							bs623 &= -33;
						}
						break;
					case 3:
						if(v623) {
							bs623 |= 16;
						} else {
							bs623 &= -17;
						}
						break;
					case 4:
						if(v623) {
							bs623 |= 8;
						} else {
							bs623 &= -9;
						}
						break;
					case 5:
						if(v623) {
							bs623 |= 4;
						} else {
							bs623 &= -5;
						}
						break;
					case 6:
						if(v623) {
							bs623 |= 2;
						} else {
							bs623 &= -3;
						}
						break;
					case 7:
						if(v623) {
							bs623 |= 1;
						} else {
							bs623 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs623;
				var this625 = 0;
				var bs624 = this625;
				var l624 = "     ".length;
				var _g1625 = 0;
				var _g725 = l624;
				while(_g1625 < _g725) {
					var i625 = _g1625++;
					var no624 = "     ".charCodeAt(i625);
					if(no624 == null) {
						break;
					}
					var v624;
					switch(no624) {
					case 32:
						v624 = false;
						break;
					case 42:
						v624 = true;
						break;
					case 48:
						v624 = false;
						break;
					case 49:
						v624 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i625)));
					}
					switch(i625 - (l624 - 8)) {
					case 0:
						if(v624) {
							bs624 |= 128;
						} else {
							bs624 &= -129;
						}
						break;
					case 1:
						if(v624) {
							bs624 |= 64;
						} else {
							bs624 &= -65;
						}
						break;
					case 2:
						if(v624) {
							bs624 |= 32;
						} else {
							bs624 &= -33;
						}
						break;
					case 3:
						if(v624) {
							bs624 |= 16;
						} else {
							bs624 &= -17;
						}
						break;
					case 4:
						if(v624) {
							bs624 |= 8;
						} else {
							bs624 &= -9;
						}
						break;
					case 5:
						if(v624) {
							bs624 |= 4;
						} else {
							bs624 &= -5;
						}
						break;
					case 6:
						if(v624) {
							bs624 |= 2;
						} else {
							bs624 &= -3;
						}
						break;
					case 7:
						if(v624) {
							bs624 |= 1;
						} else {
							bs624 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs624;
				var this626 = 0;
				var bs625 = this626;
				var l625 = "*   *".length;
				var _g1626 = 0;
				var _g726 = l625;
				while(_g1626 < _g726) {
					var i626 = _g1626++;
					var no625 = "*   *".charCodeAt(i626);
					if(no625 == null) {
						break;
					}
					var v625;
					switch(no625) {
					case 32:
						v625 = false;
						break;
					case 42:
						v625 = true;
						break;
					case 48:
						v625 = false;
						break;
					case 49:
						v625 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i626)));
					}
					switch(i626 - (l625 - 8)) {
					case 0:
						if(v625) {
							bs625 |= 128;
						} else {
							bs625 &= -129;
						}
						break;
					case 1:
						if(v625) {
							bs625 |= 64;
						} else {
							bs625 &= -65;
						}
						break;
					case 2:
						if(v625) {
							bs625 |= 32;
						} else {
							bs625 &= -33;
						}
						break;
					case 3:
						if(v625) {
							bs625 |= 16;
						} else {
							bs625 &= -17;
						}
						break;
					case 4:
						if(v625) {
							bs625 |= 8;
						} else {
							bs625 &= -9;
						}
						break;
					case 5:
						if(v625) {
							bs625 |= 4;
						} else {
							bs625 &= -5;
						}
						break;
					case 6:
						if(v625) {
							bs625 |= 2;
						} else {
							bs625 &= -3;
						}
						break;
					case 7:
						if(v625) {
							bs625 |= 1;
						} else {
							bs625 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs625;
				var this627 = 0;
				var bs626 = this627;
				var l626 = "*   *".length;
				var _g1627 = 0;
				var _g727 = l626;
				while(_g1627 < _g727) {
					var i627 = _g1627++;
					var no626 = "*   *".charCodeAt(i627);
					if(no626 == null) {
						break;
					}
					var v626;
					switch(no626) {
					case 32:
						v626 = false;
						break;
					case 42:
						v626 = true;
						break;
					case 48:
						v626 = false;
						break;
					case 49:
						v626 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i627)));
					}
					switch(i627 - (l626 - 8)) {
					case 0:
						if(v626) {
							bs626 |= 128;
						} else {
							bs626 &= -129;
						}
						break;
					case 1:
						if(v626) {
							bs626 |= 64;
						} else {
							bs626 &= -65;
						}
						break;
					case 2:
						if(v626) {
							bs626 |= 32;
						} else {
							bs626 &= -33;
						}
						break;
					case 3:
						if(v626) {
							bs626 |= 16;
						} else {
							bs626 &= -17;
						}
						break;
					case 4:
						if(v626) {
							bs626 |= 8;
						} else {
							bs626 &= -9;
						}
						break;
					case 5:
						if(v626) {
							bs626 |= 4;
						} else {
							bs626 &= -5;
						}
						break;
					case 6:
						if(v626) {
							bs626 |= 2;
						} else {
							bs626 &= -3;
						}
						break;
					case 7:
						if(v626) {
							bs626 |= 1;
						} else {
							bs626 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs626;
				var this628 = 0;
				var bs627 = this628;
				var l627 = " ****".length;
				var _g1628 = 0;
				var _g728 = l627;
				while(_g1628 < _g728) {
					var i628 = _g1628++;
					var no627 = " ****".charCodeAt(i628);
					if(no627 == null) {
						break;
					}
					var v627;
					switch(no627) {
					case 32:
						v627 = false;
						break;
					case 42:
						v627 = true;
						break;
					case 48:
						v627 = false;
						break;
					case 49:
						v627 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i628)));
					}
					switch(i628 - (l627 - 8)) {
					case 0:
						if(v627) {
							bs627 |= 128;
						} else {
							bs627 &= -129;
						}
						break;
					case 1:
						if(v627) {
							bs627 |= 64;
						} else {
							bs627 &= -65;
						}
						break;
					case 2:
						if(v627) {
							bs627 |= 32;
						} else {
							bs627 &= -33;
						}
						break;
					case 3:
						if(v627) {
							bs627 |= 16;
						} else {
							bs627 &= -17;
						}
						break;
					case 4:
						if(v627) {
							bs627 |= 8;
						} else {
							bs627 &= -9;
						}
						break;
					case 5:
						if(v627) {
							bs627 |= 4;
						} else {
							bs627 &= -5;
						}
						break;
					case 6:
						if(v627) {
							bs627 |= 2;
						} else {
							bs627 &= -3;
						}
						break;
					case 7:
						if(v627) {
							bs627 |= 1;
						} else {
							bs627 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs627;
				var this629 = 0;
				var bs628 = this629;
				var l628 = "    *".length;
				var _g1629 = 0;
				var _g729 = l628;
				while(_g1629 < _g729) {
					var i629 = _g1629++;
					var no628 = "    *".charCodeAt(i629);
					if(no628 == null) {
						break;
					}
					var v628;
					switch(no628) {
					case 32:
						v628 = false;
						break;
					case 42:
						v628 = true;
						break;
					case 48:
						v628 = false;
						break;
					case 49:
						v628 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i629)));
					}
					switch(i629 - (l628 - 8)) {
					case 0:
						if(v628) {
							bs628 |= 128;
						} else {
							bs628 &= -129;
						}
						break;
					case 1:
						if(v628) {
							bs628 |= 64;
						} else {
							bs628 &= -65;
						}
						break;
					case 2:
						if(v628) {
							bs628 |= 32;
						} else {
							bs628 &= -33;
						}
						break;
					case 3:
						if(v628) {
							bs628 |= 16;
						} else {
							bs628 &= -17;
						}
						break;
					case 4:
						if(v628) {
							bs628 |= 8;
						} else {
							bs628 &= -9;
						}
						break;
					case 5:
						if(v628) {
							bs628 |= 4;
						} else {
							bs628 &= -5;
						}
						break;
					case 6:
						if(v628) {
							bs628 |= 2;
						} else {
							bs628 &= -3;
						}
						break;
					case 7:
						if(v628) {
							bs628 |= 1;
						} else {
							bs628 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs628;
				var this630 = 0;
				var bs629 = this630;
				var l629 = " *** ".length;
				var _g1630 = 0;
				var _g730 = l629;
				while(_g1630 < _g730) {
					var i630 = _g1630++;
					var no629 = " *** ".charCodeAt(i630);
					if(no629 == null) {
						break;
					}
					var v629;
					switch(no629) {
					case 32:
						v629 = false;
						break;
					case 42:
						v629 = true;
						break;
					case 48:
						v629 = false;
						break;
					case 49:
						v629 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i630)));
					}
					switch(i630 - (l629 - 8)) {
					case 0:
						if(v629) {
							bs629 |= 128;
						} else {
							bs629 &= -129;
						}
						break;
					case 1:
						if(v629) {
							bs629 |= 64;
						} else {
							bs629 &= -65;
						}
						break;
					case 2:
						if(v629) {
							bs629 |= 32;
						} else {
							bs629 &= -33;
						}
						break;
					case 3:
						if(v629) {
							bs629 |= 16;
						} else {
							bs629 &= -17;
						}
						break;
					case 4:
						if(v629) {
							bs629 |= 8;
						} else {
							bs629 &= -9;
						}
						break;
					case 5:
						if(v629) {
							bs629 |= 4;
						} else {
							bs629 &= -5;
						}
						break;
					case 6:
						if(v629) {
							bs629 |= 2;
						} else {
							bs629 &= -3;
						}
						break;
					case 7:
						if(v629) {
							bs629 |= 1;
						} else {
							bs629 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs629;
				break;
			case 122:
				var this631 = 0;
				var bs630 = this631;
				var l630 = "     ".length;
				var _g1631 = 0;
				var _g731 = l630;
				while(_g1631 < _g731) {
					var i631 = _g1631++;
					var no630 = "     ".charCodeAt(i631);
					if(no630 == null) {
						break;
					}
					var v630;
					switch(no630) {
					case 32:
						v630 = false;
						break;
					case 42:
						v630 = true;
						break;
					case 48:
						v630 = false;
						break;
					case 49:
						v630 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i631)));
					}
					switch(i631 - (l630 - 8)) {
					case 0:
						if(v630) {
							bs630 |= 128;
						} else {
							bs630 &= -129;
						}
						break;
					case 1:
						if(v630) {
							bs630 |= 64;
						} else {
							bs630 &= -65;
						}
						break;
					case 2:
						if(v630) {
							bs630 |= 32;
						} else {
							bs630 &= -33;
						}
						break;
					case 3:
						if(v630) {
							bs630 |= 16;
						} else {
							bs630 &= -17;
						}
						break;
					case 4:
						if(v630) {
							bs630 |= 8;
						} else {
							bs630 &= -9;
						}
						break;
					case 5:
						if(v630) {
							bs630 |= 4;
						} else {
							bs630 &= -5;
						}
						break;
					case 6:
						if(v630) {
							bs630 |= 2;
						} else {
							bs630 &= -3;
						}
						break;
					case 7:
						if(v630) {
							bs630 |= 1;
						} else {
							bs630 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs630;
				var this632 = 0;
				var bs631 = this632;
				var l631 = "     ".length;
				var _g1632 = 0;
				var _g732 = l631;
				while(_g1632 < _g732) {
					var i632 = _g1632++;
					var no631 = "     ".charCodeAt(i632);
					if(no631 == null) {
						break;
					}
					var v631;
					switch(no631) {
					case 32:
						v631 = false;
						break;
					case 42:
						v631 = true;
						break;
					case 48:
						v631 = false;
						break;
					case 49:
						v631 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i632)));
					}
					switch(i632 - (l631 - 8)) {
					case 0:
						if(v631) {
							bs631 |= 128;
						} else {
							bs631 &= -129;
						}
						break;
					case 1:
						if(v631) {
							bs631 |= 64;
						} else {
							bs631 &= -65;
						}
						break;
					case 2:
						if(v631) {
							bs631 |= 32;
						} else {
							bs631 &= -33;
						}
						break;
					case 3:
						if(v631) {
							bs631 |= 16;
						} else {
							bs631 &= -17;
						}
						break;
					case 4:
						if(v631) {
							bs631 |= 8;
						} else {
							bs631 &= -9;
						}
						break;
					case 5:
						if(v631) {
							bs631 |= 4;
						} else {
							bs631 &= -5;
						}
						break;
					case 6:
						if(v631) {
							bs631 |= 2;
						} else {
							bs631 &= -3;
						}
						break;
					case 7:
						if(v631) {
							bs631 |= 1;
						} else {
							bs631 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs631;
				var this633 = 0;
				var bs632 = this633;
				var l632 = "*****".length;
				var _g1633 = 0;
				var _g733 = l632;
				while(_g1633 < _g733) {
					var i633 = _g1633++;
					var no632 = "*****".charCodeAt(i633);
					if(no632 == null) {
						break;
					}
					var v632;
					switch(no632) {
					case 32:
						v632 = false;
						break;
					case 42:
						v632 = true;
						break;
					case 48:
						v632 = false;
						break;
					case 49:
						v632 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i633)));
					}
					switch(i633 - (l632 - 8)) {
					case 0:
						if(v632) {
							bs632 |= 128;
						} else {
							bs632 &= -129;
						}
						break;
					case 1:
						if(v632) {
							bs632 |= 64;
						} else {
							bs632 &= -65;
						}
						break;
					case 2:
						if(v632) {
							bs632 |= 32;
						} else {
							bs632 &= -33;
						}
						break;
					case 3:
						if(v632) {
							bs632 |= 16;
						} else {
							bs632 &= -17;
						}
						break;
					case 4:
						if(v632) {
							bs632 |= 8;
						} else {
							bs632 &= -9;
						}
						break;
					case 5:
						if(v632) {
							bs632 |= 4;
						} else {
							bs632 &= -5;
						}
						break;
					case 6:
						if(v632) {
							bs632 |= 2;
						} else {
							bs632 &= -3;
						}
						break;
					case 7:
						if(v632) {
							bs632 |= 1;
						} else {
							bs632 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs632;
				var this634 = 0;
				var bs633 = this634;
				var l633 = "   * ".length;
				var _g1634 = 0;
				var _g734 = l633;
				while(_g1634 < _g734) {
					var i634 = _g1634++;
					var no633 = "   * ".charCodeAt(i634);
					if(no633 == null) {
						break;
					}
					var v633;
					switch(no633) {
					case 32:
						v633 = false;
						break;
					case 42:
						v633 = true;
						break;
					case 48:
						v633 = false;
						break;
					case 49:
						v633 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i634)));
					}
					switch(i634 - (l633 - 8)) {
					case 0:
						if(v633) {
							bs633 |= 128;
						} else {
							bs633 &= -129;
						}
						break;
					case 1:
						if(v633) {
							bs633 |= 64;
						} else {
							bs633 &= -65;
						}
						break;
					case 2:
						if(v633) {
							bs633 |= 32;
						} else {
							bs633 &= -33;
						}
						break;
					case 3:
						if(v633) {
							bs633 |= 16;
						} else {
							bs633 &= -17;
						}
						break;
					case 4:
						if(v633) {
							bs633 |= 8;
						} else {
							bs633 &= -9;
						}
						break;
					case 5:
						if(v633) {
							bs633 |= 4;
						} else {
							bs633 &= -5;
						}
						break;
					case 6:
						if(v633) {
							bs633 |= 2;
						} else {
							bs633 &= -3;
						}
						break;
					case 7:
						if(v633) {
							bs633 |= 1;
						} else {
							bs633 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs633;
				var this635 = 0;
				var bs634 = this635;
				var l634 = "  *  ".length;
				var _g1635 = 0;
				var _g735 = l634;
				while(_g1635 < _g735) {
					var i635 = _g1635++;
					var no634 = "  *  ".charCodeAt(i635);
					if(no634 == null) {
						break;
					}
					var v634;
					switch(no634) {
					case 32:
						v634 = false;
						break;
					case 42:
						v634 = true;
						break;
					case 48:
						v634 = false;
						break;
					case 49:
						v634 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i635)));
					}
					switch(i635 - (l634 - 8)) {
					case 0:
						if(v634) {
							bs634 |= 128;
						} else {
							bs634 &= -129;
						}
						break;
					case 1:
						if(v634) {
							bs634 |= 64;
						} else {
							bs634 &= -65;
						}
						break;
					case 2:
						if(v634) {
							bs634 |= 32;
						} else {
							bs634 &= -33;
						}
						break;
					case 3:
						if(v634) {
							bs634 |= 16;
						} else {
							bs634 &= -17;
						}
						break;
					case 4:
						if(v634) {
							bs634 |= 8;
						} else {
							bs634 &= -9;
						}
						break;
					case 5:
						if(v634) {
							bs634 |= 4;
						} else {
							bs634 &= -5;
						}
						break;
					case 6:
						if(v634) {
							bs634 |= 2;
						} else {
							bs634 &= -3;
						}
						break;
					case 7:
						if(v634) {
							bs634 |= 1;
						} else {
							bs634 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs634;
				var this636 = 0;
				var bs635 = this636;
				var l635 = " *   ".length;
				var _g1636 = 0;
				var _g736 = l635;
				while(_g1636 < _g736) {
					var i636 = _g1636++;
					var no635 = " *   ".charCodeAt(i636);
					if(no635 == null) {
						break;
					}
					var v635;
					switch(no635) {
					case 32:
						v635 = false;
						break;
					case 42:
						v635 = true;
						break;
					case 48:
						v635 = false;
						break;
					case 49:
						v635 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i636)));
					}
					switch(i636 - (l635 - 8)) {
					case 0:
						if(v635) {
							bs635 |= 128;
						} else {
							bs635 &= -129;
						}
						break;
					case 1:
						if(v635) {
							bs635 |= 64;
						} else {
							bs635 &= -65;
						}
						break;
					case 2:
						if(v635) {
							bs635 |= 32;
						} else {
							bs635 &= -33;
						}
						break;
					case 3:
						if(v635) {
							bs635 |= 16;
						} else {
							bs635 &= -17;
						}
						break;
					case 4:
						if(v635) {
							bs635 |= 8;
						} else {
							bs635 &= -9;
						}
						break;
					case 5:
						if(v635) {
							bs635 |= 4;
						} else {
							bs635 &= -5;
						}
						break;
					case 6:
						if(v635) {
							bs635 |= 2;
						} else {
							bs635 &= -3;
						}
						break;
					case 7:
						if(v635) {
							bs635 |= 1;
						} else {
							bs635 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs635;
				var this637 = 0;
				var bs636 = this637;
				var l636 = "*****".length;
				var _g1637 = 0;
				var _g737 = l636;
				while(_g1637 < _g737) {
					var i637 = _g1637++;
					var no636 = "*****".charCodeAt(i637);
					if(no636 == null) {
						break;
					}
					var v636;
					switch(no636) {
					case 32:
						v636 = false;
						break;
					case 42:
						v636 = true;
						break;
					case 48:
						v636 = false;
						break;
					case 49:
						v636 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i637)));
					}
					switch(i637 - (l636 - 8)) {
					case 0:
						if(v636) {
							bs636 |= 128;
						} else {
							bs636 &= -129;
						}
						break;
					case 1:
						if(v636) {
							bs636 |= 64;
						} else {
							bs636 &= -65;
						}
						break;
					case 2:
						if(v636) {
							bs636 |= 32;
						} else {
							bs636 &= -33;
						}
						break;
					case 3:
						if(v636) {
							bs636 |= 16;
						} else {
							bs636 &= -17;
						}
						break;
					case 4:
						if(v636) {
							bs636 |= 8;
						} else {
							bs636 &= -9;
						}
						break;
					case 5:
						if(v636) {
							bs636 |= 4;
						} else {
							bs636 &= -5;
						}
						break;
					case 6:
						if(v636) {
							bs636 |= 2;
						} else {
							bs636 &= -3;
						}
						break;
					case 7:
						if(v636) {
							bs636 |= 1;
						} else {
							bs636 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs636;
				break;
			case 123:
				var this638 = 0;
				var bs637 = this638;
				var l637 = "   * ".length;
				var _g1638 = 0;
				var _g738 = l637;
				while(_g1638 < _g738) {
					var i638 = _g1638++;
					var no637 = "   * ".charCodeAt(i638);
					if(no637 == null) {
						break;
					}
					var v637;
					switch(no637) {
					case 32:
						v637 = false;
						break;
					case 42:
						v637 = true;
						break;
					case 48:
						v637 = false;
						break;
					case 49:
						v637 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i638)));
					}
					switch(i638 - (l637 - 8)) {
					case 0:
						if(v637) {
							bs637 |= 128;
						} else {
							bs637 &= -129;
						}
						break;
					case 1:
						if(v637) {
							bs637 |= 64;
						} else {
							bs637 &= -65;
						}
						break;
					case 2:
						if(v637) {
							bs637 |= 32;
						} else {
							bs637 &= -33;
						}
						break;
					case 3:
						if(v637) {
							bs637 |= 16;
						} else {
							bs637 &= -17;
						}
						break;
					case 4:
						if(v637) {
							bs637 |= 8;
						} else {
							bs637 &= -9;
						}
						break;
					case 5:
						if(v637) {
							bs637 |= 4;
						} else {
							bs637 &= -5;
						}
						break;
					case 6:
						if(v637) {
							bs637 |= 2;
						} else {
							bs637 &= -3;
						}
						break;
					case 7:
						if(v637) {
							bs637 |= 1;
						} else {
							bs637 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs637;
				var this639 = 0;
				var bs638 = this639;
				var l638 = "  *  ".length;
				var _g1639 = 0;
				var _g739 = l638;
				while(_g1639 < _g739) {
					var i639 = _g1639++;
					var no638 = "  *  ".charCodeAt(i639);
					if(no638 == null) {
						break;
					}
					var v638;
					switch(no638) {
					case 32:
						v638 = false;
						break;
					case 42:
						v638 = true;
						break;
					case 48:
						v638 = false;
						break;
					case 49:
						v638 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i639)));
					}
					switch(i639 - (l638 - 8)) {
					case 0:
						if(v638) {
							bs638 |= 128;
						} else {
							bs638 &= -129;
						}
						break;
					case 1:
						if(v638) {
							bs638 |= 64;
						} else {
							bs638 &= -65;
						}
						break;
					case 2:
						if(v638) {
							bs638 |= 32;
						} else {
							bs638 &= -33;
						}
						break;
					case 3:
						if(v638) {
							bs638 |= 16;
						} else {
							bs638 &= -17;
						}
						break;
					case 4:
						if(v638) {
							bs638 |= 8;
						} else {
							bs638 &= -9;
						}
						break;
					case 5:
						if(v638) {
							bs638 |= 4;
						} else {
							bs638 &= -5;
						}
						break;
					case 6:
						if(v638) {
							bs638 |= 2;
						} else {
							bs638 &= -3;
						}
						break;
					case 7:
						if(v638) {
							bs638 |= 1;
						} else {
							bs638 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs638;
				var this640 = 0;
				var bs639 = this640;
				var l639 = "  *  ".length;
				var _g1640 = 0;
				var _g740 = l639;
				while(_g1640 < _g740) {
					var i640 = _g1640++;
					var no639 = "  *  ".charCodeAt(i640);
					if(no639 == null) {
						break;
					}
					var v639;
					switch(no639) {
					case 32:
						v639 = false;
						break;
					case 42:
						v639 = true;
						break;
					case 48:
						v639 = false;
						break;
					case 49:
						v639 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i640)));
					}
					switch(i640 - (l639 - 8)) {
					case 0:
						if(v639) {
							bs639 |= 128;
						} else {
							bs639 &= -129;
						}
						break;
					case 1:
						if(v639) {
							bs639 |= 64;
						} else {
							bs639 &= -65;
						}
						break;
					case 2:
						if(v639) {
							bs639 |= 32;
						} else {
							bs639 &= -33;
						}
						break;
					case 3:
						if(v639) {
							bs639 |= 16;
						} else {
							bs639 &= -17;
						}
						break;
					case 4:
						if(v639) {
							bs639 |= 8;
						} else {
							bs639 &= -9;
						}
						break;
					case 5:
						if(v639) {
							bs639 |= 4;
						} else {
							bs639 &= -5;
						}
						break;
					case 6:
						if(v639) {
							bs639 |= 2;
						} else {
							bs639 &= -3;
						}
						break;
					case 7:
						if(v639) {
							bs639 |= 1;
						} else {
							bs639 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs639;
				var this641 = 0;
				var bs640 = this641;
				var l640 = " *   ".length;
				var _g1641 = 0;
				var _g741 = l640;
				while(_g1641 < _g741) {
					var i641 = _g1641++;
					var no640 = " *   ".charCodeAt(i641);
					if(no640 == null) {
						break;
					}
					var v640;
					switch(no640) {
					case 32:
						v640 = false;
						break;
					case 42:
						v640 = true;
						break;
					case 48:
						v640 = false;
						break;
					case 49:
						v640 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i641)));
					}
					switch(i641 - (l640 - 8)) {
					case 0:
						if(v640) {
							bs640 |= 128;
						} else {
							bs640 &= -129;
						}
						break;
					case 1:
						if(v640) {
							bs640 |= 64;
						} else {
							bs640 &= -65;
						}
						break;
					case 2:
						if(v640) {
							bs640 |= 32;
						} else {
							bs640 &= -33;
						}
						break;
					case 3:
						if(v640) {
							bs640 |= 16;
						} else {
							bs640 &= -17;
						}
						break;
					case 4:
						if(v640) {
							bs640 |= 8;
						} else {
							bs640 &= -9;
						}
						break;
					case 5:
						if(v640) {
							bs640 |= 4;
						} else {
							bs640 &= -5;
						}
						break;
					case 6:
						if(v640) {
							bs640 |= 2;
						} else {
							bs640 &= -3;
						}
						break;
					case 7:
						if(v640) {
							bs640 |= 1;
						} else {
							bs640 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs640;
				var this642 = 0;
				var bs641 = this642;
				var l641 = "  *  ".length;
				var _g1642 = 0;
				var _g742 = l641;
				while(_g1642 < _g742) {
					var i642 = _g1642++;
					var no641 = "  *  ".charCodeAt(i642);
					if(no641 == null) {
						break;
					}
					var v641;
					switch(no641) {
					case 32:
						v641 = false;
						break;
					case 42:
						v641 = true;
						break;
					case 48:
						v641 = false;
						break;
					case 49:
						v641 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i642)));
					}
					switch(i642 - (l641 - 8)) {
					case 0:
						if(v641) {
							bs641 |= 128;
						} else {
							bs641 &= -129;
						}
						break;
					case 1:
						if(v641) {
							bs641 |= 64;
						} else {
							bs641 &= -65;
						}
						break;
					case 2:
						if(v641) {
							bs641 |= 32;
						} else {
							bs641 &= -33;
						}
						break;
					case 3:
						if(v641) {
							bs641 |= 16;
						} else {
							bs641 &= -17;
						}
						break;
					case 4:
						if(v641) {
							bs641 |= 8;
						} else {
							bs641 &= -9;
						}
						break;
					case 5:
						if(v641) {
							bs641 |= 4;
						} else {
							bs641 &= -5;
						}
						break;
					case 6:
						if(v641) {
							bs641 |= 2;
						} else {
							bs641 &= -3;
						}
						break;
					case 7:
						if(v641) {
							bs641 |= 1;
						} else {
							bs641 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs641;
				var this643 = 0;
				var bs642 = this643;
				var l642 = "  *  ".length;
				var _g1643 = 0;
				var _g743 = l642;
				while(_g1643 < _g743) {
					var i643 = _g1643++;
					var no642 = "  *  ".charCodeAt(i643);
					if(no642 == null) {
						break;
					}
					var v642;
					switch(no642) {
					case 32:
						v642 = false;
						break;
					case 42:
						v642 = true;
						break;
					case 48:
						v642 = false;
						break;
					case 49:
						v642 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i643)));
					}
					switch(i643 - (l642 - 8)) {
					case 0:
						if(v642) {
							bs642 |= 128;
						} else {
							bs642 &= -129;
						}
						break;
					case 1:
						if(v642) {
							bs642 |= 64;
						} else {
							bs642 &= -65;
						}
						break;
					case 2:
						if(v642) {
							bs642 |= 32;
						} else {
							bs642 &= -33;
						}
						break;
					case 3:
						if(v642) {
							bs642 |= 16;
						} else {
							bs642 &= -17;
						}
						break;
					case 4:
						if(v642) {
							bs642 |= 8;
						} else {
							bs642 &= -9;
						}
						break;
					case 5:
						if(v642) {
							bs642 |= 4;
						} else {
							bs642 &= -5;
						}
						break;
					case 6:
						if(v642) {
							bs642 |= 2;
						} else {
							bs642 &= -3;
						}
						break;
					case 7:
						if(v642) {
							bs642 |= 1;
						} else {
							bs642 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs642;
				var this644 = 0;
				var bs643 = this644;
				var l643 = "   * ".length;
				var _g1644 = 0;
				var _g744 = l643;
				while(_g1644 < _g744) {
					var i644 = _g1644++;
					var no643 = "   * ".charCodeAt(i644);
					if(no643 == null) {
						break;
					}
					var v643;
					switch(no643) {
					case 32:
						v643 = false;
						break;
					case 42:
						v643 = true;
						break;
					case 48:
						v643 = false;
						break;
					case 49:
						v643 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i644)));
					}
					switch(i644 - (l643 - 8)) {
					case 0:
						if(v643) {
							bs643 |= 128;
						} else {
							bs643 &= -129;
						}
						break;
					case 1:
						if(v643) {
							bs643 |= 64;
						} else {
							bs643 &= -65;
						}
						break;
					case 2:
						if(v643) {
							bs643 |= 32;
						} else {
							bs643 &= -33;
						}
						break;
					case 3:
						if(v643) {
							bs643 |= 16;
						} else {
							bs643 &= -17;
						}
						break;
					case 4:
						if(v643) {
							bs643 |= 8;
						} else {
							bs643 &= -9;
						}
						break;
					case 5:
						if(v643) {
							bs643 |= 4;
						} else {
							bs643 &= -5;
						}
						break;
					case 6:
						if(v643) {
							bs643 |= 2;
						} else {
							bs643 &= -3;
						}
						break;
					case 7:
						if(v643) {
							bs643 |= 1;
						} else {
							bs643 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs643;
				break;
			case 124:
				var this645 = 0;
				var bs644 = this645;
				var l644 = "  *  ".length;
				var _g1645 = 0;
				var _g745 = l644;
				while(_g1645 < _g745) {
					var i645 = _g1645++;
					var no644 = "  *  ".charCodeAt(i645);
					if(no644 == null) {
						break;
					}
					var v644;
					switch(no644) {
					case 32:
						v644 = false;
						break;
					case 42:
						v644 = true;
						break;
					case 48:
						v644 = false;
						break;
					case 49:
						v644 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i645)));
					}
					switch(i645 - (l644 - 8)) {
					case 0:
						if(v644) {
							bs644 |= 128;
						} else {
							bs644 &= -129;
						}
						break;
					case 1:
						if(v644) {
							bs644 |= 64;
						} else {
							bs644 &= -65;
						}
						break;
					case 2:
						if(v644) {
							bs644 |= 32;
						} else {
							bs644 &= -33;
						}
						break;
					case 3:
						if(v644) {
							bs644 |= 16;
						} else {
							bs644 &= -17;
						}
						break;
					case 4:
						if(v644) {
							bs644 |= 8;
						} else {
							bs644 &= -9;
						}
						break;
					case 5:
						if(v644) {
							bs644 |= 4;
						} else {
							bs644 &= -5;
						}
						break;
					case 6:
						if(v644) {
							bs644 |= 2;
						} else {
							bs644 &= -3;
						}
						break;
					case 7:
						if(v644) {
							bs644 |= 1;
						} else {
							bs644 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs644;
				var this646 = 0;
				var bs645 = this646;
				var l645 = "  *  ".length;
				var _g1646 = 0;
				var _g746 = l645;
				while(_g1646 < _g746) {
					var i646 = _g1646++;
					var no645 = "  *  ".charCodeAt(i646);
					if(no645 == null) {
						break;
					}
					var v645;
					switch(no645) {
					case 32:
						v645 = false;
						break;
					case 42:
						v645 = true;
						break;
					case 48:
						v645 = false;
						break;
					case 49:
						v645 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i646)));
					}
					switch(i646 - (l645 - 8)) {
					case 0:
						if(v645) {
							bs645 |= 128;
						} else {
							bs645 &= -129;
						}
						break;
					case 1:
						if(v645) {
							bs645 |= 64;
						} else {
							bs645 &= -65;
						}
						break;
					case 2:
						if(v645) {
							bs645 |= 32;
						} else {
							bs645 &= -33;
						}
						break;
					case 3:
						if(v645) {
							bs645 |= 16;
						} else {
							bs645 &= -17;
						}
						break;
					case 4:
						if(v645) {
							bs645 |= 8;
						} else {
							bs645 &= -9;
						}
						break;
					case 5:
						if(v645) {
							bs645 |= 4;
						} else {
							bs645 &= -5;
						}
						break;
					case 6:
						if(v645) {
							bs645 |= 2;
						} else {
							bs645 &= -3;
						}
						break;
					case 7:
						if(v645) {
							bs645 |= 1;
						} else {
							bs645 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs645;
				var this647 = 0;
				var bs646 = this647;
				var l646 = "  *  ".length;
				var _g1647 = 0;
				var _g747 = l646;
				while(_g1647 < _g747) {
					var i647 = _g1647++;
					var no646 = "  *  ".charCodeAt(i647);
					if(no646 == null) {
						break;
					}
					var v646;
					switch(no646) {
					case 32:
						v646 = false;
						break;
					case 42:
						v646 = true;
						break;
					case 48:
						v646 = false;
						break;
					case 49:
						v646 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i647)));
					}
					switch(i647 - (l646 - 8)) {
					case 0:
						if(v646) {
							bs646 |= 128;
						} else {
							bs646 &= -129;
						}
						break;
					case 1:
						if(v646) {
							bs646 |= 64;
						} else {
							bs646 &= -65;
						}
						break;
					case 2:
						if(v646) {
							bs646 |= 32;
						} else {
							bs646 &= -33;
						}
						break;
					case 3:
						if(v646) {
							bs646 |= 16;
						} else {
							bs646 &= -17;
						}
						break;
					case 4:
						if(v646) {
							bs646 |= 8;
						} else {
							bs646 &= -9;
						}
						break;
					case 5:
						if(v646) {
							bs646 |= 4;
						} else {
							bs646 &= -5;
						}
						break;
					case 6:
						if(v646) {
							bs646 |= 2;
						} else {
							bs646 &= -3;
						}
						break;
					case 7:
						if(v646) {
							bs646 |= 1;
						} else {
							bs646 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs646;
				var this648 = 0;
				var bs647 = this648;
				var l647 = "  *  ".length;
				var _g1648 = 0;
				var _g748 = l647;
				while(_g1648 < _g748) {
					var i648 = _g1648++;
					var no647 = "  *  ".charCodeAt(i648);
					if(no647 == null) {
						break;
					}
					var v647;
					switch(no647) {
					case 32:
						v647 = false;
						break;
					case 42:
						v647 = true;
						break;
					case 48:
						v647 = false;
						break;
					case 49:
						v647 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i648)));
					}
					switch(i648 - (l647 - 8)) {
					case 0:
						if(v647) {
							bs647 |= 128;
						} else {
							bs647 &= -129;
						}
						break;
					case 1:
						if(v647) {
							bs647 |= 64;
						} else {
							bs647 &= -65;
						}
						break;
					case 2:
						if(v647) {
							bs647 |= 32;
						} else {
							bs647 &= -33;
						}
						break;
					case 3:
						if(v647) {
							bs647 |= 16;
						} else {
							bs647 &= -17;
						}
						break;
					case 4:
						if(v647) {
							bs647 |= 8;
						} else {
							bs647 &= -9;
						}
						break;
					case 5:
						if(v647) {
							bs647 |= 4;
						} else {
							bs647 &= -5;
						}
						break;
					case 6:
						if(v647) {
							bs647 |= 2;
						} else {
							bs647 &= -3;
						}
						break;
					case 7:
						if(v647) {
							bs647 |= 1;
						} else {
							bs647 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs647;
				var this649 = 0;
				var bs648 = this649;
				var l648 = "  *  ".length;
				var _g1649 = 0;
				var _g749 = l648;
				while(_g1649 < _g749) {
					var i649 = _g1649++;
					var no648 = "  *  ".charCodeAt(i649);
					if(no648 == null) {
						break;
					}
					var v648;
					switch(no648) {
					case 32:
						v648 = false;
						break;
					case 42:
						v648 = true;
						break;
					case 48:
						v648 = false;
						break;
					case 49:
						v648 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i649)));
					}
					switch(i649 - (l648 - 8)) {
					case 0:
						if(v648) {
							bs648 |= 128;
						} else {
							bs648 &= -129;
						}
						break;
					case 1:
						if(v648) {
							bs648 |= 64;
						} else {
							bs648 &= -65;
						}
						break;
					case 2:
						if(v648) {
							bs648 |= 32;
						} else {
							bs648 &= -33;
						}
						break;
					case 3:
						if(v648) {
							bs648 |= 16;
						} else {
							bs648 &= -17;
						}
						break;
					case 4:
						if(v648) {
							bs648 |= 8;
						} else {
							bs648 &= -9;
						}
						break;
					case 5:
						if(v648) {
							bs648 |= 4;
						} else {
							bs648 &= -5;
						}
						break;
					case 6:
						if(v648) {
							bs648 |= 2;
						} else {
							bs648 &= -3;
						}
						break;
					case 7:
						if(v648) {
							bs648 |= 1;
						} else {
							bs648 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs648;
				var this650 = 0;
				var bs649 = this650;
				var l649 = "  *  ".length;
				var _g1650 = 0;
				var _g750 = l649;
				while(_g1650 < _g750) {
					var i650 = _g1650++;
					var no649 = "  *  ".charCodeAt(i650);
					if(no649 == null) {
						break;
					}
					var v649;
					switch(no649) {
					case 32:
						v649 = false;
						break;
					case 42:
						v649 = true;
						break;
					case 48:
						v649 = false;
						break;
					case 49:
						v649 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i650)));
					}
					switch(i650 - (l649 - 8)) {
					case 0:
						if(v649) {
							bs649 |= 128;
						} else {
							bs649 &= -129;
						}
						break;
					case 1:
						if(v649) {
							bs649 |= 64;
						} else {
							bs649 &= -65;
						}
						break;
					case 2:
						if(v649) {
							bs649 |= 32;
						} else {
							bs649 &= -33;
						}
						break;
					case 3:
						if(v649) {
							bs649 |= 16;
						} else {
							bs649 &= -17;
						}
						break;
					case 4:
						if(v649) {
							bs649 |= 8;
						} else {
							bs649 &= -9;
						}
						break;
					case 5:
						if(v649) {
							bs649 |= 4;
						} else {
							bs649 &= -5;
						}
						break;
					case 6:
						if(v649) {
							bs649 |= 2;
						} else {
							bs649 &= -3;
						}
						break;
					case 7:
						if(v649) {
							bs649 |= 1;
						} else {
							bs649 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs649;
				var this651 = 0;
				var bs650 = this651;
				var l650 = "  *  ".length;
				var _g1651 = 0;
				var _g751 = l650;
				while(_g1651 < _g751) {
					var i651 = _g1651++;
					var no650 = "  *  ".charCodeAt(i651);
					if(no650 == null) {
						break;
					}
					var v650;
					switch(no650) {
					case 32:
						v650 = false;
						break;
					case 42:
						v650 = true;
						break;
					case 48:
						v650 = false;
						break;
					case 49:
						v650 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i651)));
					}
					switch(i651 - (l650 - 8)) {
					case 0:
						if(v650) {
							bs650 |= 128;
						} else {
							bs650 &= -129;
						}
						break;
					case 1:
						if(v650) {
							bs650 |= 64;
						} else {
							bs650 &= -65;
						}
						break;
					case 2:
						if(v650) {
							bs650 |= 32;
						} else {
							bs650 &= -33;
						}
						break;
					case 3:
						if(v650) {
							bs650 |= 16;
						} else {
							bs650 &= -17;
						}
						break;
					case 4:
						if(v650) {
							bs650 |= 8;
						} else {
							bs650 &= -9;
						}
						break;
					case 5:
						if(v650) {
							bs650 |= 4;
						} else {
							bs650 &= -5;
						}
						break;
					case 6:
						if(v650) {
							bs650 |= 2;
						} else {
							bs650 &= -3;
						}
						break;
					case 7:
						if(v650) {
							bs650 |= 1;
						} else {
							bs650 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs650;
				break;
			case 125:
				var this652 = 0;
				var bs651 = this652;
				var l651 = "   * ".length;
				var _g1652 = 0;
				var _g752 = l651;
				while(_g1652 < _g752) {
					var i652 = _g1652++;
					var no651 = "   * ".charCodeAt(i652);
					if(no651 == null) {
						break;
					}
					var v651;
					switch(no651) {
					case 32:
						v651 = false;
						break;
					case 42:
						v651 = true;
						break;
					case 48:
						v651 = false;
						break;
					case 49:
						v651 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i652)));
					}
					switch(i652 - (l651 - 8)) {
					case 0:
						if(v651) {
							bs651 |= 128;
						} else {
							bs651 &= -129;
						}
						break;
					case 1:
						if(v651) {
							bs651 |= 64;
						} else {
							bs651 &= -65;
						}
						break;
					case 2:
						if(v651) {
							bs651 |= 32;
						} else {
							bs651 &= -33;
						}
						break;
					case 3:
						if(v651) {
							bs651 |= 16;
						} else {
							bs651 &= -17;
						}
						break;
					case 4:
						if(v651) {
							bs651 |= 8;
						} else {
							bs651 &= -9;
						}
						break;
					case 5:
						if(v651) {
							bs651 |= 4;
						} else {
							bs651 &= -5;
						}
						break;
					case 6:
						if(v651) {
							bs651 |= 2;
						} else {
							bs651 &= -3;
						}
						break;
					case 7:
						if(v651) {
							bs651 |= 1;
						} else {
							bs651 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs651;
				var this653 = 0;
				var bs652 = this653;
				var l652 = "  *  ".length;
				var _g1653 = 0;
				var _g753 = l652;
				while(_g1653 < _g753) {
					var i653 = _g1653++;
					var no652 = "  *  ".charCodeAt(i653);
					if(no652 == null) {
						break;
					}
					var v652;
					switch(no652) {
					case 32:
						v652 = false;
						break;
					case 42:
						v652 = true;
						break;
					case 48:
						v652 = false;
						break;
					case 49:
						v652 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i653)));
					}
					switch(i653 - (l652 - 8)) {
					case 0:
						if(v652) {
							bs652 |= 128;
						} else {
							bs652 &= -129;
						}
						break;
					case 1:
						if(v652) {
							bs652 |= 64;
						} else {
							bs652 &= -65;
						}
						break;
					case 2:
						if(v652) {
							bs652 |= 32;
						} else {
							bs652 &= -33;
						}
						break;
					case 3:
						if(v652) {
							bs652 |= 16;
						} else {
							bs652 &= -17;
						}
						break;
					case 4:
						if(v652) {
							bs652 |= 8;
						} else {
							bs652 &= -9;
						}
						break;
					case 5:
						if(v652) {
							bs652 |= 4;
						} else {
							bs652 &= -5;
						}
						break;
					case 6:
						if(v652) {
							bs652 |= 2;
						} else {
							bs652 &= -3;
						}
						break;
					case 7:
						if(v652) {
							bs652 |= 1;
						} else {
							bs652 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs652;
				var this654 = 0;
				var bs653 = this654;
				var l653 = "  *  ".length;
				var _g1654 = 0;
				var _g754 = l653;
				while(_g1654 < _g754) {
					var i654 = _g1654++;
					var no653 = "  *  ".charCodeAt(i654);
					if(no653 == null) {
						break;
					}
					var v653;
					switch(no653) {
					case 32:
						v653 = false;
						break;
					case 42:
						v653 = true;
						break;
					case 48:
						v653 = false;
						break;
					case 49:
						v653 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i654)));
					}
					switch(i654 - (l653 - 8)) {
					case 0:
						if(v653) {
							bs653 |= 128;
						} else {
							bs653 &= -129;
						}
						break;
					case 1:
						if(v653) {
							bs653 |= 64;
						} else {
							bs653 &= -65;
						}
						break;
					case 2:
						if(v653) {
							bs653 |= 32;
						} else {
							bs653 &= -33;
						}
						break;
					case 3:
						if(v653) {
							bs653 |= 16;
						} else {
							bs653 &= -17;
						}
						break;
					case 4:
						if(v653) {
							bs653 |= 8;
						} else {
							bs653 &= -9;
						}
						break;
					case 5:
						if(v653) {
							bs653 |= 4;
						} else {
							bs653 &= -5;
						}
						break;
					case 6:
						if(v653) {
							bs653 |= 2;
						} else {
							bs653 &= -3;
						}
						break;
					case 7:
						if(v653) {
							bs653 |= 1;
						} else {
							bs653 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs653;
				var this655 = 0;
				var bs654 = this655;
				var l654 = " *   ".length;
				var _g1655 = 0;
				var _g755 = l654;
				while(_g1655 < _g755) {
					var i655 = _g1655++;
					var no654 = " *   ".charCodeAt(i655);
					if(no654 == null) {
						break;
					}
					var v654;
					switch(no654) {
					case 32:
						v654 = false;
						break;
					case 42:
						v654 = true;
						break;
					case 48:
						v654 = false;
						break;
					case 49:
						v654 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i655)));
					}
					switch(i655 - (l654 - 8)) {
					case 0:
						if(v654) {
							bs654 |= 128;
						} else {
							bs654 &= -129;
						}
						break;
					case 1:
						if(v654) {
							bs654 |= 64;
						} else {
							bs654 &= -65;
						}
						break;
					case 2:
						if(v654) {
							bs654 |= 32;
						} else {
							bs654 &= -33;
						}
						break;
					case 3:
						if(v654) {
							bs654 |= 16;
						} else {
							bs654 &= -17;
						}
						break;
					case 4:
						if(v654) {
							bs654 |= 8;
						} else {
							bs654 &= -9;
						}
						break;
					case 5:
						if(v654) {
							bs654 |= 4;
						} else {
							bs654 &= -5;
						}
						break;
					case 6:
						if(v654) {
							bs654 |= 2;
						} else {
							bs654 &= -3;
						}
						break;
					case 7:
						if(v654) {
							bs654 |= 1;
						} else {
							bs654 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs654;
				var this656 = 0;
				var bs655 = this656;
				var l655 = "  *  ".length;
				var _g1656 = 0;
				var _g756 = l655;
				while(_g1656 < _g756) {
					var i656 = _g1656++;
					var no655 = "  *  ".charCodeAt(i656);
					if(no655 == null) {
						break;
					}
					var v655;
					switch(no655) {
					case 32:
						v655 = false;
						break;
					case 42:
						v655 = true;
						break;
					case 48:
						v655 = false;
						break;
					case 49:
						v655 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i656)));
					}
					switch(i656 - (l655 - 8)) {
					case 0:
						if(v655) {
							bs655 |= 128;
						} else {
							bs655 &= -129;
						}
						break;
					case 1:
						if(v655) {
							bs655 |= 64;
						} else {
							bs655 &= -65;
						}
						break;
					case 2:
						if(v655) {
							bs655 |= 32;
						} else {
							bs655 &= -33;
						}
						break;
					case 3:
						if(v655) {
							bs655 |= 16;
						} else {
							bs655 &= -17;
						}
						break;
					case 4:
						if(v655) {
							bs655 |= 8;
						} else {
							bs655 &= -9;
						}
						break;
					case 5:
						if(v655) {
							bs655 |= 4;
						} else {
							bs655 &= -5;
						}
						break;
					case 6:
						if(v655) {
							bs655 |= 2;
						} else {
							bs655 &= -3;
						}
						break;
					case 7:
						if(v655) {
							bs655 |= 1;
						} else {
							bs655 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs655;
				var this657 = 0;
				var bs656 = this657;
				var l656 = "  *  ".length;
				var _g1657 = 0;
				var _g757 = l656;
				while(_g1657 < _g757) {
					var i657 = _g1657++;
					var no656 = "  *  ".charCodeAt(i657);
					if(no656 == null) {
						break;
					}
					var v656;
					switch(no656) {
					case 32:
						v656 = false;
						break;
					case 42:
						v656 = true;
						break;
					case 48:
						v656 = false;
						break;
					case 49:
						v656 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i657)));
					}
					switch(i657 - (l656 - 8)) {
					case 0:
						if(v656) {
							bs656 |= 128;
						} else {
							bs656 &= -129;
						}
						break;
					case 1:
						if(v656) {
							bs656 |= 64;
						} else {
							bs656 &= -65;
						}
						break;
					case 2:
						if(v656) {
							bs656 |= 32;
						} else {
							bs656 &= -33;
						}
						break;
					case 3:
						if(v656) {
							bs656 |= 16;
						} else {
							bs656 &= -17;
						}
						break;
					case 4:
						if(v656) {
							bs656 |= 8;
						} else {
							bs656 &= -9;
						}
						break;
					case 5:
						if(v656) {
							bs656 |= 4;
						} else {
							bs656 &= -5;
						}
						break;
					case 6:
						if(v656) {
							bs656 |= 2;
						} else {
							bs656 &= -3;
						}
						break;
					case 7:
						if(v656) {
							bs656 |= 1;
						} else {
							bs656 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs656;
				var this658 = 0;
				var bs657 = this658;
				var l657 = "   * ".length;
				var _g1658 = 0;
				var _g758 = l657;
				while(_g1658 < _g758) {
					var i658 = _g1658++;
					var no657 = "   * ".charCodeAt(i658);
					if(no657 == null) {
						break;
					}
					var v657;
					switch(no657) {
					case 32:
						v657 = false;
						break;
					case 42:
						v657 = true;
						break;
					case 48:
						v657 = false;
						break;
					case 49:
						v657 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i658)));
					}
					switch(i658 - (l657 - 8)) {
					case 0:
						if(v657) {
							bs657 |= 128;
						} else {
							bs657 &= -129;
						}
						break;
					case 1:
						if(v657) {
							bs657 |= 64;
						} else {
							bs657 &= -65;
						}
						break;
					case 2:
						if(v657) {
							bs657 |= 32;
						} else {
							bs657 &= -33;
						}
						break;
					case 3:
						if(v657) {
							bs657 |= 16;
						} else {
							bs657 &= -17;
						}
						break;
					case 4:
						if(v657) {
							bs657 |= 8;
						} else {
							bs657 &= -9;
						}
						break;
					case 5:
						if(v657) {
							bs657 |= 4;
						} else {
							bs657 &= -5;
						}
						break;
					case 6:
						if(v657) {
							bs657 |= 2;
						} else {
							bs657 &= -3;
						}
						break;
					case 7:
						if(v657) {
							bs657 |= 1;
						} else {
							bs657 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs657;
				break;
			case 126:
				var this659 = 0;
				var bs658 = this659;
				var l658 = " ** *".length;
				var _g1659 = 0;
				var _g759 = l658;
				while(_g1659 < _g759) {
					var i659 = _g1659++;
					var no658 = " ** *".charCodeAt(i659);
					if(no658 == null) {
						break;
					}
					var v658;
					switch(no658) {
					case 32:
						v658 = false;
						break;
					case 42:
						v658 = true;
						break;
					case 48:
						v658 = false;
						break;
					case 49:
						v658 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i659)));
					}
					switch(i659 - (l658 - 8)) {
					case 0:
						if(v658) {
							bs658 |= 128;
						} else {
							bs658 &= -129;
						}
						break;
					case 1:
						if(v658) {
							bs658 |= 64;
						} else {
							bs658 &= -65;
						}
						break;
					case 2:
						if(v658) {
							bs658 |= 32;
						} else {
							bs658 &= -33;
						}
						break;
					case 3:
						if(v658) {
							bs658 |= 16;
						} else {
							bs658 &= -17;
						}
						break;
					case 4:
						if(v658) {
							bs658 |= 8;
						} else {
							bs658 &= -9;
						}
						break;
					case 5:
						if(v658) {
							bs658 |= 4;
						} else {
							bs658 &= -5;
						}
						break;
					case 6:
						if(v658) {
							bs658 |= 2;
						} else {
							bs658 &= -3;
						}
						break;
					case 7:
						if(v658) {
							bs658 |= 1;
						} else {
							bs658 &= -2;
						}
						break;
					default:
					}
				}
				arr1[0] = bs658;
				var this660 = 0;
				var bs659 = this660;
				var l659 = "*  * ".length;
				var _g1660 = 0;
				var _g760 = l659;
				while(_g1660 < _g760) {
					var i660 = _g1660++;
					var no659 = "*  * ".charCodeAt(i660);
					if(no659 == null) {
						break;
					}
					var v659;
					switch(no659) {
					case 32:
						v659 = false;
						break;
					case 42:
						v659 = true;
						break;
					case 48:
						v659 = false;
						break;
					case 49:
						v659 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i660)));
					}
					switch(i660 - (l659 - 8)) {
					case 0:
						if(v659) {
							bs659 |= 128;
						} else {
							bs659 &= -129;
						}
						break;
					case 1:
						if(v659) {
							bs659 |= 64;
						} else {
							bs659 &= -65;
						}
						break;
					case 2:
						if(v659) {
							bs659 |= 32;
						} else {
							bs659 &= -33;
						}
						break;
					case 3:
						if(v659) {
							bs659 |= 16;
						} else {
							bs659 &= -17;
						}
						break;
					case 4:
						if(v659) {
							bs659 |= 8;
						} else {
							bs659 &= -9;
						}
						break;
					case 5:
						if(v659) {
							bs659 |= 4;
						} else {
							bs659 &= -5;
						}
						break;
					case 6:
						if(v659) {
							bs659 |= 2;
						} else {
							bs659 &= -3;
						}
						break;
					case 7:
						if(v659) {
							bs659 |= 1;
						} else {
							bs659 &= -2;
						}
						break;
					default:
					}
				}
				arr1[1] = bs659;
				var this661 = 0;
				var bs660 = this661;
				var l660 = "     ".length;
				var _g1661 = 0;
				var _g761 = l660;
				while(_g1661 < _g761) {
					var i661 = _g1661++;
					var no660 = "     ".charCodeAt(i661);
					if(no660 == null) {
						break;
					}
					var v660;
					switch(no660) {
					case 32:
						v660 = false;
						break;
					case 42:
						v660 = true;
						break;
					case 48:
						v660 = false;
						break;
					case 49:
						v660 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i661)));
					}
					switch(i661 - (l660 - 8)) {
					case 0:
						if(v660) {
							bs660 |= 128;
						} else {
							bs660 &= -129;
						}
						break;
					case 1:
						if(v660) {
							bs660 |= 64;
						} else {
							bs660 &= -65;
						}
						break;
					case 2:
						if(v660) {
							bs660 |= 32;
						} else {
							bs660 &= -33;
						}
						break;
					case 3:
						if(v660) {
							bs660 |= 16;
						} else {
							bs660 &= -17;
						}
						break;
					case 4:
						if(v660) {
							bs660 |= 8;
						} else {
							bs660 &= -9;
						}
						break;
					case 5:
						if(v660) {
							bs660 |= 4;
						} else {
							bs660 &= -5;
						}
						break;
					case 6:
						if(v660) {
							bs660 |= 2;
						} else {
							bs660 &= -3;
						}
						break;
					case 7:
						if(v660) {
							bs660 |= 1;
						} else {
							bs660 &= -2;
						}
						break;
					default:
					}
				}
				arr1[2] = bs660;
				var this662 = 0;
				var bs661 = this662;
				var l661 = "     ".length;
				var _g1662 = 0;
				var _g762 = l661;
				while(_g1662 < _g762) {
					var i662 = _g1662++;
					var no661 = "     ".charCodeAt(i662);
					if(no661 == null) {
						break;
					}
					var v661;
					switch(no661) {
					case 32:
						v661 = false;
						break;
					case 42:
						v661 = true;
						break;
					case 48:
						v661 = false;
						break;
					case 49:
						v661 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i662)));
					}
					switch(i662 - (l661 - 8)) {
					case 0:
						if(v661) {
							bs661 |= 128;
						} else {
							bs661 &= -129;
						}
						break;
					case 1:
						if(v661) {
							bs661 |= 64;
						} else {
							bs661 &= -65;
						}
						break;
					case 2:
						if(v661) {
							bs661 |= 32;
						} else {
							bs661 &= -33;
						}
						break;
					case 3:
						if(v661) {
							bs661 |= 16;
						} else {
							bs661 &= -17;
						}
						break;
					case 4:
						if(v661) {
							bs661 |= 8;
						} else {
							bs661 &= -9;
						}
						break;
					case 5:
						if(v661) {
							bs661 |= 4;
						} else {
							bs661 &= -5;
						}
						break;
					case 6:
						if(v661) {
							bs661 |= 2;
						} else {
							bs661 &= -3;
						}
						break;
					case 7:
						if(v661) {
							bs661 |= 1;
						} else {
							bs661 &= -2;
						}
						break;
					default:
					}
				}
				arr1[3] = bs661;
				var this663 = 0;
				var bs662 = this663;
				var l662 = "     ".length;
				var _g1663 = 0;
				var _g763 = l662;
				while(_g1663 < _g763) {
					var i663 = _g1663++;
					var no662 = "     ".charCodeAt(i663);
					if(no662 == null) {
						break;
					}
					var v662;
					switch(no662) {
					case 32:
						v662 = false;
						break;
					case 42:
						v662 = true;
						break;
					case 48:
						v662 = false;
						break;
					case 49:
						v662 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i663)));
					}
					switch(i663 - (l662 - 8)) {
					case 0:
						if(v662) {
							bs662 |= 128;
						} else {
							bs662 &= -129;
						}
						break;
					case 1:
						if(v662) {
							bs662 |= 64;
						} else {
							bs662 &= -65;
						}
						break;
					case 2:
						if(v662) {
							bs662 |= 32;
						} else {
							bs662 &= -33;
						}
						break;
					case 3:
						if(v662) {
							bs662 |= 16;
						} else {
							bs662 &= -17;
						}
						break;
					case 4:
						if(v662) {
							bs662 |= 8;
						} else {
							bs662 &= -9;
						}
						break;
					case 5:
						if(v662) {
							bs662 |= 4;
						} else {
							bs662 &= -5;
						}
						break;
					case 6:
						if(v662) {
							bs662 |= 2;
						} else {
							bs662 &= -3;
						}
						break;
					case 7:
						if(v662) {
							bs662 |= 1;
						} else {
							bs662 &= -2;
						}
						break;
					default:
					}
				}
				arr1[4] = bs662;
				var this664 = 0;
				var bs663 = this664;
				var l663 = "     ".length;
				var _g1664 = 0;
				var _g764 = l663;
				while(_g1664 < _g764) {
					var i664 = _g1664++;
					var no663 = "     ".charCodeAt(i664);
					if(no663 == null) {
						break;
					}
					var v663;
					switch(no663) {
					case 32:
						v663 = false;
						break;
					case 42:
						v663 = true;
						break;
					case 48:
						v663 = false;
						break;
					case 49:
						v663 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i664)));
					}
					switch(i664 - (l663 - 8)) {
					case 0:
						if(v663) {
							bs663 |= 128;
						} else {
							bs663 &= -129;
						}
						break;
					case 1:
						if(v663) {
							bs663 |= 64;
						} else {
							bs663 &= -65;
						}
						break;
					case 2:
						if(v663) {
							bs663 |= 32;
						} else {
							bs663 &= -33;
						}
						break;
					case 3:
						if(v663) {
							bs663 |= 16;
						} else {
							bs663 &= -17;
						}
						break;
					case 4:
						if(v663) {
							bs663 |= 8;
						} else {
							bs663 &= -9;
						}
						break;
					case 5:
						if(v663) {
							bs663 |= 4;
						} else {
							bs663 &= -5;
						}
						break;
					case 6:
						if(v663) {
							bs663 |= 2;
						} else {
							bs663 &= -3;
						}
						break;
					case 7:
						if(v663) {
							bs663 |= 1;
						} else {
							bs663 &= -2;
						}
						break;
					default:
					}
				}
				arr1[5] = bs663;
				var this665 = 0;
				var bs664 = this665;
				var l664 = "     ".length;
				var _g1665 = 0;
				var _g765 = l664;
				while(_g1665 < _g765) {
					var i665 = _g1665++;
					var no664 = "     ".charCodeAt(i665);
					if(no664 == null) {
						break;
					}
					var v664;
					switch(no664) {
					case 32:
						v664 = false;
						break;
					case 42:
						v664 = true;
						break;
					case 48:
						v664 = false;
						break;
					case 49:
						v664 = true;
						break;
					default:
						throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i665)));
					}
					switch(i665 - (l664 - 8)) {
					case 0:
						if(v664) {
							bs664 |= 128;
						} else {
							bs664 &= -129;
						}
						break;
					case 1:
						if(v664) {
							bs664 |= 64;
						} else {
							bs664 &= -65;
						}
						break;
					case 2:
						if(v664) {
							bs664 |= 32;
						} else {
							bs664 &= -33;
						}
						break;
					case 3:
						if(v664) {
							bs664 |= 16;
						} else {
							bs664 &= -17;
						}
						break;
					case 4:
						if(v664) {
							bs664 |= 8;
						} else {
							bs664 &= -9;
						}
						break;
					case 5:
						if(v664) {
							bs664 |= 4;
						} else {
							bs664 &= -5;
						}
						break;
					case 6:
						if(v664) {
							bs664 |= 2;
						} else {
							bs664 &= -3;
						}
						break;
					case 7:
						if(v664) {
							bs664 |= 1;
						} else {
							bs664 &= -2;
						}
						break;
					default:
					}
				}
				arr1[6] = bs664;
				break;
			}
			arr[i] = trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$._new(arr1);
		}
		this.arrDotMatrix = arr;
		var dx = 100.;
		var dy = 50.;
		this.display = [];
		var _g766 = 0;
		while(_g766 < 10) {
			var i666 = _g766++;
			var $char = new trilateralXtra_segment_Character5x7(shapes,trilateralXtra_segment_PixelShape.Star,1,5,4,1.61803398874989484820);
			$char.dotMatrix = this.arrDotMatrix[i666];
			var radius = 0.8 * scale;
			$char.bgIndex = $char.shapes.refCount;
			$char.shapeIndex = $char.bgIndex + 1;
			var colorID = $char.offColor;
			var radiusW;
			var radiusH;
			var _g767 = $char.pixelShape;
			switch(_g767[1]) {
			case 0:
				radiusW = radius;
				radiusH = radius;
				break;
			case 1:
				radiusW = radius;
				radiusH = radius;
				break;
			case 2:
				radiusW = radius * $char.ratio;
				radiusH = radius;
				break;
			case 3:
				radiusW = radius;
				radiusH = radius * $char.ratio;
				break;
			case 4:
				radiusW = radius;
				radiusH = radius;
				break;
			case 5:
				radiusW = radius * $char.ratio;
				radiusH = radius;
				break;
			case 6:
				radiusW = radius;
				radiusH = radius * $char.ratio;
				break;
			}
			var dx1 = (dw - radiusW - scale * 2) / 4;
			var dy1 = (dh - radiusH - scale * 2) / 6;
			var _this = $char.shapes;
			var color = $char.bgColor;
			var this666 = _this.triangles;
			var id = _this.refCount++;
			var ax = dx;
			var ay = dy;
			var bx = dx + dw;
			var by = ay;
			var cx = bx;
			var cy = ay + dh;
			var dx2 = dx;
			var dy2 = cy;
			var tri = { t0 : new trilateral_tri_Trilateral(ax,ay,bx,by,dx2,dy2), t1 : new trilateral_tri_Trilateral(bx,by,cx,cy,dx2,dy2)};
			var tri1 = tri.t0;
			var t = Type.createEmptyInstance(trilateral_tri_Triangle);
			t.id = id;
			t.ax = tri1.ax;
			t.ay = tri1.ay;
			t.bx = tri1.bx;
			t.by = tri1.by;
			t.cx = tri1.cx;
			t.cy = tri1.cy;
			t.mark = tri1.mark;
			t.depth = 0;
			t.alpha = 1.;
			t.colorID = color;
			t.colorA = color;
			t.colorB = color;
			t.colorC = color;
			t.windingAdjusted = tri1.windingAdjusted;
			var tri0 = t;
			this666[this666.length] = tri0;
			var tri2 = tri.t1;
			var t1 = Type.createEmptyInstance(trilateral_tri_Triangle);
			t1.id = id;
			t1.ax = tri2.ax;
			t1.ay = tri2.ay;
			t1.bx = tri2.bx;
			t1.by = tri2.by;
			t1.cx = tri2.cx;
			t1.cy = tri2.cy;
			t1.mark = tri2.mark;
			t1.depth = 0;
			t1.alpha = 1.;
			t1.colorID = color;
			t1.colorA = color;
			t1.colorB = color;
			t1.colorC = color;
			t1.windingAdjusted = tri2.windingAdjusted;
			var tri11 = t1;
			this666[this666.length] = tri11;
			var startX = dx + scale + radiusW / 2;
			var startY = dy + scale + radiusH / 2;
			var px = startX;
			var py = startY;
			var _g1666 = 0;
			while(_g1666 < 7) {
				var col = _g1666++;
				var _g2100 = 0;
				while(_g2100 < 5) {
					var i667 = _g2100++;
					var _g3100 = $char.pixelShape;
					switch(_g3100[1]) {
					case 0:
						var _this1 = $char.shapes;
						var this667 = _this1.triangles;
						var id1 = _this1.refCount++;
						var this668 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
						var out = this668;
						var pi = Math.PI;
						var theta = pi / 2;
						var step = pi * 2 / 36;
						var bx1;
						var by1;
						var cx1;
						var cy1;
						var _g1667 = 0;
						var _g768 = 36;
						while(_g1667 < _g768) {
							var i668 = _g1667++;
							bx1 = px + radius * Math.sin(theta);
							by1 = py + radius * Math.cos(theta);
							theta += step;
							cx1 = px + radius * Math.sin(theta);
							cy1 = py + radius * Math.cos(theta);
							var tri3 = new trilateral_tri_Trilateral(px,py,bx1,by1,cx1,cy1);
							out[out.length] = tri3;
						}
						var triArr = out;
						var tri4;
						var _g769 = 0;
						while(_g769 < triArr.length) {
							var t2 = triArr[_g769];
							++_g769;
							if(t2 != null) {
								var t3 = Type.createEmptyInstance(trilateral_tri_Triangle);
								t3.id = id1;
								t3.ax = t2.ax;
								t3.ay = t2.ay;
								t3.bx = t2.bx;
								t3.by = t2.by;
								t3.cx = t2.cx;
								t3.cy = t2.cy;
								t3.mark = t2.mark;
								t3.depth = 0;
								t3.alpha = 1.;
								t3.colorID = colorID;
								t3.colorA = colorID;
								t3.colorB = colorID;
								t3.colorC = colorID;
								t3.windingAdjusted = t2.windingAdjusted;
								tri4 = t3;
								this667[this667.length] = tri4;
							}
						}
						break;
					case 1:
						var _this2 = $char.shapes;
						var this669 = _this2.triangles;
						var id2 = _this2.refCount++;
						var ax1 = 0.;
						var ay1 = 0.;
						var bx2 = 0.;
						var by2 = 0.;
						var cx2 = 0.;
						var cy2 = 0.;
						var dx3 = 0.;
						var dy3 = 0.;
						ax1 = px - radius;
						ay1 = py - radius;
						var lx = radius * 2;
						var ly = lx;
						bx2 = ax1 + lx;
						by2 = ay1;
						cx2 = bx2;
						cy2 = ay1 + ly;
						dx3 = ax1;
						dy3 = cy2;
						var tri5 = { t0 : new trilateral_tri_Trilateral(ax1,ay1,bx2,by2,dx3,dy3), t1 : new trilateral_tri_Trilateral(bx2,by2,cx2,cy2,dx3,dy3)};
						var tri6 = tri5.t0;
						var t4 = Type.createEmptyInstance(trilateral_tri_Triangle);
						t4.id = id2;
						t4.ax = tri6.ax;
						t4.ay = tri6.ay;
						t4.bx = tri6.bx;
						t4.by = tri6.by;
						t4.cx = tri6.cx;
						t4.cy = tri6.cy;
						t4.mark = tri6.mark;
						t4.depth = 0;
						t4.alpha = 1.;
						t4.colorID = colorID;
						t4.colorA = colorID;
						t4.colorB = colorID;
						t4.colorC = colorID;
						t4.windingAdjusted = tri6.windingAdjusted;
						var tri01 = t4;
						this669[this669.length] = tri01;
						var tri7 = tri5.t1;
						var t5 = Type.createEmptyInstance(trilateral_tri_Triangle);
						t5.id = id2;
						t5.ax = tri7.ax;
						t5.ay = tri7.ay;
						t5.bx = tri7.bx;
						t5.by = tri7.by;
						t5.cx = tri7.cx;
						t5.cy = tri7.cy;
						t5.mark = tri7.mark;
						t5.depth = 0;
						t5.alpha = 1.;
						t5.colorID = colorID;
						t5.colorA = colorID;
						t5.colorB = colorID;
						t5.colorC = colorID;
						t5.windingAdjusted = tri7.windingAdjusted;
						var tri12 = t5;
						this669[this669.length] = tri12;
						break;
					case 2:
						var _this3 = $char.shapes;
						var x = px - radiusW;
						var this670 = _this3.triangles;
						var id3 = _this3.refCount++;
						var ax2 = x;
						var ay2 = py - radiusH;
						var bx3 = x + radiusW * 2;
						var by3 = ay2;
						var cx3 = bx3;
						var cy3 = ay2 + radiusH * 2;
						var dx4 = x;
						var dy4 = cy3;
						var tri8 = { t0 : new trilateral_tri_Trilateral(ax2,ay2,bx3,by3,dx4,dy4), t1 : new trilateral_tri_Trilateral(bx3,by3,cx3,cy3,dx4,dy4)};
						var tri9 = tri8.t0;
						var t6 = Type.createEmptyInstance(trilateral_tri_Triangle);
						t6.id = id3;
						t6.ax = tri9.ax;
						t6.ay = tri9.ay;
						t6.bx = tri9.bx;
						t6.by = tri9.by;
						t6.cx = tri9.cx;
						t6.cy = tri9.cy;
						t6.mark = tri9.mark;
						t6.depth = 0;
						t6.alpha = 1.;
						t6.colorID = colorID;
						t6.colorA = colorID;
						t6.colorB = colorID;
						t6.colorC = colorID;
						t6.windingAdjusted = tri9.windingAdjusted;
						var tri02 = t6;
						this670[this670.length] = tri02;
						var tri10 = tri8.t1;
						var t7 = Type.createEmptyInstance(trilateral_tri_Triangle);
						t7.id = id3;
						t7.ax = tri10.ax;
						t7.ay = tri10.ay;
						t7.bx = tri10.bx;
						t7.by = tri10.by;
						t7.cx = tri10.cx;
						t7.cy = tri10.cy;
						t7.mark = tri10.mark;
						t7.depth = 0;
						t7.alpha = 1.;
						t7.colorID = colorID;
						t7.colorA = colorID;
						t7.colorB = colorID;
						t7.colorC = colorID;
						t7.windingAdjusted = tri10.windingAdjusted;
						var tri13 = t7;
						this670[this670.length] = tri13;
						break;
					case 3:
						var _this4 = $char.shapes;
						var x1 = px - radiusW;
						var this671 = _this4.triangles;
						var id4 = _this4.refCount++;
						var ax3 = x1;
						var ay3 = py - radiusH;
						var bx4 = x1 + radiusW * 2;
						var by4 = ay3;
						var cx4 = bx4;
						var cy4 = ay3 + radiusH * 2;
						var dx5 = x1;
						var dy5 = cy4;
						var tri14 = { t0 : new trilateral_tri_Trilateral(ax3,ay3,bx4,by4,dx5,dy5), t1 : new trilateral_tri_Trilateral(bx4,by4,cx4,cy4,dx5,dy5)};
						var tri15 = tri14.t0;
						var t8 = Type.createEmptyInstance(trilateral_tri_Triangle);
						t8.id = id4;
						t8.ax = tri15.ax;
						t8.ay = tri15.ay;
						t8.bx = tri15.bx;
						t8.by = tri15.by;
						t8.cx = tri15.cx;
						t8.cy = tri15.cy;
						t8.mark = tri15.mark;
						t8.depth = 0;
						t8.alpha = 1.;
						t8.colorID = colorID;
						t8.colorA = colorID;
						t8.colorB = colorID;
						t8.colorC = colorID;
						t8.windingAdjusted = tri15.windingAdjusted;
						var tri03 = t8;
						this671[this671.length] = tri03;
						var tri16 = tri14.t1;
						var t9 = Type.createEmptyInstance(trilateral_tri_Triangle);
						t9.id = id4;
						t9.ax = tri16.ax;
						t9.ay = tri16.ay;
						t9.bx = tri16.bx;
						t9.by = tri16.by;
						t9.cx = tri16.cx;
						t9.cy = tri16.cy;
						t9.mark = tri16.mark;
						t9.depth = 0;
						t9.alpha = 1.;
						t9.colorID = colorID;
						t9.colorA = colorID;
						t9.colorB = colorID;
						t9.colorC = colorID;
						t9.windingAdjusted = tri16.windingAdjusted;
						var tri17 = t9;
						this671[this671.length] = tri17;
						break;
					case 4:
						var _this5 = $char.shapes;
						var this672 = _this5.triangles;
						var id5 = _this5.refCount++;
						var pi1 = Math.PI;
						var omega = -pi1;
						var a0x = px + radius * Math.sin(omega);
						var a0y = py + radius * Math.cos(omega);
						omega += pi1 / 3;
						var a1x = px + radius * Math.sin(omega);
						var a1y = py + radius * Math.cos(omega);
						omega += pi1 / 3;
						var b0x = px + radius * Math.sin(omega);
						var b0y = py + radius * Math.cos(omega);
						omega += pi1 / 3;
						var b1x = px + radius * Math.sin(omega);
						var b1y = py + radius * Math.cos(omega);
						omega += pi1 / 3;
						var c0x = px + radius * Math.sin(omega);
						var c0y = py + radius * Math.cos(omega);
						omega += pi1 / 3;
						var c1x = px + radius * Math.sin(omega);
						var c1y = py + radius * Math.cos(omega);
						var tri18 = { t0 : new trilateral_tri_Trilateral(a0x,a0y,b0x,b0y,c0x,c0y), t1 : new trilateral_tri_Trilateral(a1x,a1y,b1x,b1y,c1x,c1y)};
						var tri19 = tri18.t0;
						var t10 = Type.createEmptyInstance(trilateral_tri_Triangle);
						t10.id = id5;
						t10.ax = tri19.ax;
						t10.ay = tri19.ay;
						t10.bx = tri19.bx;
						t10.by = tri19.by;
						t10.cx = tri19.cx;
						t10.cy = tri19.cy;
						t10.mark = tri19.mark;
						t10.depth = 0;
						t10.alpha = 1.;
						t10.colorID = colorID;
						t10.colorA = colorID;
						t10.colorB = colorID;
						t10.colorC = colorID;
						t10.windingAdjusted = tri19.windingAdjusted;
						var tri04 = t10;
						this672[this672.length] = tri04;
						var tri20 = tri18.t1;
						var t11 = Type.createEmptyInstance(trilateral_tri_Triangle);
						t11.id = id5;
						t11.ax = tri20.ax;
						t11.ay = tri20.ay;
						t11.bx = tri20.bx;
						t11.by = tri20.by;
						t11.cx = tri20.cx;
						t11.cy = tri20.cy;
						t11.mark = tri20.mark;
						t11.depth = 0;
						t11.alpha = 1.;
						t11.colorID = colorID;
						t11.colorA = colorID;
						t11.colorB = colorID;
						t11.colorC = colorID;
						t11.windingAdjusted = tri20.windingAdjusted;
						var tri110 = t11;
						this672[this672.length] = tri110;
						break;
					case 5:
						var _this6 = $char.shapes;
						var x2 = px - radiusW;
						var y = py - radiusH;
						var width = radiusW * 2;
						var height = radiusH * 2;
						var radius1 = radius / ($char.ratio * 2);
						var this673 = _this6.triangles;
						var id6 = _this6.refCount++;
						var this674 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
						var out1 = this674;
						var pi2 = Math.PI;
						var pi_2 = Math.PI / 2;
						var ax4 = x2 + radius1;
						var ay4 = y + radius1;
						var bx5 = x2 + width - radius1;
						var by5 = y + radius1;
						var cx5 = bx5;
						var cy5 = y + height - radius1;
						var dx6 = ax4;
						var dy6 = cy5;
						var tp_t1;
						var tp_t0;
						var ax5 = ax4;
						var ay5 = y;
						var bx6 = ax4 + (width - radius1 * 2);
						var by6 = ay5;
						var cx6 = bx6;
						var cy6 = ay5 + height;
						var dx7 = ax4;
						var dy7 = cy6;
						tp_t0 = new trilateral_tri_Trilateral(ax5,ay5,bx6,by6,dx7,dy7);
						tp_t1 = new trilateral_tri_Trilateral(bx6,by6,cx6,cy6,dx7,dy7);
						out1[out1.length] = tp_t0;
						out1[out1.length] = tp_t1;
						var dimY = height - 2 * radius1;
						var tp_t11;
						var tp_t01;
						var ax6 = x2;
						var ay6 = ay4;
						var bx7 = x2 + radius1;
						var by7 = ay6;
						var cx7 = bx7;
						var cy7 = ay6 + dimY;
						var dx8 = x2;
						var dy8 = cy7;
						tp_t01 = new trilateral_tri_Trilateral(ax6,ay6,bx7,by7,dx8,dy8);
						tp_t11 = new trilateral_tri_Trilateral(bx7,by7,cx7,cy7,dx8,dy8);
						out1[out1.length] = tp_t01;
						out1[out1.length] = tp_t11;
						var tp_t12;
						var tp_t02;
						var ax7 = bx5;
						var ay7 = by5;
						var bx8 = bx5 + radius1;
						var by8 = ay7;
						var cx8 = bx8;
						var cy8 = ay7 + dimY;
						var dx9 = bx5;
						var dy9 = cy8;
						tp_t02 = new trilateral_tri_Trilateral(ax7,ay7,bx8,by8,dx9,dy9);
						tp_t12 = new trilateral_tri_Trilateral(bx8,by8,cx8,cy8,dx9,dy9);
						out1[out1.length] = tp_t02;
						out1[out1.length] = tp_t12;
						var beta = -pi2;
						var gamma = -pi_2;
						var this675 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
						var out2 = this675;
						var pi3 = Math.PI;
						var step1 = pi3 * 2 / 36;
						var dif;
						switch(trilateral_angle_DifferencePreference.CLOCKWISE[1]) {
						case 0:
							var f;
							if(beta >= 0 && beta > Math.PI) {
								f = beta;
							} else {
								var a = beta % (2 * Math.PI);
								if(a >= 0) {
									f = a;
								} else {
									f = a + 2 * Math.PI;
								}
							}
							var this676 = f;
							var za = this676;
							var f1;
							if(gamma >= 0 && gamma > Math.PI) {
								f1 = gamma;
							} else {
								var a1 = gamma % (2 * Math.PI);
								if(a1 >= 0) {
									f1 = a1;
								} else {
									f1 = a1 + 2 * Math.PI;
								}
							}
							var this677 = f1;
							var zb = this677;
							var fa = beta;
							var fb = gamma;
							var theta1 = Math.abs(beta - gamma);
							var clockwise = beta < gamma;
							var dif1 = clockwise ? theta1 : -theta1;
							if(dif1 > 0) {
								dif = dif1;
							} else {
								dif = 2 * Math.PI + dif1;
							}
							break;
						case 1:
							var f2;
							if(beta >= 0 && beta > Math.PI) {
								f2 = beta;
							} else {
								var a2 = beta % (2 * Math.PI);
								if(a2 >= 0) {
									f2 = a2;
								} else {
									f2 = a2 + 2 * Math.PI;
								}
							}
							var this678 = f2;
							var za1 = this678;
							var f3;
							if(gamma >= 0 && gamma > Math.PI) {
								f3 = gamma;
							} else {
								var a3 = gamma % (2 * Math.PI);
								if(a3 >= 0) {
									f3 = a3;
								} else {
									f3 = a3 + 2 * Math.PI;
								}
							}
							var this679 = f3;
							var zb1 = this679;
							var fa1 = beta;
							var fb1 = gamma;
							var theta2 = Math.abs(beta - gamma);
							var clockwise1 = beta < gamma;
							var dif2 = clockwise1 ? theta2 : -theta2;
							if(dif2 < 0) {
								dif = dif2;
							} else {
								dif = -2 * Math.PI + dif2;
							}
							break;
						case 2:
							var f4;
							if(beta >= 0 && beta > Math.PI) {
								f4 = beta;
							} else {
								var a4 = beta % (2 * Math.PI);
								if(a4 >= 0) {
									f4 = a4;
								} else {
									f4 = a4 + 2 * Math.PI;
								}
							}
							var this680 = f4;
							var za2 = this680;
							var f5;
							if(gamma >= 0 && gamma > Math.PI) {
								f5 = gamma;
							} else {
								var a5 = gamma % (2 * Math.PI);
								if(a5 >= 0) {
									f5 = a5;
								} else {
									f5 = a5 + 2 * Math.PI;
								}
							}
							var this681 = f5;
							var zb2 = this681;
							var fa2 = beta;
							var fb2 = gamma;
							var theta3 = Math.abs(beta - gamma);
							var smallest = theta3 <= Math.PI;
							var clockwise2 = beta < gamma;
							var dif3 = clockwise2 ? theta3 : -theta3;
							if(smallest) {
								dif = dif3;
							} else if(clockwise2) {
								dif = -(2 * Math.PI - theta3);
							} else {
								dif = 2 * Math.PI - theta3;
							}
							break;
						case 3:
							var f6;
							if(beta >= 0 && beta > Math.PI) {
								f6 = beta;
							} else {
								var a6 = beta % (2 * Math.PI);
								if(a6 >= 0) {
									f6 = a6;
								} else {
									f6 = a6 + 2 * Math.PI;
								}
							}
							var this682 = f6;
							var za3 = this682;
							var f7;
							if(gamma >= 0 && gamma > Math.PI) {
								f7 = gamma;
							} else {
								var a7 = gamma % (2 * Math.PI);
								if(a7 >= 0) {
									f7 = a7;
								} else {
									f7 = a7 + 2 * Math.PI;
								}
							}
							var this683 = f7;
							var zb3 = this683;
							var fa3 = beta;
							var fb3 = gamma;
							var theta4 = Math.abs(beta - gamma);
							var largest = theta4 > Math.PI;
							var clockwise3 = beta < gamma;
							var dif4 = clockwise3 ? theta4 : -theta4;
							if(largest) {
								dif = dif4;
							} else if(clockwise3) {
								dif = -(2 * Math.PI - theta4);
							} else {
								dif = 2 * Math.PI - theta4;
							}
							break;
						}
						var positive = dif >= 0;
						var totalSteps = Math.ceil(Math.abs(dif) / step1);
						var step2 = dif / totalSteps;
						var angle = beta;
						var cx9;
						var cy9;
						var bx9 = 0;
						var by9 = 0;
						var _g1668 = 0;
						var _g770 = totalSteps + 1;
						while(_g1668 < _g770) {
							var i669 = _g1668++;
							cx9 = ax4 + radius1 * Math.sin(angle);
							cy9 = ay4 + radius1 * Math.cos(angle);
							if(i669 != 0) {
								var t12 = new trilateral_tri_Trilateral(ax4,ay4,bx9,by9,cx9,cy9);
								out2[out2.length] = t12;
							}
							angle += step2;
							bx9 = cx9;
							by9 = cy9;
						}
						var triArr1 = out2;
						var _g771 = 0;
						while(_g771 < triArr1.length) {
							var t13 = triArr1[_g771];
							++_g771;
							out1[out1.length] = t13;
						}
						var this684 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
						var out3 = this684;
						var pi4 = Math.PI;
						var step3 = pi4 * 2 / 36;
						var dif5;
						switch(trilateral_angle_DifferencePreference.CLOCKWISE[1]) {
						case 0:
							var f8;
							if(pi_2 >= 0 && pi_2 > Math.PI) {
								f8 = pi_2;
							} else {
								var a8 = pi_2 % (2 * Math.PI);
								if(a8 >= 0) {
									f8 = a8;
								} else {
									f8 = a8 + 2 * Math.PI;
								}
							}
							var this685 = f8;
							var za4 = this685;
							var f9;
							if(pi2 >= 0 && pi2 > Math.PI) {
								f9 = pi2;
							} else {
								var a9 = pi2 % (2 * Math.PI);
								if(a9 >= 0) {
									f9 = a9;
								} else {
									f9 = a9 + 2 * Math.PI;
								}
							}
							var this686 = f9;
							var zb4 = this686;
							var fa4 = pi_2;
							var fb4 = pi2;
							var theta5 = Math.abs(pi_2 - pi2);
							var clockwise4 = pi_2 < pi2;
							var dif6 = clockwise4 ? theta5 : -theta5;
							if(dif6 > 0) {
								dif5 = dif6;
							} else {
								dif5 = 2 * Math.PI + dif6;
							}
							break;
						case 1:
							var f10;
							if(pi_2 >= 0 && pi_2 > Math.PI) {
								f10 = pi_2;
							} else {
								var a10 = pi_2 % (2 * Math.PI);
								if(a10 >= 0) {
									f10 = a10;
								} else {
									f10 = a10 + 2 * Math.PI;
								}
							}
							var this687 = f10;
							var za5 = this687;
							var f11;
							if(pi2 >= 0 && pi2 > Math.PI) {
								f11 = pi2;
							} else {
								var a11 = pi2 % (2 * Math.PI);
								if(a11 >= 0) {
									f11 = a11;
								} else {
									f11 = a11 + 2 * Math.PI;
								}
							}
							var this688 = f11;
							var zb5 = this688;
							var fa5 = pi_2;
							var fb5 = pi2;
							var theta6 = Math.abs(pi_2 - pi2);
							var clockwise5 = pi_2 < pi2;
							var dif7 = clockwise5 ? theta6 : -theta6;
							if(dif7 < 0) {
								dif5 = dif7;
							} else {
								dif5 = -2 * Math.PI + dif7;
							}
							break;
						case 2:
							var f12;
							if(pi_2 >= 0 && pi_2 > Math.PI) {
								f12 = pi_2;
							} else {
								var a12 = pi_2 % (2 * Math.PI);
								if(a12 >= 0) {
									f12 = a12;
								} else {
									f12 = a12 + 2 * Math.PI;
								}
							}
							var this689 = f12;
							var za6 = this689;
							var f13;
							if(pi2 >= 0 && pi2 > Math.PI) {
								f13 = pi2;
							} else {
								var a13 = pi2 % (2 * Math.PI);
								if(a13 >= 0) {
									f13 = a13;
								} else {
									f13 = a13 + 2 * Math.PI;
								}
							}
							var this690 = f13;
							var zb6 = this690;
							var fa6 = pi_2;
							var fb6 = pi2;
							var theta7 = Math.abs(pi_2 - pi2);
							var smallest1 = theta7 <= Math.PI;
							var clockwise6 = pi_2 < pi2;
							var dif8 = clockwise6 ? theta7 : -theta7;
							if(smallest1) {
								dif5 = dif8;
							} else if(clockwise6) {
								dif5 = -(2 * Math.PI - theta7);
							} else {
								dif5 = 2 * Math.PI - theta7;
							}
							break;
						case 3:
							var f14;
							if(pi_2 >= 0 && pi_2 > Math.PI) {
								f14 = pi_2;
							} else {
								var a14 = pi_2 % (2 * Math.PI);
								if(a14 >= 0) {
									f14 = a14;
								} else {
									f14 = a14 + 2 * Math.PI;
								}
							}
							var this691 = f14;
							var za7 = this691;
							var f15;
							if(pi2 >= 0 && pi2 > Math.PI) {
								f15 = pi2;
							} else {
								var a15 = pi2 % (2 * Math.PI);
								if(a15 >= 0) {
									f15 = a15;
								} else {
									f15 = a15 + 2 * Math.PI;
								}
							}
							var this692 = f15;
							var zb7 = this692;
							var fa7 = pi_2;
							var fb7 = pi2;
							var theta8 = Math.abs(pi_2 - pi2);
							var largest1 = theta8 > Math.PI;
							var clockwise7 = pi_2 < pi2;
							var dif9 = clockwise7 ? theta8 : -theta8;
							if(largest1) {
								dif5 = dif9;
							} else if(clockwise7) {
								dif5 = -(2 * Math.PI - theta8);
							} else {
								dif5 = 2 * Math.PI - theta8;
							}
							break;
						}
						var positive1 = dif5 >= 0;
						var totalSteps1 = Math.ceil(Math.abs(dif5) / step3);
						var step4 = dif5 / totalSteps1;
						var angle1 = pi_2;
						var cx10;
						var cy10;
						var bx10 = 0;
						var by10 = 0;
						var _g1669 = 0;
						var _g772 = totalSteps1 + 1;
						while(_g1669 < _g772) {
							var i670 = _g1669++;
							cx10 = bx5 + radius1 * Math.sin(angle1);
							cy10 = by5 + radius1 * Math.cos(angle1);
							if(i670 != 0) {
								var t14 = new trilateral_tri_Trilateral(bx5,by5,bx10,by10,cx10,cy10);
								out3[out3.length] = t14;
							}
							angle1 += step4;
							bx10 = cx10;
							by10 = cy10;
						}
						var triArr2 = out3;
						var _g773 = 0;
						while(_g773 < triArr2.length) {
							var t15 = triArr2[_g773];
							++_g773;
							out1[out1.length] = t15;
						}
						var this693 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
						var out4 = this693;
						var pi5 = Math.PI;
						var step5 = pi5 * 2 / 36;
						var dif10;
						switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE[1]) {
						case 0:
							var f16;
							if(pi_2 >= 0 && pi_2 > Math.PI) {
								f16 = pi_2;
							} else {
								var a16 = pi_2 % (2 * Math.PI);
								if(a16 >= 0) {
									f16 = a16;
								} else {
									f16 = a16 + 2 * Math.PI;
								}
							}
							var this694 = f16;
							var za8 = this694;
							var f17;
							if(0 > Math.PI) {
								f17 = 0;
							} else {
								var a17 = 0 % (2 * Math.PI);
								if(a17 >= 0) {
									f17 = a17;
								} else {
									f17 = a17 + 2 * Math.PI;
								}
							}
							var this695 = f17;
							var zb8 = this695;
							var fa8 = pi_2;
							var fb8 = 0;
							var theta9 = Math.abs(pi_2);
							var clockwise8 = pi_2 < 0;
							var dif11 = clockwise8 ? theta9 : -theta9;
							if(dif11 > 0) {
								dif10 = dif11;
							} else {
								dif10 = 2 * Math.PI + dif11;
							}
							break;
						case 1:
							var f18;
							if(pi_2 >= 0 && pi_2 > Math.PI) {
								f18 = pi_2;
							} else {
								var a18 = pi_2 % (2 * Math.PI);
								if(a18 >= 0) {
									f18 = a18;
								} else {
									f18 = a18 + 2 * Math.PI;
								}
							}
							var this696 = f18;
							var za9 = this696;
							var f19;
							if(0 > Math.PI) {
								f19 = 0;
							} else {
								var a19 = 0 % (2 * Math.PI);
								if(a19 >= 0) {
									f19 = a19;
								} else {
									f19 = a19 + 2 * Math.PI;
								}
							}
							var this697 = f19;
							var zb9 = this697;
							var fa9 = pi_2;
							var fb9 = 0;
							var theta10 = Math.abs(pi_2);
							var clockwise9 = pi_2 < 0;
							var dif12 = clockwise9 ? theta10 : -theta10;
							if(dif12 < 0) {
								dif10 = dif12;
							} else {
								dif10 = -2 * Math.PI + dif12;
							}
							break;
						case 2:
							var f20;
							if(pi_2 >= 0 && pi_2 > Math.PI) {
								f20 = pi_2;
							} else {
								var a20 = pi_2 % (2 * Math.PI);
								if(a20 >= 0) {
									f20 = a20;
								} else {
									f20 = a20 + 2 * Math.PI;
								}
							}
							var this698 = f20;
							var za10 = this698;
							var f21;
							if(0 > Math.PI) {
								f21 = 0;
							} else {
								var a21 = 0 % (2 * Math.PI);
								if(a21 >= 0) {
									f21 = a21;
								} else {
									f21 = a21 + 2 * Math.PI;
								}
							}
							var this699 = f21;
							var zb10 = this699;
							var fa10 = pi_2;
							var fb10 = 0;
							var theta11 = Math.abs(pi_2);
							var smallest2 = theta11 <= Math.PI;
							var clockwise10 = pi_2 < 0;
							var dif13 = clockwise10 ? theta11 : -theta11;
							if(smallest2) {
								dif10 = dif13;
							} else if(clockwise10) {
								dif10 = -(2 * Math.PI - theta11);
							} else {
								dif10 = 2 * Math.PI - theta11;
							}
							break;
						case 3:
							var f22;
							if(pi_2 >= 0 && pi_2 > Math.PI) {
								f22 = pi_2;
							} else {
								var a22 = pi_2 % (2 * Math.PI);
								if(a22 >= 0) {
									f22 = a22;
								} else {
									f22 = a22 + 2 * Math.PI;
								}
							}
							var this700 = f22;
							var za11 = this700;
							var f23;
							if(0 > Math.PI) {
								f23 = 0;
							} else {
								var a23 = 0 % (2 * Math.PI);
								if(a23 >= 0) {
									f23 = a23;
								} else {
									f23 = a23 + 2 * Math.PI;
								}
							}
							var this701 = f23;
							var zb11 = this701;
							var fa11 = pi_2;
							var fb11 = 0;
							var theta12 = Math.abs(pi_2);
							var largest2 = theta12 > Math.PI;
							var clockwise11 = pi_2 < 0;
							var dif14 = clockwise11 ? theta12 : -theta12;
							if(largest2) {
								dif10 = dif14;
							} else if(clockwise11) {
								dif10 = -(2 * Math.PI - theta12);
							} else {
								dif10 = 2 * Math.PI - theta12;
							}
							break;
						}
						var positive2 = dif10 >= 0;
						var totalSteps2 = Math.ceil(Math.abs(dif10) / step5);
						var step6 = dif10 / totalSteps2;
						var angle2 = pi_2;
						var cx11;
						var cy11;
						var bx11 = 0;
						var by11 = 0;
						var _g1670 = 0;
						var _g774 = totalSteps2 + 1;
						while(_g1670 < _g774) {
							var i671 = _g1670++;
							cx11 = cx5 + radius1 * Math.sin(angle2);
							cy11 = cy5 + radius1 * Math.cos(angle2);
							if(i671 != 0) {
								var t16 = new trilateral_tri_Trilateral(cx5,cy5,bx11,by11,cx11,cy11);
								out4[out4.length] = t16;
							}
							angle2 += step6;
							bx11 = cx11;
							by11 = cy11;
						}
						var triArr3 = out4;
						var _g775 = 0;
						while(_g775 < triArr3.length) {
							var t17 = triArr3[_g775];
							++_g775;
							out1[out1.length] = t17;
						}
						var gamma1 = -pi_2;
						var this702 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
						var out5 = this702;
						var pi6 = Math.PI;
						var step7 = pi6 * 2 / 36;
						var dif15;
						switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE[1]) {
						case 0:
							var f24;
							if(0 > Math.PI) {
								f24 = 0;
							} else {
								var a24 = 0 % (2 * Math.PI);
								if(a24 >= 0) {
									f24 = a24;
								} else {
									f24 = a24 + 2 * Math.PI;
								}
							}
							var this703 = f24;
							var za12 = this703;
							var f25;
							if(gamma1 >= 0 && gamma1 > Math.PI) {
								f25 = gamma1;
							} else {
								var a25 = gamma1 % (2 * Math.PI);
								if(a25 >= 0) {
									f25 = a25;
								} else {
									f25 = a25 + 2 * Math.PI;
								}
							}
							var this704 = f25;
							var zb12 = this704;
							var fa12 = 0;
							var fb12 = gamma1;
							var theta13 = Math.abs(0 - gamma1);
							var clockwise12 = 0 < gamma1;
							var dif16 = clockwise12 ? theta13 : -theta13;
							if(dif16 > 0) {
								dif15 = dif16;
							} else {
								dif15 = 2 * Math.PI + dif16;
							}
							break;
						case 1:
							var f26;
							if(0 > Math.PI) {
								f26 = 0;
							} else {
								var a26 = 0 % (2 * Math.PI);
								if(a26 >= 0) {
									f26 = a26;
								} else {
									f26 = a26 + 2 * Math.PI;
								}
							}
							var this705 = f26;
							var za13 = this705;
							var f27;
							if(gamma1 >= 0 && gamma1 > Math.PI) {
								f27 = gamma1;
							} else {
								var a27 = gamma1 % (2 * Math.PI);
								if(a27 >= 0) {
									f27 = a27;
								} else {
									f27 = a27 + 2 * Math.PI;
								}
							}
							var this706 = f27;
							var zb13 = this706;
							var fa13 = 0;
							var fb13 = gamma1;
							var theta14 = Math.abs(0 - gamma1);
							var clockwise13 = 0 < gamma1;
							var dif17 = clockwise13 ? theta14 : -theta14;
							if(dif17 < 0) {
								dif15 = dif17;
							} else {
								dif15 = -2 * Math.PI + dif17;
							}
							break;
						case 2:
							var f28;
							if(0 > Math.PI) {
								f28 = 0;
							} else {
								var a28 = 0 % (2 * Math.PI);
								if(a28 >= 0) {
									f28 = a28;
								} else {
									f28 = a28 + 2 * Math.PI;
								}
							}
							var this707 = f28;
							var za14 = this707;
							var f29;
							if(gamma1 >= 0 && gamma1 > Math.PI) {
								f29 = gamma1;
							} else {
								var a29 = gamma1 % (2 * Math.PI);
								if(a29 >= 0) {
									f29 = a29;
								} else {
									f29 = a29 + 2 * Math.PI;
								}
							}
							var this708 = f29;
							var zb14 = this708;
							var fa14 = 0;
							var fb14 = gamma1;
							var theta15 = Math.abs(0 - gamma1);
							var smallest3 = theta15 <= Math.PI;
							var clockwise14 = 0 < gamma1;
							var dif18 = clockwise14 ? theta15 : -theta15;
							if(smallest3) {
								dif15 = dif18;
							} else if(clockwise14) {
								dif15 = -(2 * Math.PI - theta15);
							} else {
								dif15 = 2 * Math.PI - theta15;
							}
							break;
						case 3:
							var f30;
							if(0 > Math.PI) {
								f30 = 0;
							} else {
								var a30 = 0 % (2 * Math.PI);
								if(a30 >= 0) {
									f30 = a30;
								} else {
									f30 = a30 + 2 * Math.PI;
								}
							}
							var this709 = f30;
							var za15 = this709;
							var f31;
							if(gamma1 >= 0 && gamma1 > Math.PI) {
								f31 = gamma1;
							} else {
								var a31 = gamma1 % (2 * Math.PI);
								if(a31 >= 0) {
									f31 = a31;
								} else {
									f31 = a31 + 2 * Math.PI;
								}
							}
							var this710 = f31;
							var zb15 = this710;
							var fa15 = 0;
							var fb15 = gamma1;
							var theta16 = Math.abs(0 - gamma1);
							var largest3 = theta16 > Math.PI;
							var clockwise15 = 0 < gamma1;
							var dif19 = clockwise15 ? theta16 : -theta16;
							if(largest3) {
								dif15 = dif19;
							} else if(clockwise15) {
								dif15 = -(2 * Math.PI - theta16);
							} else {
								dif15 = 2 * Math.PI - theta16;
							}
							break;
						}
						var positive3 = dif15 >= 0;
						var totalSteps3 = Math.ceil(Math.abs(dif15) / step7);
						var step8 = dif15 / totalSteps3;
						var angle3 = 0;
						var cx12;
						var cy12;
						var bx12 = 0;
						var by12 = 0;
						var _g1671 = 0;
						var _g776 = totalSteps3 + 1;
						while(_g1671 < _g776) {
							var i672 = _g1671++;
							cx12 = dx6 + radius1 * Math.sin(angle3);
							cy12 = dy6 + radius1 * Math.cos(angle3);
							if(i672 != 0) {
								var t18 = new trilateral_tri_Trilateral(dx6,dy6,bx12,by12,cx12,cy12);
								out5[out5.length] = t18;
							}
							angle3 += step8;
							bx12 = cx12;
							by12 = cy12;
						}
						var triArr4 = out5;
						var _g777 = 0;
						while(_g777 < triArr4.length) {
							var t19 = triArr4[_g777];
							++_g777;
							out1[out1.length] = t19;
						}
						var triArr5 = out1;
						var tri21;
						var _g778 = 0;
						while(_g778 < triArr5.length) {
							var t20 = triArr5[_g778];
							++_g778;
							if(t20 != null) {
								var t21 = Type.createEmptyInstance(trilateral_tri_Triangle);
								t21.id = id6;
								t21.ax = t20.ax;
								t21.ay = t20.ay;
								t21.bx = t20.bx;
								t21.by = t20.by;
								t21.cx = t20.cx;
								t21.cy = t20.cy;
								t21.mark = t20.mark;
								t21.depth = 0;
								t21.alpha = 1.;
								t21.colorID = colorID;
								t21.colorA = colorID;
								t21.colorB = colorID;
								t21.colorC = colorID;
								t21.windingAdjusted = t20.windingAdjusted;
								tri21 = t21;
								this673[this673.length] = tri21;
							}
						}
						break;
					case 6:
						var _this7 = $char.shapes;
						var x3 = px - radiusW;
						var y1 = py - radiusH;
						var width1 = radiusW * 2;
						var height1 = radiusH * 2;
						var radius2 = radius / ($char.ratio * 2);
						var this711 = _this7.triangles;
						var id7 = _this7.refCount++;
						var this712 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
						var out6 = this712;
						var pi7 = Math.PI;
						var pi_21 = Math.PI / 2;
						var ax8 = x3 + radius2;
						var ay8 = y1 + radius2;
						var bx13 = x3 + width1 - radius2;
						var by13 = y1 + radius2;
						var cx13 = bx13;
						var cy13 = y1 + height1 - radius2;
						var dx10 = ax8;
						var dy10 = cy13;
						var tp_t13;
						var tp_t03;
						var ax9 = ax8;
						var ay9 = y1;
						var bx14 = ax8 + (width1 - radius2 * 2);
						var by14 = ay9;
						var cx14 = bx14;
						var cy14 = ay9 + height1;
						var dx11 = ax8;
						var dy11 = cy14;
						tp_t03 = new trilateral_tri_Trilateral(ax9,ay9,bx14,by14,dx11,dy11);
						tp_t13 = new trilateral_tri_Trilateral(bx14,by14,cx14,cy14,dx11,dy11);
						out6[out6.length] = tp_t03;
						out6[out6.length] = tp_t13;
						var dimY1 = height1 - 2 * radius2;
						var tp_t14;
						var tp_t04;
						var ax10 = x3;
						var ay10 = ay8;
						var bx15 = x3 + radius2;
						var by15 = ay10;
						var cx15 = bx15;
						var cy15 = ay10 + dimY1;
						var dx12 = x3;
						var dy12 = cy15;
						tp_t04 = new trilateral_tri_Trilateral(ax10,ay10,bx15,by15,dx12,dy12);
						tp_t14 = new trilateral_tri_Trilateral(bx15,by15,cx15,cy15,dx12,dy12);
						out6[out6.length] = tp_t04;
						out6[out6.length] = tp_t14;
						var tp_t15;
						var tp_t05;
						var ax11 = bx13;
						var ay11 = by13;
						var bx16 = bx13 + radius2;
						var by16 = ay11;
						var cx16 = bx16;
						var cy16 = ay11 + dimY1;
						var dx13 = bx13;
						var dy13 = cy16;
						tp_t05 = new trilateral_tri_Trilateral(ax11,ay11,bx16,by16,dx13,dy13);
						tp_t15 = new trilateral_tri_Trilateral(bx16,by16,cx16,cy16,dx13,dy13);
						out6[out6.length] = tp_t05;
						out6[out6.length] = tp_t15;
						var beta1 = -pi7;
						var gamma2 = -pi_21;
						var this713 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
						var out7 = this713;
						var pi8 = Math.PI;
						var step9 = pi8 * 2 / 36;
						var dif20;
						switch(trilateral_angle_DifferencePreference.CLOCKWISE[1]) {
						case 0:
							var f32;
							if(beta1 >= 0 && beta1 > Math.PI) {
								f32 = beta1;
							} else {
								var a32 = beta1 % (2 * Math.PI);
								if(a32 >= 0) {
									f32 = a32;
								} else {
									f32 = a32 + 2 * Math.PI;
								}
							}
							var this714 = f32;
							var za16 = this714;
							var f33;
							if(gamma2 >= 0 && gamma2 > Math.PI) {
								f33 = gamma2;
							} else {
								var a33 = gamma2 % (2 * Math.PI);
								if(a33 >= 0) {
									f33 = a33;
								} else {
									f33 = a33 + 2 * Math.PI;
								}
							}
							var this715 = f33;
							var zb16 = this715;
							var fa16 = beta1;
							var fb16 = gamma2;
							var theta17 = Math.abs(beta1 - gamma2);
							var clockwise16 = beta1 < gamma2;
							var dif21 = clockwise16 ? theta17 : -theta17;
							if(dif21 > 0) {
								dif20 = dif21;
							} else {
								dif20 = 2 * Math.PI + dif21;
							}
							break;
						case 1:
							var f34;
							if(beta1 >= 0 && beta1 > Math.PI) {
								f34 = beta1;
							} else {
								var a34 = beta1 % (2 * Math.PI);
								if(a34 >= 0) {
									f34 = a34;
								} else {
									f34 = a34 + 2 * Math.PI;
								}
							}
							var this716 = f34;
							var za17 = this716;
							var f35;
							if(gamma2 >= 0 && gamma2 > Math.PI) {
								f35 = gamma2;
							} else {
								var a35 = gamma2 % (2 * Math.PI);
								if(a35 >= 0) {
									f35 = a35;
								} else {
									f35 = a35 + 2 * Math.PI;
								}
							}
							var this717 = f35;
							var zb17 = this717;
							var fa17 = beta1;
							var fb17 = gamma2;
							var theta18 = Math.abs(beta1 - gamma2);
							var clockwise17 = beta1 < gamma2;
							var dif22 = clockwise17 ? theta18 : -theta18;
							if(dif22 < 0) {
								dif20 = dif22;
							} else {
								dif20 = -2 * Math.PI + dif22;
							}
							break;
						case 2:
							var f36;
							if(beta1 >= 0 && beta1 > Math.PI) {
								f36 = beta1;
							} else {
								var a36 = beta1 % (2 * Math.PI);
								if(a36 >= 0) {
									f36 = a36;
								} else {
									f36 = a36 + 2 * Math.PI;
								}
							}
							var this718 = f36;
							var za18 = this718;
							var f37;
							if(gamma2 >= 0 && gamma2 > Math.PI) {
								f37 = gamma2;
							} else {
								var a37 = gamma2 % (2 * Math.PI);
								if(a37 >= 0) {
									f37 = a37;
								} else {
									f37 = a37 + 2 * Math.PI;
								}
							}
							var this719 = f37;
							var zb18 = this719;
							var fa18 = beta1;
							var fb18 = gamma2;
							var theta19 = Math.abs(beta1 - gamma2);
							var smallest4 = theta19 <= Math.PI;
							var clockwise18 = beta1 < gamma2;
							var dif23 = clockwise18 ? theta19 : -theta19;
							if(smallest4) {
								dif20 = dif23;
							} else if(clockwise18) {
								dif20 = -(2 * Math.PI - theta19);
							} else {
								dif20 = 2 * Math.PI - theta19;
							}
							break;
						case 3:
							var f38;
							if(beta1 >= 0 && beta1 > Math.PI) {
								f38 = beta1;
							} else {
								var a38 = beta1 % (2 * Math.PI);
								if(a38 >= 0) {
									f38 = a38;
								} else {
									f38 = a38 + 2 * Math.PI;
								}
							}
							var this720 = f38;
							var za19 = this720;
							var f39;
							if(gamma2 >= 0 && gamma2 > Math.PI) {
								f39 = gamma2;
							} else {
								var a39 = gamma2 % (2 * Math.PI);
								if(a39 >= 0) {
									f39 = a39;
								} else {
									f39 = a39 + 2 * Math.PI;
								}
							}
							var this721 = f39;
							var zb19 = this721;
							var fa19 = beta1;
							var fb19 = gamma2;
							var theta20 = Math.abs(beta1 - gamma2);
							var largest4 = theta20 > Math.PI;
							var clockwise19 = beta1 < gamma2;
							var dif24 = clockwise19 ? theta20 : -theta20;
							if(largest4) {
								dif20 = dif24;
							} else if(clockwise19) {
								dif20 = -(2 * Math.PI - theta20);
							} else {
								dif20 = 2 * Math.PI - theta20;
							}
							break;
						}
						var positive4 = dif20 >= 0;
						var totalSteps4 = Math.ceil(Math.abs(dif20) / step9);
						var step10 = dif20 / totalSteps4;
						var angle4 = beta1;
						var cx17;
						var cy17;
						var bx17 = 0;
						var by17 = 0;
						var _g1672 = 0;
						var _g779 = totalSteps4 + 1;
						while(_g1672 < _g779) {
							var i673 = _g1672++;
							cx17 = ax8 + radius2 * Math.sin(angle4);
							cy17 = ay8 + radius2 * Math.cos(angle4);
							if(i673 != 0) {
								var t22 = new trilateral_tri_Trilateral(ax8,ay8,bx17,by17,cx17,cy17);
								out7[out7.length] = t22;
							}
							angle4 += step10;
							bx17 = cx17;
							by17 = cy17;
						}
						var triArr6 = out7;
						var _g780 = 0;
						while(_g780 < triArr6.length) {
							var t23 = triArr6[_g780];
							++_g780;
							out6[out6.length] = t23;
						}
						var this722 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
						var out8 = this722;
						var pi9 = Math.PI;
						var step11 = pi9 * 2 / 36;
						var dif25;
						switch(trilateral_angle_DifferencePreference.CLOCKWISE[1]) {
						case 0:
							var f40;
							if(pi_21 >= 0 && pi_21 > Math.PI) {
								f40 = pi_21;
							} else {
								var a40 = pi_21 % (2 * Math.PI);
								if(a40 >= 0) {
									f40 = a40;
								} else {
									f40 = a40 + 2 * Math.PI;
								}
							}
							var this723 = f40;
							var za20 = this723;
							var f41;
							if(pi7 >= 0 && pi7 > Math.PI) {
								f41 = pi7;
							} else {
								var a41 = pi7 % (2 * Math.PI);
								if(a41 >= 0) {
									f41 = a41;
								} else {
									f41 = a41 + 2 * Math.PI;
								}
							}
							var this724 = f41;
							var zb20 = this724;
							var fa20 = pi_21;
							var fb20 = pi7;
							var theta21 = Math.abs(pi_21 - pi7);
							var clockwise20 = pi_21 < pi7;
							var dif26 = clockwise20 ? theta21 : -theta21;
							if(dif26 > 0) {
								dif25 = dif26;
							} else {
								dif25 = 2 * Math.PI + dif26;
							}
							break;
						case 1:
							var f42;
							if(pi_21 >= 0 && pi_21 > Math.PI) {
								f42 = pi_21;
							} else {
								var a42 = pi_21 % (2 * Math.PI);
								if(a42 >= 0) {
									f42 = a42;
								} else {
									f42 = a42 + 2 * Math.PI;
								}
							}
							var this725 = f42;
							var za21 = this725;
							var f43;
							if(pi7 >= 0 && pi7 > Math.PI) {
								f43 = pi7;
							} else {
								var a43 = pi7 % (2 * Math.PI);
								if(a43 >= 0) {
									f43 = a43;
								} else {
									f43 = a43 + 2 * Math.PI;
								}
							}
							var this726 = f43;
							var zb21 = this726;
							var fa21 = pi_21;
							var fb21 = pi7;
							var theta22 = Math.abs(pi_21 - pi7);
							var clockwise21 = pi_21 < pi7;
							var dif27 = clockwise21 ? theta22 : -theta22;
							if(dif27 < 0) {
								dif25 = dif27;
							} else {
								dif25 = -2 * Math.PI + dif27;
							}
							break;
						case 2:
							var f44;
							if(pi_21 >= 0 && pi_21 > Math.PI) {
								f44 = pi_21;
							} else {
								var a44 = pi_21 % (2 * Math.PI);
								if(a44 >= 0) {
									f44 = a44;
								} else {
									f44 = a44 + 2 * Math.PI;
								}
							}
							var this727 = f44;
							var za22 = this727;
							var f45;
							if(pi7 >= 0 && pi7 > Math.PI) {
								f45 = pi7;
							} else {
								var a45 = pi7 % (2 * Math.PI);
								if(a45 >= 0) {
									f45 = a45;
								} else {
									f45 = a45 + 2 * Math.PI;
								}
							}
							var this728 = f45;
							var zb22 = this728;
							var fa22 = pi_21;
							var fb22 = pi7;
							var theta23 = Math.abs(pi_21 - pi7);
							var smallest5 = theta23 <= Math.PI;
							var clockwise22 = pi_21 < pi7;
							var dif28 = clockwise22 ? theta23 : -theta23;
							if(smallest5) {
								dif25 = dif28;
							} else if(clockwise22) {
								dif25 = -(2 * Math.PI - theta23);
							} else {
								dif25 = 2 * Math.PI - theta23;
							}
							break;
						case 3:
							var f46;
							if(pi_21 >= 0 && pi_21 > Math.PI) {
								f46 = pi_21;
							} else {
								var a46 = pi_21 % (2 * Math.PI);
								if(a46 >= 0) {
									f46 = a46;
								} else {
									f46 = a46 + 2 * Math.PI;
								}
							}
							var this729 = f46;
							var za23 = this729;
							var f47;
							if(pi7 >= 0 && pi7 > Math.PI) {
								f47 = pi7;
							} else {
								var a47 = pi7 % (2 * Math.PI);
								if(a47 >= 0) {
									f47 = a47;
								} else {
									f47 = a47 + 2 * Math.PI;
								}
							}
							var this730 = f47;
							var zb23 = this730;
							var fa23 = pi_21;
							var fb23 = pi7;
							var theta24 = Math.abs(pi_21 - pi7);
							var largest5 = theta24 > Math.PI;
							var clockwise23 = pi_21 < pi7;
							var dif29 = clockwise23 ? theta24 : -theta24;
							if(largest5) {
								dif25 = dif29;
							} else if(clockwise23) {
								dif25 = -(2 * Math.PI - theta24);
							} else {
								dif25 = 2 * Math.PI - theta24;
							}
							break;
						}
						var positive5 = dif25 >= 0;
						var totalSteps5 = Math.ceil(Math.abs(dif25) / step11);
						var step12 = dif25 / totalSteps5;
						var angle5 = pi_21;
						var cx18;
						var cy18;
						var bx18 = 0;
						var by18 = 0;
						var _g1673 = 0;
						var _g781 = totalSteps5 + 1;
						while(_g1673 < _g781) {
							var i674 = _g1673++;
							cx18 = bx13 + radius2 * Math.sin(angle5);
							cy18 = by13 + radius2 * Math.cos(angle5);
							if(i674 != 0) {
								var t24 = new trilateral_tri_Trilateral(bx13,by13,bx18,by18,cx18,cy18);
								out8[out8.length] = t24;
							}
							angle5 += step12;
							bx18 = cx18;
							by18 = cy18;
						}
						var triArr7 = out8;
						var _g782 = 0;
						while(_g782 < triArr7.length) {
							var t25 = triArr7[_g782];
							++_g782;
							out6[out6.length] = t25;
						}
						var this731 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
						var out9 = this731;
						var pi10 = Math.PI;
						var step13 = pi10 * 2 / 36;
						var dif30;
						switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE[1]) {
						case 0:
							var f48;
							if(pi_21 >= 0 && pi_21 > Math.PI) {
								f48 = pi_21;
							} else {
								var a48 = pi_21 % (2 * Math.PI);
								if(a48 >= 0) {
									f48 = a48;
								} else {
									f48 = a48 + 2 * Math.PI;
								}
							}
							var this732 = f48;
							var za24 = this732;
							var f49;
							if(0 > Math.PI) {
								f49 = 0;
							} else {
								var a49 = 0 % (2 * Math.PI);
								if(a49 >= 0) {
									f49 = a49;
								} else {
									f49 = a49 + 2 * Math.PI;
								}
							}
							var this733 = f49;
							var zb24 = this733;
							var fa24 = pi_21;
							var fb24 = 0;
							var theta25 = Math.abs(pi_21);
							var clockwise24 = pi_21 < 0;
							var dif31 = clockwise24 ? theta25 : -theta25;
							if(dif31 > 0) {
								dif30 = dif31;
							} else {
								dif30 = 2 * Math.PI + dif31;
							}
							break;
						case 1:
							var f50;
							if(pi_21 >= 0 && pi_21 > Math.PI) {
								f50 = pi_21;
							} else {
								var a50 = pi_21 % (2 * Math.PI);
								if(a50 >= 0) {
									f50 = a50;
								} else {
									f50 = a50 + 2 * Math.PI;
								}
							}
							var this734 = f50;
							var za25 = this734;
							var f51;
							if(0 > Math.PI) {
								f51 = 0;
							} else {
								var a51 = 0 % (2 * Math.PI);
								if(a51 >= 0) {
									f51 = a51;
								} else {
									f51 = a51 + 2 * Math.PI;
								}
							}
							var this735 = f51;
							var zb25 = this735;
							var fa25 = pi_21;
							var fb25 = 0;
							var theta26 = Math.abs(pi_21);
							var clockwise25 = pi_21 < 0;
							var dif32 = clockwise25 ? theta26 : -theta26;
							if(dif32 < 0) {
								dif30 = dif32;
							} else {
								dif30 = -2 * Math.PI + dif32;
							}
							break;
						case 2:
							var f52;
							if(pi_21 >= 0 && pi_21 > Math.PI) {
								f52 = pi_21;
							} else {
								var a52 = pi_21 % (2 * Math.PI);
								if(a52 >= 0) {
									f52 = a52;
								} else {
									f52 = a52 + 2 * Math.PI;
								}
							}
							var this736 = f52;
							var za26 = this736;
							var f53;
							if(0 > Math.PI) {
								f53 = 0;
							} else {
								var a53 = 0 % (2 * Math.PI);
								if(a53 >= 0) {
									f53 = a53;
								} else {
									f53 = a53 + 2 * Math.PI;
								}
							}
							var this737 = f53;
							var zb26 = this737;
							var fa26 = pi_21;
							var fb26 = 0;
							var theta27 = Math.abs(pi_21);
							var smallest6 = theta27 <= Math.PI;
							var clockwise26 = pi_21 < 0;
							var dif33 = clockwise26 ? theta27 : -theta27;
							if(smallest6) {
								dif30 = dif33;
							} else if(clockwise26) {
								dif30 = -(2 * Math.PI - theta27);
							} else {
								dif30 = 2 * Math.PI - theta27;
							}
							break;
						case 3:
							var f54;
							if(pi_21 >= 0 && pi_21 > Math.PI) {
								f54 = pi_21;
							} else {
								var a54 = pi_21 % (2 * Math.PI);
								if(a54 >= 0) {
									f54 = a54;
								} else {
									f54 = a54 + 2 * Math.PI;
								}
							}
							var this738 = f54;
							var za27 = this738;
							var f55;
							if(0 > Math.PI) {
								f55 = 0;
							} else {
								var a55 = 0 % (2 * Math.PI);
								if(a55 >= 0) {
									f55 = a55;
								} else {
									f55 = a55 + 2 * Math.PI;
								}
							}
							var this739 = f55;
							var zb27 = this739;
							var fa27 = pi_21;
							var fb27 = 0;
							var theta28 = Math.abs(pi_21);
							var largest6 = theta28 > Math.PI;
							var clockwise27 = pi_21 < 0;
							var dif34 = clockwise27 ? theta28 : -theta28;
							if(largest6) {
								dif30 = dif34;
							} else if(clockwise27) {
								dif30 = -(2 * Math.PI - theta28);
							} else {
								dif30 = 2 * Math.PI - theta28;
							}
							break;
						}
						var positive6 = dif30 >= 0;
						var totalSteps6 = Math.ceil(Math.abs(dif30) / step13);
						var step14 = dif30 / totalSteps6;
						var angle6 = pi_21;
						var cx19;
						var cy19;
						var bx19 = 0;
						var by19 = 0;
						var _g1674 = 0;
						var _g783 = totalSteps6 + 1;
						while(_g1674 < _g783) {
							var i675 = _g1674++;
							cx19 = cx13 + radius2 * Math.sin(angle6);
							cy19 = cy13 + radius2 * Math.cos(angle6);
							if(i675 != 0) {
								var t26 = new trilateral_tri_Trilateral(cx13,cy13,bx19,by19,cx19,cy19);
								out9[out9.length] = t26;
							}
							angle6 += step14;
							bx19 = cx19;
							by19 = cy19;
						}
						var triArr8 = out9;
						var _g784 = 0;
						while(_g784 < triArr8.length) {
							var t27 = triArr8[_g784];
							++_g784;
							out6[out6.length] = t27;
						}
						var gamma3 = -pi_21;
						var this740 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
						var out10 = this740;
						var pi11 = Math.PI;
						var step15 = pi11 * 2 / 36;
						var dif35;
						switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE[1]) {
						case 0:
							var f56;
							if(0 > Math.PI) {
								f56 = 0;
							} else {
								var a56 = 0 % (2 * Math.PI);
								if(a56 >= 0) {
									f56 = a56;
								} else {
									f56 = a56 + 2 * Math.PI;
								}
							}
							var this741 = f56;
							var za28 = this741;
							var f57;
							if(gamma3 >= 0 && gamma3 > Math.PI) {
								f57 = gamma3;
							} else {
								var a57 = gamma3 % (2 * Math.PI);
								if(a57 >= 0) {
									f57 = a57;
								} else {
									f57 = a57 + 2 * Math.PI;
								}
							}
							var this742 = f57;
							var zb28 = this742;
							var fa28 = 0;
							var fb28 = gamma3;
							var theta29 = Math.abs(0 - gamma3);
							var clockwise28 = 0 < gamma3;
							var dif36 = clockwise28 ? theta29 : -theta29;
							if(dif36 > 0) {
								dif35 = dif36;
							} else {
								dif35 = 2 * Math.PI + dif36;
							}
							break;
						case 1:
							var f58;
							if(0 > Math.PI) {
								f58 = 0;
							} else {
								var a58 = 0 % (2 * Math.PI);
								if(a58 >= 0) {
									f58 = a58;
								} else {
									f58 = a58 + 2 * Math.PI;
								}
							}
							var this743 = f58;
							var za29 = this743;
							var f59;
							if(gamma3 >= 0 && gamma3 > Math.PI) {
								f59 = gamma3;
							} else {
								var a59 = gamma3 % (2 * Math.PI);
								if(a59 >= 0) {
									f59 = a59;
								} else {
									f59 = a59 + 2 * Math.PI;
								}
							}
							var this744 = f59;
							var zb29 = this744;
							var fa29 = 0;
							var fb29 = gamma3;
							var theta30 = Math.abs(0 - gamma3);
							var clockwise29 = 0 < gamma3;
							var dif37 = clockwise29 ? theta30 : -theta30;
							if(dif37 < 0) {
								dif35 = dif37;
							} else {
								dif35 = -2 * Math.PI + dif37;
							}
							break;
						case 2:
							var f60;
							if(0 > Math.PI) {
								f60 = 0;
							} else {
								var a60 = 0 % (2 * Math.PI);
								if(a60 >= 0) {
									f60 = a60;
								} else {
									f60 = a60 + 2 * Math.PI;
								}
							}
							var this745 = f60;
							var za30 = this745;
							var f61;
							if(gamma3 >= 0 && gamma3 > Math.PI) {
								f61 = gamma3;
							} else {
								var a61 = gamma3 % (2 * Math.PI);
								if(a61 >= 0) {
									f61 = a61;
								} else {
									f61 = a61 + 2 * Math.PI;
								}
							}
							var this746 = f61;
							var zb30 = this746;
							var fa30 = 0;
							var fb30 = gamma3;
							var theta31 = Math.abs(0 - gamma3);
							var smallest7 = theta31 <= Math.PI;
							var clockwise30 = 0 < gamma3;
							var dif38 = clockwise30 ? theta31 : -theta31;
							if(smallest7) {
								dif35 = dif38;
							} else if(clockwise30) {
								dif35 = -(2 * Math.PI - theta31);
							} else {
								dif35 = 2 * Math.PI - theta31;
							}
							break;
						case 3:
							var f62;
							if(0 > Math.PI) {
								f62 = 0;
							} else {
								var a62 = 0 % (2 * Math.PI);
								if(a62 >= 0) {
									f62 = a62;
								} else {
									f62 = a62 + 2 * Math.PI;
								}
							}
							var this747 = f62;
							var za31 = this747;
							var f63;
							if(gamma3 >= 0 && gamma3 > Math.PI) {
								f63 = gamma3;
							} else {
								var a63 = gamma3 % (2 * Math.PI);
								if(a63 >= 0) {
									f63 = a63;
								} else {
									f63 = a63 + 2 * Math.PI;
								}
							}
							var this748 = f63;
							var zb31 = this748;
							var fa31 = 0;
							var fb31 = gamma3;
							var theta32 = Math.abs(0 - gamma3);
							var largest7 = theta32 > Math.PI;
							var clockwise31 = 0 < gamma3;
							var dif39 = clockwise31 ? theta32 : -theta32;
							if(largest7) {
								dif35 = dif39;
							} else if(clockwise31) {
								dif35 = -(2 * Math.PI - theta32);
							} else {
								dif35 = 2 * Math.PI - theta32;
							}
							break;
						}
						var positive7 = dif35 >= 0;
						var totalSteps7 = Math.ceil(Math.abs(dif35) / step15);
						var step16 = dif35 / totalSteps7;
						var angle7 = 0;
						var cx20;
						var cy20;
						var bx20 = 0;
						var by20 = 0;
						var _g1675 = 0;
						var _g785 = totalSteps7 + 1;
						while(_g1675 < _g785) {
							var i676 = _g1675++;
							cx20 = dx10 + radius2 * Math.sin(angle7);
							cy20 = dy10 + radius2 * Math.cos(angle7);
							if(i676 != 0) {
								var t28 = new trilateral_tri_Trilateral(dx10,dy10,bx20,by20,cx20,cy20);
								out10[out10.length] = t28;
							}
							angle7 += step16;
							bx20 = cx20;
							by20 = cy20;
						}
						var triArr9 = out10;
						var _g786 = 0;
						while(_g786 < triArr9.length) {
							var t29 = triArr9[_g786];
							++_g786;
							out6[out6.length] = t29;
						}
						var triArr10 = out6;
						var tri22;
						var _g787 = 0;
						while(_g787 < triArr10.length) {
							var t30 = triArr10[_g787];
							++_g787;
							if(t30 != null) {
								var t31 = Type.createEmptyInstance(trilateral_tri_Triangle);
								t31.id = id7;
								t31.ax = t30.ax;
								t31.ay = t30.ay;
								t31.bx = t30.bx;
								t31.by = t30.by;
								t31.cx = t30.cx;
								t31.cy = t30.cy;
								t31.mark = t30.mark;
								t31.depth = 0;
								t31.alpha = 1.;
								t31.colorID = colorID;
								t31.colorA = colorID;
								t31.colorB = colorID;
								t31.colorC = colorID;
								t31.windingAdjusted = t30.windingAdjusted;
								tri22 = t31;
								this711[this711.length] = tri22;
							}
						}
						break;
					}
					px += dx1;
				}
				px = startX;
				py += dy1;
			}
			var endIndex = $char.shapes.refCount - 1;
			this.display[i666] = $char;
			$char.updateColor();
			dx += dw + 0.5 * scale;
		}
	}
	,update: function() {
		trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$.displayLeft(this.arrDotMatrix,6);
		var _g1 = 0;
		var _g = this.display.length;
		while(_g1 < _g) {
			var i = _g1++;
			var $char = this.display[i];
			$char.updateColor();
		}
	}
	,render: function(framebuffer) {
		var g = framebuffer.get_g2();
		g.begin(null,-15198184);
		var tri;
		if(this.triangles.length != 0) {
			var triangles = this.triangles;
			var gameColors = this.colors;
			var s = 1;
			var ox = 1;
			var oy = 1;
			var _g1 = 0;
			var _g = triangles.length;
			while(_g1 < _g) {
				var i = _g1++;
				tri = triangles[i];
				g.set_color(gameColors[tri.colorID]);
				g.fillTriangle(ox + tri.ax * s,oy + tri.ay * s,ox + tri.bx * s,oy + tri.by * s,ox + tri.cx * s,oy + tri.cy * s);
			}
		}
		g.end();
	}
	,renderTriangles: function(g) {
		var tri;
		if(this.triangles.length == 0) {
			return;
		}
		var triangles = this.triangles;
		var gameColors = this.colors;
		var s = 1;
		var ox = 1;
		var oy = 1;
		var _g1 = 0;
		var _g = triangles.length;
		while(_g1 < _g) {
			var i = _g1++;
			tri = triangles[i];
			g.set_color(gameColors[tri.colorID]);
			g.fillTriangle(ox + tri.ax * s,oy + tri.ay * s,ox + tri.bx * s,oy + tri.by * s,ox + tri.cx * s,oy + tri.cy * s);
		}
	}
	,__class__: Main
};
Math.__name__ = true;
var Reflect = function() { };
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = true;
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		return null;
	}
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
var Std = function() { };
$hxClasses["Std"] = Std;
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x,10);
	if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) {
		v = parseInt(x);
	}
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var StringTools = function() { };
$hxClasses["StringTools"] = StringTools;
StringTools.__name__ = true;
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return HxOverrides.substr(s,slen - elen,elen) == end;
	} else {
		return false;
	}
};
StringTools.hex = function(n,digits) {
	var s = "";
	var hexChars = "0123456789ABCDEF";
	while(true) {
		s = hexChars.charAt(n & 15) + s;
		n >>>= 4;
		if(!(n > 0)) {
			break;
		}
	}
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
var Type = function() { };
$hxClasses["Type"] = Type;
Type.__name__ = true;
Type.resolveClass = function(name) {
	var cl = $hxClasses[name];
	if(cl == null || !cl.__name__) {
		return null;
	}
	return cl;
};
Type.resolveEnum = function(name) {
	var e = $hxClasses[name];
	if(e == null || !e.__ename__) {
		return null;
	}
	return e;
};
Type.createEmptyInstance = function(cl) {
	function empty() {}; empty.prototype = cl.prototype;
	return new empty();
};
Type.createEnum = function(e,constr,params) {
	var f = Reflect.field(e,constr);
	if(f == null) {
		throw new js__$Boot_HaxeError("No such constructor " + constr);
	}
	if(Reflect.isFunction(f)) {
		if(params == null) {
			throw new js__$Boot_HaxeError("Constructor " + constr + " need parameters");
		}
		return f.apply(e,params);
	}
	if(params != null && params.length != 0) {
		throw new js__$Boot_HaxeError("Constructor " + constr + " does not need parameters");
	}
	return f;
};
Type.getInstanceFields = function(c) {
	var a = [];
	for(var i in c.prototype) a.push(i);
	HxOverrides.remove(a,"__class__");
	HxOverrides.remove(a,"__properties__");
	return a;
};
var _$UInt_UInt_$Impl_$ = {};
$hxClasses["_UInt.UInt_Impl_"] = _$UInt_UInt_$Impl_$;
_$UInt_UInt_$Impl_$.__name__ = true;
_$UInt_UInt_$Impl_$.gt = function(a,b) {
	var aNeg = a < 0;
	var bNeg = b < 0;
	if(aNeg != bNeg) {
		return aNeg;
	} else {
		return a > b;
	}
};
_$UInt_UInt_$Impl_$.gte = function(a,b) {
	var aNeg = a < 0;
	var bNeg = b < 0;
	if(aNeg != bNeg) {
		return aNeg;
	} else {
		return a >= b;
	}
};
_$UInt_UInt_$Impl_$.toFloat = function(this1) {
	var $int = this1;
	if($int < 0) {
		return 4294967296.0 + $int;
	} else {
		return $int + 0.0;
	}
};
var haxe_IMap = function() { };
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = true;
haxe_IMap.prototype = {
	iterator: null
	,__class__: haxe_IMap
};
var haxe__$Int64__$_$_$Int64 = function(high,low) {
	this.high = high;
	this.low = low;
};
$hxClasses["haxe._Int64.___Int64"] = haxe__$Int64__$_$_$Int64;
haxe__$Int64__$_$_$Int64.__name__ = true;
haxe__$Int64__$_$_$Int64.prototype = {
	high: null
	,low: null
	,__class__: haxe__$Int64__$_$_$Int64
};
var haxe_Log = function() { };
$hxClasses["haxe.Log"] = haxe_Log;
haxe_Log.__name__ = true;
haxe_Log.trace = function(v,infos) {
	js_Boot.__trace(v,infos);
};
var haxe__$Unserializer_DefaultResolver = function() {
};
$hxClasses["haxe._Unserializer.DefaultResolver"] = haxe__$Unserializer_DefaultResolver;
haxe__$Unserializer_DefaultResolver.__name__ = true;
haxe__$Unserializer_DefaultResolver.prototype = {
	resolveClass: function(name) {
		return Type.resolveClass(name);
	}
	,resolveEnum: function(name) {
		return Type.resolveEnum(name);
	}
	,__class__: haxe__$Unserializer_DefaultResolver
};
var haxe_Unserializer = function(buf) {
	this.buf = buf;
	this.length = buf.length;
	this.pos = 0;
	this.scache = [];
	this.cache = [];
	var r = haxe_Unserializer.DEFAULT_RESOLVER;
	if(r == null) {
		r = new haxe__$Unserializer_DefaultResolver();
		haxe_Unserializer.DEFAULT_RESOLVER = r;
	}
	this.resolver = r;
};
$hxClasses["haxe.Unserializer"] = haxe_Unserializer;
haxe_Unserializer.__name__ = true;
haxe_Unserializer.initCodes = function() {
	var codes = [];
	var _g1 = 0;
	var _g = haxe_Unserializer.BASE64.length;
	while(_g1 < _g) {
		var i = _g1++;
		codes[haxe_Unserializer.BASE64.charCodeAt(i)] = i;
	}
	return codes;
};
haxe_Unserializer.run = function(v) {
	return new haxe_Unserializer(v).unserialize();
};
haxe_Unserializer.prototype = {
	buf: null
	,pos: null
	,length: null
	,cache: null
	,scache: null
	,resolver: null
	,readDigits: function() {
		var k = 0;
		var s = false;
		var fpos = this.pos;
		while(true) {
			var c = this.buf.charCodeAt(this.pos);
			if(c != c) {
				break;
			}
			if(c == 45) {
				if(this.pos != fpos) {
					break;
				}
				s = true;
				this.pos++;
				continue;
			}
			if(c < 48 || c > 57) {
				break;
			}
			k = k * 10 + (c - 48);
			this.pos++;
		}
		if(s) {
			k *= -1;
		}
		return k;
	}
	,readFloat: function() {
		var p1 = this.pos;
		while(true) {
			var c = this.buf.charCodeAt(this.pos);
			if(c != c) {
				break;
			}
			if(c >= 43 && c < 58 || c == 101 || c == 69) {
				this.pos++;
			} else {
				break;
			}
		}
		return parseFloat(HxOverrides.substr(this.buf,p1,this.pos - p1));
	}
	,unserializeObject: function(o) {
		while(true) {
			if(this.pos >= this.length) {
				throw new js__$Boot_HaxeError("Invalid object");
			}
			if(this.buf.charCodeAt(this.pos) == 103) {
				break;
			}
			var k = this.unserialize();
			if(typeof(k) != "string") {
				throw new js__$Boot_HaxeError("Invalid object key");
			}
			var v = this.unserialize();
			o[k] = v;
		}
		this.pos++;
	}
	,unserializeEnum: function(edecl,tag) {
		if(this.buf.charCodeAt(this.pos++) != 58) {
			throw new js__$Boot_HaxeError("Invalid enum format");
		}
		var nargs = this.readDigits();
		if(nargs == 0) {
			return Type.createEnum(edecl,tag);
		}
		var args = [];
		while(nargs-- > 0) args.push(this.unserialize());
		return Type.createEnum(edecl,tag,args);
	}
	,unserialize: function() {
		var _g = this.buf.charCodeAt(this.pos++);
		switch(_g) {
		case 65:
			var name = this.unserialize();
			var cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw new js__$Boot_HaxeError("Class not found " + name);
			}
			return cl;
		case 66:
			var name1 = this.unserialize();
			var e = this.resolver.resolveEnum(name1);
			if(e == null) {
				throw new js__$Boot_HaxeError("Enum not found " + name1);
			}
			return e;
		case 67:
			var name2 = this.unserialize();
			var cl1 = this.resolver.resolveClass(name2);
			if(cl1 == null) {
				throw new js__$Boot_HaxeError("Class not found " + name2);
			}
			var o = Type.createEmptyInstance(cl1);
			this.cache.push(o);
			o.hxUnserialize(this);
			if(this.buf.charCodeAt(this.pos++) != 103) {
				throw new js__$Boot_HaxeError("Invalid custom data");
			}
			return o;
		case 77:
			var h = new haxe_ds_ObjectMap();
			this.cache.push(h);
			var buf = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) {
				var s = this.unserialize();
				h.set(s,this.unserialize());
			}
			this.pos++;
			return h;
		case 82:
			var n = this.readDigits();
			if(n < 0 || n >= this.scache.length) {
				throw new js__$Boot_HaxeError("Invalid string reference");
			}
			return this.scache[n];
		case 97:
			var buf1 = this.buf;
			var a = [];
			this.cache.push(a);
			while(true) {
				var c = this.buf.charCodeAt(this.pos);
				if(c == 104) {
					this.pos++;
					break;
				}
				if(c == 117) {
					this.pos++;
					var n1 = this.readDigits();
					a[a.length + n1 - 1] = null;
				} else {
					a.push(this.unserialize());
				}
			}
			return a;
		case 98:
			var h1 = new haxe_ds_StringMap();
			this.cache.push(h1);
			var buf2 = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) {
				var s1 = this.unserialize();
				var value = this.unserialize();
				if(__map_reserved[s1] != null) {
					h1.setReserved(s1,value);
				} else {
					h1.h[s1] = value;
				}
			}
			this.pos++;
			return h1;
		case 99:
			var name3 = this.unserialize();
			var cl2 = this.resolver.resolveClass(name3);
			if(cl2 == null) {
				throw new js__$Boot_HaxeError("Class not found " + name3);
			}
			var o1 = Type.createEmptyInstance(cl2);
			this.cache.push(o1);
			this.unserializeObject(o1);
			return o1;
		case 100:
			return this.readFloat();
		case 102:
			return false;
		case 105:
			return this.readDigits();
		case 106:
			var name4 = this.unserialize();
			var edecl = this.resolver.resolveEnum(name4);
			if(edecl == null) {
				throw new js__$Boot_HaxeError("Enum not found " + name4);
			}
			this.pos++;
			var index = this.readDigits();
			var tag = edecl.__constructs__.slice()[index];
			if(tag == null) {
				throw new js__$Boot_HaxeError("Unknown enum index " + name4 + "@" + index);
			}
			var e1 = this.unserializeEnum(edecl,tag);
			this.cache.push(e1);
			return e1;
		case 107:
			return NaN;
		case 108:
			var l = new List();
			this.cache.push(l);
			var buf3 = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) l.add(this.unserialize());
			this.pos++;
			return l;
		case 109:
			return -Infinity;
		case 110:
			return null;
		case 111:
			var o2 = { };
			this.cache.push(o2);
			this.unserializeObject(o2);
			return o2;
		case 112:
			return Infinity;
		case 113:
			var h2 = new haxe_ds_IntMap();
			this.cache.push(h2);
			var buf4 = this.buf;
			var c1 = this.buf.charCodeAt(this.pos++);
			while(c1 == 58) {
				var i = this.readDigits();
				var value1 = this.unserialize();
				h2.h[i] = value1;
				c1 = this.buf.charCodeAt(this.pos++);
			}
			if(c1 != 104) {
				throw new js__$Boot_HaxeError("Invalid IntMap format");
			}
			return h2;
		case 114:
			var n2 = this.readDigits();
			if(n2 < 0 || n2 >= this.cache.length) {
				throw new js__$Boot_HaxeError("Invalid reference");
			}
			return this.cache[n2];
		case 115:
			var len = this.readDigits();
			var buf5 = this.buf;
			if(this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len) {
				throw new js__$Boot_HaxeError("Invalid bytes length");
			}
			var codes = haxe_Unserializer.CODES;
			if(codes == null) {
				codes = haxe_Unserializer.initCodes();
				haxe_Unserializer.CODES = codes;
			}
			var i1 = this.pos;
			var rest = len & 3;
			var size = (len >> 2) * 3 + (rest >= 2 ? rest - 1 : 0);
			var max = i1 + (len - rest);
			var bytes = new haxe_io_Bytes(new ArrayBuffer(size));
			var bpos = 0;
			while(i1 < max) {
				var c11 = codes[buf5.charCodeAt(i1++)];
				var c2 = codes[buf5.charCodeAt(i1++)];
				bytes.b[bpos++] = (c11 << 2 | c2 >> 4) & 255;
				var c3 = codes[buf5.charCodeAt(i1++)];
				bytes.b[bpos++] = (c2 << 4 | c3 >> 2) & 255;
				var c4 = codes[buf5.charCodeAt(i1++)];
				bytes.b[bpos++] = (c3 << 6 | c4) & 255;
			}
			if(rest >= 2) {
				var c12 = codes[buf5.charCodeAt(i1++)];
				var c21 = codes[buf5.charCodeAt(i1++)];
				bytes.b[bpos++] = (c12 << 2 | c21 >> 4) & 255;
				if(rest == 3) {
					var c31 = codes[buf5.charCodeAt(i1++)];
					bytes.b[bpos++] = (c21 << 4 | c31 >> 2) & 255;
				}
			}
			this.pos += len;
			this.cache.push(bytes);
			return bytes;
		case 116:
			return true;
		case 118:
			var d;
			if(this.buf.charCodeAt(this.pos) >= 48 && this.buf.charCodeAt(this.pos) <= 57 && this.buf.charCodeAt(this.pos + 1) >= 48 && this.buf.charCodeAt(this.pos + 1) <= 57 && this.buf.charCodeAt(this.pos + 2) >= 48 && this.buf.charCodeAt(this.pos + 2) <= 57 && this.buf.charCodeAt(this.pos + 3) >= 48 && this.buf.charCodeAt(this.pos + 3) <= 57 && this.buf.charCodeAt(this.pos + 4) == 45) {
				d = HxOverrides.strDate(HxOverrides.substr(this.buf,this.pos,19));
				this.pos += 19;
			} else {
				var t = this.readFloat();
				d = new Date(t);
			}
			this.cache.push(d);
			return d;
		case 119:
			var name5 = this.unserialize();
			var edecl1 = this.resolver.resolveEnum(name5);
			if(edecl1 == null) {
				throw new js__$Boot_HaxeError("Enum not found " + name5);
			}
			var e2 = this.unserializeEnum(edecl1,this.unserialize());
			this.cache.push(e2);
			return e2;
		case 120:
			throw js__$Boot_HaxeError.wrap(this.unserialize());
			break;
		case 121:
			var len1 = this.readDigits();
			if(this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len1) {
				throw new js__$Boot_HaxeError("Invalid string length");
			}
			var s2 = HxOverrides.substr(this.buf,this.pos,len1);
			this.pos += len1;
			s2 = decodeURIComponent(s2.split("+").join(" "));
			this.scache.push(s2);
			return s2;
		case 122:
			return 0;
		default:
		}
		this.pos--;
		throw new js__$Boot_HaxeError("Invalid char " + this.buf.charAt(this.pos) + " at position " + this.pos);
	}
	,__class__: haxe_Unserializer
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
$hxClasses["haxe.io.Bytes"] = haxe_io_Bytes;
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofString = function(s) {
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.ofData = function(b) {
	var hb = b.hxBytes;
	if(hb != null) {
		return hb;
	}
	return new haxe_io_Bytes(b);
};
haxe_io_Bytes.prototype = {
	length: null
	,b: null
	,data: null
	,blit: function(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	}
	,sub: function(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	,getDouble: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getFloat64(pos,true);
	}
	,getFloat: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getFloat32(pos,true);
	}
	,setDouble: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setFloat64(pos,v,true);
	}
	,setFloat: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setFloat32(pos,v,true);
	}
	,getUInt16: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getUint16(pos,true);
	}
	,getInt32: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getInt32(pos,true);
	}
	,setInt32: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setInt32(pos,v,true);
	}
	,getString: function(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		var s = "";
		var b = this.b;
		var fcc = String.fromCharCode;
		var i = pos;
		var max = pos + len;
		while(i < max) {
			var c = b[i++];
			if(c < 128) {
				if(c == 0) {
					break;
				}
				s += fcc(c);
			} else if(c < 224) {
				s += fcc((c & 63) << 6 | b[i++] & 127);
			} else if(c < 240) {
				var c2 = b[i++];
				s += fcc((c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127);
			} else {
				var c21 = b[i++];
				var c3 = b[i++];
				var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
				s += fcc((u >> 10) + 55232);
				s += fcc(u & 1023 | 56320);
			}
		}
		return s;
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
	,__class__: haxe_io_Bytes
};
var haxe_crypto_Base64 = function() { };
$hxClasses["haxe.crypto.Base64"] = haxe_crypto_Base64;
haxe_crypto_Base64.__name__ = true;
haxe_crypto_Base64.encode = function(bytes,complement) {
	if(complement == null) {
		complement = true;
	}
	var str = new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).encodeBytes(bytes).toString();
	if(complement) {
		var _g = bytes.length % 3;
		switch(_g) {
		case 1:
			str += "==";
			break;
		case 2:
			str += "=";
			break;
		default:
		}
	}
	return str;
};
var haxe_crypto_BaseCode = function(base) {
	var len = base.length;
	var nbits = 1;
	while(len > 1 << nbits) ++nbits;
	if(nbits > 8 || len != 1 << nbits) {
		throw new js__$Boot_HaxeError("BaseCode : base length must be a power of two.");
	}
	this.base = base;
	this.nbits = nbits;
};
$hxClasses["haxe.crypto.BaseCode"] = haxe_crypto_BaseCode;
haxe_crypto_BaseCode.__name__ = true;
haxe_crypto_BaseCode.prototype = {
	base: null
	,nbits: null
	,encodeBytes: function(b) {
		var nbits = this.nbits;
		var base = this.base;
		var size = b.length * 8 / nbits | 0;
		var out = new haxe_io_Bytes(new ArrayBuffer(size + (b.length * 8 % nbits == 0 ? 0 : 1)));
		var buf = 0;
		var curbits = 0;
		var mask = (1 << nbits) - 1;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < nbits) {
				curbits += 8;
				buf <<= 8;
				buf |= b.b[pin++];
			}
			curbits -= nbits;
			out.b[pout++] = base.b[buf >> curbits & mask] & 255;
		}
		if(curbits > 0) {
			out.b[pout++] = base.b[buf << nbits - curbits & mask] & 255;
		}
		return out;
	}
	,__class__: haxe_crypto_BaseCode
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
$hxClasses["haxe.ds.IntMap"] = haxe_ds_IntMap;
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	h: null
	,keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) {
			a.push(key | 0);
		}
		return HxOverrides.iter(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i];
		}};
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
$hxClasses["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap;
haxe_ds_ObjectMap.__name__ = true;
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	h: null
	,set: function(key,value) {
		var id = key.__id__ || (key.__id__ = ++haxe_ds_ObjectMap.count);
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return HxOverrides.iter(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i.__id__];
		}};
	}
	,__class__: haxe_ds_ObjectMap
};
var haxe_ds__$StringMap_StringMapIterator = function(map,keys) {
	this.map = map;
	this.keys = keys;
	this.index = 0;
	this.count = keys.length;
};
$hxClasses["haxe.ds._StringMap.StringMapIterator"] = haxe_ds__$StringMap_StringMapIterator;
haxe_ds__$StringMap_StringMapIterator.__name__ = true;
haxe_ds__$StringMap_StringMapIterator.prototype = {
	map: null
	,keys: null
	,index: null
	,count: null
	,hasNext: function() {
		return this.index < this.count;
	}
	,next: function() {
		var _this = this.map;
		var key = this.keys[this.index++];
		if(__map_reserved[key] != null) {
			return _this.getReserved(key);
		} else {
			return _this.h[key];
		}
	}
	,__class__: haxe_ds__$StringMap_StringMapIterator
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
$hxClasses["haxe.ds.StringMap"] = haxe_ds_StringMap;
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	h: null
	,rh: null
	,setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,existsReserved: function(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	,arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
	,iterator: function() {
		return new haxe_ds__$StringMap_StringMapIterator(this,this.arrayKeys());
	}
	,__class__: haxe_ds_StringMap
};
var haxe_io_BytesBuffer = function() {
	this.b = [];
};
$hxClasses["haxe.io.BytesBuffer"] = haxe_io_BytesBuffer;
haxe_io_BytesBuffer.__name__ = true;
haxe_io_BytesBuffer.prototype = {
	b: null
	,getBytes: function() {
		var bytes = new haxe_io_Bytes(new Uint8Array(this.b).buffer);
		this.b = null;
		return bytes;
	}
	,__class__: haxe_io_BytesBuffer
};
var haxe_io_Input = function() { };
$hxClasses["haxe.io.Input"] = haxe_io_Input;
haxe_io_Input.__name__ = true;
haxe_io_Input.prototype = {
	bigEndian: null
	,readByte: function() {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,readBytes: function(s,pos,len) {
		var k = len;
		var b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( eof ) {
			if (eof instanceof js__$Boot_HaxeError) eof = eof.val;
			if( js_Boot.__instanceof(eof,haxe_io_Eof) ) {
			} else throw(eof);
		}
		return len - k;
	}
	,readFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.readBytes(s,pos,len);
			if(k == 0) {
				throw new js__$Boot_HaxeError(haxe_io_Error.Blocked);
			}
			pos += k;
			len -= k;
		}
	}
	,read: function(nbytes) {
		var s = new haxe_io_Bytes(new ArrayBuffer(nbytes));
		var p = 0;
		while(nbytes > 0) {
			var k = this.readBytes(s,p,nbytes);
			if(k == 0) {
				throw new js__$Boot_HaxeError(haxe_io_Error.Blocked);
			}
			p += k;
			nbytes -= k;
		}
		return s;
	}
	,readInt32: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var ch3 = this.readByte();
		var ch4 = this.readByte();
		if(this.bigEndian) {
			return ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24;
		} else {
			return ch1 | ch2 << 8 | ch3 << 16 | ch4 << 24;
		}
	}
	,readString: function(len) {
		var b = new haxe_io_Bytes(new ArrayBuffer(len));
		this.readFullBytes(b,0,len);
		return b.toString();
	}
	,__class__: haxe_io_Input
};
var haxe_io_BytesInput = function(b,pos,len) {
	if(pos == null) {
		pos = 0;
	}
	if(len == null) {
		len = b.length - pos;
	}
	if(pos < 0 || len < 0 || pos + len > b.length) {
		throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
	}
	this.b = b.b;
	this.pos = pos;
	this.len = len;
	this.totlen = len;
};
$hxClasses["haxe.io.BytesInput"] = haxe_io_BytesInput;
haxe_io_BytesInput.__name__ = true;
haxe_io_BytesInput.__super__ = haxe_io_Input;
haxe_io_BytesInput.prototype = $extend(haxe_io_Input.prototype,{
	b: null
	,pos: null
	,len: null
	,totlen: null
	,set_position: function(p) {
		if(p < 0) {
			p = 0;
		} else if(p > this.totlen) {
			p = this.totlen;
		}
		this.len = this.totlen - p;
		return this.pos = p;
	}
	,readByte: function() {
		if(this.len == 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		this.len--;
		return this.b[this.pos++];
	}
	,readBytes: function(buf,pos,len) {
		if(pos < 0 || len < 0 || pos + len > buf.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(this.len == 0 && len > 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		if(this.len < len) {
			len = this.len;
		}
		var b1 = this.b;
		var b2 = buf.b;
		var _g1 = 0;
		var _g = len;
		while(_g1 < _g) {
			var i = _g1++;
			b2[pos + i] = b1[this.pos + i];
		}
		this.pos += len;
		this.len -= len;
		return len;
	}
	,__class__: haxe_io_BytesInput
});
var haxe_io_Output = function() { };
$hxClasses["haxe.io.Output"] = haxe_io_Output;
haxe_io_Output.__name__ = true;
haxe_io_Output.prototype = {
	bigEndian: null
	,writeByte: function(c) {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	,write: function(s) {
		var l = s.length;
		var p = 0;
		while(l > 0) {
			var k = this.writeBytes(s,p,l);
			if(k == 0) {
				throw new js__$Boot_HaxeError(haxe_io_Error.Blocked);
			}
			p += k;
			l -= k;
		}
	}
	,writeFloat: function(x) {
		this.writeInt32(haxe_io_FPHelper.floatToI32(x));
	}
	,writeInt32: function(x) {
		if(this.bigEndian) {
			this.writeByte(x >>> 24);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >>> 24);
		}
	}
	,__class__: haxe_io_Output
};
var haxe_io_BytesOutput = function() {
	this.b = new haxe_io_BytesBuffer();
};
$hxClasses["haxe.io.BytesOutput"] = haxe_io_BytesOutput;
haxe_io_BytesOutput.__name__ = true;
haxe_io_BytesOutput.__super__ = haxe_io_Output;
haxe_io_BytesOutput.prototype = $extend(haxe_io_Output.prototype,{
	b: null
	,writeByte: function(c) {
		this.b.b.push(c);
	}
	,writeBytes: function(buf,pos,len) {
		var _this = this.b;
		if(pos < 0 || len < 0 || pos + len > buf.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		var b1 = _this.b;
		var b2 = buf.b;
		var _g1 = pos;
		var _g = pos + len;
		while(_g1 < _g) {
			var i = _g1++;
			_this.b.push(b2[i]);
		}
		return len;
	}
	,getBytes: function() {
		return this.b.getBytes();
	}
	,__class__: haxe_io_BytesOutput
});
var haxe_io_Eof = function() {
};
$hxClasses["haxe.io.Eof"] = haxe_io_Eof;
haxe_io_Eof.__name__ = true;
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
	,__class__: haxe_io_Eof
};
var haxe_io_Error = $hxClasses["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"] };
haxe_io_Error.Blocked = ["Blocked",0];
haxe_io_Error.Blocked.toString = $estr;
haxe_io_Error.Blocked.__enum__ = haxe_io_Error;
haxe_io_Error.Overflow = ["Overflow",1];
haxe_io_Error.Overflow.toString = $estr;
haxe_io_Error.Overflow.__enum__ = haxe_io_Error;
haxe_io_Error.OutsideBounds = ["OutsideBounds",2];
haxe_io_Error.OutsideBounds.toString = $estr;
haxe_io_Error.OutsideBounds.__enum__ = haxe_io_Error;
haxe_io_Error.Custom = function(e) { var $x = ["Custom",3,e]; $x.__enum__ = haxe_io_Error; $x.toString = $estr; return $x; };
var haxe_io_FPHelper = function() { };
$hxClasses["haxe.io.FPHelper"] = haxe_io_FPHelper;
haxe_io_FPHelper.__name__ = true;
haxe_io_FPHelper.i32ToFloat = function(i) {
	var sign = 1 - (i >>> 31 << 1);
	var exp = i >>> 23 & 255;
	var sig = i & 8388607;
	if(sig == 0 && exp == 0) {
		return 0.0;
	}
	return sign * (1 + Math.pow(2,-23) * sig) * Math.pow(2,exp - 127);
};
haxe_io_FPHelper.floatToI32 = function(f) {
	if(f == 0) {
		return 0;
	}
	var af = f < 0 ? -f : f;
	var exp = Math.floor(Math.log(af) / 0.6931471805599453);
	if(exp < -127) {
		exp = -127;
	} else if(exp > 128) {
		exp = 128;
	}
	var sig = Math.round((af / Math.pow(2,exp) - 1) * 8388608);
	if(sig == 8388608 && exp < 128) {
		sig = 0;
		++exp;
	}
	return (f < 0 ? -2147483648 : 0) | exp + 127 << 23 | sig;
};
haxe_io_FPHelper.i64ToDouble = function(low,high) {
	var sign = 1 - (high >>> 31 << 1);
	var exp = (high >> 20 & 2047) - 1023;
	var sig = (high & 1048575) * 4294967296. + (low >>> 31) * 2147483648. + (low & 2147483647);
	if(sig == 0 && exp == -1023) {
		return 0.0;
	}
	return sign * (1.0 + Math.pow(2,-52) * sig) * Math.pow(2,exp);
};
haxe_io_FPHelper.doubleToI64 = function(v) {
	var i64 = haxe_io_FPHelper.i64tmp;
	if(v == 0) {
		i64.low = 0;
		i64.high = 0;
	} else if(!isFinite(v)) {
		if(v > 0) {
			i64.low = 0;
			i64.high = 2146435072;
		} else {
			i64.low = 0;
			i64.high = -1048576;
		}
	} else {
		var av = v < 0 ? -v : v;
		var exp = Math.floor(Math.log(av) / 0.6931471805599453);
		var sig = Math.round((av / Math.pow(2,exp) - 1) * 4503599627370496.);
		var sig_l = sig | 0;
		var sig_h = sig / 4294967296.0 | 0;
		i64.low = sig_l;
		i64.high = (v < 0 ? -2147483648 : 0) | exp + 1023 << 20 | sig_h;
	}
	return i64;
};
var haxe_io__$UInt8Array_UInt8Array_$Impl_$ = {};
$hxClasses["haxe.io._UInt8Array.UInt8Array_Impl_"] = haxe_io__$UInt8Array_UInt8Array_$Impl_$;
haxe_io__$UInt8Array_UInt8Array_$Impl_$.__name__ = true;
haxe_io__$UInt8Array_UInt8Array_$Impl_$.fromBytes = function(bytes,bytePos,length) {
	if(bytePos == null) {
		bytePos = 0;
	}
	if(length == null) {
		length = bytes.length - bytePos;
	}
	return new Uint8Array(bytes.b.bufferValue,bytePos,length);
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
$hxClasses["js._Boot.HaxeError"] = js__$Boot_HaxeError;
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	val: null
	,__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = true;
js_Boot.__unhtml = function(s) {
	return s.split("&").join("&amp;").split("<").join("&lt;").split(">").join("&gt;");
};
js_Boot.__trace = function(v,i) {
	var msg = i != null ? i.fileName + ":" + i.lineNumber + ": " : "";
	msg += js_Boot.__string_rec(v,"");
	if(i != null && i.customParams != null) {
		var _g = 0;
		var _g1 = i.customParams;
		while(_g < _g1.length) {
			var v1 = _g1[_g];
			++_g;
			msg += "," + js_Boot.__string_rec(v1,"");
		}
	}
	var d;
	var tmp;
	if(typeof(document) != "undefined") {
		d = document.getElementById("haxe:trace");
		tmp = d != null;
	} else {
		tmp = false;
	}
	if(tmp) {
		d.innerHTML += js_Boot.__unhtml(msg) + "<br/>";
	} else if(typeof console != "undefined" && console.log != null) {
		console.log(msg);
	}
};
js_Boot.getClass = function(o) {
	if((o instanceof Array) && o.__enum__ == null) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g1 = 0;
		var _g = intf.length;
		while(_g1 < _g) {
			var i = _g1++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		if((o instanceof Array)) {
			return o.__enum__ == null;
		} else {
			return false;
		}
		break;
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return true;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return (o|0) === o;
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(o instanceof cl) {
					return true;
				}
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(o instanceof cl) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ == cl;
	}
};
js_Boot.__cast = function(o,t) {
	if(js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw new js__$Boot_HaxeError("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_html_compat_ArrayBuffer = function(a) {
	if((a instanceof Array) && a.__enum__ == null) {
		this.a = a;
		this.byteLength = a.length;
	} else {
		var len = a;
		this.a = [];
		var _g1 = 0;
		var _g = len;
		while(_g1 < _g) {
			var i = _g1++;
			this.a[i] = 0;
		}
		this.byteLength = len;
	}
};
$hxClasses["js.html.compat.ArrayBuffer"] = js_html_compat_ArrayBuffer;
js_html_compat_ArrayBuffer.__name__ = true;
js_html_compat_ArrayBuffer.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var result = new ArrayBuffer(u.byteLength);
	var resultArray = new Uint8Array(result);
	resultArray.set(u);
	return result;
};
js_html_compat_ArrayBuffer.prototype = {
	byteLength: null
	,a: null
	,slice: function(begin,end) {
		return new js_html_compat_ArrayBuffer(this.a.slice(begin,end));
	}
	,__class__: js_html_compat_ArrayBuffer
};
var js_html_compat_DataView = function(buffer,byteOffset,byteLength) {
	this.buf = buffer;
	this.offset = byteOffset == null ? 0 : byteOffset;
	this.length = byteLength == null ? buffer.byteLength - this.offset : byteLength;
	if(this.offset < 0 || this.length < 0 || this.offset + this.length > buffer.byteLength) {
		throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
	}
	this.byteLength = this.length;
	this.byteOffset = this.offset;
	this.buffer = this.buf;
};
$hxClasses["js.html.compat.DataView"] = js_html_compat_DataView;
js_html_compat_DataView.__name__ = true;
js_html_compat_DataView.prototype = {
	buf: null
	,offset: null
	,length: null
	,byteLength: null
	,byteOffset: null
	,buffer: null
	,getInt8: function(byteOffset) {
		var v = this.buf.a[this.offset + byteOffset];
		if(v >= 128) {
			return v - 256;
		} else {
			return v;
		}
	}
	,getUint8: function(byteOffset) {
		return this.buf.a[this.offset + byteOffset];
	}
	,getInt16: function(byteOffset,littleEndian) {
		var v = this.getUint16(byteOffset,littleEndian);
		if(v >= 32768) {
			return v - 65536;
		} else {
			return v;
		}
	}
	,getUint16: function(byteOffset,littleEndian) {
		if(littleEndian) {
			return this.buf.a[this.offset + byteOffset] | this.buf.a[this.offset + byteOffset + 1] << 8;
		} else {
			return this.buf.a[this.offset + byteOffset] << 8 | this.buf.a[this.offset + byteOffset + 1];
		}
	}
	,getInt32: function(byteOffset,littleEndian) {
		var p = this.offset + byteOffset;
		var a = this.buf.a[p++];
		var b = this.buf.a[p++];
		var c = this.buf.a[p++];
		var d = this.buf.a[p++];
		if(littleEndian) {
			return a | b << 8 | c << 16 | d << 24;
		} else {
			return d | c << 8 | b << 16 | a << 24;
		}
	}
	,getUint32: function(byteOffset,littleEndian) {
		var v = this.getInt32(byteOffset,littleEndian);
		if(v < 0) {
			return v + 4294967296.;
		} else {
			return v;
		}
	}
	,getFloat32: function(byteOffset,littleEndian) {
		return haxe_io_FPHelper.i32ToFloat(this.getInt32(byteOffset,littleEndian));
	}
	,getFloat64: function(byteOffset,littleEndian) {
		var a = this.getInt32(byteOffset,littleEndian);
		var b = this.getInt32(byteOffset + 4,littleEndian);
		return haxe_io_FPHelper.i64ToDouble(littleEndian ? a : b,littleEndian ? b : a);
	}
	,setInt8: function(byteOffset,value) {
		this.buf.a[byteOffset + this.offset] = value < 0 ? value + 128 & 255 : value & 255;
	}
	,setUint8: function(byteOffset,value) {
		this.buf.a[byteOffset + this.offset] = value & 255;
	}
	,setInt16: function(byteOffset,value,littleEndian) {
		this.setUint16(byteOffset,value < 0 ? value + 65536 : value,littleEndian);
	}
	,setUint16: function(byteOffset,value,littleEndian) {
		var p = byteOffset + this.offset;
		if(littleEndian) {
			this.buf.a[p] = value & 255;
			this.buf.a[p++] = value >> 8 & 255;
		} else {
			this.buf.a[p++] = value >> 8 & 255;
			this.buf.a[p] = value & 255;
		}
	}
	,setInt32: function(byteOffset,value,littleEndian) {
		this.setUint32(byteOffset,value,littleEndian);
	}
	,setUint32: function(byteOffset,value,littleEndian) {
		var p = byteOffset + this.offset;
		if(littleEndian) {
			this.buf.a[p++] = value & 255;
			this.buf.a[p++] = value >> 8 & 255;
			this.buf.a[p++] = value >> 16 & 255;
			this.buf.a[p++] = value >>> 24;
		} else {
			this.buf.a[p++] = value >>> 24;
			this.buf.a[p++] = value >> 16 & 255;
			this.buf.a[p++] = value >> 8 & 255;
			this.buf.a[p++] = value & 255;
		}
	}
	,setFloat32: function(byteOffset,value,littleEndian) {
		this.setUint32(byteOffset,haxe_io_FPHelper.floatToI32(value),littleEndian);
	}
	,setFloat64: function(byteOffset,value,littleEndian) {
		var i64 = haxe_io_FPHelper.doubleToI64(value);
		if(littleEndian) {
			this.setUint32(byteOffset,i64.low);
			this.setUint32(byteOffset,i64.high);
		} else {
			this.setUint32(byteOffset,i64.high);
			this.setUint32(byteOffset,i64.low);
		}
	}
	,__class__: js_html_compat_DataView
};
var js_html_compat_Float32Array = function() { };
$hxClasses["js.html.compat.Float32Array"] = js_html_compat_Float32Array;
js_html_compat_Float32Array.__name__ = true;
js_html_compat_Float32Array._new = function(arg1,offset,length) {
	var arr;
	if(typeof(arg1) == "number") {
		arr = [];
		var _g1 = 0;
		var _g = arg1;
		while(_g1 < _g) {
			var i = _g1++;
			arr[i] = 0;
		}
		arr.byteLength = arr.length << 2;
		arr.byteOffset = 0;
		var _g2 = [];
		var _g21 = 0;
		var _g11 = arr.length << 2;
		while(_g21 < _g11) {
			var i1 = _g21++;
			_g2.push(0);
		}
		arr.buffer = new js_html_compat_ArrayBuffer(_g2);
	} else if(js_Boot.__instanceof(arg1,js_html_compat_ArrayBuffer)) {
		var buffer = arg1;
		if(offset == null) {
			offset = 0;
		}
		if(length == null) {
			length = buffer.byteLength - offset >> 2;
		}
		arr = [];
		var _g12 = 0;
		var _g3 = length;
		while(_g12 < _g3) {
			var i2 = _g12++;
			var val = buffer.a[offset++] | buffer.a[offset++] << 8 | buffer.a[offset++] << 16 | buffer.a[offset++] << 24;
			arr.push(haxe_io_FPHelper.i32ToFloat(val));
		}
		arr.byteLength = arr.length << 2;
		arr.byteOffset = offset;
		arr.buffer = buffer;
	} else if((arg1 instanceof Array) && arg1.__enum__ == null) {
		arr = arg1.slice();
		var buffer1 = [];
		var _g4 = 0;
		while(_g4 < arr.length) {
			var f = arr[_g4];
			++_g4;
			var i3 = haxe_io_FPHelper.floatToI32(f);
			buffer1.push(i3 & 255);
			buffer1.push(i3 >> 8 & 255);
			buffer1.push(i3 >> 16 & 255);
			buffer1.push(i3 >>> 24);
		}
		arr.byteLength = arr.length << 2;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(buffer1);
	} else {
		throw new js__$Boot_HaxeError("TODO " + Std.string(arg1));
	}
	arr.subarray = js_html_compat_Float32Array._subarray;
	arr.set = js_html_compat_Float32Array._set;
	return arr;
};
js_html_compat_Float32Array._set = function(arg,offset) {
	if(js_Boot.__instanceof(arg.buffer,js_html_compat_ArrayBuffer)) {
		var a = arg;
		if(arg.byteLength + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g1 = 0;
		var _g = arg.byteLength;
		while(_g1 < _g) {
			var i = _g1++;
			this[i + offset] = a[i];
		}
	} else if((arg instanceof Array) && arg.__enum__ == null) {
		var a1 = arg;
		if(a1.length + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g11 = 0;
		var _g2 = a1.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			this[i1 + offset] = a1[i1];
		}
	} else {
		throw new js__$Boot_HaxeError("TODO");
	}
};
js_html_compat_Float32Array._subarray = function(start,end) {
	var a = js_html_compat_Float32Array._new(this.slice(start,end));
	a.byteOffset = start * 4;
	return a;
};
var js_html_compat_Uint8Array = function() { };
$hxClasses["js.html.compat.Uint8Array"] = js_html_compat_Uint8Array;
js_html_compat_Uint8Array.__name__ = true;
js_html_compat_Uint8Array._new = function(arg1,offset,length) {
	var arr;
	if(typeof(arg1) == "number") {
		arr = [];
		var _g1 = 0;
		var _g = arg1;
		while(_g1 < _g) {
			var i = _g1++;
			arr[i] = 0;
		}
		arr.byteLength = arr.length;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(arr);
	} else if(js_Boot.__instanceof(arg1,js_html_compat_ArrayBuffer)) {
		var buffer = arg1;
		if(offset == null) {
			offset = 0;
		}
		if(length == null) {
			length = buffer.byteLength - offset;
		}
		if(offset == 0) {
			arr = buffer.a;
		} else {
			arr = buffer.a.slice(offset,offset + length);
		}
		arr.byteLength = arr.length;
		arr.byteOffset = offset;
		arr.buffer = buffer;
	} else if((arg1 instanceof Array) && arg1.__enum__ == null) {
		arr = arg1.slice();
		arr.byteLength = arr.length;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(arr);
	} else {
		throw new js__$Boot_HaxeError("TODO " + Std.string(arg1));
	}
	arr.subarray = js_html_compat_Uint8Array._subarray;
	arr.set = js_html_compat_Uint8Array._set;
	return arr;
};
js_html_compat_Uint8Array._set = function(arg,offset) {
	if(js_Boot.__instanceof(arg.buffer,js_html_compat_ArrayBuffer)) {
		var a = arg;
		if(arg.byteLength + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g1 = 0;
		var _g = arg.byteLength;
		while(_g1 < _g) {
			var i = _g1++;
			this[i + offset] = a[i];
		}
	} else if((arg instanceof Array) && arg.__enum__ == null) {
		var a1 = arg;
		if(a1.length + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g11 = 0;
		var _g2 = a1.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			this[i1 + offset] = a1[i1];
		}
	} else {
		throw new js__$Boot_HaxeError("TODO");
	}
};
js_html_compat_Uint8Array._subarray = function(start,end) {
	var a = js_html_compat_Uint8Array._new(this.slice(start,end));
	a.byteOffset = start;
	return a;
};
var kha__$Assets_ImageList = function() {
	this.names = [];
};
$hxClasses["kha._Assets.ImageList"] = kha__$Assets_ImageList;
kha__$Assets_ImageList.__name__ = true;
kha__$Assets_ImageList.prototype = {
	names: null
	,__class__: kha__$Assets_ImageList
};
var kha__$Assets_SoundList = function() {
	this.names = [];
};
$hxClasses["kha._Assets.SoundList"] = kha__$Assets_SoundList;
kha__$Assets_SoundList.__name__ = true;
kha__$Assets_SoundList.prototype = {
	names: null
	,__class__: kha__$Assets_SoundList
};
var kha__$Assets_BlobList = function() {
	this.names = [];
};
$hxClasses["kha._Assets.BlobList"] = kha__$Assets_BlobList;
kha__$Assets_BlobList.__name__ = true;
kha__$Assets_BlobList.prototype = {
	names: null
	,__class__: kha__$Assets_BlobList
};
var kha__$Assets_FontList = function() {
	this.names = [];
};
$hxClasses["kha._Assets.FontList"] = kha__$Assets_FontList;
kha__$Assets_FontList.__name__ = true;
kha__$Assets_FontList.prototype = {
	names: null
	,__class__: kha__$Assets_FontList
};
var kha__$Assets_VideoList = function() {
	this.names = [];
};
$hxClasses["kha._Assets.VideoList"] = kha__$Assets_VideoList;
kha__$Assets_VideoList.__name__ = true;
kha__$Assets_VideoList.prototype = {
	names: null
	,__class__: kha__$Assets_VideoList
};
var kha_Assets = function() { };
$hxClasses["kha.Assets"] = kha_Assets;
kha_Assets.__name__ = true;
kha_Assets.loadEverything = function(callback,filter,uncompressSoundsFilter) {
	var fileCount = 0;
	var _g = 0;
	var _g1 = Type.getInstanceFields(kha__$Assets_BlobList);
	while(_g < _g1.length) {
		var blob = _g1[_g];
		++_g;
		if(StringTools.endsWith(blob,"Load")) {
			fileCount += 1;
		}
	}
	var _g2 = 0;
	var _g11 = Type.getInstanceFields(kha__$Assets_ImageList);
	while(_g2 < _g11.length) {
		var image = _g11[_g2];
		++_g2;
		if(StringTools.endsWith(image,"Load")) {
			fileCount += 1;
		}
	}
	var _g3 = 0;
	var _g12 = Type.getInstanceFields(kha__$Assets_SoundList);
	while(_g3 < _g12.length) {
		var sound = _g12[_g3];
		++_g3;
		if(StringTools.endsWith(sound,"Load")) {
			fileCount += 1;
		}
	}
	var _g4 = 0;
	var _g13 = Type.getInstanceFields(kha__$Assets_FontList);
	while(_g4 < _g13.length) {
		var font = _g13[_g4];
		++_g4;
		if(StringTools.endsWith(font,"Load")) {
			fileCount += 1;
		}
	}
	var _g5 = 0;
	var _g14 = Type.getInstanceFields(kha__$Assets_VideoList);
	while(_g5 < _g14.length) {
		var video = _g14[_g5];
		++_g5;
		if(StringTools.endsWith(video,"Load")) {
			fileCount += 1;
		}
	}
	if(fileCount == 0) {
		callback();
		return;
	}
	var filesLeft = fileCount;
	var _g6 = 0;
	var _g15 = Type.getInstanceFields(kha__$Assets_BlobList);
	while(_g6 < _g15.length) {
		var blob1 = _g15[_g6];
		++_g6;
		if(StringTools.endsWith(blob1,"Load")) {
			var name = HxOverrides.substr(blob1,0,blob1.length - 4);
			var description = Reflect.field(kha_Assets.blobs,name + "Description");
			if(filter == null || filter(description)) {
				(Reflect.field(kha_Assets.blobs,blob1))(function() {
					filesLeft -= 1;
					kha_Assets.progress = 1 - filesLeft / fileCount;
					if(filesLeft == 0) {
						callback();
					}
				});
			} else {
				filesLeft -= 1;
				kha_Assets.progress = 1 - filesLeft / fileCount;
				if(filesLeft == 0) {
					callback();
				}
			}
		}
	}
	var _g7 = 0;
	var _g16 = Type.getInstanceFields(kha__$Assets_ImageList);
	while(_g7 < _g16.length) {
		var image1 = _g16[_g7];
		++_g7;
		if(StringTools.endsWith(image1,"Load")) {
			var name1 = HxOverrides.substr(image1,0,image1.length - 4);
			var description1 = Reflect.field(kha_Assets.images,name1 + "Description");
			if(filter == null || filter(description1)) {
				(Reflect.field(kha_Assets.images,image1))(function() {
					filesLeft -= 1;
					kha_Assets.progress = 1 - filesLeft / fileCount;
					if(filesLeft == 0) {
						callback();
					}
				});
			} else {
				filesLeft -= 1;
				kha_Assets.progress = 1 - filesLeft / fileCount;
				if(filesLeft == 0) {
					callback();
				}
			}
		}
	}
	var _g8 = 0;
	var _g17 = Type.getInstanceFields(kha__$Assets_SoundList);
	while(_g8 < _g17.length) {
		var sound1 = [_g17[_g8]];
		++_g8;
		if(StringTools.endsWith(sound1[0],"Load")) {
			var name2 = HxOverrides.substr(sound1[0],0,sound1[0].length - 4);
			var description2 = [Reflect.field(kha_Assets.sounds,name2 + "Description")];
			if(filter == null || filter(description2[0])) {
				(Reflect.field(kha_Assets.sounds,sound1[0]))((function(description3,sound2) {
					return function() {
						if(uncompressSoundsFilter == null || uncompressSoundsFilter(description3[0])) {
							var sound3 = Reflect.field(kha_Assets.sounds,sound2[0].substring(0,sound2[0].length - 4));
							sound3.uncompress((function() {
								return function() {
									filesLeft -= 1;
									kha_Assets.progress = 1 - filesLeft / fileCount;
									if(filesLeft == 0) {
										callback();
									}
								};
							})());
						} else {
							filesLeft -= 1;
							kha_Assets.progress = 1 - filesLeft / fileCount;
							if(filesLeft == 0) {
								callback();
							}
						}
					};
				})(description2,sound1));
			} else {
				filesLeft -= 1;
				kha_Assets.progress = 1 - filesLeft / fileCount;
				if(filesLeft == 0) {
					callback();
				}
			}
		}
	}
	var _g9 = 0;
	var _g18 = Type.getInstanceFields(kha__$Assets_FontList);
	while(_g9 < _g18.length) {
		var font1 = _g18[_g9];
		++_g9;
		if(StringTools.endsWith(font1,"Load")) {
			var name3 = HxOverrides.substr(font1,0,font1.length - 4);
			var description4 = Reflect.field(kha_Assets.fonts,name3 + "Description");
			if(filter == null || filter(description4)) {
				(Reflect.field(kha_Assets.fonts,font1))(function() {
					filesLeft -= 1;
					kha_Assets.progress = 1 - filesLeft / fileCount;
					if(filesLeft == 0) {
						callback();
					}
				});
			} else {
				filesLeft -= 1;
				kha_Assets.progress = 1 - filesLeft / fileCount;
				if(filesLeft == 0) {
					callback();
				}
			}
		}
	}
	var _g10 = 0;
	var _g19 = Type.getInstanceFields(kha__$Assets_VideoList);
	while(_g10 < _g19.length) {
		var video1 = _g19[_g10];
		++_g10;
		if(StringTools.endsWith(video1,"Load")) {
			var name4 = HxOverrides.substr(video1,0,video1.length - 4);
			var description5 = Reflect.field(kha_Assets.videos,name4 + "Description");
			if(filter == null || filter(description5)) {
				(Reflect.field(kha_Assets.videos,video1))(function() {
					filesLeft -= 1;
					kha_Assets.progress = 1 - filesLeft / fileCount;
					if(filesLeft == 0) {
						callback();
					}
				});
			} else {
				filesLeft -= 1;
				kha_Assets.progress = 1 - filesLeft / fileCount;
				if(filesLeft == 0) {
					callback();
				}
			}
		}
	}
};
kha_Assets.loadImage = function(name,done) {
	var description = Reflect.field(kha_Assets.images,name + "Description");
	kha_LoaderImpl.loadImageFromDescription(description,function(image) {
		kha_Assets.images[name] = image;
		done(image);
	});
};
kha_Assets.loadImageFromPath = function(path,readable,done) {
	var description = { files : [path], readable : readable};
	kha_LoaderImpl.loadImageFromDescription(description,done);
};
kha_Assets.get_imageFormats = function() {
	return kha_LoaderImpl.getImageFormats();
};
kha_Assets.loadBlob = function(name,done) {
	var description = Reflect.field(kha_Assets.blobs,name + "Description");
	kha_LoaderImpl.loadBlobFromDescription(description,function(blob) {
		kha_Assets.blobs[name] = blob;
		done(blob);
	});
};
kha_Assets.loadBlobFromPath = function(path,done) {
	var description = { files : [path]};
	kha_LoaderImpl.loadBlobFromDescription(description,done);
};
kha_Assets.loadSound = function(name,done) {
	var description = Reflect.field(kha_Assets.sounds,name + "Description");
	kha_LoaderImpl.loadSoundFromDescription(description,function(sound) {
		kha_Assets.sounds[name] = sound;
		done(sound);
	});
	return;
};
kha_Assets.loadSoundFromPath = function(path,done) {
	var description = { files : [path]};
	kha_LoaderImpl.loadSoundFromDescription(description,done);
	return;
};
kha_Assets.get_soundFormats = function() {
	return kha_LoaderImpl.getSoundFormats();
};
kha_Assets.loadFont = function(name,done) {
	var description = Reflect.field(kha_Assets.fonts,name + "Description");
	kha_LoaderImpl.loadFontFromDescription(description,function(font) {
		kha_Assets.fonts[name] = font;
		done(font);
	});
	return;
};
kha_Assets.loadFontFromPath = function(path,done) {
	var description = { files : [path]};
	kha_LoaderImpl.loadFontFromDescription(description,done);
	return;
};
kha_Assets.get_fontFormats = function() {
	return ["ttf"];
};
kha_Assets.loadVideo = function(name,done) {
	var description = Reflect.field(kha_Assets.videos,name + "Description");
	kha_LoaderImpl.loadVideoFromDescription(description,function(video) {
		kha_Assets.videos[name] = video;
		done(video);
	});
	return;
};
kha_Assets.loadVideoFromPath = function(path,done) {
	var description = { files : [path]};
	kha_LoaderImpl.loadVideoFromDescription(description,done);
	return;
};
kha_Assets.get_videoFormats = function() {
	return kha_LoaderImpl.getVideoFormats();
};
var kha_Canvas = function() { };
$hxClasses["kha.Canvas"] = kha_Canvas;
kha_Canvas.__name__ = true;
kha_Canvas.prototype = {
	get_width: null
	,get_height: null
	,get_g1: null
	,get_g2: null
	,get_g4: null
	,width: null
	,height: null
	,g1: null
	,g2: null
	,g4: null
	,__class__: kha_Canvas
};
var kha_Resource = function() { };
$hxClasses["kha.Resource"] = kha_Resource;
kha_Resource.__name__ = true;
kha_Resource.prototype = {
	unload: null
	,__class__: kha_Resource
};
var kha_Image = function() { };
$hxClasses["kha.Image"] = kha_Image;
kha_Image.__name__ = true;
kha_Image.__interfaces__ = [kha_Resource,kha_Canvas];
kha_Image.create = function(width,height,format,usage) {
	if(format == null) {
		format = kha_graphics4_TextureFormat.RGBA32;
	}
	if(usage == null) {
		usage = kha_graphics4_Usage.StaticUsage;
	}
	if(kha_SystemImpl.gl == null) {
		return new kha_CanvasImage(width,height,format,false);
	} else {
		return new kha_WebGLImage(width,height,format,false,0);
	}
};
kha_Image.create3D = function(width,height,depth,format,usage) {
	return null;
};
kha_Image.createRenderTarget = function(width,height,format,depthStencil,antiAliasingSamples,contextId) {
	if(contextId == null) {
		contextId = 0;
	}
	if(antiAliasingSamples == null) {
		antiAliasingSamples = 1;
	}
	if(depthStencil == null) {
		depthStencil = 0;
	}
	if(format == null) {
		format = kha_graphics4_TextureFormat.RGBA32;
	}
	if(kha_SystemImpl.gl == null) {
		return new kha_CanvasImage(width,height,format,true);
	} else {
		return new kha_WebGLImage(width,height,format,true,depthStencil);
	}
};
kha_Image.fromImage = function(image,readable) {
	if(kha_SystemImpl.gl == null) {
		var img = new kha_CanvasImage(image.width,image.height,kha_graphics4_TextureFormat.RGBA32,false);
		img.image = image;
		img.createTexture();
		return img;
	} else {
		var img1 = new kha_WebGLImage(image.width,image.height,kha_graphics4_TextureFormat.RGBA32,false,0);
		img1.image = image;
		img1.createTexture();
		return img1;
	}
};
kha_Image.fromBytes = function(bytes,width,height,format,usage) {
	if(format == null) {
		format = kha_graphics4_TextureFormat.RGBA32;
	}
	if(usage == null) {
		usage = kha_graphics4_Usage.StaticUsage;
	}
	if(kha_SystemImpl.gl != null) {
		var img = new kha_WebGLImage(width,height,format,false,0);
		img.image = img.bytesToArray(bytes);
		img.createTexture();
		return img;
	}
	return null;
};
kha_Image.fromBytes3D = function(bytes,width,height,depth,format,usage) {
	return null;
};
kha_Image.fromEncodedBytes = function(bytes,fileExtention,doneCallback,errorCallback,readable) {
	if(readable == null) {
		readable = false;
	}
	var dataUrl = "data:image;base64," + haxe_crypto_Base64.encode(bytes);
	var imageElement = js_Boot.__cast(window.document.createElement("img") , HTMLImageElement);
	imageElement.onload = function() {
		var tmp = kha_Image.fromImage(imageElement,readable);
		doneCallback(tmp);
	};
	imageElement.onerror = function() {
		errorCallback("Image was not created");
	};
	imageElement.src = dataUrl;
};
kha_Image.fromVideo = function(video) {
	if(kha_SystemImpl.gl == null) {
		var img = new kha_CanvasImage(video.element.videoWidth,video.element.videoHeight,kha_graphics4_TextureFormat.RGBA32,false);
		img.video = video.element;
		img.createTexture();
		return img;
	} else {
		var img1 = new kha_WebGLImage(video.element.videoWidth,video.element.videoHeight,kha_graphics4_TextureFormat.RGBA32,false,0);
		img1.video = video.element;
		img1.createTexture();
		return img1;
	}
};
kha_Image.get_maxSize = function() {
	if(kha_SystemImpl.gl == null) {
		return 8192;
	} else {
		return kha_SystemImpl.gl.getParameter(3379);
	}
};
kha_Image.get_nonPow2Supported = function() {
	return kha_SystemImpl.gl != null;
};
kha_Image.prototype = {
	isOpaque: function(x,y) {
		return false;
	}
	,at: function(x,y) {
		return -16777216;
	}
	,unload: function() {
	}
	,lock: function(level) {
		if(level == null) {
			level = 0;
		}
		return null;
	}
	,unlock: function() {
	}
	,getPixels: function() {
		return null;
	}
	,generateMipmaps: function(levels) {
	}
	,setMipmaps: function(mipmaps) {
	}
	,setDepthStencilFrom: function(image) {
	}
	,clear: function(x,y,z,width,height,depth,color) {
	}
	,width: null
	,get_width: function() {
		return 0;
	}
	,height: null
	,get_height: function() {
		return 0;
	}
	,depth: null
	,get_depth: function() {
		return 1;
	}
	,realWidth: null
	,get_realWidth: function() {
		return 0;
	}
	,realHeight: null
	,get_realHeight: function() {
		return 0;
	}
	,g1: null
	,get_g1: function() {
		return null;
	}
	,g2: null
	,get_g2: function() {
		return null;
	}
	,g4: null
	,get_g4: function() {
		return null;
	}
	,__class__: kha_Image
};
var kha_CanvasImage = function(width,height,format,renderTarget) {
	this.g2canvas = null;
	this.myWidth = width;
	this.myHeight = height;
	this.format = format;
	this.renderTarget = renderTarget;
	this.image = null;
	this.video = null;
	if(renderTarget) {
		this.createTexture();
	}
};
$hxClasses["kha.CanvasImage"] = kha_CanvasImage;
kha_CanvasImage.__name__ = true;
kha_CanvasImage.init = function() {
	var canvas = window.document.createElement("canvas");
	if(canvas != null) {
		kha_CanvasImage.context = canvas.getContext("2d");
		canvas.width = 2048;
		canvas.height = 2048;
		kha_CanvasImage.context.globalCompositeOperation = "copy";
	}
};
kha_CanvasImage.upperPowerOfTwo = function(v) {
	--v;
	v |= v >>> 1;
	v |= v >>> 2;
	v |= v >>> 4;
	v |= v >>> 8;
	v |= v >>> 16;
	return ++v;
};
kha_CanvasImage.__super__ = kha_Image;
kha_CanvasImage.prototype = $extend(kha_Image.prototype,{
	image: null
	,video: null
	,data: null
	,myWidth: null
	,myHeight: null
	,format: null
	,renderTarget: null
	,frameBuffer: null
	,graphics1: null
	,g2canvas: null
	,get_g1: function() {
		if(this.graphics1 == null) {
			this.graphics1 = new kha_graphics2_Graphics1(this);
		}
		return this.graphics1;
	}
	,get_g2: function() {
		if(this.g2canvas == null) {
			var canvas = window.document.createElement("canvas");
			this.image = canvas;
			var context = canvas.getContext("2d");
			canvas.width = this.get_width();
			canvas.height = this.get_height();
			this.g2canvas = new kha_js_CanvasGraphics(context);
		}
		return this.g2canvas;
	}
	,get_g4: function() {
		return null;
	}
	,get_width: function() {
		return this.myWidth;
	}
	,get_height: function() {
		return this.myHeight;
	}
	,get_realWidth: function() {
		return this.myWidth;
	}
	,get_realHeight: function() {
		return this.myHeight;
	}
	,isOpaque: function(x,y) {
		if(this.data == null) {
			if(kha_CanvasImage.context == null) {
				return true;
			} else {
				this.createImageData();
			}
		}
		return this.data.data[y * (this.image.width | 0) * 4 + x * 4 + 3] != 0;
	}
	,at: function(x,y) {
		if(this.data == null) {
			if(kha_CanvasImage.context == null) {
				return -16777216;
			} else {
				this.createImageData();
			}
		}
		return kha__$Color_Color_$Impl_$._new(this.data.data[y * (this.image.width | 0) * 4 + x * 4]);
	}
	,createImageData: function() {
		kha_CanvasImage.context.strokeStyle = "rgba(0,0,0,0)";
		kha_CanvasImage.context.fillStyle = "rgba(0,0,0,0)";
		kha_CanvasImage.context.fillRect(0,0,this.image.width,this.image.height);
		kha_CanvasImage.context.drawImage(this.image,0,0,this.image.width,this.image.height,0,0,this.image.width,this.image.height);
		this.data = kha_CanvasImage.context.getImageData(0,0,this.image.width,this.image.height);
	}
	,texture: null
	,createTexture: function() {
		if(kha_SystemImpl.gl == null) {
			return;
		}
		this.texture = kha_SystemImpl.gl.createTexture();
		kha_SystemImpl.gl.bindTexture(3553,this.texture);
		kha_SystemImpl.gl.texParameteri(3553,10240,9729);
		kha_SystemImpl.gl.texParameteri(3553,10241,9729);
		kha_SystemImpl.gl.texParameteri(3553,10242,33071);
		kha_SystemImpl.gl.texParameteri(3553,10243,33071);
		if(this.renderTarget) {
			this.frameBuffer = kha_SystemImpl.gl.createFramebuffer();
			kha_SystemImpl.gl.bindFramebuffer(36160,this.frameBuffer);
			kha_SystemImpl.gl.texImage2D(3553,0,6408,this.get_realWidth(),this.get_realHeight(),0,6408,5121,null);
			kha_SystemImpl.gl.framebufferTexture2D(36160,36064,3553,this.texture,0);
			kha_SystemImpl.gl.bindFramebuffer(36160,null);
		} else if(this.video != null) {
			kha_SystemImpl.gl.texImage2D(3553,0,6408,6408,5121,this.video);
		} else {
			kha_SystemImpl.gl.texImage2D(3553,0,6408,6408,5121,this.image);
		}
		kha_SystemImpl.gl.bindTexture(3553,null);
	}
	,set: function(stage) {
		kha_SystemImpl.gl.activeTexture(33984 + stage);
		kha_SystemImpl.gl.bindTexture(3553,this.texture);
		if(this.video != null) {
			kha_SystemImpl.gl.texImage2D(3553,0,6408,6408,5121,this.video);
		}
	}
	,bytes: null
	,lock: function(level) {
		if(level == null) {
			level = 0;
		}
		this.bytes = new haxe_io_Bytes(new ArrayBuffer(this.format == kha_graphics4_TextureFormat.RGBA32 ? 4 * this.get_width() * this.get_height() : this.get_width() * this.get_height()));
		return this.bytes;
	}
	,unlock: function() {
		if(kha_SystemImpl.gl != null) {
			this.texture = kha_SystemImpl.gl.createTexture();
			kha_SystemImpl.gl.bindTexture(3553,this.texture);
			kha_SystemImpl.gl.texParameteri(3553,10240,9729);
			kha_SystemImpl.gl.texParameteri(3553,10241,9729);
			kha_SystemImpl.gl.texParameteri(3553,10242,33071);
			kha_SystemImpl.gl.texParameteri(3553,10243,33071);
			kha_SystemImpl.gl.texImage2D(3553,0,6409,this.get_width(),this.get_height(),0,6409,5121,new Uint8Array(this.bytes.b.bufferValue));
			if(kha_SystemImpl.gl.getError() == 1282) {
				var rgbaBytes = new haxe_io_Bytes(new ArrayBuffer(this.get_width() * this.get_height() * 4));
				var _g1 = 0;
				var _g = this.get_height();
				while(_g1 < _g) {
					var y = _g1++;
					var _g3 = 0;
					var _g2 = this.get_width();
					while(_g3 < _g2) {
						var x = _g3++;
						var _this = this.bytes;
						var pos = y * this.get_width() + x;
						var value = _this.b[pos];
						var pos1 = y * this.get_width() * 4 + x * 4;
						rgbaBytes.b[pos1] = value & 255;
						var pos2 = y * this.get_width() * 4 + x * 4 + 1;
						rgbaBytes.b[pos2] = value & 255;
						var pos3 = y * this.get_width() * 4 + x * 4 + 2;
						rgbaBytes.b[pos3] = value & 255;
						var pos4 = y * this.get_width() * 4 + x * 4 + 3;
						rgbaBytes.b[pos4] = 255;
					}
				}
				kha_SystemImpl.gl.texImage2D(3553,0,6408,this.get_width(),this.get_height(),0,6408,5121,new Uint8Array(rgbaBytes.b.bufferValue));
			}
			kha_SystemImpl.gl.bindTexture(3553,null);
			this.bytes = null;
		}
	}
	,unload: function() {
		this.image = null;
		this.video = null;
		this.data = null;
	}
	,__class__: kha_CanvasImage
});
var kha__$Color_Color_$Impl_$ = $hx_exports["kha"]["_Color"]["Color_Impl_"] = {};
$hxClasses["kha._Color.Color_Impl_"] = kha__$Color_Color_$Impl_$;
kha__$Color_Color_$Impl_$.__name__ = true;
kha__$Color_Color_$Impl_$.fromValue = function(value) {
	return kha__$Color_Color_$Impl_$._new(value);
};
kha__$Color_Color_$Impl_$.fromBytes = function(r,g,b,a) {
	if(a == null) {
		a = 255;
	}
	return kha__$Color_Color_$Impl_$._new(a << 24 | r << 16 | g << 8 | b);
};
kha__$Color_Color_$Impl_$.fromFloats = function(r,g,b,a) {
	if(a == null) {
		a = 1;
	}
	return kha__$Color_Color_$Impl_$._new((a * 255 | 0) << 24 | (r * 255 | 0) << 16 | (g * 255 | 0) << 8 | (b * 255 | 0));
};
kha__$Color_Color_$Impl_$.fromString = function(value) {
	if((value.length == 7 || value.length == 9) && value.charCodeAt(0) == 35) {
		var colorValue = Std.parseInt("0x" + HxOverrides.substr(value,1,null));
		if(value.length == 7) {
			colorValue += -16777216;
		}
		return kha__$Color_Color_$Impl_$._new(colorValue);
	} else {
		throw new js__$Boot_HaxeError("Invalid Color string: '" + value + "'");
	}
};
kha__$Color_Color_$Impl_$._new = function(value) {
	var this1 = value;
	return this1;
};
kha__$Color_Color_$Impl_$.get_value = function(this1) {
	return this1;
};
kha__$Color_Color_$Impl_$.set_value = function(this1,value) {
	this1 = value;
	return this1;
};
kha__$Color_Color_$Impl_$.get_Rb = function(this1) {
	return (this1 & 16711680) >>> 16;
};
kha__$Color_Color_$Impl_$.get_Gb = function(this1) {
	return (this1 & 65280) >>> 8;
};
kha__$Color_Color_$Impl_$.get_Bb = function(this1) {
	return this1 & 255;
};
kha__$Color_Color_$Impl_$.get_Ab = function(this1) {
	return this1 >>> 24;
};
kha__$Color_Color_$Impl_$.set_Rb = function(this1,i) {
	this1 = this1 >>> 24 << 24 | i << 16 | (this1 & 65280) >>> 8 << 8 | this1 & 255;
	return i;
};
kha__$Color_Color_$Impl_$.set_Gb = function(this1,i) {
	this1 = this1 >>> 24 << 24 | (this1 & 16711680) >>> 16 << 16 | i << 8 | this1 & 255;
	return i;
};
kha__$Color_Color_$Impl_$.set_Bb = function(this1,i) {
	this1 = this1 >>> 24 << 24 | (this1 & 16711680) >>> 16 << 16 | (this1 & 65280) >>> 8 << 8 | i;
	return i;
};
kha__$Color_Color_$Impl_$.set_Ab = function(this1,i) {
	this1 = i << 24 | (this1 & 16711680) >>> 16 << 16 | (this1 & 65280) >>> 8 << 8 | this1 & 255;
	return i;
};
kha__$Color_Color_$Impl_$.get_R = function(this1) {
	return ((this1 & 16711680) >>> 16) * 0.00392156862745098;
};
kha__$Color_Color_$Impl_$.get_G = function(this1) {
	return ((this1 & 65280) >>> 8) * 0.00392156862745098;
};
kha__$Color_Color_$Impl_$.get_B = function(this1) {
	return (this1 & 255) * 0.00392156862745098;
};
kha__$Color_Color_$Impl_$.get_A = function(this1) {
	return (this1 >>> 24) * 0.00392156862745098;
};
kha__$Color_Color_$Impl_$.set_R = function(this1,f) {
	this1 = ((this1 >>> 24) * 0.00392156862745098 * 255 | 0) << 24 | (f * 255 | 0) << 16 | (((this1 & 65280) >>> 8) * 0.00392156862745098 * 255 | 0) << 8 | ((this1 & 255) * 0.00392156862745098 * 255 | 0);
	return f;
};
kha__$Color_Color_$Impl_$.set_G = function(this1,f) {
	this1 = ((this1 >>> 24) * 0.00392156862745098 * 255 | 0) << 24 | (((this1 & 16711680) >>> 16) * 0.00392156862745098 * 255 | 0) << 16 | (f * 255 | 0) << 8 | ((this1 & 255) * 0.00392156862745098 * 255 | 0);
	return f;
};
kha__$Color_Color_$Impl_$.set_B = function(this1,f) {
	this1 = ((this1 >>> 24) * 0.00392156862745098 * 255 | 0) << 24 | (((this1 & 16711680) >>> 16) * 0.00392156862745098 * 255 | 0) << 16 | (((this1 & 65280) >>> 8) * 0.00392156862745098 * 255 | 0) << 8 | (f * 255 | 0);
	return f;
};
kha__$Color_Color_$Impl_$.set_A = function(this1,f) {
	this1 = (f * 255 | 0) << 24 | (((this1 & 16711680) >>> 16) * 0.00392156862745098 * 255 | 0) << 16 | (((this1 & 65280) >>> 8) * 0.00392156862745098 * 255 | 0) << 8 | ((this1 & 255) * 0.00392156862745098 * 255 | 0);
	return f;
};
var kha_CompilerDefines = function() { };
$hxClasses["kha.CompilerDefines"] = kha_CompilerDefines;
kha_CompilerDefines.__name__ = true;
var kha_EnvironmentVariables = function() {
};
$hxClasses["kha.EnvironmentVariables"] = kha_EnvironmentVariables;
kha_EnvironmentVariables.__name__ = true;
kha_EnvironmentVariables.prototype = {
	getVariable: function(name) {
		return "";
	}
	,__class__: kha_EnvironmentVariables
};
var kha_FontStyle = function(bold,italic,underlined) {
	this.bold = bold;
	this.italic = italic;
	this.underlined = underlined;
};
$hxClasses["kha.FontStyle"] = kha_FontStyle;
kha_FontStyle.__name__ = true;
kha_FontStyle.prototype = {
	bold: null
	,italic: null
	,underlined: null
	,getBold: function() {
		return this.bold;
	}
	,getItalic: function() {
		return this.italic;
	}
	,getUnderlined: function() {
		return this.underlined;
	}
	,__class__: kha_FontStyle
};
var kha_Framebuffer = function(windowId,g1,g2,g4) {
	this.windowId = windowId;
	this.graphics1 = g1;
	this.graphics2 = g2;
	this.graphics4 = g4;
};
$hxClasses["kha.Framebuffer"] = kha_Framebuffer;
kha_Framebuffer.__name__ = true;
kha_Framebuffer.__interfaces__ = [kha_Canvas];
kha_Framebuffer.prototype = {
	windowId: null
	,graphics1: null
	,graphics2: null
	,graphics4: null
	,init: function(g1,g2,g4) {
		this.graphics1 = g1;
		this.graphics2 = g2;
		this.graphics4 = g4;
	}
	,g1: null
	,get_g1: function() {
		return this.graphics1;
	}
	,g2: null
	,get_g2: function() {
		return this.graphics2;
	}
	,g4: null
	,get_g4: function() {
		return this.graphics4;
	}
	,width: null
	,get_width: function() {
		return kha_System.windowWidth(this.windowId);
	}
	,height: null
	,get_height: function() {
		return kha_System.windowHeight(this.windowId);
	}
	,__class__: kha_Framebuffer
};
var kha_AlignedQuad = function() {
};
$hxClasses["kha.AlignedQuad"] = kha_AlignedQuad;
kha_AlignedQuad.__name__ = true;
kha_AlignedQuad.prototype = {
	x0: null
	,y0: null
	,s0: null
	,t0: null
	,x1: null
	,y1: null
	,s1: null
	,t1: null
	,xadvance: null
	,__class__: kha_AlignedQuad
};
var kha_KravurImage = function(size,ascent,descent,lineGap,width,height,chars,pixels) {
	this.mySize = size;
	this.width = width;
	this.height = height;
	this.chars = chars;
	this.baseline = ascent;
	var _g = 0;
	while(_g < chars.length) {
		var $char = chars[_g];
		++_g;
		$char.yoff += this.baseline;
	}
	this.texture = kha_Image.create(width,height,kha_graphics4_TextureFormat.L8);
	var bytes = this.texture.lock();
	var pos = 0;
	var _g1 = 0;
	var _g2 = height;
	while(_g1 < _g2) {
		var y = _g1++;
		var _g3 = 0;
		var _g21 = width;
		while(_g3 < _g21) {
			var x = _g3++;
			var v = pixels.readU8(pos);
			bytes.b[pos] = v & 255;
			++pos;
		}
	}
	this.texture.unlock();
};
$hxClasses["kha.KravurImage"] = kha_KravurImage;
kha_KravurImage.__name__ = true;
kha_KravurImage.prototype = {
	mySize: null
	,chars: null
	,texture: null
	,width: null
	,height: null
	,baseline: null
	,getTexture: function() {
		return this.texture;
	}
	,getBakedQuad: function(char_index,xpos,ypos) {
		if(char_index >= this.chars.length) {
			return null;
		}
		var ipw = 1.0 / this.width;
		var iph = 1.0 / this.height;
		var b = this.chars[char_index];
		if(b == null) {
			return null;
		}
		var round_x = Math.round(xpos + b.xoff);
		var round_y = Math.round(ypos + b.yoff);
		var q = new kha_AlignedQuad();
		q.x0 = round_x;
		q.y0 = round_y;
		q.x1 = round_x + b.x1 - b.x0;
		q.y1 = round_y + b.y1 - b.y0;
		q.s0 = b.x0 * ipw;
		q.t0 = b.y0 * iph;
		q.s1 = b.x1 * ipw;
		q.t1 = b.y1 * iph;
		q.xadvance = b.xadvance;
		return q;
	}
	,getCharWidth: function(charIndex) {
		if(this.chars.length == 0) {
			return 0;
		}
		var offset = kha_Kravur.gaps[0];
		if(charIndex < offset) {
			return this.chars[0].xadvance;
		}
		var _g1 = 1;
		var _g = kha_Kravur.gaps.length / 2 | 0;
		while(_g1 < _g) {
			var i = _g1++;
			var prevEnd = kha_Kravur.gaps[i * 2 - 1];
			var start = kha_Kravur.gaps[i * 2];
			if(charIndex > start - 1) {
				offset += start - 1 - prevEnd;
			}
		}
		if(charIndex - offset >= this.chars.length) {
			return this.chars[0].xadvance;
		}
		return this.chars[charIndex - offset].xadvance;
	}
	,getHeight: function() {
		return this.mySize;
	}
	,stringWidth: function(string) {
		var str = new String(string);
		var width = 0;
		var _g1 = 0;
		var _g = str.length;
		while(_g1 < _g) {
			var c = _g1++;
			width += this.getCharWidth(HxOverrides.cca(str,c));
		}
		return width;
	}
	,charactersWidth: function(characters,start,length) {
		var width = 0;
		var _g1 = start;
		var _g = start + length;
		while(_g1 < _g) {
			var i = _g1++;
			width += this.getCharWidth(characters[i]);
		}
		return width;
	}
	,getBaselinePosition: function() {
		return this.baseline;
	}
	,__class__: kha_KravurImage
};
var kha_Kravur = function(blob) {
	this.images = new haxe_ds_IntMap();
	this.blob = blob;
};
$hxClasses["kha.Kravur"] = kha_Kravur;
kha_Kravur.__name__ = true;
kha_Kravur.__interfaces__ = [kha_Resource];
kha_Kravur.fromBytes = function(bytes) {
	return new kha_Kravur(kha_internal_BytesBlob.fromBytes(bytes));
};
kha_Kravur.prototype = {
	oldGlyphs: null
	,blob: null
	,images: null
	,_get: function(fontSize,glyphs) {
		if(glyphs == null) {
			glyphs = kha_Kravur.glyphs;
		}
		if(glyphs != this.oldGlyphs) {
			this.oldGlyphs = glyphs;
			kha_Kravur.gaps = [glyphs[0]];
			var next = kha_Kravur.gaps[0] + 1;
			var _g1 = 1;
			var _g = glyphs.length;
			while(_g1 < _g) {
				var i = _g1++;
				if(glyphs[i] != next) {
					kha_Kravur.gaps.push(glyphs[i - 1]);
					kha_Kravur.gaps.push(glyphs[i]);
					next = glyphs[i] + 1;
				} else {
					++next;
				}
			}
			kha_Kravur.gaps.push(glyphs[glyphs.length - 1]);
		}
		var imageIndex = glyphs == null ? fontSize : fontSize * 10000 + glyphs.length;
		if(!this.images.h.hasOwnProperty(imageIndex)) {
			var width = 64;
			var height = 32;
			var length = glyphs.length;
			var this1 = new Array(length);
			var baked = this1;
			var _g11 = 0;
			var _g2 = baked.length;
			while(_g11 < _g2) {
				var i1 = _g11++;
				baked[i1] = new kha_graphics2_truetype_Stbtt_$bakedchar();
			}
			var pixels = null;
			var status = -1;
			while(status < 0) {
				if(height < width) {
					height *= 2;
				} else {
					width *= 2;
				}
				pixels = kha_internal_BytesBlob.alloc(width * height);
				status = kha_graphics2_truetype_StbTruetype.stbtt_BakeFontBitmap(this.blob,0,fontSize,pixels,width,height,glyphs,baked);
			}
			var info = new kha_graphics2_truetype_Stbtt_$fontinfo();
			kha_graphics2_truetype_StbTruetype.stbtt_InitFont(info,this.blob,0);
			var metrics = kha_graphics2_truetype_StbTruetype.stbtt_GetFontVMetrics(info);
			var scale = kha_graphics2_truetype_StbTruetype.stbtt_ScaleForPixelHeight(info,fontSize);
			var ascent = Math.round(metrics.ascent * scale);
			var descent = Math.round(metrics.descent * scale);
			var lineGap = Math.round(metrics.lineGap * scale);
			var image = new kha_KravurImage(fontSize | 0,ascent,descent,lineGap,width,height,baked,pixels);
			this.images.h[imageIndex] = image;
			return image;
		}
		return this.images.h[imageIndex];
	}
	,height: function(fontSize) {
		return this._get(fontSize).getHeight();
	}
	,width: function(fontSize,str) {
		return this._get(fontSize).stringWidth(str);
	}
	,widthOfCharacters: function(fontSize,characters,start,length) {
		return this._get(fontSize).charactersWidth(characters,start,length);
	}
	,baseline: function(fontSize) {
		return this._get(fontSize).getBaselinePosition();
	}
	,unload: function() {
		this.blob = null;
		this.images = null;
	}
	,__class__: kha_Kravur
};
var kha_LoaderImpl = function() { };
$hxClasses["kha.LoaderImpl"] = kha_LoaderImpl;
kha_LoaderImpl.__name__ = true;
kha_LoaderImpl.getImageFormats = function() {
	return ["png","jpg","hdr"];
};
kha_LoaderImpl.loadImageFromDescription = function(desc,done) {
	var readable = Object.prototype.hasOwnProperty.call(desc,"readable") && desc.readable;
	if(StringTools.endsWith(desc.files[0],".hdr")) {
		kha_LoaderImpl.loadBlobFromDescription(desc,function(blob) {
			var hdrImage = kha_internal_HdrFormat.parse(blob.toBytes());
			var tmp = kha_Image.fromBytes(haxe_io_Bytes.ofData(hdrImage.data.buffer),hdrImage.width,hdrImage.height,kha_graphics4_TextureFormat.RGBA128,readable ? kha_graphics4_Usage.DynamicUsage : kha_graphics4_Usage.StaticUsage);
			done(tmp);
		});
	} else {
		var img = window.document.createElement("img");
		img.onload = function(event) {
			var tmp1 = kha_Image.fromImage(img,readable);
			done(tmp1);
		};
		img.src = desc.files[0];
		img.crossOrigin = "";
	}
};
kha_LoaderImpl.getSoundFormats = function() {
	var element = window.document.createElement("audio");
	var formats = [];
	if(element.canPlayType("audio/mp4") != "") {
		formats.push("mp4");
	}
	if(kha_SystemImpl._hasWebAudio || element.canPlayType("audio/ogg") != "") {
		formats.push("ogg");
	}
	return formats;
};
kha_LoaderImpl.loadSoundFromDescription = function(desc,done) {
	if(kha_SystemImpl._hasWebAudio) {
		var element = window.document.createElement("audio");
		if(element.canPlayType("audio/mp4") != "") {
			var _g1 = 0;
			var _g = desc.files.length;
			while(_g1 < _g) {
				var i = _g1++;
				var file = desc.files[i];
				if(StringTools.endsWith(file,".mp4")) {
					new kha_js_WebAudioSound(file,done);
					return;
				}
			}
		}
		var _g11 = 0;
		var _g2 = desc.files.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			var file1 = desc.files[i1];
			if(StringTools.endsWith(file1,".ogg")) {
				new kha_js_WebAudioSound(file1,done);
				return;
			}
		}
	} else if(kha_SystemImpl.mobile) {
		var element1 = window.document.createElement("audio");
		if(element1.canPlayType("audio/mp4") != "") {
			var _g12 = 0;
			var _g3 = desc.files.length;
			while(_g12 < _g3) {
				var i2 = _g12++;
				var file2 = desc.files[i2];
				if(StringTools.endsWith(file2,".mp4")) {
					new kha_js_MobileWebAudioSound(file2,done);
					return;
				}
			}
		}
		var _g13 = 0;
		var _g4 = desc.files.length;
		while(_g13 < _g4) {
			var i3 = _g13++;
			var file3 = desc.files[i3];
			if(StringTools.endsWith(file3,".ogg")) {
				new kha_js_MobileWebAudioSound(file3,done);
				return;
			}
		}
	} else {
		new kha_js_Sound(desc.files,done);
	}
};
kha_LoaderImpl.getVideoFormats = function() {
	return ["mp4","webm"];
};
kha_LoaderImpl.loadVideoFromDescription = function(desc,done) {
	kha_js_Video.fromFile(desc.files,done);
};
kha_LoaderImpl.loadBlobFromDescription = function(desc,done) {
	var request = new XMLHttpRequest();
	request.open("GET",desc.files[0],true);
	request.responseType = "arraybuffer";
	request.onreadystatechange = function() {
		if(request.readyState != 4) {
			return;
		}
		if(request.status >= 200 && request.status < 400 || request.status == 0 && request.statusText == "") {
			var bytes = null;
			var arrayBuffer = request.response;
			if(arrayBuffer != null) {
				var byteArray = new Uint8Array(arrayBuffer);
				bytes = haxe_io_Bytes.ofData(byteArray);
			} else if(request.responseBody != null) {
				var data = VBArray(request.responseBody).toArray();
				bytes = new haxe_io_Bytes(new ArrayBuffer(data.length));
				var _g1 = 0;
				var _g = data.length;
				while(_g1 < _g) {
					var i = _g1++;
					bytes.b[i] = data[i] & 255;
				}
			} else {
				haxe_Log.trace("Error loading " + desc.files[0],{ fileName : "LoaderImpl.hx", lineNumber : 145, className : "kha.LoaderImpl", methodName : "loadBlobFromDescription"});
				window.console.log("loadBlob failed");
			}
			done(new kha_internal_BytesBlob(bytes));
		} else {
			haxe_Log.trace("Error loading " + desc.files[0],{ fileName : "LoaderImpl.hx", lineNumber : 151, className : "kha.LoaderImpl", methodName : "loadBlobFromDescription"});
			window.console.log("loadBlob failed");
		}
	};
	request.send(null);
};
kha_LoaderImpl.loadFontFromDescription = function(desc,done) {
	kha_LoaderImpl.loadBlobFromDescription(desc,function(blob) {
		done(new kha_Kravur(blob));
	});
};
var kha_Rotation = function(center,angle) {
	this.center = center;
	this.angle = angle;
};
$hxClasses["kha.Rotation"] = kha_Rotation;
kha_Rotation.__name__ = true;
kha_Rotation.prototype = {
	center: null
	,angle: null
	,__class__: kha_Rotation
};
var kha_TimeTask = function() {
};
$hxClasses["kha.TimeTask"] = kha_TimeTask;
kha_TimeTask.__name__ = true;
kha_TimeTask.prototype = {
	task: null
	,start: null
	,period: null
	,duration: null
	,next: null
	,id: null
	,groupId: null
	,active: null
	,paused: null
	,__class__: kha_TimeTask
};
var kha_FrameTask = function(task,priority,id) {
	this.task = task;
	this.priority = priority;
	this.id = id;
	this.active = true;
	this.paused = false;
};
$hxClasses["kha.FrameTask"] = kha_FrameTask;
kha_FrameTask.__name__ = true;
kha_FrameTask.prototype = {
	task: null
	,priority: null
	,id: null
	,active: null
	,paused: null
	,__class__: kha_FrameTask
};
var kha_Scheduler = function() { };
$hxClasses["kha.Scheduler"] = kha_Scheduler;
kha_Scheduler.__name__ = true;
kha_Scheduler.init = function() {
	kha_Scheduler.deltas = [];
	var _g1 = 0;
	var _g = kha_Scheduler.DIF_COUNT;
	while(_g1 < _g) {
		var i = _g1++;
		kha_Scheduler.deltas[i] = 0;
	}
	kha_Scheduler.stopped = true;
	kha_Scheduler.frame_tasks_sorted = true;
	kha_Scheduler.current = kha_Scheduler.lastTime = kha_Scheduler.realTime();
	kha_Scheduler.currentFrameTaskId = 0;
	kha_Scheduler.currentTimeTaskId = 0;
	kha_Scheduler.currentGroupId = 0;
	kha_Scheduler.timeTasks = [];
	kha_Scheduler.pausedTimeTasks = [];
	kha_Scheduler.outdatedTimeTasks = [];
	kha_Scheduler.timeTasksScratchpad = [];
	kha_Scheduler.frameTasks = [];
	kha_Scheduler.toDeleteFrame = [];
};
kha_Scheduler.start = function(restartTimers) {
	if(restartTimers == null) {
		restartTimers = false;
	}
	kha_Scheduler.vsync = kha_System.get_vsync();
	var hz = kha_System.get_refreshRate();
	if(hz >= 57 && hz <= 63) {
		hz = 60;
	}
	kha_Scheduler.onedifhz = 1.0 / hz;
	kha_Scheduler.stopped = false;
	kha_Scheduler.resetTime();
	kha_Scheduler.lastTime = kha_Scheduler.realTime() - kha_Scheduler.startTime;
	var _g1 = 0;
	var _g = kha_Scheduler.DIF_COUNT;
	while(_g1 < _g) {
		var i = _g1++;
		kha_Scheduler.deltas[i] = 0;
	}
	if(restartTimers) {
		var _g2 = 0;
		var _g11 = kha_Scheduler.timeTasks;
		while(_g2 < _g11.length) {
			var timeTask = _g11[_g2];
			++_g2;
			timeTask.paused = false;
		}
		var _g3 = 0;
		var _g12 = kha_Scheduler.frameTasks;
		while(_g3 < _g12.length) {
			var frameTask = _g12[_g3];
			++_g3;
			frameTask.paused = false;
		}
	}
};
kha_Scheduler.stop = function() {
	kha_Scheduler.stopped = true;
};
kha_Scheduler.isStopped = function() {
	return kha_Scheduler.stopped;
};
kha_Scheduler.warpTimeTasksBack = function(time,tasks) {
	var _g = 0;
	while(_g < tasks.length) {
		var timeTask = tasks[_g];
		++_g;
		if(timeTask.start >= time) {
			timeTask.next = timeTask.start;
		} else if(timeTask.period > 0) {
			var sinceStart = time - timeTask.start;
			var times = Math.ceil(sinceStart / timeTask.period);
			timeTask.next = timeTask.start + times * timeTask.period;
		}
	}
};
kha_Scheduler.warp = function(time) {
	if(time < kha_Scheduler.lastTime) {
		kha_Scheduler.current = time;
		kha_Scheduler.lastTime = time;
		kha_Scheduler.warpTimeTasksBack(time,kha_Scheduler.outdatedTimeTasks);
		kha_Scheduler.warpTimeTasksBack(time,kha_Scheduler.timeTasks);
		var _g = 0;
		var _g1 = kha_Scheduler.outdatedTimeTasks;
		while(_g < _g1.length) {
			var task = _g1[_g];
			++_g;
			if(task.next >= time) {
				kha_Scheduler.timeTasksScratchpad.push(task);
			}
		}
		var _g2 = 0;
		var _g11 = kha_Scheduler.timeTasksScratchpad;
		while(_g2 < _g11.length) {
			var task1 = _g11[_g2];
			++_g2;
			HxOverrides.remove(kha_Scheduler.outdatedTimeTasks,task1);
		}
		var _g3 = 0;
		var _g12 = kha_Scheduler.timeTasksScratchpad;
		while(_g3 < _g12.length) {
			var task2 = _g12[_g3];
			++_g3;
			kha_Scheduler.insertSorted(kha_Scheduler.timeTasks,task2);
		}
		while(kha_Scheduler.timeTasksScratchpad.length > 0) HxOverrides.remove(kha_Scheduler.timeTasksScratchpad,kha_Scheduler.timeTasksScratchpad[0]);
	} else if(time > kha_Scheduler.lastTime) {
		kha_Scheduler.startTime -= time - kha_Scheduler.lastTime;
		kha_Scheduler.current = time;
		kha_Scheduler.lastTime = time;
		kha_Scheduler.executeTimeTasks(time);
	}
};
kha_Scheduler.executeFrame = function() {
	var now = kha_Scheduler.realTime() - kha_Scheduler.startTime;
	var delta = now - kha_Scheduler.lastTime;
	var frameEnd = kha_Scheduler.current;
	if(delta >= 0) {
		if(kha_network_Session.the() == null) {
			if(delta > kha_Scheduler.maxframetime) {
				kha_Scheduler.startTime += delta - kha_Scheduler.maxframetime;
				delta = kha_Scheduler.maxframetime;
				frameEnd += delta;
			} else if(kha_Scheduler.vsync) {
				var realdif = kha_Scheduler.onedifhz;
				while(realdif < delta - kha_Scheduler.onedifhz) realdif += kha_Scheduler.onedifhz;
				delta = realdif;
				var _g1 = 0;
				var _g = kha_Scheduler.DIF_COUNT - 2;
				while(_g1 < _g) {
					var i = _g1++;
					delta += kha_Scheduler.deltas[i];
					kha_Scheduler.deltas[i] = kha_Scheduler.deltas[i + 1];
				}
				delta += kha_Scheduler.deltas[kha_Scheduler.DIF_COUNT - 2];
				delta /= kha_Scheduler.DIF_COUNT;
				kha_Scheduler.deltas[kha_Scheduler.DIF_COUNT - 2] = realdif;
				frameEnd += delta;
			} else {
				var _g11 = 0;
				var _g2 = kha_Scheduler.DIF_COUNT - 1;
				while(_g11 < _g2) {
					var i1 = _g11++;
					kha_Scheduler.deltas[i1] = kha_Scheduler.deltas[i1 + 1];
				}
				kha_Scheduler.deltas[kha_Scheduler.DIF_COUNT - 1] = delta;
				var next = 0;
				var _g12 = 0;
				var _g3 = kha_Scheduler.DIF_COUNT;
				while(_g12 < _g3) {
					var i2 = _g12++;
					next += kha_Scheduler.deltas[i2];
				}
				next /= kha_Scheduler.DIF_COUNT;
				frameEnd += next;
			}
		} else {
			frameEnd += delta;
		}
		kha_Scheduler.lastTime = frameEnd;
		if(!kha_Scheduler.stopped) {
			kha_Scheduler.current = frameEnd;
		}
		var _g4 = 0;
		var _g13 = kha_Scheduler.pausedTimeTasks;
		while(_g4 < _g13.length) {
			var pausedTask = _g13[_g4];
			++_g4;
			pausedTask.next += delta;
		}
		if(kha_Scheduler.stopped) {
			var _g5 = 0;
			var _g14 = kha_Scheduler.timeTasks;
			while(_g5 < _g14.length) {
				var timeTask = _g14[_g5];
				++_g5;
				timeTask.next += delta;
			}
		}
		kha_Scheduler.executeTimeTasks(frameEnd);
		var _g6 = 0;
		var _g15 = kha_Scheduler.outdatedTimeTasks;
		while(_g6 < _g15.length) {
			var task = _g15[_g6];
			++_g6;
			if(task.next < frameEnd - 10.0) {
				kha_Scheduler.timeTasksScratchpad.push(task);
			}
		}
		var _g7 = 0;
		var _g16 = kha_Scheduler.timeTasksScratchpad;
		while(_g7 < _g16.length) {
			var task1 = _g16[_g7];
			++_g7;
			HxOverrides.remove(kha_Scheduler.outdatedTimeTasks,task1);
		}
		while(kha_Scheduler.timeTasksScratchpad.length > 0) HxOverrides.remove(kha_Scheduler.timeTasksScratchpad,kha_Scheduler.timeTasksScratchpad[0]);
	}
	kha_Scheduler.sortFrameTasks();
	var _g8 = 0;
	var _g17 = kha_Scheduler.frameTasks;
	while(_g8 < _g17.length) {
		var frameTask = _g17[_g8];
		++_g8;
		if(!kha_Scheduler.stopped && !frameTask.paused && frameTask.active) {
			if(!frameTask.task()) {
				frameTask.active = false;
			}
		}
	}
	var _g9 = 0;
	var _g18 = kha_Scheduler.frameTasks;
	while(_g9 < _g18.length) {
		var frameTask1 = _g18[_g9];
		++_g9;
		if(!frameTask1.active) {
			kha_Scheduler.toDeleteFrame.push(frameTask1);
		}
	}
	while(kha_Scheduler.toDeleteFrame.length > 0) HxOverrides.remove(kha_Scheduler.frameTasks,kha_Scheduler.toDeleteFrame.pop());
};
kha_Scheduler.executeTimeTasks = function(until) {
	while(kha_Scheduler.timeTasks.length > 0) {
		kha_Scheduler.activeTimeTask = kha_Scheduler.timeTasks[0];
		if(kha_Scheduler.activeTimeTask.next <= until) {
			kha_Scheduler.activeTimeTask.next += kha_Scheduler.activeTimeTask.period;
			HxOverrides.remove(kha_Scheduler.timeTasks,kha_Scheduler.activeTimeTask);
			if(kha_Scheduler.activeTimeTask.active && kha_Scheduler.activeTimeTask.task()) {
				if(kha_Scheduler.activeTimeTask.period > 0 && (kha_Scheduler.activeTimeTask.duration == 0 || kha_Scheduler.activeTimeTask.duration >= kha_Scheduler.activeTimeTask.start + kha_Scheduler.activeTimeTask.next)) {
					kha_Scheduler.insertSorted(kha_Scheduler.timeTasks,kha_Scheduler.activeTimeTask);
				} else {
					kha_Scheduler.archiveTimeTask(kha_Scheduler.activeTimeTask,until);
				}
			} else {
				kha_Scheduler.activeTimeTask.active = false;
				kha_Scheduler.archiveTimeTask(kha_Scheduler.activeTimeTask,until);
			}
		} else {
			break;
		}
	}
	kha_Scheduler.activeTimeTask = null;
};
kha_Scheduler.archiveTimeTask = function(timeTask,frameEnd) {
};
kha_Scheduler.time = function() {
	return kha_Scheduler.current;
};
kha_Scheduler.realTime = function() {
	return kha_System.get_time();
};
kha_Scheduler.resetTime = function() {
	var now = kha_System.get_time();
	var dif = now - kha_Scheduler.startTime;
	kha_Scheduler.startTime = now;
	var _g = 0;
	var _g1 = kha_Scheduler.timeTasks;
	while(_g < _g1.length) {
		var timeTask = _g1[_g];
		++_g;
		timeTask.start -= dif;
		timeTask.next -= dif;
	}
	var _g11 = 0;
	var _g2 = kha_Scheduler.DIF_COUNT;
	while(_g11 < _g2) {
		var i = _g11++;
		kha_Scheduler.deltas[i] = 0;
	}
	kha_Scheduler.current = 0;
	kha_Scheduler.lastTime = 0;
};
kha_Scheduler.addBreakableFrameTask = function(task,priority) {
	kha_Scheduler.frameTasks.push(new kha_FrameTask(task,priority,++kha_Scheduler.currentFrameTaskId));
	kha_Scheduler.frame_tasks_sorted = false;
	return kha_Scheduler.currentFrameTaskId;
};
kha_Scheduler.addFrameTask = function(task,priority) {
	return kha_Scheduler.addBreakableFrameTask(function() {
		task();
		return true;
	},priority);
};
kha_Scheduler.pauseFrameTask = function(id,paused) {
	var _g = 0;
	var _g1 = kha_Scheduler.frameTasks;
	while(_g < _g1.length) {
		var frameTask = _g1[_g];
		++_g;
		if(frameTask.id == id) {
			frameTask.paused = paused;
			break;
		}
	}
};
kha_Scheduler.removeFrameTask = function(id) {
	var _g = 0;
	var _g1 = kha_Scheduler.frameTasks;
	while(_g < _g1.length) {
		var frameTask = _g1[_g];
		++_g;
		if(frameTask.id == id) {
			frameTask.active = false;
			break;
		}
	}
};
kha_Scheduler.generateGroupId = function() {
	return ++kha_Scheduler.currentGroupId;
};
kha_Scheduler.addBreakableTimeTaskToGroup = function(groupId,task,start,period,duration) {
	if(duration == null) {
		duration = 0;
	}
	if(period == null) {
		period = 0;
	}
	var t = new kha_TimeTask();
	t.active = true;
	t.task = task;
	t.id = ++kha_Scheduler.currentTimeTaskId;
	t.groupId = groupId;
	t.start = kha_Scheduler.current + start;
	t.period = 0;
	if(period != 0) {
		t.period = period;
	}
	t.duration = 0;
	if(duration != 0) {
		t.duration = t.start + duration;
	}
	t.next = t.start;
	kha_Scheduler.insertSorted(kha_Scheduler.timeTasks,t);
	return t.id;
};
kha_Scheduler.addTimeTaskToGroup = function(groupId,task,start,period,duration) {
	if(duration == null) {
		duration = 0;
	}
	if(period == null) {
		period = 0;
	}
	return kha_Scheduler.addBreakableTimeTaskToGroup(groupId,function() {
		task();
		return true;
	},start,period,duration);
};
kha_Scheduler.addBreakableTimeTask = function(task,start,period,duration) {
	if(duration == null) {
		duration = 0;
	}
	if(period == null) {
		period = 0;
	}
	return kha_Scheduler.addBreakableTimeTaskToGroup(0,task,start,period,duration);
};
kha_Scheduler.addTimeTask = function(task,start,period,duration) {
	if(duration == null) {
		duration = 0;
	}
	if(period == null) {
		period = 0;
	}
	return kha_Scheduler.addTimeTaskToGroup(0,task,start,period,duration);
};
kha_Scheduler.getTimeTask = function(id) {
	if(kha_Scheduler.activeTimeTask != null && kha_Scheduler.activeTimeTask.id == id) {
		return kha_Scheduler.activeTimeTask;
	}
	var _g = 0;
	var _g1 = kha_Scheduler.timeTasks;
	while(_g < _g1.length) {
		var timeTask = _g1[_g];
		++_g;
		if(timeTask.id == id) {
			return timeTask;
		}
	}
	var _g2 = 0;
	var _g11 = kha_Scheduler.pausedTimeTasks;
	while(_g2 < _g11.length) {
		var timeTask1 = _g11[_g2];
		++_g2;
		if(timeTask1.id == id) {
			return timeTask1;
		}
	}
	return null;
};
kha_Scheduler.pauseTimeTask = function(id,paused) {
	var timeTask = kha_Scheduler.getTimeTask(id);
	if(timeTask != null) {
		kha_Scheduler.pauseRunningTimeTask(timeTask,paused);
	}
	if(kha_Scheduler.activeTimeTask != null && kha_Scheduler.activeTimeTask.id == id) {
		kha_Scheduler.activeTimeTask.paused = paused;
	}
};
kha_Scheduler.pauseRunningTimeTask = function(timeTask,paused) {
	timeTask.paused = paused;
	if(paused) {
		HxOverrides.remove(kha_Scheduler.timeTasks,timeTask);
		kha_Scheduler.pausedTimeTasks.push(timeTask);
	} else {
		kha_Scheduler.insertSorted(kha_Scheduler.timeTasks,timeTask);
		HxOverrides.remove(kha_Scheduler.pausedTimeTasks,timeTask);
	}
};
kha_Scheduler.pauseTimeTasks = function(groupId,paused) {
	var _g = 0;
	var _g1 = kha_Scheduler.timeTasks;
	while(_g < _g1.length) {
		var timeTask = _g1[_g];
		++_g;
		if(timeTask.groupId == groupId) {
			kha_Scheduler.pauseRunningTimeTask(timeTask,paused);
		}
	}
	if(kha_Scheduler.activeTimeTask != null && kha_Scheduler.activeTimeTask.groupId == groupId) {
		kha_Scheduler.activeTimeTask.paused = paused;
	}
};
kha_Scheduler.removeTimeTask = function(id) {
	var timeTask = kha_Scheduler.getTimeTask(id);
	if(timeTask != null) {
		timeTask.active = false;
		HxOverrides.remove(kha_Scheduler.timeTasks,timeTask);
	}
};
kha_Scheduler.removeTimeTasks = function(groupId) {
	var _g = 0;
	var _g1 = kha_Scheduler.timeTasks;
	while(_g < _g1.length) {
		var timeTask = _g1[_g];
		++_g;
		if(timeTask.groupId == groupId) {
			timeTask.active = false;
			kha_Scheduler.timeTasksScratchpad.push(timeTask);
		}
	}
	var _g2 = 0;
	var _g11 = kha_Scheduler.timeTasksScratchpad;
	while(_g2 < _g11.length) {
		var timeTask1 = _g11[_g2];
		++_g2;
		HxOverrides.remove(kha_Scheduler.timeTasks,timeTask1);
	}
	while(kha_Scheduler.timeTasksScratchpad.length > 0) HxOverrides.remove(kha_Scheduler.timeTasksScratchpad,kha_Scheduler.timeTasksScratchpad[0]);
	if(kha_Scheduler.activeTimeTask != null && kha_Scheduler.activeTimeTask.groupId == groupId) {
		kha_Scheduler.activeTimeTask.active = false;
	}
};
kha_Scheduler.numTasksInSchedule = function() {
	return kha_Scheduler.timeTasks.length + kha_Scheduler.frameTasks.length;
};
kha_Scheduler.insertSorted = function(list,task) {
	var _g1 = 0;
	var _g = list.length;
	while(_g1 < _g) {
		var i = _g1++;
		if(list[i].next > task.next) {
			list.splice(i,0,task);
			return;
		}
	}
	list.push(task);
};
kha_Scheduler.sortFrameTasks = function() {
	if(kha_Scheduler.frame_tasks_sorted) {
		return;
	}
	kha_Scheduler.frameTasks.sort(function(a,b) {
		if(a.priority > b.priority) {
			return 1;
		} else if(a.priority < b.priority) {
			return -1;
		} else {
			return 0;
		}
	});
	kha_Scheduler.frame_tasks_sorted = true;
};
var kha_ScreenRotation = $hxClasses["kha.ScreenRotation"] = { __ename__ : true, __constructs__ : ["RotationNone","Rotation90","Rotation180","Rotation270"] };
kha_ScreenRotation.RotationNone = ["RotationNone",0];
kha_ScreenRotation.RotationNone.toString = $estr;
kha_ScreenRotation.RotationNone.__enum__ = kha_ScreenRotation;
kha_ScreenRotation.Rotation90 = ["Rotation90",1];
kha_ScreenRotation.Rotation90.toString = $estr;
kha_ScreenRotation.Rotation90.__enum__ = kha_ScreenRotation;
kha_ScreenRotation.Rotation180 = ["Rotation180",2];
kha_ScreenRotation.Rotation180.toString = $estr;
kha_ScreenRotation.Rotation180.__enum__ = kha_ScreenRotation;
kha_ScreenRotation.Rotation270 = ["Rotation270",3];
kha_ScreenRotation.Rotation270.toString = $estr;
kha_ScreenRotation.Rotation270.__enum__ = kha_ScreenRotation;
var kha_Shaders = function() { };
$hxClasses["kha.Shaders"] = kha_Shaders;
kha_Shaders.__name__ = true;
kha_Shaders.init = function() {
	var blobs = [];
	var _g = 0;
	while(_g < 3) {
		var i = _g++;
		var data = Reflect.field(kha_Shaders,"painter_colored_fragData" + i);
		var bytes = haxe_Unserializer.run(data);
		blobs.push(kha_internal_BytesBlob.fromBytes(bytes));
	}
	kha_Shaders.painter_colored_frag = new kha_graphics4_FragmentShader(blobs,["painter-colored.frag.essl","painter-colored-relaxed.frag.essl","painter-colored-webgl2.frag.essl"]);
	var blobs1 = [];
	var _g1 = 0;
	while(_g1 < 3) {
		var i1 = _g1++;
		var data1 = Reflect.field(kha_Shaders,"painter_colored_vertData" + i1);
		var bytes1 = haxe_Unserializer.run(data1);
		blobs1.push(kha_internal_BytesBlob.fromBytes(bytes1));
	}
	kha_Shaders.painter_colored_vert = new kha_graphics4_VertexShader(blobs1,["painter-colored.vert.essl","painter-colored-relaxed.vert.essl","painter-colored-webgl2.vert.essl"]);
	var blobs2 = [];
	var _g2 = 0;
	while(_g2 < 3) {
		var i2 = _g2++;
		var data2 = Reflect.field(kha_Shaders,"painter_image_fragData" + i2);
		var bytes2 = haxe_Unserializer.run(data2);
		blobs2.push(kha_internal_BytesBlob.fromBytes(bytes2));
	}
	kha_Shaders.painter_image_frag = new kha_graphics4_FragmentShader(blobs2,["painter-image.frag.essl","painter-image-relaxed.frag.essl","painter-image-webgl2.frag.essl"]);
	var blobs3 = [];
	var _g3 = 0;
	while(_g3 < 3) {
		var i3 = _g3++;
		var data3 = Reflect.field(kha_Shaders,"painter_image_vertData" + i3);
		var bytes3 = haxe_Unserializer.run(data3);
		blobs3.push(kha_internal_BytesBlob.fromBytes(bytes3));
	}
	kha_Shaders.painter_image_vert = new kha_graphics4_VertexShader(blobs3,["painter-image.vert.essl","painter-image-relaxed.vert.essl","painter-image-webgl2.vert.essl"]);
	var blobs4 = [];
	var _g4 = 0;
	while(_g4 < 3) {
		var i4 = _g4++;
		var data4 = Reflect.field(kha_Shaders,"painter_text_fragData" + i4);
		var bytes4 = haxe_Unserializer.run(data4);
		blobs4.push(kha_internal_BytesBlob.fromBytes(bytes4));
	}
	kha_Shaders.painter_text_frag = new kha_graphics4_FragmentShader(blobs4,["painter-text.frag.essl","painter-text-relaxed.frag.essl","painter-text-webgl2.frag.essl"]);
	var blobs5 = [];
	var _g5 = 0;
	while(_g5 < 3) {
		var i5 = _g5++;
		var data5 = Reflect.field(kha_Shaders,"painter_text_vertData" + i5);
		var bytes5 = haxe_Unserializer.run(data5);
		blobs5.push(kha_internal_BytesBlob.fromBytes(bytes5));
	}
	kha_Shaders.painter_text_vert = new kha_graphics4_VertexShader(blobs5,["painter-text.vert.essl","painter-text-relaxed.vert.essl","painter-text-webgl2.vert.essl"]);
	var blobs6 = [];
	var _g6 = 0;
	while(_g6 < 3) {
		var i6 = _g6++;
		var data6 = Reflect.field(kha_Shaders,"painter_video_fragData" + i6);
		var bytes6 = haxe_Unserializer.run(data6);
		blobs6.push(kha_internal_BytesBlob.fromBytes(bytes6));
	}
	kha_Shaders.painter_video_frag = new kha_graphics4_FragmentShader(blobs6,["painter-video.frag.essl","painter-video-relaxed.frag.essl","painter-video-webgl2.frag.essl"]);
	var blobs7 = [];
	var _g7 = 0;
	while(_g7 < 3) {
		var i7 = _g7++;
		var data7 = Reflect.field(kha_Shaders,"painter_video_vertData" + i7);
		var bytes7 = haxe_Unserializer.run(data7);
		blobs7.push(kha_internal_BytesBlob.fromBytes(bytes7));
	}
	kha_Shaders.painter_video_vert = new kha_graphics4_VertexShader(blobs7,["painter-video.vert.essl","painter-video-relaxed.vert.essl","painter-video-webgl2.vert.essl"]);
};
var kha_Sound = function() {
};
$hxClasses["kha.Sound"] = kha_Sound;
kha_Sound.__name__ = true;
kha_Sound.__interfaces__ = [kha_Resource];
kha_Sound.prototype = {
	compressedData: null
	,uncompressedData: null
	,uncompress: function(done) {
		var output = new haxe_io_BytesOutput();
		var header = kha_audio2_ogg_vorbis_Reader.readAll(this.compressedData,output,true);
		var soundBytes = output.getBytes();
		var count = soundBytes.length / 4 | 0;
		if(header.channel == 1) {
			var this1 = new Array(count * 2);
			this.uncompressedData = this1;
			var _g1 = 0;
			var _g = count;
			while(_g1 < _g) {
				var i = _g1++;
				this.uncompressedData[i * 2] = soundBytes.getFloat(i * 4);
				this.uncompressedData[i * 2 + 1] = soundBytes.getFloat(i * 4);
			}
		} else {
			var this2 = new Array(count);
			this.uncompressedData = this2;
			var _g11 = 0;
			var _g2 = count;
			while(_g11 < _g2) {
				var i1 = _g11++;
				this.uncompressedData[i1] = soundBytes.getFloat(i1 * 4);
			}
		}
		this.compressedData = null;
		done();
	}
	,unload: function() {
		this.compressedData = null;
		this.uncompressedData = null;
	}
	,__class__: kha_Sound
};
var kha_System = function() { };
$hxClasses["kha.System"] = kha_System;
kha_System.__name__ = true;
kha_System.init = function(options,callback) {
	if(options.title == null) {
		options.title = "Kha";
	}
	if(options.width == null) {
		options.width = 800;
	}
	if(options.height == null) {
		options.height = 600;
	}
	if(options.samplesPerPixel == null) {
		options.samplesPerPixel = 1;
	}
	if(options.vSync == null) {
		options.vSync = true;
	}
	if(options.windowMode == null) {
		options.windowMode = kha_WindowMode.Window;
	}
	if(options.resizable == null) {
		options.resizable = false;
	}
	if(options.maximizable == null) {
		options.maximizable = false;
	}
	if(options.minimizable == null) {
		options.minimizable = true;
	}
	kha_System.theTitle = options.title;
	kha_SystemImpl.init(options,callback);
};
kha_System.initEx = function(title,options,windowCallback,callback) {
	kha_System.theTitle = title;
	kha_SystemImpl.initEx(title,options,windowCallback,callback);
};
kha_System.get_title = function() {
	return kha_System.theTitle;
};
kha_System.notifyOnRender = function(listener,id) {
	if(id == null) {
		id = 0;
	}
	while(id >= kha_System.renderListeners.length) kha_System.renderListeners.push([]);
	kha_System.renderListeners[id].push(listener);
};
kha_System.removeRenderListener = function(listener,id) {
	if(id == null) {
		id = 0;
	}
	HxOverrides.remove(kha_System.renderListeners[id],listener);
};
kha_System.notifyOnApplicationState = function(foregroundListener,resumeListener,pauseListener,backgroundListener,shutdownListener) {
	if(foregroundListener != null) {
		kha_System.foregroundListeners.push(foregroundListener);
	}
	if(resumeListener != null) {
		kha_System.resumeListeners.push(resumeListener);
	}
	if(pauseListener != null) {
		kha_System.pauseListeners.push(pauseListener);
	}
	if(backgroundListener != null) {
		kha_System.backgroundListeners.push(backgroundListener);
	}
	if(shutdownListener != null) {
		kha_System.shutdownListeners.push(shutdownListener);
	}
};
kha_System.notifyOnDropFiles = function(dropFilesListener) {
	kha_System.dropFilesListeners.push(dropFilesListener);
};
kha_System.notifyOnCutCopyPaste = function(cutListener,copyListener,pasteListener) {
	kha_System.cutListener = cutListener;
	kha_System.copyListener = copyListener;
	kha_System.pasteListener = pasteListener;
};
kha_System.render = function(id,framebuffer) {
	if(kha_System.renderListeners.length == 0) {
		return;
	}
	var _g = 0;
	var _g1 = kha_System.renderListeners[id];
	while(_g < _g1.length) {
		var listener = _g1[_g];
		++_g;
		listener(framebuffer);
	}
};
kha_System.foreground = function() {
	var _g = 0;
	var _g1 = kha_System.foregroundListeners;
	while(_g < _g1.length) {
		var listener = _g1[_g];
		++_g;
		listener();
	}
};
kha_System.resume = function() {
	var _g = 0;
	var _g1 = kha_System.resumeListeners;
	while(_g < _g1.length) {
		var listener = _g1[_g];
		++_g;
		listener();
	}
};
kha_System.pause = function() {
	var _g = 0;
	var _g1 = kha_System.pauseListeners;
	while(_g < _g1.length) {
		var listener = _g1[_g];
		++_g;
		listener();
	}
};
kha_System.background = function() {
	var _g = 0;
	var _g1 = kha_System.backgroundListeners;
	while(_g < _g1.length) {
		var listener = _g1[_g];
		++_g;
		listener();
	}
};
kha_System.shutdown = function() {
	var _g = 0;
	var _g1 = kha_System.shutdownListeners;
	while(_g < _g1.length) {
		var listener = _g1[_g];
		++_g;
		listener();
	}
};
kha_System.dropFiles = function(filePath) {
	var _g = 0;
	var _g1 = kha_System.dropFilesListeners;
	while(_g < _g1.length) {
		var listener = _g1[_g];
		++_g;
		listener(filePath);
	}
};
kha_System.get_time = function() {
	return kha_SystemImpl.getTime();
};
kha_System.windowWidth = function(windowId) {
	if(windowId == null) {
		windowId = 0;
	}
	return kha_SystemImpl.windowWidth(windowId);
};
kha_System.windowHeight = function(windowId) {
	if(windowId == null) {
		windowId = 0;
	}
	return kha_SystemImpl.windowHeight(windowId);
};
kha_System.screenDpi = function() {
	return kha_SystemImpl.screenDpi();
};
kha_System.get_screenRotation = function() {
	return kha_SystemImpl.getScreenRotation();
};
kha_System.get_vsync = function() {
	return kha_SystemImpl.getVsync();
};
kha_System.get_refreshRate = function() {
	return kha_SystemImpl.getRefreshRate();
};
kha_System.get_systemId = function() {
	return kha_SystemImpl.getSystemId();
};
kha_System.requestShutdown = function() {
	kha_SystemImpl.requestShutdown();
};
kha_System.changeResolution = function(width,height) {
	kha_SystemImpl.changeResolution(width,height);
};
kha_System.loadUrl = function(url) {
	kha_SystemImpl.loadUrl(url);
};
var kha_GamepadStates = function() {
	this.axes = [];
	this.buttons = [];
};
$hxClasses["kha.GamepadStates"] = kha_GamepadStates;
kha_GamepadStates.__name__ = true;
kha_GamepadStates.prototype = {
	axes: null
	,buttons: null
	,__class__: kha_GamepadStates
};
var kha_SystemImpl = function() { };
$hxClasses["kha.SystemImpl"] = kha_SystemImpl;
kha_SystemImpl.__name__ = true;
kha_SystemImpl.errorHandler = function(message,source,lineno,colno,error) {
	window.console.error(error.stack);
	return true;
};
kha_SystemImpl.init = function(options,callback) {
	kha_SystemImpl.options = options;
	kha_SystemImpl.mobile = kha_SystemImpl.isMobile();
	kha_SystemImpl.ios = kha_SystemImpl.isIOS();
	kha_SystemImpl.chrome = kha_SystemImpl.isChrome();
	kha_SystemImpl.firefox = kha_SystemImpl.isFirefox();
	kha_SystemImpl.init2();
	callback();
};
kha_SystemImpl.initEx = function(title,options,windowCallback,callback) {
	haxe_Log.trace("initEx is not supported on the html5 target, running init() with first window options",{ fileName : "SystemImpl.hx", lineNumber : 80, className : "kha.SystemImpl", methodName : "initEx"});
	kha_SystemImpl.init({ title : title, width : options[0].width, height : options[0].height},callback);
	if(windowCallback != null) {
		windowCallback(0);
	}
};
kha_SystemImpl.isMobile = function() {
	var agent = window.navigator.userAgent;
	if(agent.indexOf("Android") >= 0 || agent.indexOf("webOS") >= 0 || agent.indexOf("BlackBerry") >= 0 || agent.indexOf("Windows Phone") >= 0) {
		return true;
	}
	if(kha_SystemImpl.isIOS()) {
		return true;
	}
	return false;
};
kha_SystemImpl.isIOS = function() {
	var agent = window.navigator.userAgent;
	if(agent.indexOf("iPhone") >= 0 || agent.indexOf("iPad") >= 0 || agent.indexOf("iPod") >= 0) {
		return true;
	}
	return false;
};
kha_SystemImpl.isChrome = function() {
	var agent = window.navigator.userAgent;
	if(agent.indexOf("Chrome") >= 0) {
		return true;
	}
	return false;
};
kha_SystemImpl.isFirefox = function() {
	var agent = window.navigator.userAgent;
	if(agent.indexOf("Firefox") >= 0) {
		return true;
	}
	return false;
};
kha_SystemImpl.windowWidth = function(windowId) {
	if(windowId == null) {
		windowId = 0;
	}
	if(kha_SystemImpl.khanvas.width == 0 && kha_SystemImpl.options.width != null) {
		return kha_SystemImpl.options.width;
	} else {
		return kha_SystemImpl.khanvas.width;
	}
};
kha_SystemImpl.windowHeight = function(windowId) {
	if(windowId == null) {
		windowId = 0;
	}
	if(kha_SystemImpl.khanvas.height == 0 && kha_SystemImpl.options.height != null) {
		return kha_SystemImpl.options.height;
	} else {
		return kha_SystemImpl.khanvas.height;
	}
};
kha_SystemImpl.screenDpi = function() {
	var dpiElement = window.document.createElement("div");
	dpiElement.style.position = "absolute";
	dpiElement.style.width = "1in";
	dpiElement.style.height = "1in";
	dpiElement.style.left = "-100%";
	dpiElement.style.top = "-100%";
	window.document.body.appendChild(dpiElement);
	var dpi = dpiElement.offsetHeight;
	dpiElement.remove();
	return dpi;
};
kha_SystemImpl.setCanvas = function(canvas) {
	kha_SystemImpl.khanvas = canvas;
};
kha_SystemImpl.getScreenRotation = function() {
	return kha_ScreenRotation.RotationNone;
};
kha_SystemImpl.getTime = function() {
	var performance = window.performance ? window.performance : window.Date;
	return performance.now() / 1000;
};
kha_SystemImpl.getVsync = function() {
	return true;
};
kha_SystemImpl.getRefreshRate = function() {
	return 60;
};
kha_SystemImpl.getSystemId = function() {
	return "HTML5";
};
kha_SystemImpl.requestShutdown = function() {
	window.close();
};
kha_SystemImpl.init2 = function(backbufferFormat) {
	haxe_Log.trace = js_Boot.__trace;
	kha_SystemImpl.keyboard = new kha_input_Keyboard();
	kha_SystemImpl.mouse = new kha_input_MouseImpl();
	kha_SystemImpl.surface = new kha_input_Surface();
	kha_SystemImpl.gamepads = [];
	kha_SystemImpl.gamepadStates = [];
	var _g = 0;
	while(_g < 4) {
		var i = _g++;
		kha_SystemImpl.gamepads[i] = new kha_input_Gamepad(i);
		kha_SystemImpl.gamepadStates[i] = new kha_GamepadStates();
	}
	window.addEventListener("gamepadconnected",function(e_) {
		kha_input_Gamepad.sendConnectEvent(e_.gamepad.index);
	});
	window.addEventListener("gamepaddisconnected",function(e_1) {
		kha_input_Gamepad.sendDisconnectEvent(e_1.gamepad.index);
	});
	kha_SystemImpl.pressedKeys = [];
	var _g1 = 0;
	while(_g1 < 256) {
		var i1 = _g1++;
		kha_SystemImpl.pressedKeys.push(false);
	}
	var _g2 = 0;
	while(_g2 < 256) {
		var i2 = _g2++;
		kha_SystemImpl.pressedKeys.push(null);
	}
	window.document.addEventListener("copy",function(e_2) {
		var e = e_2;
		if(kha_System.copyListener != null) {
			var data = kha_System.copyListener();
			if(data != null) {
				e.clipboardData.setData("text/plain",data);
			}
			e.preventDefault();
		}
	});
	window.document.addEventListener("cut",function(e_3) {
		var e1 = e_3;
		if(kha_System.cutListener != null) {
			var data1 = kha_System.cutListener();
			if(data1 != null) {
				e1.clipboardData.setData("text/plain",data1);
			}
			e1.preventDefault();
		}
	});
	window.document.addEventListener("paste",function(e_4) {
		var e2 = e_4;
		if(kha_System.pasteListener != null) {
			var tmp = e2.clipboardData.getData("text/plain");
			kha_System.pasteListener(tmp);
			e2.preventDefault();
		}
	});
	kha_CanvasImage.init();
	kha_Scheduler.init();
	kha_SystemImpl.loadFinished();
	kha_EnvironmentVariables.instance = new kha_js_EnvironmentVariables();
};
kha_SystemImpl.getMouse = function(num) {
	if(num != 0) {
		return null;
	}
	return kha_SystemImpl.mouse;
};
kha_SystemImpl.getKeyboard = function(num) {
	if(num != 0) {
		return null;
	}
	return kha_SystemImpl.keyboard;
};
kha_SystemImpl.checkGamepad = function(pad) {
	var _g1 = 0;
	var _g = pad.axes.length;
	while(_g1 < _g) {
		var i = _g1++;
		if(pad.axes[i] != null) {
			if(kha_SystemImpl.gamepadStates[pad.index].axes[i] != pad.axes[i]) {
				var axis = pad.axes[i];
				if(i % 2 == 1) {
					axis = -axis;
				}
				kha_SystemImpl.gamepadStates[pad.index].axes[i] = axis;
				kha_SystemImpl.gamepads[pad.index].sendAxisEvent(i,axis);
			}
		}
	}
	var _g11 = 0;
	var _g2 = pad.buttons.length;
	while(_g11 < _g2) {
		var i1 = _g11++;
		if(pad.buttons[i1] != null) {
			if(kha_SystemImpl.gamepadStates[pad.index].buttons[i1] != pad.buttons[i1].value) {
				kha_SystemImpl.gamepadStates[pad.index].buttons[i1] = pad.buttons[i1].value;
				kha_SystemImpl.gamepads[pad.index].sendButtonEvent(i1,pad.buttons[i1].value);
			}
		}
	}
	if(pad.axes.length <= 4 && pad.buttons.length > 7) {
		kha_SystemImpl.gamepadStates[pad.index].axes[4] = pad.buttons[6].value;
		kha_SystemImpl.gamepads[pad.index].sendAxisEvent(4,pad.buttons[6].value);
		kha_SystemImpl.gamepadStates[pad.index].axes[5] = pad.buttons[7].value;
		kha_SystemImpl.gamepads[pad.index].sendAxisEvent(5,pad.buttons[7].value);
	}
};
kha_SystemImpl.loadFinished = function() {
	var canvas = kha_SystemImpl.khanvas;
	if(canvas == null) {
		canvas = window.document.getElementById(kha_CompilerDefines.canvas_id);
	}
	canvas.style.cursor = "default";
	var gl = false;
	try {
		kha_SystemImpl.gl = canvas.getContext("webgl2",{ alpha : false, antialias : kha_SystemImpl.options.samplesPerPixel > 1, stencil : true, preserveDrawingBuffer : true});
		kha_SystemImpl.gl.pixelStorei(37441,1);
		kha_SystemImpl.halfFloat = { HALF_FLOAT_OES : 5131};
		kha_SystemImpl.depthTexture = { UNSIGNED_INT_24_8_WEBGL : 34042};
		kha_SystemImpl.drawBuffers = { COLOR_ATTACHMENT0_WEBGL : 36064};
		kha_SystemImpl.elementIndexUint = true;
		kha_SystemImpl.gl.getExtension("EXT_color_buffer_float");
		kha_SystemImpl.gl.getExtension("OES_texture_float_linear");
		kha_SystemImpl.gl.getExtension("OES_texture_half_float_linear");
		kha_SystemImpl.anisotropicFilter = kha_SystemImpl.gl.getExtension("EXT_texture_filter_anisotropic");
		if(kha_SystemImpl.anisotropicFilter == null) {
			kha_SystemImpl.anisotropicFilter = kha_SystemImpl.gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
		}
		gl = true;
		kha_SystemImpl.gl2 = true;
		kha_Shaders.init();
	} catch( e ) {
		haxe_Log.trace("Could not initialize WebGL 2, falling back to WebGL.",{ fileName : "SystemImpl.hx", lineNumber : 335, className : "kha.SystemImpl", methodName : "loadFinished"});
	}
	if(!kha_SystemImpl.gl2) {
		try {
			kha_SystemImpl.gl = canvas.getContext("experimental-webgl",{ alpha : false, antialias : kha_SystemImpl.options.samplesPerPixel > 1, stencil : true, preserveDrawingBuffer : true});
			if(kha_SystemImpl.gl != null) {
				kha_SystemImpl.gl.pixelStorei(37441,1);
				kha_SystemImpl.gl.getExtension("OES_texture_float");
				kha_SystemImpl.gl.getExtension("OES_texture_float_linear");
				kha_SystemImpl.halfFloat = kha_SystemImpl.gl.getExtension("OES_texture_half_float");
				kha_SystemImpl.gl.getExtension("OES_texture_half_float_linear");
				kha_SystemImpl.depthTexture = kha_SystemImpl.gl.getExtension("WEBGL_depth_texture");
				kha_SystemImpl.gl.getExtension("EXT_shader_texture_lod");
				kha_SystemImpl.gl.getExtension("OES_standard_derivatives");
				kha_SystemImpl.anisotropicFilter = kha_SystemImpl.gl.getExtension("EXT_texture_filter_anisotropic");
				if(kha_SystemImpl.anisotropicFilter == null) {
					kha_SystemImpl.anisotropicFilter = kha_SystemImpl.gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
				}
				kha_SystemImpl.drawBuffers = kha_SystemImpl.gl.getExtension("WEBGL_draw_buffers");
				kha_SystemImpl.elementIndexUint = kha_SystemImpl.gl.getExtension("OES_element_index_uint");
				gl = true;
				kha_Shaders.init();
			}
		} catch( e1 ) {
			haxe_Log.trace("Could not initialize WebGL, falling back to Canvas.",{ fileName : "SystemImpl.hx", lineNumber : 359, className : "kha.SystemImpl", methodName : "loadFinished"});
		}
	}
	kha_SystemImpl.setCanvas(canvas);
	if(gl) {
		var g4 = new kha_js_graphics4_Graphics();
		kha_SystemImpl.frame = new kha_Framebuffer(0,null,null,g4);
		kha_SystemImpl.frame.init(new kha_graphics2_Graphics1(kha_SystemImpl.frame),new kha_js_graphics4_Graphics2(kha_SystemImpl.frame),g4);
	} else {
		kha_Kravur = kha_js_Font;
		var g2 = new kha_js_CanvasGraphics(canvas.getContext("2d"));
		kha_SystemImpl.frame = new kha_Framebuffer(0,null,g2,null);
		kha_SystemImpl.frame.init(new kha_graphics2_Graphics1(kha_SystemImpl.frame),g2,null);
	}
	if(!kha_SystemImpl.mobile && kha_audio2_Audio._init()) {
		kha_SystemImpl._hasWebAudio = true;
		kha_audio2_Audio1._init();
	} else if(kha_SystemImpl.mobile) {
		kha_SystemImpl._hasWebAudio = false;
		kha_js_MobileWebAudio._init();
		kha_audio2_Audio1 = kha_js_MobileWebAudio;
	} else {
		kha_SystemImpl._hasWebAudio = false;
		kha_js_AudioElementAudio._compile();
		kha_audio2_Audio1 = kha_js_AudioElementAudio;
	}
	kha_vr_VrInterface.instance = new kha_js_vr_VrInterface();
	kha_Scheduler.start();
	var $window = window;
	var requestAnimationFrame = $window.requestAnimationFrame;
	if(requestAnimationFrame == null) {
		requestAnimationFrame = $window.mozRequestAnimationFrame;
	}
	if(requestAnimationFrame == null) {
		requestAnimationFrame = $window.webkitRequestAnimationFrame;
	}
	if(requestAnimationFrame == null) {
		requestAnimationFrame = $window.msRequestAnimationFrame;
	}
	var animate = null;
	animate = function(timestamp) {
		var window1 = window;
		if(requestAnimationFrame == null) {
			window1.setTimeout(animate,16.6666666666666679);
		} else {
			requestAnimationFrame(animate);
		}
		var sysGamepads = kha_SystemImpl.getGamepads();
		if(sysGamepads != null) {
			var _g1 = 0;
			var _g = sysGamepads.length;
			while(_g1 < _g) {
				var i = _g1++;
				var pad = sysGamepads[i];
				if(pad != null) {
					kha_SystemImpl.checkGamepad(pad);
				}
			}
		}
		kha_Scheduler.executeFrame();
		if(canvas.getContext) {
			var displayWidth = canvas.clientWidth;
			var displayHeight = canvas.clientHeight;
			if(canvas.width != displayWidth || canvas.height != displayHeight) {
				canvas.width = displayWidth;
				canvas.height = displayHeight;
			}
			kha_System.render(0,kha_SystemImpl.frame);
			if(kha_SystemImpl.gl != null) {
				kha_SystemImpl.gl.clearColor(1,1,1,1);
				kha_SystemImpl.gl.colorMask(false,false,false,true);
				kha_SystemImpl.gl.clear(16384);
				kha_SystemImpl.gl.colorMask(true,true,true,true);
			}
		}
	};
	var animate1 = animate;
	if(requestAnimationFrame == null) {
		$window.setTimeout(animate1,16.6666666666666679);
	} else {
		requestAnimationFrame(animate1);
	}
	if(canvas.getAttribute("tabindex") == null) {
		canvas.setAttribute("tabindex","0");
	}
	canvas.focus();
	canvas.oncontextmenu = function(event) {
		event.stopPropagation();
		event.preventDefault();
	};
	canvas.onmousedown = kha_SystemImpl.mouseDown;
	canvas.onmousemove = kha_SystemImpl.mouseMove;
	if(kha_SystemImpl.keyboard != null) {
		canvas.onkeydown = kha_SystemImpl.keyDown;
		canvas.onkeyup = kha_SystemImpl.keyUp;
		canvas.onkeypress = kha_SystemImpl.keyPress;
	}
	canvas.onblur = kha_SystemImpl.onBlur;
	canvas.onfocus = kha_SystemImpl.onFocus;
	canvas.onmousewheel = canvas.onwheel = kha_SystemImpl.mouseWheel;
	canvas.onmouseleave = kha_SystemImpl.mouseLeave;
	canvas.addEventListener("wheel mousewheel",kha_SystemImpl.mouseWheel,false);
	canvas.addEventListener("touchstart",kha_SystemImpl.touchDown,false);
	canvas.addEventListener("touchend",kha_SystemImpl.touchUp,false);
	canvas.addEventListener("touchmove",kha_SystemImpl.touchMove,false);
	canvas.addEventListener("touchcancel",kha_SystemImpl.touchCancel,false);
	window.addEventListener("unload",kha_SystemImpl.unload);
};
kha_SystemImpl.lockMouse = function() {
	if(($_=kha_SystemImpl.khanvas,$bind($_,$_.requestPointerLock))) {
		kha_SystemImpl.khanvas.requestPointerLock();
	} else if(kha_SystemImpl.khanvas.mozRequestPointerLock) {
		kha_SystemImpl.khanvas.mozRequestPointerLock();
	} else if(kha_SystemImpl.khanvas.webkitRequestPointerLock) {
		kha_SystemImpl.khanvas.webkitRequestPointerLock();
	}
};
kha_SystemImpl.unlockMouse = function() {
	if(document.exitPointerLock) {
		document.exitPointerLock();
	} else if(document.mozExitPointerLock) {
		document.mozExitPointerLock();
	} else if(document.webkitExitPointerLock) {
		document.webkitExitPointerLock();
	}
};
kha_SystemImpl.canLockMouse = function() {
	return 'pointerLockElement' in document ||
		'mozPointerLockElement' in document ||
		'webkitPointerLockElement' in document;
};
kha_SystemImpl.isMouseLocked = function() {
	return document.pointerLockElement === kha_SystemImpl.khanvas ||
			document.mozPointerLockElement === kha_SystemImpl.khanvas ||
			document.webkitPointerLockElement === kha_SystemImpl.khanvas;
};
kha_SystemImpl.notifyOfMouseLockChange = function(func,error) {
	window.document.addEventListener("pointerlockchange",func,false);
	window.document.addEventListener("mozpointerlockchange",func,false);
	window.document.addEventListener("webkitpointerlockchange",func,false);
	window.document.addEventListener("pointerlockerror",error,false);
	window.document.addEventListener("mozpointerlockerror",error,false);
	window.document.addEventListener("webkitpointerlockerror",error,false);
};
kha_SystemImpl.removeFromMouseLockChange = function(func,error) {
	window.document.removeEventListener("pointerlockchange",func,false);
	window.document.removeEventListener("mozpointerlockchange",func,false);
	window.document.removeEventListener("webkitpointerlockchange",func,false);
	window.document.removeEventListener("pointerlockerror",error,false);
	window.document.removeEventListener("mozpointerlockerror",error,false);
	window.document.removeEventListener("webkitpointerlockerror",error,false);
};
kha_SystemImpl.unload = function(_) {
};
kha_SystemImpl.setMouseXY = function(event) {
	var rect = kha_SystemImpl.khanvas.getBoundingClientRect();
	var borderWidth = kha_SystemImpl.khanvas.clientLeft;
	var borderHeight = kha_SystemImpl.khanvas.clientTop;
	kha_SystemImpl.mouseX = (event.clientX - rect.left - borderWidth) * kha_SystemImpl.khanvas.width / (rect.width - 2 * borderWidth) | 0;
	kha_SystemImpl.mouseY = (event.clientY - rect.top - borderHeight) * kha_SystemImpl.khanvas.height / (rect.height - 2 * borderHeight) | 0;
};
kha_SystemImpl.unlockSoundOnIOS = function() {
	if(!kha_SystemImpl.ios || kha_SystemImpl.iosSoundEnabled) {
		return;
	}
	var buffer = kha_js_MobileWebAudio._context.createBuffer(1,1,22050);
	var source = kha_js_MobileWebAudio._context.createBufferSource();
	source.buffer = buffer;
	source.connect(kha_js_MobileWebAudio._context.destination);
	if(source.noteOn) {
		source.noteOn(0);
	}
	kha_SystemImpl.iosSoundEnabled = true;
};
kha_SystemImpl.mouseLeave = function() {
	kha_SystemImpl.mouse.sendLeaveEvent(0);
};
kha_SystemImpl.mouseWheel = function(event) {
	kha_SystemImpl.insideInputEvent = true;
	kha_SystemImpl.unlockSoundOnIOS();
	event.preventDefault();
	if(event.deltaMode == 0) {
		if(event.deltaY < 0) {
			kha_SystemImpl.mouse.sendWheelEvent(0,-1);
		} else if(event.deltaY > 0) {
			kha_SystemImpl.mouse.sendWheelEvent(0,1);
		}
		kha_SystemImpl.insideInputEvent = false;
		return false;
	}
	if(event.deltaMode == 1) {
		kha_SystemImpl.minimumScroll = Math.min(kha_SystemImpl.minimumScroll,Math.abs(event.deltaY)) | 0;
		kha_SystemImpl.mouse.sendWheelEvent(0,event.deltaY / kha_SystemImpl.minimumScroll | 0);
		kha_SystemImpl.insideInputEvent = false;
		return false;
	}
	kha_SystemImpl.insideInputEvent = false;
	return false;
};
kha_SystemImpl.mouseDown = function(event) {
	kha_SystemImpl.insideInputEvent = true;
	kha_SystemImpl.unlockSoundOnIOS();
	kha_SystemImpl.setMouseXY(event);
	if(event.which == 1) {
		if(event.ctrlKey) {
			kha_SystemImpl.leftMouseCtrlDown = true;
			kha_SystemImpl.mouse.sendDownEvent(0,1,kha_SystemImpl.mouseX,kha_SystemImpl.mouseY);
		} else {
			kha_SystemImpl.leftMouseCtrlDown = false;
			kha_SystemImpl.mouse.sendDownEvent(0,0,kha_SystemImpl.mouseX,kha_SystemImpl.mouseY);
		}
		if(($_=kha_SystemImpl.khanvas,$bind($_,$_.setCapture)) != null) {
			kha_SystemImpl.khanvas.setCapture();
		} else {
			kha_SystemImpl.khanvas.ownerDocument.addEventListener("mousemove",kha_SystemImpl.documentMouseMove,true);
		}
		kha_SystemImpl.khanvas.ownerDocument.addEventListener("mouseup",kha_SystemImpl.mouseLeftUp);
	} else if(event.which == 2) {
		kha_SystemImpl.mouse.sendDownEvent(0,2,kha_SystemImpl.mouseX,kha_SystemImpl.mouseY);
		kha_SystemImpl.khanvas.ownerDocument.addEventListener("mouseup",kha_SystemImpl.mouseMiddleUp);
	} else if(event.which == 3) {
		kha_SystemImpl.mouse.sendDownEvent(0,1,kha_SystemImpl.mouseX,kha_SystemImpl.mouseY);
		kha_SystemImpl.khanvas.ownerDocument.addEventListener("mouseup",kha_SystemImpl.mouseRightUp);
	}
	kha_SystemImpl.insideInputEvent = false;
};
kha_SystemImpl.mouseLeftUp = function(event) {
	kha_SystemImpl.unlockSoundOnIOS();
	if(event.which != 1) {
		return;
	}
	kha_SystemImpl.insideInputEvent = true;
	kha_SystemImpl.khanvas.ownerDocument.removeEventListener("mouseup",kha_SystemImpl.mouseLeftUp);
	if(($_=kha_SystemImpl.khanvas,$bind($_,$_.releaseCapture)) != null) {
		kha_SystemImpl.khanvas.ownerDocument.releaseCapture();
	} else {
		kha_SystemImpl.khanvas.ownerDocument.removeEventListener("mousemove",kha_SystemImpl.documentMouseMove,true);
	}
	if(kha_SystemImpl.leftMouseCtrlDown) {
		kha_SystemImpl.mouse.sendUpEvent(0,1,kha_SystemImpl.mouseX,kha_SystemImpl.mouseY);
	} else {
		kha_SystemImpl.mouse.sendUpEvent(0,0,kha_SystemImpl.mouseX,kha_SystemImpl.mouseY);
	}
	kha_SystemImpl.leftMouseCtrlDown = false;
	kha_SystemImpl.insideInputEvent = false;
};
kha_SystemImpl.mouseMiddleUp = function(event) {
	kha_SystemImpl.unlockSoundOnIOS();
	if(event.which != 2) {
		return;
	}
	kha_SystemImpl.insideInputEvent = true;
	kha_SystemImpl.khanvas.ownerDocument.removeEventListener("mouseup",kha_SystemImpl.mouseMiddleUp);
	kha_SystemImpl.mouse.sendUpEvent(0,2,kha_SystemImpl.mouseX,kha_SystemImpl.mouseY);
	kha_SystemImpl.insideInputEvent = false;
};
kha_SystemImpl.mouseRightUp = function(event) {
	kha_SystemImpl.unlockSoundOnIOS();
	if(event.which != 3) {
		return;
	}
	kha_SystemImpl.insideInputEvent = true;
	kha_SystemImpl.khanvas.ownerDocument.removeEventListener("mouseup",kha_SystemImpl.mouseRightUp);
	kha_SystemImpl.mouse.sendUpEvent(0,1,kha_SystemImpl.mouseX,kha_SystemImpl.mouseY);
	kha_SystemImpl.insideInputEvent = false;
};
kha_SystemImpl.documentMouseMove = function(event) {
	event.stopPropagation();
	kha_SystemImpl.mouseMove(event);
};
kha_SystemImpl.mouseMove = function(event) {
	kha_SystemImpl.insideInputEvent = true;
	kha_SystemImpl.unlockSoundOnIOS();
	var lastMouseX = kha_SystemImpl.mouseX;
	var lastMouseY = kha_SystemImpl.mouseY;
	kha_SystemImpl.setMouseXY(event);
	var movementX = event.movementX;
	var movementY = event.movementY;
	if(event.movementX == null) {
		if(event.mozMovementX != null) {
			movementX = event.mozMovementX;
		} else if(event.webkitMovementX != null) {
			movementX = event.webkitMovementX;
		} else {
			movementX = kha_SystemImpl.mouseX - lastMouseX;
		}
		if(event.mozMovementY != null) {
			movementY = event.mozMovementY;
		} else if(event.webkitMovementY != null) {
			movementY = event.webkitMovementY;
		} else {
			movementY = kha_SystemImpl.mouseY - lastMouseY;
		}
	}
	if(kha_SystemImpl.firefox) {
		movementX = movementX * window.devicePixelRatio | 0;
		movementY = movementY * window.devicePixelRatio | 0;
	}
	kha_SystemImpl.mouse.sendMoveEvent(0,kha_SystemImpl.mouseX,kha_SystemImpl.mouseY,movementX,movementY);
	kha_SystemImpl.insideInputEvent = false;
};
kha_SystemImpl.setTouchXY = function(touch) {
	var rect = kha_SystemImpl.khanvas.getBoundingClientRect();
	var borderWidth = kha_SystemImpl.khanvas.clientLeft;
	var borderHeight = kha_SystemImpl.khanvas.clientTop;
	kha_SystemImpl.touchX = (touch.clientX - rect.left - borderWidth) * kha_SystemImpl.khanvas.width / (rect.width - 2 * borderWidth) | 0;
	kha_SystemImpl.touchY = (touch.clientY - rect.top - borderHeight) * kha_SystemImpl.khanvas.height / (rect.height - 2 * borderHeight) | 0;
};
kha_SystemImpl.touchDown = function(event) {
	kha_SystemImpl.insideInputEvent = true;
	kha_SystemImpl.unlockSoundOnIOS();
	event.stopPropagation();
	event.preventDefault();
	var _g = 0;
	var _g1 = event.changedTouches;
	while(_g < _g1.length) {
		var touch = _g1[_g];
		++_g;
		var id = touch.identifier;
		if(kha_SystemImpl.ios) {
			id = kha_SystemImpl.iosTouchs.indexOf(-1);
			if(id == -1) {
				id = kha_SystemImpl.iosTouchs.length;
			}
			kha_SystemImpl.iosTouchs[id] = touch.identifier;
		}
		kha_SystemImpl.setTouchXY(touch);
		kha_SystemImpl.mouse.sendDownEvent(0,0,kha_SystemImpl.touchX,kha_SystemImpl.touchY);
		kha_SystemImpl.surface.sendTouchStartEvent(id,kha_SystemImpl.touchX,kha_SystemImpl.touchY);
	}
	kha_SystemImpl.insideInputEvent = false;
};
kha_SystemImpl.touchUp = function(event) {
	kha_SystemImpl.insideInputEvent = true;
	kha_SystemImpl.unlockSoundOnIOS();
	var _g = 0;
	var _g1 = event.changedTouches;
	while(_g < _g1.length) {
		var touch = _g1[_g];
		++_g;
		var id = touch.identifier;
		if(kha_SystemImpl.ios) {
			id = kha_SystemImpl.iosTouchs.indexOf(id);
			kha_SystemImpl.iosTouchs[id] = -1;
		}
		kha_SystemImpl.setTouchXY(touch);
		kha_SystemImpl.mouse.sendUpEvent(0,0,kha_SystemImpl.touchX,kha_SystemImpl.touchY);
		kha_SystemImpl.surface.sendTouchEndEvent(id,kha_SystemImpl.touchX,kha_SystemImpl.touchY);
	}
	kha_SystemImpl.insideInputEvent = false;
};
kha_SystemImpl.touchMove = function(event) {
	kha_SystemImpl.insideInputEvent = true;
	kha_SystemImpl.unlockSoundOnIOS();
	var index = 0;
	var _g = 0;
	var _g1 = event.changedTouches;
	while(_g < _g1.length) {
		var touch = _g1[_g];
		++_g;
		kha_SystemImpl.setTouchXY(touch);
		if(index == 0) {
			var movementX = kha_SystemImpl.touchX - kha_SystemImpl.lastFirstTouchX;
			var movementY = kha_SystemImpl.touchY - kha_SystemImpl.lastFirstTouchY;
			kha_SystemImpl.lastFirstTouchX = kha_SystemImpl.touchX;
			kha_SystemImpl.lastFirstTouchY = kha_SystemImpl.touchY;
			kha_SystemImpl.mouse.sendMoveEvent(0,kha_SystemImpl.touchX,kha_SystemImpl.touchY,movementX,movementY);
		}
		var id = touch.identifier;
		if(kha_SystemImpl.ios) {
			id = kha_SystemImpl.iosTouchs.indexOf(id);
		}
		kha_SystemImpl.surface.sendMoveEvent(id,kha_SystemImpl.touchX,kha_SystemImpl.touchY);
		++index;
	}
	kha_SystemImpl.insideInputEvent = false;
};
kha_SystemImpl.touchCancel = function(event) {
	kha_SystemImpl.insideInputEvent = true;
	kha_SystemImpl.unlockSoundOnIOS();
	var _g = 0;
	var _g1 = event.changedTouches;
	while(_g < _g1.length) {
		var touch = _g1[_g];
		++_g;
		var id = touch.identifier;
		if(kha_SystemImpl.ios) {
			id = kha_SystemImpl.iosTouchs.indexOf(id);
		}
		kha_SystemImpl.setTouchXY(touch);
		kha_SystemImpl.mouse.sendUpEvent(0,0,kha_SystemImpl.touchX,kha_SystemImpl.touchY);
		kha_SystemImpl.surface.sendTouchEndEvent(id,kha_SystemImpl.touchX,kha_SystemImpl.touchY);
	}
	kha_SystemImpl.iosTouchs = [];
	kha_SystemImpl.insideInputEvent = false;
};
kha_SystemImpl.onBlur = function() {
	kha_System.background();
};
kha_SystemImpl.onFocus = function() {
	kha_System.foreground();
};
kha_SystemImpl.keycodeToChar = function(key,keycode,shift) {
	if(key != null) {
		if(key.length == 1) {
			return key;
		}
		switch(key) {
		case "Add":
			return "+";
		case "Divide":
			return "/";
		case "Multiply":
			return "*";
		case "Subtract":
			return "-";
		}
	}
	switch(keycode) {
	case 48:
		if(shift) {
			return "=";
		} else {
			return "0";
		}
		break;
	case 49:
		if(shift) {
			return "!";
		} else {
			return "1";
		}
		break;
	case 50:
		if(shift) {
			return "\"";
		} else {
			return "2";
		}
		break;
	case 51:
		if(shift) {
			return "§";
		} else {
			return "3";
		}
		break;
	case 52:
		if(shift) {
			return "$";
		} else {
			return "4";
		}
		break;
	case 53:
		if(shift) {
			return "%";
		} else {
			return "5";
		}
		break;
	case 54:
		if(shift) {
			return "&";
		} else {
			return "6";
		}
		break;
	case 55:
		if(shift) {
			return "/";
		} else {
			return "7";
		}
		break;
	case 56:
		if(shift) {
			return "(";
		} else {
			return "8";
		}
		break;
	case 57:
		if(shift) {
			return ")";
		} else {
			return "9";
		}
		break;
	case 106:
		return "*";
	case 107:
		return "+";
	case 109:
		return "-";
	case 111:
		return "/";
	case 187:
		if(shift) {
			return "*";
		} else {
			return "+";
		}
		break;
	case 188:
		if(shift) {
			return ";";
		} else {
			return ",";
		}
		break;
	case 189:
		if(shift) {
			return "_";
		} else {
			return "-";
		}
		break;
	case 190:
		if(shift) {
			return ":";
		} else {
			return ".";
		}
		break;
	case 191:
		if(shift) {
			return "'";
		} else {
			return "#";
		}
		break;
	case 212:
		if(shift) {
			return "`";
		} else {
			return "´";
		}
		break;
	case 219:
		if(shift) {
			return "?";
		} else {
			return "ß";
		}
		break;
	case 226:
		if(shift) {
			return ">";
		} else {
			return "<";
		}
		break;
	}
	if(keycode >= 96 && keycode <= 105) {
		return String.fromCharCode(-48 + keycode);
	}
	if(keycode >= 65 && keycode <= 90) {
		if(shift) {
			return String.fromCharCode(keycode);
		} else {
			return String.fromCharCode(keycode - 65 + 97);
		}
	}
	return String.fromCharCode(keycode);
};
kha_SystemImpl.keyDown = function(event) {
	event.stopPropagation();
	if(kha_SystemImpl.pressedKeys[event.keyCode]) {
		event.preventDefault();
		return;
	}
	kha_SystemImpl.pressedKeys[event.keyCode] = true;
	kha_SystemImpl.keyboard.sendDownEvent(event.keyCode);
};
kha_SystemImpl.keyUp = function(event) {
	event.preventDefault();
	event.stopPropagation();
	kha_SystemImpl.pressedKeys[event.keyCode] = false;
	kha_SystemImpl.keyboard.sendUpEvent(event.keyCode);
};
kha_SystemImpl.keyPress = function(event) {
	event.stopPropagation();
	if(kha_SystemImpl.firefox && (event.which == 0 || event.which == 8)) {
		return;
	}
	kha_SystemImpl.keyboard.sendPressEvent(String.fromCharCode(event.which));
};
kha_SystemImpl.canSwitchFullscreen = function() {
	return 'fullscreenElement ' in document ||
		'mozFullScreenElement' in document ||
		'webkitFullscreenElement' in document ||
		'msFullscreenElement' in document
		;
};
kha_SystemImpl.isFullscreen = function() {
	return document.fullscreenElement === this.khanvas ||
			document.mozFullScreenElement === this.khanvas ||
			document.webkitFullscreenElement === this.khanvas ||
			document.msFullscreenElement === this.khanvas ;
};
kha_SystemImpl.requestFullscreen = function() {
	if(($_=kha_SystemImpl.khanvas,$bind($_,$_.requestFullscreen))) {
		kha_SystemImpl.khanvas.requestFullscreen();
	} else if(kha_SystemImpl.khanvas.msRequestFullscreen) {
		kha_SystemImpl.khanvas.msRequestFullscreen();
	} else if(kha_SystemImpl.khanvas.mozRequestFullScreen) {
		kha_SystemImpl.khanvas.mozRequestFullScreen();
	} else if(kha_SystemImpl.khanvas.webkitRequestFullscreen) {
		kha_SystemImpl.khanvas.webkitRequestFullscreen();
	}
};
kha_SystemImpl.exitFullscreen = function() {
	if(document.exitFullscreen) {
		document.exitFullscreen();
	} else if(document.msExitFullscreen) {
		document.msExitFullscreen();
	} else if(document.mozCancelFullScreen) {
		document.mozCancelFullScreen();
	} else if(document.webkitExitFullscreen) {
		document.webkitExitFullscreen();
	}
};
kha_SystemImpl.notifyOfFullscreenChange = function(func,error) {
	window.document.addEventListener("fullscreenchange",func,false);
	window.document.addEventListener("mozfullscreenchange",func,false);
	window.document.addEventListener("webkitfullscreenchange",func,false);
	window.document.addEventListener("MSFullscreenChange",func,false);
	window.document.addEventListener("fullscreenerror",error,false);
	window.document.addEventListener("mozfullscreenerror",error,false);
	window.document.addEventListener("webkitfullscreenerror",error,false);
	window.document.addEventListener("MSFullscreenError",error,false);
};
kha_SystemImpl.removeFromFullscreenChange = function(func,error) {
	window.document.removeEventListener("fullscreenchange",func,false);
	window.document.removeEventListener("mozfullscreenchange",func,false);
	window.document.removeEventListener("webkitfullscreenchange",func,false);
	window.document.removeEventListener("MSFullscreenChange",func,false);
	window.document.removeEventListener("fullscreenerror",error,false);
	window.document.removeEventListener("mozfullscreenerror",error,false);
	window.document.removeEventListener("webkitfullscreenerror",error,false);
	window.document.removeEventListener("MSFullscreenError",error,false);
};
kha_SystemImpl.changeResolution = function(width,height) {
};
kha_SystemImpl.setKeepScreenOn = function(on) {
};
kha_SystemImpl.loadUrl = function(url) {
	window.open(url,"_blank");
};
kha_SystemImpl.getGamepadId = function(index) {
	var sysGamepads = kha_SystemImpl.getGamepads();
	if(sysGamepads != null && sysGamepads[index]) {
		return sysGamepads[index].id;
	}
	return "unkown";
};
kha_SystemImpl.getGamepads = function() {
	if(kha_SystemImpl.chrome && kha_vr_VrInterface.instance.IsVrEnabled()) {
		return null;
	}
	if(navigator.getGamepads) {
		return window.navigator.getGamepads();
	} else {
		return null;
	}
};
var kha_Video = function() {
};
$hxClasses["kha.Video"] = kha_Video;
kha_Video.__name__ = true;
kha_Video.__interfaces__ = [kha_Resource];
kha_Video.prototype = {
	width: function() {
		return 100;
	}
	,height: function() {
		return 100;
	}
	,play: function(loop) {
		if(loop == null) {
			loop = false;
		}
	}
	,pause: function() {
	}
	,stop: function() {
	}
	,getLength: function() {
		return 0;
	}
	,getCurrentPos: function() {
		return 0;
	}
	,get_position: function() {
		return 0;
	}
	,set_position: function(value) {
		return 0;
	}
	,getVolume: function() {
		return 1;
	}
	,setVolume: function(volume) {
	}
	,isFinished: function() {
		return this.getCurrentPos() >= this.getLength();
	}
	,unload: function() {
	}
	,__class__: kha_Video
};
var kha_WebGLImage = function(width,height,format,renderTarget,depthStencilFormat) {
	this.pixels = null;
	this.depthTexture = null;
	this.texture = null;
	this.renderBuffer = null;
	this.frameBuffer = null;
	this.myWidth = width;
	this.myHeight = height;
	this.format = format;
	this.renderTarget = renderTarget;
	this.image = null;
	this.video = null;
	this.depthStencilFormat = depthStencilFormat;
	kha_WebGLImage.init();
	if(renderTarget) {
		this.createTexture();
	}
};
$hxClasses["kha.WebGLImage"] = kha_WebGLImage;
kha_WebGLImage.__name__ = true;
kha_WebGLImage.init = function() {
	if(kha_WebGLImage.context == null) {
		kha_WebGLImage.canvas = window.document.createElement("canvas");
		if(kha_WebGLImage.canvas != null) {
			kha_WebGLImage.context = kha_WebGLImage.canvas.getContext("2d");
			kha_WebGLImage.canvas.width = 4096;
			kha_WebGLImage.canvas.height = 4096;
			kha_WebGLImage.context.globalCompositeOperation = "copy";
		}
	}
};
kha_WebGLImage.upperPowerOfTwo = function(v) {
	--v;
	v |= v >>> 1;
	v |= v >>> 2;
	v |= v >>> 4;
	v |= v >>> 8;
	v |= v >>> 16;
	return ++v;
};
kha_WebGLImage.formatByteSize = function(format) {
	switch(format[1]) {
	case 0:
		return 4;
	case 1:
		return 1;
	case 2:
		return 16;
	case 3:
		return 2;
	case 4:
		return 8;
	case 5:
		return 4;
	case 6:
		return 2;
	}
};
kha_WebGLImage.__super__ = kha_Image;
kha_WebGLImage.prototype = $extend(kha_Image.prototype,{
	image: null
	,video: null
	,data: null
	,myWidth: null
	,myHeight: null
	,format: null
	,renderTarget: null
	,frameBuffer: null
	,renderBuffer: null
	,texture: null
	,depthTexture: null
	,graphics1: null
	,graphics2: null
	,graphics4: null
	,depthStencilFormat: null
	,get_g1: function() {
		if(this.graphics1 == null) {
			this.graphics1 = new kha_graphics2_Graphics1(this);
		}
		return this.graphics1;
	}
	,get_g2: function() {
		if(this.graphics2 == null) {
			this.graphics2 = new kha_js_graphics4_Graphics2(this);
		}
		return this.graphics2;
	}
	,get_g4: function() {
		if(this.graphics4 == null) {
			this.graphics4 = new kha_js_graphics4_Graphics(this);
		}
		return this.graphics4;
	}
	,get_width: function() {
		return this.myWidth;
	}
	,get_height: function() {
		return this.myHeight;
	}
	,get_realWidth: function() {
		return this.myWidth;
	}
	,get_realHeight: function() {
		return this.myHeight;
	}
	,isOpaque: function(x,y) {
		if(this.data == null) {
			if(kha_WebGLImage.context == null) {
				return true;
			} else {
				this.createImageData();
			}
		}
		return this.data.data[y * (this.image.width | 0) * 4 + x * 4 + 3] != 0;
	}
	,at: function(x,y) {
		if(this.data == null) {
			if(kha_WebGLImage.context == null) {
				return -16777216;
			} else {
				this.createImageData();
			}
		}
		var r = this.data.data[y * (this.image.width | 0) * 4 + x * 4];
		var g = this.data.data[y * (this.image.width | 0) * 4 + x * 4 + 1];
		var b = this.data.data[y * (this.image.width | 0) * 4 + x * 4 + 2];
		var a = this.data.data[y * (this.image.width | 0) * 4 + x * 4 + 3];
		return kha__$Color_Color_$Impl_$._new(a << 24 | r << 16 | g << 8 | b);
	}
	,createImageData: function() {
		if(js_Boot.__instanceof(this.image,Uint8Array)) {
			this.data = new ImageData(new Uint8ClampedArray(this.image.buffer),this.get_width(),this.get_height());
		} else {
			if(this.get_width() > kha_WebGLImage.canvas.width || this.get_height() > kha_WebGLImage.canvas.height) {
				var cw = kha_WebGLImage.canvas.width;
				var ch = kha_WebGLImage.canvas.height;
				while(this.get_width() > cw || this.get_height() > ch) {
					cw *= 2;
					ch *= 2;
				}
				kha_WebGLImage.canvas.width = cw;
				kha_WebGLImage.canvas.height = ch;
			}
			kha_WebGLImage.context.strokeStyle = "rgba(0,0,0,0)";
			kha_WebGLImage.context.fillStyle = "rgba(0,0,0,0)";
			kha_WebGLImage.context.fillRect(0,0,this.image.width,this.image.height);
			kha_WebGLImage.context.drawImage(this.image,0,0,this.image.width,this.image.height,0,0,this.image.width,this.image.height);
			this.data = kha_WebGLImage.context.getImageData(0,0,this.image.width,this.image.height);
		}
	}
	,createTexture: function() {
		if(kha_SystemImpl.gl == null) {
			return;
		}
		this.texture = kha_SystemImpl.gl.createTexture();
		kha_SystemImpl.gl.bindTexture(3553,this.texture);
		kha_SystemImpl.gl.texParameteri(3553,10240,9729);
		kha_SystemImpl.gl.texParameteri(3553,10241,9729);
		kha_SystemImpl.gl.texParameteri(3553,10242,33071);
		kha_SystemImpl.gl.texParameteri(3553,10243,33071);
		if(this.renderTarget) {
			this.frameBuffer = kha_SystemImpl.gl.createFramebuffer();
			kha_SystemImpl.gl.bindFramebuffer(36160,this.frameBuffer);
			var _g = this.format;
			switch(_g[1]) {
			case 0:
				kha_SystemImpl.gl.texImage2D(3553,0,6408,this.get_realWidth(),this.get_realHeight(),0,6408,5121,null);
				break;
			case 2:
				kha_SystemImpl.gl.texImage2D(3553,0,kha_SystemImpl.gl2 ? 34836 : 6408,this.get_realWidth(),this.get_realHeight(),0,6408,5126,null);
				break;
			case 3:
				kha_SystemImpl.gl.texImage2D(3553,0,kha_SystemImpl.gl2 ? 33189 : 6402,this.get_realWidth(),this.get_realHeight(),0,6402,5123,null);
				break;
			case 4:
				kha_SystemImpl.gl.texImage2D(3553,0,kha_SystemImpl.gl2 ? 34842 : 6408,this.get_realWidth(),this.get_realHeight(),0,6408,kha_SystemImpl.halfFloat.HALF_FLOAT_OES,null);
				break;
			case 5:
				kha_SystemImpl.gl.texImage2D(3553,0,kha_SystemImpl.gl2 ? 33326 : 6406,this.get_realWidth(),this.get_realHeight(),0,kha_SystemImpl.gl2 ? 6403 : 6406,5126,null);
				break;
			case 6:
				kha_SystemImpl.gl.texImage2D(3553,0,kha_SystemImpl.gl2 ? 33325 : 6406,this.get_realWidth(),this.get_realHeight(),0,kha_SystemImpl.gl2 ? 6403 : 6406,kha_SystemImpl.halfFloat.HALF_FLOAT_OES,null);
				break;
			default:
				kha_SystemImpl.gl.texImage2D(3553,0,6408,this.get_realWidth(),this.get_realHeight(),0,6408,5121,null);
			}
			if(this.format == kha_graphics4_TextureFormat.DEPTH16) {
				kha_SystemImpl.gl.texParameteri(3553,10240,9728);
				kha_SystemImpl.gl.texParameteri(3553,10241,9728);
				kha_SystemImpl.gl.framebufferTexture2D(36160,36096,3553,this.texture,0);
				if(!kha_SystemImpl.gl2) {
					var colortex = kha_SystemImpl.gl.createTexture();
					kha_SystemImpl.gl.bindTexture(3553,colortex);
					kha_SystemImpl.gl.texImage2D(3553,0,6408,this.get_realWidth(),this.get_realHeight(),0,6408,5121,null);
					kha_SystemImpl.gl.framebufferTexture2D(36160,36064,3553,colortex,0);
					kha_SystemImpl.gl.bindTexture(3553,this.texture);
				}
			} else {
				kha_SystemImpl.gl.framebufferTexture2D(36160,36064,3553,this.texture,0);
			}
			this.initDepthStencilBuffer(this.depthStencilFormat);
			if(kha_SystemImpl.gl.checkFramebufferStatus(36160) != 36053) {
				haxe_Log.trace("WebGL error: Framebuffer incomplete",{ fileName : "WebGLImage.hx", lineNumber : 218, className : "kha.WebGLImage", methodName : "createTexture"});
			}
			kha_SystemImpl.gl.bindRenderbuffer(36161,null);
			kha_SystemImpl.gl.bindFramebuffer(36160,null);
		} else if(this.video != null) {
			kha_SystemImpl.gl.texImage2D(3553,0,6408,6408,5121,this.video);
		} else {
			var _g1 = this.format;
			switch(_g1[1]) {
			case 0:
				if(js_Boot.__instanceof(this.image,Uint8Array)) {
					kha_SystemImpl.gl.texImage2D(3553,0,6408,this.myWidth,this.myHeight,0,6408,5121,this.image);
				} else {
					kha_SystemImpl.gl.texImage2D(3553,0,6408,6408,5121,this.image);
				}
				break;
			case 2:
				kha_SystemImpl.gl.texImage2D(3553,0,kha_SystemImpl.gl2 ? 34836 : 6408,this.myWidth,this.myHeight,0,6408,5126,this.image);
				break;
			case 4:
				kha_SystemImpl.gl.texImage2D(3553,0,kha_SystemImpl.gl2 ? 34842 : 6408,this.myWidth,this.myHeight,0,6408,kha_SystemImpl.halfFloat.HALF_FLOAT_OES,this.image);
				break;
			case 5:
				kha_SystemImpl.gl.texImage2D(3553,0,kha_SystemImpl.gl2 ? 33326 : 6406,this.myWidth,this.myHeight,0,kha_SystemImpl.gl2 ? 6403 : 6406,5126,this.image);
				break;
			case 6:
				kha_SystemImpl.gl.texImage2D(3553,0,kha_SystemImpl.gl2 ? 33325 : 6406,this.myWidth,this.myHeight,0,kha_SystemImpl.gl2 ? 6403 : 6406,kha_SystemImpl.halfFloat.HALF_FLOAT_OES,this.image);
				break;
			default:
				kha_SystemImpl.gl.texImage2D(3553,0,6408,6408,5121,this.image);
			}
		}
		kha_SystemImpl.gl.bindTexture(3553,null);
	}
	,initDepthStencilBuffer: function(depthStencilFormat) {
		switch(depthStencilFormat) {
		case 0:
			break;
		case 1:case 5:
			if(kha_SystemImpl.depthTexture == null) {
				this.renderBuffer = kha_SystemImpl.gl.createRenderbuffer();
				kha_SystemImpl.gl.bindRenderbuffer(36161,this.renderBuffer);
				kha_SystemImpl.gl.renderbufferStorage(36161,33189,this.get_realWidth(),this.get_realHeight());
				kha_SystemImpl.gl.framebufferRenderbuffer(36160,36096,36161,this.renderBuffer);
			} else {
				this.depthTexture = kha_SystemImpl.gl.createTexture();
				kha_SystemImpl.gl.bindTexture(3553,this.depthTexture);
				if(depthStencilFormat == 1) {
					kha_SystemImpl.gl.texImage2D(3553,0,kha_SystemImpl.gl2 ? 33190 : 6402,this.get_realWidth(),this.get_realHeight(),0,6402,5125,null);
				} else {
					kha_SystemImpl.gl.texImage2D(3553,0,kha_SystemImpl.gl2 ? 33189 : 6402,this.get_realWidth(),this.get_realHeight(),0,6402,5123,null);
				}
				kha_SystemImpl.gl.texParameteri(3553,10240,9728);
				kha_SystemImpl.gl.texParameteri(3553,10241,9728);
				kha_SystemImpl.gl.texParameteri(3553,10242,33071);
				kha_SystemImpl.gl.texParameteri(3553,10243,33071);
				kha_SystemImpl.gl.bindFramebuffer(36160,this.frameBuffer);
				kha_SystemImpl.gl.framebufferTexture2D(36160,36096,3553,this.depthTexture,0);
			}
			break;
		case 2:case 3:case 4:
			if(kha_SystemImpl.depthTexture == null) {
				this.renderBuffer = kha_SystemImpl.gl.createRenderbuffer();
				kha_SystemImpl.gl.bindRenderbuffer(36161,this.renderBuffer);
				kha_SystemImpl.gl.renderbufferStorage(36161,34041,this.get_realWidth(),this.get_realHeight());
				kha_SystemImpl.gl.framebufferRenderbuffer(36160,33306,36161,this.renderBuffer);
			} else {
				this.depthTexture = kha_SystemImpl.gl.createTexture();
				kha_SystemImpl.gl.bindTexture(3553,this.depthTexture);
				kha_SystemImpl.gl.texImage2D(3553,0,kha_SystemImpl.gl2 ? 35056 : 34041,this.get_realWidth(),this.get_realHeight(),0,34041,kha_SystemImpl.depthTexture.UNSIGNED_INT_24_8_WEBGL,null);
				kha_SystemImpl.gl.texParameteri(3553,10240,9728);
				kha_SystemImpl.gl.texParameteri(3553,10241,9728);
				kha_SystemImpl.gl.texParameteri(3553,10242,33071);
				kha_SystemImpl.gl.texParameteri(3553,10243,33071);
				kha_SystemImpl.gl.bindFramebuffer(36160,this.frameBuffer);
				kha_SystemImpl.gl.framebufferTexture2D(36160,33306,3553,this.depthTexture,0);
			}
			break;
		}
	}
	,set: function(stage) {
		kha_SystemImpl.gl.activeTexture(33984 + stage);
		kha_SystemImpl.gl.bindTexture(3553,this.texture);
		if(this.video != null) {
			kha_SystemImpl.gl.texImage2D(3553,0,6408,6408,5121,this.video);
		}
	}
	,setDepth: function(stage) {
		kha_SystemImpl.gl.activeTexture(33984 + stage);
		kha_SystemImpl.gl.bindTexture(3553,this.depthTexture);
	}
	,setDepthStencilFrom: function(image) {
		kha_SystemImpl.gl.bindFramebuffer(36160,this.frameBuffer);
		kha_SystemImpl.gl.framebufferTexture2D(36160,36096,3553,(js_Boot.__cast(image , kha_WebGLImage)).depthTexture,0);
	}
	,bytesToArray: function(bytes) {
		var _g = this.format;
		switch(_g[1]) {
		case 0:case 1:
			return new Uint8Array(bytes.b.bufferValue);
		case 2:case 4:case 5:case 6:
			return new Float32Array(bytes.b.bufferValue);
		default:
			return new Uint8Array(bytes.b.bufferValue);
		}
	}
	,bytes: null
	,lock: function(level) {
		if(level == null) {
			level = 0;
		}
		this.bytes = new haxe_io_Bytes(new ArrayBuffer(kha_WebGLImage.formatByteSize(this.format) * this.get_width() * this.get_height()));
		return this.bytes;
	}
	,unlock: function() {
		if(kha_SystemImpl.gl != null) {
			this.texture = kha_SystemImpl.gl.createTexture();
			kha_SystemImpl.gl.bindTexture(3553,this.texture);
			kha_SystemImpl.gl.texParameteri(3553,10240,9729);
			kha_SystemImpl.gl.texParameteri(3553,10241,9729);
			kha_SystemImpl.gl.texParameteri(3553,10242,33071);
			kha_SystemImpl.gl.texParameteri(3553,10243,33071);
			var _g = this.format;
			switch(_g[1]) {
			case 0:
				kha_SystemImpl.gl.texImage2D(3553,0,6408,this.get_width(),this.get_height(),0,6408,5121,this.bytesToArray(this.bytes));
				break;
			case 1:
				kha_SystemImpl.gl.texImage2D(3553,0,6409,this.get_width(),this.get_height(),0,6409,5121,this.bytesToArray(this.bytes));
				if(kha_SystemImpl.gl.getError() == 1282) {
					var rgbaBytes = new haxe_io_Bytes(new ArrayBuffer(this.get_width() * this.get_height() * 4));
					var _g1 = 0;
					var _g2 = this.get_height();
					while(_g1 < _g2) {
						var y = _g1++;
						var _g3 = 0;
						var _g21 = this.get_width();
						while(_g3 < _g21) {
							var x = _g3++;
							var _this = this.bytes;
							var pos = y * this.get_width() + x;
							var value = _this.b[pos];
							var pos1 = y * this.get_width() * 4 + x * 4;
							rgbaBytes.b[pos1] = value & 255;
							var pos2 = y * this.get_width() * 4 + x * 4 + 1;
							rgbaBytes.b[pos2] = value & 255;
							var pos3 = y * this.get_width() * 4 + x * 4 + 2;
							rgbaBytes.b[pos3] = value & 255;
							var pos4 = y * this.get_width() * 4 + x * 4 + 3;
							rgbaBytes.b[pos4] = 255;
						}
					}
					kha_SystemImpl.gl.texImage2D(3553,0,6408,this.get_width(),this.get_height(),0,6408,5121,this.bytesToArray(rgbaBytes));
				}
				break;
			case 2:
				kha_SystemImpl.gl.texImage2D(3553,0,kha_SystemImpl.gl2 ? 34836 : 6408,this.get_width(),this.get_height(),0,6408,5126,this.bytesToArray(this.bytes));
				break;
			case 4:
				kha_SystemImpl.gl.texImage2D(3553,0,kha_SystemImpl.gl2 ? 34842 : 6408,this.get_width(),this.get_height(),0,6408,kha_SystemImpl.halfFloat.HALF_FLOAT_OES,this.bytesToArray(this.bytes));
				break;
			case 5:
				kha_SystemImpl.gl.texImage2D(3553,0,kha_SystemImpl.gl2 ? 33326 : 6406,this.get_width(),this.get_height(),0,kha_SystemImpl.gl2 ? 6403 : 6406,5126,this.bytesToArray(this.bytes));
				break;
			case 6:
				kha_SystemImpl.gl.texImage2D(3553,0,kha_SystemImpl.gl2 ? 33325 : 6406,this.get_width(),this.get_height(),0,kha_SystemImpl.gl2 ? 6403 : 6406,kha_SystemImpl.halfFloat.HALF_FLOAT_OES,this.bytesToArray(this.bytes));
				break;
			default:
				kha_SystemImpl.gl.texImage2D(3553,0,6408,this.get_width(),this.get_height(),0,6408,5121,this.bytesToArray(this.bytes));
			}
			kha_SystemImpl.gl.bindTexture(3553,null);
			this.bytes = null;
		}
	}
	,pixels: null
	,getPixels: function() {
		if(this.frameBuffer == null) {
			return null;
		}
		if(this.pixels == null) {
			this.pixels = new Uint8Array(kha_WebGLImage.formatByteSize(this.format) * this.get_width() * this.get_height());
		}
		kha_SystemImpl.gl.bindFramebuffer(36160,this.frameBuffer);
		kha_SystemImpl.gl.readPixels(0,0,this.myWidth,this.myHeight,6408,5121,this.pixels);
		return haxe_io_Bytes.ofData(this.pixels.buffer);
	}
	,unload: function() {
		if(this.texture != null) {
			kha_SystemImpl.gl.deleteTexture(this.texture);
		}
		if(this.depthTexture != null) {
			kha_SystemImpl.gl.deleteTexture(this.depthTexture);
		}
		if(this.frameBuffer != null) {
			kha_SystemImpl.gl.deleteFramebuffer(this.frameBuffer);
		}
		if(this.renderBuffer != null) {
			kha_SystemImpl.gl.deleteRenderbuffer(this.renderBuffer);
		}
	}
	,generateMipmaps: function(levels) {
		kha_SystemImpl.gl.bindTexture(3553,this.texture);
		kha_SystemImpl.gl.generateMipmap(3553);
	}
	,setMipmaps: function(mipmaps) {
		kha_SystemImpl.gl.bindTexture(3553,this.texture);
		if(this.format == kha_graphics4_TextureFormat.RGBA128) {
			var _g1 = 0;
			var _g = mipmaps.length;
			while(_g1 < _g) {
				var i = _g1++;
				kha_SystemImpl.gl.texImage2D(3553,i + 1,kha_SystemImpl.gl2 ? 34836 : 6408,mipmaps[i].get_width(),mipmaps[i].get_height(),0,6408,5126,(js_Boot.__cast(mipmaps[i] , kha_WebGLImage)).image);
			}
		} else if(this.format == kha_graphics4_TextureFormat.RGBA64) {
			var _g11 = 0;
			var _g2 = mipmaps.length;
			while(_g11 < _g2) {
				var i1 = _g11++;
				kha_SystemImpl.gl.texImage2D(3553,i1 + 1,kha_SystemImpl.gl2 ? 34842 : 6408,mipmaps[i1].get_width(),mipmaps[i1].get_height(),0,6408,kha_SystemImpl.halfFloat.HALF_FLOAT_OES,(js_Boot.__cast(mipmaps[i1] , kha_WebGLImage)).image);
			}
		} else {
			var _g12 = 0;
			var _g3 = mipmaps.length;
			while(_g12 < _g3) {
				var i2 = _g12++;
				kha_SystemImpl.gl.texImage2D(3553,i2 + 1,6408,6408,5121,(js_Boot.__cast(mipmaps[i2] , kha_WebGLImage)).image);
			}
		}
	}
	,__class__: kha_WebGLImage
});
var kha_WindowMode = $hxClasses["kha.WindowMode"] = { __ename__ : true, __constructs__ : ["Window","BorderlessWindow","Fullscreen"] };
kha_WindowMode.Window = ["Window",0];
kha_WindowMode.Window.toString = $estr;
kha_WindowMode.Window.__enum__ = kha_WindowMode;
kha_WindowMode.BorderlessWindow = ["BorderlessWindow",1];
kha_WindowMode.BorderlessWindow.toString = $estr;
kha_WindowMode.BorderlessWindow.__enum__ = kha_WindowMode;
kha_WindowMode.Fullscreen = ["Fullscreen",2];
kha_WindowMode.Fullscreen.toString = $estr;
kha_WindowMode.Fullscreen.__enum__ = kha_WindowMode;
var kha_Position = $hxClasses["kha.Position"] = { __ename__ : true, __constructs__ : ["Center","Fixed"] };
kha_Position.Center = ["Center",0];
kha_Position.Center.toString = $estr;
kha_Position.Center.__enum__ = kha_Position;
kha_Position.Fixed = function(v) { var $x = ["Fixed",1,v]; $x.__enum__ = kha_Position; $x.toString = $estr; return $x; };
var kha_TargetDisplay = $hxClasses["kha.TargetDisplay"] = { __ename__ : true, __constructs__ : ["Primary","ById"] };
kha_TargetDisplay.Primary = ["Primary",0];
kha_TargetDisplay.Primary.toString = $estr;
kha_TargetDisplay.Primary.__enum__ = kha_TargetDisplay;
kha_TargetDisplay.ById = function(id) { var $x = ["ById",1,id]; $x.__enum__ = kha_TargetDisplay; $x.toString = $estr; return $x; };
var kha_RendererOptions = function(textureFormat,depthStencilFormat,samplesPerPixel) {
	this.textureFormat = textureFormat;
	this.depthStencilFormat = depthStencilFormat;
	this.samplesPerPixel = samplesPerPixel;
};
$hxClasses["kha.RendererOptions"] = kha_RendererOptions;
kha_RendererOptions.__name__ = true;
kha_RendererOptions.prototype = {
	textureFormat: null
	,depthStencilFormat: null
	,samplesPerPixel: null
	,__class__: kha_RendererOptions
};
var kha_WindowedModeOptions = function(minimizable,maximizable,resizable) {
	this.minimizable = minimizable;
	this.maximizable = maximizable;
	this.resizable = resizable;
};
$hxClasses["kha.WindowedModeOptions"] = kha_WindowedModeOptions;
kha_WindowedModeOptions.__name__ = true;
kha_WindowedModeOptions.prototype = {
	minimizable: null
	,maximizable: null
	,resizable: null
	,__class__: kha_WindowedModeOptions
};
var kha_WindowOptions = function(width,height,mode,title,x,y,targetDisplay,rendererOptions,windowedModeOptions) {
	this.width = width;
	this.height = height;
	this.mode = mode;
	this.title = title;
	this.x = x;
	this.y = y;
	this.targetDisplay = targetDisplay;
	this.rendererOptions = rendererOptions;
	this.windowedModeOptions = windowedModeOptions;
};
$hxClasses["kha.WindowOptions"] = kha_WindowOptions;
kha_WindowOptions.__name__ = true;
kha_WindowOptions.prototype = {
	width: null
	,height: null
	,mode: null
	,title: null
	,x: null
	,y: null
	,targetDisplay: null
	,rendererOptions: null
	,windowedModeOptions: null
	,__class__: kha_WindowOptions
};
var kha_arrays__$Float32Array_Float32Array_$Impl_$ = {};
$hxClasses["kha.arrays._Float32Array.Float32Array_Impl_"] = kha_arrays__$Float32Array_Float32Array_$Impl_$;
kha_arrays__$Float32Array_Float32Array_$Impl_$.__name__ = true;
kha_arrays__$Float32Array_Float32Array_$Impl_$._new = function(elements) {
	var this1 = new Float32Array(elements);
	return this1;
};
kha_arrays__$Float32Array_Float32Array_$Impl_$.get_length = function(this1) {
	return this1.length;
};
kha_arrays__$Float32Array_Float32Array_$Impl_$.set = function(this1,index,value) {
	return this1[index] = value;
};
kha_arrays__$Float32Array_Float32Array_$Impl_$.get = function(this1,index) {
	return this1[index];
};
kha_arrays__$Float32Array_Float32Array_$Impl_$.data = function(this1) {
	return this1;
};
kha_arrays__$Float32Array_Float32Array_$Impl_$.arrayRead = function(this1,index) {
	return this1[index];
};
kha_arrays__$Float32Array_Float32Array_$Impl_$.arrayWrite = function(this1,index,value) {
	return this1[index] = value;
};
kha_arrays__$Float32Array_Float32Array_$Impl_$.subarray = function(this1,start,end) {
	return this1.subarray(start,end);
};
var kha_arrays__$Uint32Array_Uint32Array_$Impl_$ = {};
$hxClasses["kha.arrays._Uint32Array.Uint32Array_Impl_"] = kha_arrays__$Uint32Array_Uint32Array_$Impl_$;
kha_arrays__$Uint32Array_Uint32Array_$Impl_$.__name__ = true;
kha_arrays__$Uint32Array_Uint32Array_$Impl_$._new = function(elements) {
	var this1 = new Uint32Array(elements);
	return this1;
};
kha_arrays__$Uint32Array_Uint32Array_$Impl_$.get_length = function(this1) {
	return this1.length;
};
kha_arrays__$Uint32Array_Uint32Array_$Impl_$.set = function(this1,index,value) {
	return this1[index] = value;
};
kha_arrays__$Uint32Array_Uint32Array_$Impl_$.get = function(this1,index) {
	return this1[index];
};
kha_arrays__$Uint32Array_Uint32Array_$Impl_$.data = function(this1) {
	return this1;
};
kha_arrays__$Uint32Array_Uint32Array_$Impl_$.arrayRead = function(this1,index) {
	return this1[index];
};
kha_arrays__$Uint32Array_Uint32Array_$Impl_$.arrayWrite = function(this1,index,value) {
	return this1[index] = value;
};
kha_arrays__$Uint32Array_Uint32Array_$Impl_$.subarray = function(this1,start,end) {
	return this1.subarray(start,end);
};
var kha_audio1_AudioChannel = function() { };
$hxClasses["kha.audio1.AudioChannel"] = kha_audio1_AudioChannel;
kha_audio1_AudioChannel.__name__ = true;
kha_audio1_AudioChannel.prototype = {
	play: null
	,pause: null
	,stop: null
	,length: null
	,get_length: null
	,position: null
	,get_position: null
	,get_volume: null
	,set_volume: null
	,finished: null
	,get_finished: null
	,__class__: kha_audio1_AudioChannel
};
var kha_audio2_Audio = function() { };
$hxClasses["kha.audio2.Audio"] = kha_audio2_Audio;
kha_audio2_Audio.__name__ = true;
kha_audio2_Audio.initContext = function() {
	try {
		kha_audio2_Audio._context = new AudioContext();
		return;
	} catch( e ) {
	}
	try {
		this._context = new webkitAudioContext();
		return;
	} catch( e1 ) {
	}
};
kha_audio2_Audio._init = function() {
	kha_audio2_Audio.initContext();
	if(kha_audio2_Audio._context == null) {
		return false;
	}
	var bufferSize = 2048;
	kha_audio2_Audio.buffer = new kha_audio2_Buffer(bufferSize * 4,2,kha_audio2_Audio._context.sampleRate | 0);
	kha_audio2_Audio.processingNode = kha_audio2_Audio._context.createScriptProcessor(bufferSize,0,2);
	kha_audio2_Audio.processingNode.onaudioprocess = function(e) {
		var output1 = e.outputBuffer.getChannelData(0);
		var output2 = e.outputBuffer.getChannelData(1);
		if(kha_audio2_Audio.audioCallback != null) {
			kha_audio2_Audio.audioCallback(e.outputBuffer.length * 2,kha_audio2_Audio.buffer);
			var _g1 = 0;
			var _g = e.outputBuffer.length;
			while(_g1 < _g) {
				var i = _g1++;
				output1[i] = kha_audio2_Audio.buffer.data[kha_audio2_Audio.buffer.readLocation];
				kha_audio2_Audio.buffer.readLocation += 1;
				output2[i] = kha_audio2_Audio.buffer.data[kha_audio2_Audio.buffer.readLocation];
				kha_audio2_Audio.buffer.readLocation += 1;
				if(kha_audio2_Audio.buffer.readLocation >= kha_audio2_Audio.buffer.size) {
					kha_audio2_Audio.buffer.readLocation = 0;
				}
			}
		} else {
			var _g11 = 0;
			var _g2 = e.outputBuffer.length;
			while(_g11 < _g2) {
				var i1 = _g11++;
				output1[i1] = 0;
				output2[i1] = 0;
			}
		}
	};
	kha_audio2_Audio.processingNode.connect(kha_audio2_Audio._context.destination);
	return true;
};
kha_audio2_Audio.stream = function(sound,loop) {
	if(loop == null) {
		loop = false;
	}
	var element = window.document.createElement("audio");
	var blob = new Blob([sound.compressedData.b.bufferValue],{ type : "audio/mp4"});
	element.src = URL.createObjectURL(blob);
	element.loop = loop;
	var channel = new kha_js_AEAudioChannel(element);
	channel.play();
	return channel;
};
var kha_audio2_Audio1 = function() { };
$hxClasses["kha.audio2.Audio1"] = kha_audio2_Audio1;
kha_audio2_Audio1.__name__ = true;
kha_audio2_Audio1._init = function() {
	var this1 = new Array(16);
	kha_audio2_Audio1.soundChannels = this1;
	var this2 = new Array(16);
	kha_audio2_Audio1.streamChannels = this2;
	var this3 = new Array(16);
	kha_audio2_Audio1.internalSoundChannels = this3;
	var this4 = new Array(16);
	kha_audio2_Audio1.internalStreamChannels = this4;
	var this5 = new Array(512);
	kha_audio2_Audio1.sampleCache1 = this5;
	var this6 = new Array(512);
	kha_audio2_Audio1.sampleCache2 = this6;
	kha_audio2_Audio.audioCallback = kha_audio2_Audio1.mix;
};
kha_audio2_Audio1.max = function(a,b) {
	if(a > b) {
		return a;
	} else {
		return b;
	}
};
kha_audio2_Audio1.min = function(a,b) {
	if(a < b) {
		return a;
	} else {
		return b;
	}
};
kha_audio2_Audio1.mix = function(samples,buffer) {
	if(kha_audio2_Audio1.sampleCache1.length < samples) {
		var this1 = new Array(samples);
		kha_audio2_Audio1.sampleCache1 = this1;
		var this2 = new Array(samples);
		kha_audio2_Audio1.sampleCache2 = this2;
	}
	var _g1 = 0;
	var _g = samples;
	while(_g1 < _g) {
		var i = _g1++;
		kha_audio2_Audio1.sampleCache2[i] = 0;
	}
	var _g2 = 0;
	while(_g2 < 16) {
		var i1 = _g2++;
		kha_audio2_Audio1.internalSoundChannels[i1] = kha_audio2_Audio1.soundChannels[i1];
	}
	var _g3 = 0;
	while(_g3 < 16) {
		var i2 = _g3++;
		kha_audio2_Audio1.internalStreamChannels[i2] = kha_audio2_Audio1.streamChannels[i2];
	}
	var _g4 = 0;
	var _g11 = kha_audio2_Audio1.internalSoundChannels;
	while(_g4 < _g11.length) {
		var channel = _g11[_g4];
		++_g4;
		if(channel == null || channel.get_finished()) {
			continue;
		}
		channel.nextSamples(kha_audio2_Audio1.sampleCache1,samples,buffer.samplesPerSecond);
		var _g31 = 0;
		var _g21 = samples;
		while(_g31 < _g21) {
			var i3 = _g31++;
			var _g41 = i3;
			var _g5 = kha_audio2_Audio1.sampleCache2;
			var val = kha_audio2_Audio1.sampleCache1[i3] * channel.get_volume();
			_g5[_g41] = _g5[_g41] + val;
		}
	}
	var _g6 = 0;
	var _g12 = kha_audio2_Audio1.internalStreamChannels;
	while(_g6 < _g12.length) {
		var channel1 = _g12[_g6];
		++_g6;
		if(channel1 == null || channel1.get_finished()) {
			continue;
		}
		channel1.nextSamples(kha_audio2_Audio1.sampleCache1,samples,buffer.samplesPerSecond);
		var _g32 = 0;
		var _g22 = samples;
		while(_g32 < _g22) {
			var i4 = _g32++;
			var _g42 = i4;
			var _g51 = kha_audio2_Audio1.sampleCache2;
			var val1 = kha_audio2_Audio1.sampleCache1[i4] * channel1.get_volume();
			_g51[_g42] = _g51[_g42] + val1;
		}
	}
	var _g13 = 0;
	var _g7 = samples;
	while(_g13 < _g7) {
		var i5 = _g13++;
		var a = kha_audio2_Audio1.sampleCache2[i5];
		var a1 = a < 1.0 ? a : 1.0;
		buffer.data[buffer.writeLocation] = a1 > -1.0 ? a1 : -1.0;
		buffer.writeLocation += 1;
		if(buffer.writeLocation >= buffer.size) {
			buffer.writeLocation = 0;
		}
	}
};
kha_audio2_Audio1.play = function(sound,loop) {
	if(loop == null) {
		loop = false;
	}
	var channel = null;
	var _g = 0;
	while(_g < 16) {
		var i = _g++;
		if(kha_audio2_Audio1.soundChannels[i] == null || kha_audio2_Audio1.soundChannels[i].get_finished()) {
			channel = new kha_audio2_AudioChannel(loop);
			channel.data = sound.uncompressedData;
			kha_audio2_Audio1.soundChannels[i] = channel;
			break;
		}
	}
	return channel;
};
kha_audio2_Audio1._playAgain = function(channel) {
	var _g = 0;
	while(_g < 16) {
		var i = _g++;
		if(kha_audio2_Audio1.soundChannels[i] == null || kha_audio2_Audio1.soundChannels[i].get_finished() || kha_audio2_Audio1.soundChannels[i] == channel) {
			kha_audio2_Audio1.soundChannels[i] = channel;
			break;
		}
	}
};
kha_audio2_Audio1.stream = function(sound,loop) {
	if(loop == null) {
		loop = false;
	}
	var hardwareChannel = kha_audio2_Audio.stream(sound,loop);
	if(hardwareChannel != null) {
		return hardwareChannel;
	}
	var channel = null;
	var _g = 0;
	while(_g < 16) {
		var i = _g++;
		if(kha_audio2_Audio1.streamChannels[i] == null || kha_audio2_Audio1.streamChannels[i].get_finished()) {
			channel = new kha_audio2_StreamChannel(sound.compressedData,loop);
			kha_audio2_Audio1.streamChannels[i] = channel;
			break;
		}
	}
	return channel;
};
var kha_audio2_AudioChannel = function(looping) {
	this.paused = false;
	this.looping = looping;
	this.myVolume = 1;
	this.myPosition = 0;
};
$hxClasses["kha.audio2.AudioChannel"] = kha_audio2_AudioChannel;
kha_audio2_AudioChannel.__name__ = true;
kha_audio2_AudioChannel.__interfaces__ = [kha_audio1_AudioChannel];
kha_audio2_AudioChannel.prototype = {
	data: null
	,myVolume: null
	,myPosition: null
	,paused: null
	,looping: null
	,nextSamples: function(samples,length,sampleRate) {
		if(this.paused) {
			var _g1 = 0;
			var _g = length;
			while(_g1 < _g) {
				var i = _g1++;
				samples[i] = 0;
			}
			return;
		}
		var w_ptr = 0;
		var chk_ptr = 0;
		while(w_ptr < length) {
			var addressable_data = this.data.length - this.myPosition;
			var next_chunk = addressable_data < length - w_ptr ? addressable_data : length - w_ptr;
			while(chk_ptr < next_chunk) {
				samples[w_ptr] = this.data[this.myPosition];
				++this.myPosition;
				++chk_ptr;
				++w_ptr;
			}
			if(!this.looping) {
				break;
			} else {
				chk_ptr = 0;
				if(this.myPosition >= this.data.length) {
					this.myPosition = 0;
				}
			}
		}
		while(w_ptr < length) {
			samples[w_ptr] = 0;
			++w_ptr;
		}
	}
	,play: function() {
		this.paused = false;
		if(this.get_finished()) {
			this.myPosition = 0;
			kha_audio2_Audio1._playAgain(this);
		}
	}
	,pause: function() {
		this.paused = true;
	}
	,stop: function() {
		this.myPosition = this.data.length;
	}
	,length: null
	,get_length: function() {
		return this.data.length / 44100 / 2;
	}
	,position: null
	,get_position: function() {
		return this.myPosition / 44100 / 2;
	}
	,get_volume: function() {
		return this.myVolume;
	}
	,set_volume: function(value) {
		return this.myVolume = value;
	}
	,finished: null
	,get_finished: function() {
		return this.myPosition >= this.data.length;
	}
	,__class__: kha_audio2_AudioChannel
};
var kha_audio2_Buffer = function(size,channels,samplesPerSecond) {
	this.size = size;
	var this1 = new Array(size);
	this.data = this1;
	this.channels = channels;
	this.samplesPerSecond = samplesPerSecond;
	this.readLocation = 0;
	this.writeLocation = 0;
};
$hxClasses["kha.audio2.Buffer"] = kha_audio2_Buffer;
kha_audio2_Buffer.__name__ = true;
kha_audio2_Buffer.prototype = {
	channels: null
	,samplesPerSecond: null
	,data: null
	,size: null
	,readLocation: null
	,writeLocation: null
	,__class__: kha_audio2_Buffer
};
var kha_audio2_StreamChannel = function(data,loop) {
	this.paused = false;
	this.atend = false;
	this.myVolume = 1;
	this.loop = loop;
	this.reader = kha_audio2_ogg_vorbis_Reader.openFromBytes(data);
};
$hxClasses["kha.audio2.StreamChannel"] = kha_audio2_StreamChannel;
kha_audio2_StreamChannel.__name__ = true;
kha_audio2_StreamChannel.__interfaces__ = [kha_audio1_AudioChannel];
kha_audio2_StreamChannel.prototype = {
	reader: null
	,atend: null
	,loop: null
	,myVolume: null
	,paused: null
	,nextSamples: function(samples,length,sampleRate) {
		if(this.paused) {
			var _g1 = 0;
			var _g = length;
			while(_g1 < _g) {
				var i = _g1++;
				samples[i] = 0;
			}
			return;
		}
		var count = this.reader.read(samples,length / 2 | 0,2,sampleRate,true) * 2;
		if(count < length) {
			if(this.loop) {
				this.reader.set_currentMillisecond(0);
			} else {
				this.atend = true;
			}
			var _g11 = count;
			var _g2 = length;
			while(_g11 < _g2) {
				var i1 = _g11++;
				samples[i1] = 0;
			}
		}
	}
	,play: function() {
		this.paused = false;
	}
	,pause: function() {
		this.paused = true;
	}
	,stop: function() {
		this.atend = true;
	}
	,length: null
	,get_length: function() {
		return this.reader.get_totalMillisecond() / 1000.0;
	}
	,position: null
	,get_position: function() {
		return this.reader.get_currentMillisecond() / 1000.0;
	}
	,get_volume: function() {
		return this.myVolume;
	}
	,set_volume: function(value) {
		return this.myVolume = value;
	}
	,finished: null
	,get_finished: function() {
		return this.atend;
	}
	,__class__: kha_audio2_StreamChannel
};
var kha_audio2_ogg_tools_Crc32 = function() { };
$hxClasses["kha.audio2.ogg.tools.Crc32"] = kha_audio2_ogg_tools_Crc32;
kha_audio2_ogg_tools_Crc32.__name__ = true;
kha_audio2_ogg_tools_Crc32.init = function() {
	if(kha_audio2_ogg_tools_Crc32.table != null) {
		return;
	}
	var this1 = new Array(256);
	kha_audio2_ogg_tools_Crc32.table = this1;
	var _g = 0;
	while(_g < 256) {
		var i = _g++;
		var s = i << 24;
		var _g1 = 0;
		while(_g1 < 8) {
			var j = _g1++;
			s = s << 1 ^ (_$UInt_UInt_$Impl_$.gte(s,1 << 31) ? 79764919 : 0);
		}
		kha_audio2_ogg_tools_Crc32.table[i] = s;
	}
};
kha_audio2_ogg_tools_Crc32.update = function(crc,$byte) {
	return crc << 8 ^ kha_audio2_ogg_tools_Crc32.table[$byte ^ crc >>> 24];
};
var kha_audio2_ogg_tools_MathTools = function() { };
$hxClasses["kha.audio2.ogg.tools.MathTools"] = kha_audio2_ogg_tools_MathTools;
kha_audio2_ogg_tools_MathTools.__name__ = true;
kha_audio2_ogg_tools_MathTools.ilog = function(n) {
	var log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
	if(n < 16384) {
		if(n < 16) {
			return log2_4[n];
		} else if(n < 512) {
			return 5 + log2_4[n >> 5];
		} else {
			return 10 + log2_4[n >> 10];
		}
	} else if(n < 16777216) {
		if(n < 524288) {
			return 15 + log2_4[n >> 15];
		} else {
			return 20 + log2_4[n >> 20];
		}
	} else if(n < 536870912) {
		return 25 + log2_4[n >> 25];
	} else if(n < -2147483648) {
		return 30 + log2_4[n >> 30];
	} else {
		return 0;
	}
};
var kha_audio2_ogg_tools_Mdct = function() { };
$hxClasses["kha.audio2.ogg.tools.Mdct"] = kha_audio2_ogg_tools_Mdct;
kha_audio2_ogg_tools_Mdct.__name__ = true;
kha_audio2_ogg_tools_Mdct.inverseTransform = function(buffer,n,a,b,c,bitReverse) {
	var n2 = n >> 1;
	var n4 = n >> 2;
	var n8 = n >> 3;
	var this1 = new Array(n2);
	var buf2 = this1;
	var dOffset = n2 - 2;
	var aaOffset = 0;
	var eOffset = 0;
	var eStopOffset = n2;
	while(eOffset != eStopOffset) {
		buf2[dOffset + 1] = buffer[eOffset] * a[aaOffset] - buffer[eOffset + 2] * a[aaOffset + 1];
		buf2[dOffset] = buffer[eOffset] * a[aaOffset + 1] + buffer[eOffset + 2] * a[aaOffset];
		dOffset -= 2;
		aaOffset += 2;
		eOffset += 4;
	}
	eOffset = n2 - 3;
	while(dOffset >= 0) {
		buf2[dOffset + 1] = -buffer[eOffset + 2] * a[aaOffset] - -buffer[eOffset] * a[aaOffset + 1];
		buf2[dOffset] = -buffer[eOffset + 2] * a[aaOffset + 1] + -buffer[eOffset] * a[aaOffset];
		dOffset -= 2;
		aaOffset += 2;
		eOffset -= 4;
	}
	var u = buffer;
	var v = buf2;
	var aaOffset1 = n2 - 8;
	var eOffset0 = n4;
	var eOffset1 = 0;
	var dOffset0 = n4;
	var dOffset1 = 0;
	while(aaOffset1 >= 0) {
		var v41_21 = v[eOffset0 + 1] - v[eOffset1 + 1];
		var v40_20 = v[eOffset0] - v[eOffset1];
		u[dOffset0 + 1] = v[eOffset0 + 1] + v[eOffset1 + 1];
		u[dOffset0] = v[eOffset0] + v[eOffset1];
		u[dOffset1 + 1] = v41_21 * a[aaOffset1 + 4] - v40_20 * a[aaOffset1 + 5];
		u[dOffset1] = v40_20 * a[aaOffset1 + 4] + v41_21 * a[aaOffset1 + 5];
		v41_21 = v[eOffset0 + 3] - v[eOffset1 + 3];
		v40_20 = v[eOffset0 + 2] - v[eOffset1 + 2];
		u[dOffset0 + 3] = v[eOffset0 + 3] + v[eOffset1 + 3];
		u[dOffset0 + 2] = v[eOffset0 + 2] + v[eOffset1 + 2];
		u[dOffset1 + 3] = v41_21 * a[aaOffset1] - v40_20 * a[aaOffset1 + 1];
		u[dOffset1 + 2] = v40_20 * a[aaOffset1] + v41_21 * a[aaOffset1 + 1];
		aaOffset1 -= 8;
		dOffset0 += 4;
		dOffset1 += 4;
		eOffset0 += 4;
		eOffset1 += 4;
	}
	var log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
	var ld = (n < 16384 ? n < 16 ? log2_4[n] : n < 512 ? 5 + log2_4[n >> 5] : 10 + log2_4[n >> 10] : n < 16777216 ? n < 524288 ? 15 + log2_4[n >> 15] : 20 + log2_4[n >> 20] : n < 536870912 ? 25 + log2_4[n >> 25] : n < -2147483648 ? 30 + log2_4[n >> 30] : 0) - 1;
	var i_off = n2 - 1 - n4 * 0;
	var eeOffset0 = i_off;
	var eeOffset2 = i_off + -(n >> 3);
	var aOffset = 0;
	var i = (n >> 4 >> 2) + 1;
	while(--i > 0) {
		var k00_20 = u[eeOffset0] - u[eeOffset2];
		var k01_21 = u[eeOffset0 + -1] - u[eeOffset2 + -1];
		var _g = eeOffset0;
		var _g1 = u;
		_g1[_g] = _g1[_g] + u[eeOffset2];
		var _g2 = eeOffset0 + -1;
		var _g11 = u;
		_g11[_g2] = _g11[_g2] + u[eeOffset2 + -1];
		u[eeOffset2] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
		u[eeOffset2 + -1] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
		aOffset += 8;
		k00_20 = u[eeOffset0 + -2] - u[eeOffset2 + -2];
		k01_21 = u[eeOffset0 + -3] - u[eeOffset2 + -3];
		var _g3 = eeOffset0 + -2;
		var _g12 = u;
		_g12[_g3] = _g12[_g3] + u[eeOffset2 + -2];
		var _g4 = eeOffset0 + -3;
		var _g13 = u;
		_g13[_g4] = _g13[_g4] + u[eeOffset2 + -3];
		u[eeOffset2 + -2] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
		u[eeOffset2 + -3] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
		aOffset += 8;
		k00_20 = u[eeOffset0 + -4] - u[eeOffset2 + -4];
		k01_21 = u[eeOffset0 + -5] - u[eeOffset2 + -5];
		var _g5 = eeOffset0 + -4;
		var _g14 = u;
		_g14[_g5] = _g14[_g5] + u[eeOffset2 + -4];
		var _g6 = eeOffset0 + -5;
		var _g15 = u;
		_g15[_g6] = _g15[_g6] + u[eeOffset2 + -5];
		u[eeOffset2 + -4] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
		u[eeOffset2 + -5] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
		aOffset += 8;
		k00_20 = u[eeOffset0 + -6] - u[eeOffset2 + -6];
		k01_21 = u[eeOffset0 + -7] - u[eeOffset2 + -7];
		var _g7 = eeOffset0 + -6;
		var _g16 = u;
		_g16[_g7] = _g16[_g7] + u[eeOffset2 + -6];
		var _g8 = eeOffset0 + -7;
		var _g17 = u;
		_g17[_g8] = _g17[_g8] + u[eeOffset2 + -7];
		u[eeOffset2 + -6] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
		u[eeOffset2 + -7] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
		aOffset += 8;
		eeOffset0 -= 8;
		eeOffset2 -= 8;
	}
	var i_off1 = n2 - 1 - n4;
	var eeOffset01 = i_off1;
	var eeOffset21 = i_off1 + -(n >> 3);
	var aOffset1 = 0;
	var i1 = (n >> 4 >> 2) + 1;
	while(--i1 > 0) {
		var k00_201 = u[eeOffset01] - u[eeOffset21];
		var k01_211 = u[eeOffset01 + -1] - u[eeOffset21 + -1];
		var _g9 = eeOffset01;
		var _g18 = u;
		_g18[_g9] = _g18[_g9] + u[eeOffset21];
		var _g10 = eeOffset01 + -1;
		var _g19 = u;
		_g19[_g10] = _g19[_g10] + u[eeOffset21 + -1];
		u[eeOffset21] = k00_201 * a[aOffset1] - k01_211 * a[aOffset1 + 1];
		u[eeOffset21 + -1] = k01_211 * a[aOffset1] + k00_201 * a[aOffset1 + 1];
		aOffset1 += 8;
		k00_201 = u[eeOffset01 + -2] - u[eeOffset21 + -2];
		k01_211 = u[eeOffset01 + -3] - u[eeOffset21 + -3];
		var _g20 = eeOffset01 + -2;
		var _g110 = u;
		_g110[_g20] = _g110[_g20] + u[eeOffset21 + -2];
		var _g21 = eeOffset01 + -3;
		var _g111 = u;
		_g111[_g21] = _g111[_g21] + u[eeOffset21 + -3];
		u[eeOffset21 + -2] = k00_201 * a[aOffset1] - k01_211 * a[aOffset1 + 1];
		u[eeOffset21 + -3] = k01_211 * a[aOffset1] + k00_201 * a[aOffset1 + 1];
		aOffset1 += 8;
		k00_201 = u[eeOffset01 + -4] - u[eeOffset21 + -4];
		k01_211 = u[eeOffset01 + -5] - u[eeOffset21 + -5];
		var _g22 = eeOffset01 + -4;
		var _g112 = u;
		_g112[_g22] = _g112[_g22] + u[eeOffset21 + -4];
		var _g23 = eeOffset01 + -5;
		var _g113 = u;
		_g113[_g23] = _g113[_g23] + u[eeOffset21 + -5];
		u[eeOffset21 + -4] = k00_201 * a[aOffset1] - k01_211 * a[aOffset1 + 1];
		u[eeOffset21 + -5] = k01_211 * a[aOffset1] + k00_201 * a[aOffset1 + 1];
		aOffset1 += 8;
		k00_201 = u[eeOffset01 + -6] - u[eeOffset21 + -6];
		k01_211 = u[eeOffset01 + -7] - u[eeOffset21 + -7];
		var _g24 = eeOffset01 + -6;
		var _g114 = u;
		_g114[_g24] = _g114[_g24] + u[eeOffset21 + -6];
		var _g25 = eeOffset01 + -7;
		var _g115 = u;
		_g115[_g25] = _g115[_g25] + u[eeOffset21 + -7];
		u[eeOffset21 + -6] = k00_201 * a[aOffset1] - k01_211 * a[aOffset1 + 1];
		u[eeOffset21 + -7] = k01_211 * a[aOffset1] + k00_201 * a[aOffset1 + 1];
		aOffset1 += 8;
		eeOffset01 -= 8;
		eeOffset21 -= 8;
	}
	var d0 = n2 - 1 - n8 * 0;
	var aOffset2 = 0;
	var eOffset01 = d0;
	var eOffset2 = d0 + -(n >> 4);
	var i2 = (n >> 5 >> 2) + 1;
	while(--i2 > 0) {
		var k00_202 = u[eOffset01] - u[eOffset2];
		var k01_212 = u[eOffset01 + -1] - u[eOffset2 + -1];
		var _g26 = eOffset01;
		var _g116 = u;
		_g116[_g26] = _g116[_g26] + u[eOffset2];
		var _g27 = eOffset01 + -1;
		var _g117 = u;
		_g117[_g27] = _g117[_g27] + u[eOffset2 + -1];
		u[eOffset2] = k00_202 * a[aOffset2] - k01_212 * a[aOffset2 + 1];
		u[eOffset2 + -1] = k01_212 * a[aOffset2] + k00_202 * a[aOffset2 + 1];
		aOffset2 += 16;
		k00_202 = u[eOffset01 + -2] - u[eOffset2 + -2];
		k01_212 = u[eOffset01 + -3] - u[eOffset2 + -3];
		var _g28 = eOffset01 + -2;
		var _g118 = u;
		_g118[_g28] = _g118[_g28] + u[eOffset2 + -2];
		var _g29 = eOffset01 + -3;
		var _g119 = u;
		_g119[_g29] = _g119[_g29] + u[eOffset2 + -3];
		u[eOffset2 + -2] = k00_202 * a[aOffset2] - k01_212 * a[aOffset2 + 1];
		u[eOffset2 + -3] = k01_212 * a[aOffset2] + k00_202 * a[aOffset2 + 1];
		aOffset2 += 16;
		k00_202 = u[eOffset01 + -4] - u[eOffset2 + -4];
		k01_212 = u[eOffset01 + -5] - u[eOffset2 + -5];
		var _g30 = eOffset01 + -4;
		var _g120 = u;
		_g120[_g30] = _g120[_g30] + u[eOffset2 + -4];
		var _g31 = eOffset01 + -5;
		var _g121 = u;
		_g121[_g31] = _g121[_g31] + u[eOffset2 + -5];
		u[eOffset2 + -4] = k00_202 * a[aOffset2] - k01_212 * a[aOffset2 + 1];
		u[eOffset2 + -5] = k01_212 * a[aOffset2] + k00_202 * a[aOffset2 + 1];
		aOffset2 += 16;
		k00_202 = u[eOffset01 + -6] - u[eOffset2 + -6];
		k01_212 = u[eOffset01 + -7] - u[eOffset2 + -7];
		var _g32 = eOffset01 + -6;
		var _g122 = u;
		_g122[_g32] = _g122[_g32] + u[eOffset2 + -6];
		var _g33 = eOffset01 + -7;
		var _g123 = u;
		_g123[_g33] = _g123[_g33] + u[eOffset2 + -7];
		u[eOffset2 + -6] = k00_202 * a[aOffset2] - k01_212 * a[aOffset2 + 1];
		u[eOffset2 + -7] = k01_212 * a[aOffset2] + k00_202 * a[aOffset2 + 1];
		eOffset01 -= 8;
		eOffset2 -= 8;
		aOffset2 += 16;
	}
	var d01 = n2 - 1 - n8;
	var aOffset3 = 0;
	var eOffset02 = d01;
	var eOffset21 = d01 + -(n >> 4);
	var i3 = (n >> 5 >> 2) + 1;
	while(--i3 > 0) {
		var k00_203 = u[eOffset02] - u[eOffset21];
		var k01_213 = u[eOffset02 + -1] - u[eOffset21 + -1];
		var _g34 = eOffset02;
		var _g124 = u;
		_g124[_g34] = _g124[_g34] + u[eOffset21];
		var _g35 = eOffset02 + -1;
		var _g125 = u;
		_g125[_g35] = _g125[_g35] + u[eOffset21 + -1];
		u[eOffset21] = k00_203 * a[aOffset3] - k01_213 * a[aOffset3 + 1];
		u[eOffset21 + -1] = k01_213 * a[aOffset3] + k00_203 * a[aOffset3 + 1];
		aOffset3 += 16;
		k00_203 = u[eOffset02 + -2] - u[eOffset21 + -2];
		k01_213 = u[eOffset02 + -3] - u[eOffset21 + -3];
		var _g36 = eOffset02 + -2;
		var _g126 = u;
		_g126[_g36] = _g126[_g36] + u[eOffset21 + -2];
		var _g37 = eOffset02 + -3;
		var _g127 = u;
		_g127[_g37] = _g127[_g37] + u[eOffset21 + -3];
		u[eOffset21 + -2] = k00_203 * a[aOffset3] - k01_213 * a[aOffset3 + 1];
		u[eOffset21 + -3] = k01_213 * a[aOffset3] + k00_203 * a[aOffset3 + 1];
		aOffset3 += 16;
		k00_203 = u[eOffset02 + -4] - u[eOffset21 + -4];
		k01_213 = u[eOffset02 + -5] - u[eOffset21 + -5];
		var _g38 = eOffset02 + -4;
		var _g128 = u;
		_g128[_g38] = _g128[_g38] + u[eOffset21 + -4];
		var _g39 = eOffset02 + -5;
		var _g129 = u;
		_g129[_g39] = _g129[_g39] + u[eOffset21 + -5];
		u[eOffset21 + -4] = k00_203 * a[aOffset3] - k01_213 * a[aOffset3 + 1];
		u[eOffset21 + -5] = k01_213 * a[aOffset3] + k00_203 * a[aOffset3 + 1];
		aOffset3 += 16;
		k00_203 = u[eOffset02 + -6] - u[eOffset21 + -6];
		k01_213 = u[eOffset02 + -7] - u[eOffset21 + -7];
		var _g40 = eOffset02 + -6;
		var _g130 = u;
		_g130[_g40] = _g130[_g40] + u[eOffset21 + -6];
		var _g41 = eOffset02 + -7;
		var _g131 = u;
		_g131[_g41] = _g131[_g41] + u[eOffset21 + -7];
		u[eOffset21 + -6] = k00_203 * a[aOffset3] - k01_213 * a[aOffset3 + 1];
		u[eOffset21 + -7] = k01_213 * a[aOffset3] + k00_203 * a[aOffset3 + 1];
		eOffset02 -= 8;
		eOffset21 -= 8;
		aOffset3 += 16;
	}
	var d02 = n2 - 1 - n8 * 2;
	var aOffset4 = 0;
	var eOffset03 = d02;
	var eOffset22 = d02 + -(n >> 4);
	var i4 = (n >> 5 >> 2) + 1;
	while(--i4 > 0) {
		var k00_204 = u[eOffset03] - u[eOffset22];
		var k01_214 = u[eOffset03 + -1] - u[eOffset22 + -1];
		var _g42 = eOffset03;
		var _g132 = u;
		_g132[_g42] = _g132[_g42] + u[eOffset22];
		var _g43 = eOffset03 + -1;
		var _g133 = u;
		_g133[_g43] = _g133[_g43] + u[eOffset22 + -1];
		u[eOffset22] = k00_204 * a[aOffset4] - k01_214 * a[aOffset4 + 1];
		u[eOffset22 + -1] = k01_214 * a[aOffset4] + k00_204 * a[aOffset4 + 1];
		aOffset4 += 16;
		k00_204 = u[eOffset03 + -2] - u[eOffset22 + -2];
		k01_214 = u[eOffset03 + -3] - u[eOffset22 + -3];
		var _g44 = eOffset03 + -2;
		var _g134 = u;
		_g134[_g44] = _g134[_g44] + u[eOffset22 + -2];
		var _g45 = eOffset03 + -3;
		var _g135 = u;
		_g135[_g45] = _g135[_g45] + u[eOffset22 + -3];
		u[eOffset22 + -2] = k00_204 * a[aOffset4] - k01_214 * a[aOffset4 + 1];
		u[eOffset22 + -3] = k01_214 * a[aOffset4] + k00_204 * a[aOffset4 + 1];
		aOffset4 += 16;
		k00_204 = u[eOffset03 + -4] - u[eOffset22 + -4];
		k01_214 = u[eOffset03 + -5] - u[eOffset22 + -5];
		var _g46 = eOffset03 + -4;
		var _g136 = u;
		_g136[_g46] = _g136[_g46] + u[eOffset22 + -4];
		var _g47 = eOffset03 + -5;
		var _g137 = u;
		_g137[_g47] = _g137[_g47] + u[eOffset22 + -5];
		u[eOffset22 + -4] = k00_204 * a[aOffset4] - k01_214 * a[aOffset4 + 1];
		u[eOffset22 + -5] = k01_214 * a[aOffset4] + k00_204 * a[aOffset4 + 1];
		aOffset4 += 16;
		k00_204 = u[eOffset03 + -6] - u[eOffset22 + -6];
		k01_214 = u[eOffset03 + -7] - u[eOffset22 + -7];
		var _g48 = eOffset03 + -6;
		var _g138 = u;
		_g138[_g48] = _g138[_g48] + u[eOffset22 + -6];
		var _g49 = eOffset03 + -7;
		var _g139 = u;
		_g139[_g49] = _g139[_g49] + u[eOffset22 + -7];
		u[eOffset22 + -6] = k00_204 * a[aOffset4] - k01_214 * a[aOffset4 + 1];
		u[eOffset22 + -7] = k01_214 * a[aOffset4] + k00_204 * a[aOffset4 + 1];
		eOffset03 -= 8;
		eOffset22 -= 8;
		aOffset4 += 16;
	}
	var d03 = n2 - 1 - n8 * 3;
	var aOffset5 = 0;
	var eOffset04 = d03;
	var eOffset23 = d03 + -(n >> 4);
	var i5 = (n >> 5 >> 2) + 1;
	while(--i5 > 0) {
		var k00_205 = u[eOffset04] - u[eOffset23];
		var k01_215 = u[eOffset04 + -1] - u[eOffset23 + -1];
		var _g50 = eOffset04;
		var _g140 = u;
		_g140[_g50] = _g140[_g50] + u[eOffset23];
		var _g51 = eOffset04 + -1;
		var _g141 = u;
		_g141[_g51] = _g141[_g51] + u[eOffset23 + -1];
		u[eOffset23] = k00_205 * a[aOffset5] - k01_215 * a[aOffset5 + 1];
		u[eOffset23 + -1] = k01_215 * a[aOffset5] + k00_205 * a[aOffset5 + 1];
		aOffset5 += 16;
		k00_205 = u[eOffset04 + -2] - u[eOffset23 + -2];
		k01_215 = u[eOffset04 + -3] - u[eOffset23 + -3];
		var _g52 = eOffset04 + -2;
		var _g142 = u;
		_g142[_g52] = _g142[_g52] + u[eOffset23 + -2];
		var _g53 = eOffset04 + -3;
		var _g143 = u;
		_g143[_g53] = _g143[_g53] + u[eOffset23 + -3];
		u[eOffset23 + -2] = k00_205 * a[aOffset5] - k01_215 * a[aOffset5 + 1];
		u[eOffset23 + -3] = k01_215 * a[aOffset5] + k00_205 * a[aOffset5 + 1];
		aOffset5 += 16;
		k00_205 = u[eOffset04 + -4] - u[eOffset23 + -4];
		k01_215 = u[eOffset04 + -5] - u[eOffset23 + -5];
		var _g54 = eOffset04 + -4;
		var _g144 = u;
		_g144[_g54] = _g144[_g54] + u[eOffset23 + -4];
		var _g55 = eOffset04 + -5;
		var _g145 = u;
		_g145[_g55] = _g145[_g55] + u[eOffset23 + -5];
		u[eOffset23 + -4] = k00_205 * a[aOffset5] - k01_215 * a[aOffset5 + 1];
		u[eOffset23 + -5] = k01_215 * a[aOffset5] + k00_205 * a[aOffset5 + 1];
		aOffset5 += 16;
		k00_205 = u[eOffset04 + -6] - u[eOffset23 + -6];
		k01_215 = u[eOffset04 + -7] - u[eOffset23 + -7];
		var _g56 = eOffset04 + -6;
		var _g146 = u;
		_g146[_g56] = _g146[_g56] + u[eOffset23 + -6];
		var _g57 = eOffset04 + -7;
		var _g147 = u;
		_g147[_g57] = _g147[_g57] + u[eOffset23 + -7];
		u[eOffset23 + -6] = k00_205 * a[aOffset5] - k01_215 * a[aOffset5 + 1];
		u[eOffset23 + -7] = k01_215 * a[aOffset5] + k00_205 * a[aOffset5 + 1];
		eOffset04 -= 8;
		eOffset23 -= 8;
		aOffset5 += 16;
	}
	var _g148 = 2;
	var _g58 = ld - 3 >> 1;
	while(_g148 < _g58) {
		var l = _g148++;
		var k0 = n >> l + 2;
		var k0_2 = k0 >> 1;
		var lim = 1 << l + 1;
		var _g310 = 0;
		var _g210 = lim;
		while(_g310 < _g210) {
			var i6 = _g310++;
			var d04 = n2 - 1 - k0 * i6;
			var k1 = 1 << l + 3;
			var aOffset6 = 0;
			var eOffset05 = d04;
			var eOffset24 = d04 + -k0_2;
			var i7 = (n >> l + 4 >> 2) + 1;
			while(--i7 > 0) {
				var k00_206 = u[eOffset05] - u[eOffset24];
				var k01_216 = u[eOffset05 + -1] - u[eOffset24 + -1];
				var _g59 = eOffset05;
				var _g149 = u;
				_g149[_g59] = _g149[_g59] + u[eOffset24];
				var _g60 = eOffset05 + -1;
				var _g150 = u;
				_g150[_g60] = _g150[_g60] + u[eOffset24 + -1];
				u[eOffset24] = k00_206 * a[aOffset6] - k01_216 * a[aOffset6 + 1];
				u[eOffset24 + -1] = k01_216 * a[aOffset6] + k00_206 * a[aOffset6 + 1];
				aOffset6 += k1;
				k00_206 = u[eOffset05 + -2] - u[eOffset24 + -2];
				k01_216 = u[eOffset05 + -3] - u[eOffset24 + -3];
				var _g61 = eOffset05 + -2;
				var _g151 = u;
				_g151[_g61] = _g151[_g61] + u[eOffset24 + -2];
				var _g62 = eOffset05 + -3;
				var _g152 = u;
				_g152[_g62] = _g152[_g62] + u[eOffset24 + -3];
				u[eOffset24 + -2] = k00_206 * a[aOffset6] - k01_216 * a[aOffset6 + 1];
				u[eOffset24 + -3] = k01_216 * a[aOffset6] + k00_206 * a[aOffset6 + 1];
				aOffset6 += k1;
				k00_206 = u[eOffset05 + -4] - u[eOffset24 + -4];
				k01_216 = u[eOffset05 + -5] - u[eOffset24 + -5];
				var _g63 = eOffset05 + -4;
				var _g153 = u;
				_g153[_g63] = _g153[_g63] + u[eOffset24 + -4];
				var _g64 = eOffset05 + -5;
				var _g154 = u;
				_g154[_g64] = _g154[_g64] + u[eOffset24 + -5];
				u[eOffset24 + -4] = k00_206 * a[aOffset6] - k01_216 * a[aOffset6 + 1];
				u[eOffset24 + -5] = k01_216 * a[aOffset6] + k00_206 * a[aOffset6 + 1];
				aOffset6 += k1;
				k00_206 = u[eOffset05 + -6] - u[eOffset24 + -6];
				k01_216 = u[eOffset05 + -7] - u[eOffset24 + -7];
				var _g65 = eOffset05 + -6;
				var _g155 = u;
				_g155[_g65] = _g155[_g65] + u[eOffset24 + -6];
				var _g66 = eOffset05 + -7;
				var _g156 = u;
				_g156[_g66] = _g156[_g66] + u[eOffset24 + -7];
				u[eOffset24 + -6] = k00_206 * a[aOffset6] - k01_216 * a[aOffset6 + 1];
				u[eOffset24 + -7] = k01_216 * a[aOffset6] + k00_206 * a[aOffset6 + 1];
				eOffset05 -= 8;
				eOffset24 -= 8;
				aOffset6 += k1;
			}
		}
	}
	var _g157 = ld - 3 >> 1;
	var _g67 = ld - 6;
	while(_g157 < _g67) {
		var l1 = _g157++;
		var k01 = n >> l1 + 2;
		var k11 = 1 << l1 + 3;
		var k0_21 = k01 >> 1;
		var rlim = n >> l1 + 6;
		var lim1 = 1 << l1 + 1;
		var aOffset7 = 0;
		var i_off2 = n2 - 1;
		var r = rlim + 1;
		while(--r > 0) {
			var A0 = a[aOffset7];
			var A1 = a[aOffset7 + 1];
			var A2 = a[aOffset7 + k11];
			var A3 = a[aOffset7 + k11 + 1];
			var A4 = a[aOffset7 + k11 * 2];
			var A5 = a[aOffset7 + k11 * 2 + 1];
			var A6 = a[aOffset7 + k11 * 3];
			var A7 = a[aOffset7 + k11 * 3 + 1];
			var eeOffset02 = i_off2;
			var eeOffset22 = i_off2 + -k0_21;
			var i8 = lim1 + 1;
			while(--i8 > 0) {
				var k00 = u[eeOffset02] - u[eeOffset22];
				var k111 = u[eeOffset02 + -1] - u[eeOffset22 + -1];
				u[eeOffset02] = u[eeOffset02] + u[eeOffset22];
				u[eeOffset02 + -1] = u[eeOffset02 + -1] + u[eeOffset22 + -1];
				u[eeOffset22] = k00 * A0 - k111 * A1;
				u[eeOffset22 + -1] = k111 * A0 + k00 * A1;
				k00 = u[eeOffset02 + -2] - u[eeOffset22 + -2];
				k111 = u[eeOffset02 + -3] - u[eeOffset22 + -3];
				u[eeOffset02 + -2] = u[eeOffset02 + -2] + u[eeOffset22 + -2];
				u[eeOffset02 + -3] = u[eeOffset02 + -3] + u[eeOffset22 + -3];
				u[eeOffset22 + -2] = k00 * A2 - k111 * A3;
				u[eeOffset22 + -3] = k111 * A2 + k00 * A3;
				k00 = u[eeOffset02 + -4] - u[eeOffset22 + -4];
				k111 = u[eeOffset02 + -5] - u[eeOffset22 + -5];
				u[eeOffset02 + -4] = u[eeOffset02 + -4] + u[eeOffset22 + -4];
				u[eeOffset02 + -5] = u[eeOffset02 + -5] + u[eeOffset22 + -5];
				u[eeOffset22 + -4] = k00 * A4 - k111 * A5;
				u[eeOffset22 + -5] = k111 * A4 + k00 * A5;
				k00 = u[eeOffset02 + -6] - u[eeOffset22 + -6];
				k111 = u[eeOffset02 + -7] - u[eeOffset22 + -7];
				u[eeOffset02 + -6] = u[eeOffset02 + -6] + u[eeOffset22 + -6];
				u[eeOffset02 + -7] = u[eeOffset02 + -7] + u[eeOffset22 + -7];
				u[eeOffset22 + -6] = k00 * A6 - k111 * A7;
				u[eeOffset22 + -7] = k111 * A6 + k00 * A7;
				eeOffset02 -= k01;
				eeOffset22 -= k01;
			}
			aOffset7 += k11 * 4;
			i_off2 -= 8;
		}
	}
	var i_off3 = n2 - 1;
	var A21 = a[n >> 3];
	var zOffset = i_off3;
	var baseOffset = i_off3 - 16 * (n >> 5);
	while(zOffset > baseOffset) {
		var t0 = u[zOffset];
		var t1 = u[zOffset + -8];
		u[zOffset + -8] = t0 - t1;
		u[zOffset] = t0 + t1;
		t0 = u[zOffset + -1];
		t1 = u[zOffset + -9];
		u[zOffset + -9] = t0 - t1;
		u[zOffset + -1] = t0 + t1;
		t0 = u[zOffset + -2];
		t1 = u[zOffset + -10];
		var k001 = t0 - t1;
		u[zOffset + -2] = t0 + t1;
		t0 = u[zOffset + -3];
		t1 = u[zOffset + -11];
		var k112 = t0 - t1;
		u[zOffset + -3] = t0 + t1;
		u[zOffset + -10] = (k001 + k112) * A21;
		u[zOffset + -11] = (k112 - k001) * A21;
		t0 = u[zOffset + -4];
		t1 = u[zOffset + -12];
		k001 = t1 - t0;
		u[zOffset + -4] = t0 + t1;
		t0 = u[zOffset + -5];
		t1 = u[zOffset + -13];
		k112 = t0 - t1;
		u[zOffset + -5] = t0 + t1;
		u[zOffset + -12] = k112;
		u[zOffset + -13] = k001;
		t0 = u[zOffset + -6];
		t1 = u[zOffset + -14];
		k001 = t1 - t0;
		u[zOffset + -6] = t0 + t1;
		t0 = u[zOffset + -7];
		t1 = u[zOffset + -15];
		k112 = t0 - t1;
		u[zOffset + -7] = t0 + t1;
		u[zOffset + -14] = (k001 + k112) * A21;
		u[zOffset + -15] = (k001 - k112) * A21;
		var t01 = u[zOffset];
		var t11 = u[zOffset + -4];
		var k002 = t01 - t11;
		var y0 = t01 + t11;
		t01 = u[zOffset + -2];
		t11 = u[zOffset + -6];
		var y2 = t01 + t11;
		var k22 = t01 - t11;
		u[zOffset] = y0 + y2;
		u[zOffset + -2] = y0 - y2;
		var k33 = u[zOffset + -3] - u[zOffset + -7];
		u[zOffset + -4] = k002 + k33;
		u[zOffset + -6] = k002 - k33;
		t01 = u[zOffset + -1];
		t11 = u[zOffset + -5];
		var k113 = t01 - t11;
		var y1 = t01 + t11;
		var y3 = u[zOffset + -3] + u[zOffset + -7];
		u[zOffset + -1] = y1 + y3;
		u[zOffset + -3] = y1 - y3;
		u[zOffset + -5] = k113 - k22;
		u[zOffset + -7] = k113 + k22;
		var zOffset1 = zOffset - 8;
		var t02 = u[zOffset1];
		var t12 = u[zOffset1 + -4];
		var k003 = t02 - t12;
		var y01 = t02 + t12;
		t02 = u[zOffset1 + -2];
		t12 = u[zOffset1 + -6];
		var y21 = t02 + t12;
		var k221 = t02 - t12;
		u[zOffset1] = y01 + y21;
		u[zOffset1 + -2] = y01 - y21;
		var k331 = u[zOffset1 + -3] - u[zOffset1 + -7];
		u[zOffset1 + -4] = k003 + k331;
		u[zOffset1 + -6] = k003 - k331;
		t02 = u[zOffset1 + -1];
		t12 = u[zOffset1 + -5];
		var k114 = t02 - t12;
		var y11 = t02 + t12;
		var y31 = u[zOffset1 + -3] + u[zOffset1 + -7];
		u[zOffset1 + -1] = y11 + y31;
		u[zOffset1 + -3] = y11 - y31;
		u[zOffset1 + -5] = k114 - k221;
		u[zOffset1 + -7] = k114 + k221;
		zOffset -= 16;
	}
	var brOffset = 0;
	var dOffset01 = n4 - 4;
	var dOffset11 = n2 - 4;
	while(dOffset01 >= 0) {
		var k4 = bitReverse[brOffset];
		v[dOffset11 + 3] = u[k4];
		v[dOffset11 + 2] = u[k4 + 1];
		v[dOffset01 + 3] = u[k4 + 2];
		v[dOffset01 + 2] = u[k4 + 3];
		k4 = bitReverse[brOffset + 1];
		v[dOffset11 + 1] = u[k4];
		v[dOffset11] = u[k4 + 1];
		v[dOffset01 + 1] = u[k4 + 2];
		v[dOffset01] = u[k4 + 3];
		dOffset01 -= 4;
		dOffset11 -= 4;
		brOffset += 2;
	}
	var cOffset = 0;
	var dOffset2 = 0;
	var eOffset3 = n2 - 4;
	while(dOffset2 < eOffset3) {
		var a02 = v[dOffset2] - v[eOffset3 + 2];
		var a11 = v[dOffset2 + 1] + v[eOffset3 + 3];
		var b0 = c[cOffset + 1] * a02 + c[cOffset] * a11;
		var b1 = c[cOffset + 1] * a11 - c[cOffset] * a02;
		var b2 = v[dOffset2] + v[eOffset3 + 2];
		var b3 = v[dOffset2 + 1] - v[eOffset3 + 3];
		v[dOffset2] = b2 + b0;
		v[dOffset2 + 1] = b3 + b1;
		v[eOffset3 + 2] = b2 - b0;
		v[eOffset3 + 3] = b1 - b3;
		a02 = v[dOffset2 + 2] - v[eOffset3];
		a11 = v[dOffset2 + 3] + v[eOffset3 + 1];
		b0 = c[cOffset + 3] * a02 + c[cOffset + 2] * a11;
		b1 = c[cOffset + 3] * a11 - c[cOffset + 2] * a02;
		b2 = v[dOffset2 + 2] + v[eOffset3];
		b3 = v[dOffset2 + 3] - v[eOffset3 + 1];
		v[dOffset2 + 2] = b2 + b0;
		v[dOffset2 + 3] = b3 + b1;
		v[eOffset3] = b2 - b0;
		v[eOffset3 + 1] = b1 - b3;
		cOffset += 4;
		dOffset2 += 4;
		eOffset3 -= 4;
	}
	var bOffset = n2 - 8;
	var eOffset4 = n2 - 8;
	var dOffset02 = 0;
	var dOffset12 = n2 - 4;
	var dOffset21 = n2;
	var dOffset3 = n - 4;
	while(eOffset4 >= 0) {
		var p3 = buf2[eOffset4 + 6] * b[bOffset + 7] - buf2[eOffset4 + 7] * b[bOffset + 6];
		var p2 = -buf2[eOffset4 + 6] * b[bOffset + 6] - buf2[eOffset4 + 7] * b[bOffset + 7];
		buffer[dOffset02] = p3;
		buffer[dOffset12 + 3] = -p3;
		buffer[dOffset21] = p2;
		buffer[dOffset3 + 3] = p2;
		var p1 = buf2[eOffset4 + 4] * b[bOffset + 5] - buf2[eOffset4 + 5] * b[bOffset + 4];
		var p0 = -buf2[eOffset4 + 4] * b[bOffset + 4] - buf2[eOffset4 + 5] * b[bOffset + 5];
		buffer[dOffset02 + 1] = p1;
		buffer[dOffset12 + 2] = -p1;
		buffer[dOffset21 + 1] = p0;
		buffer[dOffset3 + 2] = p0;
		p3 = buf2[eOffset4 + 2] * b[bOffset + 3] - buf2[eOffset4 + 3] * b[bOffset + 2];
		p2 = -buf2[eOffset4 + 2] * b[bOffset + 2] - buf2[eOffset4 + 3] * b[bOffset + 3];
		buffer[dOffset02 + 2] = p3;
		buffer[dOffset12 + 1] = -p3;
		buffer[dOffset21 + 2] = p2;
		buffer[dOffset3 + 1] = p2;
		p1 = buf2[eOffset4] * b[bOffset + 1] - buf2[eOffset4 + 1] * b[bOffset];
		p0 = -buf2[eOffset4] * b[bOffset] - buf2[eOffset4 + 1] * b[bOffset + 1];
		buffer[dOffset02 + 3] = p1;
		buffer[dOffset12] = -p1;
		buffer[dOffset21 + 3] = p0;
		buffer[dOffset3] = p0;
		bOffset -= 8;
		eOffset4 -= 8;
		dOffset02 += 4;
		dOffset21 += 4;
		dOffset12 -= 4;
		dOffset3 -= 4;
	}
};
kha_audio2_ogg_tools_Mdct.step3Iter0Loop = function(n,e,i_off,k_off,a) {
	var eeOffset0 = i_off;
	var eeOffset2 = i_off + k_off;
	var aOffset = 0;
	var i = (n >> 2) + 1;
	while(--i > 0) {
		var k00_20 = e[eeOffset0] - e[eeOffset2];
		var k01_21 = e[eeOffset0 + -1] - e[eeOffset2 + -1];
		var _g = eeOffset0;
		var _g1 = e;
		_g1[_g] = _g1[_g] + e[eeOffset2];
		var _g2 = eeOffset0 + -1;
		var _g11 = e;
		_g11[_g2] = _g11[_g2] + e[eeOffset2 + -1];
		e[eeOffset2] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
		e[eeOffset2 + -1] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
		aOffset += 8;
		k00_20 = e[eeOffset0 + -2] - e[eeOffset2 + -2];
		k01_21 = e[eeOffset0 + -3] - e[eeOffset2 + -3];
		var _g3 = eeOffset0 + -2;
		var _g12 = e;
		_g12[_g3] = _g12[_g3] + e[eeOffset2 + -2];
		var _g4 = eeOffset0 + -3;
		var _g13 = e;
		_g13[_g4] = _g13[_g4] + e[eeOffset2 + -3];
		e[eeOffset2 + -2] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
		e[eeOffset2 + -3] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
		aOffset += 8;
		k00_20 = e[eeOffset0 + -4] - e[eeOffset2 + -4];
		k01_21 = e[eeOffset0 + -5] - e[eeOffset2 + -5];
		var _g5 = eeOffset0 + -4;
		var _g14 = e;
		_g14[_g5] = _g14[_g5] + e[eeOffset2 + -4];
		var _g6 = eeOffset0 + -5;
		var _g15 = e;
		_g15[_g6] = _g15[_g6] + e[eeOffset2 + -5];
		e[eeOffset2 + -4] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
		e[eeOffset2 + -5] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
		aOffset += 8;
		k00_20 = e[eeOffset0 + -6] - e[eeOffset2 + -6];
		k01_21 = e[eeOffset0 + -7] - e[eeOffset2 + -7];
		var _g7 = eeOffset0 + -6;
		var _g16 = e;
		_g16[_g7] = _g16[_g7] + e[eeOffset2 + -6];
		var _g8 = eeOffset0 + -7;
		var _g17 = e;
		_g17[_g8] = _g17[_g8] + e[eeOffset2 + -7];
		e[eeOffset2 + -6] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
		e[eeOffset2 + -7] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
		aOffset += 8;
		eeOffset0 -= 8;
		eeOffset2 -= 8;
	}
};
kha_audio2_ogg_tools_Mdct.step3InnerRLoop = function(lim,e,d0,k_off,a,k1) {
	var aOffset = 0;
	var eOffset0 = d0;
	var eOffset2 = d0 + k_off;
	var i = (lim >> 2) + 1;
	while(--i > 0) {
		var k00_20 = e[eOffset0] - e[eOffset2];
		var k01_21 = e[eOffset0 + -1] - e[eOffset2 + -1];
		var _g = eOffset0;
		var _g1 = e;
		_g1[_g] = _g1[_g] + e[eOffset2];
		var _g2 = eOffset0 + -1;
		var _g11 = e;
		_g11[_g2] = _g11[_g2] + e[eOffset2 + -1];
		e[eOffset2] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
		e[eOffset2 + -1] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
		aOffset += k1;
		k00_20 = e[eOffset0 + -2] - e[eOffset2 + -2];
		k01_21 = e[eOffset0 + -3] - e[eOffset2 + -3];
		var _g3 = eOffset0 + -2;
		var _g12 = e;
		_g12[_g3] = _g12[_g3] + e[eOffset2 + -2];
		var _g4 = eOffset0 + -3;
		var _g13 = e;
		_g13[_g4] = _g13[_g4] + e[eOffset2 + -3];
		e[eOffset2 + -2] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
		e[eOffset2 + -3] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
		aOffset += k1;
		k00_20 = e[eOffset0 + -4] - e[eOffset2 + -4];
		k01_21 = e[eOffset0 + -5] - e[eOffset2 + -5];
		var _g5 = eOffset0 + -4;
		var _g14 = e;
		_g14[_g5] = _g14[_g5] + e[eOffset2 + -4];
		var _g6 = eOffset0 + -5;
		var _g15 = e;
		_g15[_g6] = _g15[_g6] + e[eOffset2 + -5];
		e[eOffset2 + -4] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
		e[eOffset2 + -5] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
		aOffset += k1;
		k00_20 = e[eOffset0 + -6] - e[eOffset2 + -6];
		k01_21 = e[eOffset0 + -7] - e[eOffset2 + -7];
		var _g7 = eOffset0 + -6;
		var _g16 = e;
		_g16[_g7] = _g16[_g7] + e[eOffset2 + -6];
		var _g8 = eOffset0 + -7;
		var _g17 = e;
		_g17[_g8] = _g17[_g8] + e[eOffset2 + -7];
		e[eOffset2 + -6] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
		e[eOffset2 + -7] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
		eOffset0 -= 8;
		eOffset2 -= 8;
		aOffset += k1;
	}
};
kha_audio2_ogg_tools_Mdct.step3InnerSLoop = function(n,e,i_off,k_off,a,aOffset0,aOffset1,k0) {
	var A0 = a[aOffset0];
	var A1 = a[aOffset0 + 1];
	var A2 = a[aOffset0 + aOffset1];
	var A3 = a[aOffset0 + aOffset1 + 1];
	var A4 = a[aOffset0 + aOffset1 * 2];
	var A5 = a[aOffset0 + aOffset1 * 2 + 1];
	var A6 = a[aOffset0 + aOffset1 * 3];
	var A7 = a[aOffset0 + aOffset1 * 3 + 1];
	var eeOffset0 = i_off;
	var eeOffset2 = i_off + k_off;
	var i = n + 1;
	while(--i > 0) {
		var k00 = e[eeOffset0] - e[eeOffset2];
		var k11 = e[eeOffset0 + -1] - e[eeOffset2 + -1];
		e[eeOffset0] = e[eeOffset0] + e[eeOffset2];
		e[eeOffset0 + -1] = e[eeOffset0 + -1] + e[eeOffset2 + -1];
		e[eeOffset2] = k00 * A0 - k11 * A1;
		e[eeOffset2 + -1] = k11 * A0 + k00 * A1;
		k00 = e[eeOffset0 + -2] - e[eeOffset2 + -2];
		k11 = e[eeOffset0 + -3] - e[eeOffset2 + -3];
		e[eeOffset0 + -2] = e[eeOffset0 + -2] + e[eeOffset2 + -2];
		e[eeOffset0 + -3] = e[eeOffset0 + -3] + e[eeOffset2 + -3];
		e[eeOffset2 + -2] = k00 * A2 - k11 * A3;
		e[eeOffset2 + -3] = k11 * A2 + k00 * A3;
		k00 = e[eeOffset0 + -4] - e[eeOffset2 + -4];
		k11 = e[eeOffset0 + -5] - e[eeOffset2 + -5];
		e[eeOffset0 + -4] = e[eeOffset0 + -4] + e[eeOffset2 + -4];
		e[eeOffset0 + -5] = e[eeOffset0 + -5] + e[eeOffset2 + -5];
		e[eeOffset2 + -4] = k00 * A4 - k11 * A5;
		e[eeOffset2 + -5] = k11 * A4 + k00 * A5;
		k00 = e[eeOffset0 + -6] - e[eeOffset2 + -6];
		k11 = e[eeOffset0 + -7] - e[eeOffset2 + -7];
		e[eeOffset0 + -6] = e[eeOffset0 + -6] + e[eeOffset2 + -6];
		e[eeOffset0 + -7] = e[eeOffset0 + -7] + e[eeOffset2 + -7];
		e[eeOffset2 + -6] = k00 * A6 - k11 * A7;
		e[eeOffset2 + -7] = k11 * A6 + k00 * A7;
		eeOffset0 -= k0;
		eeOffset2 -= k0;
	}
};
kha_audio2_ogg_tools_Mdct.iter54 = function(e,zOffset) {
	var t0 = e[zOffset];
	var t1 = e[zOffset + -4];
	var k00 = t0 - t1;
	var y0 = t0 + t1;
	t0 = e[zOffset + -2];
	t1 = e[zOffset + -6];
	var y2 = t0 + t1;
	var k22 = t0 - t1;
	e[zOffset] = y0 + y2;
	e[zOffset + -2] = y0 - y2;
	var k33 = e[zOffset + -3] - e[zOffset + -7];
	e[zOffset + -4] = k00 + k33;
	e[zOffset + -6] = k00 - k33;
	t0 = e[zOffset + -1];
	t1 = e[zOffset + -5];
	var k11 = t0 - t1;
	var y1 = t0 + t1;
	var y3 = e[zOffset + -3] + e[zOffset + -7];
	e[zOffset + -1] = y1 + y3;
	e[zOffset + -3] = y1 - y3;
	e[zOffset + -5] = k11 - k22;
	e[zOffset + -7] = k11 + k22;
};
kha_audio2_ogg_tools_Mdct.step3InnerSLoopLd654 = function(n,e,i_off,a,baseN) {
	var A2 = a[baseN >> 3];
	var zOffset = i_off;
	var baseOffset = i_off - 16 * n;
	while(zOffset > baseOffset) {
		var t0 = e[zOffset];
		var t1 = e[zOffset + -8];
		e[zOffset + -8] = t0 - t1;
		e[zOffset] = t0 + t1;
		t0 = e[zOffset + -1];
		t1 = e[zOffset + -9];
		e[zOffset + -9] = t0 - t1;
		e[zOffset + -1] = t0 + t1;
		t0 = e[zOffset + -2];
		t1 = e[zOffset + -10];
		var k00 = t0 - t1;
		e[zOffset + -2] = t0 + t1;
		t0 = e[zOffset + -3];
		t1 = e[zOffset + -11];
		var k11 = t0 - t1;
		e[zOffset + -3] = t0 + t1;
		e[zOffset + -10] = (k00 + k11) * A2;
		e[zOffset + -11] = (k11 - k00) * A2;
		t0 = e[zOffset + -4];
		t1 = e[zOffset + -12];
		k00 = t1 - t0;
		e[zOffset + -4] = t0 + t1;
		t0 = e[zOffset + -5];
		t1 = e[zOffset + -13];
		k11 = t0 - t1;
		e[zOffset + -5] = t0 + t1;
		e[zOffset + -12] = k11;
		e[zOffset + -13] = k00;
		t0 = e[zOffset + -6];
		t1 = e[zOffset + -14];
		k00 = t1 - t0;
		e[zOffset + -6] = t0 + t1;
		t0 = e[zOffset + -7];
		t1 = e[zOffset + -15];
		k11 = t0 - t1;
		e[zOffset + -7] = t0 + t1;
		e[zOffset + -14] = (k00 + k11) * A2;
		e[zOffset + -15] = (k00 - k11) * A2;
		var t01 = e[zOffset];
		var t11 = e[zOffset + -4];
		var k001 = t01 - t11;
		var y0 = t01 + t11;
		t01 = e[zOffset + -2];
		t11 = e[zOffset + -6];
		var y2 = t01 + t11;
		var k22 = t01 - t11;
		e[zOffset] = y0 + y2;
		e[zOffset + -2] = y0 - y2;
		var k33 = e[zOffset + -3] - e[zOffset + -7];
		e[zOffset + -4] = k001 + k33;
		e[zOffset + -6] = k001 - k33;
		t01 = e[zOffset + -1];
		t11 = e[zOffset + -5];
		var k111 = t01 - t11;
		var y1 = t01 + t11;
		var y3 = e[zOffset + -3] + e[zOffset + -7];
		e[zOffset + -1] = y1 + y3;
		e[zOffset + -3] = y1 - y3;
		e[zOffset + -5] = k111 - k22;
		e[zOffset + -7] = k111 + k22;
		var zOffset1 = zOffset - 8;
		var t02 = e[zOffset1];
		var t12 = e[zOffset1 + -4];
		var k002 = t02 - t12;
		var y01 = t02 + t12;
		t02 = e[zOffset1 + -2];
		t12 = e[zOffset1 + -6];
		var y21 = t02 + t12;
		var k221 = t02 - t12;
		e[zOffset1] = y01 + y21;
		e[zOffset1 + -2] = y01 - y21;
		var k331 = e[zOffset1 + -3] - e[zOffset1 + -7];
		e[zOffset1 + -4] = k002 + k331;
		e[zOffset1 + -6] = k002 - k331;
		t02 = e[zOffset1 + -1];
		t12 = e[zOffset1 + -5];
		var k112 = t02 - t12;
		var y11 = t02 + t12;
		var y31 = e[zOffset1 + -3] + e[zOffset1 + -7];
		e[zOffset1 + -1] = y11 + y31;
		e[zOffset1 + -3] = y11 - y31;
		e[zOffset1 + -5] = k112 - k221;
		e[zOffset1 + -7] = k112 + k221;
		zOffset -= 16;
	}
};
var kha_audio2_ogg_vorbis_Reader = function(input,seekFunc,inputLength) {
	this.seekFunc = seekFunc;
	this.inputLength = inputLength;
	this.decoder = kha_audio2_ogg_vorbis_VorbisDecoder.start(input);
	this.decoder.setupSampleNumber(seekFunc,inputLength);
	this.loopStart = this.get_header().comment.get_loopStart();
	this.loopLength = this.get_header().comment.get_loopLength();
};
$hxClasses["kha.audio2.ogg.vorbis.Reader"] = kha_audio2_ogg_vorbis_Reader;
kha_audio2_ogg_vorbis_Reader.__name__ = true;
kha_audio2_ogg_vorbis_Reader.openFromBytes = function(bytes) {
	var input = new haxe_io_BytesInput(bytes);
	var a1 = input;
	return new kha_audio2_ogg_vorbis_Reader(input,function(a2) {
		kha_audio2_ogg_vorbis_Reader.seekBytes(a1,a2);
	},bytes.length);
};
kha_audio2_ogg_vorbis_Reader.seekBytes = function(bytes,pos) {
	bytes.set_position(pos);
};
kha_audio2_ogg_vorbis_Reader.readAll = function(bytes,output,useFloat) {
	if(useFloat == null) {
		useFloat = false;
	}
	var input = new haxe_io_BytesInput(bytes);
	var decoder = kha_audio2_ogg_vorbis_VorbisDecoder.start(input);
	var a1 = input;
	decoder.setupSampleNumber(function(a2) {
		kha_audio2_ogg_vorbis_Reader.seekBytes(a1,a2);
	},bytes.length);
	var header = decoder.header;
	var count = 0;
	var bufferSize = 4096;
	var length = bufferSize * header.channel;
	var this1 = new Array(length);
	var buffer = this1;
	while(true) {
		var n = decoder.read(buffer,bufferSize,header.channel,header.sampleRate,useFloat);
		var _g1 = 0;
		var _g = n * header.channel;
		while(_g1 < _g) {
			var i = _g1++;
			output.writeFloat(buffer[i]);
		}
		if(n == 0) {
			break;
		}
		count += n;
	}
	return decoder.header;
};
kha_audio2_ogg_vorbis_Reader.prototype = {
	decoder: null
	,get_header: function() {
		return this.decoder.header;
	}
	,get_totalSample: function() {
		return this.decoder.totalSample;
	}
	,get_totalMillisecond: function() {
		var samples = this.decoder.totalSample;
		var b = this.get_header().sampleRate;
		return _$UInt_UInt_$Impl_$.toFloat(samples) / _$UInt_UInt_$Impl_$.toFloat(b) * 1000;
	}
	,get_currentSample: function() {
		return this.decoder.currentSample;
	}
	,set_currentSample: function(value) {
		this.decoder.seek(this.seekFunc,this.inputLength,value);
		return this.decoder.currentSample;
	}
	,get_currentMillisecond: function() {
		var samples = this.get_currentSample();
		var b = this.get_header().sampleRate;
		return _$UInt_UInt_$Impl_$.toFloat(samples) / _$UInt_UInt_$Impl_$.toFloat(b) * 1000;
	}
	,set_currentMillisecond: function(value) {
		var _g = value / 1000;
		var _g1 = this.get_header().sampleRate;
		this.set_currentSample(Math.floor(_$UInt_UInt_$Impl_$.toFloat(_g1) * _g));
		return this.get_currentMillisecond();
	}
	,loopStart: null
	,loopLength: null
	,seekFunc: null
	,inputLength: null
	,read: function(output,samples,channels,sampleRate,useFloat) {
		if(useFloat == null) {
			useFloat = false;
		}
		this.decoder.ensurePosition(this.seekFunc);
		if(samples == null) {
			samples = this.decoder.totalSample;
		}
		if(channels == null) {
			channels = this.get_header().channel;
		}
		if(sampleRate == null) {
			sampleRate = this.get_header().sampleRate;
		}
		return this.decoder.read(output,samples,channels,sampleRate,useFloat);
	}
	,clone: function() {
		var reader = Type.createEmptyInstance(kha_audio2_ogg_vorbis_Reader);
		reader.seekFunc = this.seekFunc;
		reader.inputLength = this.inputLength;
		reader.decoder = this.decoder.clone(this.seekFunc);
		reader.loopStart = this.loopStart;
		reader.loopLength = this.loopLength;
		return reader;
	}
	,sampleToMillisecond: function(samples) {
		var b = this.get_header().sampleRate;
		return _$UInt_UInt_$Impl_$.toFloat(samples) / _$UInt_UInt_$Impl_$.toFloat(b) * 1000;
	}
	,millisecondToSample: function(millseconds) {
		var _g = millseconds / 1000;
		var _g1 = this.get_header().sampleRate;
		return Math.floor(_$UInt_UInt_$Impl_$.toFloat(_g1) * _g);
	}
	,__class__: kha_audio2_ogg_vorbis_Reader
};
var kha_audio2_ogg_vorbis_VorbisDecodeState = function(input) {
	this.nextSeg = 0;
	this.firstDecode = false;
	this.bytesInSeg = 0;
	this.validBits = 0;
	this.input = input;
	this.inputPosition = 0;
	this.page = new kha_audio2_ogg_vorbis_data_Page();
	kha_audio2_ogg_tools_Crc32.init();
};
$hxClasses["kha.audio2.ogg.vorbis.VorbisDecodeState"] = kha_audio2_ogg_vorbis_VorbisDecodeState;
kha_audio2_ogg_vorbis_VorbisDecodeState.__name__ = true;
kha_audio2_ogg_vorbis_VorbisDecodeState.prototype = {
	page: null
	,eof: null
	,pFirst: null
	,pLast: null
	,validBits: null
	,inputPosition: null
	,input: null
	,discardSamplesDeferred: null
	,segments: null
	,bytesInSeg: null
	,channelBuffers: null
	,channelBufferStart: null
	,channelBufferEnd: null
	,currentSample: null
	,previousWindow: null
	,previousLength: null
	,finalY: null
	,firstDecode: null
	,nextSeg: null
	,acc: null
	,lastSeg: null
	,lastSegWhich: null
	,endSegWithKnownLoc: null
	,knownLocForPacket: null
	,error: null
	,currentLoc: null
	,currentLocValid: null
	,firstAudioPageOffset: null
	,setup: function(loc0,loc1) {
		this.inputPosition += 1;
		var segmentCount = this.input.readByte();
		this.inputPosition += segmentCount;
		var this1 = new Array(segmentCount);
		var vec = this1;
		var _g1 = 0;
		var _g = segmentCount;
		while(_g1 < _g) {
			var i = _g1++;
			vec[i] = this.input.readByte();
		}
		this.segments = vec;
		this.endSegWithKnownLoc = -2;
		if(loc0 != -1 || loc1 != -1) {
			var i1 = segmentCount - 1;
			while(i1 >= 0) {
				if(this.segments[i1] < 255) {
					break;
				}
				if(i1 >= 0) {
					this.endSegWithKnownLoc = i1;
					this.knownLocForPacket = loc0;
				}
				--i1;
			}
		}
		if(this.firstDecode) {
			var i2 = 0;
			var len = 0;
			var p = new kha_audio2_ogg_vorbis_data_ProbedPage();
			var _g11 = 0;
			var _g2 = segmentCount;
			while(_g11 < _g2) {
				var i3 = _g11++;
				len += this.segments[i3];
			}
			len += 27 + segmentCount;
			p.pageStart = this.firstAudioPageOffset;
			p.pageEnd = p.pageStart + len;
			p.firstDecodedSample = 0;
			p.lastDecodedSample = loc0;
			this.pFirst = p;
		}
		this.nextSeg = 0;
	}
	,clone: function(seekFunc) {
		var state = Type.createEmptyInstance(kha_audio2_ogg_vorbis_VorbisDecodeState);
		seekFunc(this.inputPosition);
		state.input = this.input;
		state.eof = this.eof;
		state.validBits = this.validBits;
		state.discardSamplesDeferred = this.discardSamplesDeferred;
		state.firstDecode = this.firstDecode;
		state.nextSeg = this.nextSeg;
		state.bytesInSeg = this.bytesInSeg;
		state.acc = state.acc;
		state.lastSeg = this.lastSeg;
		state.lastSegWhich = this.lastSegWhich;
		state.currentLoc = this.currentLoc;
		state.currentLocValid = this.currentLocValid;
		state.inputPosition = this.inputPosition;
		state.firstAudioPageOffset = this.firstAudioPageOffset;
		state.error = this.error;
		state.segments = this.segments;
		state.pFirst = this.pFirst;
		state.pLast = this.pLast;
		state.page = this.page.clone();
		return state;
	}
	,next: function() {
		if(this.lastSeg) {
			return 0;
		}
		if(this.nextSeg == -1) {
			this.lastSegWhich = this.segments.length - 1;
			try {
				this.page.start(this);
			} catch( e ) {
				if (e instanceof js__$Boot_HaxeError) e = e.val;
				if( js_Boot.__instanceof(e,kha_audio2_ogg_vorbis_data_ReaderError) ) {
					this.lastSeg = true;
					this.error = e;
					return 0;
				} else throw(e);
			}
			if((this.page.flag & 1) == 0) {
				throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.CONTINUED_PACKET_FLAG_INVALID,null,{ fileName : "VorbisDecodeState.hx", lineNumber : 171, className : "kha.audio2.ogg.vorbis.VorbisDecodeState", methodName : "next"}));
			}
		}
		var len = this.segments[this.nextSeg++];
		if(len < 255) {
			this.lastSeg = true;
			this.lastSegWhich = this.nextSeg - 1;
		}
		if(this.nextSeg >= this.segments.length) {
			this.nextSeg = -1;
		}
		var b = this.bytesInSeg == 0;
		this.bytesInSeg = len;
		return len;
	}
	,startPacket: function() {
		while(this.nextSeg == -1) {
			this.page.start(this);
			if((this.page.flag & 1) != 0) {
				throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.MISSING_CAPTURE_PATTERN,null,{ fileName : "VorbisDecodeState.hx", lineNumber : 193, className : "kha.audio2.ogg.vorbis.VorbisDecodeState", methodName : "startPacket"}));
			}
		}
		this.lastSeg = false;
		this.validBits = 0;
		this.bytesInSeg = 0;
	}
	,maybeStartPacket: function() {
		if(this.nextSeg == -1) {
			var eof = false;
			var x;
			try {
				this.inputPosition += 1;
				x = this.input.readByte();
			} catch( e ) {
				if (e instanceof js__$Boot_HaxeError) e = e.val;
				if( js_Boot.__instanceof(e,haxe_io_Eof) ) {
					eof = true;
					x = 0;
				} else throw(e);
			}
			if(eof) {
				return false;
			}
			var tmp;
			var tmp1;
			var tmp2;
			if(x == 79) {
				this.inputPosition += 1;
				tmp2 = this.input.readByte() != 103;
			} else {
				tmp2 = true;
			}
			if(!tmp2) {
				this.inputPosition += 1;
				tmp1 = this.input.readByte() != 103;
			} else {
				tmp1 = true;
			}
			if(!tmp1) {
				this.inputPosition += 1;
				tmp = this.input.readByte() != 83;
			} else {
				tmp = true;
			}
			if(tmp) {
				throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.MISSING_CAPTURE_PATTERN,null,{ fileName : "VorbisDecodeState.hx", lineNumber : 218, className : "kha.audio2.ogg.vorbis.VorbisDecodeState", methodName : "maybeStartPacket"}));
			}
			this.page.startWithoutCapturePattern(this);
		}
		this.startPacket();
		return true;
	}
	,readBits: function(n) {
		if(this.validBits < 0) {
			return 0;
		} else if(this.validBits < n) {
			if(n > 24) {
				return this.readBits(24) + (this.readBits(n - 24) << 24);
			} else {
				if(this.validBits == 0) {
					this.acc = 0;
				}
				while(true) {
					if(this.bytesInSeg == 0 && (this.lastSeg || this.next() == 0)) {
						this.validBits = -1;
						break;
					} else {
						this.bytesInSeg--;
						this.inputPosition += 1;
						this.acc = this.acc + (this.input.readByte() << this.validBits);
						this.validBits += 8;
					}
					if(!(this.validBits < n)) {
						break;
					}
				}
				if(this.validBits < 0) {
					return 0;
				} else {
					var z = this.acc & (1 << n) - 1;
					this.acc = this.acc >>> n;
					this.validBits -= n;
					return z;
				}
			}
		} else {
			var z1 = this.acc & (1 << n) - 1;
			this.acc = this.acc >>> n;
			this.validBits -= n;
			return z1;
		}
	}
	,readPacketRaw: function() {
		if(this.bytesInSeg == 0 && (this.lastSeg || this.next() == 0)) {
			return -1;
		} else {
			this.bytesInSeg--;
			this.inputPosition += 1;
			return this.input.readByte();
		}
	}
	,readPacket: function() {
		var x;
		if(this.bytesInSeg == 0 && (this.lastSeg || this.next() == 0)) {
			x = -1;
		} else {
			this.bytesInSeg--;
			this.inputPosition += 1;
			x = this.input.readByte();
		}
		this.validBits = 0;
		return x;
	}
	,flushPacket: function() {
		while(this.bytesInSeg != 0 || !this.lastSeg && this.next() != 0) {
			this.bytesInSeg--;
			this.inputPosition += 1;
			this.input.readByte();
		}
	}
	,vorbisValidate: function() {
		var header = new haxe_io_Bytes(new ArrayBuffer(6));
		var _g = 0;
		while(_g < 6) {
			var i = _g++;
			var x;
			if(this.bytesInSeg == 0 && (this.lastSeg || this.next() == 0)) {
				x = -1;
			} else {
				this.bytesInSeg--;
				this.inputPosition += 1;
				x = this.input.readByte();
			}
			this.validBits = 0;
			header.b[i] = x & 255;
		}
		if(header.toString() != "vorbis") {
			throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,"vorbis header",{ fileName : "VorbisDecodeState.hx", lineNumber : 300, className : "kha.audio2.ogg.vorbis.VorbisDecodeState", methodName : "vorbisValidate"}));
		}
	}
	,firstPageValidate: function() {
		if(this.segments.length != 1) {
			throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"segmentCount",{ fileName : "VorbisDecodeState.hx", lineNumber : 307, className : "kha.audio2.ogg.vorbis.VorbisDecodeState", methodName : "firstPageValidate"}));
		}
		if(this.segments[0] != 30) {
			throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"decodeState head",{ fileName : "VorbisDecodeState.hx", lineNumber : 310, className : "kha.audio2.ogg.vorbis.VorbisDecodeState", methodName : "firstPageValidate"}));
		}
	}
	,startFirstDecode: function() {
		this.firstAudioPageOffset = this.inputPosition;
		this.firstDecode = true;
	}
	,capturePattern: function() {
		var tmp;
		var tmp1;
		var tmp2;
		this.inputPosition += 1;
		if(this.input.readByte() == 79) {
			this.inputPosition += 1;
			tmp2 = this.input.readByte() != 103;
		} else {
			tmp2 = true;
		}
		if(!tmp2) {
			this.inputPosition += 1;
			tmp1 = this.input.readByte() != 103;
		} else {
			tmp1 = true;
		}
		if(!tmp1) {
			this.inputPosition += 1;
			tmp = this.input.readByte() != 83;
		} else {
			tmp = true;
		}
		if(tmp) {
			throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.MISSING_CAPTURE_PATTERN,null,{ fileName : "VorbisDecodeState.hx", lineNumber : 323, className : "kha.audio2.ogg.vorbis.VorbisDecodeState", methodName : "capturePattern"}));
		}
	}
	,skip: function(len) {
		this.inputPosition += len;
		var this1 = new Array(len);
		var vec = this1;
		var _g1 = 0;
		var _g = len;
		while(_g1 < _g) {
			var i = _g1++;
			vec[i] = this.input.readByte();
		}
	}
	,prepHuffman: function() {
		if(this.validBits <= 24) {
			if(this.validBits == 0) {
				this.acc = 0;
			}
			while(true) {
				if(this.bytesInSeg == 0 && (this.lastSeg || this.next() == 0)) {
					return;
				} else {
					this.bytesInSeg--;
					this.inputPosition += 1;
					this.acc = this.acc + (this.input.readByte() << this.validBits);
					this.validBits += 8;
				}
				if(!(this.validBits <= 24)) {
					break;
				}
			}
		}
	}
	,decode: function(c) {
		if(this.validBits < 10) {
			this.prepHuffman();
		}
		var i = c.fastHuffman[this.acc & 1023];
		var val;
		if(i >= 0) {
			var l = c.codewordLengths[i];
			this.acc = this.acc >>> l;
			this.validBits -= l;
			if(this.validBits < 0) {
				this.validBits = 0;
				val = -1;
			} else {
				val = i;
			}
		} else {
			val = this.decodeScalarRaw(c);
		}
		if(c.sparse) {
			val = c.sortedValues[val];
		}
		return val;
	}
	,decodeRaw: function(c) {
		if(this.validBits < 10) {
			this.prepHuffman();
		}
		var i = c.fastHuffman[this.acc & 1023];
		if(i >= 0) {
			var l = c.codewordLengths[i];
			this.acc = this.acc >>> l;
			this.validBits -= l;
			if(this.validBits < 0) {
				this.validBits = 0;
				return -1;
			} else {
				return i;
			}
		} else {
			return this.decodeScalarRaw(c);
		}
	}
	,isLastByte: function() {
		if(this.bytesInSeg == 0) {
			return this.lastSeg;
		} else {
			return false;
		}
	}
	,finishDecodePacket: function(previousLength,n,r) {
		var left = r.left.start;
		var currentLocValid = false;
		var n2 = n >> 1;
		if(this.firstDecode) {
			this.currentLoc = -n2;
			this.discardSamplesDeferred = n - r.right.end;
			currentLocValid = true;
			this.firstDecode = false;
		} else if(this.discardSamplesDeferred != 0) {
			r.left.start += this.discardSamplesDeferred;
			left = r.left.start;
			this.discardSamplesDeferred = 0;
		} else {
			var tmp = previousLength == 0 && currentLocValid;
		}
		if(this.lastSegWhich == this.endSegWithKnownLoc) {
			if(currentLocValid && (this.page.flag & 4) != 0) {
				var currentEnd = this.knownLocForPacket - (n - r.right.end);
				if(currentEnd < this.currentLoc + r.right.end) {
					var len = currentEnd < this.currentLoc ? 0 : currentEnd - this.currentLoc;
					len += r.left.start;
					this.currentLoc += len;
					return { len : len, left : left, right : r.right.start};
				}
			}
			this.currentLoc = this.knownLocForPacket - (n2 - r.left.start);
			currentLocValid = true;
		}
		if(currentLocValid) {
			this.currentLoc += r.right.start - r.left.start;
		}
		return { len : r.right.end, left : left, right : r.right.start};
	}
	,readInt32: function() {
		this.inputPosition += 4;
		return this.input.readInt32();
	}
	,readByte: function() {
		this.inputPosition += 1;
		return this.input.readByte();
	}
	,read: function(n) {
		this.inputPosition += n;
		var this1 = new Array(n);
		var vec = this1;
		var _g1 = 0;
		var _g = n;
		while(_g1 < _g) {
			var i = _g1++;
			vec[i] = this.input.readByte();
		}
		return vec;
	}
	,readBytes: function(n) {
		this.inputPosition += n;
		return this.input.read(n);
	}
	,readString: function(n) {
		this.inputPosition += n;
		return this.input.readString(n);
	}
	,getSampleNumber: function(seekFunc,inputLength) {
		var restoreOffset = this.inputPosition;
		var previousSafe = _$UInt_UInt_$Impl_$.gte(inputLength,65536) && _$UInt_UInt_$Impl_$.gte(inputLength - 65536,this.firstAudioPageOffset) ? inputLength - 65536 : this.firstAudioPageOffset;
		seekFunc(this.inputPosition = previousSafe);
		var end = 0;
		var last = false;
		var _g = this.findPage(seekFunc,inputLength);
		switch(_g[1]) {
		case 0:
			var l = _g[3];
			var e = _g[2];
			end = e;
			last = l;
			break;
		case 1:
			throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.CANT_FIND_LAST_PAGE,null,{ fileName : "VorbisDecodeState.hx", lineNumber : 518, className : "kha.audio2.ogg.vorbis.VorbisDecodeState", methodName : "getSampleNumber"}));
			break;
		}
		var lastPageLoc = this.inputPosition;
		try {
			while(!last) {
				seekFunc(this.inputPosition = end);
				var _g1 = this.findPage(seekFunc,inputLength);
				switch(_g1[1]) {
				case 0:
					var l1 = _g1[3];
					var e1 = _g1[2];
					end = e1;
					last = l1;
					break;
				case 1:
					throw "__break__";
					break;
				}
				previousSafe = lastPageLoc + 1;
				lastPageLoc = this.inputPosition;
			}
		} catch( e ) { if( e != "__break__" ) throw e; }
		seekFunc(this.inputPosition = lastPageLoc);
		this.inputPosition += 6;
		var this1 = new Array(6);
		var vec = this1;
		var _g11 = 0;
		var _g2 = 6;
		while(_g11 < _g2) {
			var i = _g11++;
			vec[i] = this.input.readByte();
		}
		var vorbisHeader = vec;
		this.inputPosition += 4;
		var lo = this.input.readInt32();
		this.inputPosition += 4;
		var hi = this.input.readInt32();
		if(lo == -1 && hi == -1 || hi > 0) {
			throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.CANT_FIND_LAST_PAGE,null,{ fileName : "VorbisDecodeState.hx", lineNumber : 552, className : "kha.audio2.ogg.vorbis.VorbisDecodeState", methodName : "getSampleNumber"}));
		}
		this.pLast = new kha_audio2_ogg_vorbis_data_ProbedPage();
		this.pLast.pageStart = lastPageLoc;
		this.pLast.pageEnd = end;
		this.pLast.lastDecodedSample = lo;
		this.pLast.firstDecodedSample = null;
		this.pLast.afterPreviousPageStart = previousSafe;
		seekFunc(this.inputPosition = restoreOffset);
		return lo;
	}
	,forcePageResync: function() {
		this.nextSeg = -1;
	}
	,setInputOffset: function(seekFunc,n) {
		seekFunc(this.inputPosition = n);
	}
	,findPage: function(seekFunc,inputLength) {
		try {
			while(true) {
				this.inputPosition += 1;
				var n = this.input.readByte();
				if(n == 79) {
					var retryLoc = this.inputPosition;
					if(retryLoc - 25 > inputLength) {
						return kha_audio2_ogg_vorbis__$VorbisDecodeState_FindPageResult.NotFound;
					}
					var tmp;
					var tmp1;
					this.inputPosition += 1;
					if(this.input.readByte() == 103) {
						this.inputPosition += 1;
						tmp1 = this.input.readByte() != 103;
					} else {
						tmp1 = true;
					}
					if(!tmp1) {
						this.inputPosition += 1;
						tmp = this.input.readByte() != 83;
					} else {
						tmp = true;
					}
					if(tmp) {
						continue;
					}
					var this1 = new Array(27);
					var header = this1;
					header[0] = 79;
					header[1] = 103;
					header[2] = 103;
					header[3] = 83;
					var _g = 4;
					while(_g < 27) {
						var i = _g++;
						this.inputPosition += 1;
						header[i] = this.input.readByte();
					}
					if(header[4] != 0) {
						seekFunc(this.inputPosition = retryLoc);
						continue;
					}
					var goal = header[22] + (header[23] << 8) + (header[24] << 16) + (header[25] << 24);
					var _g1 = 22;
					while(_g1 < 26) {
						var i1 = _g1++;
						header[i1] = 0;
					}
					var crc = 0;
					var _g2 = 0;
					while(_g2 < 27) {
						var i2 = _g2++;
						crc = crc << 8 ^ kha_audio2_ogg_tools_Crc32.table[header[i2] ^ crc >>> 24];
					}
					var len = 0;
					try {
						var _g11 = 0;
						var _g3 = header[26];
						while(_g11 < _g3) {
							var i3 = _g11++;
							this.inputPosition += 1;
							var s = this.input.readByte();
							crc = crc << 8 ^ kha_audio2_ogg_tools_Crc32.table[s ^ crc >>> 24];
							len += s;
						}
						var _g12 = 0;
						var _g4 = len;
						while(_g12 < _g4) {
							var i4 = _g12++;
							this.inputPosition += 1;
							var $byte = this.input.readByte();
							crc = crc << 8 ^ kha_audio2_ogg_tools_Crc32.table[$byte ^ crc >>> 24];
						}
					} catch( e ) {
						if (e instanceof js__$Boot_HaxeError) e = e.val;
						if( js_Boot.__instanceof(e,haxe_io_Eof) ) {
							return kha_audio2_ogg_vorbis__$VorbisDecodeState_FindPageResult.NotFound;
						} else throw(e);
					}
					if(crc == goal) {
						var end = this.inputPosition;
						seekFunc(this.inputPosition = retryLoc - 1);
						return kha_audio2_ogg_vorbis__$VorbisDecodeState_FindPageResult.Found(end,(header[5] & 4) != 0);
					}
				}
			}
		} catch( e1 ) {
			if (e1 instanceof js__$Boot_HaxeError) e1 = e1.val;
			if( js_Boot.__instanceof(e1,haxe_io_Eof) ) {
				return kha_audio2_ogg_vorbis__$VorbisDecodeState_FindPageResult.NotFound;
			} else throw(e1);
		}
	}
	,analyzePage: function(seekFunc,h) {
		var z = new kha_audio2_ogg_vorbis_data_ProbedPage();
		var this1 = new Array(255);
		var packetType = this1;
		z.pageStart = this.inputPosition;
		this.inputPosition += 27;
		var this2 = new Array(27);
		var vec = this2;
		var _g1 = 0;
		var _g = 27;
		while(_g1 < _g) {
			var i = _g1++;
			vec[i] = this.input.readByte();
		}
		var pageHeader = vec;
		var n = pageHeader[26];
		this.inputPosition += n;
		var this3 = new Array(n);
		var vec1 = this3;
		var _g11 = 0;
		var _g2 = n;
		while(_g11 < _g2) {
			var i1 = _g11++;
			vec1[i1] = this.input.readByte();
		}
		var lacing = vec1;
		var len = 0;
		var _g12 = 0;
		var _g3 = pageHeader[26];
		while(_g12 < _g3) {
			var i2 = _g12++;
			len += lacing[i2];
		}
		z.pageEnd = z.pageStart + 27 + pageHeader[26] + len;
		z.lastDecodedSample = pageHeader[6] + (pageHeader[7] << 8) + (pageHeader[8] << 16) + (pageHeader[9] << 16);
		if((pageHeader[5] & 4) != 0) {
			z.firstDecodedSample = null;
			seekFunc(this.inputPosition = z.pageStart);
			return z;
		}
		var numPacket = 0;
		var packetStart = (pageHeader[5] & 1) == 0;
		var modeCount = h.modes.length;
		var _g13 = 0;
		var _g4 = pageHeader[26];
		while(_g13 < _g4) {
			var i3 = _g13++;
			if(packetStart) {
				if(lacing[i3] == 0) {
					seekFunc(this.inputPosition = z.pageStart);
					return null;
				}
				this.inputPosition += 1;
				var n1 = this.input.readByte();
				if((n1 & 1) != 0) {
					seekFunc(this.inputPosition = z.pageStart);
					return null;
				}
				n1 >>= 1;
				var n2 = modeCount - 1;
				var log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
				var b = n2 < 16384 ? n2 < 16 ? log2_4[n2] : n2 < 512 ? 5 + log2_4[n2 >> 5] : 10 + log2_4[n2 >> 10] : n2 < 16777216 ? n2 < 524288 ? 15 + log2_4[n2 >> 15] : 20 + log2_4[n2 >> 20] : n2 < 536870912 ? 25 + log2_4[n2 >> 25] : n2 < -2147483648 ? 30 + log2_4[n2 >> 30] : 0;
				n1 &= (1 << b) - 1;
				if(n1 >= modeCount) {
					seekFunc(this.inputPosition = z.pageStart);
					return null;
				}
				packetType[numPacket++] = h.modes[n1].blockflag;
				var len1 = lacing[i3] - 1;
				this.inputPosition += len1;
				var this4 = new Array(len1);
				var vec2 = this4;
				var _g14 = 0;
				var _g5 = len1;
				while(_g14 < _g5) {
					var i4 = _g14++;
					vec2[i4] = this.input.readByte();
				}
			} else {
				var len2 = lacing[i3];
				this.inputPosition += len2;
				var this5 = new Array(len2);
				var vec3 = this5;
				var _g15 = 0;
				var _g6 = len2;
				while(_g15 < _g6) {
					var i5 = _g15++;
					vec3[i5] = this.input.readByte();
				}
			}
			packetStart = lacing[i3] < 255;
		}
		var samples = 0;
		if(numPacket > 1) {
			samples += packetType[numPacket - 1] ? h.blocksize1 : h.blocksize0;
		}
		var i6 = numPacket - 2;
		while(i6 >= 1) {
			--i6;
			if(packetType[i6]) {
				if(packetType[i6 + 1]) {
					samples += h.blocksize1 >> 1;
				} else {
					samples += (h.blocksize1 - h.blocksize0 >> 2) + (h.blocksize0 >> 1);
				}
			} else {
				samples += h.blocksize0 >> 1;
			}
			--i6;
		}
		z.firstDecodedSample = z.lastDecodedSample - samples;
		seekFunc(this.inputPosition = z.pageStart);
		return z;
	}
	,decodeScalarRaw: function(c) {
		this.prepHuffman();
		var b = c.sortedCodewords != null || c.codewords != null;
		var codewordLengths = c.codewordLengths;
		var codewords = c.codewords;
		var sortedCodewords = c.sortedCodewords;
		if(c.entries > 8 ? sortedCodewords != null : codewords != null) {
			var n = this.acc;
			n = (n & -1431655766) >>> 1 | (n & 1431655765) << 1;
			n = (n & -858993460) >>> 2 | (n & 858993459) << 2;
			n = (n & -252645136) >>> 4 | (n & 252645135) << 4;
			n = (n & -16711936) >>> 8 | (n & 16711935) << 8;
			var code = n >>> 16 | n << 16;
			var x = 0;
			var n1 = c.sortedEntries;
			while(n1 > 1) {
				var m = x + (n1 >> 1);
				if(_$UInt_UInt_$Impl_$.gte(code,sortedCodewords[m])) {
					x = m;
					n1 -= n1 >> 1;
				} else {
					n1 >>= 1;
				}
			}
			if(!c.sparse) {
				x = c.sortedValues[x];
			}
			var len = codewordLengths[x];
			if(this.validBits >= len) {
				this.acc = this.acc >>> len;
				this.validBits -= len;
				return x;
			}
			this.validBits = 0;
			return -1;
		}
		var b1 = !c.sparse;
		var _g1 = 0;
		var _g = c.entries;
		while(_g1 < _g) {
			var i = _g1++;
			var cl = codewordLengths[i];
			if(cl == 255) {
				continue;
			}
			if(codewords[i] == (this.acc & (1 << cl) - 1)) {
				if(this.validBits >= cl) {
					this.acc = this.acc >>> cl;
					this.validBits -= cl;
					return i;
				}
				this.validBits = 0;
				return -1;
			}
		}
		this.error = new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_STREAM,null,{ fileName : "VorbisDecodeState.hx", lineNumber : 846, className : "kha.audio2.ogg.vorbis.VorbisDecodeState", methodName : "decodeScalarRaw"});
		this.validBits = 0;
		return -1;
	}
	,__class__: kha_audio2_ogg_vorbis_VorbisDecodeState
};
var kha_audio2_ogg_vorbis__$VorbisDecodeState_FindPageResult = $hxClasses["kha.audio2.ogg.vorbis._VorbisDecodeState.FindPageResult"] = { __ename__ : true, __constructs__ : ["Found","NotFound"] };
kha_audio2_ogg_vorbis__$VorbisDecodeState_FindPageResult.Found = function(end,last) { var $x = ["Found",0,end,last]; $x.__enum__ = kha_audio2_ogg_vorbis__$VorbisDecodeState_FindPageResult; $x.toString = $estr; return $x; };
kha_audio2_ogg_vorbis__$VorbisDecodeState_FindPageResult.NotFound = ["NotFound",1];
kha_audio2_ogg_vorbis__$VorbisDecodeState_FindPageResult.NotFound.toString = $estr;
kha_audio2_ogg_vorbis__$VorbisDecodeState_FindPageResult.NotFound.__enum__ = kha_audio2_ogg_vorbis__$VorbisDecodeState_FindPageResult;
var kha_audio2_ogg_vorbis_VorbisDecoder = function(header,decodeState) {
	this.header = header;
	this.decodeState = decodeState;
	this.totalSample = null;
	this.currentSample = 0;
	this.previousLength = 0;
	var length = header.channel;
	var this1 = new Array(length);
	this.channelBuffers = this1;
	var length1 = header.channel;
	var this2 = new Array(length1);
	this.previousWindow = this2;
	var length2 = header.channel;
	var this3 = new Array(length2);
	this.finalY = this3;
	var _g1 = 0;
	var _g = header.channel;
	while(_g1 < _g) {
		var i = _g1++;
		var this4 = this.channelBuffers;
		var len = header.blocksize1;
		var this5 = new Array(len);
		var vec = this5;
		this4[i] = vec;
		var this6 = this.previousWindow;
		var len1 = header.blocksize1 / 2 | 0;
		var this7 = new Array(len1);
		var vec1 = this7;
		this6[i] = vec1;
		this.finalY[i] = [];
	}
	var this8 = new Array(2);
	this.a = this8;
	var this9 = new Array(2);
	this.b = this9;
	var this10 = new Array(2);
	this.c = this10;
	var this11 = new Array(2);
	this.window = this11;
	var this12 = new Array(2);
	this.bitReverseData = this12;
	this.initBlocksize(0,header.blocksize0);
	this.initBlocksize(1,header.blocksize1);
};
$hxClasses["kha.audio2.ogg.vorbis.VorbisDecoder"] = kha_audio2_ogg_vorbis_VorbisDecoder;
kha_audio2_ogg_vorbis_VorbisDecoder.__name__ = true;
kha_audio2_ogg_vorbis_VorbisDecoder.start = function(input) {
	var decodeState = new kha_audio2_ogg_vorbis_VorbisDecodeState(input);
	var header = kha_audio2_ogg_vorbis_data_Header.read(decodeState);
	var decoder = new kha_audio2_ogg_vorbis_VorbisDecoder(header,decodeState);
	decodeState.startFirstDecode();
	decoder.pumpFirstFrame();
	return decoder;
};
kha_audio2_ogg_vorbis_VorbisDecoder.prototype = {
	previousWindow: null
	,previousLength: null
	,finalY: null
	,a: null
	,b: null
	,c: null
	,window: null
	,bitReverseData: null
	,channelBuffers: null
	,channelBufferStart: null
	,channelBufferEnd: null
	,header: null
	,currentSample: null
	,totalSample: null
	,decodeState: null
	,read: function(output,samples,channels,sampleRate,useFloat) {
		var b = this.header.sampleRate;
		if((_$UInt_UInt_$Impl_$.toFloat(sampleRate) % _$UInt_UInt_$Impl_$.toFloat(b) | 0) != 0) {
			throw new js__$Boot_HaxeError("Unsupported sampleRate : can't convert " + Std.string(_$UInt_UInt_$Impl_$.toFloat(this.header.sampleRate)) + " to " + sampleRate);
		}
		if(channels % this.header.channel != 0) {
			throw new js__$Boot_HaxeError("Unsupported channels : can't convert " + this.header.channel + " to " + channels);
		}
		var b1 = this.header.sampleRate;
		var sampleRepeat = _$UInt_UInt_$Impl_$.toFloat(sampleRate) / _$UInt_UInt_$Impl_$.toFloat(b1) | 0;
		var channelRepeat = channels / this.header.channel | 0;
		var n = 0;
		var len = Math.floor(samples / sampleRepeat);
		if(this.totalSample != null && len > this.totalSample - this.currentSample) {
			len = this.totalSample - this.currentSample;
		}
		var index = 0;
		while(n < len) {
			var k = this.channelBufferEnd - this.channelBufferStart;
			if(k >= len - n) {
				k = len - n;
			}
			var _g1 = this.channelBufferStart;
			var _g = this.channelBufferStart + k;
			while(_g1 < _g) {
				var j = _g1++;
				var _g3 = 0;
				var _g2 = sampleRepeat;
				while(_g3 < _g2) {
					var sr = _g3++;
					var _g5 = 0;
					var _g4 = this.header.channel;
					while(_g5 < _g4) {
						var i = _g5++;
						var _g7 = 0;
						var _g6 = channelRepeat;
						while(_g7 < _g6) {
							var cr = _g7++;
							var value = this.channelBuffers[i][j];
							if(value > 1) {
								value = 1;
							} else if(value < -1) {
								value = -1;
							}
							if(useFloat) {
								output[index] = value;
								++index;
							}
						}
					}
				}
			}
			n += k;
			this.channelBufferStart += k;
			if(n == len || this.getFrameFloat() == 0) {
				break;
			}
		}
		var _g11 = n;
		var _g8 = len;
		while(_g11 < _g8) {
			var j1 = _g11++;
			var _g31 = 0;
			var _g21 = sampleRepeat;
			while(_g31 < _g21) {
				var sr1 = _g31++;
				var _g51 = 0;
				var _g41 = this.header.channel;
				while(_g51 < _g41) {
					var i1 = _g51++;
					var _g71 = 0;
					var _g61 = channelRepeat;
					while(_g71 < _g61) {
						var cr1 = _g71++;
						if(useFloat) {
							output[index] = 0;
							++index;
						}
					}
				}
			}
		}
		this.currentSample += len;
		return len * sampleRepeat;
	}
	,skipSamples: function(len) {
		var n = 0;
		if(this.totalSample != null && len > this.totalSample - this.currentSample) {
			len = this.totalSample - this.currentSample;
		}
		while(n < len) {
			var k = this.channelBufferEnd - this.channelBufferStart;
			if(k >= len - n) {
				k = len - n;
			}
			n += k;
			this.channelBufferStart += k;
			if(n == len || this.getFrameFloat() == 0) {
				break;
			}
		}
		this.currentSample += len;
		return len;
	}
	,setupSampleNumber: function(seekFunc,inputLength) {
		if(this.totalSample == null) {
			this.totalSample = this.decodeState.getSampleNumber(seekFunc,inputLength);
		}
	}
	,seek: function(seekFunc,inputLength,sampleNumber) {
		if(this.currentSample == sampleNumber) {
			return;
		}
		if(this.totalSample == null) {
			this.setupSampleNumber(seekFunc,inputLength);
			if(this.totalSample == 0) {
				throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.CANT_FIND_LAST_PAGE,null,{ fileName : "VorbisDecoder.hx", lineNumber : 187, className : "kha.audio2.ogg.vorbis.VorbisDecoder", methodName : "seek"}));
			}
		}
		if(sampleNumber < 0) {
			sampleNumber = 0;
		}
		var p0 = this.decodeState.pFirst;
		var p1 = this.decodeState.pLast;
		if(sampleNumber >= p1.lastDecodedSample) {
			sampleNumber = p1.lastDecodedSample - 1;
		}
		if(sampleNumber < p0.lastDecodedSample) {
			this.seekFrameFromPage(seekFunc,p0.pageStart,0,sampleNumber);
		} else {
			var attempts = 0;
			while(p0.pageEnd < p1.pageStart) {
				var startOffset = p0.pageEnd;
				var endOffset = p1.afterPreviousPageStart;
				var startSample = p0.lastDecodedSample;
				var endSample = p1.lastDecodedSample;
				if(startSample == null || endSample == null) {
					throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.SEEK_FAILED,null,{ fileName : "VorbisDecoder.hx", lineNumber : 219, className : "kha.audio2.ogg.vorbis.VorbisDecoder", methodName : "seek"}));
				}
				if(_$UInt_UInt_$Impl_$.gt(endOffset,startOffset + 4000)) {
					endOffset = endOffset - 4000;
				}
				var probe = startOffset + Math.floor(_$UInt_UInt_$Impl_$.toFloat(endOffset - startOffset) / _$UInt_UInt_$Impl_$.toFloat(endSample - startSample) * (sampleNumber - startSample));
				if(attempts >= 4) {
					var probe2 = startOffset + (endOffset - startOffset >>> 1);
					if(attempts >= 8) {
						probe = probe2;
					} else if(_$UInt_UInt_$Impl_$.gt(probe2,probe)) {
						probe = probe + (probe2 - probe >>> 1);
					} else {
						probe = probe2 + (probe - probe2 >>> 1);
					}
				}
				++attempts;
				seekFunc(this.decodeState.inputPosition = probe);
				var _g = this.decodeState.findPage(seekFunc,inputLength);
				switch(_g[1]) {
				case 0:
					break;
				case 1:
					throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.SEEK_FAILED,null,{ fileName : "VorbisDecoder.hx", lineNumber : 249, className : "kha.audio2.ogg.vorbis.VorbisDecoder", methodName : "seek"}));
					break;
				}
				var q = this.decodeState.analyzePage(seekFunc,this.header);
				if(q == null) {
					throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.SEEK_FAILED,null,{ fileName : "VorbisDecoder.hx", lineNumber : 255, className : "kha.audio2.ogg.vorbis.VorbisDecoder", methodName : "seek"}));
				}
				q.afterPreviousPageStart = probe;
				if(q.pageStart == p1.pageStart) {
					p1 = q;
					continue;
				}
				if(sampleNumber < q.lastDecodedSample) {
					p1 = q;
				} else {
					p0 = q;
				}
			}
			if(p0.lastDecodedSample <= sampleNumber && sampleNumber < p1.lastDecodedSample) {
				this.seekFrameFromPage(seekFunc,p1.pageStart,p0.lastDecodedSample,sampleNumber);
			} else {
				throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.SEEK_FAILED,null,{ fileName : "VorbisDecoder.hx", lineNumber : 275, className : "kha.audio2.ogg.vorbis.VorbisDecoder", methodName : "seek"}));
			}
		}
	}
	,seekFrameFromPage: function(seekFunc,pageStart,firstSample,targetSample) {
		var frame = 0;
		var frameStart = firstSample;
		seekFunc(this.decodeState.inputPosition = pageStart);
		this.decodeState.nextSeg = -1;
		var leftEnd = 0;
		var leftStart = 0;
		var prevState = null;
		var lastState = null;
		while(true) {
			prevState = lastState;
			lastState = this.decodeState.clone(seekFunc);
			var initialResult = this.decodeInitial();
			if(initialResult == null) {
				lastState = prevState;
				break;
			}
			leftStart = initialResult.left.start;
			leftEnd = initialResult.left.end;
			var start = frame == 0 ? leftEnd : leftStart;
			if(targetSample < frameStart + initialResult.right.start - start) {
				break;
			}
			var _this = this.decodeState;
			while(_this.bytesInSeg != 0 || !_this.lastSeg && _this.next() != 0) {
				_this.bytesInSeg--;
				_this.inputPosition += 1;
				_this.input.readByte();
			}
			frameStart += initialResult.right.start - start;
			++frame;
		}
		this.decodeState = lastState;
		seekFunc(this.decodeState.inputPosition);
		this.previousLength = 0;
		this.pumpFirstFrame();
		this.currentSample = frameStart;
		this.skipSamples(targetSample - frameStart);
	}
	,clone: function(seekFunc) {
		var decoder = Type.createEmptyInstance(kha_audio2_ogg_vorbis_VorbisDecoder);
		decoder.currentSample = this.currentSample;
		decoder.totalSample = this.totalSample;
		decoder.previousLength = this.previousLength;
		decoder.channelBufferStart = this.channelBufferStart;
		decoder.channelBufferEnd = this.channelBufferEnd;
		decoder.a = this.a;
		decoder.b = this.b;
		decoder.c = this.c;
		decoder.window = this.window;
		decoder.bitReverseData = this.bitReverseData;
		decoder.header = this.header;
		decoder.decodeState = this.decodeState.clone(seekFunc);
		var length = this.header.channel;
		var this1 = new Array(length);
		decoder.channelBuffers = this1;
		var length1 = this.header.channel;
		var this2 = new Array(length1);
		decoder.previousWindow = this2;
		var length2 = this.header.channel;
		var this3 = new Array(length2);
		decoder.finalY = this3;
		var _g1 = 0;
		var _g = this.header.channel;
		while(_g1 < _g) {
			var i = _g1++;
			decoder.channelBuffers[i] = kha_audio2_ogg_vorbis_VorbisTools.copyVector(this.channelBuffers[i]);
			decoder.previousWindow[i] = kha_audio2_ogg_vorbis_VorbisTools.copyVector(this.previousWindow[i]);
			decoder.finalY[i] = Lambda.array(this.finalY[i]);
		}
		return decoder;
	}
	,ensurePosition: function(seekFunc) {
		seekFunc(this.decodeState.inputPosition);
	}
	,getFrameFloat: function() {
		var result = this.decodePacket();
		if(result == null) {
			this.channelBufferStart = this.channelBufferEnd = 0;
			return 0;
		}
		var len = this.finishFrame(result);
		this.channelBufferStart = result.left;
		this.channelBufferEnd = result.left + len;
		return len;
	}
	,pumpFirstFrame: function() {
		this.finishFrame(this.decodePacket());
	}
	,finishFrame: function(r) {
		var len = r.len;
		var right = r.right;
		var left = r.left;
		if(this.previousLength != 0) {
			var n = this.previousLength;
			var w = this.getWindow(n);
			var _g1 = 0;
			var _g = this.header.channel;
			while(_g1 < _g) {
				var i = _g1++;
				var cb = this.channelBuffers[i];
				var pw = this.previousWindow[i];
				var _g3 = 0;
				var _g2 = n;
				while(_g3 < _g2) {
					var j = _g3++;
					cb[left + j] = cb[left + j] * w[j] + pw[j] * w[n - 1 - j];
				}
			}
		}
		var prev = this.previousLength;
		this.previousLength = len - right;
		var _g11 = 0;
		var _g4 = this.header.channel;
		while(_g11 < _g4) {
			var i1 = _g11++;
			var pw1 = this.previousWindow[i1];
			var cb1 = this.channelBuffers[i1];
			var _g31 = 0;
			var _g21 = len - right;
			while(_g31 < _g21) {
				var j1 = _g31++;
				pw1[j1] = cb1[right + j1];
			}
		}
		if(prev == 0) {
			return 0;
		}
		if(len < right) {
			right = len;
		}
		return right - left;
	}
	,getWindow: function(len) {
		len <<= 1;
		if(len == this.header.blocksize0) {
			return this.window[0];
		} else if(len == this.header.blocksize1) {
			return this.window[1];
		} else {
			return null;
		}
	}
	,initBlocksize: function(bs,n) {
		var n2 = n >> 1;
		var n4 = n >> 2;
		var n8 = n >> 3;
		var this1 = this.a;
		var this2 = new Array(n2);
		this1[bs] = this2;
		var this3 = this.b;
		var this4 = new Array(n2);
		this3[bs] = this4;
		var this5 = this.c;
		var this6 = new Array(n4);
		this5[bs] = this6;
		var this7 = this.window;
		var this8 = new Array(n2);
		this7[bs] = this8;
		var this9 = this.bitReverseData;
		var this10 = new Array(n8);
		this9[bs] = this10;
		kha_audio2_ogg_vorbis_VorbisTools.computeTwiddleFactors(n,this.a[bs],this.b[bs],this.c[bs]);
		kha_audio2_ogg_vorbis_VorbisTools.computeWindow(n,this.window[bs]);
		kha_audio2_ogg_vorbis_VorbisTools.computeBitReverse(n,this.bitReverseData[bs]);
	}
	,inverseMdct: function(buffer,n,blocktype) {
		var bt = blocktype ? 1 : 0;
		var a = this.a[bt];
		var b = this.b[bt];
		var c = this.c[bt];
		var bitReverse = this.bitReverseData[bt];
		var n2 = n >> 1;
		var n4 = n >> 2;
		var n8 = n >> 3;
		var this1 = new Array(n2);
		var buf2 = this1;
		var dOffset = n2 - 2;
		var aaOffset = 0;
		var eOffset = 0;
		var eStopOffset = n2;
		while(eOffset != eStopOffset) {
			buf2[dOffset + 1] = buffer[eOffset] * a[aaOffset] - buffer[eOffset + 2] * a[aaOffset + 1];
			buf2[dOffset] = buffer[eOffset] * a[aaOffset + 1] + buffer[eOffset + 2] * a[aaOffset];
			dOffset -= 2;
			aaOffset += 2;
			eOffset += 4;
		}
		eOffset = n2 - 3;
		while(dOffset >= 0) {
			buf2[dOffset + 1] = -buffer[eOffset + 2] * a[aaOffset] - -buffer[eOffset] * a[aaOffset + 1];
			buf2[dOffset] = -buffer[eOffset + 2] * a[aaOffset + 1] + -buffer[eOffset] * a[aaOffset];
			dOffset -= 2;
			aaOffset += 2;
			eOffset -= 4;
		}
		var u = buffer;
		var v = buf2;
		var aaOffset1 = n2 - 8;
		var eOffset0 = n4;
		var eOffset1 = 0;
		var dOffset0 = n4;
		var dOffset1 = 0;
		while(aaOffset1 >= 0) {
			var v41_21 = v[eOffset0 + 1] - v[eOffset1 + 1];
			var v40_20 = v[eOffset0] - v[eOffset1];
			u[dOffset0 + 1] = v[eOffset0 + 1] + v[eOffset1 + 1];
			u[dOffset0] = v[eOffset0] + v[eOffset1];
			u[dOffset1 + 1] = v41_21 * a[aaOffset1 + 4] - v40_20 * a[aaOffset1 + 5];
			u[dOffset1] = v40_20 * a[aaOffset1 + 4] + v41_21 * a[aaOffset1 + 5];
			v41_21 = v[eOffset0 + 3] - v[eOffset1 + 3];
			v40_20 = v[eOffset0 + 2] - v[eOffset1 + 2];
			u[dOffset0 + 3] = v[eOffset0 + 3] + v[eOffset1 + 3];
			u[dOffset0 + 2] = v[eOffset0 + 2] + v[eOffset1 + 2];
			u[dOffset1 + 3] = v41_21 * a[aaOffset1] - v40_20 * a[aaOffset1 + 1];
			u[dOffset1 + 2] = v40_20 * a[aaOffset1] + v41_21 * a[aaOffset1 + 1];
			aaOffset1 -= 8;
			dOffset0 += 4;
			dOffset1 += 4;
			eOffset0 += 4;
			eOffset1 += 4;
		}
		var log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
		var ld = (n < 16384 ? n < 16 ? log2_4[n] : n < 512 ? 5 + log2_4[n >> 5] : 10 + log2_4[n >> 10] : n < 16777216 ? n < 524288 ? 15 + log2_4[n >> 15] : 20 + log2_4[n >> 20] : n < 536870912 ? 25 + log2_4[n >> 25] : n < -2147483648 ? 30 + log2_4[n >> 30] : 0) - 1;
		var i_off = n2 - 1 - n4 * 0;
		var eeOffset0 = i_off;
		var eeOffset2 = i_off + -(n >> 3);
		var aOffset = 0;
		var i = (n >> 4 >> 2) + 1;
		while(--i > 0) {
			var k00_20 = u[eeOffset0] - u[eeOffset2];
			var k01_21 = u[eeOffset0 + -1] - u[eeOffset2 + -1];
			var _g = eeOffset0;
			var _g1 = u;
			_g1[_g] = _g1[_g] + u[eeOffset2];
			var _g2 = eeOffset0 + -1;
			var _g11 = u;
			_g11[_g2] = _g11[_g2] + u[eeOffset2 + -1];
			u[eeOffset2] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eeOffset2 + -1] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 8;
			k00_20 = u[eeOffset0 + -2] - u[eeOffset2 + -2];
			k01_21 = u[eeOffset0 + -3] - u[eeOffset2 + -3];
			var _g3 = eeOffset0 + -2;
			var _g12 = u;
			_g12[_g3] = _g12[_g3] + u[eeOffset2 + -2];
			var _g4 = eeOffset0 + -3;
			var _g13 = u;
			_g13[_g4] = _g13[_g4] + u[eeOffset2 + -3];
			u[eeOffset2 + -2] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eeOffset2 + -3] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 8;
			k00_20 = u[eeOffset0 + -4] - u[eeOffset2 + -4];
			k01_21 = u[eeOffset0 + -5] - u[eeOffset2 + -5];
			var _g5 = eeOffset0 + -4;
			var _g14 = u;
			_g14[_g5] = _g14[_g5] + u[eeOffset2 + -4];
			var _g6 = eeOffset0 + -5;
			var _g15 = u;
			_g15[_g6] = _g15[_g6] + u[eeOffset2 + -5];
			u[eeOffset2 + -4] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eeOffset2 + -5] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 8;
			k00_20 = u[eeOffset0 + -6] - u[eeOffset2 + -6];
			k01_21 = u[eeOffset0 + -7] - u[eeOffset2 + -7];
			var _g7 = eeOffset0 + -6;
			var _g16 = u;
			_g16[_g7] = _g16[_g7] + u[eeOffset2 + -6];
			var _g8 = eeOffset0 + -7;
			var _g17 = u;
			_g17[_g8] = _g17[_g8] + u[eeOffset2 + -7];
			u[eeOffset2 + -6] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			u[eeOffset2 + -7] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 8;
			eeOffset0 -= 8;
			eeOffset2 -= 8;
		}
		var i_off1 = n2 - 1 - n4;
		var eeOffset01 = i_off1;
		var eeOffset21 = i_off1 + -(n >> 3);
		var aOffset1 = 0;
		var i1 = (n >> 4 >> 2) + 1;
		while(--i1 > 0) {
			var k00_201 = u[eeOffset01] - u[eeOffset21];
			var k01_211 = u[eeOffset01 + -1] - u[eeOffset21 + -1];
			var _g9 = eeOffset01;
			var _g18 = u;
			_g18[_g9] = _g18[_g9] + u[eeOffset21];
			var _g10 = eeOffset01 + -1;
			var _g19 = u;
			_g19[_g10] = _g19[_g10] + u[eeOffset21 + -1];
			u[eeOffset21] = k00_201 * a[aOffset1] - k01_211 * a[aOffset1 + 1];
			u[eeOffset21 + -1] = k01_211 * a[aOffset1] + k00_201 * a[aOffset1 + 1];
			aOffset1 += 8;
			k00_201 = u[eeOffset01 + -2] - u[eeOffset21 + -2];
			k01_211 = u[eeOffset01 + -3] - u[eeOffset21 + -3];
			var _g20 = eeOffset01 + -2;
			var _g110 = u;
			_g110[_g20] = _g110[_g20] + u[eeOffset21 + -2];
			var _g21 = eeOffset01 + -3;
			var _g111 = u;
			_g111[_g21] = _g111[_g21] + u[eeOffset21 + -3];
			u[eeOffset21 + -2] = k00_201 * a[aOffset1] - k01_211 * a[aOffset1 + 1];
			u[eeOffset21 + -3] = k01_211 * a[aOffset1] + k00_201 * a[aOffset1 + 1];
			aOffset1 += 8;
			k00_201 = u[eeOffset01 + -4] - u[eeOffset21 + -4];
			k01_211 = u[eeOffset01 + -5] - u[eeOffset21 + -5];
			var _g22 = eeOffset01 + -4;
			var _g112 = u;
			_g112[_g22] = _g112[_g22] + u[eeOffset21 + -4];
			var _g23 = eeOffset01 + -5;
			var _g113 = u;
			_g113[_g23] = _g113[_g23] + u[eeOffset21 + -5];
			u[eeOffset21 + -4] = k00_201 * a[aOffset1] - k01_211 * a[aOffset1 + 1];
			u[eeOffset21 + -5] = k01_211 * a[aOffset1] + k00_201 * a[aOffset1 + 1];
			aOffset1 += 8;
			k00_201 = u[eeOffset01 + -6] - u[eeOffset21 + -6];
			k01_211 = u[eeOffset01 + -7] - u[eeOffset21 + -7];
			var _g24 = eeOffset01 + -6;
			var _g114 = u;
			_g114[_g24] = _g114[_g24] + u[eeOffset21 + -6];
			var _g25 = eeOffset01 + -7;
			var _g115 = u;
			_g115[_g25] = _g115[_g25] + u[eeOffset21 + -7];
			u[eeOffset21 + -6] = k00_201 * a[aOffset1] - k01_211 * a[aOffset1 + 1];
			u[eeOffset21 + -7] = k01_211 * a[aOffset1] + k00_201 * a[aOffset1 + 1];
			aOffset1 += 8;
			eeOffset01 -= 8;
			eeOffset21 -= 8;
		}
		var d0 = n2 - 1 - n8 * 0;
		var aOffset2 = 0;
		var eOffset01 = d0;
		var eOffset2 = d0 + -(n >> 4);
		var i2 = (n >> 5 >> 2) + 1;
		while(--i2 > 0) {
			var k00_202 = u[eOffset01] - u[eOffset2];
			var k01_212 = u[eOffset01 + -1] - u[eOffset2 + -1];
			var _g26 = eOffset01;
			var _g116 = u;
			_g116[_g26] = _g116[_g26] + u[eOffset2];
			var _g27 = eOffset01 + -1;
			var _g117 = u;
			_g117[_g27] = _g117[_g27] + u[eOffset2 + -1];
			u[eOffset2] = k00_202 * a[aOffset2] - k01_212 * a[aOffset2 + 1];
			u[eOffset2 + -1] = k01_212 * a[aOffset2] + k00_202 * a[aOffset2 + 1];
			aOffset2 += 16;
			k00_202 = u[eOffset01 + -2] - u[eOffset2 + -2];
			k01_212 = u[eOffset01 + -3] - u[eOffset2 + -3];
			var _g28 = eOffset01 + -2;
			var _g118 = u;
			_g118[_g28] = _g118[_g28] + u[eOffset2 + -2];
			var _g29 = eOffset01 + -3;
			var _g119 = u;
			_g119[_g29] = _g119[_g29] + u[eOffset2 + -3];
			u[eOffset2 + -2] = k00_202 * a[aOffset2] - k01_212 * a[aOffset2 + 1];
			u[eOffset2 + -3] = k01_212 * a[aOffset2] + k00_202 * a[aOffset2 + 1];
			aOffset2 += 16;
			k00_202 = u[eOffset01 + -4] - u[eOffset2 + -4];
			k01_212 = u[eOffset01 + -5] - u[eOffset2 + -5];
			var _g30 = eOffset01 + -4;
			var _g120 = u;
			_g120[_g30] = _g120[_g30] + u[eOffset2 + -4];
			var _g31 = eOffset01 + -5;
			var _g121 = u;
			_g121[_g31] = _g121[_g31] + u[eOffset2 + -5];
			u[eOffset2 + -4] = k00_202 * a[aOffset2] - k01_212 * a[aOffset2 + 1];
			u[eOffset2 + -5] = k01_212 * a[aOffset2] + k00_202 * a[aOffset2 + 1];
			aOffset2 += 16;
			k00_202 = u[eOffset01 + -6] - u[eOffset2 + -6];
			k01_212 = u[eOffset01 + -7] - u[eOffset2 + -7];
			var _g32 = eOffset01 + -6;
			var _g122 = u;
			_g122[_g32] = _g122[_g32] + u[eOffset2 + -6];
			var _g33 = eOffset01 + -7;
			var _g123 = u;
			_g123[_g33] = _g123[_g33] + u[eOffset2 + -7];
			u[eOffset2 + -6] = k00_202 * a[aOffset2] - k01_212 * a[aOffset2 + 1];
			u[eOffset2 + -7] = k01_212 * a[aOffset2] + k00_202 * a[aOffset2 + 1];
			eOffset01 -= 8;
			eOffset2 -= 8;
			aOffset2 += 16;
		}
		var d01 = n2 - 1 - n8;
		var aOffset3 = 0;
		var eOffset02 = d01;
		var eOffset21 = d01 + -(n >> 4);
		var i3 = (n >> 5 >> 2) + 1;
		while(--i3 > 0) {
			var k00_203 = u[eOffset02] - u[eOffset21];
			var k01_213 = u[eOffset02 + -1] - u[eOffset21 + -1];
			var _g34 = eOffset02;
			var _g124 = u;
			_g124[_g34] = _g124[_g34] + u[eOffset21];
			var _g35 = eOffset02 + -1;
			var _g125 = u;
			_g125[_g35] = _g125[_g35] + u[eOffset21 + -1];
			u[eOffset21] = k00_203 * a[aOffset3] - k01_213 * a[aOffset3 + 1];
			u[eOffset21 + -1] = k01_213 * a[aOffset3] + k00_203 * a[aOffset3 + 1];
			aOffset3 += 16;
			k00_203 = u[eOffset02 + -2] - u[eOffset21 + -2];
			k01_213 = u[eOffset02 + -3] - u[eOffset21 + -3];
			var _g36 = eOffset02 + -2;
			var _g126 = u;
			_g126[_g36] = _g126[_g36] + u[eOffset21 + -2];
			var _g37 = eOffset02 + -3;
			var _g127 = u;
			_g127[_g37] = _g127[_g37] + u[eOffset21 + -3];
			u[eOffset21 + -2] = k00_203 * a[aOffset3] - k01_213 * a[aOffset3 + 1];
			u[eOffset21 + -3] = k01_213 * a[aOffset3] + k00_203 * a[aOffset3 + 1];
			aOffset3 += 16;
			k00_203 = u[eOffset02 + -4] - u[eOffset21 + -4];
			k01_213 = u[eOffset02 + -5] - u[eOffset21 + -5];
			var _g38 = eOffset02 + -4;
			var _g128 = u;
			_g128[_g38] = _g128[_g38] + u[eOffset21 + -4];
			var _g39 = eOffset02 + -5;
			var _g129 = u;
			_g129[_g39] = _g129[_g39] + u[eOffset21 + -5];
			u[eOffset21 + -4] = k00_203 * a[aOffset3] - k01_213 * a[aOffset3 + 1];
			u[eOffset21 + -5] = k01_213 * a[aOffset3] + k00_203 * a[aOffset3 + 1];
			aOffset3 += 16;
			k00_203 = u[eOffset02 + -6] - u[eOffset21 + -6];
			k01_213 = u[eOffset02 + -7] - u[eOffset21 + -7];
			var _g40 = eOffset02 + -6;
			var _g130 = u;
			_g130[_g40] = _g130[_g40] + u[eOffset21 + -6];
			var _g41 = eOffset02 + -7;
			var _g131 = u;
			_g131[_g41] = _g131[_g41] + u[eOffset21 + -7];
			u[eOffset21 + -6] = k00_203 * a[aOffset3] - k01_213 * a[aOffset3 + 1];
			u[eOffset21 + -7] = k01_213 * a[aOffset3] + k00_203 * a[aOffset3 + 1];
			eOffset02 -= 8;
			eOffset21 -= 8;
			aOffset3 += 16;
		}
		var d02 = n2 - 1 - n8 * 2;
		var aOffset4 = 0;
		var eOffset03 = d02;
		var eOffset22 = d02 + -(n >> 4);
		var i4 = (n >> 5 >> 2) + 1;
		while(--i4 > 0) {
			var k00_204 = u[eOffset03] - u[eOffset22];
			var k01_214 = u[eOffset03 + -1] - u[eOffset22 + -1];
			var _g42 = eOffset03;
			var _g132 = u;
			_g132[_g42] = _g132[_g42] + u[eOffset22];
			var _g43 = eOffset03 + -1;
			var _g133 = u;
			_g133[_g43] = _g133[_g43] + u[eOffset22 + -1];
			u[eOffset22] = k00_204 * a[aOffset4] - k01_214 * a[aOffset4 + 1];
			u[eOffset22 + -1] = k01_214 * a[aOffset4] + k00_204 * a[aOffset4 + 1];
			aOffset4 += 16;
			k00_204 = u[eOffset03 + -2] - u[eOffset22 + -2];
			k01_214 = u[eOffset03 + -3] - u[eOffset22 + -3];
			var _g44 = eOffset03 + -2;
			var _g134 = u;
			_g134[_g44] = _g134[_g44] + u[eOffset22 + -2];
			var _g45 = eOffset03 + -3;
			var _g135 = u;
			_g135[_g45] = _g135[_g45] + u[eOffset22 + -3];
			u[eOffset22 + -2] = k00_204 * a[aOffset4] - k01_214 * a[aOffset4 + 1];
			u[eOffset22 + -3] = k01_214 * a[aOffset4] + k00_204 * a[aOffset4 + 1];
			aOffset4 += 16;
			k00_204 = u[eOffset03 + -4] - u[eOffset22 + -4];
			k01_214 = u[eOffset03 + -5] - u[eOffset22 + -5];
			var _g46 = eOffset03 + -4;
			var _g136 = u;
			_g136[_g46] = _g136[_g46] + u[eOffset22 + -4];
			var _g47 = eOffset03 + -5;
			var _g137 = u;
			_g137[_g47] = _g137[_g47] + u[eOffset22 + -5];
			u[eOffset22 + -4] = k00_204 * a[aOffset4] - k01_214 * a[aOffset4 + 1];
			u[eOffset22 + -5] = k01_214 * a[aOffset4] + k00_204 * a[aOffset4 + 1];
			aOffset4 += 16;
			k00_204 = u[eOffset03 + -6] - u[eOffset22 + -6];
			k01_214 = u[eOffset03 + -7] - u[eOffset22 + -7];
			var _g48 = eOffset03 + -6;
			var _g138 = u;
			_g138[_g48] = _g138[_g48] + u[eOffset22 + -6];
			var _g49 = eOffset03 + -7;
			var _g139 = u;
			_g139[_g49] = _g139[_g49] + u[eOffset22 + -7];
			u[eOffset22 + -6] = k00_204 * a[aOffset4] - k01_214 * a[aOffset4 + 1];
			u[eOffset22 + -7] = k01_214 * a[aOffset4] + k00_204 * a[aOffset4 + 1];
			eOffset03 -= 8;
			eOffset22 -= 8;
			aOffset4 += 16;
		}
		var d03 = n2 - 1 - n8 * 3;
		var aOffset5 = 0;
		var eOffset04 = d03;
		var eOffset23 = d03 + -(n >> 4);
		var i5 = (n >> 5 >> 2) + 1;
		while(--i5 > 0) {
			var k00_205 = u[eOffset04] - u[eOffset23];
			var k01_215 = u[eOffset04 + -1] - u[eOffset23 + -1];
			var _g50 = eOffset04;
			var _g140 = u;
			_g140[_g50] = _g140[_g50] + u[eOffset23];
			var _g51 = eOffset04 + -1;
			var _g141 = u;
			_g141[_g51] = _g141[_g51] + u[eOffset23 + -1];
			u[eOffset23] = k00_205 * a[aOffset5] - k01_215 * a[aOffset5 + 1];
			u[eOffset23 + -1] = k01_215 * a[aOffset5] + k00_205 * a[aOffset5 + 1];
			aOffset5 += 16;
			k00_205 = u[eOffset04 + -2] - u[eOffset23 + -2];
			k01_215 = u[eOffset04 + -3] - u[eOffset23 + -3];
			var _g52 = eOffset04 + -2;
			var _g142 = u;
			_g142[_g52] = _g142[_g52] + u[eOffset23 + -2];
			var _g53 = eOffset04 + -3;
			var _g143 = u;
			_g143[_g53] = _g143[_g53] + u[eOffset23 + -3];
			u[eOffset23 + -2] = k00_205 * a[aOffset5] - k01_215 * a[aOffset5 + 1];
			u[eOffset23 + -3] = k01_215 * a[aOffset5] + k00_205 * a[aOffset5 + 1];
			aOffset5 += 16;
			k00_205 = u[eOffset04 + -4] - u[eOffset23 + -4];
			k01_215 = u[eOffset04 + -5] - u[eOffset23 + -5];
			var _g54 = eOffset04 + -4;
			var _g144 = u;
			_g144[_g54] = _g144[_g54] + u[eOffset23 + -4];
			var _g55 = eOffset04 + -5;
			var _g145 = u;
			_g145[_g55] = _g145[_g55] + u[eOffset23 + -5];
			u[eOffset23 + -4] = k00_205 * a[aOffset5] - k01_215 * a[aOffset5 + 1];
			u[eOffset23 + -5] = k01_215 * a[aOffset5] + k00_205 * a[aOffset5 + 1];
			aOffset5 += 16;
			k00_205 = u[eOffset04 + -6] - u[eOffset23 + -6];
			k01_215 = u[eOffset04 + -7] - u[eOffset23 + -7];
			var _g56 = eOffset04 + -6;
			var _g146 = u;
			_g146[_g56] = _g146[_g56] + u[eOffset23 + -6];
			var _g57 = eOffset04 + -7;
			var _g147 = u;
			_g147[_g57] = _g147[_g57] + u[eOffset23 + -7];
			u[eOffset23 + -6] = k00_205 * a[aOffset5] - k01_215 * a[aOffset5 + 1];
			u[eOffset23 + -7] = k01_215 * a[aOffset5] + k00_205 * a[aOffset5 + 1];
			eOffset04 -= 8;
			eOffset23 -= 8;
			aOffset5 += 16;
		}
		var _g148 = 2;
		var _g58 = ld - 3 >> 1;
		while(_g148 < _g58) {
			var l = _g148++;
			var k0 = n >> l + 2;
			var k0_2 = k0 >> 1;
			var lim = 1 << l + 1;
			var _g310 = 0;
			var _g210 = lim;
			while(_g310 < _g210) {
				var i6 = _g310++;
				var d04 = n2 - 1 - k0 * i6;
				var k1 = 1 << l + 3;
				var aOffset6 = 0;
				var eOffset05 = d04;
				var eOffset24 = d04 + -k0_2;
				var i7 = (n >> l + 4 >> 2) + 1;
				while(--i7 > 0) {
					var k00_206 = u[eOffset05] - u[eOffset24];
					var k01_216 = u[eOffset05 + -1] - u[eOffset24 + -1];
					var _g59 = eOffset05;
					var _g149 = u;
					_g149[_g59] = _g149[_g59] + u[eOffset24];
					var _g60 = eOffset05 + -1;
					var _g150 = u;
					_g150[_g60] = _g150[_g60] + u[eOffset24 + -1];
					u[eOffset24] = k00_206 * a[aOffset6] - k01_216 * a[aOffset6 + 1];
					u[eOffset24 + -1] = k01_216 * a[aOffset6] + k00_206 * a[aOffset6 + 1];
					aOffset6 += k1;
					k00_206 = u[eOffset05 + -2] - u[eOffset24 + -2];
					k01_216 = u[eOffset05 + -3] - u[eOffset24 + -3];
					var _g61 = eOffset05 + -2;
					var _g151 = u;
					_g151[_g61] = _g151[_g61] + u[eOffset24 + -2];
					var _g62 = eOffset05 + -3;
					var _g152 = u;
					_g152[_g62] = _g152[_g62] + u[eOffset24 + -3];
					u[eOffset24 + -2] = k00_206 * a[aOffset6] - k01_216 * a[aOffset6 + 1];
					u[eOffset24 + -3] = k01_216 * a[aOffset6] + k00_206 * a[aOffset6 + 1];
					aOffset6 += k1;
					k00_206 = u[eOffset05 + -4] - u[eOffset24 + -4];
					k01_216 = u[eOffset05 + -5] - u[eOffset24 + -5];
					var _g63 = eOffset05 + -4;
					var _g153 = u;
					_g153[_g63] = _g153[_g63] + u[eOffset24 + -4];
					var _g64 = eOffset05 + -5;
					var _g154 = u;
					_g154[_g64] = _g154[_g64] + u[eOffset24 + -5];
					u[eOffset24 + -4] = k00_206 * a[aOffset6] - k01_216 * a[aOffset6 + 1];
					u[eOffset24 + -5] = k01_216 * a[aOffset6] + k00_206 * a[aOffset6 + 1];
					aOffset6 += k1;
					k00_206 = u[eOffset05 + -6] - u[eOffset24 + -6];
					k01_216 = u[eOffset05 + -7] - u[eOffset24 + -7];
					var _g65 = eOffset05 + -6;
					var _g155 = u;
					_g155[_g65] = _g155[_g65] + u[eOffset24 + -6];
					var _g66 = eOffset05 + -7;
					var _g156 = u;
					_g156[_g66] = _g156[_g66] + u[eOffset24 + -7];
					u[eOffset24 + -6] = k00_206 * a[aOffset6] - k01_216 * a[aOffset6 + 1];
					u[eOffset24 + -7] = k01_216 * a[aOffset6] + k00_206 * a[aOffset6 + 1];
					eOffset05 -= 8;
					eOffset24 -= 8;
					aOffset6 += k1;
				}
			}
		}
		var _g157 = ld - 3 >> 1;
		var _g67 = ld - 6;
		while(_g157 < _g67) {
			var l1 = _g157++;
			var k01 = n >> l1 + 2;
			var k11 = 1 << l1 + 3;
			var k0_21 = k01 >> 1;
			var rlim = n >> l1 + 6;
			var lim1 = 1 << l1 + 1;
			var aOffset7 = 0;
			var i_off2 = n2 - 1;
			var r = rlim + 1;
			while(--r > 0) {
				var A0 = a[aOffset7];
				var A1 = a[aOffset7 + 1];
				var A2 = a[aOffset7 + k11];
				var A3 = a[aOffset7 + k11 + 1];
				var A4 = a[aOffset7 + k11 * 2];
				var A5 = a[aOffset7 + k11 * 2 + 1];
				var A6 = a[aOffset7 + k11 * 3];
				var A7 = a[aOffset7 + k11 * 3 + 1];
				var eeOffset02 = i_off2;
				var eeOffset22 = i_off2 + -k0_21;
				var i8 = lim1 + 1;
				while(--i8 > 0) {
					var k00 = u[eeOffset02] - u[eeOffset22];
					var k111 = u[eeOffset02 + -1] - u[eeOffset22 + -1];
					u[eeOffset02] = u[eeOffset02] + u[eeOffset22];
					u[eeOffset02 + -1] = u[eeOffset02 + -1] + u[eeOffset22 + -1];
					u[eeOffset22] = k00 * A0 - k111 * A1;
					u[eeOffset22 + -1] = k111 * A0 + k00 * A1;
					k00 = u[eeOffset02 + -2] - u[eeOffset22 + -2];
					k111 = u[eeOffset02 + -3] - u[eeOffset22 + -3];
					u[eeOffset02 + -2] = u[eeOffset02 + -2] + u[eeOffset22 + -2];
					u[eeOffset02 + -3] = u[eeOffset02 + -3] + u[eeOffset22 + -3];
					u[eeOffset22 + -2] = k00 * A2 - k111 * A3;
					u[eeOffset22 + -3] = k111 * A2 + k00 * A3;
					k00 = u[eeOffset02 + -4] - u[eeOffset22 + -4];
					k111 = u[eeOffset02 + -5] - u[eeOffset22 + -5];
					u[eeOffset02 + -4] = u[eeOffset02 + -4] + u[eeOffset22 + -4];
					u[eeOffset02 + -5] = u[eeOffset02 + -5] + u[eeOffset22 + -5];
					u[eeOffset22 + -4] = k00 * A4 - k111 * A5;
					u[eeOffset22 + -5] = k111 * A4 + k00 * A5;
					k00 = u[eeOffset02 + -6] - u[eeOffset22 + -6];
					k111 = u[eeOffset02 + -7] - u[eeOffset22 + -7];
					u[eeOffset02 + -6] = u[eeOffset02 + -6] + u[eeOffset22 + -6];
					u[eeOffset02 + -7] = u[eeOffset02 + -7] + u[eeOffset22 + -7];
					u[eeOffset22 + -6] = k00 * A6 - k111 * A7;
					u[eeOffset22 + -7] = k111 * A6 + k00 * A7;
					eeOffset02 -= k01;
					eeOffset22 -= k01;
				}
				aOffset7 += k11 * 4;
				i_off2 -= 8;
			}
		}
		var i_off3 = n2 - 1;
		var A21 = a[n >> 3];
		var zOffset = i_off3;
		var baseOffset = i_off3 - 16 * (n >> 5);
		while(zOffset > baseOffset) {
			var t0 = u[zOffset];
			var t1 = u[zOffset + -8];
			u[zOffset + -8] = t0 - t1;
			u[zOffset] = t0 + t1;
			t0 = u[zOffset + -1];
			t1 = u[zOffset + -9];
			u[zOffset + -9] = t0 - t1;
			u[zOffset + -1] = t0 + t1;
			t0 = u[zOffset + -2];
			t1 = u[zOffset + -10];
			var k001 = t0 - t1;
			u[zOffset + -2] = t0 + t1;
			t0 = u[zOffset + -3];
			t1 = u[zOffset + -11];
			var k112 = t0 - t1;
			u[zOffset + -3] = t0 + t1;
			u[zOffset + -10] = (k001 + k112) * A21;
			u[zOffset + -11] = (k112 - k001) * A21;
			t0 = u[zOffset + -4];
			t1 = u[zOffset + -12];
			k001 = t1 - t0;
			u[zOffset + -4] = t0 + t1;
			t0 = u[zOffset + -5];
			t1 = u[zOffset + -13];
			k112 = t0 - t1;
			u[zOffset + -5] = t0 + t1;
			u[zOffset + -12] = k112;
			u[zOffset + -13] = k001;
			t0 = u[zOffset + -6];
			t1 = u[zOffset + -14];
			k001 = t1 - t0;
			u[zOffset + -6] = t0 + t1;
			t0 = u[zOffset + -7];
			t1 = u[zOffset + -15];
			k112 = t0 - t1;
			u[zOffset + -7] = t0 + t1;
			u[zOffset + -14] = (k001 + k112) * A21;
			u[zOffset + -15] = (k001 - k112) * A21;
			var t01 = u[zOffset];
			var t11 = u[zOffset + -4];
			var k002 = t01 - t11;
			var y0 = t01 + t11;
			t01 = u[zOffset + -2];
			t11 = u[zOffset + -6];
			var y2 = t01 + t11;
			var k22 = t01 - t11;
			u[zOffset] = y0 + y2;
			u[zOffset + -2] = y0 - y2;
			var k33 = u[zOffset + -3] - u[zOffset + -7];
			u[zOffset + -4] = k002 + k33;
			u[zOffset + -6] = k002 - k33;
			t01 = u[zOffset + -1];
			t11 = u[zOffset + -5];
			var k113 = t01 - t11;
			var y1 = t01 + t11;
			var y3 = u[zOffset + -3] + u[zOffset + -7];
			u[zOffset + -1] = y1 + y3;
			u[zOffset + -3] = y1 - y3;
			u[zOffset + -5] = k113 - k22;
			u[zOffset + -7] = k113 + k22;
			var zOffset1 = zOffset - 8;
			var t02 = u[zOffset1];
			var t12 = u[zOffset1 + -4];
			var k003 = t02 - t12;
			var y01 = t02 + t12;
			t02 = u[zOffset1 + -2];
			t12 = u[zOffset1 + -6];
			var y21 = t02 + t12;
			var k221 = t02 - t12;
			u[zOffset1] = y01 + y21;
			u[zOffset1 + -2] = y01 - y21;
			var k331 = u[zOffset1 + -3] - u[zOffset1 + -7];
			u[zOffset1 + -4] = k003 + k331;
			u[zOffset1 + -6] = k003 - k331;
			t02 = u[zOffset1 + -1];
			t12 = u[zOffset1 + -5];
			var k114 = t02 - t12;
			var y11 = t02 + t12;
			var y31 = u[zOffset1 + -3] + u[zOffset1 + -7];
			u[zOffset1 + -1] = y11 + y31;
			u[zOffset1 + -3] = y11 - y31;
			u[zOffset1 + -5] = k114 - k221;
			u[zOffset1 + -7] = k114 + k221;
			zOffset -= 16;
		}
		var brOffset = 0;
		var dOffset01 = n4 - 4;
		var dOffset11 = n2 - 4;
		while(dOffset01 >= 0) {
			var k4 = bitReverse[brOffset];
			v[dOffset11 + 3] = u[k4];
			v[dOffset11 + 2] = u[k4 + 1];
			v[dOffset01 + 3] = u[k4 + 2];
			v[dOffset01 + 2] = u[k4 + 3];
			k4 = bitReverse[brOffset + 1];
			v[dOffset11 + 1] = u[k4];
			v[dOffset11] = u[k4 + 1];
			v[dOffset01 + 1] = u[k4 + 2];
			v[dOffset01] = u[k4 + 3];
			dOffset01 -= 4;
			dOffset11 -= 4;
			brOffset += 2;
		}
		var cOffset = 0;
		var dOffset2 = 0;
		var eOffset3 = n2 - 4;
		while(dOffset2 < eOffset3) {
			var a02 = v[dOffset2] - v[eOffset3 + 2];
			var a11 = v[dOffset2 + 1] + v[eOffset3 + 3];
			var b0 = c[cOffset + 1] * a02 + c[cOffset] * a11;
			var b1 = c[cOffset + 1] * a11 - c[cOffset] * a02;
			var b2 = v[dOffset2] + v[eOffset3 + 2];
			var b3 = v[dOffset2 + 1] - v[eOffset3 + 3];
			v[dOffset2] = b2 + b0;
			v[dOffset2 + 1] = b3 + b1;
			v[eOffset3 + 2] = b2 - b0;
			v[eOffset3 + 3] = b1 - b3;
			a02 = v[dOffset2 + 2] - v[eOffset3];
			a11 = v[dOffset2 + 3] + v[eOffset3 + 1];
			b0 = c[cOffset + 3] * a02 + c[cOffset + 2] * a11;
			b1 = c[cOffset + 3] * a11 - c[cOffset + 2] * a02;
			b2 = v[dOffset2 + 2] + v[eOffset3];
			b3 = v[dOffset2 + 3] - v[eOffset3 + 1];
			v[dOffset2 + 2] = b2 + b0;
			v[dOffset2 + 3] = b3 + b1;
			v[eOffset3] = b2 - b0;
			v[eOffset3 + 1] = b1 - b3;
			cOffset += 4;
			dOffset2 += 4;
			eOffset3 -= 4;
		}
		var bOffset = n2 - 8;
		var eOffset4 = n2 - 8;
		var dOffset02 = 0;
		var dOffset12 = n2 - 4;
		var dOffset21 = n2;
		var dOffset3 = n - 4;
		while(eOffset4 >= 0) {
			var p3 = buf2[eOffset4 + 6] * b[bOffset + 7] - buf2[eOffset4 + 7] * b[bOffset + 6];
			var p2 = -buf2[eOffset4 + 6] * b[bOffset + 6] - buf2[eOffset4 + 7] * b[bOffset + 7];
			buffer[dOffset02] = p3;
			buffer[dOffset12 + 3] = -p3;
			buffer[dOffset21] = p2;
			buffer[dOffset3 + 3] = p2;
			var p1 = buf2[eOffset4 + 4] * b[bOffset + 5] - buf2[eOffset4 + 5] * b[bOffset + 4];
			var p0 = -buf2[eOffset4 + 4] * b[bOffset + 4] - buf2[eOffset4 + 5] * b[bOffset + 5];
			buffer[dOffset02 + 1] = p1;
			buffer[dOffset12 + 2] = -p1;
			buffer[dOffset21 + 1] = p0;
			buffer[dOffset3 + 2] = p0;
			p3 = buf2[eOffset4 + 2] * b[bOffset + 3] - buf2[eOffset4 + 3] * b[bOffset + 2];
			p2 = -buf2[eOffset4 + 2] * b[bOffset + 2] - buf2[eOffset4 + 3] * b[bOffset + 3];
			buffer[dOffset02 + 2] = p3;
			buffer[dOffset12 + 1] = -p3;
			buffer[dOffset21 + 2] = p2;
			buffer[dOffset3 + 1] = p2;
			p1 = buf2[eOffset4] * b[bOffset + 1] - buf2[eOffset4 + 1] * b[bOffset];
			p0 = -buf2[eOffset4] * b[bOffset] - buf2[eOffset4 + 1] * b[bOffset + 1];
			buffer[dOffset02 + 3] = p1;
			buffer[dOffset12] = -p1;
			buffer[dOffset21 + 3] = p0;
			buffer[dOffset3] = p0;
			bOffset -= 8;
			eOffset4 -= 8;
			dOffset02 += 4;
			dOffset21 += 4;
			dOffset12 -= 4;
			dOffset3 -= 4;
		}
	}
	,decodePacket: function() {
		var result = this.decodeInitial();
		if(result == null) {
			return null;
		}
		var rest = this.decodePacketRest(result);
		return rest;
	}
	,decodeInitial: function() {
		this.channelBufferStart = this.channelBufferEnd = 0;
		while(true) {
			if(!this.decodeState.maybeStartPacket()) {
				return null;
			}
			var _this = this.decodeState;
			var tmp;
			if(_this.validBits < 0) {
				tmp = 0;
			} else if(_this.validBits < 1) {
				if(_this.validBits == 0) {
					_this.acc = 0;
				}
				while(true) {
					if(_this.bytesInSeg == 0 && (_this.lastSeg || _this.next() == 0)) {
						_this.validBits = -1;
						break;
					} else {
						_this.bytesInSeg--;
						_this.inputPosition += 1;
						_this.acc = _this.acc + (_this.input.readByte() << _this.validBits);
						_this.validBits += 8;
					}
					if(!(_this.validBits < 1)) {
						break;
					}
				}
				if(_this.validBits < 0) {
					tmp = 0;
				} else {
					var z = _this.acc & 1;
					_this.acc = _this.acc >>> 1;
					_this.validBits -= 1;
					tmp = z;
				}
			} else {
				var z1 = _this.acc & 1;
				_this.acc = _this.acc >>> 1;
				_this.validBits -= 1;
				tmp = z1;
			}
			if(tmp != 0) {
				while(true) {
					var _this1 = this.decodeState;
					var x;
					if(_this1.bytesInSeg == 0 && (_this1.lastSeg || _this1.next() == 0)) {
						x = -1;
					} else {
						_this1.bytesInSeg--;
						_this1.inputPosition += 1;
						x = _this1.input.readByte();
					}
					_this1.validBits = 0;
					if(!(-1 != x)) {
						break;
					}
				}
				continue;
			}
			break;
		}
		var _this2 = this.decodeState;
		var n = this.header.modes.length - 1;
		var log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
		var n1 = n < 16384 ? n < 16 ? log2_4[n] : n < 512 ? 5 + log2_4[n >> 5] : 10 + log2_4[n >> 10] : n < 16777216 ? n < 524288 ? 15 + log2_4[n >> 15] : 20 + log2_4[n >> 20] : n < 536870912 ? 25 + log2_4[n >> 25] : n < -2147483648 ? 30 + log2_4[n >> 30] : 0;
		var i;
		if(_this2.validBits < 0) {
			i = 0;
		} else if(_this2.validBits < n1) {
			if(n1 > 24) {
				i = _this2.readBits(24) + (_this2.readBits(n1 - 24) << 24);
			} else {
				if(_this2.validBits == 0) {
					_this2.acc = 0;
				}
				while(true) {
					if(_this2.bytesInSeg == 0 && (_this2.lastSeg || _this2.next() == 0)) {
						_this2.validBits = -1;
						break;
					} else {
						_this2.bytesInSeg--;
						_this2.inputPosition += 1;
						_this2.acc = _this2.acc + (_this2.input.readByte() << _this2.validBits);
						_this2.validBits += 8;
					}
					if(!(_this2.validBits < n1)) {
						break;
					}
				}
				if(_this2.validBits < 0) {
					i = 0;
				} else {
					var z2 = _this2.acc & (1 << n1) - 1;
					_this2.acc = _this2.acc >>> n1;
					_this2.validBits -= n1;
					i = z2;
				}
			}
		} else {
			var z3 = _this2.acc & (1 << n1) - 1;
			_this2.acc = _this2.acc >>> n1;
			_this2.validBits -= n1;
			i = z3;
		}
		if(i == -1 || i >= this.header.modes.length) {
			throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.SEEK_FAILED,null,{ fileName : "VorbisDecoder.hx", lineNumber : 519, className : "kha.audio2.ogg.vorbis.VorbisDecoder", methodName : "decodeInitial"}));
		}
		var m = this.header.modes[i];
		var n2;
		var prev;
		var next;
		if(m.blockflag) {
			n2 = this.header.blocksize1;
			var _this3 = this.decodeState;
			if(_this3.validBits < 0) {
				prev = 0;
			} else if(_this3.validBits < 1) {
				if(_this3.validBits == 0) {
					_this3.acc = 0;
				}
				while(true) {
					if(_this3.bytesInSeg == 0 && (_this3.lastSeg || _this3.next() == 0)) {
						_this3.validBits = -1;
						break;
					} else {
						_this3.bytesInSeg--;
						_this3.inputPosition += 1;
						_this3.acc = _this3.acc + (_this3.input.readByte() << _this3.validBits);
						_this3.validBits += 8;
					}
					if(!(_this3.validBits < 1)) {
						break;
					}
				}
				if(_this3.validBits < 0) {
					prev = 0;
				} else {
					var z4 = _this3.acc & 1;
					_this3.acc = _this3.acc >>> 1;
					_this3.validBits -= 1;
					prev = z4;
				}
			} else {
				var z5 = _this3.acc & 1;
				_this3.acc = _this3.acc >>> 1;
				_this3.validBits -= 1;
				prev = z5;
			}
			var _this4 = this.decodeState;
			if(_this4.validBits < 0) {
				next = 0;
			} else if(_this4.validBits < 1) {
				if(_this4.validBits == 0) {
					_this4.acc = 0;
				}
				while(true) {
					if(_this4.bytesInSeg == 0 && (_this4.lastSeg || _this4.next() == 0)) {
						_this4.validBits = -1;
						break;
					} else {
						_this4.bytesInSeg--;
						_this4.inputPosition += 1;
						_this4.acc = _this4.acc + (_this4.input.readByte() << _this4.validBits);
						_this4.validBits += 8;
					}
					if(!(_this4.validBits < 1)) {
						break;
					}
				}
				if(_this4.validBits < 0) {
					next = 0;
				} else {
					var z6 = _this4.acc & 1;
					_this4.acc = _this4.acc >>> 1;
					_this4.validBits -= 1;
					next = z6;
				}
			} else {
				var z7 = _this4.acc & 1;
				_this4.acc = _this4.acc >>> 1;
				_this4.validBits -= 1;
				next = z7;
			}
		} else {
			next = 0;
			prev = next;
			n2 = this.header.blocksize0;
		}
		var windowCenter = n2 >> 1;
		return { mode : i, left : m.blockflag && prev == 0 ? { start : n2 - this.header.blocksize0 >> 2, end : n2 + this.header.blocksize0 >> 2} : { start : 0, end : windowCenter}, right : m.blockflag && next == 0 ? { start : n2 * 3 - this.header.blocksize0 >> 2, end : n2 * 3 + this.header.blocksize0 >> 2} : { start : windowCenter, end : n2}};
	}
	,decodePacketRest: function(r) {
		var len = 0;
		var m = this.header.modes[r.mode];
		var this1 = new Array(256);
		var zeroChannel = this1;
		var this2 = new Array(256);
		var reallyZeroChannel = this2;
		var n = m.blockflag ? this.header.blocksize1 : this.header.blocksize0;
		var map = this.header.mapping[m.mapping];
		var n2 = n >> 1;
		var rangeList = [256,128,86,64];
		var codebooks = this.header.codebooks;
		var _g1 = 0;
		var _g = this.header.channel;
		while(_g1 < _g) {
			var i = _g1++;
			var s = map.chan[i].mux;
			zeroChannel[i] = false;
			var floor = this.header.floorConfig[map.submapFloor[s]];
			if(floor.type == 0) {
				throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_STREAM,null,{ fileName : "VorbisDecoder.hx", lineNumber : 581, className : "kha.audio2.ogg.vorbis.VorbisDecoder", methodName : "decodePacketRest"}));
			} else {
				var g = floor.floor1;
				var _this = this.decodeState;
				var tmp;
				if(_this.validBits < 0) {
					tmp = 0;
				} else if(_this.validBits < 1) {
					if(_this.validBits == 0) {
						_this.acc = 0;
					}
					while(true) {
						if(_this.bytesInSeg == 0 && (_this.lastSeg || _this.next() == 0)) {
							_this.validBits = -1;
							break;
						} else {
							_this.bytesInSeg--;
							_this.inputPosition += 1;
							_this.acc = _this.acc + (_this.input.readByte() << _this.validBits);
							_this.validBits += 8;
						}
						if(!(_this.validBits < 1)) {
							break;
						}
					}
					if(_this.validBits < 0) {
						tmp = 0;
					} else {
						var z = _this.acc & 1;
						_this.acc = _this.acc >>> 1;
						_this.validBits -= 1;
						tmp = z;
					}
				} else {
					var z1 = _this.acc & 1;
					_this.acc = _this.acc >>> 1;
					_this.validBits -= 1;
					tmp = z1;
				}
				if(tmp != 0) {
					var fy = [];
					var this3 = new Array(256);
					var step2Flag = this3;
					var range = rangeList[g.floor1Multiplier - 1];
					var offset = 2;
					fy = this.finalY[i];
					var _this1 = this.decodeState;
					var log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
					var n1 = (range < 16384 ? range < 16 ? log2_4[range] : range < 512 ? 5 + log2_4[range >> 5] : 10 + log2_4[range >> 10] : range < 16777216 ? range < 524288 ? 15 + log2_4[range >> 15] : 20 + log2_4[range >> 20] : range < 536870912 ? 25 + log2_4[range >> 25] : range < -2147483648 ? 30 + log2_4[range >> 30] : 0) - 1;
					var tmp1;
					if(_this1.validBits < 0) {
						tmp1 = 0;
					} else if(_this1.validBits < n1) {
						if(n1 > 24) {
							tmp1 = _this1.readBits(24) + (_this1.readBits(n1 - 24) << 24);
						} else {
							if(_this1.validBits == 0) {
								_this1.acc = 0;
							}
							while(true) {
								if(_this1.bytesInSeg == 0 && (_this1.lastSeg || _this1.next() == 0)) {
									_this1.validBits = -1;
									break;
								} else {
									_this1.bytesInSeg--;
									_this1.inputPosition += 1;
									_this1.acc = _this1.acc + (_this1.input.readByte() << _this1.validBits);
									_this1.validBits += 8;
								}
								if(!(_this1.validBits < n1)) {
									break;
								}
							}
							if(_this1.validBits < 0) {
								tmp1 = 0;
							} else {
								var z2 = _this1.acc & (1 << n1) - 1;
								_this1.acc = _this1.acc >>> n1;
								_this1.validBits -= n1;
								tmp1 = z2;
							}
						}
					} else {
						var z3 = _this1.acc & (1 << n1) - 1;
						_this1.acc = _this1.acc >>> n1;
						_this1.validBits -= n1;
						tmp1 = z3;
					}
					fy[0] = tmp1;
					var _this2 = this.decodeState;
					var log2_41 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
					var n3 = (range < 16384 ? range < 16 ? log2_41[range] : range < 512 ? 5 + log2_41[range >> 5] : 10 + log2_41[range >> 10] : range < 16777216 ? range < 524288 ? 15 + log2_41[range >> 15] : 20 + log2_41[range >> 20] : range < 536870912 ? 25 + log2_41[range >> 25] : range < -2147483648 ? 30 + log2_41[range >> 30] : 0) - 1;
					var tmp2;
					if(_this2.validBits < 0) {
						tmp2 = 0;
					} else if(_this2.validBits < n3) {
						if(n3 > 24) {
							tmp2 = _this2.readBits(24) + (_this2.readBits(n3 - 24) << 24);
						} else {
							if(_this2.validBits == 0) {
								_this2.acc = 0;
							}
							while(true) {
								if(_this2.bytesInSeg == 0 && (_this2.lastSeg || _this2.next() == 0)) {
									_this2.validBits = -1;
									break;
								} else {
									_this2.bytesInSeg--;
									_this2.inputPosition += 1;
									_this2.acc = _this2.acc + (_this2.input.readByte() << _this2.validBits);
									_this2.validBits += 8;
								}
								if(!(_this2.validBits < n3)) {
									break;
								}
							}
							if(_this2.validBits < 0) {
								tmp2 = 0;
							} else {
								var z4 = _this2.acc & (1 << n3) - 1;
								_this2.acc = _this2.acc >>> n3;
								_this2.validBits -= n3;
								tmp2 = z4;
							}
						}
					} else {
						var z5 = _this2.acc & (1 << n3) - 1;
						_this2.acc = _this2.acc >>> n3;
						_this2.validBits -= n3;
						tmp2 = z5;
					}
					fy[1] = tmp2;
					var _g3 = 0;
					var _g2 = g.partitions;
					while(_g3 < _g2) {
						var j = _g3++;
						var pclass = g.partitionClassList[j];
						var cdim = g.classDimensions[pclass];
						var cbits = g.classSubclasses[pclass];
						var csub = (1 << cbits) - 1;
						var cval = 0;
						if(cbits != 0) {
							var c = codebooks[g.classMasterbooks[pclass]];
							var _this3 = this.decodeState;
							if(_this3.validBits < 10) {
								_this3.prepHuffman();
							}
							var i1 = c.fastHuffman[_this3.acc & 1023];
							var val;
							if(i1 >= 0) {
								var l = c.codewordLengths[i1];
								_this3.acc = _this3.acc >>> l;
								_this3.validBits -= l;
								if(_this3.validBits < 0) {
									_this3.validBits = 0;
									val = -1;
								} else {
									val = i1;
								}
							} else {
								val = _this3.decodeScalarRaw(c);
							}
							if(c.sparse) {
								val = c.sortedValues[val];
							}
							cval = val;
						}
						var books = g.subclassBooks[pclass];
						var _g5 = 0;
						var _g4 = cdim;
						while(_g5 < _g4) {
							var k = _g5++;
							var book = books[cval & csub];
							cval >>= cbits;
							var tmp3 = offset++;
							var tmp4;
							if(book >= 0) {
								var _this4 = this.decodeState;
								var c1 = codebooks[book];
								if(_this4.validBits < 10) {
									_this4.prepHuffman();
								}
								var i2 = c1.fastHuffman[_this4.acc & 1023];
								var val1;
								if(i2 >= 0) {
									var l1 = c1.codewordLengths[i2];
									_this4.acc = _this4.acc >>> l1;
									_this4.validBits -= l1;
									if(_this4.validBits < 0) {
										_this4.validBits = 0;
										val1 = -1;
									} else {
										val1 = i2;
									}
								} else {
									val1 = _this4.decodeScalarRaw(c1);
								}
								if(c1.sparse) {
									val1 = c1.sortedValues[val1];
								}
								tmp4 = val1;
							} else {
								tmp4 = 0;
							}
							fy[tmp3] = tmp4;
						}
					}
					if(this.decodeState.validBits == -1) {
						zeroChannel[i] = true;
						continue;
					}
					step2Flag[0] = step2Flag[1] = true;
					var naighbors = g.neighbors;
					var xlist = g.xlist;
					var _g31 = 2;
					var _g21 = g.values;
					while(_g31 < _g21) {
						var j1 = _g31++;
						var low = naighbors[j1][0];
						var high = naighbors[j1][1];
						var x0 = xlist[low];
						var y0 = fy[low];
						var dy = fy[high] - y0;
						var adx = xlist[high] - x0;
						var err = Math.abs(dy) * (xlist[j1] - x0);
						var off = err / adx | 0;
						var lowroom = dy < 0 ? y0 - off : y0 + off;
						var val2 = fy[j1];
						var highroom = range - lowroom;
						var room = highroom < lowroom ? highroom * 2 : lowroom * 2;
						if(val2 != 0) {
							step2Flag[low] = step2Flag[high] = true;
							step2Flag[j1] = true;
							if(val2 >= room) {
								if(highroom > lowroom) {
									fy[j1] = val2 - lowroom + lowroom;
								} else {
									fy[j1] = lowroom - val2 + highroom - 1;
								}
							} else if((val2 & 1) != 0) {
								fy[j1] = lowroom - (val2 + 1 >> 1);
							} else {
								fy[j1] = lowroom + (val2 >> 1);
							}
						} else {
							step2Flag[j1] = false;
							fy[j1] = lowroom;
						}
					}
					var _g32 = 0;
					var _g22 = g.values;
					while(_g32 < _g22) {
						var j2 = _g32++;
						if(!step2Flag[j2]) {
							fy[j2] = -1;
						}
					}
				} else {
					zeroChannel[i] = true;
				}
			}
		}
		var _g11 = 0;
		var _g6 = this.header.channel;
		while(_g11 < _g6) {
			var i3 = _g11++;
			reallyZeroChannel[i3] = zeroChannel[i3];
		}
		var _g12 = 0;
		var _g7 = map.couplingSteps;
		while(_g12 < _g7) {
			var i4 = _g12++;
			if(!zeroChannel[map.chan[i4].magnitude] || !zeroChannel[map.chan[i4].angle]) {
				zeroChannel[map.chan[i4].magnitude] = zeroChannel[map.chan[i4].angle] = false;
			}
		}
		var _g13 = 0;
		var _g8 = map.submaps;
		while(_g13 < _g8) {
			var i5 = _g13++;
			var length = this.header.channel;
			var this4 = new Array(length);
			var residueBuffers = this4;
			var this5 = new Array(256);
			var doNotDecode = this5;
			var ch = 0;
			var _g33 = 0;
			var _g23 = this.header.channel;
			while(_g33 < _g23) {
				var j3 = _g33++;
				if(map.chan[j3].mux == i5) {
					if(zeroChannel[j3]) {
						doNotDecode[ch] = true;
						residueBuffers[ch] = null;
					} else {
						doNotDecode[ch] = false;
						residueBuffers[ch] = this.channelBuffers[j3];
					}
					++ch;
				}
			}
			var r1 = map.submapResidue[i5];
			var residue = this.header.residueConfig[r1];
			residue.decode(this.decodeState,this.header,residueBuffers,ch,n2,doNotDecode,this.channelBuffers);
		}
		var i6 = map.couplingSteps;
		var n21 = n >> 1;
		while(--i6 >= 0) {
			var m1 = this.channelBuffers[map.chan[i6].magnitude];
			var a = this.channelBuffers[map.chan[i6].angle];
			var _g14 = 0;
			var _g9 = n21;
			while(_g14 < _g9) {
				var j4 = _g14++;
				var a2;
				var m2;
				if(m1[j4] > 0) {
					if(a[j4] > 0) {
						m2 = m1[j4];
						a2 = m1[j4] - a[j4];
					} else {
						a2 = m1[j4];
						m2 = m1[j4] + a[j4];
					}
				} else if(a[j4] > 0) {
					m2 = m1[j4];
					a2 = m1[j4] + a[j4];
				} else {
					a2 = m1[j4];
					m2 = m1[j4] - a[j4];
				}
				m1[j4] = m2;
				a[j4] = a2;
			}
		}
		var _g15 = 0;
		var _g10 = this.header.channel;
		while(_g15 < _g10) {
			var i7 = _g15++;
			if(reallyZeroChannel[i7]) {
				var _g34 = 0;
				var _g24 = n21;
				while(_g34 < _g24) {
					var j5 = _g34++;
					this.channelBuffers[i7][j5] = 0;
				}
			} else {
				map.doFloor(this.header.floorConfig,i7,n,this.channelBuffers[i7],this.finalY[i7],null);
			}
		}
		var _g16 = 0;
		var _g17 = this.header.channel;
		while(_g16 < _g17) {
			var i8 = _g16++;
			this.inverseMdct(this.channelBuffers[i8],n,m.blockflag);
		}
		var _this5 = this.decodeState;
		while(_this5.bytesInSeg != 0 || !_this5.lastSeg && _this5.next() != 0) {
			_this5.bytesInSeg--;
			_this5.inputPosition += 1;
			_this5.input.readByte();
		}
		return this.decodeState.finishDecodePacket(this.previousLength,n,r);
	}
	,__class__: kha_audio2_ogg_vorbis_VorbisDecoder
};
var kha_audio2_ogg_vorbis_VorbisTools = function() { };
$hxClasses["kha.audio2.ogg.vorbis.VorbisTools"] = kha_audio2_ogg_vorbis_VorbisTools;
kha_audio2_ogg_vorbis_VorbisTools.__name__ = true;
kha_audio2_ogg_vorbis_VorbisTools.assert = function(b,p) {
};
kha_audio2_ogg_vorbis_VorbisTools.neighbors = function(x,n) {
	var low = -1;
	var high = 65536;
	var plow = 0;
	var phigh = 0;
	var _g1 = 0;
	var _g = n;
	while(_g1 < _g) {
		var i = _g1++;
		if(x[i] > low && x[i] < x[n]) {
			plow = i;
			low = x[i];
		}
		if(x[i] < high && x[i] > x[n]) {
			phigh = i;
			high = x[i];
		}
	}
	return { low : plow, high : phigh};
};
kha_audio2_ogg_vorbis_VorbisTools.floatUnpack = function(x) {
	var mantissa = _$UInt_UInt_$Impl_$.toFloat(x & 2097151);
	var sign = x & -2147483648;
	var exp = (x & 2145386496) >>> 21;
	var res = sign != 0 ? -mantissa : mantissa;
	return res * Math.pow(2,exp - 788);
};
kha_audio2_ogg_vorbis_VorbisTools.bitReverse = function(n) {
	n = (n & -1431655766) >>> 1 | (n & 1431655765) << 1;
	n = (n & -858993460) >>> 2 | (n & 858993459) << 2;
	n = (n & -252645136) >>> 4 | (n & 252645135) << 4;
	n = (n & -16711936) >>> 8 | (n & 16711935) << 8;
	return n >>> 16 | n << 16;
};
kha_audio2_ogg_vorbis_VorbisTools.pointCompare = function(a,b) {
	if(a.x < b.x) {
		return -1;
	} else if(a.x > b.x) {
		return 1;
	} else {
		return 0;
	}
};
kha_audio2_ogg_vorbis_VorbisTools.uintAsc = function(a,b) {
	if(_$UInt_UInt_$Impl_$.gt(b,a)) {
		return -1;
	} else if(a == b) {
		return 0;
	} else {
		return 1;
	}
};
kha_audio2_ogg_vorbis_VorbisTools.lookup1Values = function(entries,dim) {
	var r = Math.exp(Math.log(entries) / dim) | 0;
	if((Math.pow(r + 1,dim) | 0) <= entries) {
		++r;
	}
	var b = Math.pow(r + 1,dim) > entries;
	var b1 = (Math.pow(r,dim) | 0) <= entries;
	return r;
};
kha_audio2_ogg_vorbis_VorbisTools.computeWindow = function(n,window) {
	var n2 = n >> 1;
	var _g1 = 0;
	var _g = n2;
	while(_g1 < _g) {
		var i = _g1++;
		window[i] = Math.sin(1.57079632679489656 * kha_audio2_ogg_vorbis_VorbisTools.square(Math.sin((i + 0.5) / n2 * 0.5 * 3.14159265358979323846264)));
	}
};
kha_audio2_ogg_vorbis_VorbisTools.square = function(f) {
	return f * f;
};
kha_audio2_ogg_vorbis_VorbisTools.computeBitReverse = function(n,rev) {
	var log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
	var ld = (n < 16384 ? n < 16 ? log2_4[n] : n < 512 ? 5 + log2_4[n >> 5] : 10 + log2_4[n >> 10] : n < 16777216 ? n < 524288 ? 15 + log2_4[n >> 15] : 20 + log2_4[n >> 20] : n < 536870912 ? 25 + log2_4[n >> 25] : n < -2147483648 ? 30 + log2_4[n >> 30] : 0) - 1;
	var n8 = n >> 3;
	var _g1 = 0;
	var _g = n8;
	while(_g1 < _g) {
		var i = _g1++;
		var n1 = i;
		n1 = (n1 & -1431655766) >>> 1 | (n1 & 1431655765) << 1;
		n1 = (n1 & -858993460) >>> 2 | (n1 & 858993459) << 2;
		n1 = (n1 & -252645136) >>> 4 | (n1 & 252645135) << 4;
		n1 = (n1 & -16711936) >>> 8 | (n1 & 16711935) << 8;
		rev[i] = (n1 >>> 16 | n1 << 16) >>> 32 - ld + 3 << 2;
	}
};
kha_audio2_ogg_vorbis_VorbisTools.computeTwiddleFactors = function(n,af,bf,cf) {
	var n4 = n >> 2;
	var n8 = n >> 3;
	var k2 = 0;
	var _g1 = 0;
	var _g = n4;
	while(_g1 < _g) {
		var k = _g1++;
		af[k2] = Math.cos(4 * k * 3.14159265358979323846264 / n);
		af[k2 + 1] = -Math.sin(4 * k * 3.14159265358979323846264 / n);
		bf[k2] = Math.cos((k2 + 1) * 3.14159265358979323846264 / n / 2) * 0.5;
		bf[k2 + 1] = Math.sin((k2 + 1) * 3.14159265358979323846264 / n / 2) * 0.5;
		k2 += 2;
	}
	var k21 = 0;
	var _g11 = 0;
	var _g2 = n8;
	while(_g11 < _g2) {
		var k1 = _g11++;
		cf[k21] = Math.cos(2 * (k21 + 1) * 3.14159265358979323846264 / n);
		cf[k21 + 1] = -Math.sin(2 * (k21 + 1) * 3.14159265358979323846264 / n);
		k21 += 2;
	}
};
kha_audio2_ogg_vorbis_VorbisTools.drawLine = function(output,x0,y0,x1,y1,n) {
	if(kha_audio2_ogg_vorbis_VorbisTools.integerDivideTable == null) {
		var this1 = new Array(32);
		kha_audio2_ogg_vorbis_VorbisTools.integerDivideTable = this1;
		var _g = 0;
		while(_g < 32) {
			var i = _g++;
			var this2 = kha_audio2_ogg_vorbis_VorbisTools.integerDivideTable;
			var this3 = new Array(64);
			this2[i] = this3;
			var _g1 = 1;
			while(_g1 < 64) {
				var j = _g1++;
				kha_audio2_ogg_vorbis_VorbisTools.integerDivideTable[i][j] = i / j | 0;
			}
		}
	}
	var dy = y1 - y0;
	var adx = x1 - x0;
	var ady = dy < 0 ? -dy : dy;
	var base;
	var x = x0;
	var y = y0;
	var err = 0;
	var sy;
	if(adx < 64 && ady < 32) {
		if(dy < 0) {
			base = -kha_audio2_ogg_vorbis_VorbisTools.integerDivideTable[ady][adx];
			sy = base - 1;
		} else {
			base = kha_audio2_ogg_vorbis_VorbisTools.integerDivideTable[ady][adx];
			sy = base + 1;
		}
	} else {
		base = dy / adx | 0;
		if(dy < 0) {
			sy = base - 1;
		} else {
			sy = base + 1;
		}
	}
	ady -= (base < 0 ? -base : base) * adx;
	if(x1 > n) {
		x1 = n;
	}
	var _g2 = x;
	var _g11 = output;
	_g11[_g2] = _g11[_g2] * kha_audio2_ogg_vorbis_VorbisTools.INVERSE_DB_TABLE[y];
	var _g12 = x + 1;
	var _g3 = x1;
	while(_g12 < _g3) {
		var i1 = _g12++;
		err += ady;
		if(err >= adx) {
			err -= adx;
			y += sy;
		} else {
			y += base;
		}
		var _g21 = i1;
		var _g31 = output;
		_g31[_g21] = _g31[_g21] * kha_audio2_ogg_vorbis_VorbisTools.INVERSE_DB_TABLE[y];
	}
};
kha_audio2_ogg_vorbis_VorbisTools.predictPoint = function(x,x0,x1,y0,y1) {
	var dy = y1 - y0;
	var adx = x1 - x0;
	var err = Math.abs(dy) * (x - x0);
	var off = err / adx | 0;
	if(dy < 0) {
		return y0 - off;
	} else {
		return y0 + off;
	}
};
kha_audio2_ogg_vorbis_VorbisTools.emptyFloatVector = function(len) {
	var this1 = new Array(len);
	var vec = this1;
	return vec;
};
kha_audio2_ogg_vorbis_VorbisTools.copyVector = function(source) {
	var length = source.length;
	var this1 = new Array(length);
	var dest = this1;
	var _g1 = 0;
	var _g = source.length;
	while(_g1 < _g) {
		var i = _g1++;
		dest[i] = source[i];
	}
	return dest;
};
var kha_audio2_ogg_vorbis_data_Codebook = function() {
};
$hxClasses["kha.audio2.ogg.vorbis.data.Codebook"] = kha_audio2_ogg_vorbis_data_Codebook;
kha_audio2_ogg_vorbis_data_Codebook.__name__ = true;
kha_audio2_ogg_vorbis_data_Codebook.read = function(decodeState) {
	var c = new kha_audio2_ogg_vorbis_data_Codebook();
	var tmp;
	var tmp1;
	var tmp2;
	if(decodeState.validBits < 0) {
		tmp2 = 0;
	} else if(decodeState.validBits < 8) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 8)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp2 = 0;
		} else {
			var z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp2 = z;
		}
	} else {
		var z1 = decodeState.acc & 255;
		decodeState.acc = decodeState.acc >>> 8;
		decodeState.validBits -= 8;
		tmp2 = z1;
	}
	if(tmp2 == 66) {
		var tmp3;
		if(decodeState.validBits < 0) {
			tmp3 = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 8)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp3 = 0;
			} else {
				var z2 = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp3 = z2;
			}
		} else {
			var z3 = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp3 = z3;
		}
		tmp1 = tmp3 != 67;
	} else {
		tmp1 = true;
	}
	if(!tmp1) {
		var tmp4;
		if(decodeState.validBits < 0) {
			tmp4 = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 8)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp4 = 0;
			} else {
				var z4 = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp4 = z4;
			}
		} else {
			var z5 = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp4 = z5;
		}
		tmp = tmp4 != 86;
	} else {
		tmp = true;
	}
	if(tmp) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Codebook.hx", lineNumber : 40, className : "kha.audio2.ogg.vorbis.data.Codebook", methodName : "read"}));
	}
	var x;
	if(decodeState.validBits < 0) {
		x = 0;
	} else if(decodeState.validBits < 8) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 8)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			x = 0;
		} else {
			var z6 = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			x = z6;
		}
	} else {
		var z7 = decodeState.acc & 255;
		decodeState.acc = decodeState.acc >>> 8;
		decodeState.validBits -= 8;
		x = z7;
	}
	var tmp5;
	if(decodeState.validBits < 0) {
		tmp5 = 0;
	} else if(decodeState.validBits < 8) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 8)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp5 = 0;
		} else {
			var z8 = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp5 = z8;
		}
	} else {
		var z9 = decodeState.acc & 255;
		decodeState.acc = decodeState.acc >>> 8;
		decodeState.validBits -= 8;
		tmp5 = z9;
	}
	c.dimensions = (tmp5 << 8) + x;
	var x1;
	if(decodeState.validBits < 0) {
		x1 = 0;
	} else if(decodeState.validBits < 8) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 8)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			x1 = 0;
		} else {
			var z10 = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			x1 = z10;
		}
	} else {
		var z11 = decodeState.acc & 255;
		decodeState.acc = decodeState.acc >>> 8;
		decodeState.validBits -= 8;
		x1 = z11;
	}
	var y;
	if(decodeState.validBits < 0) {
		y = 0;
	} else if(decodeState.validBits < 8) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 8)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			y = 0;
		} else {
			var z12 = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			y = z12;
		}
	} else {
		var z13 = decodeState.acc & 255;
		decodeState.acc = decodeState.acc >>> 8;
		decodeState.validBits -= 8;
		y = z13;
	}
	var tmp6;
	if(decodeState.validBits < 0) {
		tmp6 = 0;
	} else if(decodeState.validBits < 8) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 8)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp6 = 0;
		} else {
			var z14 = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp6 = z14;
		}
	} else {
		var z15 = decodeState.acc & 255;
		decodeState.acc = decodeState.acc >>> 8;
		decodeState.validBits -= 8;
		tmp6 = z15;
	}
	c.entries = (tmp6 << 16) + (y << 8) + x1;
	var ordered;
	if(decodeState.validBits < 0) {
		ordered = 0;
	} else if(decodeState.validBits < 1) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 1)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			ordered = 0;
		} else {
			var z16 = decodeState.acc & 1;
			decodeState.acc = decodeState.acc >>> 1;
			decodeState.validBits -= 1;
			ordered = z16;
		}
	} else {
		var z17 = decodeState.acc & 1;
		decodeState.acc = decodeState.acc >>> 1;
		decodeState.validBits -= 1;
		ordered = z17;
	}
	var tmp7;
	if(ordered != 0) {
		tmp7 = false;
	} else {
		var tmp8;
		if(decodeState.validBits < 0) {
			tmp8 = 0;
		} else if(decodeState.validBits < 1) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 1)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp8 = 0;
			} else {
				var z18 = decodeState.acc & 1;
				decodeState.acc = decodeState.acc >>> 1;
				decodeState.validBits -= 1;
				tmp8 = z18;
			}
		} else {
			var z19 = decodeState.acc & 1;
			decodeState.acc = decodeState.acc >>> 1;
			decodeState.validBits -= 1;
			tmp8 = z19;
		}
		tmp7 = tmp8 != 0;
	}
	c.sparse = tmp7;
	var length = c.entries;
	var this1 = new Array(length);
	var lengths = this1;
	if(!c.sparse) {
		c.codewordLengths = lengths;
	}
	var total = 0;
	if(ordered != 0) {
		var currentEntry = 0;
		var currentLength;
		if(decodeState.validBits < 0) {
			currentLength = 0;
		} else if(decodeState.validBits < 5) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 5)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				currentLength = 0;
			} else {
				var z20 = decodeState.acc & 31;
				decodeState.acc = decodeState.acc >>> 5;
				decodeState.validBits -= 5;
				currentLength = z20;
			}
		} else {
			var z21 = decodeState.acc & 31;
			decodeState.acc = decodeState.acc >>> 5;
			decodeState.validBits -= 5;
			currentLength = z21;
		}
		var currentLength1 = currentLength + 1;
		while(currentEntry < c.entries) {
			var limit = c.entries - currentEntry;
			var log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
			var n = limit < 16384 ? limit < 16 ? log2_4[limit] : limit < 512 ? 5 + log2_4[limit >> 5] : 10 + log2_4[limit >> 10] : limit < 16777216 ? limit < 524288 ? 15 + log2_4[limit >> 15] : 20 + log2_4[limit >> 20] : limit < 536870912 ? 25 + log2_4[limit >> 25] : limit < -2147483648 ? 30 + log2_4[limit >> 30] : 0;
			var n1;
			if(decodeState.validBits < 0) {
				n1 = 0;
			} else if(decodeState.validBits < n) {
				if(n > 24) {
					n1 = decodeState.readBits(24) + (decodeState.readBits(n - 24) << 24);
				} else {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					while(true) {
						if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						}
						if(!(decodeState.validBits < n)) {
							break;
						}
					}
					if(decodeState.validBits < 0) {
						n1 = 0;
					} else {
						var z22 = decodeState.acc & (1 << n) - 1;
						decodeState.acc = decodeState.acc >>> n;
						decodeState.validBits -= n;
						n1 = z22;
					}
				}
			} else {
				var z23 = decodeState.acc & (1 << n) - 1;
				decodeState.acc = decodeState.acc >>> n;
				decodeState.validBits -= n;
				n1 = z23;
			}
			if(currentEntry + n1 > c.entries) {
				throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,"codebook entrys",{ fileName : "Codebook.hx", lineNumber : 67, className : "kha.audio2.ogg.vorbis.data.Codebook", methodName : "read"}));
			}
			var _g1 = 0;
			var _g = n1;
			while(_g1 < _g) {
				var i = _g1++;
				lengths[currentEntry + i] = currentLength1;
			}
			currentEntry += n1;
			++currentLength1;
		}
	} else {
		var _g11 = 0;
		var _g2 = c.entries;
		while(_g11 < _g2) {
			var j = _g11++;
			var present;
			if(c.sparse) {
				if(decodeState.validBits < 0) {
					present = 0;
				} else if(decodeState.validBits < 1) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					while(true) {
						if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						}
						if(!(decodeState.validBits < 1)) {
							break;
						}
					}
					if(decodeState.validBits < 0) {
						present = 0;
					} else {
						var z24 = decodeState.acc & 1;
						decodeState.acc = decodeState.acc >>> 1;
						decodeState.validBits -= 1;
						present = z24;
					}
				} else {
					var z25 = decodeState.acc & 1;
					decodeState.acc = decodeState.acc >>> 1;
					decodeState.validBits -= 1;
					present = z25;
				}
			} else {
				present = 1;
			}
			if(present != 0) {
				var val;
				if(decodeState.validBits < 0) {
					val = 0;
				} else if(decodeState.validBits < 5) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					while(true) {
						if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						}
						if(!(decodeState.validBits < 5)) {
							break;
						}
					}
					if(decodeState.validBits < 0) {
						val = 0;
					} else {
						var z26 = decodeState.acc & 31;
						decodeState.acc = decodeState.acc >>> 5;
						decodeState.validBits -= 5;
						val = z26;
					}
				} else {
					var z27 = decodeState.acc & 31;
					decodeState.acc = decodeState.acc >>> 5;
					decodeState.validBits -= 5;
					val = z27;
				}
				lengths[j] = val + 1;
				++total;
			} else {
				lengths[j] = 255;
			}
		}
	}
	if(c.sparse && total >= c.entries >> 2) {
		c.codewordLengths = lengths;
		c.sparse = false;
	}
	var tmp9;
	if(c.sparse) {
		tmp9 = total;
	} else {
		var sortedCount = 0;
		var _g12 = 0;
		var _g3 = c.entries;
		while(_g12 < _g3) {
			var j1 = _g12++;
			var l = lengths[j1];
			if(l > 10 && l != 255) {
				++sortedCount;
			}
		}
		tmp9 = sortedCount;
	}
	c.sortedEntries = tmp9;
	var values = null;
	if(!c.sparse) {
		var length1 = c.entries;
		var this2 = new Array(length1);
		c.codewords = this2;
	} else {
		if(c.sortedEntries != 0) {
			var length2 = c.sortedEntries;
			var this3 = new Array(length2);
			c.codewordLengths = this3;
			var length3 = c.entries;
			var this4 = new Array(length3);
			c.codewords = this4;
			var length4 = c.entries;
			var this5 = new Array(length4);
			values = this5;
		}
		var size = c.entries + 64 * c.sortedEntries;
	}
	if(!c.computeCodewords(lengths,c.entries,values)) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,"compute codewords",{ fileName : "Codebook.hx", lineNumber : 120, className : "kha.audio2.ogg.vorbis.data.Codebook", methodName : "read"}));
	}
	if(c.sortedEntries != 0) {
		c.sortedCodewords = [];
		var length5 = c.sortedEntries;
		var this6 = new Array(length5);
		c.sortedValues = this6;
		c.computeSortedHuffman(lengths,values);
	}
	if(c.sparse) {
		values = null;
		c.codewords = null;
		lengths = null;
	}
	c.computeAcceleratedHuffman();
	var tmp10;
	if(decodeState.validBits < 0) {
		tmp10 = 0;
	} else if(decodeState.validBits < 4) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 4)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp10 = 0;
		} else {
			var z28 = decodeState.acc & 15;
			decodeState.acc = decodeState.acc >>> 4;
			decodeState.validBits -= 4;
			tmp10 = z28;
		}
	} else {
		var z29 = decodeState.acc & 15;
		decodeState.acc = decodeState.acc >>> 4;
		decodeState.validBits -= 4;
		tmp10 = z29;
	}
	c.lookupType = tmp10;
	if(c.lookupType > 2) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,"codebook lookup type",{ fileName : "Codebook.hx", lineNumber : 143, className : "kha.audio2.ogg.vorbis.data.Codebook", methodName : "read"}));
	}
	if(c.lookupType > 0) {
		var x2;
		if(decodeState.validBits < 0) {
			x2 = 0;
		} else if(decodeState.validBits < 32) {
			x2 = decodeState.readBits(24) + (decodeState.readBits(8) << 24);
		} else {
			var z30 = decodeState.acc & -1;
			decodeState.acc = decodeState.acc >>> 32;
			decodeState.validBits -= 32;
			x2 = z30;
		}
		var mantissa = _$UInt_UInt_$Impl_$.toFloat(x2 & 2097151);
		var sign = x2 & -2147483648;
		var exp = (x2 & 2145386496) >>> 21;
		var res = sign != 0 ? -mantissa : mantissa;
		c.minimumValue = res * Math.pow(2,exp - 788);
		var x3;
		if(decodeState.validBits < 0) {
			x3 = 0;
		} else if(decodeState.validBits < 32) {
			x3 = decodeState.readBits(24) + (decodeState.readBits(8) << 24);
		} else {
			var z31 = decodeState.acc & -1;
			decodeState.acc = decodeState.acc >>> 32;
			decodeState.validBits -= 32;
			x3 = z31;
		}
		var mantissa1 = _$UInt_UInt_$Impl_$.toFloat(x3 & 2097151);
		var sign1 = x3 & -2147483648;
		var exp1 = (x3 & 2145386496) >>> 21;
		var res1 = sign1 != 0 ? -mantissa1 : mantissa1;
		c.deltaValue = res1 * Math.pow(2,exp1 - 788);
		var tmp11;
		if(decodeState.validBits < 0) {
			tmp11 = 0;
		} else if(decodeState.validBits < 4) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 4)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp11 = 0;
			} else {
				var z32 = decodeState.acc & 15;
				decodeState.acc = decodeState.acc >>> 4;
				decodeState.validBits -= 4;
				tmp11 = z32;
			}
		} else {
			var z33 = decodeState.acc & 15;
			decodeState.acc = decodeState.acc >>> 4;
			decodeState.validBits -= 4;
			tmp11 = z33;
		}
		c.valueBits = tmp11 + 1;
		var tmp12;
		if(decodeState.validBits < 0) {
			tmp12 = 0;
		} else if(decodeState.validBits < 1) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 1)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp12 = 0;
			} else {
				var z34 = decodeState.acc & 1;
				decodeState.acc = decodeState.acc >>> 1;
				decodeState.validBits -= 1;
				tmp12 = z34;
			}
		} else {
			var z35 = decodeState.acc & 1;
			decodeState.acc = decodeState.acc >>> 1;
			decodeState.validBits -= 1;
			tmp12 = z35;
		}
		c.sequenceP = tmp12 != 0;
		if(c.lookupType == 1) {
			c.lookupValues = kha_audio2_ogg_vorbis_VorbisTools.lookup1Values(c.entries,c.dimensions);
		} else {
			c.lookupValues = c.entries * c.dimensions;
		}
		var length6 = c.lookupValues;
		var this7 = new Array(length6);
		var mults = this7;
		var _g13 = 0;
		var _g4 = c.lookupValues;
		while(_g13 < _g4) {
			var j2 = _g13++;
			var n2 = c.valueBits;
			var q;
			if(decodeState.validBits < 0) {
				q = 0;
			} else if(decodeState.validBits < n2) {
				if(n2 > 24) {
					q = decodeState.readBits(24) + (decodeState.readBits(n2 - 24) << 24);
				} else {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					while(true) {
						if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						}
						if(!(decodeState.validBits < n2)) {
							break;
						}
					}
					if(decodeState.validBits < 0) {
						q = 0;
					} else {
						var z36 = decodeState.acc & (1 << n2) - 1;
						decodeState.acc = decodeState.acc >>> n2;
						decodeState.validBits -= n2;
						q = z36;
					}
				}
			} else {
				var z37 = decodeState.acc & (1 << n2) - 1;
				decodeState.acc = decodeState.acc >>> n2;
				decodeState.validBits -= n2;
				q = z37;
			}
			if(q == -1) {
				throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,"fail lookup",{ fileName : "Codebook.hx", lineNumber : 161, className : "kha.audio2.ogg.vorbis.data.Codebook", methodName : "read"}));
			}
			mults[j2] = q;
		}
		var length7 = c.lookupValues;
		var this8 = new Array(length7);
		c.multiplicands = this8;
		var _g14 = 0;
		var _g5 = c.lookupValues;
		while(_g14 < _g5) {
			var j3 = _g14++;
			c.multiplicands[j3] = mults[j3] * c.deltaValue + c.minimumValue;
		}
		if(c.lookupType == 2 && c.sequenceP) {
			var _g15 = 1;
			var _g6 = c.lookupValues;
			while(_g15 < _g6) {
				var j4 = _g15++;
				c.multiplicands[j4] = c.multiplicands[j4 - 1];
			}
			c.sequenceP = false;
		}
	}
	return c;
};
kha_audio2_ogg_vorbis_data_Codebook.prototype = {
	dimensions: null
	,entries: null
	,codewordLengths: null
	,minimumValue: null
	,deltaValue: null
	,valueBits: null
	,lookupType: null
	,sequenceP: null
	,sparse: null
	,lookupValues: null
	,multiplicands: null
	,codewords: null
	,fastHuffman: null
	,sortedCodewords: null
	,sortedValues: null
	,sortedEntries: null
	,addEntry: function(huffCode,symbol,count,len,values) {
		if(!this.sparse) {
			this.codewords[symbol] = huffCode;
		} else {
			this.codewords[count] = huffCode;
			this.codewordLengths[count] = len;
			values[count] = symbol;
		}
	}
	,includeInSort: function(len) {
		if(this.sparse) {
			return true;
		} else if(len == 255) {
			return false;
		} else if(len > 10) {
			return true;
		} else {
			return false;
		}
	}
	,computeCodewords: function(len,n,values) {
		var this1 = new Array(32);
		var available = this1;
		var _g = 0;
		while(_g < 32) {
			var x = _g++;
			available[x] = 0;
		}
		var k = 0;
		while(k < n) {
			if(len[k] < 255) {
				break;
			}
			++k;
		}
		if(k == n) {
			var b = this.sortedEntries == 0;
			return true;
		}
		var m = 0;
		var count = m++;
		if(!this.sparse) {
			this.codewords[k] = 0;
		} else {
			this.codewords[count] = 0;
			this.codewordLengths[count] = len[k];
			values[count] = k;
		}
		var i = 0;
		while(++i <= len[k]) available[i] = 1 << 32 - i;
		i = k;
		while(++i < n) {
			var z = len[i];
			if(z == 255) {
				continue;
			}
			while(z > 0 && available[z] == 0) --z;
			if(z == 0) {
				return false;
			}
			var res = available[z];
			available[z] = 0;
			var n1 = res;
			n1 = (n1 & -1431655766) >>> 1 | (n1 & 1431655765) << 1;
			n1 = (n1 & -858993460) >>> 2 | (n1 & 858993459) << 2;
			n1 = (n1 & -252645136) >>> 4 | (n1 & 252645135) << 4;
			n1 = (n1 & -16711936) >>> 8 | (n1 & 16711935) << 8;
			var huffCode = n1 >>> 16 | n1 << 16;
			var count1 = m++;
			if(!this.sparse) {
				this.codewords[i] = huffCode;
			} else {
				this.codewords[count1] = huffCode;
				this.codewordLengths[count1] = len[i];
				values[count1] = i;
			}
			if(z != len[i]) {
				var y = len[i];
				while(y > z) {
					available[y] = res + (1 << 32 - y);
					--y;
				}
			}
		}
		return true;
	}
	,computeSortedHuffman: function(lengths,values) {
		if(!this.sparse) {
			var k = 0;
			var _g1 = 0;
			var _g = this.entries;
			while(_g1 < _g) {
				var i = _g1++;
				var len = lengths[i];
				if(this.sparse ? true : len == 255 ? false : len > 10) {
					var n = this.codewords[i];
					n = (n & -1431655766) >>> 1 | (n & 1431655765) << 1;
					n = (n & -858993460) >>> 2 | (n & 858993459) << 2;
					n = (n & -252645136) >>> 4 | (n & 252645135) << 4;
					n = (n & -16711936) >>> 8 | (n & 16711935) << 8;
					this.sortedCodewords[k++] = n >>> 16 | n << 16;
				}
			}
			var b = k == this.sortedEntries;
		} else {
			var _g11 = 0;
			var _g2 = this.sortedEntries;
			while(_g11 < _g2) {
				var i1 = _g11++;
				var n1 = this.codewords[i1];
				n1 = (n1 & -1431655766) >>> 1 | (n1 & 1431655765) << 1;
				n1 = (n1 & -858993460) >>> 2 | (n1 & 858993459) << 2;
				n1 = (n1 & -252645136) >>> 4 | (n1 & 252645135) << 4;
				n1 = (n1 & -16711936) >>> 8 | (n1 & 16711935) << 8;
				this.sortedCodewords[i1] = n1 >>> 16 | n1 << 16;
			}
		}
		this.sortedCodewords[this.sortedEntries] = -1;
		this.sortedCodewords.sort(kha_audio2_ogg_vorbis_VorbisTools.uintAsc);
		var len1 = this.sparse ? this.sortedEntries : this.entries;
		var _g12 = 0;
		var _g3 = len1;
		while(_g12 < _g3) {
			var i2 = _g12++;
			var huffLen = this.sparse ? lengths[values[i2]] : lengths[i2];
			if(this.sparse ? true : huffLen == 255 ? false : huffLen > 10) {
				var n2 = this.codewords[i2];
				n2 = (n2 & -1431655766) >>> 1 | (n2 & 1431655765) << 1;
				n2 = (n2 & -858993460) >>> 2 | (n2 & 858993459) << 2;
				n2 = (n2 & -252645136) >>> 4 | (n2 & 252645135) << 4;
				n2 = (n2 & -16711936) >>> 8 | (n2 & 16711935) << 8;
				var code = n2 >>> 16 | n2 << 16;
				var x = 0;
				var n3 = this.sortedEntries;
				while(n3 > 1) {
					var m = x + (n3 >> 1);
					if(_$UInt_UInt_$Impl_$.gte(code,this.sortedCodewords[m])) {
						x = m;
						n3 -= n3 >> 1;
					} else {
						n3 >>= 1;
					}
				}
				if(this.sparse) {
					this.sortedValues[x] = values[i2];
					this.codewordLengths[x] = huffLen;
				} else {
					this.sortedValues[x] = i2;
				}
			}
		}
	}
	,computeAcceleratedHuffman: function() {
		var this1 = new Array(1024);
		this.fastHuffman = this1;
		this.fastHuffman[0] = -1;
		var _g1 = 0;
		var _g = 1024;
		while(_g1 < _g) {
			var i = _g1++;
			this.fastHuffman[i] = -1;
		}
		var len = this.sparse ? this.sortedEntries : this.entries;
		var _g11 = 0;
		var _g2 = len;
		while(_g11 < _g2) {
			var i1 = _g11++;
			if(this.codewordLengths[i1] <= 10) {
				var z;
				if(this.sparse) {
					var n = this.sortedCodewords[i1];
					n = (n & -1431655766) >>> 1 | (n & 1431655765) << 1;
					n = (n & -858993460) >>> 2 | (n & 858993459) << 2;
					n = (n & -252645136) >>> 4 | (n & 252645135) << 4;
					n = (n & -16711936) >>> 8 | (n & 16711935) << 8;
					z = n >>> 16 | n << 16;
				} else {
					z = this.codewords[i1];
				}
				while(z < 1024) {
					this.fastHuffman[z] = i1;
					z += 1 << this.codewordLengths[i1];
				}
			}
		}
	}
	,codebookDecode: function(decodeState,output,offset,len) {
		if(decodeState.validBits < 10) {
			decodeState.prepHuffman();
		}
		var i = this.fastHuffman[decodeState.acc & 1023];
		var val;
		if(i >= 0) {
			var l = this.codewordLengths[i];
			decodeState.acc = decodeState.acc >>> l;
			decodeState.validBits -= l;
			if(decodeState.validBits < 0) {
				decodeState.validBits = 0;
				val = -1;
			} else {
				val = i;
			}
		} else {
			val = decodeState.decodeScalarRaw(this);
		}
		if(this.sparse) {
			val = this.sortedValues[val];
		}
		var z = val;
		var lookupValues = this.lookupValues;
		var sequenceP = this.sequenceP;
		var multiplicands = this.multiplicands;
		var minimumValue = this.minimumValue;
		if(z < 0) {
			return false;
		}
		if(len > this.dimensions) {
			len = this.dimensions;
		}
		if(this.lookupType == 1) {
			var div = 1;
			var last = 0.0;
			var _g1 = 0;
			var _g = len;
			while(_g1 < _g) {
				var i1 = _g1++;
				var off = _$UInt_UInt_$Impl_$.toFloat(z / div | 0) % _$UInt_UInt_$Impl_$.toFloat(lookupValues) | 0;
				var val1 = multiplicands[off] + last;
				var _g2 = offset + i1;
				var _g3 = output;
				_g3[_g2] = _g3[_g2] + val1;
				if(sequenceP) {
					last = val1 + minimumValue;
				}
				div = div * lookupValues;
			}
			return true;
		}
		z *= this.dimensions;
		if(sequenceP) {
			var last1 = 0.0;
			var _g11 = 0;
			var _g4 = len;
			while(_g11 < _g4) {
				var i2 = _g11++;
				var val2 = multiplicands[z + i2] + last1;
				var _g21 = offset + i2;
				var _g31 = output;
				_g31[_g21] = _g31[_g21] + val2;
				last1 = val2 + minimumValue;
			}
		} else {
			var last2 = 0.0;
			var _g12 = 0;
			var _g5 = len;
			while(_g12 < _g5) {
				var i3 = _g12++;
				var _g22 = offset + i3;
				var _g32 = output;
				_g32[_g22] = _g32[_g22] + (multiplicands[z + i3] + last2);
			}
		}
		return true;
	}
	,codebookDecodeStep: function(decodeState,output,offset,len,step) {
		if(decodeState.validBits < 10) {
			decodeState.prepHuffman();
		}
		var i = this.fastHuffman[decodeState.acc & 1023];
		var val;
		if(i >= 0) {
			var l = this.codewordLengths[i];
			decodeState.acc = decodeState.acc >>> l;
			decodeState.validBits -= l;
			if(decodeState.validBits < 0) {
				decodeState.validBits = 0;
				val = -1;
			} else {
				val = i;
			}
		} else {
			val = decodeState.decodeScalarRaw(this);
		}
		if(this.sparse) {
			val = this.sortedValues[val];
		}
		var z = val;
		var last = 0.0;
		if(z < 0) {
			return false;
		}
		if(len > this.dimensions) {
			len = this.dimensions;
		}
		var lookupValues = this.lookupValues;
		var sequenceP = this.sequenceP;
		var multiplicands = this.multiplicands;
		if(this.lookupType == 1) {
			var div = 1;
			var _g1 = 0;
			var _g = len;
			while(_g1 < _g) {
				var i1 = _g1++;
				var off = _$UInt_UInt_$Impl_$.toFloat(z / div | 0) % _$UInt_UInt_$Impl_$.toFloat(lookupValues) | 0;
				var val1 = multiplicands[off] + last;
				var _g2 = offset + i1 * step;
				var _g3 = output;
				_g3[_g2] = _g3[_g2] + val1;
				if(sequenceP) {
					last = val1;
				}
				div = div * lookupValues;
			}
			return true;
		}
		z *= this.dimensions;
		var _g11 = 0;
		var _g4 = len;
		while(_g11 < _g4) {
			var i2 = _g11++;
			var val2 = multiplicands[z + i2] + last;
			var _g21 = offset + i2 * step;
			var _g31 = output;
			_g31[_g21] = _g31[_g21] + val2;
			if(sequenceP) {
				last = val2;
			}
		}
		return true;
	}
	,decodeStart: function(decodeState) {
		if(decodeState.validBits < 10) {
			decodeState.prepHuffman();
		}
		var i = this.fastHuffman[decodeState.acc & 1023];
		var val;
		if(i >= 0) {
			var l = this.codewordLengths[i];
			decodeState.acc = decodeState.acc >>> l;
			decodeState.validBits -= l;
			if(decodeState.validBits < 0) {
				decodeState.validBits = 0;
				val = -1;
			} else {
				val = i;
			}
		} else {
			val = decodeState.decodeScalarRaw(this);
		}
		if(this.sparse) {
			val = this.sortedValues[val];
		}
		return val;
	}
	,decodeDeinterleaveRepeat: function(decodeState,residueBuffers,ch,cInter,pInter,len,totalDecode) {
		var effective = this.dimensions;
		if(this.lookupType == 0) {
			throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_STREAM,null,{ fileName : "Codebook.hx", lineNumber : 488, className : "kha.audio2.ogg.vorbis.data.Codebook", methodName : "decodeDeinterleaveRepeat"}));
		}
		var multiplicands = this.multiplicands;
		var sequenceP = this.sequenceP;
		var lookupValues = this.lookupValues;
		while(totalDecode > 0) {
			var last = 0.0;
			if(decodeState.validBits < 10) {
				decodeState.prepHuffman();
			}
			var i = this.fastHuffman[decodeState.acc & 1023];
			var val;
			if(i >= 0) {
				var l = this.codewordLengths[i];
				decodeState.acc = decodeState.acc >>> l;
				decodeState.validBits -= l;
				if(decodeState.validBits < 0) {
					decodeState.validBits = 0;
					val = -1;
				} else {
					val = i;
				}
			} else {
				val = decodeState.decodeScalarRaw(this);
			}
			if(this.sparse) {
				val = this.sortedValues[val];
			}
			var z = val;
			if(z < 0) {
				if(decodeState.bytesInSeg == 0 && decodeState.lastSeg) {
					return null;
				}
				throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_STREAM,null,{ fileName : "Codebook.hx", lineNumber : 503, className : "kha.audio2.ogg.vorbis.data.Codebook", methodName : "decodeDeinterleaveRepeat"}));
			}
			if(cInter + pInter * ch + effective > len * ch) {
				effective = len * ch - (pInter * ch - cInter);
			}
			if(this.lookupType == 1) {
				var div = 1;
				if(sequenceP) {
					var _g1 = 0;
					var _g = effective;
					while(_g1 < _g) {
						var i1 = _g1++;
						var off = _$UInt_UInt_$Impl_$.toFloat(z / div | 0) % _$UInt_UInt_$Impl_$.toFloat(lookupValues) | 0;
						var val1 = multiplicands[off] + last;
						var _g2 = pInter;
						var _g3 = residueBuffers[cInter];
						_g3[_g2] = _g3[_g2] + val1;
						if(++cInter == ch) {
							cInter = 0;
							++pInter;
						}
						last = val1;
						div = div * lookupValues;
					}
				} else {
					var _g11 = 0;
					var _g4 = effective;
					while(_g11 < _g4) {
						var i2 = _g11++;
						var off1 = _$UInt_UInt_$Impl_$.toFloat(z / div | 0) % _$UInt_UInt_$Impl_$.toFloat(lookupValues) | 0;
						var val2 = multiplicands[off1] + last;
						var _g21 = pInter;
						var _g31 = residueBuffers[cInter];
						_g31[_g21] = _g31[_g21] + val2;
						if(++cInter == ch) {
							cInter = 0;
							++pInter;
						}
						div = div * lookupValues;
					}
				}
			} else {
				z *= this.dimensions;
				if(sequenceP) {
					var _g12 = 0;
					var _g5 = effective;
					while(_g12 < _g5) {
						var i3 = _g12++;
						var val3 = multiplicands[z + i3] + last;
						var _g22 = pInter;
						var _g32 = residueBuffers[cInter];
						_g32[_g22] = _g32[_g22] + val3;
						if(++cInter == ch) {
							cInter = 0;
							++pInter;
						}
						last = val3;
					}
				} else {
					var _g13 = 0;
					var _g6 = effective;
					while(_g13 < _g6) {
						var i4 = _g13++;
						var val4 = multiplicands[z + i4] + last;
						var _g23 = pInter;
						var _g33 = residueBuffers[cInter];
						_g33[_g23] = _g33[_g23] + val4;
						if(++cInter == ch) {
							cInter = 0;
							++pInter;
						}
					}
				}
			}
			totalDecode -= effective;
		}
		return { cInter : cInter, pInter : pInter};
	}
	,residueDecode: function(decodeState,target,offset,n,rtype) {
		if(rtype == 0) {
			var step = n / this.dimensions | 0;
			var _g1 = 0;
			var _g = step;
			while(_g1 < _g) {
				var k = _g1++;
				if(!this.codebookDecodeStep(decodeState,target,offset + k,n - offset - k,step)) {
					return false;
				}
			}
		} else {
			var k1 = 0;
			while(k1 < n) {
				if(!this.codebookDecode(decodeState,target,offset,n - k1)) {
					return false;
				}
				k1 += this.dimensions;
				offset += this.dimensions;
			}
		}
		return true;
	}
	,__class__: kha_audio2_ogg_vorbis_data_Codebook
};
var kha_audio2_ogg_vorbis_data_Comment = function() {
	this.data = new haxe_ds_StringMap();
};
$hxClasses["kha.audio2.ogg.vorbis.data.Comment"] = kha_audio2_ogg_vorbis_data_Comment;
kha_audio2_ogg_vorbis_data_Comment.__name__ = true;
kha_audio2_ogg_vorbis_data_Comment.prototype = {
	data: null
	,get_title: function() {
		return this.getString("title");
	}
	,get_loopStart: function() {
		return Std.parseInt(this.getString("loopstart"));
	}
	,get_loopLength: function() {
		return Std.parseInt(this.getString("looplength"));
	}
	,get_version: function() {
		return this.getString("version");
	}
	,get_album: function() {
		return this.getString("album");
	}
	,get_organization: function() {
		return this.getString("organization");
	}
	,get_tracknumber: function() {
		return this.getString("tracknumber");
	}
	,get_performer: function() {
		return this.getString("performer");
	}
	,get_copyright: function() {
		return this.getString("copyright");
	}
	,get_license: function() {
		return this.getString("license");
	}
	,get_artist: function() {
		return this.getString("artist");
	}
	,get_description: function() {
		return this.getString("description");
	}
	,get_genre: function() {
		return this.getString("genre");
	}
	,get_date: function() {
		return this.getString("date");
	}
	,get_location: function() {
		return this.getString("location");
	}
	,get_contact: function() {
		return this.getString("contact");
	}
	,get_isrc: function() {
		return this.getString("isrc");
	}
	,get_artists: function() {
		return this.getArray("artist");
	}
	,add: function(key,value) {
		key = key.toLowerCase();
		var _this = this.data;
		if(__map_reserved[key] != null ? _this.existsReserved(key) : _this.h.hasOwnProperty(key)) {
			var _this1 = this.data;
			(__map_reserved[key] != null ? _this1.getReserved(key) : _this1.h[key]).push(value);
		} else {
			var v = [value];
			var _this2 = this.data;
			if(__map_reserved[key] != null) {
				_this2.setReserved(key,v);
			} else {
				_this2.h[key] = v;
			}
		}
	}
	,getString: function(key) {
		key = key.toLowerCase();
		var _this = this.data;
		if(__map_reserved[key] != null ? _this.existsReserved(key) : _this.h.hasOwnProperty(key)) {
			var _this1 = this.data;
			return (__map_reserved[key] != null ? _this1.getReserved(key) : _this1.h[key])[0];
		} else {
			return null;
		}
	}
	,getArray: function(key) {
		key = key.toLowerCase();
		var _this = this.data;
		if(__map_reserved[key] != null ? _this.existsReserved(key) : _this.h.hasOwnProperty(key)) {
			var _this1 = this.data;
			if(__map_reserved[key] != null) {
				return _this1.getReserved(key);
			} else {
				return _this1.h[key];
			}
		} else {
			return null;
		}
	}
	,__class__: kha_audio2_ogg_vorbis_data_Comment
};
var kha_audio2_ogg_vorbis_data_Floor = function() {
};
$hxClasses["kha.audio2.ogg.vorbis.data.Floor"] = kha_audio2_ogg_vorbis_data_Floor;
kha_audio2_ogg_vorbis_data_Floor.__name__ = true;
kha_audio2_ogg_vorbis_data_Floor.read = function(decodeState,codebooks) {
	var floor = new kha_audio2_ogg_vorbis_data_Floor();
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 16) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 16)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			tmp = z;
		}
	} else {
		var z1 = decodeState.acc & 65535;
		decodeState.acc = decodeState.acc >>> 16;
		decodeState.validBits -= 16;
		tmp = z1;
	}
	floor.type = tmp;
	if(floor.type > 1) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Floor.hx", lineNumber : 28, className : "kha.audio2.ogg.vorbis.data.Floor", methodName : "read"}));
	}
	if(floor.type == 0) {
		var g = floor.floor0 = new kha_audio2_ogg_vorbis_data_Floor0();
		var tmp1;
		if(decodeState.validBits < 0) {
			tmp1 = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 8)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp1 = 0;
			} else {
				var z2 = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp1 = z2;
			}
		} else {
			var z3 = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp1 = z3;
		}
		g.order = tmp1;
		var tmp2;
		if(decodeState.validBits < 0) {
			tmp2 = 0;
		} else if(decodeState.validBits < 16) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 16)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp2 = 0;
			} else {
				var z4 = decodeState.acc & 65535;
				decodeState.acc = decodeState.acc >>> 16;
				decodeState.validBits -= 16;
				tmp2 = z4;
			}
		} else {
			var z5 = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			tmp2 = z5;
		}
		g.rate = tmp2;
		var tmp3;
		if(decodeState.validBits < 0) {
			tmp3 = 0;
		} else if(decodeState.validBits < 16) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 16)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp3 = 0;
			} else {
				var z6 = decodeState.acc & 65535;
				decodeState.acc = decodeState.acc >>> 16;
				decodeState.validBits -= 16;
				tmp3 = z6;
			}
		} else {
			var z7 = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			tmp3 = z7;
		}
		g.barkMapSize = tmp3;
		var tmp4;
		if(decodeState.validBits < 0) {
			tmp4 = 0;
		} else if(decodeState.validBits < 6) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 6)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp4 = 0;
			} else {
				var z8 = decodeState.acc & 63;
				decodeState.acc = decodeState.acc >>> 6;
				decodeState.validBits -= 6;
				tmp4 = z8;
			}
		} else {
			var z9 = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			tmp4 = z9;
		}
		g.amplitudeBits = tmp4;
		var tmp5;
		if(decodeState.validBits < 0) {
			tmp5 = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 8)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp5 = 0;
			} else {
				var z10 = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp5 = z10;
			}
		} else {
			var z11 = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp5 = z11;
		}
		g.amplitudeOffset = tmp5;
		var tmp6;
		if(decodeState.validBits < 0) {
			tmp6 = 0;
		} else if(decodeState.validBits < 4) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 4)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp6 = 0;
			} else {
				var z12 = decodeState.acc & 15;
				decodeState.acc = decodeState.acc >>> 4;
				decodeState.validBits -= 4;
				tmp6 = z12;
			}
		} else {
			var z13 = decodeState.acc & 15;
			decodeState.acc = decodeState.acc >>> 4;
			decodeState.validBits -= 4;
			tmp6 = z13;
		}
		g.numberOfBooks = tmp6 + 1;
		var _g1 = 0;
		var _g = g.numberOfBooks;
		while(_g1 < _g) {
			var j = _g1++;
			var this1 = g.bookList;
			var val;
			if(decodeState.validBits < 0) {
				val = 0;
			} else if(decodeState.validBits < 8) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				while(true) {
					if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					}
					if(!(decodeState.validBits < 8)) {
						break;
					}
				}
				if(decodeState.validBits < 0) {
					val = 0;
				} else {
					var z14 = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					val = z14;
				}
			} else {
				var z15 = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				val = z15;
			}
			this1[j] = val;
		}
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.FEATURE_NOT_SUPPORTED,null,{ fileName : "Floor.hx", lineNumber : 41, className : "kha.audio2.ogg.vorbis.data.Floor", methodName : "read"}));
	} else {
		var p = [];
		var g1 = floor.floor1 = new kha_audio2_ogg_vorbis_data_Floor1();
		var maxClass = -1;
		var tmp7;
		if(decodeState.validBits < 0) {
			tmp7 = 0;
		} else if(decodeState.validBits < 5) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 5)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp7 = 0;
			} else {
				var z16 = decodeState.acc & 31;
				decodeState.acc = decodeState.acc >>> 5;
				decodeState.validBits -= 5;
				tmp7 = z16;
			}
		} else {
			var z17 = decodeState.acc & 31;
			decodeState.acc = decodeState.acc >>> 5;
			decodeState.validBits -= 5;
			tmp7 = z17;
		}
		g1.partitions = tmp7;
		var length = g1.partitions;
		var this2 = new Array(length);
		g1.partitionClassList = this2;
		var _g11 = 0;
		var _g2 = g1.partitions;
		while(_g11 < _g2) {
			var j1 = _g11++;
			var this3 = g1.partitionClassList;
			var val1;
			if(decodeState.validBits < 0) {
				val1 = 0;
			} else if(decodeState.validBits < 4) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				while(true) {
					if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					}
					if(!(decodeState.validBits < 4)) {
						break;
					}
				}
				if(decodeState.validBits < 0) {
					val1 = 0;
				} else {
					var z18 = decodeState.acc & 15;
					decodeState.acc = decodeState.acc >>> 4;
					decodeState.validBits -= 4;
					val1 = z18;
				}
			} else {
				var z19 = decodeState.acc & 15;
				decodeState.acc = decodeState.acc >>> 4;
				decodeState.validBits -= 4;
				val1 = z19;
			}
			this3[j1] = val1;
			if(g1.partitionClassList[j1] > maxClass) {
				maxClass = g1.partitionClassList[j1];
			}
		}
		var this4 = new Array(maxClass + 1);
		g1.classDimensions = this4;
		var this5 = new Array(maxClass + 1);
		g1.classMasterbooks = this5;
		var this6 = new Array(maxClass + 1);
		g1.classSubclasses = this6;
		var this7 = new Array(maxClass + 1);
		g1.subclassBooks = this7;
		var _g12 = 0;
		var _g3 = maxClass + 1;
		while(_g12 < _g3) {
			var j2 = _g12++;
			var this8 = g1.classDimensions;
			var val2;
			if(decodeState.validBits < 0) {
				val2 = 0;
			} else if(decodeState.validBits < 3) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				while(true) {
					if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					}
					if(!(decodeState.validBits < 3)) {
						break;
					}
				}
				if(decodeState.validBits < 0) {
					val2 = 0;
				} else {
					var z20 = decodeState.acc & 7;
					decodeState.acc = decodeState.acc >>> 3;
					decodeState.validBits -= 3;
					val2 = z20;
				}
			} else {
				var z21 = decodeState.acc & 7;
				decodeState.acc = decodeState.acc >>> 3;
				decodeState.validBits -= 3;
				val2 = z21;
			}
			this8[j2] = val2 + 1;
			var this9 = g1.classSubclasses;
			var val3;
			if(decodeState.validBits < 0) {
				val3 = 0;
			} else if(decodeState.validBits < 2) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				while(true) {
					if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					}
					if(!(decodeState.validBits < 2)) {
						break;
					}
				}
				if(decodeState.validBits < 0) {
					val3 = 0;
				} else {
					var z22 = decodeState.acc & 3;
					decodeState.acc = decodeState.acc >>> 2;
					decodeState.validBits -= 2;
					val3 = z22;
				}
			} else {
				var z23 = decodeState.acc & 3;
				decodeState.acc = decodeState.acc >>> 2;
				decodeState.validBits -= 2;
				val3 = z23;
			}
			this9[j2] = val3;
			if(g1.classSubclasses[j2] != 0) {
				var this10 = g1.classMasterbooks;
				var val4;
				if(decodeState.validBits < 0) {
					val4 = 0;
				} else if(decodeState.validBits < 8) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					while(true) {
						if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						}
						if(!(decodeState.validBits < 8)) {
							break;
						}
					}
					if(decodeState.validBits < 0) {
						val4 = 0;
					} else {
						var z24 = decodeState.acc & 255;
						decodeState.acc = decodeState.acc >>> 8;
						decodeState.validBits -= 8;
						val4 = z24;
					}
				} else {
					var z25 = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					val4 = z25;
				}
				this10[j2] = val4;
				if(g1.classMasterbooks[j2] >= codebooks.length) {
					throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Floor.hx", lineNumber : 64, className : "kha.audio2.ogg.vorbis.data.Floor", methodName : "read"}));
				}
			}
			var kl = 1 << g1.classSubclasses[j2];
			var this11 = g1.subclassBooks;
			var this12 = new Array(kl);
			this11[j2] = this12;
			var _g31 = 0;
			var _g21 = kl;
			while(_g31 < _g21) {
				var k = _g31++;
				var this13 = g1.subclassBooks[j2];
				var val5;
				if(decodeState.validBits < 0) {
					val5 = 0;
				} else if(decodeState.validBits < 8) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					while(true) {
						if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						}
						if(!(decodeState.validBits < 8)) {
							break;
						}
					}
					if(decodeState.validBits < 0) {
						val5 = 0;
					} else {
						var z26 = decodeState.acc & 255;
						decodeState.acc = decodeState.acc >>> 8;
						decodeState.validBits -= 8;
						val5 = z26;
					}
				} else {
					var z27 = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					val5 = z27;
				}
				this13[k] = val5 - 1;
				if(g1.subclassBooks[j2][k] >= codebooks.length) {
					throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Floor.hx", lineNumber : 73, className : "kha.audio2.ogg.vorbis.data.Floor", methodName : "read"}));
				}
			}
		}
		var tmp8;
		if(decodeState.validBits < 0) {
			tmp8 = 0;
		} else if(decodeState.validBits < 2) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 2)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp8 = 0;
			} else {
				var z28 = decodeState.acc & 3;
				decodeState.acc = decodeState.acc >>> 2;
				decodeState.validBits -= 2;
				tmp8 = z28;
			}
		} else {
			var z29 = decodeState.acc & 3;
			decodeState.acc = decodeState.acc >>> 2;
			decodeState.validBits -= 2;
			tmp8 = z29;
		}
		g1.floor1Multiplier = tmp8 + 1;
		var tmp9;
		if(decodeState.validBits < 0) {
			tmp9 = 0;
		} else if(decodeState.validBits < 4) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 4)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp9 = 0;
			} else {
				var z30 = decodeState.acc & 15;
				decodeState.acc = decodeState.acc >>> 4;
				decodeState.validBits -= 4;
				tmp9 = z30;
			}
		} else {
			var z31 = decodeState.acc & 15;
			decodeState.acc = decodeState.acc >>> 4;
			decodeState.validBits -= 4;
			tmp9 = z31;
		}
		g1.rangebits = tmp9;
		var this14 = new Array(250);
		g1.xlist = this14;
		g1.xlist[0] = 0;
		g1.xlist[1] = 1 << g1.rangebits;
		g1.values = 2;
		var _g13 = 0;
		var _g4 = g1.partitions;
		while(_g13 < _g4) {
			var j3 = _g13++;
			var c = g1.partitionClassList[j3];
			var _g32 = 0;
			var _g22 = g1.classDimensions[c];
			while(_g32 < _g22) {
				var k1 = _g32++;
				var this15 = g1.xlist;
				var index = g1.values;
				var n = g1.rangebits;
				var val6;
				if(decodeState.validBits < 0) {
					val6 = 0;
				} else if(decodeState.validBits < n) {
					if(n > 24) {
						val6 = decodeState.readBits(24) + (decodeState.readBits(n - 24) << 24);
					} else {
						if(decodeState.validBits == 0) {
							decodeState.acc = 0;
						}
						while(true) {
							if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
								decodeState.validBits = -1;
								break;
							} else {
								decodeState.bytesInSeg--;
								decodeState.inputPosition += 1;
								decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
								decodeState.validBits += 8;
							}
							if(!(decodeState.validBits < n)) {
								break;
							}
						}
						if(decodeState.validBits < 0) {
							val6 = 0;
						} else {
							var z32 = decodeState.acc & (1 << n) - 1;
							decodeState.acc = decodeState.acc >>> n;
							decodeState.validBits -= n;
							val6 = z32;
						}
					}
				} else {
					var z33 = decodeState.acc & (1 << n) - 1;
					decodeState.acc = decodeState.acc >>> n;
					decodeState.validBits -= n;
					val6 = z33;
				}
				this15[index] = val6;
				g1.values++;
			}
		}
		var _g14 = 0;
		var _g5 = g1.values;
		while(_g14 < _g5) {
			var j4 = _g14++;
			p.push(new kha_audio2_ogg_vorbis_data_IntPoint());
			p[j4].x = g1.xlist[j4];
			p[j4].y = j4;
		}
		p.sort(kha_audio2_ogg_vorbis_VorbisTools.pointCompare);
		var length1 = g1.values;
		var this16 = new Array(length1);
		g1.sortedOrder = this16;
		var _g15 = 0;
		var _g6 = g1.values;
		while(_g15 < _g6) {
			var j5 = _g15++;
			g1.sortedOrder[j5] = p[j5].y;
		}
		var length2 = g1.values;
		var this17 = new Array(length2);
		g1.neighbors = this17;
		var _g16 = 2;
		var _g7 = g1.values;
		while(_g16 < _g7) {
			var j6 = _g16++;
			var ne_low;
			var ne_high;
			var x = g1.xlist;
			var low = -1;
			var high = 65536;
			var plow = 0;
			var phigh = 0;
			var _g17 = 0;
			var _g8 = j6;
			while(_g17 < _g8) {
				var i = _g17++;
				if(x[i] > low && x[i] < x[j6]) {
					plow = i;
					low = x[i];
				}
				if(x[i] < high && x[i] > x[j6]) {
					phigh = i;
					high = x[i];
				}
			}
			ne_low = plow;
			ne_high = phigh;
			var this18 = g1.neighbors;
			var length3 = g1.values;
			var this19 = new Array(length3);
			this18[j6] = this19;
			g1.neighbors[j6][0] = ne_low;
			g1.neighbors[j6][1] = ne_high;
		}
	}
	return floor;
};
kha_audio2_ogg_vorbis_data_Floor.prototype = {
	floor0: null
	,floor1: null
	,type: null
	,__class__: kha_audio2_ogg_vorbis_data_Floor
};
var kha_audio2_ogg_vorbis_data_Floor0 = function() {
};
$hxClasses["kha.audio2.ogg.vorbis.data.Floor0"] = kha_audio2_ogg_vorbis_data_Floor0;
kha_audio2_ogg_vorbis_data_Floor0.__name__ = true;
kha_audio2_ogg_vorbis_data_Floor0.prototype = {
	order: null
	,rate: null
	,barkMapSize: null
	,amplitudeBits: null
	,amplitudeOffset: null
	,numberOfBooks: null
	,bookList: null
	,__class__: kha_audio2_ogg_vorbis_data_Floor0
};
var kha_audio2_ogg_vorbis_data_Floor1 = function() {
};
$hxClasses["kha.audio2.ogg.vorbis.data.Floor1"] = kha_audio2_ogg_vorbis_data_Floor1;
kha_audio2_ogg_vorbis_data_Floor1.__name__ = true;
kha_audio2_ogg_vorbis_data_Floor1.prototype = {
	partitions: null
	,partitionClassList: null
	,classDimensions: null
	,classSubclasses: null
	,classMasterbooks: null
	,subclassBooks: null
	,xlist: null
	,sortedOrder: null
	,neighbors: null
	,floor1Multiplier: null
	,rangebits: null
	,values: null
	,__class__: kha_audio2_ogg_vorbis_data_Floor1
};
var kha_audio2_ogg_vorbis_data_Header = function() {
};
$hxClasses["kha.audio2.ogg.vorbis.data.Header"] = kha_audio2_ogg_vorbis_data_Header;
kha_audio2_ogg_vorbis_data_Header.__name__ = true;
kha_audio2_ogg_vorbis_data_Header.read = function(decodeState) {
	var page = decodeState.page;
	page.start(decodeState);
	if((page.flag & 2) == 0) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"not firstPage",{ fileName : "Header.hx", lineNumber : 46, className : "kha.audio2.ogg.vorbis.data.Header", methodName : "read"}));
	}
	if((page.flag & 4) != 0) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"lastPage",{ fileName : "Header.hx", lineNumber : 49, className : "kha.audio2.ogg.vorbis.data.Header", methodName : "read"}));
	}
	if((page.flag & 1) != 0) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"continuedPacket",{ fileName : "Header.hx", lineNumber : 52, className : "kha.audio2.ogg.vorbis.data.Header", methodName : "read"}));
	}
	decodeState.firstPageValidate();
	decodeState.inputPosition += 1;
	if(decodeState.input.readByte() != 1) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"decodeState head",{ fileName : "Header.hx", lineNumber : 57, className : "kha.audio2.ogg.vorbis.data.Header", methodName : "read"}));
	}
	var header = new haxe_io_Bytes(new ArrayBuffer(6));
	var _g = 0;
	while(_g < 6) {
		var i = _g++;
		var x;
		if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
			x = -1;
		} else {
			decodeState.bytesInSeg--;
			decodeState.inputPosition += 1;
			x = decodeState.input.readByte();
		}
		decodeState.validBits = 0;
		header.b[i] = x & 255;
	}
	if(header.toString() != "vorbis") {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,"vorbis header",{ fileName : "VorbisDecodeState.hx", lineNumber : 300, className : "kha.audio2.ogg.vorbis.VorbisDecodeState", methodName : "vorbisValidate"}));
	}
	decodeState.inputPosition += 4;
	var version = decodeState.input.readInt32();
	if(version != 0) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"vorbis version : " + version,{ fileName : "Header.hx", lineNumber : 66, className : "kha.audio2.ogg.vorbis.data.Header", methodName : "read"}));
	}
	var header1 = new kha_audio2_ogg_vorbis_data_Header();
	decodeState.inputPosition += 1;
	header1.channel = decodeState.input.readByte();
	if(header1.channel == 0) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"no channel",{ fileName : "Header.hx", lineNumber : 73, className : "kha.audio2.ogg.vorbis.data.Header", methodName : "read"}));
	} else if(header1.channel > 16) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.TOO_MANY_CHANNELS,"too many channels",{ fileName : "Header.hx", lineNumber : 75, className : "kha.audio2.ogg.vorbis.data.Header", methodName : "read"}));
	}
	decodeState.inputPosition += 4;
	header1.sampleRate = decodeState.input.readInt32();
	if(header1.sampleRate == 0) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"no sampling rate",{ fileName : "Header.hx", lineNumber : 80, className : "kha.audio2.ogg.vorbis.data.Header", methodName : "read"}));
	}
	decodeState.inputPosition += 4;
	header1.maximumBitRate = decodeState.input.readInt32();
	decodeState.inputPosition += 4;
	header1.nominalBitRate = decodeState.input.readInt32();
	decodeState.inputPosition += 4;
	header1.minimumBitRate = decodeState.input.readInt32();
	decodeState.inputPosition += 1;
	var x1 = decodeState.input.readByte();
	var log0 = x1 & 15;
	var log1 = x1 >> 4;
	header1.blocksize0 = 1 << log0;
	header1.blocksize1 = 1 << log1;
	if(log0 < 6 || log0 > 13) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Header.hx", lineNumber : 93, className : "kha.audio2.ogg.vorbis.data.Header", methodName : "read"}));
	}
	if(log1 < 6 || log1 > 13) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Header.hx", lineNumber : 96, className : "kha.audio2.ogg.vorbis.data.Header", methodName : "read"}));
	}
	if(log0 > log1) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Header.hx", lineNumber : 99, className : "kha.audio2.ogg.vorbis.data.Header", methodName : "read"}));
	}
	decodeState.inputPosition += 1;
	var x2 = decodeState.input.readByte();
	if((x2 & 1) == 0) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,null,{ fileName : "Header.hx", lineNumber : 105, className : "kha.audio2.ogg.vorbis.data.Header", methodName : "read"}));
	}
	decodeState.page.start(decodeState);
	decodeState.startPacket();
	var len = 0;
	var output = new haxe_io_BytesOutput();
	while(true) {
		len = decodeState.next();
		if(!(len != 0)) {
			break;
		}
		decodeState.inputPosition += len;
		output.write(decodeState.input.read(len));
		decodeState.bytesInSeg = 0;
	}
	var packetInput = new haxe_io_BytesInput(output.getBytes());
	packetInput.readByte();
	packetInput.read(6);
	var vendorLength = packetInput.readInt32();
	header1.vendor = packetInput.readString(vendorLength);
	header1.comment = new kha_audio2_ogg_vorbis_data_Comment();
	var commentCount = packetInput.readInt32();
	var _g1 = 0;
	var _g2 = commentCount;
	while(_g1 < _g2) {
		var i1 = _g1++;
		var n = packetInput.readInt32();
		var str = packetInput.readString(n);
		var splitter = str.indexOf("=");
		if(splitter != -1) {
			header1.comment.add(str.substring(0,splitter),str.substring(splitter + 1));
		}
	}
	var x3 = packetInput.readByte();
	if((x3 & 1) == 0) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Header.hx", lineNumber : 141, className : "kha.audio2.ogg.vorbis.data.Header", methodName : "read"}));
	}
	decodeState.startPacket();
	var x4;
	if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
		x4 = -1;
	} else {
		decodeState.bytesInSeg--;
		decodeState.inputPosition += 1;
		x4 = decodeState.input.readByte();
	}
	decodeState.validBits = 0;
	if(x4 != 5) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,"setup packet",{ fileName : "Header.hx", lineNumber : 149, className : "kha.audio2.ogg.vorbis.data.Header", methodName : "read"}));
	}
	var header2 = new haxe_io_Bytes(new ArrayBuffer(6));
	var _g3 = 0;
	while(_g3 < 6) {
		var i2 = _g3++;
		var x5;
		if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
			x5 = -1;
		} else {
			decodeState.bytesInSeg--;
			decodeState.inputPosition += 1;
			x5 = decodeState.input.readByte();
		}
		decodeState.validBits = 0;
		header2.b[i2] = x5 & 255;
	}
	if(header2.toString() != "vorbis") {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,"vorbis header",{ fileName : "VorbisDecodeState.hx", lineNumber : 300, className : "kha.audio2.ogg.vorbis.VorbisDecodeState", methodName : "vorbisValidate"}));
	}
	var codebookCount;
	if(decodeState.validBits < 0) {
		codebookCount = 0;
	} else if(decodeState.validBits < 8) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 8)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			codebookCount = 0;
		} else {
			var z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			codebookCount = z;
		}
	} else {
		var z1 = decodeState.acc & 255;
		decodeState.acc = decodeState.acc >>> 8;
		decodeState.validBits -= 8;
		codebookCount = z1;
	}
	var codebookCount1 = codebookCount + 1;
	var this1 = new Array(codebookCount1);
	header1.codebooks = this1;
	var _g11 = 0;
	var _g4 = codebookCount1;
	while(_g11 < _g4) {
		var i3 = _g11++;
		header1.codebooks[i3] = kha_audio2_ogg_vorbis_data_Codebook.read(decodeState);
	}
	var x6;
	if(decodeState.validBits < 0) {
		x6 = 0;
	} else if(decodeState.validBits < 6) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 6)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			x6 = 0;
		} else {
			var z2 = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			x6 = z2;
		}
	} else {
		var z3 = decodeState.acc & 63;
		decodeState.acc = decodeState.acc >>> 6;
		decodeState.validBits -= 6;
		x6 = z3;
	}
	x2 = x6 + 1;
	var _g12 = 0;
	var _g5 = x2;
	while(_g12 < _g5) {
		var i4 = _g12++;
		var tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 16) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 16)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				var z4 = decodeState.acc & 65535;
				decodeState.acc = decodeState.acc >>> 16;
				decodeState.validBits -= 16;
				tmp = z4;
			}
		} else {
			var z5 = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			tmp = z5;
		}
		if(tmp != 0) {
			throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Header.hx", lineNumber : 165, className : "kha.audio2.ogg.vorbis.data.Header", methodName : "read"}));
		}
	}
	var floorCount;
	if(decodeState.validBits < 0) {
		floorCount = 0;
	} else if(decodeState.validBits < 6) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 6)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			floorCount = 0;
		} else {
			var z6 = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			floorCount = z6;
		}
	} else {
		var z7 = decodeState.acc & 63;
		decodeState.acc = decodeState.acc >>> 6;
		decodeState.validBits -= 6;
		floorCount = z7;
	}
	var floorCount1 = floorCount + 1;
	var this2 = new Array(floorCount1);
	header1.floorConfig = this2;
	var _g13 = 0;
	var _g6 = floorCount1;
	while(_g13 < _g6) {
		var i5 = _g13++;
		header1.floorConfig[i5] = kha_audio2_ogg_vorbis_data_Floor.read(decodeState,header1.codebooks);
	}
	var residueCount;
	if(decodeState.validBits < 0) {
		residueCount = 0;
	} else if(decodeState.validBits < 6) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 6)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			residueCount = 0;
		} else {
			var z8 = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			residueCount = z8;
		}
	} else {
		var z9 = decodeState.acc & 63;
		decodeState.acc = decodeState.acc >>> 6;
		decodeState.validBits -= 6;
		residueCount = z9;
	}
	var residueCount1 = residueCount + 1;
	var this3 = new Array(residueCount1);
	header1.residueConfig = this3;
	var _g14 = 0;
	var _g7 = residueCount1;
	while(_g14 < _g7) {
		var i6 = _g14++;
		header1.residueConfig[i6] = kha_audio2_ogg_vorbis_data_Residue.read(decodeState,header1.codebooks);
	}
	var mappingCount;
	if(decodeState.validBits < 0) {
		mappingCount = 0;
	} else if(decodeState.validBits < 6) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 6)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			mappingCount = 0;
		} else {
			var z10 = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			mappingCount = z10;
		}
	} else {
		var z11 = decodeState.acc & 63;
		decodeState.acc = decodeState.acc >>> 6;
		decodeState.validBits -= 6;
		mappingCount = z11;
	}
	var mappingCount1 = mappingCount + 1;
	var this4 = new Array(mappingCount1);
	header1.mapping = this4;
	var _g15 = 0;
	var _g8 = mappingCount1;
	while(_g15 < _g8) {
		var i7 = _g15++;
		var map = kha_audio2_ogg_vorbis_data_Mapping.read(decodeState,header1.channel);
		header1.mapping[i7] = map;
		var _g31 = 0;
		var _g21 = map.submaps;
		while(_g31 < _g21) {
			var j = _g31++;
			if(map.submapFloor[j] >= header1.floorConfig.length) {
				throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Header.hx", lineNumber : 191, className : "kha.audio2.ogg.vorbis.data.Header", methodName : "read"}));
			}
			if(map.submapResidue[j] >= header1.residueConfig.length) {
				throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Header.hx", lineNumber : 194, className : "kha.audio2.ogg.vorbis.data.Header", methodName : "read"}));
			}
		}
	}
	var modeCount;
	if(decodeState.validBits < 0) {
		modeCount = 0;
	} else if(decodeState.validBits < 6) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 6)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			modeCount = 0;
		} else {
			var z12 = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			modeCount = z12;
		}
	} else {
		var z13 = decodeState.acc & 63;
		decodeState.acc = decodeState.acc >>> 6;
		decodeState.validBits -= 6;
		modeCount = z13;
	}
	var modeCount1 = modeCount + 1;
	var this5 = new Array(modeCount1);
	header1.modes = this5;
	var _g16 = 0;
	var _g9 = modeCount1;
	while(_g16 < _g9) {
		var i8 = _g16++;
		var mode = kha_audio2_ogg_vorbis_data_Mode.read(decodeState);
		header1.modes[i8] = mode;
		if(mode.mapping >= header1.mapping.length) {
			throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Header.hx", lineNumber : 205, className : "kha.audio2.ogg.vorbis.data.Header", methodName : "read"}));
		}
	}
	while(decodeState.bytesInSeg != 0 || !decodeState.lastSeg && decodeState.next() != 0) {
		decodeState.bytesInSeg--;
		decodeState.inputPosition += 1;
		decodeState.input.readByte();
	}
	return header1;
};
kha_audio2_ogg_vorbis_data_Header.prototype = {
	maximumBitRate: null
	,nominalBitRate: null
	,minimumBitRate: null
	,sampleRate: null
	,channel: null
	,blocksize0: null
	,blocksize1: null
	,codebooks: null
	,floorConfig: null
	,residueConfig: null
	,mapping: null
	,modes: null
	,comment: null
	,vendor: null
	,__class__: kha_audio2_ogg_vorbis_data_Header
};
var kha_audio2_ogg_vorbis_data_IntPoint = function() {
};
$hxClasses["kha.audio2.ogg.vorbis.data.IntPoint"] = kha_audio2_ogg_vorbis_data_IntPoint;
kha_audio2_ogg_vorbis_data_IntPoint.__name__ = true;
kha_audio2_ogg_vorbis_data_IntPoint.prototype = {
	x: null
	,y: null
	,__class__: kha_audio2_ogg_vorbis_data_IntPoint
};
var kha_audio2_ogg_vorbis_data_Mapping = function() {
};
$hxClasses["kha.audio2.ogg.vorbis.data.Mapping"] = kha_audio2_ogg_vorbis_data_Mapping;
kha_audio2_ogg_vorbis_data_Mapping.__name__ = true;
kha_audio2_ogg_vorbis_data_Mapping.read = function(decodeState,channels) {
	var m = new kha_audio2_ogg_vorbis_data_Mapping();
	var mappingType;
	if(decodeState.validBits < 0) {
		mappingType = 0;
	} else if(decodeState.validBits < 16) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 16)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			mappingType = 0;
		} else {
			var z = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			mappingType = z;
		}
	} else {
		var z1 = decodeState.acc & 65535;
		decodeState.acc = decodeState.acc >>> 16;
		decodeState.validBits -= 16;
		mappingType = z1;
	}
	if(mappingType != 0) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,"mapping type " + mappingType,{ fileName : "Mapping.hx", lineNumber : 22, className : "kha.audio2.ogg.vorbis.data.Mapping", methodName : "read"}));
	}
	var this1 = new Array(channels);
	m.chan = this1;
	var _g1 = 0;
	var _g = channels;
	while(_g1 < _g) {
		var j = _g1++;
		m.chan[j] = new kha_audio2_ogg_vorbis_data_MappingChannel();
	}
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 1) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 1)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z2 = decodeState.acc & 1;
			decodeState.acc = decodeState.acc >>> 1;
			decodeState.validBits -= 1;
			tmp = z2;
		}
	} else {
		var z3 = decodeState.acc & 1;
		decodeState.acc = decodeState.acc >>> 1;
		decodeState.validBits -= 1;
		tmp = z3;
	}
	if(tmp != 0) {
		var tmp1;
		if(decodeState.validBits < 0) {
			tmp1 = 0;
		} else if(decodeState.validBits < 4) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 4)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp1 = 0;
			} else {
				var z4 = decodeState.acc & 15;
				decodeState.acc = decodeState.acc >>> 4;
				decodeState.validBits -= 4;
				tmp1 = z4;
			}
		} else {
			var z5 = decodeState.acc & 15;
			decodeState.acc = decodeState.acc >>> 4;
			decodeState.validBits -= 4;
			tmp1 = z5;
		}
		m.submaps = tmp1 + 1;
	} else {
		m.submaps = 1;
	}
	var tmp2;
	if(decodeState.validBits < 0) {
		tmp2 = 0;
	} else if(decodeState.validBits < 1) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 1)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp2 = 0;
		} else {
			var z6 = decodeState.acc & 1;
			decodeState.acc = decodeState.acc >>> 1;
			decodeState.validBits -= 1;
			tmp2 = z6;
		}
	} else {
		var z7 = decodeState.acc & 1;
		decodeState.acc = decodeState.acc >>> 1;
		decodeState.validBits -= 1;
		tmp2 = z7;
	}
	if(tmp2 != 0) {
		var tmp3;
		if(decodeState.validBits < 0) {
			tmp3 = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 8)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp3 = 0;
			} else {
				var z8 = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp3 = z8;
			}
		} else {
			var z9 = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp3 = z9;
		}
		m.couplingSteps = tmp3 + 1;
		var _g11 = 0;
		var _g2 = m.couplingSteps;
		while(_g11 < _g2) {
			var k = _g11++;
			var tmp4 = m.chan[k];
			var n = channels - 1;
			var log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
			var n1 = n < 16384 ? n < 16 ? log2_4[n] : n < 512 ? 5 + log2_4[n >> 5] : 10 + log2_4[n >> 10] : n < 16777216 ? n < 524288 ? 15 + log2_4[n >> 15] : 20 + log2_4[n >> 20] : n < 536870912 ? 25 + log2_4[n >> 25] : n < -2147483648 ? 30 + log2_4[n >> 30] : 0;
			var tmp5;
			if(decodeState.validBits < 0) {
				tmp5 = 0;
			} else if(decodeState.validBits < n1) {
				if(n1 > 24) {
					tmp5 = decodeState.readBits(24) + (decodeState.readBits(n1 - 24) << 24);
				} else {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					while(true) {
						if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						}
						if(!(decodeState.validBits < n1)) {
							break;
						}
					}
					if(decodeState.validBits < 0) {
						tmp5 = 0;
					} else {
						var z10 = decodeState.acc & (1 << n1) - 1;
						decodeState.acc = decodeState.acc >>> n1;
						decodeState.validBits -= n1;
						tmp5 = z10;
					}
				}
			} else {
				var z11 = decodeState.acc & (1 << n1) - 1;
				decodeState.acc = decodeState.acc >>> n1;
				decodeState.validBits -= n1;
				tmp5 = z11;
			}
			tmp4.magnitude = tmp5;
			var tmp6 = m.chan[k];
			var n2 = channels - 1;
			var log2_41 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
			var n3 = n2 < 16384 ? n2 < 16 ? log2_41[n2] : n2 < 512 ? 5 + log2_41[n2 >> 5] : 10 + log2_41[n2 >> 10] : n2 < 16777216 ? n2 < 524288 ? 15 + log2_41[n2 >> 15] : 20 + log2_41[n2 >> 20] : n2 < 536870912 ? 25 + log2_41[n2 >> 25] : n2 < -2147483648 ? 30 + log2_41[n2 >> 30] : 0;
			var tmp7;
			if(decodeState.validBits < 0) {
				tmp7 = 0;
			} else if(decodeState.validBits < n3) {
				if(n3 > 24) {
					tmp7 = decodeState.readBits(24) + (decodeState.readBits(n3 - 24) << 24);
				} else {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					while(true) {
						if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						}
						if(!(decodeState.validBits < n3)) {
							break;
						}
					}
					if(decodeState.validBits < 0) {
						tmp7 = 0;
					} else {
						var z12 = decodeState.acc & (1 << n3) - 1;
						decodeState.acc = decodeState.acc >>> n3;
						decodeState.validBits -= n3;
						tmp7 = z12;
					}
				}
			} else {
				var z13 = decodeState.acc & (1 << n3) - 1;
				decodeState.acc = decodeState.acc >>> n3;
				decodeState.validBits -= n3;
				tmp7 = z13;
			}
			tmp6.angle = tmp7;
			if(m.chan[k].magnitude >= channels) {
				throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Mapping.hx", lineNumber : 46, className : "kha.audio2.ogg.vorbis.data.Mapping", methodName : "read"}));
			}
			if(m.chan[k].angle >= channels) {
				throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Mapping.hx", lineNumber : 49, className : "kha.audio2.ogg.vorbis.data.Mapping", methodName : "read"}));
			}
			if(m.chan[k].magnitude == m.chan[k].angle) {
				throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Mapping.hx", lineNumber : 52, className : "kha.audio2.ogg.vorbis.data.Mapping", methodName : "read"}));
			}
		}
	} else {
		m.couplingSteps = 0;
	}
	var tmp8;
	if(decodeState.validBits < 0) {
		tmp8 = 0;
	} else if(decodeState.validBits < 2) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 2)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp8 = 0;
		} else {
			var z14 = decodeState.acc & 3;
			decodeState.acc = decodeState.acc >>> 2;
			decodeState.validBits -= 2;
			tmp8 = z14;
		}
	} else {
		var z15 = decodeState.acc & 3;
		decodeState.acc = decodeState.acc >>> 2;
		decodeState.validBits -= 2;
		tmp8 = z15;
	}
	if(tmp8 != 0) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Mapping.hx", lineNumber : 61, className : "kha.audio2.ogg.vorbis.data.Mapping", methodName : "read"}));
	}
	if(m.submaps > 1) {
		var _g12 = 0;
		var _g3 = channels;
		while(_g12 < _g3) {
			var j1 = _g12++;
			var tmp9 = m.chan[j1];
			var tmp10;
			if(decodeState.validBits < 0) {
				tmp10 = 0;
			} else if(decodeState.validBits < 4) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				while(true) {
					if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					}
					if(!(decodeState.validBits < 4)) {
						break;
					}
				}
				if(decodeState.validBits < 0) {
					tmp10 = 0;
				} else {
					var z16 = decodeState.acc & 15;
					decodeState.acc = decodeState.acc >>> 4;
					decodeState.validBits -= 4;
					tmp10 = z16;
				}
			} else {
				var z17 = decodeState.acc & 15;
				decodeState.acc = decodeState.acc >>> 4;
				decodeState.validBits -= 4;
				tmp10 = z17;
			}
			tmp9.mux = tmp10;
			if(m.chan[j1].mux >= m.submaps) {
				throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Mapping.hx", lineNumber : 67, className : "kha.audio2.ogg.vorbis.data.Mapping", methodName : "read"}));
			}
		}
	} else {
		var _g13 = 0;
		var _g4 = channels;
		while(_g13 < _g4) {
			var j2 = _g13++;
			m.chan[j2].mux = 0;
		}
	}
	var length = m.submaps;
	var this2 = new Array(length);
	m.submapFloor = this2;
	var length1 = m.submaps;
	var this3 = new Array(length1);
	m.submapResidue = this3;
	var _g14 = 0;
	var _g5 = m.submaps;
	while(_g14 < _g5) {
		var j3 = _g14++;
		if(decodeState.validBits >= 0) {
			if(decodeState.validBits < 8) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				while(true) {
					if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					}
					if(!(decodeState.validBits < 8)) {
						break;
					}
				}
				if(decodeState.validBits >= 0) {
					var z18 = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
				}
			} else {
				var z19 = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
			}
		}
		var this4 = m.submapFloor;
		var val;
		if(decodeState.validBits < 0) {
			val = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 8)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				val = 0;
			} else {
				var z20 = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				val = z20;
			}
		} else {
			var z21 = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			val = z21;
		}
		this4[j3] = val;
		var this5 = m.submapResidue;
		var val1;
		if(decodeState.validBits < 0) {
			val1 = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 8)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				val1 = 0;
			} else {
				var z22 = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				val1 = z22;
			}
		} else {
			var z23 = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			val1 = z23;
		}
		this5[j3] = val1;
	}
	return m;
};
kha_audio2_ogg_vorbis_data_Mapping.prototype = {
	couplingSteps: null
	,chan: null
	,submaps: null
	,submapFloor: null
	,submapResidue: null
	,doFloor: function(floors,i,n,target,finalY,step2Flag) {
		var n2 = n >> 1;
		var s = this.chan[i].mux;
		var floor;
		var floor1 = floors[this.submapFloor[s]];
		if(floor1.type == 0) {
			throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_STREAM,null,{ fileName : "Mapping.hx", lineNumber : 94, className : "kha.audio2.ogg.vorbis.data.Mapping", methodName : "doFloor"}));
		} else {
			var g = floor1.floor1;
			var lx = 0;
			var ly = finalY[0] * g.floor1Multiplier;
			var _g1 = 1;
			var _g = g.values;
			while(_g1 < _g) {
				var q = _g1++;
				var j = g.sortedOrder[q];
				if(finalY[j] >= 0) {
					var hy = finalY[j] * g.floor1Multiplier;
					var hx = g.xlist[j];
					kha_audio2_ogg_vorbis_VorbisTools.drawLine(target,lx,ly,hx,hy,n2);
					lx = hx;
					ly = hy;
				}
			}
			if(lx < n2) {
				var _g11 = lx;
				var _g2 = n2;
				while(_g11 < _g2) {
					var j1 = _g11++;
					var _g21 = j1;
					var _g3 = target;
					_g3[_g21] = _g3[_g21] * kha_audio2_ogg_vorbis_VorbisTools.INVERSE_DB_TABLE[ly];
				}
			}
		}
	}
	,__class__: kha_audio2_ogg_vorbis_data_Mapping
};
var kha_audio2_ogg_vorbis_data_MappingChannel = function() {
};
$hxClasses["kha.audio2.ogg.vorbis.data.MappingChannel"] = kha_audio2_ogg_vorbis_data_MappingChannel;
kha_audio2_ogg_vorbis_data_MappingChannel.__name__ = true;
kha_audio2_ogg_vorbis_data_MappingChannel.prototype = {
	magnitude: null
	,angle: null
	,mux: null
	,__class__: kha_audio2_ogg_vorbis_data_MappingChannel
};
var kha_audio2_ogg_vorbis_data_Mode = function() {
};
$hxClasses["kha.audio2.ogg.vorbis.data.Mode"] = kha_audio2_ogg_vorbis_data_Mode;
kha_audio2_ogg_vorbis_data_Mode.__name__ = true;
kha_audio2_ogg_vorbis_data_Mode.read = function(decodeState) {
	var m = new kha_audio2_ogg_vorbis_data_Mode();
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 1) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 1)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z = decodeState.acc & 1;
			decodeState.acc = decodeState.acc >>> 1;
			decodeState.validBits -= 1;
			tmp = z;
		}
	} else {
		var z1 = decodeState.acc & 1;
		decodeState.acc = decodeState.acc >>> 1;
		decodeState.validBits -= 1;
		tmp = z1;
	}
	m.blockflag = tmp != 0;
	var tmp1;
	if(decodeState.validBits < 0) {
		tmp1 = 0;
	} else if(decodeState.validBits < 16) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 16)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp1 = 0;
		} else {
			var z2 = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			tmp1 = z2;
		}
	} else {
		var z3 = decodeState.acc & 65535;
		decodeState.acc = decodeState.acc >>> 16;
		decodeState.validBits -= 16;
		tmp1 = z3;
	}
	m.windowtype = tmp1;
	var tmp2;
	if(decodeState.validBits < 0) {
		tmp2 = 0;
	} else if(decodeState.validBits < 16) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 16)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp2 = 0;
		} else {
			var z4 = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			tmp2 = z4;
		}
	} else {
		var z5 = decodeState.acc & 65535;
		decodeState.acc = decodeState.acc >>> 16;
		decodeState.validBits -= 16;
		tmp2 = z5;
	}
	m.transformtype = tmp2;
	var tmp3;
	if(decodeState.validBits < 0) {
		tmp3 = 0;
	} else if(decodeState.validBits < 8) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 8)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp3 = 0;
		} else {
			var z6 = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp3 = z6;
		}
	} else {
		var z7 = decodeState.acc & 255;
		decodeState.acc = decodeState.acc >>> 8;
		decodeState.validBits -= 8;
		tmp3 = z7;
	}
	m.mapping = tmp3;
	if(m.windowtype != 0) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Mode.hx", lineNumber : 22, className : "kha.audio2.ogg.vorbis.data.Mode", methodName : "read"}));
	}
	if(m.transformtype != 0) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Mode.hx", lineNumber : 25, className : "kha.audio2.ogg.vorbis.data.Mode", methodName : "read"}));
	}
	return m;
};
kha_audio2_ogg_vorbis_data_Mode.prototype = {
	blockflag: null
	,mapping: null
	,windowtype: null
	,transformtype: null
	,__class__: kha_audio2_ogg_vorbis_data_Mode
};
var kha_audio2_ogg_vorbis_data_Page = function() {
};
$hxClasses["kha.audio2.ogg.vorbis.data.Page"] = kha_audio2_ogg_vorbis_data_Page;
kha_audio2_ogg_vorbis_data_Page.__name__ = true;
kha_audio2_ogg_vorbis_data_Page.prototype = {
	flag: null
	,clone: function() {
		var page = new kha_audio2_ogg_vorbis_data_Page();
		page.flag = this.flag;
		return page;
	}
	,start: function(decodeState) {
		var tmp;
		var tmp1;
		var tmp2;
		decodeState.inputPosition += 1;
		if(decodeState.input.readByte() == 79) {
			decodeState.inputPosition += 1;
			tmp2 = decodeState.input.readByte() != 103;
		} else {
			tmp2 = true;
		}
		if(!tmp2) {
			decodeState.inputPosition += 1;
			tmp1 = decodeState.input.readByte() != 103;
		} else {
			tmp1 = true;
		}
		if(!tmp1) {
			decodeState.inputPosition += 1;
			tmp = decodeState.input.readByte() != 83;
		} else {
			tmp = true;
		}
		if(tmp) {
			throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.MISSING_CAPTURE_PATTERN,null,{ fileName : "VorbisDecodeState.hx", lineNumber : 323, className : "kha.audio2.ogg.vorbis.VorbisDecodeState", methodName : "capturePattern"}));
		}
		this.startWithoutCapturePattern(decodeState);
	}
	,startWithoutCapturePattern: function(decodeState) {
		decodeState.inputPosition += 1;
		var version = decodeState.input.readByte();
		if(version != 0) {
			throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_STREAM_STRUCTURE_VERSION,"" + version,{ fileName : "Page.hx", lineNumber : 34, className : "kha.audio2.ogg.vorbis.data.Page", methodName : "startWithoutCapturePattern"}));
		}
		decodeState.inputPosition += 1;
		this.flag = decodeState.input.readByte();
		decodeState.inputPosition += 4;
		var loc0 = decodeState.input.readInt32();
		decodeState.inputPosition += 4;
		var loc1 = decodeState.input.readInt32();
		decodeState.inputPosition += 4;
		decodeState.input.readInt32();
		decodeState.inputPosition += 4;
		decodeState.input.readInt32();
		decodeState.inputPosition += 4;
		decodeState.input.readInt32();
		decodeState.setup(loc0,loc1);
	}
	,__class__: kha_audio2_ogg_vorbis_data_Page
};
var kha_audio2_ogg_vorbis_data_PageFlag = function() { };
$hxClasses["kha.audio2.ogg.vorbis.data.PageFlag"] = kha_audio2_ogg_vorbis_data_PageFlag;
kha_audio2_ogg_vorbis_data_PageFlag.__name__ = true;
var kha_audio2_ogg_vorbis_data_ProbedPage = function() {
};
$hxClasses["kha.audio2.ogg.vorbis.data.ProbedPage"] = kha_audio2_ogg_vorbis_data_ProbedPage;
kha_audio2_ogg_vorbis_data_ProbedPage.__name__ = true;
kha_audio2_ogg_vorbis_data_ProbedPage.prototype = {
	pageStart: null
	,pageEnd: null
	,afterPreviousPageStart: null
	,firstDecodedSample: null
	,lastDecodedSample: null
	,__class__: kha_audio2_ogg_vorbis_data_ProbedPage
};
var kha_audio2_ogg_vorbis_data_ReaderError = function(type,message,posInfos) {
	if(message == null) {
		message = "";
	}
	this.type = type;
	this.message = message;
	this.posInfos = posInfos;
};
$hxClasses["kha.audio2.ogg.vorbis.data.ReaderError"] = kha_audio2_ogg_vorbis_data_ReaderError;
kha_audio2_ogg_vorbis_data_ReaderError.__name__ = true;
kha_audio2_ogg_vorbis_data_ReaderError.prototype = {
	type: null
	,message: null
	,posInfos: null
	,__class__: kha_audio2_ogg_vorbis_data_ReaderError
};
var kha_audio2_ogg_vorbis_data_ReaderErrorType = $hxClasses["kha.audio2.ogg.vorbis.data.ReaderErrorType"] = { __ename__ : true, __constructs__ : ["NEED_MORE_DATA","INVALID_API_MIXING","OUTOFMEM","FEATURE_NOT_SUPPORTED","TOO_MANY_CHANNELS","FILE_OPEN_FAILURE","SEEK_WITHOUT_LENGTH","UNEXPECTED_EOF","SEEK_INVALID","INVALID_SETUP","INVALID_STREAM","MISSING_CAPTURE_PATTERN","INVALID_STREAM_STRUCTURE_VERSION","CONTINUED_PACKET_FLAG_INVALID","INCORRECT_STREAM_SERIAL_NUMBER","INVALID_FIRST_PAGE","BAD_PACKET_TYPE","CANT_FIND_LAST_PAGE","SEEK_FAILED","OTHER"] };
kha_audio2_ogg_vorbis_data_ReaderErrorType.NEED_MORE_DATA = ["NEED_MORE_DATA",0];
kha_audio2_ogg_vorbis_data_ReaderErrorType.NEED_MORE_DATA.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.NEED_MORE_DATA.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_API_MIXING = ["INVALID_API_MIXING",1];
kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_API_MIXING.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_API_MIXING.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
kha_audio2_ogg_vorbis_data_ReaderErrorType.OUTOFMEM = ["OUTOFMEM",2];
kha_audio2_ogg_vorbis_data_ReaderErrorType.OUTOFMEM.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.OUTOFMEM.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
kha_audio2_ogg_vorbis_data_ReaderErrorType.FEATURE_NOT_SUPPORTED = ["FEATURE_NOT_SUPPORTED",3];
kha_audio2_ogg_vorbis_data_ReaderErrorType.FEATURE_NOT_SUPPORTED.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.FEATURE_NOT_SUPPORTED.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
kha_audio2_ogg_vorbis_data_ReaderErrorType.TOO_MANY_CHANNELS = ["TOO_MANY_CHANNELS",4];
kha_audio2_ogg_vorbis_data_ReaderErrorType.TOO_MANY_CHANNELS.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.TOO_MANY_CHANNELS.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
kha_audio2_ogg_vorbis_data_ReaderErrorType.FILE_OPEN_FAILURE = ["FILE_OPEN_FAILURE",5];
kha_audio2_ogg_vorbis_data_ReaderErrorType.FILE_OPEN_FAILURE.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.FILE_OPEN_FAILURE.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
kha_audio2_ogg_vorbis_data_ReaderErrorType.SEEK_WITHOUT_LENGTH = ["SEEK_WITHOUT_LENGTH",6];
kha_audio2_ogg_vorbis_data_ReaderErrorType.SEEK_WITHOUT_LENGTH.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.SEEK_WITHOUT_LENGTH.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
kha_audio2_ogg_vorbis_data_ReaderErrorType.UNEXPECTED_EOF = ["UNEXPECTED_EOF",7];
kha_audio2_ogg_vorbis_data_ReaderErrorType.UNEXPECTED_EOF.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.UNEXPECTED_EOF.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
kha_audio2_ogg_vorbis_data_ReaderErrorType.SEEK_INVALID = ["SEEK_INVALID",8];
kha_audio2_ogg_vorbis_data_ReaderErrorType.SEEK_INVALID.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.SEEK_INVALID.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP = ["INVALID_SETUP",9];
kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_STREAM = ["INVALID_STREAM",10];
kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_STREAM.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_STREAM.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
kha_audio2_ogg_vorbis_data_ReaderErrorType.MISSING_CAPTURE_PATTERN = ["MISSING_CAPTURE_PATTERN",11];
kha_audio2_ogg_vorbis_data_ReaderErrorType.MISSING_CAPTURE_PATTERN.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.MISSING_CAPTURE_PATTERN.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_STREAM_STRUCTURE_VERSION = ["INVALID_STREAM_STRUCTURE_VERSION",12];
kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_STREAM_STRUCTURE_VERSION.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_STREAM_STRUCTURE_VERSION.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
kha_audio2_ogg_vorbis_data_ReaderErrorType.CONTINUED_PACKET_FLAG_INVALID = ["CONTINUED_PACKET_FLAG_INVALID",13];
kha_audio2_ogg_vorbis_data_ReaderErrorType.CONTINUED_PACKET_FLAG_INVALID.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.CONTINUED_PACKET_FLAG_INVALID.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
kha_audio2_ogg_vorbis_data_ReaderErrorType.INCORRECT_STREAM_SERIAL_NUMBER = ["INCORRECT_STREAM_SERIAL_NUMBER",14];
kha_audio2_ogg_vorbis_data_ReaderErrorType.INCORRECT_STREAM_SERIAL_NUMBER.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.INCORRECT_STREAM_SERIAL_NUMBER.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE = ["INVALID_FIRST_PAGE",15];
kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
kha_audio2_ogg_vorbis_data_ReaderErrorType.BAD_PACKET_TYPE = ["BAD_PACKET_TYPE",16];
kha_audio2_ogg_vorbis_data_ReaderErrorType.BAD_PACKET_TYPE.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.BAD_PACKET_TYPE.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
kha_audio2_ogg_vorbis_data_ReaderErrorType.CANT_FIND_LAST_PAGE = ["CANT_FIND_LAST_PAGE",17];
kha_audio2_ogg_vorbis_data_ReaderErrorType.CANT_FIND_LAST_PAGE.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.CANT_FIND_LAST_PAGE.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
kha_audio2_ogg_vorbis_data_ReaderErrorType.SEEK_FAILED = ["SEEK_FAILED",18];
kha_audio2_ogg_vorbis_data_ReaderErrorType.SEEK_FAILED.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.SEEK_FAILED.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
kha_audio2_ogg_vorbis_data_ReaderErrorType.OTHER = ["OTHER",19];
kha_audio2_ogg_vorbis_data_ReaderErrorType.OTHER.toString = $estr;
kha_audio2_ogg_vorbis_data_ReaderErrorType.OTHER.__enum__ = kha_audio2_ogg_vorbis_data_ReaderErrorType;
var kha_audio2_ogg_vorbis_data_Residue = function() {
};
$hxClasses["kha.audio2.ogg.vorbis.data.Residue"] = kha_audio2_ogg_vorbis_data_Residue;
kha_audio2_ogg_vorbis_data_Residue.__name__ = true;
kha_audio2_ogg_vorbis_data_Residue.read = function(decodeState,codebooks) {
	var r = new kha_audio2_ogg_vorbis_data_Residue();
	var tmp;
	if(decodeState.validBits < 0) {
		tmp = 0;
	} else if(decodeState.validBits < 16) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 16)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else {
			var z = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			tmp = z;
		}
	} else {
		var z1 = decodeState.acc & 65535;
		decodeState.acc = decodeState.acc >>> 16;
		decodeState.validBits -= 16;
		tmp = z1;
	}
	r.type = tmp;
	if(r.type > 2) {
		throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Residue.hx", lineNumber : 29, className : "kha.audio2.ogg.vorbis.data.Residue", methodName : "read"}));
	}
	var this1 = new Array(64);
	var residueCascade = this1;
	var tmp1;
	if(decodeState.validBits < 0) {
		tmp1 = 0;
	} else if(decodeState.validBits < 24) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 24)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp1 = 0;
		} else {
			var z2 = decodeState.acc & 16777215;
			decodeState.acc = decodeState.acc >>> 24;
			decodeState.validBits -= 24;
			tmp1 = z2;
		}
	} else {
		var z3 = decodeState.acc & 16777215;
		decodeState.acc = decodeState.acc >>> 24;
		decodeState.validBits -= 24;
		tmp1 = z3;
	}
	r.begin = tmp1;
	var tmp2;
	if(decodeState.validBits < 0) {
		tmp2 = 0;
	} else if(decodeState.validBits < 24) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 24)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp2 = 0;
		} else {
			var z4 = decodeState.acc & 16777215;
			decodeState.acc = decodeState.acc >>> 24;
			decodeState.validBits -= 24;
			tmp2 = z4;
		}
	} else {
		var z5 = decodeState.acc & 16777215;
		decodeState.acc = decodeState.acc >>> 24;
		decodeState.validBits -= 24;
		tmp2 = z5;
	}
	r.end = tmp2;
	var tmp3;
	if(decodeState.validBits < 0) {
		tmp3 = 0;
	} else if(decodeState.validBits < 24) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 24)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp3 = 0;
		} else {
			var z6 = decodeState.acc & 16777215;
			decodeState.acc = decodeState.acc >>> 24;
			decodeState.validBits -= 24;
			tmp3 = z6;
		}
	} else {
		var z7 = decodeState.acc & 16777215;
		decodeState.acc = decodeState.acc >>> 24;
		decodeState.validBits -= 24;
		tmp3 = z7;
	}
	r.partSize = tmp3 + 1;
	var classifications;
	if(decodeState.validBits < 0) {
		classifications = 0;
	} else if(decodeState.validBits < 6) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 6)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			classifications = 0;
		} else {
			var z8 = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			classifications = z8;
		}
	} else {
		var z9 = decodeState.acc & 63;
		decodeState.acc = decodeState.acc >>> 6;
		decodeState.validBits -= 6;
		classifications = z9;
	}
	var classifications1 = r.classifications = classifications + 1;
	var tmp4;
	if(decodeState.validBits < 0) {
		tmp4 = 0;
	} else if(decodeState.validBits < 8) {
		if(decodeState.validBits == 0) {
			decodeState.acc = 0;
		}
		while(true) {
			if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			}
			if(!(decodeState.validBits < 8)) {
				break;
			}
		}
		if(decodeState.validBits < 0) {
			tmp4 = 0;
		} else {
			var z10 = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp4 = z10;
		}
	} else {
		var z11 = decodeState.acc & 255;
		decodeState.acc = decodeState.acc >>> 8;
		decodeState.validBits -= 8;
		tmp4 = z11;
	}
	r.classbook = tmp4;
	var _g1 = 0;
	var _g = r.classifications;
	while(_g1 < _g) {
		var j = _g1++;
		var highBits = 0;
		var lowBits;
		if(decodeState.validBits < 0) {
			lowBits = 0;
		} else if(decodeState.validBits < 3) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 3)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				lowBits = 0;
			} else {
				var z12 = decodeState.acc & 7;
				decodeState.acc = decodeState.acc >>> 3;
				decodeState.validBits -= 3;
				lowBits = z12;
			}
		} else {
			var z13 = decodeState.acc & 7;
			decodeState.acc = decodeState.acc >>> 3;
			decodeState.validBits -= 3;
			lowBits = z13;
		}
		var tmp5;
		if(decodeState.validBits < 0) {
			tmp5 = 0;
		} else if(decodeState.validBits < 1) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			while(true) {
				if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				}
				if(!(decodeState.validBits < 1)) {
					break;
				}
			}
			if(decodeState.validBits < 0) {
				tmp5 = 0;
			} else {
				var z14 = decodeState.acc & 1;
				decodeState.acc = decodeState.acc >>> 1;
				decodeState.validBits -= 1;
				tmp5 = z14;
			}
		} else {
			var z15 = decodeState.acc & 1;
			decodeState.acc = decodeState.acc >>> 1;
			decodeState.validBits -= 1;
			tmp5 = z15;
		}
		if(tmp5 != 0) {
			if(decodeState.validBits < 0) {
				highBits = 0;
			} else if(decodeState.validBits < 5) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				while(true) {
					if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					}
					if(!(decodeState.validBits < 5)) {
						break;
					}
				}
				if(decodeState.validBits < 0) {
					highBits = 0;
				} else {
					var z16 = decodeState.acc & 31;
					decodeState.acc = decodeState.acc >>> 5;
					decodeState.validBits -= 5;
					highBits = z16;
				}
			} else {
				var z17 = decodeState.acc & 31;
				decodeState.acc = decodeState.acc >>> 5;
				decodeState.validBits -= 5;
				highBits = z17;
			}
		}
		residueCascade[j] = highBits * 8 + lowBits;
	}
	var length = r.classifications;
	var this2 = new Array(length);
	r.residueBooks = this2;
	var _g11 = 0;
	var _g2 = r.classifications;
	while(_g11 < _g2) {
		var j1 = _g11++;
		var this3 = r.residueBooks;
		var this4 = new Array(8);
		this3[j1] = this4;
		var _g21 = 0;
		while(_g21 < 8) {
			var k = _g21++;
			if((residueCascade[j1] & 1 << k) != 0) {
				var this5 = r.residueBooks[j1];
				var val;
				if(decodeState.validBits < 0) {
					val = 0;
				} else if(decodeState.validBits < 8) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					while(true) {
						if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						}
						if(!(decodeState.validBits < 8)) {
							break;
						}
					}
					if(decodeState.validBits < 0) {
						val = 0;
					} else {
						var z18 = decodeState.acc & 255;
						decodeState.acc = decodeState.acc >>> 8;
						decodeState.validBits -= 8;
						val = z18;
					}
				} else {
					var z19 = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					val = z19;
				}
				this5[k] = val;
				if(r.residueBooks[j1][k] >= codebooks.length) {
					throw new js__$Boot_HaxeError(new kha_audio2_ogg_vorbis_data_ReaderError(kha_audio2_ogg_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "Residue.hx", lineNumber : 55, className : "kha.audio2.ogg.vorbis.data.Residue", methodName : "read"}));
				}
			} else {
				r.residueBooks[j1][k] = -1;
			}
		}
	}
	var el = codebooks[r.classbook].entries;
	var classwords = codebooks[r.classbook].dimensions;
	var this6 = new Array(el);
	r.classdata = this6;
	var _g12 = 0;
	var _g3 = el;
	while(_g12 < _g3) {
		var j2 = _g12++;
		var temp = j2;
		var k1 = classwords;
		var this7 = r.classdata;
		var this8 = new Array(classwords);
		var cd = this7[j2] = this8;
		while(--k1 >= 0) {
			cd[k1] = temp % classifications1;
			temp = temp / classifications1 | 0;
		}
	}
	return r;
};
kha_audio2_ogg_vorbis_data_Residue.prototype = {
	begin: null
	,end: null
	,partSize: null
	,classifications: null
	,classbook: null
	,classdata: null
	,residueBooks: null
	,type: null
	,decode: function(decodeState,header,residueBuffers,ch,n,doNotDecode,channelBuffers) {
		var codebooks = header.codebooks;
		var classwords = codebooks[this.classbook].dimensions;
		var nRead = this.end - this.begin;
		var partSize = this.partSize;
		var partRead = _$UInt_UInt_$Impl_$.toFloat(nRead) / _$UInt_UInt_$Impl_$.toFloat(partSize) | 0;
		var length = header.channel * partRead + 1;
		var this1 = new Array(length);
		var classifications = this1;
		var _g1 = 0;
		var _g = ch;
		while(_g1 < _g) {
			var i = _g1++;
			if(!doNotDecode[i]) {
				var buffer = residueBuffers[i];
				var _g3 = 0;
				var _g2 = buffer.length;
				while(_g3 < _g2) {
					var j = _g3++;
					buffer[j] = 0;
				}
			}
		}
		if(this.type == 2 && ch != 1) {
			var _g11 = 0;
			var _g4 = ch;
			while(_g11 < _g4) {
				var j1 = _g11++;
				if(!doNotDecode[j1]) {
					break;
				} else if(j1 == ch - 1) {
					return;
				}
			}
			var _g5 = 0;
			while(_g5 < 8) {
				var pass = _g5++;
				var pcount = 0;
				var classSet = 0;
				if(ch == 2) {
					while(pcount < partRead) {
						var z = this.begin + pcount * partSize;
						var cInter = z & 1;
						var pInter = z >>> 1;
						if(pass == 0) {
							var c = codebooks[this.classbook];
							if(decodeState.validBits < 10) {
								decodeState.prepHuffman();
							}
							var i1 = c.fastHuffman[decodeState.acc & 1023];
							var val;
							if(i1 >= 0) {
								var l = c.codewordLengths[i1];
								decodeState.acc = decodeState.acc >>> l;
								decodeState.validBits -= l;
								if(decodeState.validBits < 0) {
									decodeState.validBits = 0;
									val = -1;
								} else {
									val = i1;
								}
							} else {
								val = decodeState.decodeScalarRaw(c);
							}
							if(c.sparse) {
								val = c.sortedValues[val];
							}
							var q = val;
							if(q == -1) {
								return;
							}
							var i2 = classwords;
							while(--i2 >= 0) {
								classifications[i2 + pcount] = q % this.classifications;
								q = q / this.classifications | 0;
							}
						}
						var _g21 = 0;
						var _g12 = classwords;
						while(_g21 < _g12) {
							var i3 = _g21++;
							if(pcount >= partRead) {
								break;
							}
							var z1 = this.begin + pcount * partSize;
							var c1 = classifications[pcount];
							var b = this.residueBooks[c1][pass];
							if(b >= 0) {
								var book = codebooks[b];
								var result = book.decodeDeinterleaveRepeat(decodeState,residueBuffers,ch,cInter,pInter,n,partSize);
								if(result == null) {
									return;
								} else {
									cInter = result.cInter;
									pInter = result.pInter;
								}
							} else {
								z1 = z1 + partSize;
								cInter = z1 & 1;
								pInter = z1 >>> 1;
							}
							++pcount;
						}
					}
				} else if(ch == 1) {
					while(pcount < partRead) {
						var z2 = this.begin + pcount * partSize;
						var cInter1 = 0;
						var pInter1 = z2;
						if(pass == 0) {
							var c2 = codebooks[this.classbook];
							if(decodeState.validBits < 10) {
								decodeState.prepHuffman();
							}
							var i4 = c2.fastHuffman[decodeState.acc & 1023];
							var val1;
							if(i4 >= 0) {
								var l1 = c2.codewordLengths[i4];
								decodeState.acc = decodeState.acc >>> l1;
								decodeState.validBits -= l1;
								if(decodeState.validBits < 0) {
									decodeState.validBits = 0;
									val1 = -1;
								} else {
									val1 = i4;
								}
							} else {
								val1 = decodeState.decodeScalarRaw(c2);
							}
							if(c2.sparse) {
								val1 = c2.sortedValues[val1];
							}
							var q1 = val1;
							if(q1 == -1) {
								return;
							}
							var i5 = classwords;
							while(--i5 >= 0) {
								classifications[i5 + pcount] = q1 % this.classifications;
								q1 = q1 / this.classifications | 0;
							}
						}
						var _g22 = 0;
						var _g13 = classwords;
						while(_g22 < _g13) {
							var i6 = _g22++;
							if(pcount >= partRead) {
								break;
							}
							var z3 = this.begin + pcount * partSize;
							var b1 = this.residueBooks[classifications[pcount]][pass];
							if(b1 >= 0) {
								var book1 = codebooks[b1];
								var result1 = book1.decodeDeinterleaveRepeat(decodeState,residueBuffers,ch,cInter1,pInter1,n,partSize);
								if(result1 == null) {
									return;
								} else {
									cInter1 = result1.cInter;
									pInter1 = result1.pInter;
								}
							} else {
								z3 = z3 + partSize;
								cInter1 = 0;
								pInter1 = z3;
							}
							++pcount;
						}
					}
				} else {
					while(pcount < partRead) {
						var z4 = this.begin + pcount * partSize;
						var cInter2 = _$UInt_UInt_$Impl_$.toFloat(z4) % _$UInt_UInt_$Impl_$.toFloat(ch) | 0;
						var pInter2 = _$UInt_UInt_$Impl_$.toFloat(z4) / _$UInt_UInt_$Impl_$.toFloat(ch) | 0;
						if(pass == 0) {
							var c3 = codebooks[this.classbook];
							if(decodeState.validBits < 10) {
								decodeState.prepHuffman();
							}
							var i7 = c3.fastHuffman[decodeState.acc & 1023];
							var val2;
							if(i7 >= 0) {
								var l2 = c3.codewordLengths[i7];
								decodeState.acc = decodeState.acc >>> l2;
								decodeState.validBits -= l2;
								if(decodeState.validBits < 0) {
									decodeState.validBits = 0;
									val2 = -1;
								} else {
									val2 = i7;
								}
							} else {
								val2 = decodeState.decodeScalarRaw(c3);
							}
							if(c3.sparse) {
								val2 = c3.sortedValues[val2];
							}
							var q2 = val2;
							if(q2 == -1) {
								return;
							}
							var i8 = classwords;
							while(--i8 >= 0) {
								classifications[i8 + pcount] = q2 % this.classifications;
								q2 = q2 / this.classifications | 0;
							}
						}
						var _g23 = 0;
						var _g14 = classwords;
						while(_g23 < _g14) {
							var i9 = _g23++;
							if(pcount >= partRead) {
								break;
							}
							var z5 = this.begin + pcount * partSize;
							var b2 = this.residueBooks[classifications[pcount]][pass];
							if(b2 >= 0) {
								var book2 = codebooks[b2];
								var result2 = book2.decodeDeinterleaveRepeat(decodeState,residueBuffers,ch,cInter2,pInter2,n,partSize);
								if(result2 == null) {
									return;
								} else {
									cInter2 = result2.cInter;
									pInter2 = result2.pInter;
								}
							} else {
								z5 = z5 + partSize;
								cInter2 = _$UInt_UInt_$Impl_$.toFloat(z5) % _$UInt_UInt_$Impl_$.toFloat(ch) | 0;
								pInter2 = _$UInt_UInt_$Impl_$.toFloat(z5) / _$UInt_UInt_$Impl_$.toFloat(ch) | 0;
							}
							++pcount;
						}
					}
				}
			}
			return;
		}
		var _g6 = 0;
		while(_g6 < 8) {
			var pass1 = _g6++;
			var pcount1 = 0;
			var classSet1 = 0;
			while(pcount1 < partRead) {
				if(pass1 == 0) {
					var _g24 = 0;
					var _g15 = ch;
					while(_g24 < _g15) {
						var j2 = _g24++;
						if(!doNotDecode[j2]) {
							var c4 = codebooks[this.classbook];
							if(decodeState.validBits < 10) {
								decodeState.prepHuffman();
							}
							var i10 = c4.fastHuffman[decodeState.acc & 1023];
							var val3;
							if(i10 >= 0) {
								var l3 = c4.codewordLengths[i10];
								decodeState.acc = decodeState.acc >>> l3;
								decodeState.validBits -= l3;
								if(decodeState.validBits < 0) {
									decodeState.validBits = 0;
									val3 = -1;
								} else {
									val3 = i10;
								}
							} else {
								val3 = decodeState.decodeScalarRaw(c4);
							}
							if(c4.sparse) {
								val3 = c4.sortedValues[val3];
							}
							var temp = val3;
							if(temp == -1) {
								return;
							}
							var i11 = classwords;
							while(--i11 >= 0) {
								classifications[j2 * partRead + i11 + pcount1] = temp % this.classifications;
								temp = temp / this.classifications | 0;
							}
						}
					}
				}
				var _g25 = 0;
				var _g16 = classwords;
				while(_g25 < _g16) {
					var i12 = _g25++;
					if(pcount1 >= partRead) {
						break;
					}
					var _g41 = 0;
					var _g31 = ch;
					while(_g41 < _g31) {
						var j3 = _g41++;
						if(!doNotDecode[j3]) {
							var c5 = classifications[j3 * partRead + pcount1];
							var b3 = this.residueBooks[c5][pass1];
							if(b3 >= 0) {
								var target = residueBuffers[j3];
								var offset = this.begin + pcount1 * partSize;
								var n1 = partSize;
								var book3 = codebooks[b3];
								if(!book3.residueDecode(decodeState,target,offset,n1,this.type)) {
									return;
								}
							}
						}
					}
					++pcount1;
				}
			}
		}
	}
	,__class__: kha_audio2_ogg_vorbis_data_Residue
};
var kha_audio2_ogg_vorbis_data_Setting = function() { };
$hxClasses["kha.audio2.ogg.vorbis.data.Setting"] = kha_audio2_ogg_vorbis_data_Setting;
kha_audio2_ogg_vorbis_data_Setting.__name__ = true;
var kha_graphics1_Graphics = function() { };
$hxClasses["kha.graphics1.Graphics"] = kha_graphics1_Graphics;
kha_graphics1_Graphics.__name__ = true;
kha_graphics1_Graphics.prototype = {
	begin: null
	,end: null
	,setPixel: null
	,__class__: kha_graphics1_Graphics
};
var kha_graphics2_Graphics = function() {
	this.transformations = [];
	this.transformations.push(new kha_math_FastMatrix3(1,0,0,0,1,0,0,0,1));
	this.opacities = [];
	this.opacities.push(1);
	this.myFontSize = 12;
	this.pipe = null;
};
$hxClasses["kha.graphics2.Graphics"] = kha_graphics2_Graphics;
kha_graphics2_Graphics.__name__ = true;
kha_graphics2_Graphics.prototype = {
	begin: function(clear,clearColor) {
		if(clear == null) {
			clear = true;
		}
	}
	,end: function() {
	}
	,flush: function() {
	}
	,clear: function(color) {
	}
	,drawImage: function(img,x,y) {
		this.drawSubImage(img,x,y,0,0,img.get_width(),img.get_height());
	}
	,drawSubImage: function(img,x,y,sx,sy,sw,sh) {
		this.drawScaledSubImage(img,sx,sy,sw,sh,x,y,sw,sh);
	}
	,drawScaledImage: function(img,dx,dy,dw,dh) {
		this.drawScaledSubImage(img,0,0,img.get_width(),img.get_height(),dx,dy,dw,dh);
	}
	,drawScaledSubImage: function(image,sx,sy,sw,sh,dx,dy,dw,dh) {
	}
	,drawRect: function(x,y,width,height,strength) {
		if(strength == null) {
			strength = 1.0;
		}
	}
	,fillRect: function(x,y,width,height) {
	}
	,drawString: function(text,x,y) {
	}
	,drawCharacters: function(text,start,length,x,y) {
	}
	,drawLine: function(x1,y1,x2,y2,strength) {
		if(strength == null) {
			strength = 1.0;
		}
	}
	,drawVideo: function(video,x,y,width,height) {
	}
	,fillTriangle: function(x1,y1,x2,y2,x3,y3) {
	}
	,get_imageScaleQuality: function() {
		return kha_graphics2_ImageScaleQuality.Low;
	}
	,set_imageScaleQuality: function(value) {
		return kha_graphics2_ImageScaleQuality.High;
	}
	,get_mipmapScaleQuality: function() {
		return kha_graphics2_ImageScaleQuality.Low;
	}
	,set_mipmapScaleQuality: function(value) {
		return kha_graphics2_ImageScaleQuality.High;
	}
	,get_color: function() {
		return -16777216;
	}
	,set_color: function(color) {
		return -16777216;
	}
	,get_font: function() {
		return null;
	}
	,set_font: function(font) {
		return null;
	}
	,get_fontSize: function() {
		return this.myFontSize;
	}
	,set_fontSize: function(value) {
		return this.myFontSize = value;
	}
	,get_fontGlyphs: function() {
		return kha_Kravur.glyphs;
	}
	,set_fontGlyphs: function(value) {
		return kha_Kravur.glyphs = value;
	}
	,pushTransformation: function(transformation) {
		var trans = new kha_math_FastMatrix3(1,0,0,0,1,0,0,0,1);
		trans._00 = transformation._00;
		trans._10 = transformation._10;
		trans._20 = transformation._20;
		trans._01 = transformation._01;
		trans._11 = transformation._11;
		trans._21 = transformation._21;
		trans._02 = transformation._02;
		trans._12 = transformation._12;
		trans._22 = transformation._22;
		this.setTransformation(trans);
		this.transformations.push(trans);
	}
	,popTransformation: function() {
		var ret = this.transformations.pop();
		this.setTransformation(this.transformations[this.transformations.length - 1]);
		return ret;
	}
	,get_transformation: function() {
		return this.transformations[this.transformations.length - 1];
	}
	,set_transformation: function(transformation) {
		this.setTransformation(transformation);
		var _this = this.transformations[this.transformations.length - 1];
		_this._00 = transformation._00;
		_this._10 = transformation._10;
		_this._20 = transformation._20;
		_this._01 = transformation._01;
		_this._11 = transformation._11;
		_this._21 = transformation._21;
		_this._02 = transformation._02;
		_this._12 = transformation._12;
		_this._22 = transformation._22;
		return transformation;
	}
	,translation: function(tx,ty) {
		var _this__22;
		var _this__21;
		var _this__20;
		var _this__12;
		var _this__11;
		var _this__10;
		var _this__02;
		var _this__01;
		var _this__00 = 1;
		_this__10 = 0;
		_this__20 = tx;
		_this__01 = 0;
		_this__11 = 1;
		_this__21 = ty;
		_this__02 = 0;
		_this__12 = 0;
		_this__22 = 1;
		var m = this.transformations[this.transformations.length - 1];
		return new kha_math_FastMatrix3(_this__00 * m._00 + _this__10 * m._01 + _this__20 * m._02,_this__00 * m._10 + _this__10 * m._11 + _this__20 * m._12,_this__00 * m._20 + _this__10 * m._21 + _this__20 * m._22,_this__01 * m._00 + _this__11 * m._01 + _this__21 * m._02,_this__01 * m._10 + _this__11 * m._11 + _this__21 * m._12,_this__01 * m._20 + _this__11 * m._21 + _this__21 * m._22,_this__02 * m._00 + _this__12 * m._01 + _this__22 * m._02,_this__02 * m._10 + _this__12 * m._11 + _this__22 * m._12,_this__02 * m._20 + _this__12 * m._21 + _this__22 * m._22);
	}
	,translate: function(tx,ty) {
		var _this__22;
		var _this__21;
		var _this__20;
		var _this__12;
		var _this__11;
		var _this__10;
		var _this__02;
		var _this__01;
		var _this__00 = 1;
		_this__10 = 0;
		_this__20 = tx;
		_this__01 = 0;
		_this__11 = 1;
		_this__21 = ty;
		_this__02 = 0;
		_this__12 = 0;
		_this__22 = 1;
		var m = this.transformations[this.transformations.length - 1];
		var transformation = new kha_math_FastMatrix3(_this__00 * m._00 + _this__10 * m._01 + _this__20 * m._02,_this__00 * m._10 + _this__10 * m._11 + _this__20 * m._12,_this__00 * m._20 + _this__10 * m._21 + _this__20 * m._22,_this__01 * m._00 + _this__11 * m._01 + _this__21 * m._02,_this__01 * m._10 + _this__11 * m._11 + _this__21 * m._12,_this__01 * m._20 + _this__11 * m._21 + _this__21 * m._22,_this__02 * m._00 + _this__12 * m._01 + _this__22 * m._02,_this__02 * m._10 + _this__12 * m._11 + _this__22 * m._12,_this__02 * m._20 + _this__12 * m._21 + _this__22 * m._22);
		this.setTransformation(transformation);
		var _this = this.transformations[this.transformations.length - 1];
		_this._00 = transformation._00;
		_this._10 = transformation._10;
		_this._20 = transformation._20;
		_this._01 = transformation._01;
		_this._11 = transformation._11;
		_this._21 = transformation._21;
		_this._02 = transformation._02;
		_this._12 = transformation._12;
		_this._22 = transformation._22;
	}
	,pushTranslation: function(tx,ty) {
		var _this__22;
		var _this__21;
		var _this__20;
		var _this__12;
		var _this__11;
		var _this__10;
		var _this__02;
		var _this__01;
		var _this__00 = 1;
		_this__10 = 0;
		_this__20 = tx;
		_this__01 = 0;
		_this__11 = 1;
		_this__21 = ty;
		_this__02 = 0;
		_this__12 = 0;
		_this__22 = 1;
		var m = this.transformations[this.transformations.length - 1];
		this.pushTransformation(new kha_math_FastMatrix3(_this__00 * m._00 + _this__10 * m._01 + _this__20 * m._02,_this__00 * m._10 + _this__10 * m._11 + _this__20 * m._12,_this__00 * m._20 + _this__10 * m._21 + _this__20 * m._22,_this__01 * m._00 + _this__11 * m._01 + _this__21 * m._02,_this__01 * m._10 + _this__11 * m._11 + _this__21 * m._12,_this__01 * m._20 + _this__11 * m._21 + _this__21 * m._22,_this__02 * m._00 + _this__12 * m._01 + _this__22 * m._02,_this__02 * m._10 + _this__12 * m._11 + _this__22 * m._12,_this__02 * m._20 + _this__12 * m._21 + _this__22 * m._22));
	}
	,rotation: function(angle,centerx,centery) {
		var _this__22;
		var _this__21;
		var _this__20;
		var _this__12;
		var _this__11;
		var _this__10;
		var _this__02;
		var _this__01;
		var _this__00;
		var _this__221;
		var _this__211;
		var _this__201;
		var _this__121;
		var _this__111;
		var _this__101;
		var _this__021;
		var _this__011;
		var _this__001;
		var _this__222;
		var _this__212;
		var _this__202;
		var _this__122;
		var _this__112;
		var _this__102;
		var _this__022;
		var _this__012;
		var _this__002 = 1;
		_this__102 = 0;
		_this__202 = centerx;
		_this__012 = 0;
		_this__112 = 1;
		_this__212 = centery;
		_this__022 = 0;
		_this__122 = 0;
		_this__222 = 1;
		var m__22;
		var m__21;
		var m__20;
		var m__12;
		var m__11;
		var m__10;
		var m__02;
		var m__01;
		var m__00 = Math.cos(angle);
		m__10 = -Math.sin(angle);
		m__20 = 0;
		m__01 = Math.sin(angle);
		m__11 = Math.cos(angle);
		m__21 = 0;
		m__02 = 0;
		m__12 = 0;
		m__22 = 1;
		_this__001 = _this__002 * m__00 + _this__102 * m__01 + _this__202 * m__02;
		_this__101 = _this__002 * m__10 + _this__102 * m__11 + _this__202 * m__12;
		_this__201 = _this__002 * m__20 + _this__102 * m__21 + _this__202 * m__22;
		_this__011 = _this__012 * m__00 + _this__112 * m__01 + _this__212 * m__02;
		_this__111 = _this__012 * m__10 + _this__112 * m__11 + _this__212 * m__12;
		_this__211 = _this__012 * m__20 + _this__112 * m__21 + _this__212 * m__22;
		_this__021 = _this__022 * m__00 + _this__122 * m__01 + _this__222 * m__02;
		_this__121 = _this__022 * m__10 + _this__122 * m__11 + _this__222 * m__12;
		_this__221 = _this__022 * m__20 + _this__122 * m__21 + _this__222 * m__22;
		var m__221;
		var m__211;
		var m__201;
		var m__121;
		var m__111;
		var m__101;
		var m__021;
		var m__011;
		var m__001 = 1;
		m__101 = 0;
		m__201 = -centerx;
		m__011 = 0;
		m__111 = 1;
		m__211 = -centery;
		m__021 = 0;
		m__121 = 0;
		m__221 = 1;
		_this__00 = _this__001 * m__001 + _this__101 * m__011 + _this__201 * m__021;
		_this__10 = _this__001 * m__101 + _this__101 * m__111 + _this__201 * m__121;
		_this__20 = _this__001 * m__201 + _this__101 * m__211 + _this__201 * m__221;
		_this__01 = _this__011 * m__001 + _this__111 * m__011 + _this__211 * m__021;
		_this__11 = _this__011 * m__101 + _this__111 * m__111 + _this__211 * m__121;
		_this__21 = _this__011 * m__201 + _this__111 * m__211 + _this__211 * m__221;
		_this__02 = _this__021 * m__001 + _this__121 * m__011 + _this__221 * m__021;
		_this__12 = _this__021 * m__101 + _this__121 * m__111 + _this__221 * m__121;
		_this__22 = _this__021 * m__201 + _this__121 * m__211 + _this__221 * m__221;
		var m = this.transformations[this.transformations.length - 1];
		return new kha_math_FastMatrix3(_this__00 * m._00 + _this__10 * m._01 + _this__20 * m._02,_this__00 * m._10 + _this__10 * m._11 + _this__20 * m._12,_this__00 * m._20 + _this__10 * m._21 + _this__20 * m._22,_this__01 * m._00 + _this__11 * m._01 + _this__21 * m._02,_this__01 * m._10 + _this__11 * m._11 + _this__21 * m._12,_this__01 * m._20 + _this__11 * m._21 + _this__21 * m._22,_this__02 * m._00 + _this__12 * m._01 + _this__22 * m._02,_this__02 * m._10 + _this__12 * m._11 + _this__22 * m._12,_this__02 * m._20 + _this__12 * m._21 + _this__22 * m._22);
	}
	,rotate: function(angle,centerx,centery) {
		var temp__22;
		var temp__21;
		var temp__20;
		var temp__12;
		var temp__11;
		var temp__10;
		var temp__02;
		var temp__01;
		var temp__00;
		var _this__22;
		var _this__21;
		var _this__20;
		var _this__12;
		var _this__11;
		var _this__10;
		var _this__02;
		var _this__01;
		var _this__00;
		var _this__221;
		var _this__211;
		var _this__201;
		var _this__121;
		var _this__111;
		var _this__101;
		var _this__021;
		var _this__011;
		var _this__001;
		var _this__222;
		var _this__212;
		var _this__202;
		var _this__122;
		var _this__112;
		var _this__102;
		var _this__022;
		var _this__012;
		var _this__002 = 1;
		_this__102 = 0;
		_this__202 = centerx;
		_this__012 = 0;
		_this__112 = 1;
		_this__212 = centery;
		_this__022 = 0;
		_this__122 = 0;
		_this__222 = 1;
		var m__22;
		var m__21;
		var m__20;
		var m__12;
		var m__11;
		var m__10;
		var m__02;
		var m__01;
		var m__00 = Math.cos(angle);
		m__10 = -Math.sin(angle);
		m__20 = 0;
		m__01 = Math.sin(angle);
		m__11 = Math.cos(angle);
		m__21 = 0;
		m__02 = 0;
		m__12 = 0;
		m__22 = 1;
		_this__001 = _this__002 * m__00 + _this__102 * m__01 + _this__202 * m__02;
		_this__101 = _this__002 * m__10 + _this__102 * m__11 + _this__202 * m__12;
		_this__201 = _this__002 * m__20 + _this__102 * m__21 + _this__202 * m__22;
		_this__011 = _this__012 * m__00 + _this__112 * m__01 + _this__212 * m__02;
		_this__111 = _this__012 * m__10 + _this__112 * m__11 + _this__212 * m__12;
		_this__211 = _this__012 * m__20 + _this__112 * m__21 + _this__212 * m__22;
		_this__021 = _this__022 * m__00 + _this__122 * m__01 + _this__222 * m__02;
		_this__121 = _this__022 * m__10 + _this__122 * m__11 + _this__222 * m__12;
		_this__221 = _this__022 * m__20 + _this__122 * m__21 + _this__222 * m__22;
		var m__221;
		var m__211;
		var m__201;
		var m__121;
		var m__111;
		var m__101;
		var m__021;
		var m__011;
		var m__001 = 1;
		m__101 = 0;
		m__201 = -centerx;
		m__011 = 0;
		m__111 = 1;
		m__211 = -centery;
		m__021 = 0;
		m__121 = 0;
		m__221 = 1;
		_this__00 = _this__001 * m__001 + _this__101 * m__011 + _this__201 * m__021;
		_this__10 = _this__001 * m__101 + _this__101 * m__111 + _this__201 * m__121;
		_this__20 = _this__001 * m__201 + _this__101 * m__211 + _this__201 * m__221;
		_this__01 = _this__011 * m__001 + _this__111 * m__011 + _this__211 * m__021;
		_this__11 = _this__011 * m__101 + _this__111 * m__111 + _this__211 * m__121;
		_this__21 = _this__011 * m__201 + _this__111 * m__211 + _this__211 * m__221;
		_this__02 = _this__021 * m__001 + _this__121 * m__011 + _this__221 * m__021;
		_this__12 = _this__021 * m__101 + _this__121 * m__111 + _this__221 * m__121;
		_this__22 = _this__021 * m__201 + _this__121 * m__211 + _this__221 * m__221;
		var m = this.transformations[this.transformations.length - 1];
		temp__00 = _this__00 * m._00 + _this__10 * m._01 + _this__20 * m._02;
		temp__10 = _this__00 * m._10 + _this__10 * m._11 + _this__20 * m._12;
		temp__20 = _this__00 * m._20 + _this__10 * m._21 + _this__20 * m._22;
		temp__01 = _this__01 * m._00 + _this__11 * m._01 + _this__21 * m._02;
		temp__11 = _this__01 * m._10 + _this__11 * m._11 + _this__21 * m._12;
		temp__21 = _this__01 * m._20 + _this__11 * m._21 + _this__21 * m._22;
		temp__02 = _this__02 * m._00 + _this__12 * m._01 + _this__22 * m._02;
		temp__12 = _this__02 * m._10 + _this__12 * m._11 + _this__22 * m._12;
		temp__22 = _this__02 * m._20 + _this__12 * m._21 + _this__22 * m._22;
		this.transformations[this.transformations.length - 1]._00 = temp__00;
		this.transformations[this.transformations.length - 1]._01 = temp__01;
		this.transformations[this.transformations.length - 1]._02 = temp__02;
		this.transformations[this.transformations.length - 1]._10 = temp__10;
		this.transformations[this.transformations.length - 1]._11 = temp__11;
		this.transformations[this.transformations.length - 1]._12 = temp__12;
		this.transformations[this.transformations.length - 1]._20 = temp__20;
		this.transformations[this.transformations.length - 1]._21 = temp__21;
		this.transformations[this.transformations.length - 1]._22 = temp__22;
	}
	,pushRotation: function(angle,centerx,centery) {
		var _this__22;
		var _this__21;
		var _this__20;
		var _this__12;
		var _this__11;
		var _this__10;
		var _this__02;
		var _this__01;
		var _this__00;
		var _this__221;
		var _this__211;
		var _this__201;
		var _this__121;
		var _this__111;
		var _this__101;
		var _this__021;
		var _this__011;
		var _this__001;
		var _this__222;
		var _this__212;
		var _this__202;
		var _this__122;
		var _this__112;
		var _this__102;
		var _this__022;
		var _this__012;
		var _this__002 = 1;
		_this__102 = 0;
		_this__202 = centerx;
		_this__012 = 0;
		_this__112 = 1;
		_this__212 = centery;
		_this__022 = 0;
		_this__122 = 0;
		_this__222 = 1;
		var m__22;
		var m__21;
		var m__20;
		var m__12;
		var m__11;
		var m__10;
		var m__02;
		var m__01;
		var m__00 = Math.cos(angle);
		m__10 = -Math.sin(angle);
		m__20 = 0;
		m__01 = Math.sin(angle);
		m__11 = Math.cos(angle);
		m__21 = 0;
		m__02 = 0;
		m__12 = 0;
		m__22 = 1;
		_this__001 = _this__002 * m__00 + _this__102 * m__01 + _this__202 * m__02;
		_this__101 = _this__002 * m__10 + _this__102 * m__11 + _this__202 * m__12;
		_this__201 = _this__002 * m__20 + _this__102 * m__21 + _this__202 * m__22;
		_this__011 = _this__012 * m__00 + _this__112 * m__01 + _this__212 * m__02;
		_this__111 = _this__012 * m__10 + _this__112 * m__11 + _this__212 * m__12;
		_this__211 = _this__012 * m__20 + _this__112 * m__21 + _this__212 * m__22;
		_this__021 = _this__022 * m__00 + _this__122 * m__01 + _this__222 * m__02;
		_this__121 = _this__022 * m__10 + _this__122 * m__11 + _this__222 * m__12;
		_this__221 = _this__022 * m__20 + _this__122 * m__21 + _this__222 * m__22;
		var m__221;
		var m__211;
		var m__201;
		var m__121;
		var m__111;
		var m__101;
		var m__021;
		var m__011;
		var m__001 = 1;
		m__101 = 0;
		m__201 = -centerx;
		m__011 = 0;
		m__111 = 1;
		m__211 = -centery;
		m__021 = 0;
		m__121 = 0;
		m__221 = 1;
		_this__00 = _this__001 * m__001 + _this__101 * m__011 + _this__201 * m__021;
		_this__10 = _this__001 * m__101 + _this__101 * m__111 + _this__201 * m__121;
		_this__20 = _this__001 * m__201 + _this__101 * m__211 + _this__201 * m__221;
		_this__01 = _this__011 * m__001 + _this__111 * m__011 + _this__211 * m__021;
		_this__11 = _this__011 * m__101 + _this__111 * m__111 + _this__211 * m__121;
		_this__21 = _this__011 * m__201 + _this__111 * m__211 + _this__211 * m__221;
		_this__02 = _this__021 * m__001 + _this__121 * m__011 + _this__221 * m__021;
		_this__12 = _this__021 * m__101 + _this__121 * m__111 + _this__221 * m__121;
		_this__22 = _this__021 * m__201 + _this__121 * m__211 + _this__221 * m__221;
		var m = this.transformations[this.transformations.length - 1];
		this.pushTransformation(new kha_math_FastMatrix3(_this__00 * m._00 + _this__10 * m._01 + _this__20 * m._02,_this__00 * m._10 + _this__10 * m._11 + _this__20 * m._12,_this__00 * m._20 + _this__10 * m._21 + _this__20 * m._22,_this__01 * m._00 + _this__11 * m._01 + _this__21 * m._02,_this__01 * m._10 + _this__11 * m._11 + _this__21 * m._12,_this__01 * m._20 + _this__11 * m._21 + _this__21 * m._22,_this__02 * m._00 + _this__12 * m._01 + _this__22 * m._02,_this__02 * m._10 + _this__12 * m._11 + _this__22 * m._12,_this__02 * m._20 + _this__12 * m._21 + _this__22 * m._22));
	}
	,pushOpacity: function(opacity) {
		this.setOpacity(opacity);
		this.opacities.push(opacity);
	}
	,popOpacity: function() {
		var ret = this.opacities.pop();
		this.setOpacity(this.get_opacity());
		return ret;
	}
	,get_opacity: function() {
		return this.opacities[this.opacities.length - 1];
	}
	,set_opacity: function(opacity) {
		this.setOpacity(opacity);
		return this.opacities[this.opacities.length - 1] = opacity;
	}
	,scissor: function(x,y,width,height) {
	}
	,disableScissor: function() {
	}
	,pipe: null
	,get_pipeline: function() {
		return this.pipe;
	}
	,set_pipeline: function(pipeline) {
		this.setPipeline(pipeline);
		return this.pipe = pipeline;
	}
	,transformations: null
	,opacities: null
	,myFontSize: null
	,setTransformation: function(transformation) {
	}
	,setOpacity: function(opacity) {
	}
	,setPipeline: function(pipeline) {
	}
	,__class__: kha_graphics2_Graphics
};
var kha_graphics2_Graphics1 = function(canvas) {
	this.canvas = canvas;
};
$hxClasses["kha.graphics2.Graphics1"] = kha_graphics2_Graphics1;
kha_graphics2_Graphics1.__name__ = true;
kha_graphics2_Graphics1.__interfaces__ = [kha_graphics1_Graphics];
kha_graphics2_Graphics1.prototype = {
	canvas: null
	,texture: null
	,pixels: null
	,begin: function() {
		if(this.texture == null) {
			this.texture = kha_Image.create(this.canvas.get_width(),this.canvas.get_height(),kha_graphics4_TextureFormat.RGBA32,kha_graphics4_Usage.ReadableUsage);
		}
		this.pixels = this.texture.lock();
	}
	,end: function() {
		this.texture.unlock();
		this.canvas.get_g2().begin();
		this.canvas.get_g2().drawImage(this.texture,0,0);
		this.canvas.get_g2().end();
	}
	,setPixel: function(x,y,color) {
		this.pixels.setInt32(y * this.texture.get_realWidth() * 4 + x * 4,kha__$Color_Color_$Impl_$.fromBytes(color & 255,(color & 65280) >>> 8,(color & 16711680) >>> 16,color >>> 24));
	}
	,__class__: kha_graphics2_Graphics1
};
var kha_graphics2_ImageScaleQuality = $hxClasses["kha.graphics2.ImageScaleQuality"] = { __ename__ : true, __constructs__ : ["Low","High"] };
kha_graphics2_ImageScaleQuality.Low = ["Low",0];
kha_graphics2_ImageScaleQuality.Low.toString = $estr;
kha_graphics2_ImageScaleQuality.Low.__enum__ = kha_graphics2_ImageScaleQuality;
kha_graphics2_ImageScaleQuality.High = ["High",1];
kha_graphics2_ImageScaleQuality.High.toString = $estr;
kha_graphics2_ImageScaleQuality.High.__enum__ = kha_graphics2_ImageScaleQuality;
var kha_graphics2_truetype_VectorOfIntPointer = function() {
};
$hxClasses["kha.graphics2.truetype.VectorOfIntPointer"] = kha_graphics2_truetype_VectorOfIntPointer;
kha_graphics2_truetype_VectorOfIntPointer.__name__ = true;
kha_graphics2_truetype_VectorOfIntPointer.prototype = {
	value: null
	,__class__: kha_graphics2_truetype_VectorOfIntPointer
};
var kha_graphics2_truetype_Stbtt_$temp_$rect = function() {
};
$hxClasses["kha.graphics2.truetype.Stbtt_temp_rect"] = kha_graphics2_truetype_Stbtt_$temp_$rect;
kha_graphics2_truetype_Stbtt_$temp_$rect.__name__ = true;
kha_graphics2_truetype_Stbtt_$temp_$rect.prototype = {
	x0: null
	,y0: null
	,x1: null
	,y1: null
	,__class__: kha_graphics2_truetype_Stbtt_$temp_$rect
};
var kha_graphics2_truetype_Stbtt_$temp_$glyph_$h_$metrics = function() {
};
$hxClasses["kha.graphics2.truetype.Stbtt_temp_glyph_h_metrics"] = kha_graphics2_truetype_Stbtt_$temp_$glyph_$h_$metrics;
kha_graphics2_truetype_Stbtt_$temp_$glyph_$h_$metrics.__name__ = true;
kha_graphics2_truetype_Stbtt_$temp_$glyph_$h_$metrics.prototype = {
	advanceWidth: null
	,leftSideBearing: null
	,__class__: kha_graphics2_truetype_Stbtt_$temp_$glyph_$h_$metrics
};
var kha_graphics2_truetype_Stbtt_$temp_$font_$v_$metrics = function() {
};
$hxClasses["kha.graphics2.truetype.Stbtt_temp_font_v_metrics"] = kha_graphics2_truetype_Stbtt_$temp_$font_$v_$metrics;
kha_graphics2_truetype_Stbtt_$temp_$font_$v_$metrics.__name__ = true;
kha_graphics2_truetype_Stbtt_$temp_$font_$v_$metrics.prototype = {
	ascent: null
	,descent: null
	,lineGap: null
	,__class__: kha_graphics2_truetype_Stbtt_$temp_$font_$v_$metrics
};
var kha_graphics2_truetype_Stbtt_$temp_$region = function() {
};
$hxClasses["kha.graphics2.truetype.Stbtt_temp_region"] = kha_graphics2_truetype_Stbtt_$temp_$region;
kha_graphics2_truetype_Stbtt_$temp_$region.__name__ = true;
kha_graphics2_truetype_Stbtt_$temp_$region.prototype = {
	width: null
	,height: null
	,xoff: null
	,yoff: null
	,__class__: kha_graphics2_truetype_Stbtt_$temp_$region
};
var kha_graphics2_truetype_Stbtt_$bakedchar = function() {
};
$hxClasses["kha.graphics2.truetype.Stbtt_bakedchar"] = kha_graphics2_truetype_Stbtt_$bakedchar;
kha_graphics2_truetype_Stbtt_$bakedchar.__name__ = true;
kha_graphics2_truetype_Stbtt_$bakedchar.prototype = {
	x0: null
	,y0: null
	,x1: null
	,y1: null
	,xoff: null
	,yoff: null
	,xadvance: null
	,__class__: kha_graphics2_truetype_Stbtt_$bakedchar
};
var kha_graphics2_truetype_Stbtt_$aligned_$quad = function() { };
$hxClasses["kha.graphics2.truetype.Stbtt_aligned_quad"] = kha_graphics2_truetype_Stbtt_$aligned_$quad;
kha_graphics2_truetype_Stbtt_$aligned_$quad.__name__ = true;
kha_graphics2_truetype_Stbtt_$aligned_$quad.prototype = {
	x0: null
	,y0: null
	,s0: null
	,t0: null
	,x1: null
	,y1: null
	,s1: null
	,t1: null
	,__class__: kha_graphics2_truetype_Stbtt_$aligned_$quad
};
var kha_graphics2_truetype_Stbtt_$packedchar = function() { };
$hxClasses["kha.graphics2.truetype.Stbtt_packedchar"] = kha_graphics2_truetype_Stbtt_$packedchar;
kha_graphics2_truetype_Stbtt_$packedchar.__name__ = true;
kha_graphics2_truetype_Stbtt_$packedchar.prototype = {
	x0: null
	,y0: null
	,x1: null
	,y1: null
	,xoff: null
	,yoff: null
	,xadvance: null
	,xoff2: null
	,yoff2: null
	,__class__: kha_graphics2_truetype_Stbtt_$packedchar
};
var kha_graphics2_truetype_Stbtt_$pack_$range = function() { };
$hxClasses["kha.graphics2.truetype.Stbtt_pack_range"] = kha_graphics2_truetype_Stbtt_$pack_$range;
kha_graphics2_truetype_Stbtt_$pack_$range.__name__ = true;
kha_graphics2_truetype_Stbtt_$pack_$range.prototype = {
	font_size: null
	,first_unicode_codepoint_in_range: null
	,array_of_unicode_codepoints: null
	,num_chars: null
	,chardata_for_range: null
	,h_oversample: null
	,v_oversample: null
	,__class__: kha_graphics2_truetype_Stbtt_$pack_$range
};
var kha_graphics2_truetype_Stbtt_$pack_$context = function() { };
$hxClasses["kha.graphics2.truetype.Stbtt_pack_context"] = kha_graphics2_truetype_Stbtt_$pack_$context;
kha_graphics2_truetype_Stbtt_$pack_$context.__name__ = true;
kha_graphics2_truetype_Stbtt_$pack_$context.prototype = {
	width: null
	,height: null
	,stride_in_bytes: null
	,padding: null
	,h_oversample: null
	,v_oversample: null
	,pixels: null
	,__class__: kha_graphics2_truetype_Stbtt_$pack_$context
};
var kha_graphics2_truetype_Stbtt_$fontinfo = function() {
};
$hxClasses["kha.graphics2.truetype.Stbtt_fontinfo"] = kha_graphics2_truetype_Stbtt_$fontinfo;
kha_graphics2_truetype_Stbtt_$fontinfo.__name__ = true;
kha_graphics2_truetype_Stbtt_$fontinfo.prototype = {
	data: null
	,fontstart: null
	,numGlyphs: null
	,loca: null
	,head: null
	,glyf: null
	,hhea: null
	,hmtx: null
	,kern: null
	,index_map: null
	,indexToLocFormat: null
	,__class__: kha_graphics2_truetype_Stbtt_$fontinfo
};
var kha_graphics2_truetype_Stbtt_$vertex = function() {
};
$hxClasses["kha.graphics2.truetype.Stbtt_vertex"] = kha_graphics2_truetype_Stbtt_$vertex;
kha_graphics2_truetype_Stbtt_$vertex.__name__ = true;
kha_graphics2_truetype_Stbtt_$vertex.prototype = {
	x: null
	,y: null
	,cx: null
	,cy: null
	,type: null
	,padding: null
	,__class__: kha_graphics2_truetype_Stbtt_$vertex
};
var kha_graphics2_truetype_Stbtt_$_$bitmap = function() {
};
$hxClasses["kha.graphics2.truetype.Stbtt__bitmap"] = kha_graphics2_truetype_Stbtt_$_$bitmap;
kha_graphics2_truetype_Stbtt_$_$bitmap.__name__ = true;
kha_graphics2_truetype_Stbtt_$_$bitmap.prototype = {
	w: null
	,h: null
	,stride: null
	,pixels: null
	,pixels_offset: null
	,__class__: kha_graphics2_truetype_Stbtt_$_$bitmap
};
var kha_graphics2_truetype_Stbtt_$_$edge = function() {
};
$hxClasses["kha.graphics2.truetype.Stbtt__edge"] = kha_graphics2_truetype_Stbtt_$_$edge;
kha_graphics2_truetype_Stbtt_$_$edge.__name__ = true;
kha_graphics2_truetype_Stbtt_$_$edge.prototype = {
	x0: null
	,y0: null
	,x1: null
	,y1: null
	,invert: null
	,__class__: kha_graphics2_truetype_Stbtt_$_$edge
};
var kha_graphics2_truetype_Stbtt_$_$active_$edge = function() {
};
$hxClasses["kha.graphics2.truetype.Stbtt__active_edge"] = kha_graphics2_truetype_Stbtt_$_$active_$edge;
kha_graphics2_truetype_Stbtt_$_$active_$edge.__name__ = true;
kha_graphics2_truetype_Stbtt_$_$active_$edge.prototype = {
	next: null
	,fx: null
	,fdx: null
	,fdy: null
	,direction: null
	,sy: null
	,ey: null
	,__class__: kha_graphics2_truetype_Stbtt_$_$active_$edge
};
var kha_graphics2_truetype_Stbtt_$_$point = function() {
};
$hxClasses["kha.graphics2.truetype.Stbtt__point"] = kha_graphics2_truetype_Stbtt_$_$point;
kha_graphics2_truetype_Stbtt_$_$point.__name__ = true;
kha_graphics2_truetype_Stbtt_$_$point.prototype = {
	x: null
	,y: null
	,__class__: kha_graphics2_truetype_Stbtt_$_$point
};
var kha_graphics2_truetype_StbTruetype = function() { };
$hxClasses["kha.graphics2.truetype.StbTruetype"] = kha_graphics2_truetype_StbTruetype;
kha_graphics2_truetype_StbTruetype.__name__ = true;
kha_graphics2_truetype_StbTruetype.STBTT_assert = function(value) {
	if(!value) {
		throw new js__$Boot_HaxeError("Error");
	}
};
kha_graphics2_truetype_StbTruetype.STBTT_POINT_SIZE = function(x) {
	return -x;
};
kha_graphics2_truetype_StbTruetype.ttBYTE = function(p,pos) {
	if(pos == null) {
		pos = 0;
	}
	return p.readU8(pos);
};
kha_graphics2_truetype_StbTruetype.ttCHAR = function(p,pos) {
	if(pos == null) {
		pos = 0;
	}
	var n = p.readU8(pos);
	if(n >= 128) {
		return n - 256;
	}
	return n;
};
kha_graphics2_truetype_StbTruetype.ttUSHORT = function(p,pos) {
	if(pos == null) {
		pos = 0;
	}
	var ch1 = p.readU8(pos);
	var ch2 = p.readU8(pos + 1);
	return ch2 | ch1 << 8;
};
kha_graphics2_truetype_StbTruetype.ttSHORT = function(p,pos) {
	if(pos == null) {
		pos = 0;
	}
	var ch1 = p.readU8(pos);
	var ch2 = p.readU8(pos + 1);
	var n = ch2 | ch1 << 8;
	if((n & 32768) != 0) {
		return n - 65536;
	}
	return n;
};
kha_graphics2_truetype_StbTruetype.ttULONG = function(p,pos) {
	if(pos == null) {
		pos = 0;
	}
	var ch1 = p.readU8(pos);
	var ch2 = p.readU8(pos + 1);
	var ch3 = p.readU8(pos + 2);
	var ch4 = p.readU8(pos + 3);
	return ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24;
};
kha_graphics2_truetype_StbTruetype.ttLONG = function(p,pos) {
	if(pos == null) {
		pos = 0;
	}
	var ch1 = p.readU8(pos);
	var ch2 = p.readU8(pos + 1);
	var ch3 = p.readU8(pos + 2);
	var ch4 = p.readU8(pos + 3);
	return ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24;
};
kha_graphics2_truetype_StbTruetype.ttFixed = function(p,pos) {
	if(pos == null) {
		pos = 0;
	}
	var ch1 = p.readU8(pos);
	var ch2 = p.readU8(pos + 1);
	var ch3 = p.readU8(pos + 2);
	var ch4 = p.readU8(pos + 3);
	return ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24;
};
kha_graphics2_truetype_StbTruetype.stbtt_tag4 = function(p,pos,c0,c1,c2,c3) {
	if(p.readU8(pos) == c0 && p.readU8(pos + 1) == c1 && p.readU8(pos + 2) == c2) {
		return p.readU8(pos + 3) == c3;
	} else {
		return false;
	}
};
kha_graphics2_truetype_StbTruetype.stbtt_tag = function(p,pos,str) {
	var c0 = HxOverrides.cca(str,0);
	var c1 = HxOverrides.cca(str,1);
	var c2 = HxOverrides.cca(str,2);
	var c3 = HxOverrides.cca(str,3);
	if(p.readU8(pos) == c0 && p.readU8(pos + 1) == c1 && p.readU8(pos + 2) == c2) {
		return p.readU8(pos + 3) == c3;
	} else {
		return false;
	}
};
kha_graphics2_truetype_StbTruetype.stbtt__isfont = function(font) {
	var c0 = HxOverrides.cca("1",0);
	if(font.readU8(0) == c0 && font.readU8(1) == 0 && font.readU8(2) == 0 && font.readU8(3) == 0) {
		return true;
	}
	var c01 = HxOverrides.cca("typ1",0);
	var c1 = HxOverrides.cca("typ1",1);
	var c2 = HxOverrides.cca("typ1",2);
	var c3 = HxOverrides.cca("typ1",3);
	if(font.readU8(0) == c01 && font.readU8(1) == c1 && font.readU8(2) == c2 && font.readU8(3) == c3) {
		return true;
	}
	var c02 = HxOverrides.cca("OTTO",0);
	var c11 = HxOverrides.cca("OTTO",1);
	var c21 = HxOverrides.cca("OTTO",2);
	var c31 = HxOverrides.cca("OTTO",3);
	if(font.readU8(0) == c02 && font.readU8(1) == c11 && font.readU8(2) == c21 && font.readU8(3) == c31) {
		return true;
	}
	if(font.readU8(0) == 0 && font.readU8(1) == 1 && font.readU8(2) == 0 && font.readU8(3) == 0) {
		return true;
	}
	return false;
};
kha_graphics2_truetype_StbTruetype.stbtt__find_table = function(data,fontstart,tag) {
	var pos = fontstart + 4;
	var ch1 = data.readU8(pos);
	var ch2 = data.readU8(pos + 1);
	var num_tables = ch2 | ch1 << 8;
	var tabledir = fontstart + 12;
	var _g1 = 0;
	var _g = num_tables;
	while(_g1 < _g) {
		var i = _g1++;
		var loc = tabledir + 16 * i;
		var c0 = HxOverrides.cca(tag,0);
		var c1 = HxOverrides.cca(tag,1);
		var c2 = HxOverrides.cca(tag,2);
		var c3 = HxOverrides.cca(tag,3);
		if(data.readU8(loc) == c0 && data.readU8(loc + 1) == c1 && data.readU8(loc + 2) == c2 && data.readU8(loc + 3) == c3) {
			var pos1 = loc + 8;
			var ch11 = data.readU8(pos1);
			var ch21 = data.readU8(pos1 + 1);
			var ch3 = data.readU8(pos1 + 2);
			var ch4 = data.readU8(pos1 + 3);
			return ch4 | ch3 << 8 | ch21 << 16 | ch11 << 24;
		}
	}
	return 0;
};
kha_graphics2_truetype_StbTruetype.stbtt_GetFontOffsetForIndex = function(font_collection,index) {
	if(kha_graphics2_truetype_StbTruetype.stbtt__isfont(font_collection)) {
		if(index == 0) {
			return 0;
		} else {
			return -1;
		}
	}
	var c0 = HxOverrides.cca("ttcf",0);
	var c1 = HxOverrides.cca("ttcf",1);
	var c2 = HxOverrides.cca("ttcf",2);
	var c3 = HxOverrides.cca("ttcf",3);
	if(font_collection.readU8(0) == c0 && font_collection.readU8(1) == c1 && font_collection.readU8(2) == c2 && font_collection.readU8(3) == c3) {
		var tmp;
		var ch1 = font_collection.readU8(4);
		var ch2 = font_collection.readU8(5);
		var ch3 = font_collection.readU8(6);
		var ch4 = font_collection.readU8(7);
		if((ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24) != 65536) {
			var ch11 = font_collection.readU8(4);
			var ch21 = font_collection.readU8(5);
			var ch31 = font_collection.readU8(6);
			var ch41 = font_collection.readU8(7);
			tmp = (ch41 | ch31 << 8 | ch21 << 16 | ch11 << 24) == 131072;
		} else {
			tmp = true;
		}
		if(tmp) {
			var ch12 = font_collection.readU8(8);
			var ch22 = font_collection.readU8(9);
			var ch32 = font_collection.readU8(10);
			var ch42 = font_collection.readU8(11);
			var n = ch42 | ch32 << 8 | ch22 << 16 | ch12 << 24;
			if(index >= n) {
				return -1;
			}
			var pos = 12 + index * 4;
			var ch13 = font_collection.readU8(pos);
			var ch23 = font_collection.readU8(pos + 1);
			var ch33 = font_collection.readU8(pos + 2);
			var ch43 = font_collection.readU8(pos + 3);
			return ch43 | ch33 << 8 | ch23 << 16 | ch13 << 24;
		}
	}
	return -1;
};
kha_graphics2_truetype_StbTruetype.stbtt_InitFont = function(info,data,fontstart) {
	var cmap;
	var t;
	var numTables;
	info.data = data;
	info.fontstart = fontstart;
	cmap = kha_graphics2_truetype_StbTruetype.stbtt__find_table(data,fontstart,"cmap");
	info.loca = kha_graphics2_truetype_StbTruetype.stbtt__find_table(data,fontstart,"loca");
	info.head = kha_graphics2_truetype_StbTruetype.stbtt__find_table(data,fontstart,"head");
	info.glyf = kha_graphics2_truetype_StbTruetype.stbtt__find_table(data,fontstart,"glyf");
	info.hhea = kha_graphics2_truetype_StbTruetype.stbtt__find_table(data,fontstart,"hhea");
	info.hmtx = kha_graphics2_truetype_StbTruetype.stbtt__find_table(data,fontstart,"hmtx");
	info.kern = kha_graphics2_truetype_StbTruetype.stbtt__find_table(data,fontstart,"kern");
	if(cmap == 0 || info.loca == 0 || info.head == 0 || info.glyf == 0 || info.hhea == 0 || info.hmtx == 0) {
		return false;
	}
	t = kha_graphics2_truetype_StbTruetype.stbtt__find_table(data,fontstart,"maxp");
	if(t != 0) {
		var pos = t + 4;
		var ch1 = data.readU8(pos);
		var ch2 = data.readU8(pos + 1);
		info.numGlyphs = ch2 | ch1 << 8;
	} else {
		info.numGlyphs = 65535;
	}
	var pos1 = cmap + 2;
	var ch11 = data.readU8(pos1);
	var ch21 = data.readU8(pos1 + 1);
	numTables = ch21 | ch11 << 8;
	info.index_map = 0;
	var _g1 = 0;
	var _g = numTables;
	while(_g1 < _g) {
		var i = _g1++;
		var encoding_record = cmap + 4 + 8 * i;
		var ch12 = data.readU8(encoding_record);
		var ch22 = data.readU8(encoding_record + 1);
		var _g2 = ch22 | ch12 << 8;
		switch(_g2) {
		case 0:
			var pos2 = encoding_record + 4;
			var ch13 = data.readU8(pos2);
			var ch23 = data.readU8(pos2 + 1);
			var ch3 = data.readU8(pos2 + 2);
			var ch4 = data.readU8(pos2 + 3);
			info.index_map = cmap + (ch4 | ch3 << 8 | ch23 << 16 | ch13 << 24);
			break;
		case 3:
			var pos3 = encoding_record + 2;
			var ch14 = data.readU8(pos3);
			var ch24 = data.readU8(pos3 + 1);
			var _g21 = ch24 | ch14 << 8;
			switch(_g21) {
			case 1:case 10:
				var pos4 = encoding_record + 4;
				var ch15 = data.readU8(pos4);
				var ch25 = data.readU8(pos4 + 1);
				var ch31 = data.readU8(pos4 + 2);
				var ch41 = data.readU8(pos4 + 3);
				info.index_map = cmap + (ch41 | ch31 << 8 | ch25 << 16 | ch15 << 24);
				break;
			}
			break;
		}
	}
	if(info.index_map == 0) {
		return false;
	}
	var pos5 = info.head + 50;
	var ch16 = data.readU8(pos5);
	var ch26 = data.readU8(pos5 + 1);
	info.indexToLocFormat = ch26 | ch16 << 8;
	return true;
};
kha_graphics2_truetype_StbTruetype.stbtt_FindGlyphIndex = function(info,unicode_codepoint) {
	var data = info.data;
	var index_map = info.index_map;
	var ch1 = data.readU8(index_map);
	var ch2 = data.readU8(index_map + 1);
	var format = ch2 | ch1 << 8;
	if(format == 0) {
		var pos = index_map + 2;
		var ch11 = data.readU8(pos);
		var ch21 = data.readU8(pos + 1);
		var bytes = ch21 | ch11 << 8;
		if(unicode_codepoint < bytes - 6) {
			return data.readU8(index_map + 6 + unicode_codepoint);
		}
		return 0;
	} else if(format == 6) {
		var pos1 = index_map + 6;
		var ch12 = data.readU8(pos1);
		var ch22 = data.readU8(pos1 + 1);
		var first = ch22 | ch12 << 8;
		var pos2 = index_map + 8;
		var ch13 = data.readU8(pos2);
		var ch23 = data.readU8(pos2 + 1);
		var count = ch23 | ch13 << 8;
		if(unicode_codepoint >= first && unicode_codepoint < first + count) {
			var pos3 = index_map + 10 + (unicode_codepoint - first) * 2;
			var ch14 = data.readU8(pos3);
			var ch24 = data.readU8(pos3 + 1);
			return ch24 | ch14 << 8;
		}
		return 0;
	} else if(format == 2) {
		throw new js__$Boot_HaxeError("Error");
	} else if(format == 4) {
		var pos4 = index_map + 6;
		var ch15 = data.readU8(pos4);
		var ch25 = data.readU8(pos4 + 1);
		var segcount = (ch25 | ch15 << 8) >> 1;
		var pos5 = index_map + 8;
		var ch16 = data.readU8(pos5);
		var ch26 = data.readU8(pos5 + 1);
		var searchRange = (ch26 | ch16 << 8) >> 1;
		var pos6 = index_map + 10;
		var ch17 = data.readU8(pos6);
		var ch27 = data.readU8(pos6 + 1);
		var entrySelector = ch27 | ch17 << 8;
		var pos7 = index_map + 12;
		var ch18 = data.readU8(pos7);
		var ch28 = data.readU8(pos7 + 1);
		var rangeShift = (ch28 | ch18 << 8) >> 1;
		var endCount = index_map + 14;
		var search = endCount;
		if(unicode_codepoint > 65535) {
			return 0;
		}
		var pos8 = search + rangeShift * 2;
		var ch19 = data.readU8(pos8);
		var ch29 = data.readU8(pos8 + 1);
		if(unicode_codepoint >= (ch29 | ch19 << 8)) {
			search += rangeShift * 2;
		}
		search -= 2;
		while(entrySelector != 0) {
			var end;
			searchRange >>= 1;
			var pos9 = search + searchRange * 2;
			var ch110 = data.readU8(pos9);
			var ch210 = data.readU8(pos9 + 1);
			end = ch210 | ch110 << 8;
			if(unicode_codepoint > end) {
				search += searchRange * 2;
			}
			--entrySelector;
		}
		search += 2;
		var offset;
		var start;
		var item = search - endCount >> 1;
		var pos10 = endCount + 2 * item;
		var ch111 = data.readU8(pos10);
		var ch211 = data.readU8(pos10 + 1);
		if(unicode_codepoint > (ch211 | ch111 << 8)) {
			throw new js__$Boot_HaxeError("Error");
		}
		var pos11 = index_map + 14 + segcount * 2 + 2 + 2 * item;
		var ch112 = data.readU8(pos11);
		var ch212 = data.readU8(pos11 + 1);
		start = ch212 | ch112 << 8;
		if(unicode_codepoint < start) {
			return 0;
		}
		var pos12 = index_map + 14 + segcount * 6 + 2 + 2 * item;
		var ch113 = data.readU8(pos12);
		var ch213 = data.readU8(pos12 + 1);
		offset = ch213 | ch113 << 8;
		if(offset == 0) {
			var pos13 = index_map + 14 + segcount * 4 + 2 + 2 * item;
			var ch114 = data.readU8(pos13);
			var ch214 = data.readU8(pos13 + 1);
			var n = ch214 | ch114 << 8;
			return unicode_codepoint + ((n & 32768) != 0 ? n - 65536 : n);
		}
		var pos14 = offset + (unicode_codepoint - start) * 2 + index_map + 14 + segcount * 6 + 2 + 2 * item;
		var ch115 = data.readU8(pos14);
		var ch215 = data.readU8(pos14 + 1);
		return ch215 | ch115 << 8;
	} else if(format == 12 || format == 13) {
		var pos15 = index_map + 12;
		var ch116 = data.readU8(pos15);
		var ch216 = data.readU8(pos15 + 1);
		var ch3 = data.readU8(pos15 + 2);
		var ch4 = data.readU8(pos15 + 3);
		var ngroups = ch4 | ch3 << 8 | ch216 << 16 | ch116 << 24;
		var low;
		var high;
		low = 0;
		high = ngroups;
		while(low < high) {
			var mid = low + (high - low >> 1);
			var pos16 = index_map + 16 + mid * 12;
			var ch117 = data.readU8(pos16);
			var ch217 = data.readU8(pos16 + 1);
			var ch31 = data.readU8(pos16 + 2);
			var ch41 = data.readU8(pos16 + 3);
			var start_char = ch41 | ch31 << 8 | ch217 << 16 | ch117 << 24;
			var pos17 = index_map + 16 + mid * 12 + 4;
			var ch118 = data.readU8(pos17);
			var ch218 = data.readU8(pos17 + 1);
			var ch32 = data.readU8(pos17 + 2);
			var ch42 = data.readU8(pos17 + 3);
			var end_char = ch42 | ch32 << 8 | ch218 << 16 | ch118 << 24;
			if(unicode_codepoint < start_char) {
				high = mid;
			} else if(unicode_codepoint > end_char) {
				low = mid + 1;
			} else {
				var pos18 = index_map + 16 + mid * 12 + 8;
				var ch119 = data.readU8(pos18);
				var ch219 = data.readU8(pos18 + 1);
				var ch33 = data.readU8(pos18 + 2);
				var ch43 = data.readU8(pos18 + 3);
				var start_glyph = ch43 | ch33 << 8 | ch219 << 16 | ch119 << 24;
				if(format == 12) {
					return start_glyph + unicode_codepoint - start_char;
				} else {
					return start_glyph;
				}
			}
		}
		return 0;
	}
	throw new js__$Boot_HaxeError("Error");
};
kha_graphics2_truetype_StbTruetype.stbtt_GetCodepointShape = function(info,unicode_codepoint) {
	return kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphShape(info,kha_graphics2_truetype_StbTruetype.stbtt_FindGlyphIndex(info,unicode_codepoint));
};
kha_graphics2_truetype_StbTruetype.stbtt_setvertex = function(v,type,x,y,cx,cy) {
	v.type = type;
	v.x = x;
	v.y = y;
	v.cx = cx;
	v.cy = cy;
};
kha_graphics2_truetype_StbTruetype.stbtt__GetGlyfOffset = function(info,glyph_index) {
	var g1;
	var g2;
	if(glyph_index >= info.numGlyphs) {
		return -1;
	}
	if(info.indexToLocFormat >= 2) {
		return -1;
	}
	if(info.indexToLocFormat == 0) {
		var info1 = info.glyf;
		var p = info.data;
		var pos = info.loca + glyph_index * 2;
		var ch1 = p.readU8(pos);
		var ch2 = p.readU8(pos + 1);
		g1 = info1 + (ch2 | ch1 << 8) * 2;
		var info2 = info.glyf;
		var p1 = info.data;
		var pos1 = info.loca + glyph_index * 2 + 2;
		var ch11 = p1.readU8(pos1);
		var ch21 = p1.readU8(pos1 + 1);
		g2 = info2 + (ch21 | ch11 << 8) * 2;
	} else {
		var info3 = info.glyf;
		var p2 = info.data;
		var pos2 = info.loca + glyph_index * 4;
		var ch12 = p2.readU8(pos2);
		var ch22 = p2.readU8(pos2 + 1);
		var ch3 = p2.readU8(pos2 + 2);
		var ch4 = p2.readU8(pos2 + 3);
		g1 = info3 + (ch4 | ch3 << 8 | ch22 << 16 | ch12 << 24);
		var info4 = info.glyf;
		var p3 = info.data;
		var pos3 = info.loca + glyph_index * 4 + 4;
		var ch13 = p3.readU8(pos3);
		var ch23 = p3.readU8(pos3 + 1);
		var ch31 = p3.readU8(pos3 + 2);
		var ch41 = p3.readU8(pos3 + 3);
		g2 = info4 + (ch41 | ch31 << 8 | ch23 << 16 | ch13 << 24);
	}
	if(g1 == g2) {
		return -1;
	} else {
		return g1;
	}
};
kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphBox = function(info,glyph_index,rect) {
	var g = kha_graphics2_truetype_StbTruetype.stbtt__GetGlyfOffset(info,glyph_index);
	if(g < 0) {
		return false;
	}
	var p = info.data;
	var pos = g + 2;
	var ch1 = p.readU8(pos);
	var ch2 = p.readU8(pos + 1);
	var n = ch2 | ch1 << 8;
	rect.x0 = (n & 32768) != 0 ? n - 65536 : n;
	var p1 = info.data;
	var pos1 = g + 4;
	var ch11 = p1.readU8(pos1);
	var ch21 = p1.readU8(pos1 + 1);
	var n1 = ch21 | ch11 << 8;
	rect.y0 = (n1 & 32768) != 0 ? n1 - 65536 : n1;
	var p2 = info.data;
	var pos2 = g + 6;
	var ch12 = p2.readU8(pos2);
	var ch22 = p2.readU8(pos2 + 1);
	var n2 = ch22 | ch12 << 8;
	rect.x1 = (n2 & 32768) != 0 ? n2 - 65536 : n2;
	var p3 = info.data;
	var pos3 = g + 8;
	var ch13 = p3.readU8(pos3);
	var ch23 = p3.readU8(pos3 + 1);
	var n3 = ch23 | ch13 << 8;
	rect.y1 = (n3 & 32768) != 0 ? n3 - 65536 : n3;
	return true;
};
kha_graphics2_truetype_StbTruetype.stbtt_GetCodepointBox = function(info,codepoint,rect) {
	return kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphBox(info,kha_graphics2_truetype_StbTruetype.stbtt_FindGlyphIndex(info,codepoint),rect);
};
kha_graphics2_truetype_StbTruetype.stbtt_IsGlyphEmpty = function(info,glyph_index) {
	var numberOfContours;
	var g = kha_graphics2_truetype_StbTruetype.stbtt__GetGlyfOffset(info,glyph_index);
	if(g < 0) {
		return true;
	}
	var p = info.data;
	var ch1 = p.readU8(g);
	var ch2 = p.readU8(g + 1);
	var n = ch2 | ch1 << 8;
	if((n & 32768) != 0) {
		numberOfContours = n - 65536;
	} else {
		numberOfContours = n;
	}
	return numberOfContours == 0;
};
kha_graphics2_truetype_StbTruetype.stbtt__close_shape = function(vertices,num_vertices,was_off,start_off,sx,sy,scx,scy,cx,cy) {
	if(start_off) {
		if(was_off) {
			kha_graphics2_truetype_StbTruetype.stbtt_setvertex(vertices[num_vertices++],3,cx + scx >> 1,cy + scy >> 1,cx,cy);
		}
		kha_graphics2_truetype_StbTruetype.stbtt_setvertex(vertices[num_vertices++],3,sx,sy,scx,scy);
	} else if(was_off) {
		kha_graphics2_truetype_StbTruetype.stbtt_setvertex(vertices[num_vertices++],3,sx,sy,cx,cy);
	} else {
		kha_graphics2_truetype_StbTruetype.stbtt_setvertex(vertices[num_vertices++],2,sx,sy,0,0);
	}
	return num_vertices;
};
kha_graphics2_truetype_StbTruetype.copyVertices = function(from,to,offset,count) {
	var _g1 = 0;
	var _g = count;
	while(_g1 < _g) {
		var i = _g1++;
		to[offset + i] = from[i];
	}
};
kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphShape = function(info,glyph_index) {
	var numberOfContours;
	var endPtsOfContours;
	var data = info.data;
	var vertices = null;
	var num_vertices = 0;
	var g = kha_graphics2_truetype_StbTruetype.stbtt__GetGlyfOffset(info,glyph_index);
	if(g < 0) {
		return null;
	}
	var ch1 = data.readU8(g);
	var ch2 = data.readU8(g + 1);
	var n = ch2 | ch1 << 8;
	if((n & 32768) != 0) {
		numberOfContours = n - 65536;
	} else {
		numberOfContours = n;
	}
	if(numberOfContours > 0) {
		var flags = 0;
		var flagcount;
		var ins;
		var j = 0;
		var m;
		var n1;
		var next_move = 0;
		var off = 0;
		var was_off = false;
		var start_off = false;
		var x;
		var y;
		var cx;
		var cy;
		var sx;
		var sy;
		var scx;
		var scy;
		var points;
		var pointsIndex = 0;
		endPtsOfContours = data.sub(g + 10,data.get_length() - (g + 10));
		var pos = g + 10 + numberOfContours * 2;
		var ch11 = data.readU8(pos);
		var ch21 = data.readU8(pos + 1);
		ins = ch21 | ch11 << 8;
		points = data.sub(g + 10 + numberOfContours * 2 + 2 + ins,data.get_length() - (g + 10 + numberOfContours * 2 + 2 + ins));
		var pos1 = numberOfContours * 2 - 2;
		var ch12 = endPtsOfContours.readU8(pos1);
		var ch22 = endPtsOfContours.readU8(pos1 + 1);
		n1 = 1 + (ch22 | ch12 << 8);
		m = n1 + 2 * numberOfContours;
		var this1 = new Array(m);
		vertices = this1;
		if(vertices == null) {
			return null;
		} else {
			var _g1 = 0;
			var _g = vertices.length;
			while(_g1 < _g) {
				var i = _g1++;
				vertices[i] = new kha_graphics2_truetype_Stbtt_$vertex();
			}
		}
		next_move = 0;
		flagcount = 0;
		off = m - n1;
		var _g11 = 0;
		var _g2 = n1;
		while(_g11 < _g2) {
			var i1 = _g11++;
			if(flagcount == 0) {
				flags = points.readU8(pointsIndex++);
				if((flags & 8) != 0) {
					flagcount = points.readU8(pointsIndex++);
				}
			} else {
				--flagcount;
			}
			vertices[off + i1].type = flags;
		}
		x = 0;
		var _g12 = 0;
		var _g3 = n1;
		while(_g12 < _g3) {
			var i2 = _g12++;
			flags = vertices[off + i2].type;
			if((flags & 2) != 0) {
				var dx = points.readU8(pointsIndex++);
				x += (flags & 16) != 0 ? dx : -dx;
			} else if((flags & 16) == 0) {
				var value;
				var ch13 = points.readU8(pointsIndex);
				var ch23 = points.readU8(pointsIndex + 1);
				var n2 = ch23 | ch13 << 8;
				if((n2 & 32768) != 0) {
					value = n2 - 65536;
				} else {
					value = n2;
				}
				x += value;
				pointsIndex += 2;
			}
			vertices[off + i2].x = x;
		}
		y = 0;
		var _g13 = 0;
		var _g4 = n1;
		while(_g13 < _g4) {
			var i3 = _g13++;
			flags = vertices[off + i3].type;
			if((flags & 4) != 0) {
				var dy = points.readU8(pointsIndex++);
				y += (flags & 32) != 0 ? dy : -dy;
			} else if((flags & 32) == 0) {
				var value1;
				var ch14 = points.readU8(pointsIndex);
				var ch24 = points.readU8(pointsIndex + 1);
				var n3 = ch24 | ch14 << 8;
				if((n3 & 32768) != 0) {
					value1 = n3 - 65536;
				} else {
					value1 = n3;
				}
				y += value1;
				pointsIndex += 2;
			}
			vertices[off + i3].y = y;
		}
		num_vertices = 0;
		scy = 0;
		scx = scy;
		cy = scx;
		cx = cy;
		sy = cx;
		sx = sy;
		var i4 = 0;
		while(i4 < n1) {
			flags = vertices[off + i4].type;
			x = vertices[off + i4].x;
			y = vertices[off + i4].y;
			if(next_move == i4) {
				if(i4 != 0) {
					num_vertices = kha_graphics2_truetype_StbTruetype.stbtt__close_shape(vertices,num_vertices,was_off,start_off,sx,sy,scx,scy,cx,cy);
				}
				start_off = (flags & 1) == 0;
				if(start_off) {
					scx = x;
					scy = y;
					if((vertices[off + i4 + 1].type & 1) == 0) {
						sx = x + vertices[off + i4 + 1].x >> 1;
						sy = y + vertices[off + i4 + 1].y >> 1;
					} else {
						sx = vertices[off + i4 + 1].x;
						sy = vertices[off + i4 + 1].y;
						++i4;
					}
				} else {
					sx = x;
					sy = y;
				}
				kha_graphics2_truetype_StbTruetype.stbtt_setvertex(vertices[num_vertices++],1,sx,sy,0,0);
				was_off = false;
				var pos2 = j * 2;
				var ch15 = endPtsOfContours.readU8(pos2);
				var ch25 = endPtsOfContours.readU8(pos2 + 1);
				next_move = 1 + (ch25 | ch15 << 8);
				++j;
			} else if((flags & 1) == 0) {
				if(was_off) {
					kha_graphics2_truetype_StbTruetype.stbtt_setvertex(vertices[num_vertices++],3,cx + x >> 1,cy + y >> 1,cx,cy);
				}
				cx = x;
				cy = y;
				was_off = true;
			} else {
				if(was_off) {
					kha_graphics2_truetype_StbTruetype.stbtt_setvertex(vertices[num_vertices++],3,x,y,cx,cy);
				} else {
					kha_graphics2_truetype_StbTruetype.stbtt_setvertex(vertices[num_vertices++],2,x,y,0,0);
				}
				was_off = false;
			}
			++i4;
		}
		num_vertices = kha_graphics2_truetype_StbTruetype.stbtt__close_shape(vertices,num_vertices,was_off,start_off,sx,sy,scx,scy,cx,cy);
	} else if(numberOfContours == -1) {
		var more = 1;
		var comp = data.sub(g + 10,data.get_length() - (g + 10));
		var compIndex = 0;
		num_vertices = 0;
		vertices = null;
		while(more != 0) {
			var flags1;
			var gidx;
			var comp_num_verts = 0;
			var i5;
			var comp_verts = null;
			var tmp = null;
			var mtx0 = 1;
			var mtx1 = 0;
			var mtx2 = 0;
			var mtx3 = 1;
			var mtx4 = 0;
			var mtx5 = 0;
			var m1;
			var n4;
			var ch16 = comp.readU8(compIndex);
			var ch26 = comp.readU8(compIndex + 1);
			var n5 = ch26 | ch16 << 8;
			if((n5 & 32768) != 0) {
				flags1 = n5 - 65536;
			} else {
				flags1 = n5;
			}
			compIndex += 2;
			var ch17 = comp.readU8(compIndex);
			var ch27 = comp.readU8(compIndex + 1);
			var n6 = ch27 | ch17 << 8;
			if((n6 & 32768) != 0) {
				gidx = n6 - 65536;
			} else {
				gidx = n6;
			}
			compIndex += 2;
			if((flags1 & 2) != 0) {
				if((flags1 & 1) != 0) {
					var ch18 = comp.readU8(compIndex);
					var ch28 = comp.readU8(compIndex + 1);
					var n7 = ch28 | ch18 << 8;
					if((n7 & 32768) != 0) {
						mtx4 = n7 - 65536;
					} else {
						mtx4 = n7;
					}
					compIndex += 2;
					var ch19 = comp.readU8(compIndex);
					var ch29 = comp.readU8(compIndex + 1);
					var n8 = ch29 | ch19 << 8;
					if((n8 & 32768) != 0) {
						mtx5 = n8 - 65536;
					} else {
						mtx5 = n8;
					}
					compIndex += 2;
				} else {
					var n9 = comp.readU8(compIndex);
					if(n9 >= 128) {
						mtx4 = n9 - 256;
					} else {
						mtx4 = n9;
					}
					++compIndex;
					var n10 = comp.readU8(compIndex);
					if(n10 >= 128) {
						mtx5 = n10 - 256;
					} else {
						mtx5 = n10;
					}
					++compIndex;
				}
			} else {
				throw new js__$Boot_HaxeError("Error");
			}
			if((flags1 & 8) != 0) {
				var ch110 = comp.readU8(compIndex);
				var ch210 = comp.readU8(compIndex + 1);
				var n11 = ch210 | ch110 << 8;
				mtx3 = ((n11 & 32768) != 0 ? n11 - 65536 : n11) / 16384.0;
				mtx0 = mtx3;
				compIndex += 2;
				mtx2 = 0;
				mtx1 = mtx2;
			} else if((flags1 & 64) != 0) {
				var ch111 = comp.readU8(compIndex);
				var ch211 = comp.readU8(compIndex + 1);
				var n12 = ch211 | ch111 << 8;
				mtx0 = ((n12 & 32768) != 0 ? n12 - 65536 : n12) / 16384.0;
				compIndex += 2;
				mtx2 = 0;
				mtx1 = mtx2;
				var ch112 = comp.readU8(compIndex);
				var ch212 = comp.readU8(compIndex + 1);
				var n13 = ch212 | ch112 << 8;
				mtx3 = ((n13 & 32768) != 0 ? n13 - 65536 : n13) / 16384.0;
				compIndex += 2;
			} else if((flags1 & 128) != 0) {
				var ch113 = comp.readU8(compIndex);
				var ch213 = comp.readU8(compIndex + 1);
				var n14 = ch213 | ch113 << 8;
				mtx0 = ((n14 & 32768) != 0 ? n14 - 65536 : n14) / 16384.0;
				compIndex += 2;
				var ch114 = comp.readU8(compIndex);
				var ch214 = comp.readU8(compIndex + 1);
				var n15 = ch214 | ch114 << 8;
				mtx1 = ((n15 & 32768) != 0 ? n15 - 65536 : n15) / 16384.0;
				compIndex += 2;
				var ch115 = comp.readU8(compIndex);
				var ch215 = comp.readU8(compIndex + 1);
				var n16 = ch215 | ch115 << 8;
				mtx2 = ((n16 & 32768) != 0 ? n16 - 65536 : n16) / 16384.0;
				compIndex += 2;
				var ch116 = comp.readU8(compIndex);
				var ch216 = comp.readU8(compIndex + 1);
				var n17 = ch216 | ch116 << 8;
				mtx3 = ((n17 & 32768) != 0 ? n17 - 65536 : n17) / 16384.0;
				compIndex += 2;
			}
			m1 = Math.sqrt(mtx0 * mtx0 + mtx1 * mtx1);
			n4 = Math.sqrt(mtx2 * mtx2 + mtx3 * mtx3);
			comp_verts = kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphShape(info,gidx);
			if(comp_verts == null) {
				comp_num_verts = 0;
			} else {
				comp_num_verts = comp_verts.length;
			}
			if(comp_num_verts > 0) {
				var _g14 = 0;
				var _g5 = comp_num_verts;
				while(_g14 < _g5) {
					var i6 = _g14++;
					var v = comp_verts[i6];
					var x1;
					var y1;
					x1 = v.x;
					y1 = v.y;
					v.x = m1 * (mtx0 * x1 + mtx2 * y1 + mtx4) | 0;
					v.y = n4 * (mtx1 * x1 + mtx3 * y1 + mtx5) | 0;
					x1 = v.cx;
					y1 = v.cy;
					v.cx = m1 * (mtx0 * x1 + mtx2 * y1 + mtx4) | 0;
					v.cy = n4 * (mtx1 * x1 + mtx3 * y1 + mtx5) | 0;
				}
				var this2 = new Array(num_vertices + comp_num_verts);
				tmp = this2;
				if(tmp == null) {
					return null;
				}
				if(num_vertices > 0) {
					kha_graphics2_truetype_StbTruetype.copyVertices(vertices,tmp,0,num_vertices);
				}
				kha_graphics2_truetype_StbTruetype.copyVertices(comp_verts,tmp,num_vertices,comp_num_verts);
				vertices = tmp;
				num_vertices += comp_num_verts;
			}
			more = flags1 & 32;
		}
	} else if(numberOfContours < 0) {
		throw new js__$Boot_HaxeError("Error");
	}
	if(vertices == null) {
		return null;
	}
	if(vertices.length < num_vertices) {
		throw new js__$Boot_HaxeError("Error");
	}
	if(num_vertices < vertices.length) {
		var this3 = new Array(num_vertices);
		var tmp1 = this3;
		kha_graphics2_truetype_StbTruetype.copyVertices(vertices,tmp1,0,num_vertices);
		return tmp1;
	} else {
		return vertices;
	}
};
kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphHMetrics = function(info,glyph_index) {
	var p = info.data;
	var pos = info.hhea + 34;
	var ch1 = p.readU8(pos);
	var ch2 = p.readU8(pos + 1);
	var numOfLongHorMetrics = ch2 | ch1 << 8;
	var metrics = new kha_graphics2_truetype_Stbtt_$temp_$glyph_$h_$metrics();
	if(glyph_index < numOfLongHorMetrics) {
		var p1 = info.data;
		var pos1 = info.hmtx + 4 * glyph_index;
		var ch11 = p1.readU8(pos1);
		var ch21 = p1.readU8(pos1 + 1);
		var n = ch21 | ch11 << 8;
		metrics.advanceWidth = (n & 32768) != 0 ? n - 65536 : n;
		var p2 = info.data;
		var pos2 = info.hmtx + 4 * glyph_index + 2;
		var ch12 = p2.readU8(pos2);
		var ch22 = p2.readU8(pos2 + 1);
		var n1 = ch22 | ch12 << 8;
		metrics.leftSideBearing = (n1 & 32768) != 0 ? n1 - 65536 : n1;
	} else {
		var p3 = info.data;
		var pos3 = info.hmtx + 4 * (numOfLongHorMetrics - 1);
		var ch13 = p3.readU8(pos3);
		var ch23 = p3.readU8(pos3 + 1);
		var n2 = ch23 | ch13 << 8;
		metrics.advanceWidth = (n2 & 32768) != 0 ? n2 - 65536 : n2;
		var p4 = info.data;
		var pos4 = info.hmtx + 4 * numOfLongHorMetrics + 2 * (glyph_index - numOfLongHorMetrics);
		var ch14 = p4.readU8(pos4);
		var ch24 = p4.readU8(pos4 + 1);
		var n3 = ch24 | ch14 << 8;
		metrics.leftSideBearing = (n3 & 32768) != 0 ? n3 - 65536 : n3;
	}
	return metrics;
};
kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphKernAdvance = function(info,glyph1,glyph2) {
	var data = info.data.sub(info.kern,info.data.get_length() - info.kern);
	var needle;
	var straw;
	var l;
	var r;
	var m;
	if(info.kern == 0) {
		return 0;
	}
	var ch1 = data.readU8(2);
	var ch2 = data.readU8(3);
	if((ch2 | ch1 << 8) < 1) {
		return 0;
	}
	var ch11 = data.readU8(8);
	var ch21 = data.readU8(9);
	if((ch21 | ch11 << 8) != 1) {
		return 0;
	}
	l = 0;
	var ch12 = data.readU8(10);
	var ch22 = data.readU8(11);
	r = (ch22 | ch12 << 8) - 1;
	needle = glyph1 << 16 | glyph2;
	while(l <= r) {
		m = l + r >> 1;
		var pos = 18 + m * 6;
		var ch13 = data.readU8(pos);
		var ch23 = data.readU8(pos + 1);
		var ch3 = data.readU8(pos + 2);
		var ch4 = data.readU8(pos + 3);
		straw = ch4 | ch3 << 8 | ch23 << 16 | ch13 << 24;
		if(needle < straw) {
			r = m - 1;
		} else if(needle > straw) {
			l = m + 1;
		} else {
			var pos1 = 22 + m * 6;
			var ch14 = data.readU8(pos1);
			var ch24 = data.readU8(pos1 + 1);
			var n = ch24 | ch14 << 8;
			if((n & 32768) != 0) {
				return n - 65536;
			} else {
				return n;
			}
		}
	}
	return 0;
};
kha_graphics2_truetype_StbTruetype.stbtt_GetCodepointKernAdvance = function(info,ch1,ch2) {
	if(info.kern == 0) {
		return 0;
	}
	return kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphKernAdvance(info,kha_graphics2_truetype_StbTruetype.stbtt_FindGlyphIndex(info,ch1),kha_graphics2_truetype_StbTruetype.stbtt_FindGlyphIndex(info,ch2));
};
kha_graphics2_truetype_StbTruetype.stbtt_GetCodepointHMetrics = function(info,codepoint) {
	return kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphHMetrics(info,kha_graphics2_truetype_StbTruetype.stbtt_FindGlyphIndex(info,codepoint));
};
kha_graphics2_truetype_StbTruetype.stbtt_GetFontVMetrics = function(info) {
	var metrics = new kha_graphics2_truetype_Stbtt_$temp_$font_$v_$metrics();
	var p = info.data;
	var pos = info.hhea + 4;
	var ch1 = p.readU8(pos);
	var ch2 = p.readU8(pos + 1);
	var n = ch2 | ch1 << 8;
	metrics.ascent = (n & 32768) != 0 ? n - 65536 : n;
	var p1 = info.data;
	var pos1 = info.hhea + 6;
	var ch11 = p1.readU8(pos1);
	var ch21 = p1.readU8(pos1 + 1);
	var n1 = ch21 | ch11 << 8;
	metrics.descent = (n1 & 32768) != 0 ? n1 - 65536 : n1;
	var p2 = info.data;
	var pos2 = info.hhea + 8;
	var ch12 = p2.readU8(pos2);
	var ch22 = p2.readU8(pos2 + 1);
	var n2 = ch22 | ch12 << 8;
	metrics.lineGap = (n2 & 32768) != 0 ? n2 - 65536 : n2;
	return metrics;
};
kha_graphics2_truetype_StbTruetype.stbtt_GetFontBoundingBox = function(info) {
	var rect = new kha_graphics2_truetype_Stbtt_$temp_$rect();
	var p = info.data;
	var pos = info.head + 36;
	var ch1 = p.readU8(pos);
	var ch2 = p.readU8(pos + 1);
	var n = ch2 | ch1 << 8;
	rect.x0 = (n & 32768) != 0 ? n - 65536 : n;
	var p1 = info.data;
	var pos1 = info.head + 38;
	var ch11 = p1.readU8(pos1);
	var ch21 = p1.readU8(pos1 + 1);
	var n1 = ch21 | ch11 << 8;
	rect.y0 = (n1 & 32768) != 0 ? n1 - 65536 : n1;
	var p2 = info.data;
	var pos2 = info.head + 40;
	var ch12 = p2.readU8(pos2);
	var ch22 = p2.readU8(pos2 + 1);
	var n2 = ch22 | ch12 << 8;
	rect.x1 = (n2 & 32768) != 0 ? n2 - 65536 : n2;
	var p3 = info.data;
	var pos3 = info.head + 42;
	var ch13 = p3.readU8(pos3);
	var ch23 = p3.readU8(pos3 + 1);
	var n3 = ch23 | ch13 << 8;
	rect.y1 = (n3 & 32768) != 0 ? n3 - 65536 : n3;
	return rect;
};
kha_graphics2_truetype_StbTruetype.stbtt_ScaleForPixelHeight = function(info,height) {
	var p = info.data;
	var pos = info.hhea + 4;
	var ch1 = p.readU8(pos);
	var ch2 = p.readU8(pos + 1);
	var n = ch2 | ch1 << 8;
	var p1 = info.data;
	var pos1 = info.hhea + 6;
	var ch11 = p1.readU8(pos1);
	var ch21 = p1.readU8(pos1 + 1);
	var n1 = ch21 | ch11 << 8;
	var fheight = ((n & 32768) != 0 ? n - 65536 : n) - ((n1 & 32768) != 0 ? n1 - 65536 : n1);
	return height / fheight;
};
kha_graphics2_truetype_StbTruetype.stbtt_ScaleForMappingEmToPixels = function(info,pixels) {
	var p = info.data;
	var pos = info.head + 18;
	var ch1 = p.readU8(pos);
	var ch2 = p.readU8(pos + 1);
	var unitsPerEm = ch2 | ch1 << 8;
	return pixels / unitsPerEm;
};
kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphBitmapBoxSubpixel = function(font,glyph,scale_x,scale_y,shift_x,shift_y) {
	var rect = new kha_graphics2_truetype_Stbtt_$temp_$rect();
	if(!kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphBox(font,glyph,rect)) {
		rect.x0 = 0;
		rect.y0 = 0;
		rect.x1 = 0;
		rect.y1 = 0;
	} else {
		var x0 = rect.x0;
		var x1 = rect.x1;
		var y0 = rect.y0;
		var y1 = rect.y1;
		rect.x0 = Math.floor(x0 * scale_x + shift_x);
		rect.y0 = Math.floor(-y1 * scale_y + shift_y);
		rect.x1 = Math.ceil(x1 * scale_x + shift_x);
		rect.y1 = Math.ceil(-y0 * scale_y + shift_y);
	}
	return rect;
};
kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphBitmapBox = function(font,glyph,scale_x,scale_y) {
	return kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphBitmapBoxSubpixel(font,glyph,scale_x,scale_y,0.0,0.0);
};
kha_graphics2_truetype_StbTruetype.stbtt_GetCodepointBitmapBoxSubpixel = function(font,codepoint,scale_x,scale_y,shift_x,shift_y) {
	return kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphBitmapBoxSubpixel(font,kha_graphics2_truetype_StbTruetype.stbtt_FindGlyphIndex(font,codepoint),scale_x,scale_y,shift_x,shift_y);
};
kha_graphics2_truetype_StbTruetype.stbtt_GetCodepointBitmapBox = function(font,codepoint,scale_x,scale_y) {
	return kha_graphics2_truetype_StbTruetype.stbtt_GetCodepointBitmapBoxSubpixel(font,codepoint,scale_x,scale_y,0.0,0.0);
};
kha_graphics2_truetype_StbTruetype.stbtt__new_active = function(e,eIndex,off_x,start_point) {
	var z = new kha_graphics2_truetype_Stbtt_$_$active_$edge();
	var dxdy = (e[eIndex].x1 - e[eIndex].x0) / (e[eIndex].y1 - e[eIndex].y0);
	if(z == null) {
		return z;
	}
	z.fdx = dxdy;
	z.fdy = dxdy != 0.0 ? 1.0 / dxdy : 0.0;
	z.fx = e[eIndex].x0 + dxdy * (start_point - e[eIndex].y0);
	z.fx -= off_x;
	z.direction = e[eIndex].invert ? 1.0 : -1.0;
	z.sy = e[eIndex].y0;
	z.ey = e[eIndex].y1;
	z.next = null;
	return z;
};
kha_graphics2_truetype_StbTruetype.stbtt__handle_clipped_edge = function(scanline,scanlineIndex,x,e,x0,y0,x1,y1) {
	if(y0 == y1) {
		return;
	}
	if(!(y0 < y1)) {
		throw new js__$Boot_HaxeError("Error");
	}
	if(!(e.sy <= e.ey)) {
		throw new js__$Boot_HaxeError("Error");
	}
	if(y0 > e.ey) {
		return;
	}
	if(y1 < e.sy) {
		return;
	}
	if(y0 < e.sy) {
		x0 += (x1 - x0) * (e.sy - y0) / (y1 - y0);
		y0 = e.sy;
	}
	if(y1 > e.ey) {
		x1 += (x1 - x0) * (e.ey - y1) / (y1 - y0);
		y1 = e.ey;
	}
	if(x0 == x) {
		if(!(x1 <= x + 1)) {
			throw new js__$Boot_HaxeError("Error");
		}
	} else if(x0 == x + 1) {
		if(!(x1 >= x)) {
			throw new js__$Boot_HaxeError("Error");
		}
	} else if(x0 <= x) {
		if(!(x1 <= x)) {
			throw new js__$Boot_HaxeError("Error");
		}
	} else if(x0 >= x + 1) {
		if(!(x1 >= x + 1)) {
			throw new js__$Boot_HaxeError("Error");
		}
	} else if(!(x1 >= x && x1 <= x + 1)) {
		throw new js__$Boot_HaxeError("Error");
	}
	if(x0 <= x && x1 <= x) {
		var _g = scanlineIndex + x;
		var _g1 = scanline;
		_g1[_g] = _g1[_g] + e.direction * (y1 - y0);
	} else if(!(x0 >= x + 1 && x1 >= x + 1)) {
		if(!(x0 >= x && x0 <= x + 1 && x1 >= x && x1 <= x + 1)) {
			throw new js__$Boot_HaxeError("Error");
		}
		var _g2 = scanlineIndex + x;
		var _g11 = scanline;
		_g11[_g2] = _g11[_g2] + e.direction * (y1 - y0) * (1 - (x0 - x + (x1 - x)) / 2);
	}
};
kha_graphics2_truetype_StbTruetype.stbtt__fill_active_edges_new = function(scanline,scanline_fill,scanline_fillIndex,len,e,y_top) {
	var y_bottom = y_top + 1;
	while(e != null) {
		if(!(e.ey >= y_top)) {
			throw new js__$Boot_HaxeError("Error");
		}
		if(e.fdx == 0) {
			var x0 = e.fx;
			if(x0 < len) {
				if(x0 >= 0) {
					kha_graphics2_truetype_StbTruetype.stbtt__handle_clipped_edge(scanline,0,x0 | 0,e,x0,y_top,x0,y_bottom);
					kha_graphics2_truetype_StbTruetype.stbtt__handle_clipped_edge(scanline_fill,scanline_fillIndex - 1,x0 + 1 | 0,e,x0,y_top,x0,y_bottom);
				} else {
					kha_graphics2_truetype_StbTruetype.stbtt__handle_clipped_edge(scanline_fill,scanline_fillIndex - 1,0,e,x0,y_top,x0,y_bottom);
				}
			}
		} else {
			var x01 = e.fx;
			var dx = e.fdx;
			var xb = x01 + dx;
			var x_top;
			var x_bottom;
			var sy0;
			var sy1;
			var dy = e.fdy;
			if(!(e.sy <= y_bottom && e.ey >= y_top)) {
				throw new js__$Boot_HaxeError("Error");
			}
			if(e.sy > y_top) {
				x_top = x01 + dx * (e.sy - y_top);
				sy0 = e.sy;
			} else {
				x_top = x01;
				sy0 = y_top;
			}
			if(e.ey < y_bottom) {
				x_bottom = x01 + dx * (e.ey - y_top);
				sy1 = e.ey;
			} else {
				x_bottom = xb;
				sy1 = y_bottom;
			}
			if(x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
				if((x_top | 0) == (x_bottom | 0)) {
					var height;
					var x = x_top | 0;
					height = sy1 - sy0;
					if(!(x >= 0 && x < len)) {
						throw new js__$Boot_HaxeError("Error");
					}
					var _g = x;
					var _g1 = scanline;
					_g1[_g] = _g1[_g] + e.direction * (1 - (x_top - x + (x_bottom - x)) / 2) * height;
					var _g2 = scanline_fillIndex + x;
					var _g11 = scanline_fill;
					_g11[_g2] = _g11[_g2] + e.direction * height;
				} else {
					var x1;
					var x11;
					var x2;
					var y_crossing;
					var step;
					var sign;
					var area;
					if(x_top > x_bottom) {
						var t;
						sy0 = y_bottom - (sy0 - y_top);
						sy1 = y_bottom - (sy1 - y_top);
						t = sy0;
						sy0 = sy1;
						sy1 = t;
						t = x_bottom;
						x_bottom = x_top;
						x_top = t;
						dx = -dx;
						dy = -dy;
						t = x01;
						x01 = xb;
						xb = t;
					}
					x11 = x_top | 0;
					x2 = x_bottom | 0;
					y_crossing = (x11 + 1 - x01) * dy + y_top;
					sign = e.direction;
					area = sign * (y_crossing - sy0);
					var _g3 = x11;
					var _g12 = scanline;
					_g12[_g3] = _g12[_g3] + area * (1 - (x_top - x11 + (x11 + 1 - x11)) / 2);
					step = sign * dy;
					var _g13 = x11 + 1;
					var _g4 = x2;
					while(_g13 < _g4) {
						var x3 = _g13++;
						var _g21 = x3;
						var _g31 = scanline;
						_g31[_g21] = _g31[_g21] + (area + step / 2);
						area += step;
					}
					y_crossing += dy * (x2 - (x11 + 1));
					if(!(Math.abs(area) <= 1.01)) {
						throw new js__$Boot_HaxeError("Error");
					}
					var _g5 = x2;
					var _g14 = scanline;
					_g14[_g5] = _g14[_g5] + (area + sign * (1 - (x2 - x2 + (x_bottom - x2)) / 2) * (sy1 - y_crossing));
					var _g6 = scanline_fillIndex + x2;
					var _g15 = scanline_fill;
					_g15[_g6] = _g15[_g6] + sign * (sy1 - sy0);
				}
			} else {
				var _g16 = 0;
				var _g7 = len;
				while(_g16 < _g7) {
					var x4 = _g16++;
					var y0 = y_top;
					var x12 = x4;
					var x21 = x4 + 1;
					var x31 = xb;
					var y3 = y_bottom;
					var y1;
					var y2;
					y1 = (x4 - x01) / dx + y_top;
					y2 = (x4 + 1 - x01) / dx + y_top;
					if(x01 < x12 && x31 > x21) {
						kha_graphics2_truetype_StbTruetype.stbtt__handle_clipped_edge(scanline,0,x4,e,x01,y0,x12,y1);
						kha_graphics2_truetype_StbTruetype.stbtt__handle_clipped_edge(scanline,0,x4,e,x12,y1,x21,y2);
						kha_graphics2_truetype_StbTruetype.stbtt__handle_clipped_edge(scanline,0,x4,e,x21,y2,x31,y3);
					} else if(x31 < x12 && x01 > x21) {
						kha_graphics2_truetype_StbTruetype.stbtt__handle_clipped_edge(scanline,0,x4,e,x01,y0,x21,y2);
						kha_graphics2_truetype_StbTruetype.stbtt__handle_clipped_edge(scanline,0,x4,e,x21,y2,x12,y1);
						kha_graphics2_truetype_StbTruetype.stbtt__handle_clipped_edge(scanline,0,x4,e,x12,y1,x31,y3);
					} else if(x01 < x12 && x31 > x12) {
						kha_graphics2_truetype_StbTruetype.stbtt__handle_clipped_edge(scanline,0,x4,e,x01,y0,x12,y1);
						kha_graphics2_truetype_StbTruetype.stbtt__handle_clipped_edge(scanline,0,x4,e,x12,y1,x31,y3);
					} else if(x31 < x12 && x01 > x12) {
						kha_graphics2_truetype_StbTruetype.stbtt__handle_clipped_edge(scanline,0,x4,e,x01,y0,x12,y1);
						kha_graphics2_truetype_StbTruetype.stbtt__handle_clipped_edge(scanline,0,x4,e,x12,y1,x31,y3);
					} else if(x01 < x21 && x31 > x21) {
						kha_graphics2_truetype_StbTruetype.stbtt__handle_clipped_edge(scanline,0,x4,e,x01,y0,x21,y2);
						kha_graphics2_truetype_StbTruetype.stbtt__handle_clipped_edge(scanline,0,x4,e,x21,y2,x31,y3);
					} else if(x31 < x21 && x01 > x21) {
						kha_graphics2_truetype_StbTruetype.stbtt__handle_clipped_edge(scanline,0,x4,e,x01,y0,x21,y2);
						kha_graphics2_truetype_StbTruetype.stbtt__handle_clipped_edge(scanline,0,x4,e,x21,y2,x31,y3);
					} else {
						kha_graphics2_truetype_StbTruetype.stbtt__handle_clipped_edge(scanline,0,x4,e,x01,y0,x31,y3);
					}
				}
			}
		}
		e = e.next;
	}
};
kha_graphics2_truetype_StbTruetype.stbtt__rasterize_sorted_edges = function(result,e,n,vsubsample,off_x,off_y) {
	var active = null;
	var y;
	var j = 0;
	var i;
	var scanline;
	var scanline2;
	var scanline2Index = 0;
	var eIndex = 0;
	if(result.w > 64) {
		var length = result.w * 2 + 1;
		var this1 = new Array(length);
		scanline = this1;
	} else {
		var this2 = new Array(129);
		scanline = this2;
	}
	scanline2 = scanline;
	scanline2Index = result.w;
	y = off_y;
	e[eIndex + n].y0 = off_y + result.h + 1;
	while(j < result.h) {
		var scan_y_top = y + 0.0;
		var scan_y_bottom = y + 1.0;
		var step_value;
		var step_parent;
		step_value = active;
		step_parent = null;
		var _g1 = 0;
		var _g = result.w;
		while(_g1 < _g) {
			var i1 = _g1++;
			scanline[i1] = 0;
		}
		var _g11 = 0;
		var _g2 = result.w + 1;
		while(_g11 < _g2) {
			var i2 = _g11++;
			scanline2[scanline2Index + i2] = 0;
		}
		while(step_value != null) {
			var z = step_value;
			if(z.ey <= scan_y_top) {
				if(step_parent == null) {
					active = z.next;
					step_value = z.next;
				} else {
					step_parent.next = z.next;
					step_value = z.next;
				}
				if(z.direction == 0) {
					throw new js__$Boot_HaxeError("Error");
				}
				z.direction = 0;
			} else {
				step_parent = step_value;
				step_value = step_value.next;
			}
		}
		while(e[eIndex].y0 <= scan_y_bottom) {
			if(e[eIndex].y0 != e[eIndex].y1) {
				var z1 = kha_graphics2_truetype_StbTruetype.stbtt__new_active(e,eIndex,off_x,scan_y_top);
				if(!(z1.ey >= scan_y_top)) {
					throw new js__$Boot_HaxeError("Error");
				}
				z1.next = active;
				active = z1;
			}
			++eIndex;
		}
		if(active != null) {
			kha_graphics2_truetype_StbTruetype.stbtt__fill_active_edges_new(scanline,scanline2,scanline2Index + 1,result.w,active,scan_y_top);
		}
		var sum = 0;
		var _g12 = 0;
		var _g3 = result.w;
		while(_g12 < _g3) {
			var i3 = _g12++;
			var k;
			var m;
			sum += scanline2[scanline2Index + i3];
			k = scanline[i3] + sum;
			k = Math.abs(k) * 255.0 + 0.5;
			m = k | 0;
			if(m > 255) {
				m = 255;
			}
			result.pixels.writeU8(result.pixels_offset + j * result.stride + i3,m);
		}
		step_parent = null;
		step_value = active;
		while(step_value != null) {
			var z2 = step_value;
			z2.fx += z2.fdx;
			step_parent = step_value;
			step_value = step_value.next;
		}
		++y;
		++j;
	}
};
kha_graphics2_truetype_StbTruetype.STBTT__COMPARE = function(a,b) {
	return a.y0 < b.y0;
};
kha_graphics2_truetype_StbTruetype.stbtt__sort_edges_ins_sort = function(p,n) {
	var i;
	var j;
	var _g1 = 1;
	var _g = n;
	while(_g1 < _g) {
		var i1 = _g1++;
		var t = p[i1];
		var a = t;
		j = i1;
		while(j > 0) {
			var b = p[j - 1];
			var c = kha_graphics2_truetype_StbTruetype.STBTT__COMPARE(a,b);
			if(!c) {
				break;
			}
			p[j] = p[j - 1];
			--j;
		}
		if(i1 != j) {
			p[j] = t;
		}
	}
};
kha_graphics2_truetype_StbTruetype.stbtt__sort_edges_quicksort = function(p,pIndex,n) {
	while(n > 12) {
		var t;
		var c01;
		var c12;
		var c;
		var m;
		var i;
		var j;
		m = n >> 1;
		c01 = kha_graphics2_truetype_StbTruetype.STBTT__COMPARE(p[pIndex],p[pIndex + m]);
		c12 = kha_graphics2_truetype_StbTruetype.STBTT__COMPARE(p[pIndex + m],p[pIndex + n - 1]);
		if(c01 != c12) {
			var z;
			c = kha_graphics2_truetype_StbTruetype.STBTT__COMPARE(p[pIndex],p[pIndex + n - 1]);
			if(c == c12) {
				z = 0;
			} else {
				z = n - 1;
			}
			t = p[pIndex + z];
			p[pIndex + z] = p[pIndex + m];
			p[pIndex + m] = t;
		}
		t = p[pIndex];
		p[pIndex] = p[pIndex + m];
		p[pIndex + m] = t;
		i = 1;
		j = n - 1;
		while(true) {
			while(kha_graphics2_truetype_StbTruetype.STBTT__COMPARE(p[pIndex + i],p[pIndex])) ++i;
			while(kha_graphics2_truetype_StbTruetype.STBTT__COMPARE(p[pIndex],p[pIndex + j])) --j;
			if(i >= j) {
				break;
			}
			t = p[pIndex + i];
			p[pIndex + i] = p[pIndex + j];
			p[pIndex + j] = t;
			++i;
			--j;
		}
		if(j < n - i) {
			kha_graphics2_truetype_StbTruetype.stbtt__sort_edges_quicksort(p,pIndex,j);
			pIndex += i;
			n -= i;
		} else {
			kha_graphics2_truetype_StbTruetype.stbtt__sort_edges_quicksort(p,pIndex + i,n - i);
			n = j;
		}
	}
};
kha_graphics2_truetype_StbTruetype.stbtt__sort_edges = function(p,n) {
	kha_graphics2_truetype_StbTruetype.stbtt__sort_edges_quicksort(p,0,n);
	kha_graphics2_truetype_StbTruetype.stbtt__sort_edges_ins_sort(p,n);
};
kha_graphics2_truetype_StbTruetype.stbtt__rasterize = function(result,pts,wcount,windings,scale_x,scale_y,shift_x,shift_y,off_x,off_y,invert) {
	var y_scale_inv = invert ? -scale_y : scale_y;
	var e;
	var n;
	var i;
	var j;
	var k;
	var m;
	var vsubsample = 1;
	var ptsIndex = 0;
	n = 0;
	var _g1 = 0;
	var _g = windings;
	while(_g1 < _g) {
		var i1 = _g1++;
		n += wcount[i1];
	}
	var this1 = new Array(n + 1);
	e = this1;
	if(e == null) {
		return;
	} else {
		var _g11 = 0;
		var _g2 = e.length;
		while(_g11 < _g2) {
			var i2 = _g11++;
			e[i2] = new kha_graphics2_truetype_Stbtt_$_$edge();
		}
	}
	n = 0;
	m = 0;
	var _g12 = 0;
	var _g3 = windings;
	while(_g12 < _g3) {
		var i3 = _g12++;
		var p = pts;
		var pIndex = ptsIndex + m;
		m += wcount[i3];
		j = wcount[i3] - 1;
		var _g31 = 0;
		var _g21 = wcount[i3];
		while(_g31 < _g21) {
			var k1 = _g31++;
			var a = k1;
			var b = j;
			if(p[pIndex + j].y == p[pIndex + k1].y) {
				j = k1;
				continue;
			}
			e[n].invert = false;
			if(invert ? p[pIndex + j].y > p[pIndex + k1].y : p[pIndex + j].y < p[pIndex + k1].y) {
				e[n].invert = true;
				a = j;
				b = k1;
			}
			e[n].x0 = p[pIndex + a].x * scale_x + shift_x;
			e[n].y0 = (p[pIndex + a].y * y_scale_inv + shift_y) * vsubsample;
			e[n].x1 = p[pIndex + b].x * scale_x + shift_x;
			e[n].y1 = (p[pIndex + b].y * y_scale_inv + shift_y) * vsubsample;
			++n;
			j = k1;
		}
	}
	kha_graphics2_truetype_StbTruetype.stbtt__sort_edges(e,n);
	kha_graphics2_truetype_StbTruetype.stbtt__rasterize_sorted_edges(result,e,n,vsubsample,off_x,off_y);
};
kha_graphics2_truetype_StbTruetype.stbtt__add_point = function(points,n,x,y) {
	if(points == null) {
		return;
	}
	points[n].x = x;
	points[n].y = y;
};
kha_graphics2_truetype_StbTruetype.stbtt__tesselate_curve = function(points,num_points,x0,y0,x1,y1,x2,y2,objspace_flatness_squared,n) {
	var mx = (x0 + 2 * x1 + x2) / 4;
	var my = (y0 + 2 * y1 + y2) / 4;
	var dx = (x0 + x2) / 2 - mx;
	var dy = (y0 + y2) / 2 - my;
	if(n > 16) {
		return 1;
	}
	if(dx * dx + dy * dy > objspace_flatness_squared) {
		kha_graphics2_truetype_StbTruetype.stbtt__tesselate_curve(points,num_points,x0,y0,(x0 + x1) / 2.0,(y0 + y1) / 2.0,mx,my,objspace_flatness_squared,n + 1);
		kha_graphics2_truetype_StbTruetype.stbtt__tesselate_curve(points,num_points,mx,my,(x1 + x2) / 2.0,(y1 + y2) / 2.0,x2,y2,objspace_flatness_squared,n + 1);
	} else {
		kha_graphics2_truetype_StbTruetype.stbtt__add_point(points,num_points.value,x2,y2);
		num_points.value += 1;
	}
	return 1;
};
kha_graphics2_truetype_StbTruetype.stbtt_FlattenCurves = function(vertices,num_verts,objspace_flatness,contour_lengths,num_contours) {
	var points = null;
	var num_points = 0;
	var objspace_flatness_squared = objspace_flatness * objspace_flatness;
	var i;
	var n = 0;
	var start = 0;
	var pass;
	var _g1 = 0;
	var _g = num_verts;
	while(_g1 < _g) {
		var i1 = _g1++;
		if(vertices[i1].type == 1) {
			++n;
		}
	}
	num_contours.value = n;
	if(n == 0) {
		return null;
	}
	var this1 = new Array(n);
	contour_lengths.value = this1;
	if(contour_lengths.value == null) {
		num_contours.value = 0;
		return null;
	}
	var _g2 = 0;
	while(_g2 < 2) {
		var pass1 = _g2++;
		var x = 0;
		var y = 0;
		if(pass1 == 1) {
			var this2 = new Array(num_points);
			points = this2;
			if(points == null) {
				contour_lengths.value = null;
				num_contours.value = 0;
				return null;
			} else {
				var _g21 = 0;
				var _g11 = points.length;
				while(_g21 < _g11) {
					var i2 = _g21++;
					points[i2] = new kha_graphics2_truetype_Stbtt_$_$point();
				}
			}
		}
		num_points = 0;
		n = -1;
		var _g22 = 0;
		var _g12 = num_verts;
		while(_g22 < _g12) {
			var i3 = _g22++;
			var _g3 = vertices[i3].type;
			switch(_g3) {
			case 1:
				if(n >= 0) {
					contour_lengths.value[n] = num_points - start;
				}
				++n;
				start = num_points;
				x = vertices[i3].x;
				y = vertices[i3].y;
				kha_graphics2_truetype_StbTruetype.stbtt__add_point(points,num_points++,x,y);
				break;
			case 2:
				x = vertices[i3].x;
				y = vertices[i3].y;
				kha_graphics2_truetype_StbTruetype.stbtt__add_point(points,num_points++,x,y);
				break;
			case 3:
				var num_points_reference = { value : num_points};
				kha_graphics2_truetype_StbTruetype.stbtt__tesselate_curve(points,num_points_reference,x,y,vertices[i3].cx,vertices[i3].cy,vertices[i3].x,vertices[i3].y,objspace_flatness_squared,0);
				num_points = num_points_reference.value;
				x = vertices[i3].x;
				y = vertices[i3].y;
				break;
			}
		}
		contour_lengths.value[n] = num_points - start;
	}
	return points;
};
kha_graphics2_truetype_StbTruetype.stbtt_Rasterize = function(result,flatness_in_pixels,vertices,num_verts,scale_x,scale_y,shift_x,shift_y,x_off,y_off,invert) {
	var scale = scale_x > scale_y ? scale_y : scale_x;
	var winding_count = 0;
	var winding_lengths = null;
	var winding_count_reference = { value : winding_count};
	var winding_lengths_reference = new kha_graphics2_truetype_VectorOfIntPointer();
	var windings = kha_graphics2_truetype_StbTruetype.stbtt_FlattenCurves(vertices,num_verts,flatness_in_pixels / scale,winding_lengths_reference,winding_count_reference);
	winding_count = winding_count_reference.value;
	winding_lengths = winding_lengths_reference.value;
	if(windings != null) {
		kha_graphics2_truetype_StbTruetype.stbtt__rasterize(result,windings,winding_lengths,winding_count,scale_x,scale_y,shift_x,shift_y,x_off,y_off,invert);
	}
};
kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphBitmapSubpixel = function(info,scale_x,scale_y,shift_x,shift_y,glyph,region) {
	var ix0;
	var iy0;
	var ix1;
	var iy1;
	var gbm = new kha_graphics2_truetype_Stbtt_$_$bitmap();
	var vertices = kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphShape(info,glyph);
	var num_verts = vertices.length;
	if(scale_x == 0) {
		scale_x = scale_y;
	}
	if(scale_y == 0) {
		if(scale_x == 0) {
			return null;
		}
		scale_y = scale_x;
	}
	var rect = kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphBitmapBoxSubpixel(info,glyph,scale_x,scale_y,shift_x,shift_y);
	ix0 = rect.x0;
	iy0 = rect.y0;
	ix1 = rect.x1;
	iy1 = rect.y1;
	gbm.w = ix1 - ix0;
	gbm.h = iy1 - iy0;
	gbm.pixels = null;
	region.width = gbm.w;
	region.height = gbm.h;
	region.xoff = ix0;
	region.yoff = iy0;
	if(gbm.w != 0 && gbm.h != 0) {
		gbm.pixels = kha_internal_BytesBlob.alloc(gbm.w * gbm.h);
		if(gbm.pixels != null) {
			gbm.stride = gbm.w;
			kha_graphics2_truetype_StbTruetype.stbtt_Rasterize(gbm,0.35,vertices,num_verts,scale_x,scale_y,shift_x,shift_y,ix0,iy0,true);
		}
	}
	return gbm.pixels;
};
kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphBitmap = function(info,scale_x,scale_y,glyph,region) {
	return kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphBitmapSubpixel(info,scale_x,scale_y,0.0,0.0,glyph,region);
};
kha_graphics2_truetype_StbTruetype.stbtt_MakeGlyphBitmapSubpixel = function(info,output,output_offset,out_w,out_h,out_stride,scale_x,scale_y,shift_x,shift_y,glyph) {
	var ix0 = 0;
	var iy0 = 0;
	var vertices = kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphShape(info,glyph);
	var num_verts = vertices == null ? 0 : vertices.length;
	var gbm = new kha_graphics2_truetype_Stbtt_$_$bitmap();
	var rect = kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphBitmapBoxSubpixel(info,glyph,scale_x,scale_y,shift_x,shift_y);
	ix0 = rect.x0;
	iy0 = rect.y0;
	gbm.pixels = output;
	gbm.pixels_offset = output_offset;
	gbm.w = out_w;
	gbm.h = out_h;
	gbm.stride = out_stride;
	if(gbm.w != 0 && gbm.h != 0) {
		kha_graphics2_truetype_StbTruetype.stbtt_Rasterize(gbm,0.35,vertices,num_verts,scale_x,scale_y,shift_x,shift_y,ix0,iy0,true);
	}
};
kha_graphics2_truetype_StbTruetype.stbtt_MakeGlyphBitmap = function(info,output,output_offset,out_w,out_h,out_stride,scale_x,scale_y,glyph) {
	kha_graphics2_truetype_StbTruetype.stbtt_MakeGlyphBitmapSubpixel(info,output,output_offset,out_w,out_h,out_stride,scale_x,scale_y,0.0,0.0,glyph);
};
kha_graphics2_truetype_StbTruetype.stbtt_GetCodepointBitmapSubpixel = function(info,scale_x,scale_y,shift_x,shift_y,codepoint,region) {
	return kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphBitmapSubpixel(info,scale_x,scale_y,shift_x,shift_y,kha_graphics2_truetype_StbTruetype.stbtt_FindGlyphIndex(info,codepoint),region);
};
kha_graphics2_truetype_StbTruetype.stbtt_MakeCodepointBitmapSubpixel = function(info,output,output_offset,out_w,out_h,out_stride,scale_x,scale_y,shift_x,shift_y,codepoint) {
	kha_graphics2_truetype_StbTruetype.stbtt_MakeGlyphBitmapSubpixel(info,output,output_offset,out_w,out_h,out_stride,scale_x,scale_y,shift_x,shift_y,kha_graphics2_truetype_StbTruetype.stbtt_FindGlyphIndex(info,codepoint));
};
kha_graphics2_truetype_StbTruetype.stbtt_GetCodepointBitmap = function(info,scale_x,scale_y,codepoint,region) {
	return kha_graphics2_truetype_StbTruetype.stbtt_GetCodepointBitmapSubpixel(info,scale_x,scale_y,0.0,0.0,codepoint,region);
};
kha_graphics2_truetype_StbTruetype.stbtt_MakeCodepointBitmap = function(info,output,output_offset,out_w,out_h,out_stride,scale_x,scale_y,codepoint) {
	kha_graphics2_truetype_StbTruetype.stbtt_MakeCodepointBitmapSubpixel(info,output,output_offset,out_w,out_h,out_stride,scale_x,scale_y,0.0,0.0,codepoint);
};
kha_graphics2_truetype_StbTruetype.stbtt_BakeFontBitmap = function(data,offset,pixel_height,pixels,pw,ph,chars,chardata) {
	var scale;
	var x;
	var y;
	var bottom_y;
	var f = new kha_graphics2_truetype_Stbtt_$fontinfo();
	if(!kha_graphics2_truetype_StbTruetype.stbtt_InitFont(f,data,offset)) {
		return -1;
	}
	var _g1 = 0;
	var _g = pw * ph;
	while(_g1 < _g) {
		var i = _g1++;
		pixels.writeU8(i,0);
	}
	y = 1;
	x = y;
	bottom_y = 1;
	scale = kha_graphics2_truetype_StbTruetype.stbtt_ScaleForPixelHeight(f,pixel_height);
	var i1 = 0;
	var _g2 = 0;
	while(_g2 < chars.length) {
		var index = chars[_g2];
		++_g2;
		var advance;
		var lsb;
		var x0;
		var y0;
		var x1;
		var y1;
		var gw;
		var gh;
		var g = kha_graphics2_truetype_StbTruetype.stbtt_FindGlyphIndex(f,index);
		var metrics = kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphHMetrics(f,g);
		advance = metrics.advanceWidth;
		lsb = metrics.leftSideBearing;
		var rect = kha_graphics2_truetype_StbTruetype.stbtt_GetGlyphBitmapBox(f,g,scale,scale);
		x0 = rect.x0;
		y0 = rect.y0;
		x1 = rect.x1;
		y1 = rect.y1;
		gw = x1 - x0;
		gh = y1 - y0;
		if(x + gw + 1 >= pw) {
			y = bottom_y;
			x = 1;
		}
		if(y + gh + 1 >= ph) {
			return -i1;
		}
		if(x + gw >= pw) {
			throw new js__$Boot_HaxeError("Error");
		}
		if(y + gh >= ph) {
			throw new js__$Boot_HaxeError("Error");
		}
		kha_graphics2_truetype_StbTruetype.stbtt_MakeGlyphBitmap(f,pixels,x + y * pw,gw,gh,pw,scale,scale,g);
		chardata[i1].x0 = x;
		chardata[i1].y0 = y;
		chardata[i1].x1 = x + gw;
		chardata[i1].y1 = y + gh;
		chardata[i1].xadvance = scale * advance;
		chardata[i1].xoff = x0;
		chardata[i1].yoff = y0;
		x = x + gw + 1;
		if(y + gh + 1 > bottom_y) {
			bottom_y = y + gh + 1;
		}
		++i1;
	}
	return bottom_y;
};
kha_graphics2_truetype_StbTruetype.stbtt_GetBakedQuad = function(chardata,pw,ph,char_index,xpos,ypos,q,opengl_fillrule) {
	var d3d_bias = opengl_fillrule ? 0 : -0.5;
	var ipw = 1.0 / pw;
	var iph = 1.0 / ph;
	var b = chardata[char_index];
	var round_x = Math.floor(xpos.value + b.xoff + 0.5);
	var round_y = Math.floor(ypos.value + b.yoff + 0.5);
	q.x0 = round_x + d3d_bias;
	q.y0 = round_y + d3d_bias;
	q.x1 = round_x + b.x1 - b.x0 + d3d_bias;
	q.y1 = round_y + b.y1 - b.y0 + d3d_bias;
	q.s0 = b.x0 * ipw;
	q.t0 = b.y0 * iph;
	q.s1 = b.x1 * ipw;
	q.t1 = b.y1 * iph;
	xpos.value += b.xadvance;
};
var kha_graphics4_BlendingFactor = $hxClasses["kha.graphics4.BlendingFactor"] = { __ename__ : true, __constructs__ : ["Undefined","BlendOne","BlendZero","SourceAlpha","DestinationAlpha","InverseSourceAlpha","InverseDestinationAlpha","SourceColor","DestinationColor","InverseSourceColor","InverseDestinationColor"] };
kha_graphics4_BlendingFactor.Undefined = ["Undefined",0];
kha_graphics4_BlendingFactor.Undefined.toString = $estr;
kha_graphics4_BlendingFactor.Undefined.__enum__ = kha_graphics4_BlendingFactor;
kha_graphics4_BlendingFactor.BlendOne = ["BlendOne",1];
kha_graphics4_BlendingFactor.BlendOne.toString = $estr;
kha_graphics4_BlendingFactor.BlendOne.__enum__ = kha_graphics4_BlendingFactor;
kha_graphics4_BlendingFactor.BlendZero = ["BlendZero",2];
kha_graphics4_BlendingFactor.BlendZero.toString = $estr;
kha_graphics4_BlendingFactor.BlendZero.__enum__ = kha_graphics4_BlendingFactor;
kha_graphics4_BlendingFactor.SourceAlpha = ["SourceAlpha",3];
kha_graphics4_BlendingFactor.SourceAlpha.toString = $estr;
kha_graphics4_BlendingFactor.SourceAlpha.__enum__ = kha_graphics4_BlendingFactor;
kha_graphics4_BlendingFactor.DestinationAlpha = ["DestinationAlpha",4];
kha_graphics4_BlendingFactor.DestinationAlpha.toString = $estr;
kha_graphics4_BlendingFactor.DestinationAlpha.__enum__ = kha_graphics4_BlendingFactor;
kha_graphics4_BlendingFactor.InverseSourceAlpha = ["InverseSourceAlpha",5];
kha_graphics4_BlendingFactor.InverseSourceAlpha.toString = $estr;
kha_graphics4_BlendingFactor.InverseSourceAlpha.__enum__ = kha_graphics4_BlendingFactor;
kha_graphics4_BlendingFactor.InverseDestinationAlpha = ["InverseDestinationAlpha",6];
kha_graphics4_BlendingFactor.InverseDestinationAlpha.toString = $estr;
kha_graphics4_BlendingFactor.InverseDestinationAlpha.__enum__ = kha_graphics4_BlendingFactor;
kha_graphics4_BlendingFactor.SourceColor = ["SourceColor",7];
kha_graphics4_BlendingFactor.SourceColor.toString = $estr;
kha_graphics4_BlendingFactor.SourceColor.__enum__ = kha_graphics4_BlendingFactor;
kha_graphics4_BlendingFactor.DestinationColor = ["DestinationColor",8];
kha_graphics4_BlendingFactor.DestinationColor.toString = $estr;
kha_graphics4_BlendingFactor.DestinationColor.__enum__ = kha_graphics4_BlendingFactor;
kha_graphics4_BlendingFactor.InverseSourceColor = ["InverseSourceColor",9];
kha_graphics4_BlendingFactor.InverseSourceColor.toString = $estr;
kha_graphics4_BlendingFactor.InverseSourceColor.__enum__ = kha_graphics4_BlendingFactor;
kha_graphics4_BlendingFactor.InverseDestinationColor = ["InverseDestinationColor",10];
kha_graphics4_BlendingFactor.InverseDestinationColor.toString = $estr;
kha_graphics4_BlendingFactor.InverseDestinationColor.__enum__ = kha_graphics4_BlendingFactor;
var kha_graphics4_BlendingOperation = $hxClasses["kha.graphics4.BlendingOperation"] = { __ename__ : true, __constructs__ : ["Add","Subtract","ReverseSubtract","Min","Max"] };
kha_graphics4_BlendingOperation.Add = ["Add",0];
kha_graphics4_BlendingOperation.Add.toString = $estr;
kha_graphics4_BlendingOperation.Add.__enum__ = kha_graphics4_BlendingOperation;
kha_graphics4_BlendingOperation.Subtract = ["Subtract",1];
kha_graphics4_BlendingOperation.Subtract.toString = $estr;
kha_graphics4_BlendingOperation.Subtract.__enum__ = kha_graphics4_BlendingOperation;
kha_graphics4_BlendingOperation.ReverseSubtract = ["ReverseSubtract",2];
kha_graphics4_BlendingOperation.ReverseSubtract.toString = $estr;
kha_graphics4_BlendingOperation.ReverseSubtract.__enum__ = kha_graphics4_BlendingOperation;
kha_graphics4_BlendingOperation.Min = ["Min",3];
kha_graphics4_BlendingOperation.Min.toString = $estr;
kha_graphics4_BlendingOperation.Min.__enum__ = kha_graphics4_BlendingOperation;
kha_graphics4_BlendingOperation.Max = ["Max",4];
kha_graphics4_BlendingOperation.Max.toString = $estr;
kha_graphics4_BlendingOperation.Max.__enum__ = kha_graphics4_BlendingOperation;
var kha_graphics4_CompareMode = $hxClasses["kha.graphics4.CompareMode"] = { __ename__ : true, __constructs__ : ["Always","Never","Equal","NotEqual","Less","LessEqual","Greater","GreaterEqual"] };
kha_graphics4_CompareMode.Always = ["Always",0];
kha_graphics4_CompareMode.Always.toString = $estr;
kha_graphics4_CompareMode.Always.__enum__ = kha_graphics4_CompareMode;
kha_graphics4_CompareMode.Never = ["Never",1];
kha_graphics4_CompareMode.Never.toString = $estr;
kha_graphics4_CompareMode.Never.__enum__ = kha_graphics4_CompareMode;
kha_graphics4_CompareMode.Equal = ["Equal",2];
kha_graphics4_CompareMode.Equal.toString = $estr;
kha_graphics4_CompareMode.Equal.__enum__ = kha_graphics4_CompareMode;
kha_graphics4_CompareMode.NotEqual = ["NotEqual",3];
kha_graphics4_CompareMode.NotEqual.toString = $estr;
kha_graphics4_CompareMode.NotEqual.__enum__ = kha_graphics4_CompareMode;
kha_graphics4_CompareMode.Less = ["Less",4];
kha_graphics4_CompareMode.Less.toString = $estr;
kha_graphics4_CompareMode.Less.__enum__ = kha_graphics4_CompareMode;
kha_graphics4_CompareMode.LessEqual = ["LessEqual",5];
kha_graphics4_CompareMode.LessEqual.toString = $estr;
kha_graphics4_CompareMode.LessEqual.__enum__ = kha_graphics4_CompareMode;
kha_graphics4_CompareMode.Greater = ["Greater",6];
kha_graphics4_CompareMode.Greater.toString = $estr;
kha_graphics4_CompareMode.Greater.__enum__ = kha_graphics4_CompareMode;
kha_graphics4_CompareMode.GreaterEqual = ["GreaterEqual",7];
kha_graphics4_CompareMode.GreaterEqual.toString = $estr;
kha_graphics4_CompareMode.GreaterEqual.__enum__ = kha_graphics4_CompareMode;
var kha_graphics4_ConstantLocation = function() { };
$hxClasses["kha.graphics4.ConstantLocation"] = kha_graphics4_ConstantLocation;
kha_graphics4_ConstantLocation.__name__ = true;
var kha_graphics4_CubeMap = function(size,format,renderTarget,depthStencilFormat) {
	this.isDepthAttachment = false;
	this.depthTexture = null;
	this.texture = null;
	this.frameBuffer = null;
	this.myWidth = size;
	this.myHeight = size;
	this.format = format;
	this.renderTarget = renderTarget;
	this.depthStencilFormat = depthStencilFormat;
	if(renderTarget) {
		this.createTexture();
	}
};
$hxClasses["kha.graphics4.CubeMap"] = kha_graphics4_CubeMap;
kha_graphics4_CubeMap.__name__ = true;
kha_graphics4_CubeMap.__interfaces__ = [kha_Resource,kha_Canvas];
kha_graphics4_CubeMap.createRenderTarget = function(size,format,depthStencil,contextId) {
	if(contextId == null) {
		contextId = 0;
	}
	if(format == null) {
		format = kha_graphics4_TextureFormat.RGBA32;
	}
	if(depthStencil == null) {
		depthStencil = 0;
	}
	return new kha_graphics4_CubeMap(size,format,true,depthStencil);
};
kha_graphics4_CubeMap.prototype = {
	myWidth: null
	,myHeight: null
	,format: null
	,renderTarget: null
	,depthStencilFormat: null
	,graphics4: null
	,frameBuffer: null
	,texture: null
	,depthTexture: null
	,isDepthAttachment: null
	,createTexture: function() {
		if(kha_SystemImpl.gl == null) {
			return;
		}
		this.texture = kha_SystemImpl.gl.createTexture();
		kha_SystemImpl.gl.bindTexture(34067,this.texture);
		kha_SystemImpl.gl.texParameteri(34067,10240,9729);
		kha_SystemImpl.gl.texParameteri(34067,10241,9729);
		kha_SystemImpl.gl.texParameteri(34067,10242,33071);
		kha_SystemImpl.gl.texParameteri(34067,10243,33071);
		if(this.renderTarget) {
			this.frameBuffer = kha_SystemImpl.gl.createFramebuffer();
			kha_SystemImpl.gl.bindFramebuffer(36160,this.frameBuffer);
			var _g = this.format;
			switch(_g[1]) {
			case 0:
				var _g1 = 0;
				while(_g1 < 6) {
					var i = _g1++;
					kha_SystemImpl.gl.texImage2D(34069 + i,0,6408,this.myWidth,this.myHeight,0,6408,5121,null);
				}
				break;
			case 2:
				var _g2 = 0;
				while(_g2 < 6) {
					var i1 = _g2++;
					kha_SystemImpl.gl.texImage2D(34069 + i1,0,kha_SystemImpl.gl2 ? 34836 : 6408,this.myWidth,this.myHeight,0,6408,5126,null);
				}
				break;
			case 3:
				var _g3 = 0;
				while(_g3 < 6) {
					var i2 = _g3++;
					kha_SystemImpl.gl.texImage2D(34069 + i2,0,kha_SystemImpl.gl2 ? 33189 : 6402,this.myWidth,this.myHeight,0,6402,5123,null);
				}
				break;
			case 4:
				var _g4 = 0;
				while(_g4 < 6) {
					var i3 = _g4++;
					kha_SystemImpl.gl.texImage2D(34069 + i3,0,kha_SystemImpl.gl2 ? 34842 : 6408,this.myWidth,this.myHeight,0,6408,kha_SystemImpl.halfFloat.HALF_FLOAT_OES,null);
				}
				break;
			case 5:
				var _g5 = 0;
				while(_g5 < 6) {
					var i4 = _g5++;
					kha_SystemImpl.gl.texImage2D(34069 + i4,0,kha_SystemImpl.gl2 ? 33326 : 6406,this.myWidth,this.myHeight,0,6406,5126,null);
				}
				break;
			case 6:
				var _g6 = 0;
				while(_g6 < 6) {
					var i5 = _g6++;
					kha_SystemImpl.gl.texImage2D(34069 + i5,0,kha_SystemImpl.gl2 ? 33325 : 6406,this.myWidth,this.myHeight,0,6406,kha_SystemImpl.halfFloat.HALF_FLOAT_OES,null);
				}
				break;
			default:
				var _g7 = 0;
				while(_g7 < 6) {
					var i6 = _g7++;
					kha_SystemImpl.gl.texImage2D(34069 + i6,0,6408,this.myWidth,this.myHeight,0,6408,5121,null);
				}
			}
			if(this.format == kha_graphics4_TextureFormat.DEPTH16) {
				kha_SystemImpl.gl.texParameteri(34067,10240,9728);
				kha_SystemImpl.gl.texParameteri(34067,10241,9728);
				this.isDepthAttachment = true;
				if(!kha_SystemImpl.gl2) {
					var colortex = kha_SystemImpl.gl.createTexture();
					kha_SystemImpl.gl.bindTexture(34067,colortex);
					var _g11 = 0;
					while(_g11 < 6) {
						var i7 = _g11++;
						kha_SystemImpl.gl.texImage2D(34069 + i7,0,6408,this.myWidth,this.myHeight,0,6408,5121,null);
						kha_SystemImpl.gl.framebufferTexture2D(36160,36064,34069 + i7,colortex,0);
					}
					kha_SystemImpl.gl.bindTexture(34067,this.texture);
				}
			}
			this.initDepthStencilBuffer(this.depthStencilFormat);
			kha_SystemImpl.gl.bindFramebuffer(36160,null);
		}
		kha_SystemImpl.gl.bindTexture(34067,null);
	}
	,initDepthStencilBuffer: function(depthStencilFormat) {
		switch(depthStencilFormat) {
		case 0:
			break;
		case 1:case 5:
			this.depthTexture = kha_SystemImpl.gl.createTexture();
			kha_SystemImpl.gl.bindTexture(34067,this.depthTexture);
			if(depthStencilFormat == 1) {
				kha_SystemImpl.gl.texImage2D(34067,0,kha_SystemImpl.gl2 ? 33190 : 6402,this.myWidth,this.myHeight,0,6402,5125,null);
			} else {
				kha_SystemImpl.gl.texImage2D(34067,0,kha_SystemImpl.gl2 ? 33189 : 6402,this.myWidth,this.myHeight,0,6402,5123,null);
			}
			kha_SystemImpl.gl.texParameteri(34067,10240,9728);
			kha_SystemImpl.gl.texParameteri(34067,10241,9728);
			kha_SystemImpl.gl.texParameteri(34067,10242,33071);
			kha_SystemImpl.gl.texParameteri(34067,10243,33071);
			kha_SystemImpl.gl.bindFramebuffer(36160,this.frameBuffer);
			kha_SystemImpl.gl.framebufferTexture2D(36160,36096,34067,this.depthTexture,0);
			break;
		case 2:case 3:case 4:
			this.depthTexture = kha_SystemImpl.gl.createTexture();
			kha_SystemImpl.gl.bindTexture(34067,this.depthTexture);
			kha_SystemImpl.gl.texImage2D(34067,0,kha_SystemImpl.gl2 ? 35056 : 34041,this.myWidth,this.myHeight,0,34041,kha_SystemImpl.depthTexture.UNSIGNED_INT_24_8_WEBGL,null);
			kha_SystemImpl.gl.texParameteri(34067,10240,9728);
			kha_SystemImpl.gl.texParameteri(34067,10241,9728);
			kha_SystemImpl.gl.texParameteri(34067,10242,33071);
			kha_SystemImpl.gl.texParameteri(34067,10243,33071);
			kha_SystemImpl.gl.bindFramebuffer(36160,this.frameBuffer);
			kha_SystemImpl.gl.framebufferTexture2D(36160,33306,34067,this.depthTexture,0);
			break;
		}
	}
	,set: function(stage) {
		kha_SystemImpl.gl.activeTexture(33984 + stage);
		kha_SystemImpl.gl.bindTexture(34067,this.texture);
	}
	,setDepth: function(stage) {
		kha_SystemImpl.gl.activeTexture(33984 + stage);
		kha_SystemImpl.gl.bindTexture(34067,this.depthTexture);
	}
	,unload: function() {
	}
	,lock: function(level) {
		if(level == null) {
			level = 0;
		}
		return null;
	}
	,unlock: function() {
	}
	,width: null
	,get_width: function() {
		return this.myWidth;
	}
	,height: null
	,get_height: function() {
		return this.myHeight;
	}
	,g1: null
	,get_g1: function() {
		return null;
	}
	,g2: null
	,get_g2: function() {
		return null;
	}
	,g4: null
	,get_g4: function() {
		if(this.graphics4 == null) {
			this.graphics4 = new kha_js_graphics4_Graphics(this);
		}
		return this.graphics4;
	}
	,__class__: kha_graphics4_CubeMap
};
var kha_graphics4_CullMode = $hxClasses["kha.graphics4.CullMode"] = { __ename__ : true, __constructs__ : ["Clockwise","CounterClockwise","None"] };
kha_graphics4_CullMode.Clockwise = ["Clockwise",0];
kha_graphics4_CullMode.Clockwise.toString = $estr;
kha_graphics4_CullMode.Clockwise.__enum__ = kha_graphics4_CullMode;
kha_graphics4_CullMode.CounterClockwise = ["CounterClockwise",1];
kha_graphics4_CullMode.CounterClockwise.toString = $estr;
kha_graphics4_CullMode.CounterClockwise.__enum__ = kha_graphics4_CullMode;
kha_graphics4_CullMode.None = ["None",2];
kha_graphics4_CullMode.None.toString = $estr;
kha_graphics4_CullMode.None.__enum__ = kha_graphics4_CullMode;
var kha_graphics4_FragmentShader = function(sources,files) {
	this.sources = [];
	var _g = 0;
	while(_g < sources.length) {
		var source = sources[_g];
		++_g;
		this.sources.push(source.toString());
	}
	this.type = 35632;
	this.shader = null;
	this.files = files;
};
$hxClasses["kha.graphics4.FragmentShader"] = kha_graphics4_FragmentShader;
kha_graphics4_FragmentShader.__name__ = true;
kha_graphics4_FragmentShader.fromSource = function(source) {
	var shader = new kha_graphics4_FragmentShader([],["runtime-string"]);
	shader.sources.push(source);
	return shader;
};
kha_graphics4_FragmentShader.prototype = {
	sources: null
	,type: null
	,shader: null
	,files: null
	,'delete': function() {
		kha_SystemImpl.gl.deleteShader(this.shader);
		this.shader = null;
		this.sources = null;
	}
	,__class__: kha_graphics4_FragmentShader
};
var kha_graphics4_GeometryShader = function(source) {
};
$hxClasses["kha.graphics4.GeometryShader"] = kha_graphics4_GeometryShader;
kha_graphics4_GeometryShader.__name__ = true;
kha_graphics4_GeometryShader.prototype = {
	'delete': function() {
	}
	,__class__: kha_graphics4_GeometryShader
};
var kha_graphics4_Graphics = function() { };
$hxClasses["kha.graphics4.Graphics"] = kha_graphics4_Graphics;
kha_graphics4_Graphics.__name__ = true;
kha_graphics4_Graphics.prototype = {
	begin: null
	,beginFace: null
	,beginEye: null
	,end: null
	,vsynced: null
	,refreshRate: null
	,clear: null
	,viewport: null
	,scissor: null
	,disableScissor: null
	,setVertexBuffer: null
	,setVertexBuffers: null
	,setIndexBuffer: null
	,setTexture: null
	,setTextureDepth: null
	,setTextureArray: null
	,setVideoTexture: null
	,setImageTexture: null
	,setTextureParameters: null
	,setTexture3DParameters: null
	,setCubeMap: null
	,setCubeMapDepth: null
	,renderTargetsInvertedY: null
	,instancedRenderingAvailable: null
	,setPipeline: null
	,setBool: null
	,setInt: null
	,setFloat: null
	,setFloat2: null
	,setFloat3: null
	,setFloat4: null
	,setFloats: null
	,setVector2: null
	,setVector3: null
	,setVector4: null
	,setMatrix: null
	,setMatrix3: null
	,drawIndexedVertices: null
	,drawIndexedVerticesInstanced: null
	,flush: null
	,__class__: kha_graphics4_Graphics
};
var kha_graphics4_ImageShaderPainter = function(g4) {
	this.destinationBlend = kha_graphics4_BlendingFactor.Undefined;
	this.sourceBlend = kha_graphics4_BlendingFactor.Undefined;
	this.myPipeline = null;
	this.bilinearMipmaps = false;
	this.bilinear = false;
	this.g = g4;
	this.bufferIndex = 0;
	kha_graphics4_ImageShaderPainter.initShaders();
	this.initBuffers();
	this.projectionLocation = kha_graphics4_ImageShaderPainter.shaderPipeline.getConstantLocation("projectionMatrix");
	this.textureLocation = kha_graphics4_ImageShaderPainter.shaderPipeline.getTextureUnit("tex");
};
$hxClasses["kha.graphics4.ImageShaderPainter"] = kha_graphics4_ImageShaderPainter;
kha_graphics4_ImageShaderPainter.__name__ = true;
kha_graphics4_ImageShaderPainter.initShaders = function() {
	if(kha_graphics4_ImageShaderPainter.shaderPipeline == null) {
		kha_graphics4_ImageShaderPainter.structure = kha_graphics4_Graphics2.createImageVertexStructure();
		kha_graphics4_ImageShaderPainter.shaderPipeline = kha_graphics4_Graphics2.createImagePipeline(kha_graphics4_ImageShaderPainter.structure);
		kha_graphics4_ImageShaderPainter.shaderPipeline.compile();
	}
};
kha_graphics4_ImageShaderPainter.prototype = {
	projectionMatrix: null
	,projectionLocation: null
	,textureLocation: null
	,bufferIndex: null
	,rectVertexBuffer: null
	,rectVertices: null
	,indexBuffer: null
	,lastTexture: null
	,bilinear: null
	,bilinearMipmaps: null
	,g: null
	,myPipeline: null
	,sourceBlend: null
	,destinationBlend: null
	,get_pipeline: function() {
		return this.myPipeline;
	}
	,set_pipeline: function(pipe) {
		if(pipe == null) {
			this.projectionLocation = kha_graphics4_ImageShaderPainter.shaderPipeline.getConstantLocation("projectionMatrix");
			this.textureLocation = kha_graphics4_ImageShaderPainter.shaderPipeline.getTextureUnit("tex");
		} else {
			this.projectionLocation = pipe.getConstantLocation("projectionMatrix");
			this.textureLocation = pipe.getTextureUnit("tex");
		}
		return this.myPipeline = pipe;
	}
	,setProjection: function(projectionMatrix) {
		this.projectionMatrix = projectionMatrix;
	}
	,initBuffers: function() {
		this.rectVertexBuffer = new kha_graphics4_VertexBuffer(kha_graphics4_ImageShaderPainter.bufferSize * 4,kha_graphics4_ImageShaderPainter.structure,kha_graphics4_Usage.DynamicUsage);
		this.rectVertices = this.rectVertexBuffer.lock();
		this.indexBuffer = new kha_graphics4_IndexBuffer(kha_graphics4_ImageShaderPainter.bufferSize * 3 * 2,kha_graphics4_Usage.StaticUsage);
		var indices = this.indexBuffer.lock();
		var _g1 = 0;
		var _g = kha_graphics4_ImageShaderPainter.bufferSize;
		while(_g1 < _g) {
			var i = _g1++;
			indices[i * 3 * 2] = i * 4;
			indices[i * 3 * 2 + 1] = i * 4 + 1;
			indices[i * 3 * 2 + 2] = i * 4 + 2;
			indices[i * 3 * 2 + 3] = i * 4;
			indices[i * 3 * 2 + 4] = i * 4 + 2;
			indices[i * 3 * 2 + 5] = i * 4 + 3;
		}
		this.indexBuffer.unlock();
	}
	,setRectVertices: function(bottomleftx,bottomlefty,topleftx,toplefty,toprightx,toprighty,bottomrightx,bottomrighty) {
		var baseIndex = this.bufferIndex * kha_graphics4_ImageShaderPainter.vertexSize * 4;
		this.rectVertices[baseIndex] = bottomleftx;
		this.rectVertices[baseIndex + 1] = bottomlefty;
		this.rectVertices[baseIndex + 2] = -5.0;
		this.rectVertices[baseIndex + 9] = topleftx;
		this.rectVertices[baseIndex + 10] = toplefty;
		this.rectVertices[baseIndex + 11] = -5.0;
		this.rectVertices[baseIndex + 18] = toprightx;
		this.rectVertices[baseIndex + 19] = toprighty;
		this.rectVertices[baseIndex + 20] = -5.0;
		this.rectVertices[baseIndex + 27] = bottomrightx;
		this.rectVertices[baseIndex + 28] = bottomrighty;
		this.rectVertices[baseIndex + 29] = -5.0;
	}
	,setRectTexCoords: function(left,top,right,bottom) {
		var baseIndex = this.bufferIndex * kha_graphics4_ImageShaderPainter.vertexSize * 4;
		this.rectVertices[baseIndex + 3] = left;
		this.rectVertices[baseIndex + 4] = bottom;
		this.rectVertices[baseIndex + 12] = left;
		this.rectVertices[baseIndex + 13] = top;
		this.rectVertices[baseIndex + 21] = right;
		this.rectVertices[baseIndex + 22] = top;
		this.rectVertices[baseIndex + 30] = right;
		this.rectVertices[baseIndex + 31] = bottom;
	}
	,setRectColor: function(r,g,b,a) {
		var baseIndex = this.bufferIndex * kha_graphics4_ImageShaderPainter.vertexSize * 4;
		this.rectVertices[baseIndex + 5] = r;
		this.rectVertices[baseIndex + 6] = g;
		this.rectVertices[baseIndex + 7] = b;
		this.rectVertices[baseIndex + 8] = a;
		this.rectVertices[baseIndex + 14] = r;
		this.rectVertices[baseIndex + 15] = g;
		this.rectVertices[baseIndex + 16] = b;
		this.rectVertices[baseIndex + 17] = a;
		this.rectVertices[baseIndex + 23] = r;
		this.rectVertices[baseIndex + 24] = g;
		this.rectVertices[baseIndex + 25] = b;
		this.rectVertices[baseIndex + 26] = a;
		this.rectVertices[baseIndex + 32] = r;
		this.rectVertices[baseIndex + 33] = g;
		this.rectVertices[baseIndex + 34] = b;
		this.rectVertices[baseIndex + 35] = a;
	}
	,drawBuffer: function() {
		this.rectVertexBuffer.unlock();
		this.g.setVertexBuffer(this.rectVertexBuffer);
		this.g.setIndexBuffer(this.indexBuffer);
		this.g.setPipeline(this.get_pipeline() == null ? kha_graphics4_ImageShaderPainter.shaderPipeline : this.get_pipeline());
		this.g.setTexture(this.textureLocation,this.lastTexture);
		this.g.setTextureParameters(this.textureLocation,kha_graphics4_TextureAddressing.Clamp,kha_graphics4_TextureAddressing.Clamp,this.bilinear ? kha_graphics4_TextureFilter.LinearFilter : kha_graphics4_TextureFilter.PointFilter,this.bilinear ? kha_graphics4_TextureFilter.LinearFilter : kha_graphics4_TextureFilter.PointFilter,this.bilinearMipmaps ? kha_graphics4_MipMapFilter.LinearMipFilter : kha_graphics4_MipMapFilter.NoMipFilter);
		this.g.setMatrix(this.projectionLocation,this.projectionMatrix);
		this.g.drawIndexedVertices(0,this.bufferIndex * 2 * 3);
		this.g.setTexture(this.textureLocation,null);
		this.bufferIndex = 0;
		this.rectVertices = this.rectVertexBuffer.lock();
	}
	,setBilinearFilter: function(bilinear) {
		this.end();
		this.bilinear = bilinear;
	}
	,setBilinearMipmapFilter: function(bilinear) {
		this.end();
		this.bilinearMipmaps = bilinear;
	}
	,drawImage: function(img,bottomleftx,bottomlefty,topleftx,toplefty,toprightx,toprighty,bottomrightx,bottomrighty,opacity,color) {
		var tex = img;
		if(this.bufferIndex + 1 >= kha_graphics4_ImageShaderPainter.bufferSize || this.lastTexture != null && tex != this.lastTexture) {
			this.drawBuffer();
		}
		var r = ((color & 16711680) >>> 16) * 0.00392156862745098;
		var g = ((color & 65280) >>> 8) * 0.00392156862745098;
		var b = (color & 255) * 0.00392156862745098;
		var a = (color >>> 24) * 0.00392156862745098 * opacity;
		var baseIndex = this.bufferIndex * kha_graphics4_ImageShaderPainter.vertexSize * 4;
		this.rectVertices[baseIndex + 5] = r;
		this.rectVertices[baseIndex + 6] = g;
		this.rectVertices[baseIndex + 7] = b;
		this.rectVertices[baseIndex + 8] = a;
		this.rectVertices[baseIndex + 14] = r;
		this.rectVertices[baseIndex + 15] = g;
		this.rectVertices[baseIndex + 16] = b;
		this.rectVertices[baseIndex + 17] = a;
		this.rectVertices[baseIndex + 23] = r;
		this.rectVertices[baseIndex + 24] = g;
		this.rectVertices[baseIndex + 25] = b;
		this.rectVertices[baseIndex + 26] = a;
		this.rectVertices[baseIndex + 32] = r;
		this.rectVertices[baseIndex + 33] = g;
		this.rectVertices[baseIndex + 34] = b;
		this.rectVertices[baseIndex + 35] = a;
		var right = tex.get_width() / tex.get_realWidth();
		var bottom = tex.get_height() / tex.get_realHeight();
		var baseIndex1 = this.bufferIndex * kha_graphics4_ImageShaderPainter.vertexSize * 4;
		this.rectVertices[baseIndex1 + 3] = 0;
		this.rectVertices[baseIndex1 + 4] = bottom;
		this.rectVertices[baseIndex1 + 12] = 0;
		this.rectVertices[baseIndex1 + 13] = 0;
		this.rectVertices[baseIndex1 + 21] = right;
		this.rectVertices[baseIndex1 + 22] = 0;
		this.rectVertices[baseIndex1 + 30] = right;
		this.rectVertices[baseIndex1 + 31] = bottom;
		var baseIndex2 = this.bufferIndex * kha_graphics4_ImageShaderPainter.vertexSize * 4;
		this.rectVertices[baseIndex2] = bottomleftx;
		this.rectVertices[baseIndex2 + 1] = bottomlefty;
		this.rectVertices[baseIndex2 + 2] = -5.0;
		this.rectVertices[baseIndex2 + 9] = topleftx;
		this.rectVertices[baseIndex2 + 10] = toplefty;
		this.rectVertices[baseIndex2 + 11] = -5.0;
		this.rectVertices[baseIndex2 + 18] = toprightx;
		this.rectVertices[baseIndex2 + 19] = toprighty;
		this.rectVertices[baseIndex2 + 20] = -5.0;
		this.rectVertices[baseIndex2 + 27] = bottomrightx;
		this.rectVertices[baseIndex2 + 28] = bottomrighty;
		this.rectVertices[baseIndex2 + 29] = -5.0;
		++this.bufferIndex;
		this.lastTexture = tex;
	}
	,drawImage2: function(img,sx,sy,sw,sh,bottomleftx,bottomlefty,topleftx,toplefty,toprightx,toprighty,bottomrightx,bottomrighty,opacity,color) {
		var tex = img;
		if(this.bufferIndex + 1 >= kha_graphics4_ImageShaderPainter.bufferSize || this.lastTexture != null && tex != this.lastTexture) {
			this.drawBuffer();
		}
		var left = sx / tex.get_realWidth();
		var top = sy / tex.get_realHeight();
		var right = (sx + sw) / tex.get_realWidth();
		var bottom = (sy + sh) / tex.get_realHeight();
		var baseIndex = this.bufferIndex * kha_graphics4_ImageShaderPainter.vertexSize * 4;
		this.rectVertices[baseIndex + 3] = left;
		this.rectVertices[baseIndex + 4] = bottom;
		this.rectVertices[baseIndex + 12] = left;
		this.rectVertices[baseIndex + 13] = top;
		this.rectVertices[baseIndex + 21] = right;
		this.rectVertices[baseIndex + 22] = top;
		this.rectVertices[baseIndex + 30] = right;
		this.rectVertices[baseIndex + 31] = bottom;
		var r = ((color & 16711680) >>> 16) * 0.00392156862745098;
		var g = ((color & 65280) >>> 8) * 0.00392156862745098;
		var b = (color & 255) * 0.00392156862745098;
		var a = (color >>> 24) * 0.00392156862745098 * opacity;
		var baseIndex1 = this.bufferIndex * kha_graphics4_ImageShaderPainter.vertexSize * 4;
		this.rectVertices[baseIndex1 + 5] = r;
		this.rectVertices[baseIndex1 + 6] = g;
		this.rectVertices[baseIndex1 + 7] = b;
		this.rectVertices[baseIndex1 + 8] = a;
		this.rectVertices[baseIndex1 + 14] = r;
		this.rectVertices[baseIndex1 + 15] = g;
		this.rectVertices[baseIndex1 + 16] = b;
		this.rectVertices[baseIndex1 + 17] = a;
		this.rectVertices[baseIndex1 + 23] = r;
		this.rectVertices[baseIndex1 + 24] = g;
		this.rectVertices[baseIndex1 + 25] = b;
		this.rectVertices[baseIndex1 + 26] = a;
		this.rectVertices[baseIndex1 + 32] = r;
		this.rectVertices[baseIndex1 + 33] = g;
		this.rectVertices[baseIndex1 + 34] = b;
		this.rectVertices[baseIndex1 + 35] = a;
		var baseIndex2 = this.bufferIndex * kha_graphics4_ImageShaderPainter.vertexSize * 4;
		this.rectVertices[baseIndex2] = bottomleftx;
		this.rectVertices[baseIndex2 + 1] = bottomlefty;
		this.rectVertices[baseIndex2 + 2] = -5.0;
		this.rectVertices[baseIndex2 + 9] = topleftx;
		this.rectVertices[baseIndex2 + 10] = toplefty;
		this.rectVertices[baseIndex2 + 11] = -5.0;
		this.rectVertices[baseIndex2 + 18] = toprightx;
		this.rectVertices[baseIndex2 + 19] = toprighty;
		this.rectVertices[baseIndex2 + 20] = -5.0;
		this.rectVertices[baseIndex2 + 27] = bottomrightx;
		this.rectVertices[baseIndex2 + 28] = bottomrighty;
		this.rectVertices[baseIndex2 + 29] = -5.0;
		++this.bufferIndex;
		this.lastTexture = tex;
	}
	,drawImageScale: function(img,sx,sy,sw,sh,left,top,right,bottom,opacity,color) {
		var tex = img;
		if(this.bufferIndex + 1 >= kha_graphics4_ImageShaderPainter.bufferSize || this.lastTexture != null && tex != this.lastTexture) {
			this.drawBuffer();
		}
		var left1 = sx / tex.get_realWidth();
		var top1 = sy / tex.get_realHeight();
		var right1 = (sx + sw) / tex.get_realWidth();
		var bottom1 = (sy + sh) / tex.get_realHeight();
		var baseIndex = this.bufferIndex * kha_graphics4_ImageShaderPainter.vertexSize * 4;
		this.rectVertices[baseIndex + 3] = left1;
		this.rectVertices[baseIndex + 4] = bottom1;
		this.rectVertices[baseIndex + 12] = left1;
		this.rectVertices[baseIndex + 13] = top1;
		this.rectVertices[baseIndex + 21] = right1;
		this.rectVertices[baseIndex + 22] = top1;
		this.rectVertices[baseIndex + 30] = right1;
		this.rectVertices[baseIndex + 31] = bottom1;
		var r = ((color & 16711680) >>> 16) * 0.00392156862745098;
		var g = ((color & 65280) >>> 8) * 0.00392156862745098;
		var b = (color & 255) * 0.00392156862745098;
		var baseIndex1 = this.bufferIndex * kha_graphics4_ImageShaderPainter.vertexSize * 4;
		this.rectVertices[baseIndex1 + 5] = r;
		this.rectVertices[baseIndex1 + 6] = g;
		this.rectVertices[baseIndex1 + 7] = b;
		this.rectVertices[baseIndex1 + 8] = opacity;
		this.rectVertices[baseIndex1 + 14] = r;
		this.rectVertices[baseIndex1 + 15] = g;
		this.rectVertices[baseIndex1 + 16] = b;
		this.rectVertices[baseIndex1 + 17] = opacity;
		this.rectVertices[baseIndex1 + 23] = r;
		this.rectVertices[baseIndex1 + 24] = g;
		this.rectVertices[baseIndex1 + 25] = b;
		this.rectVertices[baseIndex1 + 26] = opacity;
		this.rectVertices[baseIndex1 + 32] = r;
		this.rectVertices[baseIndex1 + 33] = g;
		this.rectVertices[baseIndex1 + 34] = b;
		this.rectVertices[baseIndex1 + 35] = opacity;
		var baseIndex2 = this.bufferIndex * kha_graphics4_ImageShaderPainter.vertexSize * 4;
		this.rectVertices[baseIndex2] = left;
		this.rectVertices[baseIndex2 + 1] = bottom;
		this.rectVertices[baseIndex2 + 2] = -5.0;
		this.rectVertices[baseIndex2 + 9] = left;
		this.rectVertices[baseIndex2 + 10] = top;
		this.rectVertices[baseIndex2 + 11] = -5.0;
		this.rectVertices[baseIndex2 + 18] = right;
		this.rectVertices[baseIndex2 + 19] = top;
		this.rectVertices[baseIndex2 + 20] = -5.0;
		this.rectVertices[baseIndex2 + 27] = right;
		this.rectVertices[baseIndex2 + 28] = bottom;
		this.rectVertices[baseIndex2 + 29] = -5.0;
		++this.bufferIndex;
		this.lastTexture = tex;
	}
	,end: function() {
		if(this.bufferIndex > 0) {
			this.drawBuffer();
		}
		this.lastTexture = null;
	}
	,__class__: kha_graphics4_ImageShaderPainter
};
var kha_graphics4_ColoredShaderPainter = function(g4) {
	this.destinationBlend = kha_graphics4_BlendingFactor.Undefined;
	this.sourceBlend = kha_graphics4_BlendingFactor.Undefined;
	this.myPipeline = null;
	this.g = g4;
	this.bufferIndex = 0;
	this.triangleBufferIndex = 0;
	kha_graphics4_ColoredShaderPainter.initShaders();
	this.initBuffers();
	this.projectionLocation = kha_graphics4_ColoredShaderPainter.shaderPipeline.getConstantLocation("projectionMatrix");
};
$hxClasses["kha.graphics4.ColoredShaderPainter"] = kha_graphics4_ColoredShaderPainter;
kha_graphics4_ColoredShaderPainter.__name__ = true;
kha_graphics4_ColoredShaderPainter.initShaders = function() {
	if(kha_graphics4_ColoredShaderPainter.shaderPipeline == null) {
		kha_graphics4_ColoredShaderPainter.structure = kha_graphics4_Graphics2.createColoredVertexStructure();
		kha_graphics4_ColoredShaderPainter.shaderPipeline = kha_graphics4_Graphics2.createColoredPipeline(kha_graphics4_ColoredShaderPainter.structure);
		kha_graphics4_ColoredShaderPainter.shaderPipeline.compile();
	}
};
kha_graphics4_ColoredShaderPainter.prototype = {
	projectionMatrix: null
	,projectionLocation: null
	,bufferIndex: null
	,rectVertexBuffer: null
	,rectVertices: null
	,indexBuffer: null
	,triangleBufferIndex: null
	,triangleVertexBuffer: null
	,triangleVertices: null
	,triangleIndexBuffer: null
	,g: null
	,myPipeline: null
	,sourceBlend: null
	,destinationBlend: null
	,get_pipeline: function() {
		return this.myPipeline;
	}
	,set_pipeline: function(pipe) {
		if(pipe == null) {
			this.projectionLocation = kha_graphics4_ColoredShaderPainter.shaderPipeline.getConstantLocation("projectionMatrix");
		} else {
			this.projectionLocation = pipe.getConstantLocation("projectionMatrix");
		}
		return this.myPipeline = pipe;
	}
	,setProjection: function(projectionMatrix) {
		this.projectionMatrix = projectionMatrix;
	}
	,initBuffers: function() {
		this.rectVertexBuffer = new kha_graphics4_VertexBuffer(kha_graphics4_ColoredShaderPainter.bufferSize * 4,kha_graphics4_ColoredShaderPainter.structure,kha_graphics4_Usage.DynamicUsage);
		this.rectVertices = this.rectVertexBuffer.lock();
		this.indexBuffer = new kha_graphics4_IndexBuffer(kha_graphics4_ColoredShaderPainter.bufferSize * 3 * 2,kha_graphics4_Usage.StaticUsage);
		var indices = this.indexBuffer.lock();
		var _g1 = 0;
		var _g = kha_graphics4_ColoredShaderPainter.bufferSize;
		while(_g1 < _g) {
			var i = _g1++;
			indices[i * 3 * 2] = i * 4;
			indices[i * 3 * 2 + 1] = i * 4 + 1;
			indices[i * 3 * 2 + 2] = i * 4 + 2;
			indices[i * 3 * 2 + 3] = i * 4;
			indices[i * 3 * 2 + 4] = i * 4 + 2;
			indices[i * 3 * 2 + 5] = i * 4 + 3;
		}
		this.indexBuffer.unlock();
		this.triangleVertexBuffer = new kha_graphics4_VertexBuffer(kha_graphics4_ColoredShaderPainter.triangleBufferSize * 3,kha_graphics4_ColoredShaderPainter.structure,kha_graphics4_Usage.DynamicUsage);
		this.triangleVertices = this.triangleVertexBuffer.lock();
		this.triangleIndexBuffer = new kha_graphics4_IndexBuffer(kha_graphics4_ColoredShaderPainter.triangleBufferSize * 3,kha_graphics4_Usage.StaticUsage);
		var triIndices = this.triangleIndexBuffer.lock();
		var _g11 = 0;
		var _g2 = kha_graphics4_ColoredShaderPainter.bufferSize;
		while(_g11 < _g2) {
			var i1 = _g11++;
			triIndices[i1 * 3] = i1 * 3;
			triIndices[i1 * 3 + 1] = i1 * 3 + 1;
			triIndices[i1 * 3 + 2] = i1 * 3 + 2;
		}
		this.triangleIndexBuffer.unlock();
	}
	,setRectVertices: function(bottomleftx,bottomlefty,topleftx,toplefty,toprightx,toprighty,bottomrightx,bottomrighty) {
		var baseIndex = this.bufferIndex * 7 * 4;
		this.rectVertices[baseIndex] = bottomleftx;
		this.rectVertices[baseIndex + 1] = bottomlefty;
		this.rectVertices[baseIndex + 2] = -5.0;
		this.rectVertices[baseIndex + 7] = topleftx;
		this.rectVertices[baseIndex + 8] = toplefty;
		this.rectVertices[baseIndex + 9] = -5.0;
		this.rectVertices[baseIndex + 14] = toprightx;
		this.rectVertices[baseIndex + 15] = toprighty;
		this.rectVertices[baseIndex + 16] = -5.0;
		this.rectVertices[baseIndex + 21] = bottomrightx;
		this.rectVertices[baseIndex + 22] = bottomrighty;
		this.rectVertices[baseIndex + 23] = -5.0;
	}
	,setRectColors: function(opacity,color) {
		var baseIndex = this.bufferIndex * 7 * 4;
		var a = opacity * ((color >>> 24) * 0.00392156862745098);
		this.rectVertices[baseIndex + 3] = ((color & 16711680) >>> 16) * 0.00392156862745098;
		this.rectVertices[baseIndex + 4] = ((color & 65280) >>> 8) * 0.00392156862745098;
		this.rectVertices[baseIndex + 5] = (color & 255) * 0.00392156862745098;
		this.rectVertices[baseIndex + 6] = a;
		this.rectVertices[baseIndex + 10] = ((color & 16711680) >>> 16) * 0.00392156862745098;
		this.rectVertices[baseIndex + 11] = ((color & 65280) >>> 8) * 0.00392156862745098;
		this.rectVertices[baseIndex + 12] = (color & 255) * 0.00392156862745098;
		this.rectVertices[baseIndex + 13] = a;
		this.rectVertices[baseIndex + 17] = ((color & 16711680) >>> 16) * 0.00392156862745098;
		this.rectVertices[baseIndex + 18] = ((color & 65280) >>> 8) * 0.00392156862745098;
		this.rectVertices[baseIndex + 19] = (color & 255) * 0.00392156862745098;
		this.rectVertices[baseIndex + 20] = a;
		this.rectVertices[baseIndex + 24] = ((color & 16711680) >>> 16) * 0.00392156862745098;
		this.rectVertices[baseIndex + 25] = ((color & 65280) >>> 8) * 0.00392156862745098;
		this.rectVertices[baseIndex + 26] = (color & 255) * 0.00392156862745098;
		this.rectVertices[baseIndex + 27] = a;
	}
	,setTriVertices: function(x1,y1,x2,y2,x3,y3) {
		var baseIndex = this.triangleBufferIndex * 7 * 3;
		this.triangleVertices[baseIndex] = x1;
		this.triangleVertices[baseIndex + 1] = y1;
		this.triangleVertices[baseIndex + 2] = -5.0;
		this.triangleVertices[baseIndex + 7] = x2;
		this.triangleVertices[baseIndex + 8] = y2;
		this.triangleVertices[baseIndex + 9] = -5.0;
		this.triangleVertices[baseIndex + 14] = x3;
		this.triangleVertices[baseIndex + 15] = y3;
		this.triangleVertices[baseIndex + 16] = -5.0;
	}
	,setTriColors: function(opacity,color) {
		var baseIndex = this.triangleBufferIndex * 7 * 3;
		var a = opacity * ((color >>> 24) * 0.00392156862745098);
		this.triangleVertices[baseIndex + 3] = ((color & 16711680) >>> 16) * 0.00392156862745098;
		this.triangleVertices[baseIndex + 4] = ((color & 65280) >>> 8) * 0.00392156862745098;
		this.triangleVertices[baseIndex + 5] = (color & 255) * 0.00392156862745098;
		this.triangleVertices[baseIndex + 6] = a;
		this.triangleVertices[baseIndex + 10] = ((color & 16711680) >>> 16) * 0.00392156862745098;
		this.triangleVertices[baseIndex + 11] = ((color & 65280) >>> 8) * 0.00392156862745098;
		this.triangleVertices[baseIndex + 12] = (color & 255) * 0.00392156862745098;
		this.triangleVertices[baseIndex + 13] = a;
		this.triangleVertices[baseIndex + 17] = ((color & 16711680) >>> 16) * 0.00392156862745098;
		this.triangleVertices[baseIndex + 18] = ((color & 65280) >>> 8) * 0.00392156862745098;
		this.triangleVertices[baseIndex + 19] = (color & 255) * 0.00392156862745098;
		this.triangleVertices[baseIndex + 20] = a;
	}
	,drawBuffer: function(trisDone) {
		if(!trisDone) {
			if(this.triangleBufferIndex > 0) {
				this.drawTriBuffer(true);
			}
		}
		this.rectVertexBuffer.unlock();
		this.g.setVertexBuffer(this.rectVertexBuffer);
		this.g.setIndexBuffer(this.indexBuffer);
		this.g.setPipeline(this.get_pipeline() == null ? kha_graphics4_ColoredShaderPainter.shaderPipeline : this.get_pipeline());
		this.g.setMatrix(this.projectionLocation,this.projectionMatrix);
		this.g.drawIndexedVertices(0,this.bufferIndex * 2 * 3);
		this.bufferIndex = 0;
		this.rectVertices = this.rectVertexBuffer.lock();
	}
	,drawTriBuffer: function(rectsDone) {
		if(!rectsDone) {
			if(this.bufferIndex > 0) {
				this.drawBuffer(true);
			}
		}
		this.triangleVertexBuffer.unlock();
		this.g.setVertexBuffer(this.triangleVertexBuffer);
		this.g.setIndexBuffer(this.triangleIndexBuffer);
		this.g.setPipeline(this.get_pipeline() == null ? kha_graphics4_ColoredShaderPainter.shaderPipeline : this.get_pipeline());
		this.g.setMatrix(this.projectionLocation,this.projectionMatrix);
		this.g.drawIndexedVertices(0,this.triangleBufferIndex * 3);
		this.triangleBufferIndex = 0;
		this.triangleVertices = this.triangleVertexBuffer.lock();
	}
	,fillRect: function(opacity,color,bottomleftx,bottomlefty,topleftx,toplefty,toprightx,toprighty,bottomrightx,bottomrighty) {
		if(this.triangleBufferIndex > 0) {
			this.drawTriBuffer(true);
		}
		if(this.bufferIndex + 1 >= kha_graphics4_ColoredShaderPainter.bufferSize) {
			this.drawBuffer(false);
		}
		this.setRectColors(opacity,color);
		this.setRectVertices(bottomleftx,bottomlefty,topleftx,toplefty,toprightx,toprighty,bottomrightx,bottomrighty);
		++this.bufferIndex;
	}
	,fillTriangle: function(opacity,color,x1,y1,x2,y2,x3,y3) {
		if(this.bufferIndex > 0) {
			this.drawBuffer(true);
		}
		if(this.triangleBufferIndex + 1 >= kha_graphics4_ColoredShaderPainter.triangleBufferSize) {
			this.drawTriBuffer(false);
		}
		this.setTriColors(opacity,color);
		this.setTriVertices(x1,y1,x2,y2,x3,y3);
		++this.triangleBufferIndex;
	}
	,endTris: function(rectsDone) {
		if(this.triangleBufferIndex > 0) {
			this.drawTriBuffer(rectsDone);
		}
	}
	,endRects: function(trisDone) {
		if(this.bufferIndex > 0) {
			this.drawBuffer(trisDone);
		}
	}
	,end: function() {
		if(this.triangleBufferIndex > 0) {
			this.drawTriBuffer(false);
		}
		if(this.bufferIndex > 0) {
			this.drawBuffer(false);
		}
	}
	,__class__: kha_graphics4_ColoredShaderPainter
};
var kha_graphics4_TextShaderPainter = function(g4) {
	this.destinationBlend = kha_graphics4_BlendingFactor.Undefined;
	this.sourceBlend = kha_graphics4_BlendingFactor.Undefined;
	this.bilinear = false;
	this.myPipeline = null;
	this.g = g4;
	this.bufferIndex = 0;
	kha_graphics4_TextShaderPainter.initShaders();
	this.initBuffers();
	this.projectionLocation = kha_graphics4_TextShaderPainter.shaderPipeline.getConstantLocation("projectionMatrix");
	this.textureLocation = kha_graphics4_TextShaderPainter.shaderPipeline.getTextureUnit("tex");
};
$hxClasses["kha.graphics4.TextShaderPainter"] = kha_graphics4_TextShaderPainter;
kha_graphics4_TextShaderPainter.__name__ = true;
kha_graphics4_TextShaderPainter.initShaders = function() {
	if(kha_graphics4_TextShaderPainter.shaderPipeline == null) {
		kha_graphics4_TextShaderPainter.structure = kha_graphics4_Graphics2.createTextVertexStructure();
		kha_graphics4_TextShaderPainter.shaderPipeline = kha_graphics4_Graphics2.createTextPipeline(kha_graphics4_TextShaderPainter.structure);
		kha_graphics4_TextShaderPainter.shaderPipeline.compile();
	}
};
kha_graphics4_TextShaderPainter.findIndex = function(charcode,fontGlyphs) {
	var _g1 = 0;
	var _g = fontGlyphs.length;
	while(_g1 < _g) {
		var i = _g1++;
		if(fontGlyphs[i] == charcode) {
			return i;
		}
	}
	return 0;
};
kha_graphics4_TextShaderPainter.prototype = {
	projectionMatrix: null
	,projectionLocation: null
	,textureLocation: null
	,bufferIndex: null
	,rectVertexBuffer: null
	,rectVertices: null
	,indexBuffer: null
	,font: null
	,lastTexture: null
	,g: null
	,myPipeline: null
	,fontSize: null
	,bilinear: null
	,sourceBlend: null
	,destinationBlend: null
	,get_pipeline: function() {
		return this.myPipeline;
	}
	,set_pipeline: function(pipe) {
		if(pipe == null) {
			this.projectionLocation = kha_graphics4_TextShaderPainter.shaderPipeline.getConstantLocation("projectionMatrix");
			this.textureLocation = kha_graphics4_TextShaderPainter.shaderPipeline.getTextureUnit("tex");
		} else {
			this.projectionLocation = pipe.getConstantLocation("projectionMatrix");
			this.textureLocation = pipe.getTextureUnit("tex");
		}
		return this.myPipeline = pipe;
	}
	,setProjection: function(projectionMatrix) {
		this.projectionMatrix = projectionMatrix;
	}
	,initBuffers: function() {
		this.rectVertexBuffer = new kha_graphics4_VertexBuffer(kha_graphics4_TextShaderPainter.bufferSize * 4,kha_graphics4_TextShaderPainter.structure,kha_graphics4_Usage.DynamicUsage);
		this.rectVertices = this.rectVertexBuffer.lock();
		this.indexBuffer = new kha_graphics4_IndexBuffer(kha_graphics4_TextShaderPainter.bufferSize * 3 * 2,kha_graphics4_Usage.StaticUsage);
		var indices = this.indexBuffer.lock();
		var _g1 = 0;
		var _g = kha_graphics4_TextShaderPainter.bufferSize;
		while(_g1 < _g) {
			var i = _g1++;
			indices[i * 3 * 2] = i * 4;
			indices[i * 3 * 2 + 1] = i * 4 + 1;
			indices[i * 3 * 2 + 2] = i * 4 + 2;
			indices[i * 3 * 2 + 3] = i * 4;
			indices[i * 3 * 2 + 4] = i * 4 + 2;
			indices[i * 3 * 2 + 5] = i * 4 + 3;
		}
		this.indexBuffer.unlock();
	}
	,setRectVertices: function(bottomleftx,bottomlefty,topleftx,toplefty,toprightx,toprighty,bottomrightx,bottomrighty) {
		var baseIndex = this.bufferIndex * 9 * 4;
		this.rectVertices[baseIndex] = bottomleftx;
		this.rectVertices[baseIndex + 1] = bottomlefty;
		this.rectVertices[baseIndex + 2] = -5.0;
		this.rectVertices[baseIndex + 9] = topleftx;
		this.rectVertices[baseIndex + 10] = toplefty;
		this.rectVertices[baseIndex + 11] = -5.0;
		this.rectVertices[baseIndex + 18] = toprightx;
		this.rectVertices[baseIndex + 19] = toprighty;
		this.rectVertices[baseIndex + 20] = -5.0;
		this.rectVertices[baseIndex + 27] = bottomrightx;
		this.rectVertices[baseIndex + 28] = bottomrighty;
		this.rectVertices[baseIndex + 29] = -5.0;
	}
	,setRectTexCoords: function(left,top,right,bottom) {
		var baseIndex = this.bufferIndex * 9 * 4;
		this.rectVertices[baseIndex + 3] = left;
		this.rectVertices[baseIndex + 4] = bottom;
		this.rectVertices[baseIndex + 12] = left;
		this.rectVertices[baseIndex + 13] = top;
		this.rectVertices[baseIndex + 21] = right;
		this.rectVertices[baseIndex + 22] = top;
		this.rectVertices[baseIndex + 30] = right;
		this.rectVertices[baseIndex + 31] = bottom;
	}
	,setRectColors: function(opacity,color) {
		var baseIndex = this.bufferIndex * 9 * 4;
		var a = opacity * ((color >>> 24) * 0.00392156862745098);
		this.rectVertices[baseIndex + 5] = ((color & 16711680) >>> 16) * 0.00392156862745098;
		this.rectVertices[baseIndex + 6] = ((color & 65280) >>> 8) * 0.00392156862745098;
		this.rectVertices[baseIndex + 7] = (color & 255) * 0.00392156862745098;
		this.rectVertices[baseIndex + 8] = a;
		this.rectVertices[baseIndex + 14] = ((color & 16711680) >>> 16) * 0.00392156862745098;
		this.rectVertices[baseIndex + 15] = ((color & 65280) >>> 8) * 0.00392156862745098;
		this.rectVertices[baseIndex + 16] = (color & 255) * 0.00392156862745098;
		this.rectVertices[baseIndex + 17] = a;
		this.rectVertices[baseIndex + 23] = ((color & 16711680) >>> 16) * 0.00392156862745098;
		this.rectVertices[baseIndex + 24] = ((color & 65280) >>> 8) * 0.00392156862745098;
		this.rectVertices[baseIndex + 25] = (color & 255) * 0.00392156862745098;
		this.rectVertices[baseIndex + 26] = a;
		this.rectVertices[baseIndex + 32] = ((color & 16711680) >>> 16) * 0.00392156862745098;
		this.rectVertices[baseIndex + 33] = ((color & 65280) >>> 8) * 0.00392156862745098;
		this.rectVertices[baseIndex + 34] = (color & 255) * 0.00392156862745098;
		this.rectVertices[baseIndex + 35] = a;
	}
	,drawBuffer: function() {
		this.rectVertexBuffer.unlock();
		this.g.setVertexBuffer(this.rectVertexBuffer);
		this.g.setIndexBuffer(this.indexBuffer);
		this.g.setPipeline(this.get_pipeline() == null ? kha_graphics4_TextShaderPainter.shaderPipeline : this.get_pipeline());
		this.g.setTexture(this.textureLocation,this.lastTexture);
		this.g.setMatrix(this.projectionLocation,this.projectionMatrix);
		this.g.setTextureParameters(this.textureLocation,kha_graphics4_TextureAddressing.Clamp,kha_graphics4_TextureAddressing.Clamp,this.bilinear ? kha_graphics4_TextureFilter.LinearFilter : kha_graphics4_TextureFilter.PointFilter,this.bilinear ? kha_graphics4_TextureFilter.LinearFilter : kha_graphics4_TextureFilter.PointFilter,kha_graphics4_MipMapFilter.NoMipFilter);
		this.g.drawIndexedVertices(0,this.bufferIndex * 2 * 3);
		this.g.setTexture(this.textureLocation,null);
		this.bufferIndex = 0;
		this.rectVertices = this.rectVertexBuffer.lock();
	}
	,setBilinearFilter: function(bilinear) {
		this.end();
		this.bilinear = bilinear;
	}
	,setFont: function(font) {
		this.font = js_Boot.__cast(font , kha_Kravur);
	}
	,text: null
	,startString: function(text) {
		this.text = text;
	}
	,charCodeAt: function(position) {
		return HxOverrides.cca(this.text,position);
	}
	,stringLength: function() {
		return this.text.length;
	}
	,endString: function() {
		this.text = null;
	}
	,drawString: function(text,opacity,color,x,y,transformation,fontGlyphs) {
		var font = this.font._get(this.fontSize,fontGlyphs);
		var tex = font.getTexture();
		if(this.lastTexture != null && tex != this.lastTexture) {
			this.drawBuffer();
		}
		this.lastTexture = tex;
		var xpos = x;
		var ypos = y;
		this.startString(text);
		var _g1 = 0;
		var _g = this.stringLength();
		while(_g1 < _g) {
			var i = _g1++;
			var q = font.getBakedQuad(kha_graphics4_TextShaderPainter.findIndex(this.charCodeAt(i),fontGlyphs),xpos,ypos);
			if(q != null) {
				if(this.bufferIndex + 1 >= kha_graphics4_TextShaderPainter.bufferSize) {
					this.drawBuffer();
				}
				this.setRectColors(opacity,color);
				this.setRectTexCoords(q.s0 * tex.get_width() / tex.get_realWidth(),q.t0 * tex.get_height() / tex.get_realHeight(),q.s1 * tex.get_width() / tex.get_realWidth(),q.t1 * tex.get_height() / tex.get_realHeight());
				var p0_y;
				var p0_x;
				var value_y;
				var value_x = q.x0;
				value_y = q.y1;
				var w = transformation._02 * value_x + transformation._12 * value_y + transformation._22;
				var x1 = (transformation._00 * value_x + transformation._10 * value_y + transformation._20) / w;
				var y1 = (transformation._01 * value_x + transformation._11 * value_y + transformation._21) / w;
				p0_x = x1;
				p0_y = y1;
				var p1_y;
				var p1_x;
				var value_y1;
				var value_x1 = q.x0;
				value_y1 = q.y0;
				var w1 = transformation._02 * value_x1 + transformation._12 * value_y1 + transformation._22;
				var x2 = (transformation._00 * value_x1 + transformation._10 * value_y1 + transformation._20) / w1;
				var y2 = (transformation._01 * value_x1 + transformation._11 * value_y1 + transformation._21) / w1;
				p1_x = x2;
				p1_y = y2;
				var p2_y;
				var p2_x;
				var value_y2;
				var value_x2 = q.x1;
				value_y2 = q.y0;
				var w2 = transformation._02 * value_x2 + transformation._12 * value_y2 + transformation._22;
				var x3 = (transformation._00 * value_x2 + transformation._10 * value_y2 + transformation._20) / w2;
				var y3 = (transformation._01 * value_x2 + transformation._11 * value_y2 + transformation._21) / w2;
				p2_x = x3;
				p2_y = y3;
				var p3_y;
				var p3_x;
				var value_y3;
				var value_x3 = q.x1;
				value_y3 = q.y1;
				var w3 = transformation._02 * value_x3 + transformation._12 * value_y3 + transformation._22;
				var x4 = (transformation._00 * value_x3 + transformation._10 * value_y3 + transformation._20) / w3;
				var y4 = (transformation._01 * value_x3 + transformation._11 * value_y3 + transformation._21) / w3;
				p3_x = x4;
				p3_y = y4;
				this.setRectVertices(p0_x,p0_y,p1_x,p1_y,p2_x,p2_y,p3_x,p3_y);
				xpos += q.xadvance;
				++this.bufferIndex;
			}
		}
		this.endString();
	}
	,drawCharacters: function(text,start,length,opacity,color,x,y,transformation,fontGlyphs) {
		var font = this.font._get(this.fontSize,fontGlyphs);
		var tex = font.getTexture();
		if(this.lastTexture != null && tex != this.lastTexture) {
			this.drawBuffer();
		}
		this.lastTexture = tex;
		var xpos = x;
		var ypos = y;
		var _g1 = start;
		var _g = start + length;
		while(_g1 < _g) {
			var i = _g1++;
			var q = font.getBakedQuad(kha_graphics4_TextShaderPainter.findIndex(text[i],fontGlyphs),xpos,ypos);
			if(q != null) {
				if(this.bufferIndex + 1 >= kha_graphics4_TextShaderPainter.bufferSize) {
					this.drawBuffer();
				}
				this.setRectColors(opacity,color);
				this.setRectTexCoords(q.s0 * tex.get_width() / tex.get_realWidth(),q.t0 * tex.get_height() / tex.get_realHeight(),q.s1 * tex.get_width() / tex.get_realWidth(),q.t1 * tex.get_height() / tex.get_realHeight());
				var p0_y;
				var p0_x;
				var value_y;
				var value_x = q.x0;
				value_y = q.y1;
				var w = transformation._02 * value_x + transformation._12 * value_y + transformation._22;
				var x1 = (transformation._00 * value_x + transformation._10 * value_y + transformation._20) / w;
				var y1 = (transformation._01 * value_x + transformation._11 * value_y + transformation._21) / w;
				p0_x = x1;
				p0_y = y1;
				var p1_y;
				var p1_x;
				var value_y1;
				var value_x1 = q.x0;
				value_y1 = q.y0;
				var w1 = transformation._02 * value_x1 + transformation._12 * value_y1 + transformation._22;
				var x2 = (transformation._00 * value_x1 + transformation._10 * value_y1 + transformation._20) / w1;
				var y2 = (transformation._01 * value_x1 + transformation._11 * value_y1 + transformation._21) / w1;
				p1_x = x2;
				p1_y = y2;
				var p2_y;
				var p2_x;
				var value_y2;
				var value_x2 = q.x1;
				value_y2 = q.y0;
				var w2 = transformation._02 * value_x2 + transformation._12 * value_y2 + transformation._22;
				var x3 = (transformation._00 * value_x2 + transformation._10 * value_y2 + transformation._20) / w2;
				var y3 = (transformation._01 * value_x2 + transformation._11 * value_y2 + transformation._21) / w2;
				p2_x = x3;
				p2_y = y3;
				var p3_y;
				var p3_x;
				var value_y3;
				var value_x3 = q.x1;
				value_y3 = q.y1;
				var w3 = transformation._02 * value_x3 + transformation._12 * value_y3 + transformation._22;
				var x4 = (transformation._00 * value_x3 + transformation._10 * value_y3 + transformation._20) / w3;
				var y4 = (transformation._01 * value_x3 + transformation._11 * value_y3 + transformation._21) / w3;
				p3_x = x4;
				p3_y = y4;
				this.setRectVertices(p0_x,p0_y,p1_x,p1_y,p2_x,p2_y,p3_x,p3_y);
				xpos += q.xadvance;
				++this.bufferIndex;
			}
		}
	}
	,end: function() {
		if(this.bufferIndex > 0) {
			this.drawBuffer();
		}
		this.lastTexture = null;
	}
	,__class__: kha_graphics4_TextShaderPainter
};
var kha_graphics4_Graphics2 = function(canvas) {
	this.myMipmapScaleQuality = kha_graphics2_ImageScaleQuality.High;
	this.myImageScaleQuality = kha_graphics2_ImageScaleQuality.High;
	kha_graphics2_Graphics.call(this);
	this.set_color(-1);
	this.canvas = canvas;
	this.g = canvas.get_g4();
	this.imagePainter = new kha_graphics4_ImageShaderPainter(this.g);
	this.coloredPainter = new kha_graphics4_ColoredShaderPainter(this.g);
	this.textPainter = new kha_graphics4_TextShaderPainter(this.g);
	this.textPainter.fontSize = this.get_fontSize();
	this.setProjection();
	if(kha_graphics4_Graphics2.videoPipeline == null) {
		kha_graphics4_Graphics2.videoPipeline = kha_graphics4_Graphics2.createImagePipeline(kha_graphics4_Graphics2.createImageVertexStructure());
		kha_graphics4_Graphics2.videoPipeline.fragmentShader = kha_Shaders.painter_video_frag;
		kha_graphics4_Graphics2.videoPipeline.vertexShader = kha_Shaders.painter_video_vert;
		kha_graphics4_Graphics2.videoPipeline.compile();
	}
};
$hxClasses["kha.graphics4.Graphics2"] = kha_graphics4_Graphics2;
kha_graphics4_Graphics2.__name__ = true;
kha_graphics4_Graphics2.upperPowerOfTwo = function(v) {
	--v;
	v |= v >>> 1;
	v |= v >>> 2;
	v |= v >>> 4;
	v |= v >>> 8;
	v |= v >>> 16;
	return ++v;
};
kha_graphics4_Graphics2.createImageVertexStructure = function() {
	var structure = new kha_graphics4_VertexStructure();
	structure.add("vertexPosition",kha_graphics4_VertexData.Float3);
	structure.add("texPosition",kha_graphics4_VertexData.Float2);
	structure.add("vertexColor",kha_graphics4_VertexData.Float4);
	return structure;
};
kha_graphics4_Graphics2.createImagePipeline = function(structure) {
	var shaderPipeline = new kha_graphics4_PipelineState();
	shaderPipeline.fragmentShader = kha_Shaders.painter_image_frag;
	shaderPipeline.vertexShader = kha_Shaders.painter_image_vert;
	shaderPipeline.inputLayout = [structure];
	shaderPipeline.blendSource = kha_graphics4_BlendingFactor.BlendOne;
	shaderPipeline.blendDestination = kha_graphics4_BlendingFactor.InverseSourceAlpha;
	shaderPipeline.alphaBlendSource = kha_graphics4_BlendingFactor.SourceAlpha;
	shaderPipeline.alphaBlendDestination = kha_graphics4_BlendingFactor.InverseSourceAlpha;
	return shaderPipeline;
};
kha_graphics4_Graphics2.createColoredVertexStructure = function() {
	var structure = new kha_graphics4_VertexStructure();
	structure.add("vertexPosition",kha_graphics4_VertexData.Float3);
	structure.add("vertexColor",kha_graphics4_VertexData.Float4);
	return structure;
};
kha_graphics4_Graphics2.createColoredPipeline = function(structure) {
	var shaderPipeline = new kha_graphics4_PipelineState();
	shaderPipeline.fragmentShader = kha_Shaders.painter_colored_frag;
	shaderPipeline.vertexShader = kha_Shaders.painter_colored_vert;
	shaderPipeline.inputLayout = [structure];
	shaderPipeline.blendSource = kha_graphics4_BlendingFactor.SourceAlpha;
	shaderPipeline.blendDestination = kha_graphics4_BlendingFactor.InverseSourceAlpha;
	shaderPipeline.alphaBlendSource = kha_graphics4_BlendingFactor.SourceAlpha;
	shaderPipeline.alphaBlendDestination = kha_graphics4_BlendingFactor.InverseSourceAlpha;
	return shaderPipeline;
};
kha_graphics4_Graphics2.createTextVertexStructure = function() {
	var structure = new kha_graphics4_VertexStructure();
	structure.add("vertexPosition",kha_graphics4_VertexData.Float3);
	structure.add("texPosition",kha_graphics4_VertexData.Float2);
	structure.add("vertexColor",kha_graphics4_VertexData.Float4);
	return structure;
};
kha_graphics4_Graphics2.createTextPipeline = function(structure) {
	var shaderPipeline = new kha_graphics4_PipelineState();
	shaderPipeline.fragmentShader = kha_Shaders.painter_text_frag;
	shaderPipeline.vertexShader = kha_Shaders.painter_text_vert;
	shaderPipeline.inputLayout = [structure];
	shaderPipeline.blendSource = kha_graphics4_BlendingFactor.SourceAlpha;
	shaderPipeline.blendDestination = kha_graphics4_BlendingFactor.InverseSourceAlpha;
	shaderPipeline.alphaBlendSource = kha_graphics4_BlendingFactor.SourceAlpha;
	shaderPipeline.alphaBlendDestination = kha_graphics4_BlendingFactor.InverseSourceAlpha;
	return shaderPipeline;
};
kha_graphics4_Graphics2.__super__ = kha_graphics2_Graphics;
kha_graphics4_Graphics2.prototype = $extend(kha_graphics2_Graphics.prototype,{
	myColor: null
	,myFont: null
	,projectionMatrix: null
	,imagePainter: null
	,coloredPainter: null
	,textPainter: null
	,canvas: null
	,g: null
	,setProjection: function() {
		var width = this.canvas.get_width();
		var height = this.canvas.get_height();
		if(js_Boot.__instanceof(this.canvas,kha_Framebuffer)) {
			this.projectionMatrix = kha_math_FastMatrix4.orthogonalProjection(0,width,height,0,0.1,1000);
		} else {
			if(!kha_Image.get_nonPow2Supported()) {
				width = kha_graphics4_Graphics2.upperPowerOfTwo(width);
				height = kha_graphics4_Graphics2.upperPowerOfTwo(height);
			}
			if(this.g.renderTargetsInvertedY()) {
				this.projectionMatrix = kha_math_FastMatrix4.orthogonalProjection(0,width,0,height,0.1,1000);
			} else {
				this.projectionMatrix = kha_math_FastMatrix4.orthogonalProjection(0,width,height,0,0.1,1000);
			}
		}
		this.imagePainter.setProjection(this.projectionMatrix);
		this.coloredPainter.setProjection(this.projectionMatrix);
		this.textPainter.setProjection(this.projectionMatrix);
	}
	,drawImage: function(img,x,y) {
		var _this = this.coloredPainter;
		if(_this.triangleBufferIndex > 0) {
			_this.drawTriBuffer(false);
		}
		if(_this.bufferIndex > 0) {
			_this.drawBuffer(false);
		}
		this.textPainter.end();
		var xw = x + img.get_width();
		var yh = y + img.get_height();
		var p1_y;
		var p1_x;
		var _this1 = this.transformations[this.transformations.length - 1];
		var value_y;
		var value_x = x;
		value_y = yh;
		var w = _this1._02 * value_x + _this1._12 * value_y + _this1._22;
		var x1 = (_this1._00 * value_x + _this1._10 * value_y + _this1._20) / w;
		var y1 = (_this1._01 * value_x + _this1._11 * value_y + _this1._21) / w;
		p1_x = x1;
		p1_y = y1;
		var p2_y;
		var p2_x;
		var _this2 = this.transformations[this.transformations.length - 1];
		var value_y1;
		var value_x1 = x;
		value_y1 = y;
		var w1 = _this2._02 * value_x1 + _this2._12 * value_y1 + _this2._22;
		var x2 = (_this2._00 * value_x1 + _this2._10 * value_y1 + _this2._20) / w1;
		var y2 = (_this2._01 * value_x1 + _this2._11 * value_y1 + _this2._21) / w1;
		p2_x = x2;
		p2_y = y2;
		var p3_y;
		var p3_x;
		var _this3 = this.transformations[this.transformations.length - 1];
		var value_y2;
		var value_x2 = xw;
		value_y2 = y;
		var w2 = _this3._02 * value_x2 + _this3._12 * value_y2 + _this3._22;
		var x3 = (_this3._00 * value_x2 + _this3._10 * value_y2 + _this3._20) / w2;
		var y3 = (_this3._01 * value_x2 + _this3._11 * value_y2 + _this3._21) / w2;
		p3_x = x3;
		p3_y = y3;
		var p4_y;
		var p4_x;
		var _this4 = this.transformations[this.transformations.length - 1];
		var value_y3;
		var value_x3 = xw;
		value_y3 = yh;
		var w3 = _this4._02 * value_x3 + _this4._12 * value_y3 + _this4._22;
		var x4 = (_this4._00 * value_x3 + _this4._10 * value_y3 + _this4._20) / w3;
		var y4 = (_this4._01 * value_x3 + _this4._11 * value_y3 + _this4._21) / w3;
		p4_x = x4;
		p4_y = y4;
		var _this5 = this.imagePainter;
		var opacity = this.get_opacity();
		var color = this.get_color();
		var tex = img;
		if(_this5.bufferIndex + 1 >= kha_graphics4_ImageShaderPainter.bufferSize || _this5.lastTexture != null && tex != _this5.lastTexture) {
			_this5.drawBuffer();
		}
		var r = ((color & 16711680) >>> 16) * 0.00392156862745098;
		var g = ((color & 65280) >>> 8) * 0.00392156862745098;
		var b = (color & 255) * 0.00392156862745098;
		var a = (color >>> 24) * 0.00392156862745098 * opacity;
		var baseIndex = _this5.bufferIndex * kha_graphics4_ImageShaderPainter.vertexSize * 4;
		_this5.rectVertices[baseIndex + 5] = r;
		_this5.rectVertices[baseIndex + 6] = g;
		_this5.rectVertices[baseIndex + 7] = b;
		_this5.rectVertices[baseIndex + 8] = a;
		_this5.rectVertices[baseIndex + 14] = r;
		_this5.rectVertices[baseIndex + 15] = g;
		_this5.rectVertices[baseIndex + 16] = b;
		_this5.rectVertices[baseIndex + 17] = a;
		_this5.rectVertices[baseIndex + 23] = r;
		_this5.rectVertices[baseIndex + 24] = g;
		_this5.rectVertices[baseIndex + 25] = b;
		_this5.rectVertices[baseIndex + 26] = a;
		_this5.rectVertices[baseIndex + 32] = r;
		_this5.rectVertices[baseIndex + 33] = g;
		_this5.rectVertices[baseIndex + 34] = b;
		_this5.rectVertices[baseIndex + 35] = a;
		var right = tex.get_width() / tex.get_realWidth();
		var bottom = tex.get_height() / tex.get_realHeight();
		var baseIndex1 = _this5.bufferIndex * kha_graphics4_ImageShaderPainter.vertexSize * 4;
		_this5.rectVertices[baseIndex1 + 3] = 0;
		_this5.rectVertices[baseIndex1 + 4] = bottom;
		_this5.rectVertices[baseIndex1 + 12] = 0;
		_this5.rectVertices[baseIndex1 + 13] = 0;
		_this5.rectVertices[baseIndex1 + 21] = right;
		_this5.rectVertices[baseIndex1 + 22] = 0;
		_this5.rectVertices[baseIndex1 + 30] = right;
		_this5.rectVertices[baseIndex1 + 31] = bottom;
		var baseIndex2 = _this5.bufferIndex * kha_graphics4_ImageShaderPainter.vertexSize * 4;
		_this5.rectVertices[baseIndex2] = p1_x;
		_this5.rectVertices[baseIndex2 + 1] = p1_y;
		_this5.rectVertices[baseIndex2 + 2] = -5.0;
		_this5.rectVertices[baseIndex2 + 9] = p2_x;
		_this5.rectVertices[baseIndex2 + 10] = p2_y;
		_this5.rectVertices[baseIndex2 + 11] = -5.0;
		_this5.rectVertices[baseIndex2 + 18] = p3_x;
		_this5.rectVertices[baseIndex2 + 19] = p3_y;
		_this5.rectVertices[baseIndex2 + 20] = -5.0;
		_this5.rectVertices[baseIndex2 + 27] = p4_x;
		_this5.rectVertices[baseIndex2 + 28] = p4_y;
		_this5.rectVertices[baseIndex2 + 29] = -5.0;
		++_this5.bufferIndex;
		_this5.lastTexture = tex;
	}
	,drawScaledSubImage: function(img,sx,sy,sw,sh,dx,dy,dw,dh) {
		var _this = this.coloredPainter;
		if(_this.triangleBufferIndex > 0) {
			_this.drawTriBuffer(false);
		}
		if(_this.bufferIndex > 0) {
			_this.drawBuffer(false);
		}
		this.textPainter.end();
		var p1_y;
		var p1_x;
		var _this1 = this.transformations[this.transformations.length - 1];
		var value_y;
		var value_x = dx;
		value_y = dy + dh;
		var w = _this1._02 * value_x + _this1._12 * value_y + _this1._22;
		var x = (_this1._00 * value_x + _this1._10 * value_y + _this1._20) / w;
		var y = (_this1._01 * value_x + _this1._11 * value_y + _this1._21) / w;
		p1_x = x;
		p1_y = y;
		var p2_y;
		var p2_x;
		var _this2 = this.transformations[this.transformations.length - 1];
		var value_y1;
		var value_x1 = dx;
		value_y1 = dy;
		var w1 = _this2._02 * value_x1 + _this2._12 * value_y1 + _this2._22;
		var x1 = (_this2._00 * value_x1 + _this2._10 * value_y1 + _this2._20) / w1;
		var y1 = (_this2._01 * value_x1 + _this2._11 * value_y1 + _this2._21) / w1;
		p2_x = x1;
		p2_y = y1;
		var p3_y;
		var p3_x;
		var _this3 = this.transformations[this.transformations.length - 1];
		var value_y2;
		var value_x2 = dx + dw;
		value_y2 = dy;
		var w2 = _this3._02 * value_x2 + _this3._12 * value_y2 + _this3._22;
		var x2 = (_this3._00 * value_x2 + _this3._10 * value_y2 + _this3._20) / w2;
		var y2 = (_this3._01 * value_x2 + _this3._11 * value_y2 + _this3._21) / w2;
		p3_x = x2;
		p3_y = y2;
		var p4_y;
		var p4_x;
		var _this4 = this.transformations[this.transformations.length - 1];
		var value_y3;
		var value_x3 = dx + dw;
		value_y3 = dy + dh;
		var w3 = _this4._02 * value_x3 + _this4._12 * value_y3 + _this4._22;
		var x3 = (_this4._00 * value_x3 + _this4._10 * value_y3 + _this4._20) / w3;
		var y3 = (_this4._01 * value_x3 + _this4._11 * value_y3 + _this4._21) / w3;
		p4_x = x3;
		p4_y = y3;
		var _this5 = this.imagePainter;
		var opacity = this.get_opacity();
		var color = this.get_color();
		var tex = img;
		if(_this5.bufferIndex + 1 >= kha_graphics4_ImageShaderPainter.bufferSize || _this5.lastTexture != null && tex != _this5.lastTexture) {
			_this5.drawBuffer();
		}
		var left = sx / tex.get_realWidth();
		var top = sy / tex.get_realHeight();
		var right = (sx + sw) / tex.get_realWidth();
		var bottom = (sy + sh) / tex.get_realHeight();
		var baseIndex = _this5.bufferIndex * kha_graphics4_ImageShaderPainter.vertexSize * 4;
		_this5.rectVertices[baseIndex + 3] = left;
		_this5.rectVertices[baseIndex + 4] = bottom;
		_this5.rectVertices[baseIndex + 12] = left;
		_this5.rectVertices[baseIndex + 13] = top;
		_this5.rectVertices[baseIndex + 21] = right;
		_this5.rectVertices[baseIndex + 22] = top;
		_this5.rectVertices[baseIndex + 30] = right;
		_this5.rectVertices[baseIndex + 31] = bottom;
		var r = ((color & 16711680) >>> 16) * 0.00392156862745098;
		var g = ((color & 65280) >>> 8) * 0.00392156862745098;
		var b = (color & 255) * 0.00392156862745098;
		var a = (color >>> 24) * 0.00392156862745098 * opacity;
		var baseIndex1 = _this5.bufferIndex * kha_graphics4_ImageShaderPainter.vertexSize * 4;
		_this5.rectVertices[baseIndex1 + 5] = r;
		_this5.rectVertices[baseIndex1 + 6] = g;
		_this5.rectVertices[baseIndex1 + 7] = b;
		_this5.rectVertices[baseIndex1 + 8] = a;
		_this5.rectVertices[baseIndex1 + 14] = r;
		_this5.rectVertices[baseIndex1 + 15] = g;
		_this5.rectVertices[baseIndex1 + 16] = b;
		_this5.rectVertices[baseIndex1 + 17] = a;
		_this5.rectVertices[baseIndex1 + 23] = r;
		_this5.rectVertices[baseIndex1 + 24] = g;
		_this5.rectVertices[baseIndex1 + 25] = b;
		_this5.rectVertices[baseIndex1 + 26] = a;
		_this5.rectVertices[baseIndex1 + 32] = r;
		_this5.rectVertices[baseIndex1 + 33] = g;
		_this5.rectVertices[baseIndex1 + 34] = b;
		_this5.rectVertices[baseIndex1 + 35] = a;
		var baseIndex2 = _this5.bufferIndex * kha_graphics4_ImageShaderPainter.vertexSize * 4;
		_this5.rectVertices[baseIndex2] = p1_x;
		_this5.rectVertices[baseIndex2 + 1] = p1_y;
		_this5.rectVertices[baseIndex2 + 2] = -5.0;
		_this5.rectVertices[baseIndex2 + 9] = p2_x;
		_this5.rectVertices[baseIndex2 + 10] = p2_y;
		_this5.rectVertices[baseIndex2 + 11] = -5.0;
		_this5.rectVertices[baseIndex2 + 18] = p3_x;
		_this5.rectVertices[baseIndex2 + 19] = p3_y;
		_this5.rectVertices[baseIndex2 + 20] = -5.0;
		_this5.rectVertices[baseIndex2 + 27] = p4_x;
		_this5.rectVertices[baseIndex2 + 28] = p4_y;
		_this5.rectVertices[baseIndex2 + 29] = -5.0;
		++_this5.bufferIndex;
		_this5.lastTexture = tex;
	}
	,get_color: function() {
		return this.myColor;
	}
	,set_color: function(color) {
		return this.myColor = color;
	}
	,drawRect: function(x,y,width,height,strength) {
		if(strength == null) {
			strength = 1.0;
		}
		this.imagePainter.end();
		this.textPainter.end();
		var _this = this.transformations[this.transformations.length - 1];
		var value_y;
		var value_x = x - strength / 2;
		value_y = y + strength / 2;
		var w = _this._02 * value_x + _this._12 * value_y + _this._22;
		var x1 = (_this._00 * value_x + _this._10 * value_y + _this._20) / w;
		var y1 = (_this._01 * value_x + _this._11 * value_y + _this._21) / w;
		var p1 = new kha_math_FastVector2(x1,y1);
		var _this1 = this.transformations[this.transformations.length - 1];
		var value_y1;
		var value_x1 = x - strength / 2;
		value_y1 = y - strength / 2;
		var w1 = _this1._02 * value_x1 + _this1._12 * value_y1 + _this1._22;
		var x2 = (_this1._00 * value_x1 + _this1._10 * value_y1 + _this1._20) / w1;
		var y2 = (_this1._01 * value_x1 + _this1._11 * value_y1 + _this1._21) / w1;
		var p2 = new kha_math_FastVector2(x2,y2);
		var _this2 = this.transformations[this.transformations.length - 1];
		var value_y2;
		var value_x2 = x + width + strength / 2;
		value_y2 = y - strength / 2;
		var w2 = _this2._02 * value_x2 + _this2._12 * value_y2 + _this2._22;
		var x3 = (_this2._00 * value_x2 + _this2._10 * value_y2 + _this2._20) / w2;
		var y3 = (_this2._01 * value_x2 + _this2._11 * value_y2 + _this2._21) / w2;
		var p3 = new kha_math_FastVector2(x3,y3);
		var _this3 = this.transformations[this.transformations.length - 1];
		var value_y3;
		var value_x3 = x + width + strength / 2;
		value_y3 = y + strength / 2;
		var w3 = _this3._02 * value_x3 + _this3._12 * value_y3 + _this3._22;
		var x4 = (_this3._00 * value_x3 + _this3._10 * value_y3 + _this3._20) / w3;
		var y4 = (_this3._01 * value_x3 + _this3._11 * value_y3 + _this3._21) / w3;
		var p4 = new kha_math_FastVector2(x4,y4);
		this.coloredPainter.fillRect(this.get_opacity(),this.get_color(),p1.x,p1.y,p2.x,p2.y,p3.x,p3.y,p4.x,p4.y);
		var _this4 = this.transformations[this.transformations.length - 1];
		var value_y4;
		var value_x4 = x - strength / 2;
		value_y4 = y + height + strength / 2;
		var w4 = _this4._02 * value_x4 + _this4._12 * value_y4 + _this4._22;
		var x5 = (_this4._00 * value_x4 + _this4._10 * value_y4 + _this4._20) / w4;
		var y5 = (_this4._01 * value_x4 + _this4._11 * value_y4 + _this4._21) / w4;
		p1 = new kha_math_FastVector2(x5,y5);
		var _this5 = this.transformations[this.transformations.length - 1];
		var value_y5;
		var value_x5 = x + strength / 2;
		value_y5 = y - strength / 2;
		var w5 = _this5._02 * value_x5 + _this5._12 * value_y5 + _this5._22;
		var x6 = (_this5._00 * value_x5 + _this5._10 * value_y5 + _this5._20) / w5;
		var y6 = (_this5._01 * value_x5 + _this5._11 * value_y5 + _this5._21) / w5;
		p3 = new kha_math_FastVector2(x6,y6);
		var _this6 = this.transformations[this.transformations.length - 1];
		var value_y6;
		var value_x6 = x + strength / 2;
		value_y6 = y + height + strength / 2;
		var w6 = _this6._02 * value_x6 + _this6._12 * value_y6 + _this6._22;
		var x7 = (_this6._00 * value_x6 + _this6._10 * value_y6 + _this6._20) / w6;
		var y7 = (_this6._01 * value_x6 + _this6._11 * value_y6 + _this6._21) / w6;
		p4 = new kha_math_FastVector2(x7,y7);
		this.coloredPainter.fillRect(this.get_opacity(),this.get_color(),p1.x,p1.y,p2.x,p2.y,p3.x,p3.y,p4.x,p4.y);
		var _this7 = this.transformations[this.transformations.length - 1];
		var value_y7;
		var value_x7 = x - strength / 2;
		value_y7 = y + height - strength / 2;
		var w7 = _this7._02 * value_x7 + _this7._12 * value_y7 + _this7._22;
		var x8 = (_this7._00 * value_x7 + _this7._10 * value_y7 + _this7._20) / w7;
		var y8 = (_this7._01 * value_x7 + _this7._11 * value_y7 + _this7._21) / w7;
		p2 = new kha_math_FastVector2(x8,y8);
		var _this8 = this.transformations[this.transformations.length - 1];
		var value_y8;
		var value_x8 = x + width + strength / 2;
		value_y8 = y + height - strength / 2;
		var w8 = _this8._02 * value_x8 + _this8._12 * value_y8 + _this8._22;
		var x9 = (_this8._00 * value_x8 + _this8._10 * value_y8 + _this8._20) / w8;
		var y9 = (_this8._01 * value_x8 + _this8._11 * value_y8 + _this8._21) / w8;
		p3 = new kha_math_FastVector2(x9,y9);
		var _this9 = this.transformations[this.transformations.length - 1];
		var value_y9;
		var value_x9 = x + width + strength / 2;
		value_y9 = y + height + strength / 2;
		var w9 = _this9._02 * value_x9 + _this9._12 * value_y9 + _this9._22;
		var x10 = (_this9._00 * value_x9 + _this9._10 * value_y9 + _this9._20) / w9;
		var y10 = (_this9._01 * value_x9 + _this9._11 * value_y9 + _this9._21) / w9;
		p4 = new kha_math_FastVector2(x10,y10);
		this.coloredPainter.fillRect(this.get_opacity(),this.get_color(),p1.x,p1.y,p2.x,p2.y,p3.x,p3.y,p4.x,p4.y);
		var _this10 = this.transformations[this.transformations.length - 1];
		var value_y10;
		var value_x10 = x + width - strength / 2;
		value_y10 = y + height + strength / 2;
		var w10 = _this10._02 * value_x10 + _this10._12 * value_y10 + _this10._22;
		var x11 = (_this10._00 * value_x10 + _this10._10 * value_y10 + _this10._20) / w10;
		var y11 = (_this10._01 * value_x10 + _this10._11 * value_y10 + _this10._21) / w10;
		p1 = new kha_math_FastVector2(x11,y11);
		var _this11 = this.transformations[this.transformations.length - 1];
		var value_y11;
		var value_x11 = x + width - strength / 2;
		value_y11 = y - strength / 2;
		var w11 = _this11._02 * value_x11 + _this11._12 * value_y11 + _this11._22;
		var x12 = (_this11._00 * value_x11 + _this11._10 * value_y11 + _this11._20) / w11;
		var y12 = (_this11._01 * value_x11 + _this11._11 * value_y11 + _this11._21) / w11;
		p2 = new kha_math_FastVector2(x12,y12);
		var _this12 = this.transformations[this.transformations.length - 1];
		var value_y12;
		var value_x12 = x + width + strength / 2;
		value_y12 = y - strength / 2;
		var w12 = _this12._02 * value_x12 + _this12._12 * value_y12 + _this12._22;
		var x13 = (_this12._00 * value_x12 + _this12._10 * value_y12 + _this12._20) / w12;
		var y13 = (_this12._01 * value_x12 + _this12._11 * value_y12 + _this12._21) / w12;
		p3 = new kha_math_FastVector2(x13,y13);
		var _this13 = this.transformations[this.transformations.length - 1];
		var value_y13;
		var value_x13 = x + width + strength / 2;
		value_y13 = y + height + strength / 2;
		var w13 = _this13._02 * value_x13 + _this13._12 * value_y13 + _this13._22;
		var x14 = (_this13._00 * value_x13 + _this13._10 * value_y13 + _this13._20) / w13;
		var y14 = (_this13._01 * value_x13 + _this13._11 * value_y13 + _this13._21) / w13;
		p4 = new kha_math_FastVector2(x14,y14);
		this.coloredPainter.fillRect(this.get_opacity(),this.get_color(),p1.x,p1.y,p2.x,p2.y,p3.x,p3.y,p4.x,p4.y);
	}
	,fillRect: function(x,y,width,height) {
		this.imagePainter.end();
		this.textPainter.end();
		var p1_y;
		var p1_x;
		var _this = this.transformations[this.transformations.length - 1];
		var value_y;
		var value_x = x;
		value_y = y + height;
		var w = _this._02 * value_x + _this._12 * value_y + _this._22;
		var x1 = (_this._00 * value_x + _this._10 * value_y + _this._20) / w;
		var y1 = (_this._01 * value_x + _this._11 * value_y + _this._21) / w;
		p1_x = x1;
		p1_y = y1;
		var p2_y;
		var p2_x;
		var _this1 = this.transformations[this.transformations.length - 1];
		var value_y1;
		var value_x1 = x;
		value_y1 = y;
		var w1 = _this1._02 * value_x1 + _this1._12 * value_y1 + _this1._22;
		var x2 = (_this1._00 * value_x1 + _this1._10 * value_y1 + _this1._20) / w1;
		var y2 = (_this1._01 * value_x1 + _this1._11 * value_y1 + _this1._21) / w1;
		p2_x = x2;
		p2_y = y2;
		var p3_y;
		var p3_x;
		var _this2 = this.transformations[this.transformations.length - 1];
		var value_y2;
		var value_x2 = x + width;
		value_y2 = y;
		var w2 = _this2._02 * value_x2 + _this2._12 * value_y2 + _this2._22;
		var x3 = (_this2._00 * value_x2 + _this2._10 * value_y2 + _this2._20) / w2;
		var y3 = (_this2._01 * value_x2 + _this2._11 * value_y2 + _this2._21) / w2;
		p3_x = x3;
		p3_y = y3;
		var p4_y;
		var p4_x;
		var _this3 = this.transformations[this.transformations.length - 1];
		var value_y3;
		var value_x3 = x + width;
		value_y3 = y + height;
		var w3 = _this3._02 * value_x3 + _this3._12 * value_y3 + _this3._22;
		var x4 = (_this3._00 * value_x3 + _this3._10 * value_y3 + _this3._20) / w3;
		var y4 = (_this3._01 * value_x3 + _this3._11 * value_y3 + _this3._21) / w3;
		p4_x = x4;
		p4_y = y4;
		this.coloredPainter.fillRect(this.get_opacity(),this.get_color(),p1_x,p1_y,p2_x,p2_y,p3_x,p3_y,p4_x,p4_y);
	}
	,drawString: function(text,x,y) {
		this.imagePainter.end();
		var _this = this.coloredPainter;
		if(_this.triangleBufferIndex > 0) {
			_this.drawTriBuffer(false);
		}
		if(_this.bufferIndex > 0) {
			_this.drawBuffer(false);
		}
		this.textPainter.drawString(text,this.get_opacity(),this.get_color(),x,y,this.transformations[this.transformations.length - 1],this.get_fontGlyphs());
	}
	,drawCharacters: function(text,start,length,x,y) {
		this.imagePainter.end();
		var _this = this.coloredPainter;
		if(_this.triangleBufferIndex > 0) {
			_this.drawTriBuffer(false);
		}
		if(_this.bufferIndex > 0) {
			_this.drawBuffer(false);
		}
		this.textPainter.drawCharacters(text,start,length,this.get_opacity(),this.get_color(),x,y,this.transformations[this.transformations.length - 1],this.get_fontGlyphs());
	}
	,get_font: function() {
		return this.myFont;
	}
	,set_font: function(font) {
		this.textPainter.setFont(font);
		return this.myFont = font;
	}
	,set_fontSize: function(value) {
		return kha_graphics2_Graphics.prototype.set_fontSize.call(this,this.textPainter.fontSize = value);
	}
	,drawLine: function(x1,y1,x2,y2,strength) {
		if(strength == null) {
			strength = 1.0;
		}
		this.imagePainter.end();
		this.textPainter.end();
		var vec;
		if(y2 == y1) {
			vec = new kha_math_FastVector2(0,-1);
		} else {
			vec = new kha_math_FastVector2(1,-(x2 - x1) / (y2 - y1));
		}
		vec.set_length(strength);
		var p1 = new kha_math_FastVector2(x1 + 0.5 * vec.x,y1 + 0.5 * vec.y);
		var p2 = new kha_math_FastVector2(x2 + 0.5 * vec.x,y2 + 0.5 * vec.y);
		var p3 = new kha_math_FastVector2(p1.x - vec.x,p1.y - vec.y);
		var p4 = new kha_math_FastVector2(p2.x - vec.x,p2.y - vec.y);
		var _this = this.transformations[this.transformations.length - 1];
		var w = _this._02 * p1.x + _this._12 * p1.y + _this._22;
		var x = (_this._00 * p1.x + _this._10 * p1.y + _this._20) / w;
		var y = (_this._01 * p1.x + _this._11 * p1.y + _this._21) / w;
		p1 = new kha_math_FastVector2(x,y);
		var _this1 = this.transformations[this.transformations.length - 1];
		var w1 = _this1._02 * p2.x + _this1._12 * p2.y + _this1._22;
		var x3 = (_this1._00 * p2.x + _this1._10 * p2.y + _this1._20) / w1;
		var y3 = (_this1._01 * p2.x + _this1._11 * p2.y + _this1._21) / w1;
		p2 = new kha_math_FastVector2(x3,y3);
		var _this2 = this.transformations[this.transformations.length - 1];
		var w2 = _this2._02 * p3.x + _this2._12 * p3.y + _this2._22;
		var x4 = (_this2._00 * p3.x + _this2._10 * p3.y + _this2._20) / w2;
		var y4 = (_this2._01 * p3.x + _this2._11 * p3.y + _this2._21) / w2;
		p3 = new kha_math_FastVector2(x4,y4);
		var _this3 = this.transformations[this.transformations.length - 1];
		var w3 = _this3._02 * p4.x + _this3._12 * p4.y + _this3._22;
		var x5 = (_this3._00 * p4.x + _this3._10 * p4.y + _this3._20) / w3;
		var y5 = (_this3._01 * p4.x + _this3._11 * p4.y + _this3._21) / w3;
		p4 = new kha_math_FastVector2(x5,y5);
		this.coloredPainter.fillTriangle(this.get_opacity(),this.get_color(),p1.x,p1.y,p2.x,p2.y,p3.x,p3.y);
		this.coloredPainter.fillTriangle(this.get_opacity(),this.get_color(),p3.x,p3.y,p2.x,p2.y,p4.x,p4.y);
	}
	,fillTriangle: function(x1,y1,x2,y2,x3,y3) {
		this.imagePainter.end();
		this.textPainter.end();
		var p1_y;
		var p1_x;
		var _this = this.transformations[this.transformations.length - 1];
		var value_y;
		var value_x = x1;
		value_y = y1;
		var w = _this._02 * value_x + _this._12 * value_y + _this._22;
		var x = (_this._00 * value_x + _this._10 * value_y + _this._20) / w;
		var y = (_this._01 * value_x + _this._11 * value_y + _this._21) / w;
		p1_x = x;
		p1_y = y;
		var p2_y;
		var p2_x;
		var _this1 = this.transformations[this.transformations.length - 1];
		var value_y1;
		var value_x1 = x2;
		value_y1 = y2;
		var w1 = _this1._02 * value_x1 + _this1._12 * value_y1 + _this1._22;
		var x4 = (_this1._00 * value_x1 + _this1._10 * value_y1 + _this1._20) / w1;
		var y4 = (_this1._01 * value_x1 + _this1._11 * value_y1 + _this1._21) / w1;
		p2_x = x4;
		p2_y = y4;
		var p3_y;
		var p3_x;
		var _this2 = this.transformations[this.transformations.length - 1];
		var value_y2;
		var value_x2 = x3;
		value_y2 = y3;
		var w2 = _this2._02 * value_x2 + _this2._12 * value_y2 + _this2._22;
		var x5 = (_this2._00 * value_x2 + _this2._10 * value_y2 + _this2._20) / w2;
		var y5 = (_this2._01 * value_x2 + _this2._11 * value_y2 + _this2._21) / w2;
		p3_x = x5;
		p3_y = y5;
		this.coloredPainter.fillTriangle(this.get_opacity(),this.get_color(),p1_x,p1_y,p2_x,p2_y,p3_x,p3_y);
	}
	,myImageScaleQuality: null
	,get_imageScaleQuality: function() {
		return this.myImageScaleQuality;
	}
	,set_imageScaleQuality: function(value) {
		this.imagePainter.setBilinearFilter(value == kha_graphics2_ImageScaleQuality.High);
		this.textPainter.setBilinearFilter(value == kha_graphics2_ImageScaleQuality.High);
		return this.myImageScaleQuality = value;
	}
	,myMipmapScaleQuality: null
	,get_mipmapScaleQuality: function() {
		return this.myMipmapScaleQuality;
	}
	,set_mipmapScaleQuality: function(value) {
		this.imagePainter.setBilinearMipmapFilter(value == kha_graphics2_ImageScaleQuality.High);
		return this.myMipmapScaleQuality = value;
	}
	,setPipeline: function(pipeline) {
		this.flush();
		this.imagePainter.set_pipeline(pipeline);
		this.coloredPainter.set_pipeline(pipeline);
		this.textPainter.set_pipeline(pipeline);
		if(pipeline != null) {
			this.g.setPipeline(pipeline);
		}
	}
	,scissor: function(x,y,width,height) {
		this.flush();
		this.g.scissor(x,y,width,height);
	}
	,disableScissor: function() {
		this.flush();
		this.g.disableScissor();
	}
	,begin: function(clear,clearColor) {
		if(clear == null) {
			clear = true;
		}
		this.g.begin();
		if(clear) {
			this.clear(clearColor);
		}
		this.setProjection();
	}
	,clear: function(color) {
		this.flush();
		this.g.clear(color == null ? -16777216 : color);
	}
	,flush: function() {
		this.imagePainter.end();
		this.textPainter.end();
		var _this = this.coloredPainter;
		if(_this.triangleBufferIndex > 0) {
			_this.drawTriBuffer(false);
		}
		if(_this.bufferIndex > 0) {
			_this.drawBuffer(false);
		}
	}
	,end: function() {
		this.flush();
		this.g.end();
	}
	,drawVideoInternal: function(video,x,y,width,height) {
	}
	,drawVideo: function(video,x,y,width,height) {
		this.setPipeline(kha_graphics4_Graphics2.videoPipeline);
		this.drawVideoInternal(video,x,y,width,height);
		this.setPipeline(null);
	}
	,__class__: kha_graphics4_Graphics2
});
var kha_graphics4_IndexBuffer = function(indexCount,usage,canRead) {
	if(canRead == null) {
		canRead = false;
	}
	this.usage = usage;
	this.mySize = indexCount;
	this.buffer = kha_SystemImpl.gl.createBuffer();
	var this1 = new Uint32Array(indexCount);
	this._data = this1;
};
$hxClasses["kha.graphics4.IndexBuffer"] = kha_graphics4_IndexBuffer;
kha_graphics4_IndexBuffer.__name__ = true;
kha_graphics4_IndexBuffer.prototype = {
	buffer: null
	,_data: null
	,mySize: null
	,usage: null
	,'delete': function() {
		this._data = null;
		kha_SystemImpl.gl.deleteBuffer(this.buffer);
	}
	,lock: function(start,count) {
		if(start == null) {
			start = 0;
		}
		if(count == null) {
			count = this.mySize;
		}
		return this._data.subarray(start,start + count);
	}
	,unlock: function() {
		kha_SystemImpl.gl.bindBuffer(34963,this.buffer);
		var glData = kha_SystemImpl.elementIndexUint == null ? new Uint16Array(this._data) : this._data;
		kha_SystemImpl.gl.bufferData(34963,glData,this.usage == kha_graphics4_Usage.DynamicUsage ? 35048 : 35044);
	}
	,set: function() {
		kha_SystemImpl.gl.bindBuffer(34963,this.buffer);
	}
	,count: function() {
		return this.mySize;
	}
	,__class__: kha_graphics4_IndexBuffer
};
var kha_graphics4_MipMapFilter = $hxClasses["kha.graphics4.MipMapFilter"] = { __ename__ : true, __constructs__ : ["NoMipFilter","PointMipFilter","LinearMipFilter"] };
kha_graphics4_MipMapFilter.NoMipFilter = ["NoMipFilter",0];
kha_graphics4_MipMapFilter.NoMipFilter.toString = $estr;
kha_graphics4_MipMapFilter.NoMipFilter.__enum__ = kha_graphics4_MipMapFilter;
kha_graphics4_MipMapFilter.PointMipFilter = ["PointMipFilter",1];
kha_graphics4_MipMapFilter.PointMipFilter.toString = $estr;
kha_graphics4_MipMapFilter.PointMipFilter.__enum__ = kha_graphics4_MipMapFilter;
kha_graphics4_MipMapFilter.LinearMipFilter = ["LinearMipFilter",2];
kha_graphics4_MipMapFilter.LinearMipFilter.toString = $estr;
kha_graphics4_MipMapFilter.LinearMipFilter.__enum__ = kha_graphics4_MipMapFilter;
var kha_graphics4_PipelineStateBase = function() {
	this.inputLayout = null;
	this.vertexShader = null;
	this.fragmentShader = null;
	this.geometryShader = null;
	this.tessellationControlShader = null;
	this.tessellationEvaluationShader = null;
	this.cullMode = kha_graphics4_CullMode.None;
	this.depthWrite = false;
	this.depthMode = kha_graphics4_CompareMode.Always;
	this.stencilMode = kha_graphics4_CompareMode.Always;
	this.stencilBothPass = kha_graphics4_StencilAction.Keep;
	this.stencilDepthFail = kha_graphics4_StencilAction.Keep;
	this.stencilFail = kha_graphics4_StencilAction.Keep;
	this.stencilReferenceValue = 0;
	this.stencilReadMask = 255;
	this.stencilWriteMask = 255;
	this.blendSource = kha_graphics4_BlendingFactor.BlendOne;
	this.blendDestination = kha_graphics4_BlendingFactor.BlendZero;
	this.blendOperation = kha_graphics4_BlendingOperation.Add;
	this.alphaBlendSource = kha_graphics4_BlendingFactor.BlendOne;
	this.alphaBlendDestination = kha_graphics4_BlendingFactor.BlendZero;
	this.alphaBlendOperation = kha_graphics4_BlendingOperation.Add;
	this.colorWriteMaskRed = this.colorWriteMaskBlue = this.colorWriteMaskGreen = this.colorWriteMaskAlpha = true;
	this.conservativeRasterization = false;
};
$hxClasses["kha.graphics4.PipelineStateBase"] = kha_graphics4_PipelineStateBase;
kha_graphics4_PipelineStateBase.__name__ = true;
kha_graphics4_PipelineStateBase.prototype = {
	inputLayout: null
	,vertexShader: null
	,fragmentShader: null
	,geometryShader: null
	,tessellationControlShader: null
	,tessellationEvaluationShader: null
	,cullMode: null
	,depthWrite: null
	,depthMode: null
	,stencilMode: null
	,stencilBothPass: null
	,stencilDepthFail: null
	,stencilFail: null
	,stencilReferenceValue: null
	,stencilReadMask: null
	,stencilWriteMask: null
	,blendSource: null
	,blendDestination: null
	,blendOperation: null
	,alphaBlendSource: null
	,alphaBlendDestination: null
	,alphaBlendOperation: null
	,colorWriteMaskRed: null
	,colorWriteMaskGreen: null
	,colorWriteMaskBlue: null
	,colorWriteMaskAlpha: null
	,set_colorWriteMask: function(value) {
		return this.colorWriteMaskRed = this.colorWriteMaskBlue = this.colorWriteMaskGreen = this.colorWriteMaskAlpha = value;
	}
	,conservativeRasterization: null
	,__class__: kha_graphics4_PipelineStateBase
};
var kha_graphics4_PipelineState = function() {
	this.program = null;
	kha_graphics4_PipelineStateBase.call(this);
	this.textures = [];
	this.textureValues = [];
};
$hxClasses["kha.graphics4.PipelineState"] = kha_graphics4_PipelineState;
kha_graphics4_PipelineState.__name__ = true;
kha_graphics4_PipelineState.__super__ = kha_graphics4_PipelineStateBase;
kha_graphics4_PipelineState.prototype = $extend(kha_graphics4_PipelineStateBase.prototype,{
	program: null
	,textures: null
	,textureValues: null
	,'delete': function() {
		if(this.program != null) {
			kha_SystemImpl.gl.deleteProgram(this.program);
		}
	}
	,compile: function() {
		if(this.program != null) {
			kha_SystemImpl.gl.deleteProgram(this.program);
		}
		this.program = kha_SystemImpl.gl.createProgram();
		this.compileShader(this.vertexShader);
		this.compileShader(this.fragmentShader);
		kha_SystemImpl.gl.attachShader(this.program,this.vertexShader.shader);
		kha_SystemImpl.gl.attachShader(this.program,this.fragmentShader.shader);
		var index = 0;
		var _g = 0;
		var _g1 = this.inputLayout;
		while(_g < _g1.length) {
			var structure = _g1[_g];
			++_g;
			var _g2 = 0;
			var _g3 = structure.elements;
			while(_g2 < _g3.length) {
				var element = _g3[_g2];
				++_g2;
				kha_SystemImpl.gl.bindAttribLocation(this.program,index,element.name);
				if(element.data == kha_graphics4_VertexData.Float4x4) {
					index += 4;
				} else {
					++index;
				}
			}
		}
		kha_SystemImpl.gl.linkProgram(this.program);
		if(!kha_SystemImpl.gl.getProgramParameter(this.program,35714)) {
			throw new js__$Boot_HaxeError("Could not link the shader program:\n" + kha_SystemImpl.gl.getProgramInfoLog(this.program));
		}
	}
	,set: function() {
		kha_SystemImpl.gl.useProgram(this.program);
		var _g1 = 0;
		var _g = this.textureValues.length;
		while(_g1 < _g) {
			var index = _g1++;
			kha_SystemImpl.gl.uniform1i(this.textureValues[index],index);
		}
		kha_SystemImpl.gl.colorMask(this.colorWriteMaskRed,this.colorWriteMaskGreen,this.colorWriteMaskBlue,this.colorWriteMaskAlpha);
	}
	,compileShader: function(shader) {
		if(shader.shader != null) {
			return;
		}
		var s = kha_SystemImpl.gl.createShader(shader.type);
		var highp = kha_SystemImpl.gl.getShaderPrecisionFormat(35632,36338);
		var highpSupported = highp.precision != 0;
		var files = shader.files;
		var _g1 = 0;
		var _g = files.length;
		while(_g1 < _g) {
			var i = _g1++;
			if(kha_SystemImpl.gl2) {
				if(files[i].indexOf("-webgl2") >= 0 || files[i].indexOf("runtime-string") >= 0) {
					kha_SystemImpl.gl.shaderSource(s,shader.sources[i]);
					break;
				}
			} else {
				if(!highpSupported && (files[i].indexOf("-relaxed") >= 0 || files[i].indexOf("runtime-string") >= 0)) {
					kha_SystemImpl.gl.shaderSource(s,shader.sources[i]);
					break;
				}
				if(highpSupported && (files[i].indexOf("-relaxed") < 0 || files[i].indexOf("runtime-string") >= 0)) {
					kha_SystemImpl.gl.shaderSource(s,shader.sources[i]);
					break;
				}
			}
		}
		kha_SystemImpl.gl.compileShader(s);
		if(!kha_SystemImpl.gl.getShaderParameter(s,35713)) {
			throw new js__$Boot_HaxeError("Could not compile shader:\n" + kha_SystemImpl.gl.getShaderInfoLog(s));
		}
		shader.shader = s;
	}
	,getConstantLocation: function(name) {
		var location = kha_SystemImpl.gl.getUniformLocation(this.program,name);
		var type = 5126;
		var count = kha_SystemImpl.gl.getProgramParameter(this.program,35718);
		var _g1 = 0;
		var _g = count;
		while(_g1 < _g) {
			var i = _g1++;
			var info = kha_SystemImpl.gl.getActiveUniform(this.program,i);
			if(info.name == name || info.name == name + "[0]") {
				type = info.type;
				break;
			}
		}
		return new kha_js_graphics4_ConstantLocation(location,type);
	}
	,getTextureUnit: function(name) {
		var index = this.findTexture(name);
		if(index < 0) {
			var location = kha_SystemImpl.gl.getUniformLocation(this.program,name);
			index = this.textures.length;
			this.textureValues.push(location);
			this.textures.push(name);
		}
		return new kha_js_graphics4_TextureUnit(index);
	}
	,findTexture: function(name) {
		var _g1 = 0;
		var _g = this.textures.length;
		while(_g1 < _g) {
			var index = _g1++;
			if(this.textures[index] == name) {
				return index;
			}
		}
		return -1;
	}
	,__class__: kha_graphics4_PipelineState
});
var kha_graphics4_StencilAction = $hxClasses["kha.graphics4.StencilAction"] = { __ename__ : true, __constructs__ : ["Keep","Zero","Replace","Increment","IncrementWrap","Decrement","DecrementWrap","Invert"] };
kha_graphics4_StencilAction.Keep = ["Keep",0];
kha_graphics4_StencilAction.Keep.toString = $estr;
kha_graphics4_StencilAction.Keep.__enum__ = kha_graphics4_StencilAction;
kha_graphics4_StencilAction.Zero = ["Zero",1];
kha_graphics4_StencilAction.Zero.toString = $estr;
kha_graphics4_StencilAction.Zero.__enum__ = kha_graphics4_StencilAction;
kha_graphics4_StencilAction.Replace = ["Replace",2];
kha_graphics4_StencilAction.Replace.toString = $estr;
kha_graphics4_StencilAction.Replace.__enum__ = kha_graphics4_StencilAction;
kha_graphics4_StencilAction.Increment = ["Increment",3];
kha_graphics4_StencilAction.Increment.toString = $estr;
kha_graphics4_StencilAction.Increment.__enum__ = kha_graphics4_StencilAction;
kha_graphics4_StencilAction.IncrementWrap = ["IncrementWrap",4];
kha_graphics4_StencilAction.IncrementWrap.toString = $estr;
kha_graphics4_StencilAction.IncrementWrap.__enum__ = kha_graphics4_StencilAction;
kha_graphics4_StencilAction.Decrement = ["Decrement",5];
kha_graphics4_StencilAction.Decrement.toString = $estr;
kha_graphics4_StencilAction.Decrement.__enum__ = kha_graphics4_StencilAction;
kha_graphics4_StencilAction.DecrementWrap = ["DecrementWrap",6];
kha_graphics4_StencilAction.DecrementWrap.toString = $estr;
kha_graphics4_StencilAction.DecrementWrap.__enum__ = kha_graphics4_StencilAction;
kha_graphics4_StencilAction.Invert = ["Invert",7];
kha_graphics4_StencilAction.Invert.toString = $estr;
kha_graphics4_StencilAction.Invert.__enum__ = kha_graphics4_StencilAction;
var kha_graphics4_TessellationControlShader = function(source,file) {
};
$hxClasses["kha.graphics4.TessellationControlShader"] = kha_graphics4_TessellationControlShader;
kha_graphics4_TessellationControlShader.__name__ = true;
kha_graphics4_TessellationControlShader.prototype = {
	'delete': function() {
	}
	,__class__: kha_graphics4_TessellationControlShader
};
var kha_graphics4_TessellationEvaluationShader = function(source,file) {
};
$hxClasses["kha.graphics4.TessellationEvaluationShader"] = kha_graphics4_TessellationEvaluationShader;
kha_graphics4_TessellationEvaluationShader.__name__ = true;
kha_graphics4_TessellationEvaluationShader.prototype = {
	'delete': function() {
	}
	,__class__: kha_graphics4_TessellationEvaluationShader
};
var kha_graphics4_TexDir = $hxClasses["kha.graphics4.TexDir"] = { __ename__ : true, __constructs__ : ["U","V"] };
kha_graphics4_TexDir.U = ["U",0];
kha_graphics4_TexDir.U.toString = $estr;
kha_graphics4_TexDir.U.__enum__ = kha_graphics4_TexDir;
kha_graphics4_TexDir.V = ["V",1];
kha_graphics4_TexDir.V.toString = $estr;
kha_graphics4_TexDir.V.__enum__ = kha_graphics4_TexDir;
var kha_graphics4_TextureAddressing = $hxClasses["kha.graphics4.TextureAddressing"] = { __ename__ : true, __constructs__ : ["Repeat","Mirror","Clamp"] };
kha_graphics4_TextureAddressing.Repeat = ["Repeat",0];
kha_graphics4_TextureAddressing.Repeat.toString = $estr;
kha_graphics4_TextureAddressing.Repeat.__enum__ = kha_graphics4_TextureAddressing;
kha_graphics4_TextureAddressing.Mirror = ["Mirror",1];
kha_graphics4_TextureAddressing.Mirror.toString = $estr;
kha_graphics4_TextureAddressing.Mirror.__enum__ = kha_graphics4_TextureAddressing;
kha_graphics4_TextureAddressing.Clamp = ["Clamp",2];
kha_graphics4_TextureAddressing.Clamp.toString = $estr;
kha_graphics4_TextureAddressing.Clamp.__enum__ = kha_graphics4_TextureAddressing;
var kha_graphics4_TextureFilter = $hxClasses["kha.graphics4.TextureFilter"] = { __ename__ : true, __constructs__ : ["PointFilter","LinearFilter","AnisotropicFilter"] };
kha_graphics4_TextureFilter.PointFilter = ["PointFilter",0];
kha_graphics4_TextureFilter.PointFilter.toString = $estr;
kha_graphics4_TextureFilter.PointFilter.__enum__ = kha_graphics4_TextureFilter;
kha_graphics4_TextureFilter.LinearFilter = ["LinearFilter",1];
kha_graphics4_TextureFilter.LinearFilter.toString = $estr;
kha_graphics4_TextureFilter.LinearFilter.__enum__ = kha_graphics4_TextureFilter;
kha_graphics4_TextureFilter.AnisotropicFilter = ["AnisotropicFilter",2];
kha_graphics4_TextureFilter.AnisotropicFilter.toString = $estr;
kha_graphics4_TextureFilter.AnisotropicFilter.__enum__ = kha_graphics4_TextureFilter;
var kha_graphics4_TextureFormat = $hxClasses["kha.graphics4.TextureFormat"] = { __ename__ : true, __constructs__ : ["RGBA32","L8","RGBA128","DEPTH16","RGBA64","A32","A16"] };
kha_graphics4_TextureFormat.RGBA32 = ["RGBA32",0];
kha_graphics4_TextureFormat.RGBA32.toString = $estr;
kha_graphics4_TextureFormat.RGBA32.__enum__ = kha_graphics4_TextureFormat;
kha_graphics4_TextureFormat.L8 = ["L8",1];
kha_graphics4_TextureFormat.L8.toString = $estr;
kha_graphics4_TextureFormat.L8.__enum__ = kha_graphics4_TextureFormat;
kha_graphics4_TextureFormat.RGBA128 = ["RGBA128",2];
kha_graphics4_TextureFormat.RGBA128.toString = $estr;
kha_graphics4_TextureFormat.RGBA128.__enum__ = kha_graphics4_TextureFormat;
kha_graphics4_TextureFormat.DEPTH16 = ["DEPTH16",3];
kha_graphics4_TextureFormat.DEPTH16.toString = $estr;
kha_graphics4_TextureFormat.DEPTH16.__enum__ = kha_graphics4_TextureFormat;
kha_graphics4_TextureFormat.RGBA64 = ["RGBA64",4];
kha_graphics4_TextureFormat.RGBA64.toString = $estr;
kha_graphics4_TextureFormat.RGBA64.__enum__ = kha_graphics4_TextureFormat;
kha_graphics4_TextureFormat.A32 = ["A32",5];
kha_graphics4_TextureFormat.A32.toString = $estr;
kha_graphics4_TextureFormat.A32.__enum__ = kha_graphics4_TextureFormat;
kha_graphics4_TextureFormat.A16 = ["A16",6];
kha_graphics4_TextureFormat.A16.toString = $estr;
kha_graphics4_TextureFormat.A16.__enum__ = kha_graphics4_TextureFormat;
var kha_graphics4_TextureUnit = function() { };
$hxClasses["kha.graphics4.TextureUnit"] = kha_graphics4_TextureUnit;
kha_graphics4_TextureUnit.__name__ = true;
var kha_graphics4_Usage = $hxClasses["kha.graphics4.Usage"] = { __ename__ : true, __constructs__ : ["StaticUsage","DynamicUsage","ReadableUsage"] };
kha_graphics4_Usage.StaticUsage = ["StaticUsage",0];
kha_graphics4_Usage.StaticUsage.toString = $estr;
kha_graphics4_Usage.StaticUsage.__enum__ = kha_graphics4_Usage;
kha_graphics4_Usage.DynamicUsage = ["DynamicUsage",1];
kha_graphics4_Usage.DynamicUsage.toString = $estr;
kha_graphics4_Usage.DynamicUsage.__enum__ = kha_graphics4_Usage;
kha_graphics4_Usage.ReadableUsage = ["ReadableUsage",2];
kha_graphics4_Usage.ReadableUsage.toString = $estr;
kha_graphics4_Usage.ReadableUsage.__enum__ = kha_graphics4_Usage;
var kha_graphics4_VertexBuffer = function(vertexCount,structure,usage,instanceDataStepRate,canRead) {
	if(canRead == null) {
		canRead = false;
	}
	if(instanceDataStepRate == null) {
		instanceDataStepRate = 0;
	}
	this.usage = usage;
	this.instanceDataStepRate = instanceDataStepRate;
	this.mySize = vertexCount;
	this.myStride = 0;
	var _g = 0;
	var _g1 = structure.elements;
	while(_g < _g1.length) {
		var element = _g1[_g];
		++_g;
		var _g2 = element.data;
		switch(_g2[1]) {
		case 0:
			this.myStride += 4;
			break;
		case 1:
			this.myStride += 8;
			break;
		case 2:
			this.myStride += 12;
			break;
		case 3:
			this.myStride += 16;
			break;
		case 4:
			this.myStride += 64;
			break;
		}
	}
	this.buffer = kha_SystemImpl.gl.createBuffer();
	var this1 = new Float32Array(vertexCount * this.myStride / 4 | 0);
	this._data = this1;
	this.sizes = [];
	this.offsets = [];
	this.sizes[structure.elements.length - 1] = 0;
	this.offsets[structure.elements.length - 1] = 0;
	var offset = 0;
	var index = 0;
	var _g3 = 0;
	var _g11 = structure.elements;
	while(_g3 < _g11.length) {
		var element1 = _g11[_g3];
		++_g3;
		var size;
		var _g21 = element1.data;
		switch(_g21[1]) {
		case 0:
			size = 1;
			break;
		case 1:
			size = 2;
			break;
		case 2:
			size = 3;
			break;
		case 3:
			size = 4;
			break;
		case 4:
			size = 16;
			break;
		}
		this.sizes[index] = size;
		this.offsets[index] = offset;
		var _g31 = element1.data;
		switch(_g31[1]) {
		case 0:
			offset += 4;
			break;
		case 1:
			offset += 8;
			break;
		case 2:
			offset += 12;
			break;
		case 3:
			offset += 16;
			break;
		case 4:
			offset += 64;
			break;
		}
		++index;
	}
};
$hxClasses["kha.graphics4.VertexBuffer"] = kha_graphics4_VertexBuffer;
kha_graphics4_VertexBuffer.__name__ = true;
kha_graphics4_VertexBuffer.prototype = {
	buffer: null
	,_data: null
	,mySize: null
	,myStride: null
	,sizes: null
	,offsets: null
	,usage: null
	,instanceDataStepRate: null
	,'delete': function() {
		this._data = null;
		kha_SystemImpl.gl.deleteBuffer(this.buffer);
	}
	,lock: function(start,count) {
		if(start == null) {
			start = 0;
		}
		if(count == null) {
			count = this.mySize;
		}
		return this._data.subarray(start * this.stride(),(start + count) * this.stride());
	}
	,unlock: function() {
		kha_SystemImpl.gl.bindBuffer(34962,this.buffer);
		kha_SystemImpl.gl.bufferData(34962,this._data,this.usage == kha_graphics4_Usage.DynamicUsage ? 35048 : 35044);
	}
	,stride: function() {
		return this.myStride;
	}
	,count: function() {
		return this.mySize;
	}
	,set: function(offset) {
		var ext = kha_SystemImpl.gl2 ? true : kha_SystemImpl.gl.getExtension("ANGLE_instanced_arrays");
		kha_SystemImpl.gl.bindBuffer(34962,this.buffer);
		var attributesOffset = 0;
		var _g1 = 0;
		var _g = this.sizes.length;
		while(_g1 < _g) {
			var i = _g1++;
			if(this.sizes[i] > 4) {
				var size = this.sizes[i];
				var addonOffset = 0;
				while(size > 0) {
					kha_SystemImpl.gl.enableVertexAttribArray(offset + attributesOffset);
					kha_SystemImpl.gl.vertexAttribPointer(offset + attributesOffset,4,5126,false,this.myStride,this.offsets[i] + addonOffset);
					if(ext) {
						if(kha_SystemImpl.gl2) {
							kha_SystemImpl.gl.vertexAttribDivisor(offset + attributesOffset,this.instanceDataStepRate);
						} else {
							ext.vertexAttribDivisorANGLE(offset + attributesOffset,this.instanceDataStepRate);
						}
					}
					size -= 4;
					addonOffset += 16;
					++attributesOffset;
				}
			} else {
				kha_SystemImpl.gl.enableVertexAttribArray(offset + attributesOffset);
				kha_SystemImpl.gl.vertexAttribPointer(offset + attributesOffset,this.sizes[i],5126,false,this.myStride,this.offsets[i]);
				if(ext) {
					if(kha_SystemImpl.gl2) {
						kha_SystemImpl.gl.vertexAttribDivisor(offset + attributesOffset,this.instanceDataStepRate);
					} else {
						ext.vertexAttribDivisorANGLE(offset + attributesOffset,this.instanceDataStepRate);
					}
				}
				++attributesOffset;
			}
		}
		return attributesOffset;
	}
	,__class__: kha_graphics4_VertexBuffer
};
var kha_graphics4_VertexData = $hxClasses["kha.graphics4.VertexData"] = { __ename__ : true, __constructs__ : ["Float1","Float2","Float3","Float4","Float4x4"] };
kha_graphics4_VertexData.Float1 = ["Float1",0];
kha_graphics4_VertexData.Float1.toString = $estr;
kha_graphics4_VertexData.Float1.__enum__ = kha_graphics4_VertexData;
kha_graphics4_VertexData.Float2 = ["Float2",1];
kha_graphics4_VertexData.Float2.toString = $estr;
kha_graphics4_VertexData.Float2.__enum__ = kha_graphics4_VertexData;
kha_graphics4_VertexData.Float3 = ["Float3",2];
kha_graphics4_VertexData.Float3.toString = $estr;
kha_graphics4_VertexData.Float3.__enum__ = kha_graphics4_VertexData;
kha_graphics4_VertexData.Float4 = ["Float4",3];
kha_graphics4_VertexData.Float4.toString = $estr;
kha_graphics4_VertexData.Float4.__enum__ = kha_graphics4_VertexData;
kha_graphics4_VertexData.Float4x4 = ["Float4x4",4];
kha_graphics4_VertexData.Float4x4.toString = $estr;
kha_graphics4_VertexData.Float4x4.__enum__ = kha_graphics4_VertexData;
var kha_graphics4_VertexElement = function(name,data) {
	this.name = name;
	this.data = data;
};
$hxClasses["kha.graphics4.VertexElement"] = kha_graphics4_VertexElement;
kha_graphics4_VertexElement.__name__ = true;
kha_graphics4_VertexElement.prototype = {
	name: null
	,data: null
	,__class__: kha_graphics4_VertexElement
};
var kha_graphics4_VertexShader = function(sources,files) {
	this.sources = [];
	var _g = 0;
	while(_g < sources.length) {
		var source = sources[_g];
		++_g;
		this.sources.push(source.toString());
	}
	this.type = 35633;
	this.shader = null;
	this.files = files;
};
$hxClasses["kha.graphics4.VertexShader"] = kha_graphics4_VertexShader;
kha_graphics4_VertexShader.__name__ = true;
kha_graphics4_VertexShader.fromSource = function(source) {
	var shader = new kha_graphics4_VertexShader([],["runtime-string"]);
	shader.sources.push(source);
	return shader;
};
kha_graphics4_VertexShader.prototype = {
	sources: null
	,type: null
	,shader: null
	,files: null
	,'delete': function() {
		kha_SystemImpl.gl.deleteShader(this.shader);
		this.shader = null;
		this.sources = null;
	}
	,__class__: kha_graphics4_VertexShader
};
var kha_graphics4_VertexStructure = function() {
	this.elements = [];
	this.instanced = false;
};
$hxClasses["kha.graphics4.VertexStructure"] = kha_graphics4_VertexStructure;
kha_graphics4_VertexStructure.__name__ = true;
kha_graphics4_VertexStructure.prototype = {
	elements: null
	,instanced: null
	,add: function(name,data) {
		this.elements.push(new kha_graphics4_VertexElement(name,data));
	}
	,size: function() {
		return this.elements.length;
	}
	,byteSize: function() {
		var byteSize = 0;
		var _g1 = 0;
		var _g = this.elements.length;
		while(_g1 < _g) {
			var i = _g1++;
			byteSize += this.dataByteSize(this.elements[i].data);
		}
		return byteSize;
	}
	,dataByteSize: function(data) {
		switch(data[1]) {
		case 0:
			return 4;
		case 1:
			return 8;
		case 2:
			return 12;
		case 3:
			return 16;
		case 4:
			return 64;
		}
	}
	,get: function(index) {
		return this.elements[index];
	}
	,__class__: kha_graphics4_VertexStructure
};
var kha_input_Gamepad = $hx_exports["kha"]["input"]["Gamepad"] = function(index,id) {
	if(id == null) {
		id = "unknown";
	}
	if(index == null) {
		index = 0;
	}
	this.index = index;
	this.axisListeners = [];
	this.buttonListeners = [];
	kha_input_Gamepad.instances[index] = this;
};
$hxClasses["kha.input.Gamepad"] = kha_input_Gamepad;
kha_input_Gamepad.__name__ = true;
kha_input_Gamepad.get = function(index) {
	if(index == null) {
		index = 0;
	}
	if(index >= kha_input_Gamepad.instances.length) {
		return null;
	}
	return kha_input_Gamepad.instances[index];
};
kha_input_Gamepad.notifyOnConnect = function(connectListener,disconnectListener) {
	if(connectListener != null) {
		kha_input_Gamepad.connectListeners.push(connectListener);
	}
	if(disconnectListener != null) {
		kha_input_Gamepad.disconnectListeners.push(disconnectListener);
	}
};
kha_input_Gamepad.removeConnect = function(connectListener,disconnectListener) {
	if(connectListener != null) {
		HxOverrides.remove(kha_input_Gamepad.connectListeners,connectListener);
	}
	if(disconnectListener != null) {
		HxOverrides.remove(kha_input_Gamepad.disconnectListeners,disconnectListener);
	}
};
kha_input_Gamepad.sendConnectEvent = function(index) {
	kha_input_Gamepad.instances[index].connected = true;
	var _g = 0;
	var _g1 = kha_input_Gamepad.connectListeners;
	while(_g < _g1.length) {
		var listener = _g1[_g];
		++_g;
		listener(index);
	}
};
kha_input_Gamepad.sendDisconnectEvent = function(index) {
	kha_input_Gamepad.instances[index].connected = false;
	var _g = 0;
	var _g1 = kha_input_Gamepad.disconnectListeners;
	while(_g < _g1.length) {
		var listener = _g1[_g];
		++_g;
		listener(index);
	}
};
kha_input_Gamepad.prototype = {
	index: null
	,notify: function(axisListener,buttonListener) {
		if(axisListener != null) {
			this.axisListeners.push(axisListener);
		}
		if(buttonListener != null) {
			this.buttonListeners.push(buttonListener);
		}
	}
	,remove: function(axisListener,buttonListener) {
		if(axisListener != null) {
			HxOverrides.remove(this.axisListeners,axisListener);
		}
		if(buttonListener != null) {
			HxOverrides.remove(this.buttonListeners,buttonListener);
		}
	}
	,axisListeners: null
	,buttonListeners: null
	,id: null
	,connected: null
	,get_id: function() {
		return kha_SystemImpl.getGamepadId(this.index);
	}
	,sendAxisEvent: function(axis,value) {
		var _g = 0;
		var _g1 = this.axisListeners;
		while(_g < _g1.length) {
			var listener = _g1[_g];
			++_g;
			listener(axis,value);
		}
	}
	,sendButtonEvent: function(button,value) {
		var _g = 0;
		var _g1 = this.buttonListeners;
		while(_g < _g1.length) {
			var listener = _g1[_g];
			++_g;
			listener(button,value);
		}
	}
	,__class__: kha_input_Gamepad
};
var kha_network_Controller = function() {
	this.__id = kha_network_ControllerBuilder.nextId++;
	this._inputBuffer = new haxe_io_Bytes(new ArrayBuffer(1));
};
$hxClasses["kha.network.Controller"] = kha_network_Controller;
kha_network_Controller.__name__ = true;
kha_network_Controller.prototype = {
	__id: null
	,_inputBufferIndex: null
	,_inputBuffer: null
	,_id: function() {
		return this.__id;
	}
	,_receive: function(bytes) {
	}
	,__class__: kha_network_Controller
};
var kha_input_Keyboard = $hx_exports["kha"]["input"]["Keyboard"] = function() {
	kha_network_Controller.call(this);
	this.downListeners = [];
	this.upListeners = [];
	this.pressListeners = [];
	kha_input_Keyboard.instance = this;
};
$hxClasses["kha.input.Keyboard"] = kha_input_Keyboard;
kha_input_Keyboard.__name__ = true;
kha_input_Keyboard.get = function(num) {
	if(num == null) {
		num = 0;
	}
	return kha_SystemImpl.getKeyboard(num);
};
kha_input_Keyboard.__super__ = kha_network_Controller;
kha_input_Keyboard.prototype = $extend(kha_network_Controller.prototype,{
	notify: function(downListener,upListener,pressListener) {
		if(downListener != null) {
			this.downListeners.push(downListener);
		}
		if(upListener != null) {
			this.upListeners.push(upListener);
		}
		if(pressListener != null) {
			this.pressListeners.push(pressListener);
		}
	}
	,remove: function(downListener,upListener,pressListener) {
		if(downListener != null) {
			HxOverrides.remove(this.downListeners,downListener);
		}
		if(upListener != null) {
			HxOverrides.remove(this.upListeners,upListener);
		}
		if(pressListener != null) {
			HxOverrides.remove(this.pressListeners,pressListener);
		}
	}
	,show: function() {
	}
	,hide: function() {
	}
	,downListeners: null
	,upListeners: null
	,pressListeners: null
	,sendDownEvent: function(code) {
		if(kha_network_Session.the() != null) {
			var bytes = new haxe_io_Bytes(new ArrayBuffer(4));
			bytes.setInt32(0,0);
			kha_network_Session.the().sendControllerUpdate(this._id(),bytes);
		}
		var _g = 0;
		var _g1 = this.downListeners;
		while(_g < _g1.length) {
			var listener = _g1[_g];
			++_g;
			listener(code);
		}
	}
	,sendUpEvent: function(code) {
		if(kha_network_Session.the() != null) {
			var bytes = new haxe_io_Bytes(new ArrayBuffer(4));
			bytes.setInt32(0,1);
			kha_network_Session.the().sendControllerUpdate(this._id(),bytes);
		}
		var _g = 0;
		var _g1 = this.upListeners;
		while(_g < _g1.length) {
			var listener = _g1[_g];
			++_g;
			listener(code);
		}
	}
	,sendPressEvent: function($char) {
		if(kha_network_Session.the() != null) {
			var bytes = new haxe_io_Bytes(new ArrayBuffer(5));
			bytes.setInt32(0,2);
			var v = HxOverrides.cca($char,0);
			bytes.b[4] = v & 255;
			kha_network_Session.the().sendControllerUpdate(this._id(),bytes);
		}
		var _g = 0;
		var _g1 = this.pressListeners;
		while(_g < _g1.length) {
			var listener = _g1[_g];
			++_g;
			listener($char);
		}
	}
	,_receive: function(bytes) {
		var funcindex = bytes.getInt32(0);
		if(funcindex == 0) {
			var input0 = bytes.b[4];
			this.sendDownEvent(input0);
			return;
		}
		if(funcindex == 1) {
			var input01 = bytes.b[4];
			this.sendUpEvent(input01);
			return;
		}
		if(funcindex == 2) {
			var input02 = String.fromCharCode(bytes.b[4]);
			this.sendPressEvent(input02);
			return;
		}
	}
	,__class__: kha_input_Keyboard
});
var kha_input_Mouse = $hx_exports["kha"]["input"]["Mouse"] = function() {
	kha_network_Controller.call(this);
	kha_input_Mouse.instance = this;
};
$hxClasses["kha.input.Mouse"] = kha_input_Mouse;
kha_input_Mouse.__name__ = true;
kha_input_Mouse.get = function(num) {
	if(num == null) {
		num = 0;
	}
	return kha_SystemImpl.getMouse(num);
};
kha_input_Mouse.__super__ = kha_network_Controller;
kha_input_Mouse.prototype = $extend(kha_network_Controller.prototype,{
	notify: function(downListener,upListener,moveListener,wheelListener,leaveListener) {
		this.notifyWindowed(0,downListener,upListener,moveListener,wheelListener,leaveListener);
	}
	,remove: function(downListener,upListener,moveListener,wheelListener,leaveListener) {
		this.removeWindowed(0,downListener,upListener,moveListener,wheelListener,leaveListener);
	}
	,notifyWindowed: function(windowId,downListener,upListener,moveListener,wheelListener,leaveListener) {
		if(downListener != null) {
			if(this.windowDownListeners == null) {
				this.windowDownListeners = [];
			}
			while(this.windowDownListeners.length <= windowId) this.windowDownListeners.push([]);
			this.windowDownListeners[windowId].push(downListener);
		}
		if(upListener != null) {
			if(this.windowUpListeners == null) {
				this.windowUpListeners = [];
			}
			while(this.windowUpListeners.length <= windowId) this.windowUpListeners.push([]);
			this.windowUpListeners[windowId].push(upListener);
		}
		if(moveListener != null) {
			if(this.windowMoveListeners == null) {
				this.windowMoveListeners = [];
			}
			while(this.windowMoveListeners.length <= windowId) this.windowMoveListeners.push([]);
			this.windowMoveListeners[windowId].push(moveListener);
		}
		if(wheelListener != null) {
			if(this.windowWheelListeners == null) {
				this.windowWheelListeners = [];
			}
			while(this.windowWheelListeners.length <= windowId) this.windowWheelListeners.push([]);
			this.windowWheelListeners[windowId].push(wheelListener);
		}
		if(leaveListener != null) {
			if(this.windowLeaveListeners == null) {
				this.windowLeaveListeners = [];
			}
			while(this.windowLeaveListeners.length <= windowId) this.windowLeaveListeners.push([]);
			this.windowLeaveListeners[windowId].push(leaveListener);
		}
	}
	,removeWindowed: function(windowId,downListener,upListener,moveListener,wheelListener,leaveListener) {
		if(downListener != null) {
			if(this.windowDownListeners != null) {
				if(windowId < this.windowDownListeners.length) {
					HxOverrides.remove(this.windowDownListeners[windowId],downListener);
				} else {
					haxe_Log.trace("no downListeners for window \"" + windowId + "\" are registered",{ fileName : "Mouse.hx", lineNumber : 88, className : "kha.input.Mouse", methodName : "removeWindowed"});
				}
			} else {
				haxe_Log.trace("no downListeners were ever registered",{ fileName : "Mouse.hx", lineNumber : 91, className : "kha.input.Mouse", methodName : "removeWindowed"});
			}
		}
		if(upListener != null) {
			if(this.windowUpListeners != null) {
				if(windowId < this.windowUpListeners.length) {
					HxOverrides.remove(this.windowUpListeners[windowId],upListener);
				} else {
					haxe_Log.trace("no upListeners for window \"" + windowId + "\" are registered",{ fileName : "Mouse.hx", lineNumber : 100, className : "kha.input.Mouse", methodName : "removeWindowed"});
				}
			} else {
				haxe_Log.trace("no upListeners were ever registered",{ fileName : "Mouse.hx", lineNumber : 103, className : "kha.input.Mouse", methodName : "removeWindowed"});
			}
		}
		if(moveListener != null) {
			if(this.windowMoveListeners != null) {
				if(windowId < this.windowMoveListeners.length) {
					HxOverrides.remove(this.windowMoveListeners[windowId],moveListener);
				} else {
					haxe_Log.trace("no moveListeners for window \"" + windowId + "\" are registered",{ fileName : "Mouse.hx", lineNumber : 112, className : "kha.input.Mouse", methodName : "removeWindowed"});
				}
			} else {
				haxe_Log.trace("no moveListeners were ever registered",{ fileName : "Mouse.hx", lineNumber : 115, className : "kha.input.Mouse", methodName : "removeWindowed"});
			}
		}
		if(wheelListener != null) {
			if(this.windowWheelListeners != null) {
				if(windowId < this.windowWheelListeners.length) {
					HxOverrides.remove(this.windowWheelListeners[windowId],wheelListener);
				} else {
					haxe_Log.trace("no wheelListeners for window \"" + windowId + "\" are registered",{ fileName : "Mouse.hx", lineNumber : 124, className : "kha.input.Mouse", methodName : "removeWindowed"});
				}
			} else {
				haxe_Log.trace("no wheelListeners were ever registered",{ fileName : "Mouse.hx", lineNumber : 127, className : "kha.input.Mouse", methodName : "removeWindowed"});
			}
		}
		if(leaveListener != null) {
			if(this.windowLeaveListeners != null) {
				if(windowId < this.windowLeaveListeners.length) {
					HxOverrides.remove(this.windowLeaveListeners[windowId],leaveListener);
				} else {
					haxe_Log.trace("no leaveListeners for window \"" + windowId + "\" are registered",{ fileName : "Mouse.hx", lineNumber : 136, className : "kha.input.Mouse", methodName : "removeWindowed"});
				}
			} else {
				haxe_Log.trace("no leaveListeners were ever registered",{ fileName : "Mouse.hx", lineNumber : 139, className : "kha.input.Mouse", methodName : "removeWindowed"});
			}
		}
	}
	,lock: function() {
	}
	,unlock: function() {
	}
	,canLock: function() {
		return false;
	}
	,isLocked: function() {
		return false;
	}
	,notifyOnLockChange: function(func,error) {
	}
	,removeFromLockChange: function(func,error) {
	}
	,hideSystemCursor: function() {
	}
	,showSystemCursor: function() {
	}
	,windowDownListeners: null
	,windowUpListeners: null
	,windowMoveListeners: null
	,windowWheelListeners: null
	,windowLeaveListeners: null
	,sendLeaveEvent: function(windowId) {
		if(kha_network_Session.the() != null) {
			var bytes = new haxe_io_Bytes(new ArrayBuffer(8));
			bytes.setInt32(0,0);
			bytes.setInt32(4,windowId);
			kha_network_Session.the().sendControllerUpdate(this._id(),bytes);
		}
		if(this.windowLeaveListeners != null) {
			var _g = 0;
			var _g1 = this.windowLeaveListeners[windowId];
			while(_g < _g1.length) {
				var listener = _g1[_g];
				++_g;
				listener();
			}
		}
	}
	,sendDownEvent: function(windowId,button,x,y) {
		if(kha_network_Session.the() != null) {
			var bytes = new haxe_io_Bytes(new ArrayBuffer(20));
			bytes.setInt32(0,1);
			bytes.setInt32(4,windowId);
			bytes.setInt32(8,button);
			bytes.setInt32(12,x);
			bytes.setInt32(16,y);
			kha_network_Session.the().sendControllerUpdate(this._id(),bytes);
		}
		if(this.windowDownListeners != null) {
			var _g = 0;
			var _g1 = this.windowDownListeners[windowId];
			while(_g < _g1.length) {
				var listener = _g1[_g];
				++_g;
				listener(button,x,y);
			}
		}
	}
	,sendUpEvent: function(windowId,button,x,y) {
		if(kha_network_Session.the() != null) {
			var bytes = new haxe_io_Bytes(new ArrayBuffer(20));
			bytes.setInt32(0,2);
			bytes.setInt32(4,windowId);
			bytes.setInt32(8,button);
			bytes.setInt32(12,x);
			bytes.setInt32(16,y);
			kha_network_Session.the().sendControllerUpdate(this._id(),bytes);
		}
		if(this.windowUpListeners != null) {
			var _g = 0;
			var _g1 = this.windowUpListeners[windowId];
			while(_g < _g1.length) {
				var listener = _g1[_g];
				++_g;
				listener(button,x,y);
			}
		}
	}
	,sendMoveEvent: function(windowId,x,y,movementX,movementY) {
		if(kha_network_Session.the() != null) {
			var bytes = new haxe_io_Bytes(new ArrayBuffer(24));
			bytes.setInt32(0,3);
			bytes.setInt32(4,windowId);
			bytes.setInt32(8,x);
			bytes.setInt32(12,y);
			bytes.setInt32(16,movementX);
			bytes.setInt32(20,movementY);
			kha_network_Session.the().sendControllerUpdate(this._id(),bytes);
		}
		if(this.windowMoveListeners != null) {
			var _g = 0;
			var _g1 = this.windowMoveListeners[windowId];
			while(_g < _g1.length) {
				var listener = _g1[_g];
				++_g;
				listener(x,y,movementX,movementY);
			}
		}
	}
	,sendWheelEvent: function(windowId,delta) {
		if(kha_network_Session.the() != null) {
			var bytes = new haxe_io_Bytes(new ArrayBuffer(12));
			bytes.setInt32(0,4);
			bytes.setInt32(4,windowId);
			bytes.setInt32(8,delta);
			kha_network_Session.the().sendControllerUpdate(this._id(),bytes);
		}
		if(this.windowWheelListeners != null) {
			var _g = 0;
			var _g1 = this.windowWheelListeners[windowId];
			while(_g < _g1.length) {
				var listener = _g1[_g];
				++_g;
				listener(delta);
			}
		}
	}
	,_receive: function(bytes) {
		var funcindex = bytes.getInt32(0);
		if(funcindex == 0) {
			var input0 = bytes.getInt32(4);
			this.sendLeaveEvent(input0);
			return;
		}
		if(funcindex == 1) {
			var input01 = bytes.getInt32(4);
			var input1 = bytes.getInt32(8);
			var input2 = bytes.getInt32(12);
			var input3 = bytes.getInt32(16);
			this.sendDownEvent(input01,input1,input2,input3);
			return;
		}
		if(funcindex == 2) {
			var input02 = bytes.getInt32(4);
			var input11 = bytes.getInt32(8);
			var input21 = bytes.getInt32(12);
			var input31 = bytes.getInt32(16);
			this.sendUpEvent(input02,input11,input21,input31);
			return;
		}
		if(funcindex == 3) {
			var input03 = bytes.getInt32(4);
			var input12 = bytes.getInt32(8);
			var input22 = bytes.getInt32(12);
			var input32 = bytes.getInt32(16);
			var input4 = bytes.getInt32(20);
			this.sendMoveEvent(input03,input12,input22,input32,input4);
			return;
		}
		if(funcindex == 4) {
			var input04 = bytes.getInt32(4);
			var input13 = bytes.getInt32(8);
			this.sendWheelEvent(input04,input13);
			return;
		}
	}
	,__class__: kha_input_Mouse
});
var kha_input_MouseImpl = function() {
	kha_input_Mouse.call(this);
};
$hxClasses["kha.input.MouseImpl"] = kha_input_MouseImpl;
kha_input_MouseImpl.__name__ = true;
kha_input_MouseImpl.__super__ = kha_input_Mouse;
kha_input_MouseImpl.prototype = $extend(kha_input_Mouse.prototype,{
	lock: function() {
		kha_SystemImpl.lockMouse();
	}
	,unlock: function() {
		kha_SystemImpl.unlockMouse();
	}
	,canLock: function() {
		return kha_SystemImpl.canLockMouse();
	}
	,isLocked: function() {
		return kha_SystemImpl.isMouseLocked();
	}
	,notifyOnLockChange: function(func,error) {
		kha_SystemImpl.notifyOfMouseLockChange(func,error);
	}
	,removeFromLockChange: function(func,error) {
		kha_SystemImpl.removeFromMouseLockChange(func,error);
	}
	,hideSystemCursor: function() {
		kha_SystemImpl.khanvas.style.cursor = "none";
	}
	,showSystemCursor: function() {
		kha_SystemImpl.khanvas.style.cursor = "default";
	}
	,_receive: function(bytes) {
		var funcindex = bytes.getInt32(0);
	}
	,__class__: kha_input_MouseImpl
});
var kha_input_Surface = $hx_exports["kha"]["input"]["Surface"] = function() {
	this.touchStartListeners = [];
	this.touchEndListeners = [];
	this.moveListeners = [];
	kha_input_Surface.instance = this;
};
$hxClasses["kha.input.Surface"] = kha_input_Surface;
kha_input_Surface.__name__ = true;
kha_input_Surface.get = function(num) {
	if(num == null) {
		num = 0;
	}
	if(num != 0) {
		return null;
	}
	return kha_input_Surface.instance;
};
kha_input_Surface.prototype = {
	notify: function(touchStartListener,touchEndListener,moveListener) {
		if(touchStartListener != null) {
			this.touchStartListeners.push(touchStartListener);
		}
		if(touchEndListener != null) {
			this.touchEndListeners.push(touchEndListener);
		}
		if(moveListener != null) {
			this.moveListeners.push(moveListener);
		}
	}
	,remove: function(touchStartListener,touchEndListener,moveListener) {
		if(touchStartListener != null) {
			HxOverrides.remove(this.touchStartListeners,touchStartListener);
		}
		if(touchEndListener != null) {
			HxOverrides.remove(this.touchEndListeners,touchEndListener);
		}
		if(moveListener != null) {
			this.moveListeners.push(moveListener);
		}
	}
	,touchStartListeners: null
	,touchEndListeners: null
	,moveListeners: null
	,sendTouchStartEvent: function(index,x,y) {
		var _g = 0;
		var _g1 = this.touchStartListeners;
		while(_g < _g1.length) {
			var listener = _g1[_g];
			++_g;
			listener(index,x,y);
		}
	}
	,sendTouchEndEvent: function(index,x,y) {
		var _g = 0;
		var _g1 = this.touchEndListeners;
		while(_g < _g1.length) {
			var listener = _g1[_g];
			++_g;
			listener(index,x,y);
		}
	}
	,sendMoveEvent: function(index,x,y) {
		var _g = 0;
		var _g1 = this.moveListeners;
		while(_g < _g1.length) {
			var listener = _g1[_g];
			++_g;
			listener(index,x,y);
		}
	}
	,__class__: kha_input_Surface
};
var kha_internal_BytesBlob = function(bytes) {
	this.bytes = bytes;
};
$hxClasses["kha.internal.BytesBlob"] = kha_internal_BytesBlob;
kha_internal_BytesBlob.__name__ = true;
kha_internal_BytesBlob.__interfaces__ = [kha_Resource];
kha_internal_BytesBlob.fromBytes = function(bytes) {
	return new kha_internal_BytesBlob(bytes);
};
kha_internal_BytesBlob.alloc = function(size) {
	return new kha_internal_BytesBlob(new haxe_io_Bytes(new ArrayBuffer(size)));
};
kha_internal_BytesBlob.readF32 = function(i) {
	var sign = (i & -2147483648) == 0 ? 1 : -1;
	var exp = i >> 23 & 255;
	var man = i & 8388607;
	switch(exp) {
	case 0:
		return 0.0;
	case 255:
		if(man != 0) {
			return NaN;
		} else if(sign > 0) {
			return Infinity;
		} else {
			return -Infinity;
		}
		break;
	default:
		return sign * ((man + 8388608) / 8388608.0) * Math.pow(2,exp - 127);
	}
};
kha_internal_BytesBlob.bit = function(value,position) {
	var b = (value >>> position & 1) == 1;
	if(b) {
		var a = 3;
		++a;
		return true;
	} else {
		var c = 4;
		--c;
		return false;
	}
};
kha_internal_BytesBlob.toText = function(chars,length) {
	var value = "";
	var _g1 = 0;
	var _g = length;
	while(_g1 < _g) {
		var i = _g1++;
		value += String.fromCharCode(chars[i]);
	}
	return value;
};
kha_internal_BytesBlob.prototype = {
	bytes: null
	,sub: function(start,length) {
		return new kha_internal_BytesBlob(this.bytes.sub(start,length));
	}
	,length: null
	,get_length: function() {
		return this.bytes.length;
	}
	,writeU8: function(position,value) {
		this.bytes.b[position] = value & 255;
	}
	,readU8: function(position) {
		var $byte = this.bytes.b[position];
		++position;
		return $byte;
	}
	,readS8: function(position) {
		var $byte = this.bytes.b[position];
		++position;
		var sign = ($byte & 128) == 0 ? 1 : -1;
		$byte &= 127;
		return sign * $byte;
	}
	,readU16BE: function(position) {
		var first = this.bytes.b[position];
		var second = this.bytes.b[position + 1];
		position += 2;
		return first * 256 + second;
	}
	,readU16LE: function(position) {
		var first = this.bytes.b[position];
		var second = this.bytes.b[position + 1];
		position += 2;
		return second * 256 + first;
	}
	,readU32LE: function(position) {
		var fourth = this.bytes.b[position];
		var third = this.bytes.b[position + 1];
		var second = this.bytes.b[position + 2];
		var first = this.bytes.b[position + 3];
		position += 4;
		return fourth + third * 256 + second * 256 * 256 + first * 256 * 256 * 256;
	}
	,readU32BE: function(position) {
		var fourth = this.bytes.b[position];
		var third = this.bytes.b[position + 1];
		var second = this.bytes.b[position + 2];
		var first = this.bytes.b[position + 3];
		position += 4;
		return first + second * 256 + third * 256 * 256 + fourth * 256 * 256 * 256;
	}
	,readS16BE: function(position) {
		var first = this.bytes.b[position];
		var second = this.bytes.b[position + 1];
		position += 2;
		var sign = (first & 128) == 0 ? 1 : -1;
		first &= 127;
		if(sign == -1) {
			return -32767 + first * 256 + second;
		} else {
			return first * 256 + second;
		}
	}
	,readS16LE: function(position) {
		var first = this.bytes.b[position];
		var second = this.bytes.b[position + 1];
		var sign = (second & 128) == 0 ? 1 : -1;
		second &= 127;
		position += 2;
		if(sign == -1) {
			return -32767 + second * 256 + first;
		} else {
			return second * 256 + first;
		}
	}
	,readS32LE: function(position) {
		var fourth = this.bytes.b[position];
		var third = this.bytes.b[position + 1];
		var second = this.bytes.b[position + 2];
		var first = this.bytes.b[position + 3];
		var sign = (first & 128) == 0 ? 1 : -1;
		first &= 127;
		position += 4;
		if(sign == -1) {
			return -2147483647 + fourth + third * 256 + second * 256 * 256 + first * 256 * 256 * 256;
		} else {
			return fourth + third * 256 + second * 256 * 256 + first * 256 * 256 * 256;
		}
	}
	,readS32BE: function(position) {
		var fourth = this.bytes.b[position];
		var third = this.bytes.b[position + 1];
		var second = this.bytes.b[position + 2];
		var first = this.bytes.b[position + 3];
		var sign = (fourth & 128) == 0 ? 1 : -1;
		fourth &= 127;
		position += 4;
		if(sign == -1) {
			return -2147483647 + first + second * 256 + third * 256 * 256 + fourth * 256 * 256 * 256;
		}
		return first + second * 256 + third * 256 * 256 + fourth * 256 * 256 * 256;
	}
	,readF32LE: function(position) {
		return kha_internal_BytesBlob.readF32(this.readS32LE(position));
	}
	,readF32BE: function(position) {
		return kha_internal_BytesBlob.readF32(this.readS32BE(position));
	}
	,toString: function() {
		return this.bytes.toString();
	}
	,readUtf8Char: function(position) {
		if(position.value >= this.get_length()) {
			return -1;
		}
		var c = this.readU8(position.value);
		++position.value;
		var value = 0;
		if(!kha_internal_BytesBlob.bit(c,7)) {
			value = c;
		} else if(kha_internal_BytesBlob.bit(c,7) && kha_internal_BytesBlob.bit(c,6) && !kha_internal_BytesBlob.bit(c,5)) {
			var a = c & 31;
			var c2 = this.readU8(position.value);
			++position.value;
			var b = c2 & 63;
			value = a << 6 | b;
		} else if(kha_internal_BytesBlob.bit(c,7) && kha_internal_BytesBlob.bit(c,6) && kha_internal_BytesBlob.bit(c,5) && !kha_internal_BytesBlob.bit(c,4)) {
			position.value += 2;
		} else if(kha_internal_BytesBlob.bit(c,7) && kha_internal_BytesBlob.bit(c,6) && kha_internal_BytesBlob.bit(c,5) && kha_internal_BytesBlob.bit(c,4) && !kha_internal_BytesBlob.bit(c,3)) {
			position.value += 3;
		}
		return value;
	}
	,readUtf8Block: function(buffer,position) {
		var bufferindex = 0;
		if(position.value >= this.get_length()) {
			return "";
		}
		while(bufferindex < 2000) {
			var c = this.readUtf8Char(position);
			if(c < 0) {
				break;
			}
			buffer[bufferindex] = c;
			++bufferindex;
		}
		return kha_internal_BytesBlob.toText(buffer,bufferindex);
	}
	,readUtf8String: function() {
		var this1 = new Array(2000);
		var buffer = this1;
		var text = "";
		var start = 0;
		if(this.get_length() >= 3 && this.bytes.b[0] == 239 && this.bytes.b[1] == 187 && this.bytes.b[2] == 191) {
			start = 3;
		}
		var position = { value : start};
		while(position.value < this.get_length()) text += this.readUtf8Block(buffer,position);
		return text;
	}
	,toBytes: function() {
		return this.bytes;
	}
	,unload: function() {
		this.bytes = null;
	}
	,__class__: kha_internal_BytesBlob
};
var kha_internal_HdrFormat = function() {
};
$hxClasses["kha.internal.HdrFormat"] = kha_internal_HdrFormat;
kha_internal_HdrFormat.__name__ = true;
kha_internal_HdrFormat.readBuf = function(buf) {
	var bytesRead = 0;
	while(true) {
		buf[bytesRead++] = kha_internal_HdrFormat.buffer[kha_internal_HdrFormat.fileOffset] & 255;
		if(!(++kha_internal_HdrFormat.fileOffset < kha_internal_HdrFormat.bufferLength && bytesRead < buf.length)) {
			break;
		}
	}
	return bytesRead;
};
kha_internal_HdrFormat.readBufOffset = function(buf,offset,length) {
	var bytesRead = 0;
	while(true) {
		buf[offset + bytesRead++] = kha_internal_HdrFormat.buffer[kha_internal_HdrFormat.fileOffset] & 255;
		if(!(++kha_internal_HdrFormat.fileOffset < kha_internal_HdrFormat.bufferLength && bytesRead < length)) {
			break;
		}
	}
	return bytesRead;
};
kha_internal_HdrFormat.readPixelsRaw = function(buffer,data,offset,numpixels) {
	var numExpected = 4 * numpixels;
	var numRead = kha_internal_HdrFormat.readBufOffset(data,offset,numExpected);
	if(numRead < numExpected) {
		haxe_Log.trace("Error reading raw pixels: got " + numRead + " bytes, expected " + numExpected,{ fileName : "HdrFormat.hx", lineNumber : 43, className : "kha.internal.HdrFormat", methodName : "readPixelsRaw"});
		return;
	}
};
kha_internal_HdrFormat.readPixelsRawRLE = function(buffer,data,offset,scanline_width,num_scanlines) {
	var this1 = new Uint8Array(4);
	var rgbe = this1;
	var scanline_buffer = null;
	var ptr;
	var ptr_end;
	var count;
	var this2 = new Uint8Array(2);
	var buf = this2;
	var bufferLength = buffer.length;
	while(num_scanlines > 0) {
		if(kha_internal_HdrFormat.readBuf(rgbe) < rgbe.length) {
			haxe_Log.trace("Error reading bytes: expected " + rgbe.length,{ fileName : "HdrFormat.hx", lineNumber : 59, className : "kha.internal.HdrFormat", methodName : "readPixelsRawRLE"});
			return;
		}
		if(rgbe[0] != 2 || rgbe[1] != 2 || (rgbe[2] & 128) != 0) {
			data[offset++] = rgbe[0] & 255;
			data[offset++] = rgbe[1] & 255;
			data[offset++] = rgbe[2] & 255;
			data[offset++] = rgbe[3] & 255;
			kha_internal_HdrFormat.readPixelsRaw(buffer,data,offset,scanline_width * num_scanlines - 1);
			return;
		}
		if(((rgbe[2] & 255) << 8 | rgbe[3] & 255) != scanline_width) {
			haxe_Log.trace("Wrong scanline width " + ((rgbe[2] & 255) << 8 | rgbe[3] & 255) + ", expected " + scanline_width,{ fileName : "HdrFormat.hx", lineNumber : 74, className : "kha.internal.HdrFormat", methodName : "readPixelsRawRLE"});
			return;
		}
		if(scanline_buffer == null) {
			var this3 = new Uint8Array(4 * scanline_width);
			scanline_buffer = this3;
		}
		ptr = 0;
		var _g = 0;
		while(_g < 4) {
			var i = _g++;
			ptr_end = (i + 1) * scanline_width;
			while(ptr < ptr_end) {
				if(kha_internal_HdrFormat.readBuf(buf) < buf.length) {
					haxe_Log.trace("Error reading 2-byte buffer",{ fileName : "HdrFormat.hx", lineNumber : 88, className : "kha.internal.HdrFormat", methodName : "readPixelsRawRLE"});
					return;
				}
				if((buf[0] & 255) > 128) {
					count = (buf[0] & 255) - 128;
					if(count == 0 || count > ptr_end - ptr) {
						haxe_Log.trace("Bad scanline data",{ fileName : "HdrFormat.hx", lineNumber : 95, className : "kha.internal.HdrFormat", methodName : "readPixelsRawRLE"});
						return;
					}
					while(count-- > 0) scanline_buffer[ptr++] = buf[1] & 255;
				} else {
					count = buf[0] & 255;
					if(count == 0 || count > ptr_end - ptr) {
						haxe_Log.trace("Bad scanline data",{ fileName : "HdrFormat.hx", lineNumber : 106, className : "kha.internal.HdrFormat", methodName : "readPixelsRawRLE"});
						return;
					}
					scanline_buffer[ptr++] = buf[1] & 255;
					if(--count > 0) {
						if(kha_internal_HdrFormat.readBufOffset(scanline_buffer,ptr,count) < count) {
							haxe_Log.trace("Error reading non-run data",{ fileName : "HdrFormat.hx", lineNumber : 112, className : "kha.internal.HdrFormat", methodName : "readPixelsRawRLE"});
							return;
						}
						ptr += count;
					}
				}
			}
		}
		var _g1 = 0;
		var _g2 = scanline_width;
		while(_g1 < _g2) {
			var i1 = _g1++;
			data[offset] = scanline_buffer[i1] & 255;
			data[offset + 1] = scanline_buffer[i1 + scanline_width] & 255;
			data[offset + 2] = scanline_buffer[i1 + 2 * scanline_width] & 255;
			data[offset + 3] = scanline_buffer[i1 + 3 * scanline_width] & 255;
			offset += 4;
		}
		--num_scanlines;
	}
};
kha_internal_HdrFormat.readLine = function() {
	var buf = "";
	while(true) {
		var b = kha_internal_HdrFormat.buffer[kha_internal_HdrFormat.fileOffset];
		if(b == 10) {
			++kha_internal_HdrFormat.fileOffset;
			break;
		}
		buf += String.fromCharCode(b);
		if(!(++kha_internal_HdrFormat.fileOffset < kha_internal_HdrFormat.bufferLength)) {
			break;
		}
	}
	return buf;
};
kha_internal_HdrFormat.parse = function(bytes) {
	kha_internal_HdrFormat.buffer = haxe_io__$UInt8Array_UInt8Array_$Impl_$.fromBytes(bytes);
	kha_internal_HdrFormat.bufferLength = kha_internal_HdrFormat.buffer.length;
	kha_internal_HdrFormat.fileOffset = 0;
	var width = 0;
	var height = 0;
	var exposure = 1.0;
	var gamma = 1.0;
	var rle = false;
	var _g = 0;
	while(_g < 20) {
		var i = _g++;
		var line = kha_internal_HdrFormat.readLine();
		if(kha_internal_HdrFormat.formatPattern.match(line)) {
			rle = true;
		} else if(kha_internal_HdrFormat.exposurePattern.match(line)) {
			exposure = parseFloat(kha_internal_HdrFormat.exposurePattern.matched(1));
		} else if(kha_internal_HdrFormat.widthHeightPattern.match(line)) {
			height = Std.parseInt(kha_internal_HdrFormat.widthHeightPattern.matched(1));
			width = Std.parseInt(kha_internal_HdrFormat.widthHeightPattern.matched(2));
			break;
		}
	}
	if(!rle) {
		haxe_Log.trace("File is not run length encoded!",{ fileName : "HdrFormat.hx", lineNumber : 175, className : "kha.internal.HdrFormat", methodName : "parse"});
		return null;
	}
	var this1 = new Uint8Array(width * height * 4);
	var data = this1;
	var scanline_width = width;
	var num_scanlines = height;
	kha_internal_HdrFormat.readPixelsRawRLE(kha_internal_HdrFormat.buffer,data,0,scanline_width,num_scanlines);
	var this2 = new Float32Array(width * height * 4);
	var floatData = this2;
	var offset = 0;
	while(offset < data.length) {
		var r = data[offset] / 255;
		var g = data[offset + 1] / 255;
		var b = data[offset + 2] / 255;
		var e = data[offset + 3];
		var f = Math.pow(2.0,e - 128.0);
		r *= f;
		g *= f;
		b *= f;
		floatData[offset] = r;
		floatData[offset + 1] = g;
		floatData[offset + 2] = b;
		floatData[offset + 3] = 1.0;
		offset += 4;
	}
	return { width : width, height : height, data : floatData};
};
kha_internal_HdrFormat.prototype = {
	__class__: kha_internal_HdrFormat
};
var kha_js_AEAudioChannel = function(element) {
	this.stopped = false;
	this.element = element;
};
$hxClasses["kha.js.AEAudioChannel"] = kha_js_AEAudioChannel;
kha_js_AEAudioChannel.__name__ = true;
kha_js_AEAudioChannel.__interfaces__ = [kha_audio1_AudioChannel];
kha_js_AEAudioChannel.prototype = {
	element: null
	,stopped: null
	,play: function() {
		this.stopped = false;
		if(kha_SystemImpl.mobile) {
			if(kha_SystemImpl.insideInputEvent) {
				this.element.play();
				kha_SystemImpl.mobileAudioPlaying = true;
			} else if(kha_SystemImpl.mobileAudioPlaying) {
				this.element.play();
			} else {
				kha_js_AEAudioChannel.todo.push(this);
			}
		} else {
			this.element.play();
		}
	}
	,pause: function() {
		try {
			this.element.pause();
		} catch( e ) {
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			haxe_Log.trace(e,{ fileName : "AEAudioChannel.hx", lineNumber : 39, className : "kha.js.AEAudioChannel", methodName : "pause"});
		}
	}
	,stop: function() {
		try {
			this.element.pause();
			this.element.currentTime = 0;
			this.stopped = true;
		} catch( e ) {
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			haxe_Log.trace(e,{ fileName : "AEAudioChannel.hx", lineNumber : 50, className : "kha.js.AEAudioChannel", methodName : "stop"});
		}
	}
	,length: null
	,get_length: function() {
		if(isFinite(this.element.duration)) {
			return this.element.duration;
		} else {
			return Infinity;
		}
	}
	,position: null
	,get_position: function() {
		return this.element.currentTime;
	}
	,get_volume: function() {
		return this.element.volume;
	}
	,set_volume: function(value) {
		return this.element.volume = value;
	}
	,finished: null
	,get_finished: function() {
		if(!this.stopped) {
			return this.get_position() >= this.get_length();
		} else {
			return true;
		}
	}
	,__class__: kha_js_AEAudioChannel
};
var kha_js_AudioElementAudio = function() { };
$hxClasses["kha.js.AudioElementAudio"] = kha_js_AudioElementAudio;
kha_js_AudioElementAudio.__name__ = true;
kha_js_AudioElementAudio._compile = function() {
};
kha_js_AudioElementAudio.play = function(sound,loop) {
	if(loop == null) {
		loop = false;
	}
	return kha_js_AudioElementAudio.stream(sound,loop);
};
kha_js_AudioElementAudio.stream = function(sound,loop) {
	if(loop == null) {
		loop = false;
	}
	sound.element.loop = loop;
	var channel = new kha_js_AEAudioChannel(sound.element);
	channel.play();
	return channel;
};
var kha_js_CanvasGraphics = function(canvas) {
	kha_graphics2_Graphics.call(this);
	this.canvas = canvas;
	kha_js_CanvasGraphics.instance = this;
	this.myColor = kha__$Color_Color_$Impl_$.fromBytes(0,0,0);
	canvas.save();
};
$hxClasses["kha.js.CanvasGraphics"] = kha_js_CanvasGraphics;
kha_js_CanvasGraphics.__name__ = true;
kha_js_CanvasGraphics.stringWidth = function(font,text) {
	if(kha_js_CanvasGraphics.instance == null) {
		return 5 * text.length;
	} else {
		kha_js_CanvasGraphics.instance.set_font(font);
		return kha_js_CanvasGraphics.instance.canvas.measureText(text).width;
	}
};
kha_js_CanvasGraphics.__super__ = kha_graphics2_Graphics;
kha_js_CanvasGraphics.prototype = $extend(kha_graphics2_Graphics.prototype,{
	canvas: null
	,webfont: null
	,myColor: null
	,scaleQuality: null
	,begin: function(clear,clearColor) {
		if(clear == null) {
			clear = true;
		}
		if(clear) {
			this.clear(clearColor);
		}
	}
	,clear: function(color) {
		if(color == null) {
			color = 0;
		}
		this.canvas.strokeStyle = "rgba(" + ((color & 16711680) >>> 16) + "," + ((color & 65280) >>> 8) + "," + (color & 255) + "," + (color >>> 24) * 0.00392156862745098 + ")";
		this.canvas.fillStyle = "rgba(" + ((color & 16711680) >>> 16) + "," + ((color & 65280) >>> 8) + "," + (color & 255) + "," + (color >>> 24) * 0.00392156862745098 + ")";
		if((color >>> 24) * 0.00392156862745098 == 0) {
			this.canvas.clearRect(0,0,this.canvas.canvas.width,this.canvas.canvas.height);
		} else {
			this.canvas.fillRect(0,0,this.canvas.canvas.width,this.canvas.canvas.height);
		}
		this.set_color(this.myColor);
	}
	,end: function() {
	}
	,drawImage: function(img,x,y) {
		this.canvas.globalAlpha = this.get_opacity();
		this.canvas.drawImage((js_Boot.__cast(img , kha_CanvasImage)).image,x,y);
		this.canvas.globalAlpha = 1;
	}
	,drawScaledSubImage: function(image,sx,sy,sw,sh,dx,dy,dw,dh) {
		this.canvas.globalAlpha = this.get_opacity();
		try {
			if(dw < 0 || dh < 0) {
				this.canvas.save();
				this.canvas.translate(dx,dy);
				var x = 0.0;
				var y = 0.0;
				if(dw < 0) {
					this.canvas.scale(-1,1);
					x = -dw;
				}
				if(dh < 0) {
					this.canvas.scale(1,-1);
					y = -dh;
				}
				this.canvas.drawImage((js_Boot.__cast(image , kha_CanvasImage)).image,sx,sy,sw,sh,x,y,dw,dh);
				this.canvas.restore();
			} else {
				this.canvas.drawImage((js_Boot.__cast(image , kha_CanvasImage)).image,sx,sy,sw,sh,dx,dy,dw,dh);
			}
		} catch( ex ) {
		}
		this.canvas.globalAlpha = 1;
	}
	,set_color: function(color) {
		this.myColor = color;
		this.canvas.strokeStyle = "rgba(" + ((color & 16711680) >>> 16) + "," + ((color & 65280) >>> 8) + "," + (color & 255) + "," + (color >>> 24) * 0.00392156862745098 + ")";
		this.canvas.fillStyle = "rgba(" + ((color & 16711680) >>> 16) + "," + ((color & 65280) >>> 8) + "," + (color & 255) + "," + (color >>> 24) * 0.00392156862745098 + ")";
		return color;
	}
	,get_color: function() {
		return this.myColor;
	}
	,get_imageScaleQuality: function() {
		return this.scaleQuality;
	}
	,set_imageScaleQuality: function(value) {
		if(value == kha_graphics2_ImageScaleQuality.Low) {
			this.canvas.mozImageSmoothingEnabled = false;
			this.canvas.webkitImageSmoothingEnabled = false;
			this.canvas.msImageSmoothingEnabled = false;
			this.canvas.imageSmoothingEnabled = false;
		} else {
			this.canvas.mozImageSmoothingEnabled = true;
			this.canvas.webkitImageSmoothingEnabled = true;
			this.canvas.msImageSmoothingEnabled = true;
			this.canvas.imageSmoothingEnabled = true;
		}
		return this.scaleQuality = value;
	}
	,drawRect: function(x,y,width,height,strength) {
		if(strength == null) {
			strength = 1.0;
		}
		this.canvas.beginPath();
		var oldStrength = this.canvas.lineWidth;
		this.canvas.lineWidth = Math.round(strength);
		this.canvas.rect(x,y,width,height);
		this.canvas.stroke();
		this.canvas.lineWidth = oldStrength;
	}
	,fillRect: function(x,y,width,height) {
		var tmp = this.get_opacity();
		this.canvas.globalAlpha = tmp * ((this.myColor >>> 24) * 0.00392156862745098);
		this.canvas.fillRect(x,y,width,height);
		this.canvas.globalAlpha = this.get_opacity();
	}
	,drawArc: function(cx,cy,radius,sAngle,eAngle,strength,ccw) {
		if(ccw == null) {
			ccw = false;
		}
		if(strength == null) {
			strength = 1.0;
		}
		this.canvas.beginPath();
		var oldStrength = this.canvas.lineWidth;
		this.canvas.lineWidth = Math.round(strength);
		this.canvas.arc(cx,cy,radius,sAngle,eAngle,ccw);
		this.canvas.stroke();
		this.canvas.lineWidth = oldStrength;
	}
	,drawCircle: function(cx,cy,radius,strength) {
		if(strength == null) {
			strength = 1.0;
		}
		var eAngle = 2 * Math.PI;
		this.canvas.beginPath();
		var oldStrength = this.canvas.lineWidth;
		this.canvas.lineWidth = Math.round(strength);
		this.canvas.arc(cx,cy,radius,0,eAngle,false);
		this.canvas.stroke();
		this.canvas.lineWidth = oldStrength;
	}
	,_drawArc: function(cx,cy,radius,sAngle,eAngle,strength,ccw) {
		this.canvas.beginPath();
		var oldStrength = this.canvas.lineWidth;
		this.canvas.lineWidth = Math.round(strength);
		this.canvas.arc(cx,cy,radius,sAngle,eAngle,ccw);
		this.canvas.stroke();
		this.canvas.lineWidth = oldStrength;
	}
	,fillArc: function(cx,cy,radius,sAngle,eAngle,ccw) {
		if(ccw == null) {
			ccw = false;
		}
		this.canvas.beginPath();
		this.canvas.arc(cx,cy,radius,sAngle,eAngle,ccw);
		this.canvas.fill();
	}
	,fillCircle: function(cx,cy,radius) {
		this.canvas.beginPath();
		this.canvas.arc(cx,cy,radius,0,2 * Math.PI,false);
		this.canvas.fill();
	}
	,drawString: function(text,x,y) {
		var image = this.webfont.getImage(this.get_fontSize(),this.myColor,this.get_fontGlyphs());
		if(image.width > 0) {
			var xpos = x;
			var ypos = y;
			var _g1 = 0;
			var _g = text.length;
			while(_g1 < _g) {
				var i = _g1++;
				var q;
				if(this.get_fontGlyphs() != null) {
					q = this.webfont.kravur._get(this.get_fontSize(),this.get_fontGlyphs()).getBakedQuad(this.get_fontGlyphs().indexOf(HxOverrides.cca(text,i)),xpos,ypos);
				} else {
					q = this.webfont.kravur._get(this.get_fontSize()).getBakedQuad(HxOverrides.cca(text,i) - 32,xpos,ypos);
				}
				if(q != null) {
					if(q.s1 - q.s0 > 0 && q.t1 - q.t0 > 0 && q.x1 - q.x0 > 0 && q.y1 - q.y0 > 0) {
						this.canvas.drawImage(image,q.s0 * image.width,q.t0 * image.height,(q.s1 - q.s0) * image.width,(q.t1 - q.t0) * image.height,q.x0,q.y0,q.x1 - q.x0,q.y1 - q.y0);
					}
					xpos += q.xadvance;
				}
			}
		}
	}
	,set_font: function(font) {
		this.webfont = js_Boot.__cast(font , kha_js_Font);
		return this.webfont;
	}
	,get_font: function() {
		return this.webfont;
	}
	,drawLine: function(x1,y1,x2,y2,strength) {
		if(strength == null) {
			strength = 1.0;
		}
		this.canvas.beginPath();
		var oldWith = this.canvas.lineWidth;
		this.canvas.lineWidth = Math.round(strength);
		this.canvas.moveTo(x1,y1);
		this.canvas.lineTo(x2,y2);
		this.canvas.moveTo(0,0);
		this.canvas.stroke();
		this.canvas.lineWidth = oldWith;
	}
	,fillTriangle: function(x1,y1,x2,y2,x3,y3) {
		this.canvas.beginPath();
		this.canvas.closePath();
		this.canvas.fill();
	}
	,scissor: function(x,y,width,height) {
		this.canvas.beginPath();
		this.canvas.rect(x,y,width,height);
		this.canvas.clip();
	}
	,disableScissor: function() {
		this.canvas.restore();
	}
	,drawVideo: function(video,x,y,width,height) {
		this.canvas.drawImage((js_Boot.__cast(video , kha_js_Video)).element,x,y,width,height);
	}
	,setTransformation: function(transformation) {
		this.canvas.setTransform(transformation._00,transformation._01,transformation._10,transformation._11,transformation._20,transformation._21);
	}
	,__class__: kha_js_CanvasGraphics
});
var kha_js_URLParser = function(url) {
	this._parts = null;
	this._parts = ["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];
	this.url = url;
	var r = new EReg("^(?:(?![^:@]+:[^:@/]*@)([^:/?#.]+):)?(?://)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\\d*))?)(((/(?:[^?#](?![^?#/]*\\.[^?#/.]+(?:[?#]|$)))*/?)?([^?#/]*))(?:\\?([^#]*))?(?:#(.*))?)","");
	r.match(url);
	var _g1 = 0;
	var _g = this._parts.length;
	while(_g1 < _g) {
		var i = _g1++;
		this[this._parts[i]] = r.matched(i);
	}
};
$hxClasses["kha.js.URLParser"] = kha_js_URLParser;
kha_js_URLParser.__name__ = true;
kha_js_URLParser.parse = function(url) {
	return new kha_js_URLParser(url);
};
kha_js_URLParser.prototype = {
	url: null
	,source: null
	,protocol: null
	,authority: null
	,userInfo: null
	,user: null
	,password: null
	,host: null
	,port: null
	,relative: null
	,path: null
	,directory: null
	,file: null
	,query: null
	,anchor: null
	,_parts: null
	,toString: function() {
		var s = "For Url -> " + this.url + "\n";
		var _g1 = 0;
		var _g = this._parts.length;
		while(_g1 < _g) {
			var i = _g1++;
			s += this._parts[i] + ": " + Std.string(Reflect.field(this,this._parts[i])) + (i == this._parts.length - 1 ? "" : "\n");
		}
		return s;
	}
	,__class__: kha_js_URLParser
};
var kha_js_EnvironmentVariables = function() {
	kha_EnvironmentVariables.call(this);
};
$hxClasses["kha.js.EnvironmentVariables"] = kha_js_EnvironmentVariables;
kha_js_EnvironmentVariables.__name__ = true;
kha_js_EnvironmentVariables.__super__ = kha_EnvironmentVariables;
kha_js_EnvironmentVariables.prototype = $extend(kha_EnvironmentVariables.prototype,{
	getVariable: function(name) {
		var parser = new kha_js_URLParser(window.location.href);
		var query = parser.query;
		var parts = query.split("&");
		var _g = 0;
		while(_g < parts.length) {
			var part = parts[_g];
			++_g;
			var subparts = part.split("=");
			if(subparts[0] == name) {
				return subparts[1];
			}
		}
		haxe_Log.trace("Environment variables requested.",{ fileName : "EnvironmentVariables.hx", lineNumber : 90, className : "kha.js.EnvironmentVariables", methodName : "getVariable"});
		return "";
	}
	,__class__: kha_js_EnvironmentVariables
});
var kha_js_Font = function(blob) {
	this.images = new haxe_ds_IntMap();
	this.kravur = new kha_Kravur(blob);
};
$hxClasses["kha.js.Font"] = kha_js_Font;
kha_js_Font.__name__ = true;
kha_js_Font.__interfaces__ = [kha_Resource];
kha_js_Font.fromBytes = function(bytes) {
	return new kha_js_Font(kha_internal_BytesBlob.fromBytes(bytes));
};
kha_js_Font.prototype = {
	kravur: null
	,images: null
	,height: function(fontSize) {
		return this.kravur._get(fontSize).getHeight();
	}
	,width: function(fontSize,str) {
		return this.kravur._get(fontSize).stringWidth(str);
	}
	,widthOfCharacters: function(fontSize,characters,start,length) {
		return this.kravur._get(fontSize).charactersWidth(characters,start,length);
	}
	,baseline: function(fontSize) {
		return this.kravur._get(fontSize).getBaselinePosition();
	}
	,getImage: function(fontSize,color,glyphs) {
		var imageIndex = glyphs == null ? fontSize : fontSize * 10000 + glyphs.length;
		if(!this.images.h.hasOwnProperty(imageIndex)) {
			var this1 = this.images;
			var v = new haxe_ds_IntMap();
			this1.h[imageIndex] = v;
		}
		if(!this.images.h[imageIndex].h.hasOwnProperty(color)) {
			var kravur = this.kravur._get(fontSize,glyphs);
			var canvas = window.document.createElement("canvas");
			canvas.width = kravur.width;
			canvas.height = kravur.height;
			var ctx = canvas.getContext("2d");
			ctx.fillStyle = "black";
			ctx.fillRect(0,0,kravur.width,kravur.height);
			var imageData = ctx.getImageData(0,0,kravur.width,kravur.height);
			var bytes = (js_Boot.__cast(kravur.getTexture() , kha_CanvasImage)).bytes;
			var _g1 = 0;
			var _g = bytes.length;
			while(_g1 < _g) {
				var i = _g1++;
				imageData.data[i * 4] = (color & 16711680) >>> 16;
				imageData.data[i * 4 + 1] = (color & 65280) >>> 8;
				imageData.data[i * 4 + 2] = color & 255;
				imageData.data[i * 4 + 3] = bytes.b[i];
			}
			ctx.putImageData(imageData,0,0);
			var img = window.document.createElement("img");
			img.src = canvas.toDataURL("image/png");
			this.images.h[imageIndex].h[color] = img;
			return img;
		}
		return this.images.h[imageIndex].h[color];
	}
	,unload: function() {
		this.kravur = null;
		this.images = null;
	}
	,__class__: kha_js_Font
};
var kha_js_MobileWebAudio = function() { };
$hxClasses["kha.js.MobileWebAudio"] = kha_js_MobileWebAudio;
kha_js_MobileWebAudio.__name__ = true;
kha_js_MobileWebAudio._init = function() {
	try {
		kha_js_MobileWebAudio._context = new AudioContext();
		return;
	} catch( e ) {
	}
	try {
		this._context = new webkitAudioContext();
		return;
	} catch( e1 ) {
	}
};
kha_js_MobileWebAudio.play = function(sound,loop) {
	if(loop == null) {
		loop = false;
	}
	var channel = new kha_js_MobileWebAudioChannel(sound,loop);
	channel.play();
	return channel;
};
kha_js_MobileWebAudio.stream = function(sound,loop) {
	if(loop == null) {
		loop = false;
	}
	return kha_js_MobileWebAudio.play(sound,loop);
};
var kha_js_MobileWebAudioChannel = function(sound,loop) {
	this.stopped = false;
	this.paused = false;
	this.buffer = sound._buffer;
	this.loop = loop;
	this.createSource();
};
$hxClasses["kha.js.MobileWebAudioChannel"] = kha_js_MobileWebAudioChannel;
kha_js_MobileWebAudioChannel.__name__ = true;
kha_js_MobileWebAudioChannel.__interfaces__ = [kha_audio1_AudioChannel];
kha_js_MobileWebAudioChannel.prototype = {
	buffer: null
	,loop: null
	,source: null
	,gain: null
	,startTime: null
	,pauseTime: null
	,paused: null
	,stopped: null
	,createSource: function() {
		var _gthis = this;
		this.source = kha_js_MobileWebAudio._context.createBufferSource();
		this.source.loop = this.loop;
		this.source.buffer = this.buffer;
		this.source.onended = function() {
			_gthis.stopped = true;
		};
		this.gain = kha_js_MobileWebAudio._context.createGain();
		this.source.connect(this.gain);
		this.gain.connect(kha_js_MobileWebAudio._context.destination);
	}
	,play: function() {
		if(this.paused || this.stopped) {
			this.createSource();
		}
		this.stopped = false;
		if(this.paused) {
			this.paused = false;
			this.startTime = kha_js_MobileWebAudio._context.currentTime - this.pauseTime;
			this.source.start(0,this.pauseTime);
		} else {
			this.startTime = kha_js_MobileWebAudio._context.currentTime;
			this.source.start();
		}
	}
	,pause: function() {
		this.pauseTime = kha_js_MobileWebAudio._context.currentTime - this.startTime;
		this.paused = true;
		this.source.stop();
	}
	,stop: function() {
		this.paused = false;
		this.stopped = true;
		this.source.stop();
	}
	,length: null
	,get_length: function() {
		return this.source.buffer.duration;
	}
	,position: null
	,get_position: function() {
		if(this.stopped) {
			return this.get_length();
		}
		if(this.paused) {
			return this.pauseTime;
		} else {
			return kha_js_MobileWebAudio._context.currentTime - this.startTime;
		}
	}
	,get_volume: function() {
		return this.gain.gain.value;
	}
	,set_volume: function(value) {
		return this.gain.gain.value = value;
	}
	,finished: null
	,get_finished: function() {
		return this.stopped;
	}
	,__class__: kha_js_MobileWebAudioChannel
};
var kha_js_MobileWebAudioSound = function(filename,done) {
	var _gthis = this;
	kha_Sound.call(this);
	var request = new XMLHttpRequest();
	request.open("GET",filename,true);
	request.responseType = "arraybuffer";
	request.onerror = function() {
		haxe_Log.trace("Error loading " + filename,{ fileName : "MobileWebAudioSound.hx", lineNumber : 25, className : "kha.js.MobileWebAudioSound", methodName : "new"});
	};
	request.onload = function() {
		_gthis.compressedData = haxe_io_Bytes.ofData(request.response);
		_gthis.uncompressedData = null;
		kha_js_MobileWebAudio._context.decodeAudioData(_gthis.compressedData.b.bufferValue,function(buffer) {
			_gthis._buffer = buffer;
			done(_gthis);
		},function() {
			throw new js__$Boot_HaxeError("Audio format not supported");
		});
	};
	request.send(null);
};
$hxClasses["kha.js.MobileWebAudioSound"] = kha_js_MobileWebAudioSound;
kha_js_MobileWebAudioSound.__name__ = true;
kha_js_MobileWebAudioSound.__super__ = kha_Sound;
kha_js_MobileWebAudioSound.prototype = $extend(kha_Sound.prototype,{
	_buffer: null
	,uncompress: function(done) {
		done();
	}
	,__class__: kha_js_MobileWebAudioSound
});
var kha_js_Sound = function(filenames,done) {
	kha_Sound.call(this);
	this.done = done;
	kha_js_Sound.loading.push(this);
	this.element = window.document.createElement("audio");
	this.filenames = [];
	var _g = 0;
	while(_g < filenames.length) {
		var filename = filenames[_g];
		++_g;
		if(this.element.canPlayType("audio/ogg") != "" && StringTools.endsWith(filename,".ogg")) {
			this.filenames.push(filename);
		}
		if(this.element.canPlayType("audio/mp4") != "" && StringTools.endsWith(filename,".mp4")) {
			this.filenames.push(filename);
		}
	}
	this.element.addEventListener("error",$bind(this,this.errorListener),false);
	this.element.addEventListener("canplay",$bind(this,this.canPlayThroughListener),false);
	this.element.src = this.filenames[0];
	this.element.preload = "auto";
	this.element.load();
};
$hxClasses["kha.js.Sound"] = kha_js_Sound;
kha_js_Sound.__name__ = true;
kha_js_Sound.__super__ = kha_Sound;
kha_js_Sound.prototype = $extend(kha_Sound.prototype,{
	filenames: null
	,done: null
	,element: null
	,errorListener: function(eventInfo) {
		if(this.element.error.code == 4) {
			var _g1 = 0;
			var _g = this.filenames.length - 1;
			while(_g1 < _g) {
				var i = _g1++;
				if(this.element.src == this.filenames[i]) {
					this.element.src = this.filenames[i + 1];
					return;
				}
			}
		}
		haxe_Log.trace("Error loading " + this.element.src,{ fileName : "Sound.hx", lineNumber : 108, className : "kha.js.Sound", methodName : "errorListener"});
		window.console.log("loadSound failed");
		this.finishAsset();
	}
	,canPlayThroughListener: function(eventInfo) {
		this.finishAsset();
	}
	,finishAsset: function() {
		this.element.removeEventListener("error",$bind(this,this.errorListener),false);
		this.element.removeEventListener("canplaythrough",$bind(this,this.canPlayThroughListener),false);
		this.done(this);
		HxOverrides.remove(kha_js_Sound.loading,this);
	}
	,uncompress: function(done) {
		done();
	}
	,__class__: kha_js_Sound
});
var kha_js_Video = function() {
	kha_Video.call(this);
};
$hxClasses["kha.js.Video"] = kha_js_Video;
kha_js_Video.__name__ = true;
kha_js_Video.fromElement = function(element) {
	var video = new kha_js_Video();
	video.element = element;
	if(kha_SystemImpl.gl != null) {
		video.texture = kha_Image.fromVideo(video);
	}
	return video;
};
kha_js_Video.fromFile = function(filenames,done) {
	var video = new kha_js_Video();
	video.done = done;
	video.element = window.document.createElement("video");
	video.filenames = [];
	var _g = 0;
	while(_g < filenames.length) {
		var filename = filenames[_g];
		++_g;
		if(video.element.canPlayType("video/webm") != "" && StringTools.endsWith(filename,".webm")) {
			video.filenames.push(filename);
		}
		if(video.element.canPlayType("video/mp4") != "" && StringTools.endsWith(filename,".mp4")) {
			video.filenames.push(filename);
		}
	}
	video.element.addEventListener("error",$bind(video,video.errorListener),false);
	video.element.addEventListener("canplaythrough",$bind(video,video.canPlayThroughListener),false);
	video.element.preload = "auto";
	video.element.src = video.filenames[0];
};
kha_js_Video.__super__ = kha_Video;
kha_js_Video.prototype = $extend(kha_Video.prototype,{
	filenames: null
	,element: null
	,done: null
	,texture: null
	,width: function() {
		return this.element.videoWidth;
	}
	,height: function() {
		return this.element.videoHeight;
	}
	,play: function(loop) {
		if(loop == null) {
			loop = false;
		}
		try {
			this.element.loop = loop;
			this.element.play();
		} catch( e ) {
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			haxe_Log.trace(e,{ fileName : "Video.hx", lineNumber : 64, className : "kha.js.Video", methodName : "play"});
		}
	}
	,pause: function() {
		try {
			this.element.pause();
		} catch( e ) {
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			haxe_Log.trace(e,{ fileName : "Video.hx", lineNumber : 73, className : "kha.js.Video", methodName : "pause"});
		}
	}
	,stop: function() {
		try {
			this.element.pause();
			this.element.currentTime = 0;
		} catch( e ) {
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			haxe_Log.trace(e,{ fileName : "Video.hx", lineNumber : 83, className : "kha.js.Video", methodName : "stop"});
		}
	}
	,getCurrentPos: function() {
		return Math.ceil(this.element.currentTime * 1000);
	}
	,get_position: function() {
		return Math.ceil(this.element.currentTime * 1000);
	}
	,set_position: function(value) {
		this.element.currentTime = value / 1000;
		return value;
	}
	,getLength: function() {
		if(isFinite(this.element.duration)) {
			return Math.floor(this.element.duration * 1000);
		} else {
			return -1;
		}
	}
	,errorListener: function(eventInfo) {
		if(this.element.error.code == 4) {
			var _g1 = 0;
			var _g = this.filenames.length - 1;
			while(_g1 < _g) {
				var i = _g1++;
				if(this.element.src == this.filenames[i]) {
					this.element.src = this.filenames[i + 1];
					return;
				}
			}
		}
		haxe_Log.trace("Error loading " + this.element.src,{ fileName : "Video.hx", lineNumber : 120, className : "kha.js.Video", methodName : "errorListener"});
		this.finishAsset();
	}
	,canPlayThroughListener: function(eventInfo) {
		this.finishAsset();
	}
	,finishAsset: function() {
		this.element.removeEventListener("error",$bind(this,this.errorListener),false);
		this.element.removeEventListener("canplaythrough",$bind(this,this.canPlayThroughListener),false);
		if(kha_SystemImpl.gl != null) {
			this.texture = kha_Image.fromVideo(this);
		}
		this.done(this);
	}
	,__class__: kha_js_Video
});
var kha_js_WebAudioSound = function(filename,done) {
	var _gthis = this;
	kha_Sound.call(this);
	var request = new XMLHttpRequest();
	request.open("GET",filename,true);
	request.responseType = "arraybuffer";
	request.onerror = function() {
		haxe_Log.trace("Error loading " + filename,{ fileName : "WebAudioSound.hx", lineNumber : 76, className : "kha.js.WebAudioSound", methodName : "new"});
	};
	request.onload = function() {
		_gthis.compressedData = haxe_io_Bytes.ofData(request.response);
		_gthis.uncompressedData = null;
		done(_gthis);
	};
	request.send(null);
};
$hxClasses["kha.js.WebAudioSound"] = kha_js_WebAudioSound;
kha_js_WebAudioSound.__name__ = true;
kha_js_WebAudioSound.__super__ = kha_Sound;
kha_js_WebAudioSound.prototype = $extend(kha_Sound.prototype,{
	superUncompress: function(done) {
		kha_Sound.prototype.uncompress.call(this,done);
	}
	,uncompress: function(done) {
		var _gthis = this;
		kha_audio2_Audio._context.decodeAudioData(this.compressedData.b.bufferValue,function(buffer) {
			var length = buffer.getChannelData(0).length * 2;
			var this1 = new Array(length);
			_gthis.uncompressedData = this1;
			if(buffer.numberOfChannels == 1) {
				var _g1 = 0;
				var _g = buffer.getChannelData(0).length;
				while(_g1 < _g) {
					var i = _g1++;
					_gthis.uncompressedData[i * 2] = buffer.getChannelData(0)[i];
					_gthis.uncompressedData[i * 2 + 1] = buffer.getChannelData(0)[i];
				}
			} else {
				var _g11 = 0;
				var _g2 = buffer.getChannelData(0).length;
				while(_g11 < _g2) {
					var i1 = _g11++;
					_gthis.uncompressedData[i1 * 2] = buffer.getChannelData(0)[i1];
					_gthis.uncompressedData[i1 * 2 + 1] = buffer.getChannelData(1)[i1];
				}
			}
			_gthis.compressedData = null;
			done();
		},function() {
			_gthis.superUncompress(done);
		});
	}
	,__class__: kha_js_WebAudioSound
});
var kha_js_graphics4_ConstantLocation = function(value,type) {
	this.value = value;
	this.type = type;
};
$hxClasses["kha.js.graphics4.ConstantLocation"] = kha_js_graphics4_ConstantLocation;
kha_js_graphics4_ConstantLocation.__name__ = true;
kha_js_graphics4_ConstantLocation.__interfaces__ = [kha_graphics4_ConstantLocation];
kha_js_graphics4_ConstantLocation.prototype = {
	value: null
	,type: null
	,__class__: kha_js_graphics4_ConstantLocation
};
var kha_js_graphics4_Graphics = function(renderTarget) {
	var this1 = new Array(9);
	this.matrix3Cache = this1;
	var this11 = new Array(16);
	this.matrixCache = this11;
	this.isDepthAttachment = false;
	this.isCubeMap = false;
	this.colorMaskAlpha = true;
	this.colorMaskBlue = true;
	this.colorMaskGreen = true;
	this.colorMaskRed = true;
	this.depthMask = false;
	this.depthTest = false;
	this.renderTarget = renderTarget;
	this.init();
	if(kha_SystemImpl.gl2) {
		this.instancedExtension = true;
	} else {
		this.instancedExtension = kha_SystemImpl.gl.getExtension("ANGLE_instanced_arrays");
		this.blendMinMaxExtension = kha_SystemImpl.gl.getExtension("EXT_blend_minmax");
	}
};
$hxClasses["kha.js.graphics4.Graphics"] = kha_js_graphics4_Graphics;
kha_js_graphics4_Graphics.__name__ = true;
kha_js_graphics4_Graphics.__interfaces__ = [kha_graphics4_Graphics];
kha_js_graphics4_Graphics.getBlendFunc = function(factor) {
	switch(factor[1]) {
	case 0:case 2:
		return 0;
	case 1:
		return 1;
	case 3:
		return 770;
	case 4:
		return 772;
	case 5:
		return 771;
	case 6:
		return 773;
	case 7:
		return 768;
	case 8:
		return 774;
	case 9:
		return 769;
	case 10:
		return 775;
	}
};
kha_js_graphics4_Graphics.getBlendOp = function(op) {
	switch(op[1]) {
	case 0:
		return 32774;
	case 1:
		return 32778;
	case 2:
		return 32779;
	case 3:
		return 32775;
	case 4:
		return 32776;
	}
};
kha_js_graphics4_Graphics.prototype = {
	depthTest: null
	,depthMask: null
	,colorMaskRed: null
	,colorMaskGreen: null
	,colorMaskBlue: null
	,colorMaskAlpha: null
	,indicesCount: null
	,renderTarget: null
	,renderTargetFrameBuffer: null
	,renderTargetTexture: null
	,isCubeMap: null
	,isDepthAttachment: null
	,instancedExtension: null
	,blendMinMaxExtension: null
	,init: function() {
		if(this.renderTarget == null) {
			return;
		}
		this.isCubeMap = js_Boot.__instanceof(this.renderTarget,kha_graphics4_CubeMap);
		if(this.isCubeMap) {
			var cubeMap = js_Boot.__cast(this.renderTarget , kha_graphics4_CubeMap);
			this.renderTargetFrameBuffer = cubeMap.frameBuffer;
			this.renderTargetTexture = cubeMap.texture;
			this.isDepthAttachment = cubeMap.isDepthAttachment;
		} else {
			var image = js_Boot.__cast(this.renderTarget , kha_WebGLImage);
			this.renderTargetFrameBuffer = image.frameBuffer;
			this.renderTargetTexture = image.texture;
		}
	}
	,begin: function(additionalRenderTargets) {
		kha_SystemImpl.gl.enable(3042);
		kha_SystemImpl.gl.blendFunc(770,771);
		if(this.renderTarget == null) {
			kha_SystemImpl.gl.bindFramebuffer(36160,null);
			kha_SystemImpl.gl.viewport(0,0,kha_System.windowWidth(),kha_System.windowHeight());
		} else {
			kha_SystemImpl.gl.bindFramebuffer(36160,this.renderTargetFrameBuffer);
			kha_SystemImpl.gl.viewport(0,0,this.renderTarget.get_width(),this.renderTarget.get_height());
			if(additionalRenderTargets != null) {
				kha_SystemImpl.gl.framebufferTexture2D(36160,kha_SystemImpl.drawBuffers.COLOR_ATTACHMENT0_WEBGL,3553,this.renderTargetTexture,0);
				var _g1 = 0;
				var _g = additionalRenderTargets.length;
				while(_g1 < _g) {
					var i = _g1++;
					kha_SystemImpl.gl.framebufferTexture2D(36160,kha_SystemImpl.drawBuffers.COLOR_ATTACHMENT0_WEBGL + i + 1,3553,(js_Boot.__cast(additionalRenderTargets[i] , kha_WebGLImage)).texture,0);
				}
				var attachments = [kha_SystemImpl.drawBuffers.COLOR_ATTACHMENT0_WEBGL];
				var _g11 = 0;
				var _g2 = additionalRenderTargets.length;
				while(_g11 < _g2) {
					var i1 = _g11++;
					attachments.push(kha_SystemImpl.drawBuffers.COLOR_ATTACHMENT0_WEBGL + i1 + 1);
				}
				if(kha_SystemImpl.gl2) {
					kha_SystemImpl.gl.drawBuffers(attachments);
				} else {
					kha_SystemImpl.drawBuffers.drawBuffersWEBGL(attachments);
				}
			}
		}
	}
	,beginFace: function(face) {
		kha_SystemImpl.gl.enable(3042);
		kha_SystemImpl.gl.blendFunc(770,771);
		kha_SystemImpl.gl.bindFramebuffer(36160,this.renderTargetFrameBuffer);
		kha_SystemImpl.gl.framebufferTexture2D(36160,this.isDepthAttachment ? 36096 : 36064,34069 + face,this.renderTargetTexture,0);
		kha_SystemImpl.gl.viewport(0,0,this.renderTarget.get_width(),this.renderTarget.get_height());
	}
	,beginEye: function(eye) {
		kha_SystemImpl.gl.enable(3042);
		kha_SystemImpl.gl.blendFunc(770,771);
		kha_SystemImpl.gl.bindFramebuffer(36160,null);
		if(eye == 0) {
			kha_SystemImpl.gl.viewport(0,0,kha_System.windowWidth() * 0.5 | 0,kha_System.windowHeight());
		} else {
			kha_SystemImpl.gl.viewport(kha_System.windowWidth() * 0.5 | 0,0,kha_System.windowWidth() * 0.5 | 0,kha_System.windowHeight());
		}
	}
	,end: function() {
	}
	,flush: function() {
	}
	,vsynced: function() {
		return true;
	}
	,refreshRate: function() {
		return 60;
	}
	,clear: function(color,depth,stencil) {
		var clearMask = 0;
		if(color != null) {
			clearMask |= 16384;
			kha_SystemImpl.gl.colorMask(true,true,true,true);
			kha_SystemImpl.gl.clearColor(((color & 16711680) >>> 16) * 0.00392156862745098,((color & 65280) >>> 8) * 0.00392156862745098,(color & 255) * 0.00392156862745098,(color >>> 24) * 0.00392156862745098);
		}
		if(depth != null) {
			clearMask |= 256;
			kha_SystemImpl.gl.enable(2929);
			kha_SystemImpl.gl.depthMask(true);
			kha_SystemImpl.gl.clearDepth(depth);
		}
		if(stencil != null) {
			clearMask |= 1024;
			kha_SystemImpl.gl.enable(2960);
			kha_SystemImpl.gl.stencilMask(255);
			kha_SystemImpl.gl.clearStencil(stencil);
		}
		kha_SystemImpl.gl.clear(clearMask);
		kha_SystemImpl.gl.colorMask(this.colorMaskRed,this.colorMaskGreen,this.colorMaskBlue,this.colorMaskAlpha);
		if(this.depthTest) {
			kha_SystemImpl.gl.enable(2929);
		} else {
			kha_SystemImpl.gl.disable(2929);
		}
		kha_SystemImpl.gl.depthMask(this.depthMask);
	}
	,viewport: function(x,y,width,height) {
		var h = this.renderTarget == null ? kha_System.windowHeight(0) : this.renderTarget.get_height();
		kha_SystemImpl.gl.viewport(x,h - y - height,width,height);
	}
	,setDepthMode: function(write,mode) {
		switch(mode[1]) {
		case 0:
			if(write) {
				kha_SystemImpl.gl.enable(2929);
			} else {
				kha_SystemImpl.gl.disable(2929);
			}
			this.depthTest = write;
			kha_SystemImpl.gl.depthFunc(519);
			break;
		case 1:
			kha_SystemImpl.gl.enable(2929);
			this.depthTest = true;
			kha_SystemImpl.gl.depthFunc(512);
			break;
		case 2:
			kha_SystemImpl.gl.enable(2929);
			this.depthTest = true;
			kha_SystemImpl.gl.depthFunc(514);
			break;
		case 3:
			kha_SystemImpl.gl.enable(2929);
			this.depthTest = true;
			kha_SystemImpl.gl.depthFunc(517);
			break;
		case 4:
			kha_SystemImpl.gl.enable(2929);
			this.depthTest = true;
			kha_SystemImpl.gl.depthFunc(513);
			break;
		case 5:
			kha_SystemImpl.gl.enable(2929);
			this.depthTest = true;
			kha_SystemImpl.gl.depthFunc(515);
			break;
		case 6:
			kha_SystemImpl.gl.enable(2929);
			this.depthTest = true;
			kha_SystemImpl.gl.depthFunc(516);
			break;
		case 7:
			kha_SystemImpl.gl.enable(2929);
			this.depthTest = true;
			kha_SystemImpl.gl.depthFunc(518);
			break;
		}
		kha_SystemImpl.gl.depthMask(write);
		this.depthMask = write;
	}
	,setBlendingMode: function(source,destination,operation,alphaSource,alphaDestination,alphaOperation) {
		if(source == kha_graphics4_BlendingFactor.BlendOne && destination == kha_graphics4_BlendingFactor.BlendZero) {
			kha_SystemImpl.gl.disable(3042);
		} else {
			kha_SystemImpl.gl.enable(3042);
			kha_SystemImpl.gl.blendFuncSeparate(kha_js_graphics4_Graphics.getBlendFunc(source),kha_js_graphics4_Graphics.getBlendFunc(destination),kha_js_graphics4_Graphics.getBlendFunc(alphaSource),kha_js_graphics4_Graphics.getBlendFunc(alphaDestination));
			kha_SystemImpl.gl.blendEquationSeparate(kha_js_graphics4_Graphics.getBlendOp(operation),kha_js_graphics4_Graphics.getBlendOp(alphaOperation));
		}
	}
	,createVertexBuffer: function(vertexCount,structure,usage,canRead) {
		if(canRead == null) {
			canRead = false;
		}
		return new kha_graphics4_VertexBuffer(vertexCount,structure,usage);
	}
	,setVertexBuffer: function(vertexBuffer) {
		(js_Boot.__cast(vertexBuffer , kha_graphics4_VertexBuffer)).set(0);
	}
	,setVertexBuffers: function(vertexBuffers) {
		var offset = 0;
		var _g = 0;
		while(_g < vertexBuffers.length) {
			var vertexBuffer = vertexBuffers[_g];
			++_g;
			offset += (js_Boot.__cast(vertexBuffer , kha_graphics4_VertexBuffer)).set(offset);
		}
	}
	,createIndexBuffer: function(indexCount,usage,canRead) {
		if(canRead == null) {
			canRead = false;
		}
		return new kha_graphics4_IndexBuffer(indexCount,usage);
	}
	,setIndexBuffer: function(indexBuffer) {
		this.indicesCount = indexBuffer.count();
		(js_Boot.__cast(indexBuffer , kha_graphics4_IndexBuffer)).set();
	}
	,setTexture: function(stage,texture) {
		if(texture == null) {
			kha_SystemImpl.gl.activeTexture(33984 + (js_Boot.__cast(stage , kha_js_graphics4_TextureUnit)).value);
			kha_SystemImpl.gl.bindTexture(3553,null);
		} else {
			(js_Boot.__cast(texture , kha_WebGLImage)).set((js_Boot.__cast(stage , kha_js_graphics4_TextureUnit)).value);
		}
	}
	,setTextureDepth: function(stage,texture) {
		(js_Boot.__cast(texture , kha_WebGLImage)).setDepth((js_Boot.__cast(stage , kha_js_graphics4_TextureUnit)).value);
	}
	,setTextureArray: function(unit,texture) {
	}
	,setVideoTexture: function(unit,texture) {
		if(texture == null) {
			kha_SystemImpl.gl.activeTexture(33984 + (js_Boot.__cast(unit , kha_js_graphics4_TextureUnit)).value);
			kha_SystemImpl.gl.bindTexture(3553,null);
		} else {
			(js_Boot.__cast((js_Boot.__cast(texture , kha_js_Video)).texture , kha_WebGLImage)).set((js_Boot.__cast(unit , kha_js_graphics4_TextureUnit)).value);
		}
	}
	,setImageTexture: function(unit,texture) {
	}
	,setTextureParameters: function(texunit,uAddressing,vAddressing,minificationFilter,magnificationFilter,mipmapFilter) {
		kha_SystemImpl.gl.activeTexture(33984 + (js_Boot.__cast(texunit , kha_js_graphics4_TextureUnit)).value);
		switch(uAddressing[1]) {
		case 0:
			kha_SystemImpl.gl.texParameteri(3553,10242,10497);
			break;
		case 1:
			kha_SystemImpl.gl.texParameteri(3553,10242,33648);
			break;
		case 2:
			kha_SystemImpl.gl.texParameteri(3553,10242,33071);
			break;
		}
		switch(vAddressing[1]) {
		case 0:
			kha_SystemImpl.gl.texParameteri(3553,10243,10497);
			break;
		case 1:
			kha_SystemImpl.gl.texParameteri(3553,10243,33648);
			break;
		case 2:
			kha_SystemImpl.gl.texParameteri(3553,10243,33071);
			break;
		}
		switch(minificationFilter[1]) {
		case 0:
			switch(mipmapFilter[1]) {
			case 0:
				kha_SystemImpl.gl.texParameteri(3553,10241,9728);
				break;
			case 1:
				kha_SystemImpl.gl.texParameteri(3553,10241,9984);
				break;
			case 2:
				kha_SystemImpl.gl.texParameteri(3553,10241,9986);
				break;
			}
			break;
		case 1:case 2:
			switch(mipmapFilter[1]) {
			case 0:
				kha_SystemImpl.gl.texParameteri(3553,10241,9729);
				break;
			case 1:
				kha_SystemImpl.gl.texParameteri(3553,10241,9985);
				break;
			case 2:
				kha_SystemImpl.gl.texParameteri(3553,10241,9987);
				break;
			}
			if(minificationFilter == kha_graphics4_TextureFilter.AnisotropicFilter) {
				kha_SystemImpl.gl.texParameteri(3553,kha_SystemImpl.anisotropicFilter.TEXTURE_MAX_ANISOTROPY_EXT,4);
			}
			break;
		}
		switch(magnificationFilter[1]) {
		case 0:
			kha_SystemImpl.gl.texParameteri(3553,10240,9728);
			break;
		case 1:case 2:
			kha_SystemImpl.gl.texParameteri(3553,10240,9729);
			break;
		}
	}
	,setTexture3DParameters: function(texunit,uAddressing,vAddressing,wAddressing,minificationFilter,magnificationFilter,mipmapFilter) {
	}
	,setCubeMap: function(stage,cubeMap) {
		if(cubeMap == null) {
			kha_SystemImpl.gl.activeTexture(33984 + (js_Boot.__cast(stage , kha_js_graphics4_TextureUnit)).value);
			kha_SystemImpl.gl.bindTexture(34067,null);
		} else {
			cubeMap.set((js_Boot.__cast(stage , kha_js_graphics4_TextureUnit)).value);
		}
	}
	,setCubeMapDepth: function(stage,cubeMap) {
		cubeMap.setDepth((js_Boot.__cast(stage , kha_js_graphics4_TextureUnit)).value);
	}
	,setCullMode: function(mode) {
		switch(mode[1]) {
		case 0:
			kha_SystemImpl.gl.enable(2884);
			kha_SystemImpl.gl.cullFace(1029);
			break;
		case 1:
			kha_SystemImpl.gl.enable(2884);
			kha_SystemImpl.gl.cullFace(1028);
			break;
		case 2:
			kha_SystemImpl.gl.disable(2884);
			break;
		}
	}
	,setPipeline: function(pipe) {
		this.setCullMode(pipe.cullMode);
		this.setDepthMode(pipe.depthWrite,pipe.depthMode);
		this.setStencilParameters(pipe.stencilMode,pipe.stencilBothPass,pipe.stencilDepthFail,pipe.stencilFail,pipe.stencilReferenceValue,pipe.stencilReadMask,pipe.stencilWriteMask);
		this.setBlendingMode(pipe.blendSource,pipe.blendDestination,pipe.blendOperation,pipe.alphaBlendSource,pipe.alphaBlendDestination,pipe.alphaBlendOperation);
		pipe.set();
		this.colorMaskRed = pipe.colorWriteMaskRed;
		this.colorMaskGreen = pipe.colorWriteMaskGreen;
		this.colorMaskBlue = pipe.colorWriteMaskBlue;
		this.colorMaskAlpha = pipe.colorWriteMaskAlpha;
	}
	,setBool: function(location,value) {
		kha_SystemImpl.gl.uniform1i((js_Boot.__cast(location , kha_js_graphics4_ConstantLocation)).value,value ? 1 : 0);
	}
	,setInt: function(location,value) {
		kha_SystemImpl.gl.uniform1i((js_Boot.__cast(location , kha_js_graphics4_ConstantLocation)).value,value);
	}
	,setFloat: function(location,value) {
		kha_SystemImpl.gl.uniform1f((js_Boot.__cast(location , kha_js_graphics4_ConstantLocation)).value,value);
	}
	,setFloat2: function(location,value1,value2) {
		kha_SystemImpl.gl.uniform2f((js_Boot.__cast(location , kha_js_graphics4_ConstantLocation)).value,value1,value2);
	}
	,setFloat3: function(location,value1,value2,value3) {
		kha_SystemImpl.gl.uniform3f((js_Boot.__cast(location , kha_js_graphics4_ConstantLocation)).value,value1,value2,value3);
	}
	,setFloat4: function(location,value1,value2,value3,value4) {
		kha_SystemImpl.gl.uniform4f((js_Boot.__cast(location , kha_js_graphics4_ConstantLocation)).value,value1,value2,value3,value4);
	}
	,setFloats: function(location,values) {
		var webglLocation = js_Boot.__cast(location , kha_js_graphics4_ConstantLocation);
		var _g = webglLocation.type;
		switch(_g) {
		case 35664:
			kha_SystemImpl.gl.uniform2fv(webglLocation.value,values);
			break;
		case 35665:
			kha_SystemImpl.gl.uniform3fv(webglLocation.value,values);
			break;
		case 35666:
			kha_SystemImpl.gl.uniform4fv(webglLocation.value,values);
			break;
		default:
			kha_SystemImpl.gl.uniform1fv(webglLocation.value,values);
		}
	}
	,setVector2: function(location,value) {
		kha_SystemImpl.gl.uniform2f((js_Boot.__cast(location , kha_js_graphics4_ConstantLocation)).value,value.x,value.y);
	}
	,setVector3: function(location,value) {
		kha_SystemImpl.gl.uniform3f((js_Boot.__cast(location , kha_js_graphics4_ConstantLocation)).value,value.x,value.y,value.z);
	}
	,setVector4: function(location,value) {
		kha_SystemImpl.gl.uniform4f((js_Boot.__cast(location , kha_js_graphics4_ConstantLocation)).value,value.x,value.y,value.z,value.w);
	}
	,matrixCache: null
	,setMatrix: function(location,matrix) {
		this.matrixCache[0] = matrix._00;
		this.matrixCache[1] = matrix._01;
		this.matrixCache[2] = matrix._02;
		this.matrixCache[3] = matrix._03;
		this.matrixCache[4] = matrix._10;
		this.matrixCache[5] = matrix._11;
		this.matrixCache[6] = matrix._12;
		this.matrixCache[7] = matrix._13;
		this.matrixCache[8] = matrix._20;
		this.matrixCache[9] = matrix._21;
		this.matrixCache[10] = matrix._22;
		this.matrixCache[11] = matrix._23;
		this.matrixCache[12] = matrix._30;
		this.matrixCache[13] = matrix._31;
		this.matrixCache[14] = matrix._32;
		this.matrixCache[15] = matrix._33;
		kha_SystemImpl.gl.uniformMatrix4fv((js_Boot.__cast(location , kha_js_graphics4_ConstantLocation)).value,false,this.matrixCache);
	}
	,matrix3Cache: null
	,setMatrix3: function(location,matrix) {
		this.matrix3Cache[0] = matrix._00;
		this.matrix3Cache[1] = matrix._01;
		this.matrix3Cache[2] = matrix._02;
		this.matrix3Cache[3] = matrix._10;
		this.matrix3Cache[4] = matrix._11;
		this.matrix3Cache[5] = matrix._12;
		this.matrix3Cache[6] = matrix._20;
		this.matrix3Cache[7] = matrix._21;
		this.matrix3Cache[8] = matrix._22;
		kha_SystemImpl.gl.uniformMatrix3fv((js_Boot.__cast(location , kha_js_graphics4_ConstantLocation)).value,false,this.matrix3Cache);
	}
	,drawIndexedVertices: function(start,count) {
		if(count == null) {
			count = -1;
		}
		if(start == null) {
			start = 0;
		}
		var type = kha_SystemImpl.elementIndexUint == null ? 5123 : 5125;
		var size = type == 5123 ? 2 : 4;
		kha_SystemImpl.gl.drawElements(4,count == -1 ? this.indicesCount : count,type,start * size);
	}
	,convertStencilAction: function(action) {
		switch(action[1]) {
		case 0:
			return 7680;
		case 1:
			return 0;
		case 2:
			return 7681;
		case 3:
			return 7682;
		case 4:
			return 34055;
		case 5:
			return 7683;
		case 6:
			return 34056;
		case 7:
			return 5386;
		}
	}
	,setStencilParameters: function(compareMode,bothPass,depthFail,stencilFail,referenceValue,readMask,writeMask) {
		if(writeMask == null) {
			writeMask = 255;
		}
		if(readMask == null) {
			readMask = 255;
		}
		if(compareMode == kha_graphics4_CompareMode.Always && bothPass == kha_graphics4_StencilAction.Keep && depthFail == kha_graphics4_StencilAction.Keep && stencilFail == kha_graphics4_StencilAction.Keep) {
			kha_SystemImpl.gl.disable(2960);
		} else {
			kha_SystemImpl.gl.enable(2960);
			var stencilFunc = 0;
			switch(compareMode[1]) {
			case 0:
				stencilFunc = 519;
				break;
			case 1:
				stencilFunc = 512;
				break;
			case 2:
				stencilFunc = 514;
				break;
			case 3:
				stencilFunc = 517;
				break;
			case 4:
				stencilFunc = 513;
				break;
			case 5:
				stencilFunc = 515;
				break;
			case 6:
				stencilFunc = 516;
				break;
			case 7:
				stencilFunc = 518;
				break;
			}
			kha_SystemImpl.gl.stencilMask(writeMask);
			kha_SystemImpl.gl.stencilOp(this.convertStencilAction(stencilFail),this.convertStencilAction(depthFail),this.convertStencilAction(bothPass));
			kha_SystemImpl.gl.stencilFunc(stencilFunc,referenceValue,readMask);
		}
	}
	,scissor: function(x,y,width,height) {
		kha_SystemImpl.gl.enable(3089);
		if(this.renderTarget == null) {
			kha_SystemImpl.gl.scissor(x,kha_System.windowHeight(0) - y - height,width,height);
		} else {
			kha_SystemImpl.gl.scissor(x,y,width,height);
		}
	}
	,disableScissor: function() {
		kha_SystemImpl.gl.disable(3089);
	}
	,renderTargetsInvertedY: function() {
		return true;
	}
	,drawIndexedVerticesInstanced: function(instanceCount,start,count) {
		if(count == null) {
			count = -1;
		}
		if(start == null) {
			start = 0;
		}
		if(this.instancedRenderingAvailable()) {
			var type = kha_SystemImpl.elementIndexUint == null ? 5123 : 5125;
			var typeSize = kha_SystemImpl.elementIndexUint == null ? 2 : 4;
			if(kha_SystemImpl.gl2) {
				kha_SystemImpl.gl.drawElementsInstanced(4,count == -1 ? this.indicesCount : count,type,start * typeSize,instanceCount);
			} else {
				this.instancedExtension.drawElementsInstancedANGLE(4,count == -1 ? this.indicesCount : count,type,start * typeSize,instanceCount);
			}
		}
	}
	,instancedRenderingAvailable: function() {
		return this.instancedExtension;
	}
	,__class__: kha_js_graphics4_Graphics
};
var kha_js_graphics4_Graphics2 = function(canvas) {
	kha_graphics4_Graphics2.call(this,canvas);
};
$hxClasses["kha.js.graphics4.Graphics2"] = kha_js_graphics4_Graphics2;
kha_js_graphics4_Graphics2.__name__ = true;
kha_js_graphics4_Graphics2.__super__ = kha_graphics4_Graphics2;
kha_js_graphics4_Graphics2.prototype = $extend(kha_graphics4_Graphics2.prototype,{
	drawVideoInternal: function(video,x,y,width,height) {
		var v = js_Boot.__cast(video , kha_js_Video);
		this.drawScaledSubImage(v.texture,0,0,v.texture.get_width(),v.texture.get_height(),x,y,width,height);
	}
	,begin: function(clear,clearColor) {
		if(clear == null) {
			clear = true;
		}
		kha_SystemImpl.gl.colorMask(true,true,true,true);
		kha_SystemImpl.gl.disable(2929);
		kha_SystemImpl.gl.depthFunc(519);
		kha_graphics4_Graphics2.prototype.begin.call(this,clear,clearColor);
	}
	,__class__: kha_js_graphics4_Graphics2
});
var kha_js_graphics4_TextureUnit = function(value) {
	this.value = value;
};
$hxClasses["kha.js.graphics4.TextureUnit"] = kha_js_graphics4_TextureUnit;
kha_js_graphics4_TextureUnit.__name__ = true;
kha_js_graphics4_TextureUnit.__interfaces__ = [kha_graphics4_TextureUnit];
kha_js_graphics4_TextureUnit.prototype = {
	value: null
	,__class__: kha_js_graphics4_TextureUnit
};
var kha_vr_VrInterface = function() {
};
$hxClasses["kha.vr.VrInterface"] = kha_vr_VrInterface;
kha_vr_VrInterface.__name__ = true;
kha_vr_VrInterface.prototype = {
	GetSensorState: function() {
		return null;
	}
	,GetPredictedSensorState: function(time) {
		return null;
	}
	,WarpSwapBlack: function() {
		return;
	}
	,WarpSwapLoadingIcon: function() {
		return;
	}
	,WarpSwap: function(parms) {
		return;
	}
	,IsPresenting: function() {
		return false;
	}
	,IsVrEnabled: function() {
		return false;
	}
	,GetTimeInSeconds: function() {
		return 0.0;
	}
	,GetProjectionMatrix: function(eye) {
		return null;
	}
	,GetViewMatrix: function(eye) {
		return null;
	}
	,onVRRequestPresent: function() {
		return;
	}
	,onVRExitPresent: function() {
		return;
	}
	,onResetPose: function() {
		return;
	}
	,__class__: kha_vr_VrInterface
};
var kha_js_vr_VrInterface = function() {
	this.vrHeight = 0;
	this.vrWidth = 0;
	this.height = 0;
	this.width = 0;
	this.rightViewMatrix = new kha_math_FastMatrix4(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);
	this.leftViewMatrix = new kha_math_FastMatrix4(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);
	this.rightProjectionMatrix = new kha_math_FastMatrix4(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);
	this.leftProjectionMatrix = new kha_math_FastMatrix4(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);
	this.vrEnabled = false;
	kha_vr_VrInterface.call(this);
	var displayEnabled = false;
	if(displayEnabled) {
		this.vrEnabled = true;
		this.getVRDisplays();
		haxe_Log.trace("Display enabled.",{ fileName : "VrInterface.hx", lineNumber : 39, className : "kha.js.vr.VrInterface", methodName : "new"});
	}
};
$hxClasses["kha.js.vr.VrInterface"] = kha_js_vr_VrInterface;
kha_js_vr_VrInterface.__name__ = true;
kha_js_vr_VrInterface.__super__ = kha_vr_VrInterface;
kha_js_vr_VrInterface.prototype = $extend(kha_vr_VrInterface.prototype,{
	vrEnabled: null
	,vrDisplay: null
	,frameData: null
	,leftProjectionMatrix: null
	,rightProjectionMatrix: null
	,leftViewMatrix: null
	,rightViewMatrix: null
	,width: null
	,height: null
	,vrWidth: null
	,vrHeight: null
	,getVRDisplays: function() {
		var _gthis = this;
		var vrDisplayInstance = navigator.getVRDisplays();
		vrDisplayInstance.then(function(displays) {
			if(displays.length > 0) {
				_gthis.frameData = new VRFrameData();
				_gthis.vrDisplay = displays[0];
				_gthis.vrDisplay.depthNear = 0.1;
				_gthis.vrDisplay.depthFar = 1024.0;
				var leftEye = _gthis.vrDisplay.getEyeParameters("left");
				var rightEye = _gthis.vrDisplay.getEyeParameters("right");
				_gthis.width = kha_SystemImpl.khanvas.width;
				_gthis.height = kha_SystemImpl.khanvas.height;
				_gthis.vrWidth = Math.max(leftEye.renderWidth,rightEye.renderWidth) * 2 | 0;
				_gthis.vrHeight = Math.max(leftEye.renderHeight,rightEye.renderHeight) | 0;
			} else {
				haxe_Log.trace("There are no VR displays connected.",{ fileName : "VrInterface.hx", lineNumber : 59, className : "kha.js.vr.VrInterface", methodName : "getVRDisplays"});
			}
		});
	}
	,onVRRequestPresent: function() {
		var _gthis = this;
		try {
			this.vrDisplay.requestPresent([{ source : kha_SystemImpl.khanvas}]).then(function() {
				_gthis.onResize();
				_gthis.vrDisplay.requestAnimationFrame($bind(_gthis,_gthis.onAnimationFrame));
			});
		} catch( err ) {
			if (err instanceof js__$Boot_HaxeError) err = err.val;
			haxe_Log.trace("Failed to requestPresent.",{ fileName : "VrInterface.hx", lineNumber : 71, className : "kha.js.vr.VrInterface", methodName : "onVRRequestPresent"});
			haxe_Log.trace(err,{ fileName : "VrInterface.hx", lineNumber : 72, className : "kha.js.vr.VrInterface", methodName : "onVRRequestPresent"});
		}
	}
	,onVRExitPresent: function() {
		var _gthis = this;
		try {
			this.vrDisplay.exitPresent([{ source : kha_SystemImpl.khanvas}]).then(function() {
				_gthis.onResize();
			});
		} catch( err ) {
			if (err instanceof js__$Boot_HaxeError) err = err.val;
			haxe_Log.trace("Failed to exitPresent.",{ fileName : "VrInterface.hx", lineNumber : 82, className : "kha.js.vr.VrInterface", methodName : "onVRExitPresent"});
			haxe_Log.trace(err,{ fileName : "VrInterface.hx", lineNumber : 83, className : "kha.js.vr.VrInterface", methodName : "onVRExitPresent"});
		}
	}
	,onResetPose: function() {
		try {
			this.vrDisplay.resetPose();
		} catch( err ) {
			if (err instanceof js__$Boot_HaxeError) err = err.val;
			haxe_Log.trace("Failed to resetPose",{ fileName : "VrInterface.hx", lineNumber : 91, className : "kha.js.vr.VrInterface", methodName : "onResetPose"});
			haxe_Log.trace(err,{ fileName : "VrInterface.hx", lineNumber : 92, className : "kha.js.vr.VrInterface", methodName : "onResetPose"});
		}
	}
	,onAnimationFrame: function(timestamp) {
		if(this.vrDisplay != null && this.vrDisplay.isPresenting) {
			this.vrDisplay.requestAnimationFrame($bind(this,this.onAnimationFrame));
			this.vrDisplay.getFrameData(this.frameData);
			this.leftProjectionMatrix = this.createMatrixFromArray(this.frameData.leftProjectionMatrix);
			this.leftViewMatrix = this.createMatrixFromArray(this.frameData.leftViewMatrix);
			this.rightProjectionMatrix = this.createMatrixFromArray(this.frameData.rightProjectionMatrix);
			this.rightViewMatrix = this.createMatrixFromArray(this.frameData.rightViewMatrix);
			this.vrDisplay.submitFrame();
		}
	}
	,onResize: function() {
		if(this.vrDisplay != null && this.vrDisplay.isPresenting) {
			kha_SystemImpl.khanvas.width = this.vrWidth;
			kha_SystemImpl.khanvas.height = this.vrHeight;
		} else {
			kha_SystemImpl.khanvas.width = this.width;
			kha_SystemImpl.khanvas.height = this.height;
		}
	}
	,GetSensorState: function() {
		return this.GetPredictedSensorState(0.0);
	}
	,GetPredictedSensorState: function(time) {
		var result = new kha_vr_SensorState();
		result.Predicted = new kha_vr_PoseState();
		result.Recorded = result.Predicted;
		result.Predicted.AngularAcceleration = new kha_math_Vector3();
		result.Predicted.AngularVelocity = new kha_math_Vector3();
		result.Predicted.LinearAcceleration = new kha_math_Vector3();
		result.Predicted.LinearVelocity = new kha_math_Vector3();
		result.Predicted.TimeInSeconds = time;
		result.Predicted.Pose = new kha_vr_Pose();
		result.Predicted.Pose.Orientation = new kha_math_Quaternion();
		result.Predicted.Pose.Position = new kha_math_Vector3();
		var mPose = this.frameData.pose;
		if(mPose != null) {
			result.Predicted.AngularVelocity = this.createVectorFromArray(mPose.angularVelocity);
			result.Predicted.AngularAcceleration = this.createVectorFromArray(mPose.angularAcceleration);
			result.Predicted.LinearVelocity = this.createVectorFromArray(mPose.linearVelocity);
			result.Predicted.LinearAcceleration = this.createVectorFromArray(mPose.linearAcceleration);
			result.Predicted.Pose.Orientation = this.createQuaternion(mPose.orientation);
			result.Predicted.Pose.Position = this.createVectorFromArray(mPose.position);
		}
		return result;
	}
	,WarpSwapBlack: function() {
	}
	,WarpSwapLoadingIcon: function() {
	}
	,WarpSwap: function(parms) {
	}
	,IsPresenting: function() {
		if(this.vrDisplay != null) {
			return this.vrDisplay.isPresenting;
		}
		return false;
	}
	,IsVrEnabled: function() {
		return this.vrEnabled;
	}
	,GetTimeInSeconds: function() {
		return kha_Scheduler.time();
	}
	,GetProjectionMatrix: function(eye) {
		if(eye == 0) {
			return this.leftProjectionMatrix;
		} else {
			return this.rightProjectionMatrix;
		}
	}
	,GetViewMatrix: function(eye) {
		if(eye == 0) {
			return this.leftViewMatrix;
		} else {
			return this.rightViewMatrix;
		}
	}
	,createMatrixFromArray: function(array) {
		var matrix = new kha_math_FastMatrix4(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);
		matrix._00 = array[0];
		matrix._01 = array[1];
		matrix._02 = array[2];
		matrix._03 = array[3];
		matrix._10 = array[4];
		matrix._11 = array[5];
		matrix._12 = array[6];
		matrix._13 = array[7];
		matrix._20 = array[8];
		matrix._21 = array[9];
		matrix._22 = array[10];
		matrix._23 = array[11];
		matrix._30 = array[12];
		matrix._31 = array[13];
		matrix._32 = array[14];
		matrix._33 = array[15];
		return matrix;
	}
	,createVectorFromArray: function(array) {
		var vector = new kha_math_Vector3(0,0,0);
		if(array != null) {
			vector.x = array[0];
			vector.y = array[1];
			vector.z = array[2];
		}
		return vector;
	}
	,createQuaternion: function(array) {
		var quaternion = new kha_math_Quaternion(0,0,0,0);
		if(array != null) {
			quaternion.set_x(array[0]);
			quaternion.set_y(array[1]);
			quaternion.set_z(array[2]);
			quaternion.set_w(array[3]);
		}
		return quaternion;
	}
	,__class__: kha_js_vr_VrInterface
});
var kha_math_FastMatrix3 = function(_00,_10,_20,_01,_11,_21,_02,_12,_22) {
	this._00 = _00;
	this._10 = _10;
	this._20 = _20;
	this._01 = _01;
	this._11 = _11;
	this._21 = _21;
	this._02 = _02;
	this._12 = _12;
	this._22 = _22;
};
$hxClasses["kha.math.FastMatrix3"] = kha_math_FastMatrix3;
kha_math_FastMatrix3.__name__ = true;
kha_math_FastMatrix3.fromMatrix3 = function(m) {
	return new kha_math_FastMatrix3(m._00,m._10,m._20,m._01,m._11,m._21,m._02,m._12,m._22);
};
kha_math_FastMatrix3.prototype = {
	_00: null
	,_10: null
	,_20: null
	,_01: null
	,_11: null
	,_21: null
	,_02: null
	,_12: null
	,_22: null
	,__class__: kha_math_FastMatrix3
};
var kha_math_FastMatrix4 = function(_00,_10,_20,_30,_01,_11,_21,_31,_02,_12,_22,_32,_03,_13,_23,_33) {
	this._00 = _00;
	this._10 = _10;
	this._20 = _20;
	this._30 = _30;
	this._01 = _01;
	this._11 = _11;
	this._21 = _21;
	this._31 = _31;
	this._02 = _02;
	this._12 = _12;
	this._22 = _22;
	this._32 = _32;
	this._03 = _03;
	this._13 = _13;
	this._23 = _23;
	this._33 = _33;
};
$hxClasses["kha.math.FastMatrix4"] = kha_math_FastMatrix4;
kha_math_FastMatrix4.__name__ = true;
kha_math_FastMatrix4.fromMatrix4 = function(m) {
	return new kha_math_FastMatrix4(m._00,m._10,m._20,m._30,m._01,m._11,m._21,m._31,m._02,m._12,m._22,m._32,m._03,m._13,m._23,m._33);
};
kha_math_FastMatrix4.orthogonalProjection = function(left,right,bottom,top,zn,zf) {
	var tx = -(right + left) / (right - left);
	var ty = -(top + bottom) / (top - bottom);
	var tz = -(zf + zn) / (zf - zn);
	return new kha_math_FastMatrix4(2 / (right - left),0,0,tx,0,2 / (top - bottom),0,ty,0,0,-2 / (zf - zn),tz,0,0,0,1);
};
kha_math_FastMatrix4.perspectiveProjection = function(fovY,aspect,zn,zf) {
	var uh = 1.0 / Math.tan(fovY / 2);
	var uw = uh / aspect;
	return new kha_math_FastMatrix4(uw,0,0,0,0,uh,0,0,0,0,(zf + zn) / (zn - zf),2 * zf * zn / (zn - zf),0,0,-1,0);
};
kha_math_FastMatrix4.lookAt = function(eye,at,up) {
	var zaxis = new kha_math_FastVector3(at.x - eye.x,at.y - eye.y,at.z - eye.z);
	zaxis.set_length(1);
	var _x = zaxis.y * up.z - zaxis.z * up.y;
	var _y = zaxis.z * up.x - zaxis.x * up.z;
	var _z = zaxis.x * up.y - zaxis.y * up.x;
	var xaxis = new kha_math_FastVector3(_x,_y,_z);
	xaxis.set_length(1);
	var yaxis_z;
	var yaxis_y;
	var yaxis_x;
	var _x1 = xaxis.y * zaxis.z - xaxis.z * zaxis.y;
	var _y1 = xaxis.z * zaxis.x - xaxis.x * zaxis.z;
	var _z1 = xaxis.x * zaxis.y - xaxis.y * zaxis.x;
	yaxis_x = _x1;
	yaxis_y = _y1;
	yaxis_z = _z1;
	return new kha_math_FastMatrix4(xaxis.x,xaxis.y,xaxis.z,-(xaxis.x * eye.x + xaxis.y * eye.y + xaxis.z * eye.z),yaxis_x,yaxis_y,yaxis_z,-(yaxis_x * eye.x + yaxis_y * eye.y + yaxis_z * eye.z),-zaxis.x,-zaxis.y,-zaxis.z,zaxis.x * eye.x + zaxis.y * eye.y + zaxis.z * eye.z,0,0,0,1);
};
kha_math_FastMatrix4.prototype = {
	_00: null
	,_10: null
	,_20: null
	,_30: null
	,_01: null
	,_11: null
	,_21: null
	,_31: null
	,_02: null
	,_12: null
	,_22: null
	,_32: null
	,_03: null
	,_13: null
	,_23: null
	,_33: null
	,__class__: kha_math_FastMatrix4
};
var kha_math_FastVector2 = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
};
$hxClasses["kha.math.FastVector2"] = kha_math_FastVector2;
kha_math_FastVector2.__name__ = true;
kha_math_FastVector2.fromVector2 = function(v) {
	return new kha_math_FastVector2(v.x,v.y);
};
kha_math_FastVector2.prototype = {
	x: null
	,y: null
	,get_length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}
	,set_length: function(length) {
		var currentLength = this.get_length();
		if(currentLength == 0) {
			return 0;
		}
		var mul = length / currentLength;
		this.x *= mul;
		this.y *= mul;
		return length;
	}
	,toString: function() {
		return "FastVector2(" + this.x + ", " + this.y + ")";
	}
	,__class__: kha_math_FastVector2
};
var kha_math_FastVector3 = function(x,y,z) {
	if(z == null) {
		z = 0;
	}
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
	this.z = z;
};
$hxClasses["kha.math.FastVector3"] = kha_math_FastVector3;
kha_math_FastVector3.__name__ = true;
kha_math_FastVector3.fromVector3 = function(v) {
	return new kha_math_FastVector3(v.x,v.y,v.z);
};
kha_math_FastVector3.prototype = {
	x: null
	,y: null
	,z: null
	,get_length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	}
	,set_length: function(length) {
		var currentLength = this.get_length();
		if(currentLength == 0) {
			return 0;
		}
		var mul = length / currentLength;
		this.x *= mul;
		this.y *= mul;
		this.z *= mul;
		return length;
	}
	,toString: function() {
		return "FastVector3(" + this.x + ", " + this.y + ", " + this.z + ")";
	}
	,__class__: kha_math_FastVector3
};
var kha_math_FastVector4 = function(x,y,z,w) {
	if(w == null) {
		w = 1;
	}
	if(z == null) {
		z = 0;
	}
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
	this.z = z;
	this.w = w;
};
$hxClasses["kha.math.FastVector4"] = kha_math_FastVector4;
kha_math_FastVector4.__name__ = true;
kha_math_FastVector4.fromVector4 = function(v) {
	return new kha_math_FastVector4(v.x,v.y,v.z,v.w);
};
kha_math_FastVector4.prototype = {
	x: null
	,y: null
	,z: null
	,w: null
	,get_length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	}
	,set_length: function(length) {
		var currentLength = this.get_length();
		if(currentLength == 0) {
			return 0;
		}
		var mul = length / currentLength;
		this.x *= mul;
		this.y *= mul;
		this.z *= mul;
		this.w *= mul;
		return length;
	}
	,toString: function() {
		return "FastVector4(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
	}
	,__class__: kha_math_FastVector4
};
var kha_math_Matrix3 = function(_00,_10,_20,_01,_11,_21,_02,_12,_22) {
	this._00 = _00;
	this._10 = _10;
	this._20 = _20;
	this._01 = _01;
	this._11 = _11;
	this._21 = _21;
	this._02 = _02;
	this._12 = _12;
	this._22 = _22;
};
$hxClasses["kha.math.Matrix3"] = kha_math_Matrix3;
kha_math_Matrix3.__name__ = true;
kha_math_Matrix3.prototype = {
	_00: null
	,_10: null
	,_20: null
	,_01: null
	,_11: null
	,_21: null
	,_02: null
	,_12: null
	,_22: null
	,__class__: kha_math_Matrix3
};
var kha_math_Matrix4 = function(_00,_10,_20,_30,_01,_11,_21,_31,_02,_12,_22,_32,_03,_13,_23,_33) {
	this._00 = _00;
	this._10 = _10;
	this._20 = _20;
	this._30 = _30;
	this._01 = _01;
	this._11 = _11;
	this._21 = _21;
	this._31 = _31;
	this._02 = _02;
	this._12 = _12;
	this._22 = _22;
	this._32 = _32;
	this._03 = _03;
	this._13 = _13;
	this._23 = _23;
	this._33 = _33;
};
$hxClasses["kha.math.Matrix4"] = kha_math_Matrix4;
kha_math_Matrix4.__name__ = true;
kha_math_Matrix4.orthogonalProjection = function(left,right,bottom,top,zn,zf) {
	var tx = -(right + left) / (right - left);
	var ty = -(top + bottom) / (top - bottom);
	var tz = -(zf + zn) / (zf - zn);
	return new kha_math_Matrix4(2 / (right - left),0,0,tx,0,2 / (top - bottom),0,ty,0,0,-2 / (zf - zn),tz,0,0,0,1);
};
kha_math_Matrix4.perspectiveProjection = function(fovY,aspect,zn,zf) {
	var uh = 1.0 / Math.tan(fovY / 2);
	var uw = uh / aspect;
	return new kha_math_Matrix4(uw,0,0,0,0,uh,0,0,0,0,(zf + zn) / (zn - zf),2 * zf * zn / (zn - zf),0,0,-1,0);
};
kha_math_Matrix4.lookAt = function(eye,at,up) {
	var zaxis = new kha_math_Vector3(at.x - eye.x,at.y - eye.y,at.z - eye.z);
	zaxis.set_length(1);
	var _x = zaxis.y * up.z - zaxis.z * up.y;
	var _y = zaxis.z * up.x - zaxis.x * up.z;
	var _z = zaxis.x * up.y - zaxis.y * up.x;
	var xaxis = new kha_math_Vector3(_x,_y,_z);
	xaxis.set_length(1);
	var yaxis_z;
	var yaxis_y;
	var yaxis_x;
	var _x1 = xaxis.y * zaxis.z - xaxis.z * zaxis.y;
	var _y1 = xaxis.z * zaxis.x - xaxis.x * zaxis.z;
	var _z1 = xaxis.x * zaxis.y - xaxis.y * zaxis.x;
	yaxis_x = _x1;
	yaxis_y = _y1;
	yaxis_z = _z1;
	return new kha_math_Matrix4(xaxis.x,xaxis.y,xaxis.z,-(xaxis.x * eye.x + xaxis.y * eye.y + xaxis.z * eye.z),yaxis_x,yaxis_y,yaxis_z,-(yaxis_x * eye.x + yaxis_y * eye.y + yaxis_z * eye.z),-zaxis.x,-zaxis.y,-zaxis.z,zaxis.x * eye.x + zaxis.y * eye.y + zaxis.z * eye.z,0,0,0,1);
};
kha_math_Matrix4.prototype = {
	_00: null
	,_10: null
	,_20: null
	,_30: null
	,_01: null
	,_11: null
	,_21: null
	,_31: null
	,_02: null
	,_12: null
	,_22: null
	,_32: null
	,_03: null
	,_13: null
	,_23: null
	,_33: null
	,__class__: kha_math_Matrix4
};
var kha_math_Quaternion = function(x,y,z,w) {
	if(w == null) {
		w = 1;
	}
	if(z == null) {
		z = 0;
	}
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.values = [];
	this.values.push(x);
	this.values.push(y);
	this.values.push(z);
	this.values.push(w);
};
$hxClasses["kha.math.Quaternion"] = kha_math_Quaternion;
kha_math_Quaternion.__name__ = true;
kha_math_Quaternion.fromAxisAngle = function(axis,radians) {
	var q = new kha_math_Quaternion();
	q.set_w(Math.cos(radians / 2.0));
	q.set_x(q.set_y(q.set_z(Math.sin(radians / 2.0))));
	var _g = q;
	_g.set_x(_g.get_x() * axis.x);
	var _g1 = q;
	_g1.set_y(_g1.get_y() * axis.y);
	var _g2 = q;
	_g2.set_z(_g2.get_z() * axis.z);
	return q;
};
kha_math_Quaternion.prototype = {
	values: null
	,slerp: function(t,q) {
		var epsilon = 0.0005;
		var dot = this.dot(q);
		if(dot > 1 - epsilon) {
			var result = q.add(this.sub(q).scaled(t));
			result.normalize();
			return result;
		}
		if(dot < 0) {
			dot = 0;
		}
		if(dot > 1) {
			dot = 1;
		}
		var theta0 = Math.acos(dot);
		var theta = theta0 * t;
		var q2 = q.sub(this.scaled(dot));
		q2.normalize();
		var result1 = this.scaled(Math.cos(theta)).add(q2.scaled(Math.sin(theta)));
		result1.normalize();
		return result1;
	}
	,rotated: function(b) {
		var q = new kha_math_Quaternion();
		q.set_w(this.get_w() * b.get_w() - this.get_x() * b.get_x() - this.get_y() * b.get_y() - this.get_z() * b.get_z());
		q.set_x(this.get_w() * b.get_x() + this.get_x() * b.get_w() + this.get_y() * b.get_z() - this.get_z() * b.get_y());
		q.set_y(this.get_w() * b.get_y() + this.get_y() * b.get_w() + this.get_z() * b.get_x() - this.get_x() * b.get_z());
		q.set_z(this.get_w() * b.get_z() + this.get_z() * b.get_w() + this.get_x() * b.get_y() - this.get_y() * b.get_x());
		q.normalize();
		return q;
	}
	,scaled: function(scale) {
		return new kha_math_Quaternion(this.get_x() * scale,this.get_y() * scale,this.get_z() * scale,this.get_w() * scale);
	}
	,scale: function(scale) {
		this.set_x(this.get_x() * scale);
		this.set_y(this.get_y() * scale);
		this.set_z(this.get_z() * scale);
		this.set_w(this.get_w() * scale);
	}
	,matrix: function() {
		var s = 2.0;
		var xs = this.get_x() * s;
		var ys = this.get_y() * s;
		var zs = this.get_z() * s;
		var wx = this.get_w() * xs;
		var wy = this.get_w() * ys;
		var wz = this.get_w() * zs;
		var xx = this.get_x() * xs;
		var xy = this.get_x() * ys;
		var xz = this.get_x() * zs;
		var yy = this.get_y() * ys;
		var yz = this.get_y() * zs;
		var zz = this.get_z() * zs;
		return new kha_math_Matrix4(1 - (yy + zz),xy - wz,xz + wy,0,xy + wz,1 - (xx + zz),yz - wx,0,xz - wy,yz + wx,1 - (xx + yy),0,0,0,0,1);
	}
	,get: function(index) {
		return this.values[index];
	}
	,set: function(index,value) {
		this.values[index] = value;
	}
	,get_x: function() {
		return this.values[0];
	}
	,set_x: function(value) {
		return this.values[0] = value;
	}
	,get_y: function() {
		return this.values[1];
	}
	,set_y: function(value) {
		return this.values[1] = value;
	}
	,get_z: function() {
		return this.values[2];
	}
	,set_z: function(value) {
		return this.values[2] = value;
	}
	,get_w: function() {
		return this.values[3];
	}
	,set_w: function(value) {
		return this.values[3] = value;
	}
	,get_length: function() {
		return Math.sqrt(this.get_x() * this.get_x() + this.get_y() * this.get_y() + this.get_z() * this.get_z() + this.get_w() * this.get_w());
	}
	,set_length: function(length) {
		if(this.get_length() == 0) {
			return 0;
		}
		var mul = length / this.get_length();
		var _g = this;
		_g.set_x(_g.get_x() * mul);
		var _g1 = this;
		_g1.set_y(_g1.get_y() * mul);
		var _g2 = this;
		_g2.set_z(_g2.get_z() * mul);
		return length;
	}
	,addVector: function(vec) {
		var result = new kha_math_Quaternion(this.get_x(),this.get_y(),this.get_z(),this.get_w());
		var q1 = new kha_math_Quaternion(0,vec.x,vec.y,vec.z);
		q1 = q1.mult(result);
		var _g = result;
		_g.set_x(_g.get_x() + q1.get_x() * 0.5);
		var _g1 = result;
		_g1.set_y(_g1.get_y() + q1.get_y() * 0.5);
		var _g2 = result;
		_g2.set_z(_g2.get_z() + q1.get_z() * 0.5);
		var _g3 = result;
		_g3.set_w(_g3.get_w() + q1.get_w() * 0.5);
		return result;
	}
	,add: function(q) {
		return new kha_math_Quaternion(this.get_x() + q.get_x(),this.get_y() + q.get_y(),this.get_z() + q.get_z(),this.get_w() + q.get_w());
	}
	,sub: function(q) {
		return new kha_math_Quaternion(this.get_x() - q.get_x(),this.get_y() - q.get_y(),this.get_z() - q.get_z(),this.get_w() - q.get_w());
	}
	,mult: function(r) {
		var q = new kha_math_Quaternion();
		q.set_x(this.get_w() * r.get_x() + this.get_x() * r.get_w() + this.get_y() * r.get_z() - this.get_z() * r.get_y());
		q.set_y(this.get_w() * r.get_y() - this.get_x() * r.get_z() + this.get_y() * r.get_w() + this.get_z() * r.get_x());
		q.set_z(this.get_w() * r.get_z() + this.get_x() * r.get_y() - this.get_y() * r.get_x() + this.get_z() * r.get_w());
		q.set_w(this.get_w() * r.get_w() - this.get_x() * r.get_x() - this.get_y() * r.get_y() - this.get_z() * r.get_z());
		return q;
	}
	,normalize: function() {
		this.scale(1.0 / this.get_length());
	}
	,dot: function(q) {
		return this.get_x() * q.get_x() + this.get_y() * q.get_y() + this.get_z() * q.get_z() + this.get_w() * q.get_w();
	}
	,getEulerAngles: function(A1,A2,A3,S,D) {
		if(D == null) {
			D = 1;
		}
		if(S == null) {
			S = 1;
		}
		var result = new kha_math_Vector3();
		var Q = [];
		Q[0] = this.get_x();
		Q[1] = this.get_y();
		Q[2] = this.get_z();
		var ww = this.get_w() * this.get_w();
		var Q11 = Q[A1] * Q[A1];
		var Q22 = Q[A2] * Q[A2];
		var Q33 = Q[A3] * Q[A3];
		var psign = -1;
		var SingularityRadius = 0.0000001;
		var PiOver2 = Math.PI / 2.0;
		if((A1 + 1) % 3 == A2 && (A2 + 1) % 3 == A3) {
			psign = 1;
		}
		var s2 = psign * 2.0 * (psign * this.get_w() * Q[A2] + Q[A1] * Q[A3]);
		if(s2 < -1 + SingularityRadius) {
			result.x = 0;
			result.y = -S * D * PiOver2;
			result.z = S * D * Math.atan2(2 * (psign * Q[A1] * Q[A2] + this.get_w() * Q[A3]),ww + Q22 - Q11 - Q33);
		} else if(s2 > 1 - SingularityRadius) {
			result.x = 0;
			result.y = S * D * PiOver2;
			result.z = S * D * Math.atan2(2 * (psign * Q[A1] * Q[A2] + this.get_w() * Q[A3]),ww + Q22 - Q11 - Q33);
		} else {
			result.x = -S * D * Math.atan2(-2 * (this.get_w() * Q[A1] - psign * Q[A2] * Q[A3]),ww + Q33 - Q11 - Q22);
			result.y = S * D * Math.asin(s2);
			result.z = S * D * Math.atan2(2 * (this.get_w() * Q[A3] - psign * Q[A1] * Q[A2]),ww + Q11 - Q22 - Q33);
		}
		return result;
	}
	,__class__: kha_math_Quaternion
};
var kha_math_Vector2 = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
};
$hxClasses["kha.math.Vector2"] = kha_math_Vector2;
kha_math_Vector2.__name__ = true;
kha_math_Vector2.prototype = {
	x: null
	,y: null
	,get_length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}
	,set_length: function(length) {
		var currentLength = this.get_length();
		if(currentLength == 0) {
			return 0;
		}
		var mul = length / currentLength;
		this.x *= mul;
		this.y *= mul;
		return length;
	}
	,__class__: kha_math_Vector2
};
var kha_math_Vector3 = function(x,y,z) {
	if(z == null) {
		z = 0;
	}
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
	this.z = z;
};
$hxClasses["kha.math.Vector3"] = kha_math_Vector3;
kha_math_Vector3.__name__ = true;
kha_math_Vector3.prototype = {
	x: null
	,y: null
	,z: null
	,get_length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	}
	,set_length: function(length) {
		var currentLength = this.get_length();
		if(currentLength == 0) {
			return 0;
		}
		var mul = length / currentLength;
		this.x *= mul;
		this.y *= mul;
		this.z *= mul;
		return length;
	}
	,__class__: kha_math_Vector3
};
var kha_math_Vector4 = function(x,y,z,w) {
	if(w == null) {
		w = 1;
	}
	if(z == null) {
		z = 0;
	}
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
	this.z = z;
	this.w = w;
};
$hxClasses["kha.math.Vector4"] = kha_math_Vector4;
kha_math_Vector4.__name__ = true;
kha_math_Vector4.prototype = {
	x: null
	,y: null
	,z: null
	,w: null
	,get_length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	}
	,set_length: function(length) {
		var currentLength = this.get_length();
		if(currentLength == 0) {
			return 0;
		}
		var mul = length / currentLength;
		this.x *= mul;
		this.y *= mul;
		this.z *= mul;
		this.w *= mul;
		return length;
	}
	,__class__: kha_math_Vector4
};
var kha_network_Client = function() { };
$hxClasses["kha.network.Client"] = kha_network_Client;
kha_network_Client.__name__ = true;
kha_network_Client.prototype = {
	get_id: null
	,id: null
	,send: null
	,receive: null
	,onClose: null
	,__class__: kha_network_Client
};
var kha_network_ControllerBuilder = function() { };
$hxClasses["kha.network.ControllerBuilder"] = kha_network_ControllerBuilder;
kha_network_ControllerBuilder.__name__ = true;
var kha_network_Entity = function() { };
$hxClasses["kha.network.Entity"] = kha_network_Entity;
kha_network_Entity.__name__ = true;
kha_network_Entity.prototype = {
	_id: null
	,_size: null
	,_send: null
	,_receive: null
	,__class__: kha_network_Entity
};
var kha_network_LocalClient = function(id) {
	this.myId = id;
};
$hxClasses["kha.network.LocalClient"] = kha_network_LocalClient;
kha_network_LocalClient.__name__ = true;
kha_network_LocalClient.__interfaces__ = [kha_network_Client];
kha_network_LocalClient.prototype = {
	myId: null
	,send: function(bytes,mandatory) {
	}
	,receive: function(receiver) {
	}
	,onClose: function(close) {
	}
	,controllers: null
	,get_controllers: function() {
		return null;
	}
	,id: null
	,get_id: function() {
		return this.myId;
	}
	,__class__: kha_network_LocalClient
};
var kha_network_Network = function(url,port,errorCallback,closeCallback) {
	this.open = false;
	var _gthis = this;
	this.socket = new WebSocket("ws://" + url + ":" + port);
	this.socket.onerror = function(error) {
		haxe_Log.trace("Network error.",{ fileName : "Network.hx", lineNumber : 14, className : "kha.network.Network", methodName : "new"});
		errorCallback();
	};
	this.socket.binaryType = "arraybuffer";
	this.socket.onopen = function() {
		_gthis.open = true;
	};
	this.socket.onclose = function(event) {
		haxe_Log.trace("Network connection closed. " + kha_network_Network.webSocketCloseReason(event.code) + " (" + event.reason + ").",{ fileName : "Network.hx", lineNumber : 22, className : "kha.network.Network", methodName : "new"});
		closeCallback();
	};
};
$hxClasses["kha.network.Network"] = kha_network_Network;
kha_network_Network.__name__ = true;
kha_network_Network.webSocketCloseReason = function(code) {
	switch(code) {
	case 1000:
		return "Normal Closure";
	case 1001:
		return "Going Away";
	case 1002:
		return "Protocol error";
	case 1003:
		return "Unsupported Data";
	case 1005:
		return "No Status Rcvd";
	case 1006:
		return "Abnormal Closure";
	case 1007:
		return "Invalid frame";
	case 1008:
		return "Policy Violation";
	case 1009:
		return "Message Too Big";
	case 1010:
		return "Mandatory Ext.";
	case 1011:
		return "Internal Server Error";
	case 1015:
		return "TLS handshake";
	default:
		return "";
	}
};
kha_network_Network.prototype = {
	socket: null
	,open: null
	,send: function(bytes,mandatory) {
		if(this.open) {
			this.socket.send(bytes.b.bufferValue);
		}
	}
	,listen: function(listener) {
		this.socket.onmessage = function(message) {
			var tmp = haxe_io_Bytes.ofData(message.data);
			listener(tmp);
		};
	}
	,__class__: kha_network_Network
};
var kha_network_State = function(time,data) {
	this.time = time;
	this.data = data;
};
$hxClasses["kha.network.State"] = kha_network_State;
kha_network_State.__name__ = true;
kha_network_State.prototype = {
	time: null
	,data: null
	,__class__: kha_network_State
};
var kha_network_Session = function(maxPlayers,address,port) {
	this.ping = 1;
	this.currentPlayers = 0;
	this.controllers = new haxe_ds_IntMap();
	this.entities = new haxe_ds_IntMap();
	kha_network_Session.instance = this;
	this.maxPlayers = maxPlayers;
	this.address = address;
	this.port = port;
};
$hxClasses["kha.network.Session"] = kha_network_Session;
kha_network_Session.__name__ = true;
kha_network_Session.the = function() {
	return kha_network_Session.instance;
};
kha_network_Session.prototype = {
	entities: null
	,controllers: null
	,maxPlayers: null
	,currentPlayers: null
	,ping: null
	,address: null
	,port: null
	,startCallback: null
	,refusedCallback: null
	,resetCallback: null
	,localClient: null
	,network: null
	,updateTaskId: null
	,pingTaskId: null
	,me: null
	,get_me: function() {
		return this.localClient;
	}
	,addEntity: function(entity) {
		var this1 = this.entities;
		var key = entity._id();
		this1.h[key] = entity;
	}
	,addController: function(controller) {
		haxe_Log.trace("Adding controller id " + controller._id(),{ fileName : "Session.hx", lineNumber : 88, className : "kha.network.Session", methodName : "addController"});
		controller._inputBufferIndex = 0;
		var this1 = this.controllers;
		var key = controller._id();
		this1.h[key] = controller;
	}
	,sendControllerUpdate: function(id,bytes) {
		if(this.controllers.h.hasOwnProperty(id)) {
			if(this.controllers.h[id]._inputBuffer.length < this.controllers.h[id]._inputBufferIndex + 4 + bytes.length) {
				var newBuffer = new haxe_io_Bytes(new ArrayBuffer(this.controllers.h[id]._inputBufferIndex + 4 + bytes.length));
				newBuffer.blit(0,this.controllers.h[id]._inputBuffer,0,this.controllers.h[id]._inputBufferIndex);
				this.controllers.h[id]._inputBuffer = newBuffer;
			}
			this.controllers.h[id]._inputBuffer.setInt32(this.controllers.h[id]._inputBufferIndex,bytes.length);
			this.controllers.h[id]._inputBuffer.blit(this.controllers.h[id]._inputBufferIndex + 4,bytes,0,bytes.length);
			this.controllers.h[id]._inputBufferIndex += 4 + bytes.length;
		}
	}
	,sendPing: function() {
		var bytes = new haxe_io_Bytes(new ArrayBuffer(5));
		bytes.b[0] = 4;
		bytes.setFloat(1,kha_Scheduler.realTime());
		this.sendToServer(bytes);
	}
	,sendPlayerUpdate: function() {
	}
	,receive: function(bytes,client) {
		var _g = bytes.b[0];
		switch(_g) {
		case 0:
			var index = bytes.b[1];
			this.localClient = new kha_network_LocalClient(index);
			kha_Scheduler.resetTime();
			this.startCallback();
			break;
		case 1:
			var time = bytes.getDouble(1);
			var offset = 9;
			var entity = this.entities.iterator();
			while(entity.hasNext()) {
				var entity1 = entity.next();
				entity1._receive(offset,bytes);
				offset += entity1._size();
			}
			kha_Scheduler.warp(time);
			break;
		case 3:
			var _g1 = bytes.b[1];
			switch(_g1) {
			case 0:
				break;
			case 1:
				this.executeRPC(bytes);
				break;
			}
			break;
		case 4:
			var sendTime = bytes.getFloat(1);
			this.ping = kha_Scheduler.realTime() - sendTime;
			break;
		case 5:
			this.refusedCallback();
			break;
		case 6:
			this.currentPlayers = bytes.getInt32(1);
			break;
		}
	}
	,executeRPC: function(bytes) {
		var args = [];
		var syncId = bytes.getInt32(2);
		var index = 6;
		var classnamelength = bytes.getUInt16(index);
		index += 2;
		var classname = "";
		var _g1 = 0;
		var _g = classnamelength;
		while(_g1 < _g) {
			var i = _g1++;
			classname += String.fromCharCode(bytes.b[index]);
			++index;
		}
		var methodnamelength = bytes.getUInt16(index);
		index += 2;
		var methodname = "";
		var _g11 = 0;
		var _g2 = methodnamelength;
		while(_g11 < _g2) {
			var i1 = _g11++;
			methodname += String.fromCharCode(bytes.b[index]);
			++index;
		}
		while(index < bytes.length) {
			var type = bytes.b[index];
			++index;
			switch(type) {
			case 66:
				var value = bytes.b[index] == 1;
				++index;
				haxe_Log.trace("Bool: " + (value == null ? "null" : "" + value),{ fileName : "Session.hx", lineNumber : 295, className : "kha.network.Session", methodName : "executeRPC"});
				args.push(value);
				break;
			case 70:
				var value1 = bytes.getDouble(index);
				index += 8;
				haxe_Log.trace("Float: " + value1,{ fileName : "Session.hx", lineNumber : 300, className : "kha.network.Session", methodName : "executeRPC"});
				args.push(value1);
				break;
			case 73:
				var value2 = bytes.getInt32(index);
				index += 4;
				haxe_Log.trace("Int: " + value2,{ fileName : "Session.hx", lineNumber : 305, className : "kha.network.Session", methodName : "executeRPC"});
				args.push(value2);
				break;
			case 83:
				var length = bytes.getUInt16(index);
				index += 2;
				var str = "";
				var _g12 = 0;
				var _g3 = length;
				while(_g12 < _g3) {
					var i2 = _g12++;
					str += String.fromCharCode(bytes.b[index]);
					++index;
				}
				haxe_Log.trace("String: " + str,{ fileName : "Session.hx", lineNumber : 315, className : "kha.network.Session", methodName : "executeRPC"});
				args.push(str);
				break;
			default:
				haxe_Log.trace("Unknown argument type.",{ fileName : "Session.hx", lineNumber : 318, className : "kha.network.Session", methodName : "executeRPC"});
			}
		}
		if(syncId == -1) {
			Reflect.field(Type.resolveClass(classname),methodname + "_remotely").apply(null,args);
		} else {
			var o = kha_network_SyncBuilder.objects[syncId];
			Reflect.field(kha_network_SyncBuilder.objects[syncId],methodname + "_remotely").apply(o,args);
		}
	}
	,waitForStart: function(callback,refuseCallback,errorCallback,closeCallback,resCallback) {
		var _gthis = this;
		this.startCallback = callback;
		this.refusedCallback = refuseCallback;
		this.resetCallback = resCallback;
		this.network = new kha_network_Network(this.address,this.port,errorCallback,function() {
			closeCallback();
			_gthis.reset();
		});
		this.network.listen(function(bytes) {
			_gthis.receive(bytes);
		});
		this.updateTaskId = kha_Scheduler.addFrameTask($bind(this,this.update),0);
		this.ping = 1;
		this.pingTaskId = kha_Scheduler.addTimeTask($bind(this,this.sendPing),0,1);
	}
	,reset: function() {
		kha_Scheduler.removeFrameTask(this.updateTaskId);
		kha_Scheduler.removeTimeTask(this.pingTaskId);
		this.currentPlayers = 0;
		this.ping = 1;
		this.controllers = new haxe_ds_IntMap();
		this.entities = new haxe_ds_IntMap();
		this.resetCallback();
	}
	,update: function() {
		var controller = this.controllers.iterator();
		while(controller.hasNext()) {
			var controller1 = controller.next();
			if(controller1._inputBufferIndex > 0) {
				var bytes = new haxe_io_Bytes(new ArrayBuffer(22 + controller1._inputBufferIndex));
				bytes.b[0] = 2;
				bytes.setInt32(1,controller1._id());
				bytes.setDouble(5,kha_Scheduler.time());
				bytes.setInt32(13,kha_System.windowWidth(0));
				bytes.setInt32(17,kha_System.windowHeight(0));
				var v = kha_System.get_screenRotation()[1];
				bytes.b[21] = v & 255;
				bytes.blit(22,controller1._inputBuffer,0,controller1._inputBufferIndex);
				this.sendToServer(bytes);
				controller1._inputBufferIndex = 0;
			}
		}
	}
	,sendToServer: function(bytes) {
		this.network.send(bytes,false);
	}
	,__class__: kha_network_Session
};
var kha_network_SyncBuilder = function() { };
$hxClasses["kha.network.SyncBuilder"] = kha_network_SyncBuilder;
kha_network_SyncBuilder.__name__ = true;
var kha_simd_Float32x4 = function(_0,_1,_2,_3) {
	this._0 = _0;
	this._1 = _1;
	this._2 = _2;
	this._3 = _3;
};
$hxClasses["kha.simd.Float32x4"] = kha_simd_Float32x4;
kha_simd_Float32x4.__name__ = true;
kha_simd_Float32x4.create = function() {
	return new kha_simd_Float32x4(0,0,0,0);
};
kha_simd_Float32x4.loadAllFast = function(t) {
	return new kha_simd_Float32x4(t,t,t,t);
};
kha_simd_Float32x4.load = function(a,b,c,d) {
	return new kha_simd_Float32x4(a,b,c,d);
};
kha_simd_Float32x4.loadFast = function(a,b,c,d) {
	return new kha_simd_Float32x4(a,b,c,d);
};
kha_simd_Float32x4.get = function(t,index) {
	var value = 0;
	switch(index) {
	case 0:
		value = t._0;
		break;
	case 1:
		value = t._1;
		break;
	case 2:
		value = t._2;
		break;
	case 3:
		value = t._3;
		break;
	}
	return value;
};
kha_simd_Float32x4.getFast = function(t,index) {
	switch(index) {
	case 0:
		return t._0;
	case 1:
		return t._1;
	case 2:
		return t._2;
	case 3:
		return t._3;
	}
	return 0;
};
kha_simd_Float32x4.abs = function(t) {
	return new kha_simd_Float32x4(Math.abs(t._0),Math.abs(t._1),Math.abs(t._2),Math.abs(t._3));
};
kha_simd_Float32x4.add = function(a,b) {
	return new kha_simd_Float32x4(a._0 + b._0,a._1 + b._1,a._2 + b._2,a._3 + b._3);
};
kha_simd_Float32x4.div = function(a,b) {
	return new kha_simd_Float32x4(a._0 / b._0,a._1 / b._1,a._2 / b._2,a._3 / b._3);
};
kha_simd_Float32x4.mul = function(a,b) {
	return new kha_simd_Float32x4(a._0 * b._0,a._1 * b._1,a._2 * b._2,a._3 * b._3);
};
kha_simd_Float32x4.neg = function(t) {
	return new kha_simd_Float32x4(-t._0,-t._1,-t._2,-t._3);
};
kha_simd_Float32x4.reciprocalApproximation = function(t) {
	return new kha_simd_Float32x4(0,0,0,0);
};
kha_simd_Float32x4.reciprocalSqrtApproximation = function(t) {
	return new kha_simd_Float32x4(0,0,0,0);
};
kha_simd_Float32x4.sub = function(a,b) {
	return new kha_simd_Float32x4(a._0 - b._0,a._1 - b._1,a._2 - b._2,a._3 - b._3);
};
kha_simd_Float32x4.sqrt = function(t) {
	return new kha_simd_Float32x4(Math.sqrt(t._0),Math.sqrt(t._1),Math.sqrt(t._2),Math.sqrt(t._3));
};
kha_simd_Float32x4.prototype = {
	_0: null
	,_1: null
	,_2: null
	,_3: null
	,__class__: kha_simd_Float32x4
};
var kha_vr_Pose = function() {
	this.Orientation = new kha_math_Quaternion();
	this.Position = new kha_math_Vector3();
};
$hxClasses["kha.vr.Pose"] = kha_vr_Pose;
kha_vr_Pose.__name__ = true;
kha_vr_Pose.prototype = {
	Orientation: null
	,Position: null
	,__class__: kha_vr_Pose
};
var kha_vr_PoseState = function() {
};
$hxClasses["kha.vr.PoseState"] = kha_vr_PoseState;
kha_vr_PoseState.__name__ = true;
kha_vr_PoseState.prototype = {
	Pose: null
	,AngularVelocity: null
	,LinearVelocity: null
	,AngularAcceleration: null
	,LinearAcceleration: null
	,TimeInSeconds: null
	,__class__: kha_vr_PoseState
};
var kha_vr_SensorState = function() {
};
$hxClasses["kha.vr.SensorState"] = kha_vr_SensorState;
kha_vr_SensorState.__name__ = true;
kha_vr_SensorState.prototype = {
	Predicted: null
	,Recorded: null
	,Temperature: null
	,Status: null
	,__class__: kha_vr_SensorState
};
var kha_vr_TimeWarpImage = function() {
};
$hxClasses["kha.vr.TimeWarpImage"] = kha_vr_TimeWarpImage;
kha_vr_TimeWarpImage.__name__ = true;
kha_vr_TimeWarpImage.prototype = {
	Image: null
	,TexCoordsFromTanAngles: null
	,Pose: null
	,__class__: kha_vr_TimeWarpImage
};
var kha_vr_TimeWarpParms = function() {
};
$hxClasses["kha.vr.TimeWarpParms"] = kha_vr_TimeWarpParms;
kha_vr_TimeWarpParms.__name__ = true;
kha_vr_TimeWarpParms.prototype = {
	LeftImage: null
	,RightImage: null
	,LeftOverlay: null
	,RightOverlay: null
	,__class__: kha_vr_TimeWarpParms
};
var trilateral_angle_DifferencePreference = $hxClasses["trilateral.angle.DifferencePreference"] = { __ename__ : true, __constructs__ : ["CLOCKWISE","ANTICLOCKWISE","SMALL","LARGE"] };
trilateral_angle_DifferencePreference.CLOCKWISE = ["CLOCKWISE",0];
trilateral_angle_DifferencePreference.CLOCKWISE.toString = $estr;
trilateral_angle_DifferencePreference.CLOCKWISE.__enum__ = trilateral_angle_DifferencePreference;
trilateral_angle_DifferencePreference.ANTICLOCKWISE = ["ANTICLOCKWISE",1];
trilateral_angle_DifferencePreference.ANTICLOCKWISE.toString = $estr;
trilateral_angle_DifferencePreference.ANTICLOCKWISE.__enum__ = trilateral_angle_DifferencePreference;
trilateral_angle_DifferencePreference.SMALL = ["SMALL",2];
trilateral_angle_DifferencePreference.SMALL.toString = $estr;
trilateral_angle_DifferencePreference.SMALL.__enum__ = trilateral_angle_DifferencePreference;
trilateral_angle_DifferencePreference.LARGE = ["LARGE",3];
trilateral_angle_DifferencePreference.LARGE.toString = $estr;
trilateral_angle_DifferencePreference.LARGE.__enum__ = trilateral_angle_DifferencePreference;
var trilateral_angle_Angles = function() { };
$hxClasses["trilateral.angle.Angles"] = trilateral_angle_Angles;
trilateral_angle_Angles.__name__ = true;
trilateral_angle_Angles.pi2pi = function(angle) {
	if(angle <= Math.PI && angle > -Math.PI) {
		return angle;
	} else {
		var a = (angle + Math.PI) % (2 * Math.PI);
		if(a >= 0) {
			return a - Math.PI;
		} else {
			return a + Math.PI;
		}
	}
};
trilateral_angle_Angles.zeroto2pi = function(angle) {
	if(angle >= 0 && angle > Math.PI) {
		return angle;
	} else {
		var a = angle % (2 * Math.PI);
		if(a >= 0) {
			return a;
		} else {
			return a + 2 * Math.PI;
		}
	}
};
trilateral_angle_Angles.zerotoMinus2pi = function(angle) {
	if(angle <= 0 && angle > -Math.PI) {
		return angle;
	} else {
		var a = angle % (2 * Math.PI);
		var a1 = a >= 0 ? a : a + 2 * Math.PI;
		return -(Math.PI * 2 - a1);
	}
};
trilateral_angle_Angles.differencePrefer = function(a,b,prefer) {
	switch(prefer[1]) {
	case 0:
		var f;
		if(a >= 0 && a > Math.PI) {
			f = a;
		} else {
			var a1 = a % (2 * Math.PI);
			if(a1 >= 0) {
				f = a1;
			} else {
				f = a1 + 2 * Math.PI;
			}
		}
		var this1 = f;
		var za = this1;
		var f1;
		if(b >= 0 && b > Math.PI) {
			f1 = b;
		} else {
			var a2 = b % (2 * Math.PI);
			if(a2 >= 0) {
				f1 = a2;
			} else {
				f1 = a2 + 2 * Math.PI;
			}
		}
		var this2 = f1;
		var zb = this2;
		var fa = a;
		var fb = b;
		var theta = Math.abs(a - b);
		var clockwise = a < b;
		var dif = clockwise ? theta : -theta;
		if(dif > 0) {
			return dif;
		} else {
			return 2 * Math.PI + dif;
		}
		break;
	case 1:
		var f2;
		if(a >= 0 && a > Math.PI) {
			f2 = a;
		} else {
			var a3 = a % (2 * Math.PI);
			if(a3 >= 0) {
				f2 = a3;
			} else {
				f2 = a3 + 2 * Math.PI;
			}
		}
		var this3 = f2;
		var za1 = this3;
		var f3;
		if(b >= 0 && b > Math.PI) {
			f3 = b;
		} else {
			var a4 = b % (2 * Math.PI);
			if(a4 >= 0) {
				f3 = a4;
			} else {
				f3 = a4 + 2 * Math.PI;
			}
		}
		var this4 = f3;
		var zb1 = this4;
		var fa1 = a;
		var fb1 = b;
		var theta1 = Math.abs(a - b);
		var clockwise1 = a < b;
		var dif1 = clockwise1 ? theta1 : -theta1;
		if(dif1 < 0) {
			return dif1;
		} else {
			return -2 * Math.PI + dif1;
		}
		break;
	case 2:
		var f4;
		if(a >= 0 && a > Math.PI) {
			f4 = a;
		} else {
			var a5 = a % (2 * Math.PI);
			if(a5 >= 0) {
				f4 = a5;
			} else {
				f4 = a5 + 2 * Math.PI;
			}
		}
		var this5 = f4;
		var za2 = this5;
		var f5;
		if(b >= 0 && b > Math.PI) {
			f5 = b;
		} else {
			var a6 = b % (2 * Math.PI);
			if(a6 >= 0) {
				f5 = a6;
			} else {
				f5 = a6 + 2 * Math.PI;
			}
		}
		var this6 = f5;
		var zb2 = this6;
		var fa2 = a;
		var fb2 = b;
		var theta2 = Math.abs(a - b);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = a < b;
		var dif2 = clockwise2 ? theta2 : -theta2;
		if(smallest) {
			return dif2;
		} else if(clockwise2) {
			return -(2 * Math.PI - theta2);
		} else {
			return 2 * Math.PI - theta2;
		}
		break;
	case 3:
		var f6;
		if(a >= 0 && a > Math.PI) {
			f6 = a;
		} else {
			var a7 = a % (2 * Math.PI);
			if(a7 >= 0) {
				f6 = a7;
			} else {
				f6 = a7 + 2 * Math.PI;
			}
		}
		var this7 = f6;
		var za3 = this7;
		var f7;
		if(b >= 0 && b > Math.PI) {
			f7 = b;
		} else {
			var a8 = b % (2 * Math.PI);
			if(a8 >= 0) {
				f7 = a8;
			} else {
				f7 = a8 + 2 * Math.PI;
			}
		}
		var this8 = f7;
		var zb3 = this8;
		var fa3 = a;
		var fb3 = b;
		var theta3 = Math.abs(a - b);
		var largest = theta3 > Math.PI;
		var clockwise3 = a < b;
		var dif3 = clockwise3 ? theta3 : -theta3;
		if(largest) {
			return dif3;
		} else if(clockwise3) {
			return -(2 * Math.PI - theta3);
		} else {
			return 2 * Math.PI - theta3;
		}
		break;
	}
};
trilateral_angle_Angles.difference = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		if(a1 >= 0) {
			f = a1;
		} else {
			f = a1 + 2 * Math.PI;
		}
	}
	var this1 = f;
	var za = this1;
	var f1;
	if(b >= 0 && b > Math.PI) {
		f1 = b;
	} else {
		var a2 = b % (2 * Math.PI);
		if(a2 >= 0) {
			f1 = a2;
		} else {
			f1 = a2 + 2 * Math.PI;
		}
	}
	var this2 = f1;
	var zb = this2;
	var fa = a;
	var fb = b;
	var theta = Math.abs(a - b);
	var clockwise = a < b;
	if(clockwise) {
		return theta;
	} else {
		return -theta;
	}
};
trilateral_angle_Angles.differenceClockWise = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		if(a1 >= 0) {
			f = a1;
		} else {
			f = a1 + 2 * Math.PI;
		}
	}
	var this1 = f;
	var za = this1;
	var f1;
	if(b >= 0 && b > Math.PI) {
		f1 = b;
	} else {
		var a2 = b % (2 * Math.PI);
		if(a2 >= 0) {
			f1 = a2;
		} else {
			f1 = a2 + 2 * Math.PI;
		}
	}
	var this2 = f1;
	var zb = this2;
	var fa = a;
	var fb = b;
	var theta = Math.abs(a - b);
	var clockwise = a < b;
	var dif = clockwise ? theta : -theta;
	if(dif > 0) {
		return dif;
	} else {
		return 2 * Math.PI + dif;
	}
};
trilateral_angle_Angles.differenceAntiClockwise = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		if(a1 >= 0) {
			f = a1;
		} else {
			f = a1 + 2 * Math.PI;
		}
	}
	var this1 = f;
	var za = this1;
	var f1;
	if(b >= 0 && b > Math.PI) {
		f1 = b;
	} else {
		var a2 = b % (2 * Math.PI);
		if(a2 >= 0) {
			f1 = a2;
		} else {
			f1 = a2 + 2 * Math.PI;
		}
	}
	var this2 = f1;
	var zb = this2;
	var fa = a;
	var fb = b;
	var theta = Math.abs(a - b);
	var clockwise = a < b;
	var dif = clockwise ? theta : -theta;
	if(dif < 0) {
		return dif;
	} else {
		return -2 * Math.PI + dif;
	}
};
trilateral_angle_Angles.differenceSmall = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		if(a1 >= 0) {
			f = a1;
		} else {
			f = a1 + 2 * Math.PI;
		}
	}
	var this1 = f;
	var za = this1;
	var f1;
	if(b >= 0 && b > Math.PI) {
		f1 = b;
	} else {
		var a2 = b % (2 * Math.PI);
		if(a2 >= 0) {
			f1 = a2;
		} else {
			f1 = a2 + 2 * Math.PI;
		}
	}
	var this2 = f1;
	var zb = this2;
	var fa = a;
	var fb = b;
	var theta = Math.abs(a - b);
	var smallest = theta <= Math.PI;
	var clockwise = a < b;
	var dif = clockwise ? theta : -theta;
	if(smallest) {
		return dif;
	} else if(clockwise) {
		return -(2 * Math.PI - theta);
	} else {
		return 2 * Math.PI - theta;
	}
};
trilateral_angle_Angles.differenceLarge = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		if(a1 >= 0) {
			f = a1;
		} else {
			f = a1 + 2 * Math.PI;
		}
	}
	var this1 = f;
	var za = this1;
	var f1;
	if(b >= 0 && b > Math.PI) {
		f1 = b;
	} else {
		var a2 = b % (2 * Math.PI);
		if(a2 >= 0) {
			f1 = a2;
		} else {
			f1 = a2 + 2 * Math.PI;
		}
	}
	var this2 = f1;
	var zb = this2;
	var fa = a;
	var fb = b;
	var theta = Math.abs(a - b);
	var largest = theta > Math.PI;
	var clockwise = a < b;
	var dif = clockwise ? theta : -theta;
	if(largest) {
		return dif;
	} else if(clockwise) {
		return -(2 * Math.PI - theta);
	} else {
		return 2 * Math.PI - theta;
	}
};
trilateral_angle_Angles.differenceSmallLarge = function(a,b) {
	var f;
	if(a >= 0 && a > Math.PI) {
		f = a;
	} else {
		var a1 = a % (2 * Math.PI);
		if(a1 >= 0) {
			f = a1;
		} else {
			f = a1 + 2 * Math.PI;
		}
	}
	var this1 = f;
	var za = this1;
	var f1;
	if(b >= 0 && b > Math.PI) {
		f1 = b;
	} else {
		var a2 = b % (2 * Math.PI);
		if(a2 >= 0) {
			f1 = a2;
		} else {
			f1 = a2 + 2 * Math.PI;
		}
	}
	var this2 = f1;
	var zb = this2;
	var fa = a;
	var fb = b;
	var theta = Math.abs(a - b);
	var smallest = theta <= Math.PI;
	var clockwise = a < b;
	var dif = clockwise ? theta : -theta;
	var other = clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
	if(smallest) {
		return { small : dif, large : other};
	} else {
		return { small : other, large : dif};
	}
};
var trilateral_angle__$Fraction_FractionArray_$Impl_$ = {};
$hxClasses["trilateral.angle._Fraction.FractionArray_Impl_"] = trilateral_angle__$Fraction_FractionArray_$Impl_$;
trilateral_angle__$Fraction_FractionArray_$Impl_$.__name__ = true;
trilateral_angle__$Fraction_FractionArray_$Impl_$._new = function(val) {
	var this1 = val == null ? [] : val;
	return this1;
};
trilateral_angle__$Fraction_FractionArray_$Impl_$.add = function(this1,val) {
	this1[this1.length] = val;
};
trilateral_angle__$Fraction_FractionArray_$Impl_$.toString = function(this1) {
	var l = this1.length;
	var str = "";
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		var this2 = this1[i];
		var n = this2.numerator;
		var d = this2.denominator;
		var out = n == 0 ? "0" : n == d ? "1" : d == 1 ? this2.positive ? "" + n : "-" + n : this2.positive ? "" + n + "/" + d : "-" + n + "/" + d;
		str = str + "\n" + out;
	}
	return str;
};
var trilateral_angle__$Fraction_Fraction_$Impl_$ = {};
$hxClasses["trilateral.angle._Fraction.Fraction_Impl_"] = trilateral_angle__$Fraction_Fraction_$Impl_$;
trilateral_angle__$Fraction_Fraction_$Impl_$.__name__ = true;
trilateral_angle__$Fraction_Fraction_$Impl_$._new = function(numerator,denominator,positive,value) {
	if(positive == null) {
		positive = true;
	}
	var this1;
	var numNeg = numerator < 0;
	var denoNeg = denominator < 0;
	if(value == null) {
		if(positive) {
			value = numerator / denominator;
		} else {
			value = -numerator / denominator;
		}
	}
	if(numNeg || denoNeg) {
		if(!(numNeg && denoNeg)) {
			positive = !positive;
		}
		if(numNeg) {
			numerator = -numerator;
		}
		if(denoNeg) {
			denominator = -denominator;
		}
	}
	this1 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
	return this1;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.optimize = function(this1) {
	var f = this1.value;
	var arr = trilateral_angle_Fracs.approximateFractions(f);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac = trilateral_angle__$Fraction_Fraction_$Impl_$;
	var fracStore = arr[0];
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		var frac1 = arr[i];
		if(frac1.positive) {
			fracFloat = frac1.numerator / frac1.denominator;
		} else {
			fracFloat = -frac1.numerator / frac1.denominator;
		}
		dif = Math.abs(fracFloat - f);
		if(dif < dist) {
			dist = dif;
			fracStore = frac1;
		}
	}
	return fracStore;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.optimizeFraction = function(this1) {
	var f = this1.positive ? this1.numerator / this1.denominator : -this1.numerator / this1.denominator;
	var arr = trilateral_angle_Fracs.approximateFractions(f);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac = trilateral_angle__$Fraction_Fraction_$Impl_$;
	var fracStore = arr[0];
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		var frac1 = arr[i];
		if(frac1.positive) {
			fracFloat = frac1.numerator / frac1.denominator;
		} else {
			fracFloat = -frac1.numerator / frac1.denominator;
		}
		dif = Math.abs(fracFloat - f);
		if(dif < dist) {
			dist = dif;
			fracStore = frac1;
		}
	}
	return fracStore;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.toFloat = function(this1) {
	if(this1.positive) {
		return this1.numerator / this1.denominator;
	} else {
		return -this1.numerator / this1.denominator;
	}
};
trilateral_angle__$Fraction_Fraction_$Impl_$["float"] = function(this1) {
	return this1.value;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.verbose = function(this1) {
	return "{ numerator:" + this1.numerator + ", denominator: " + this1.denominator + ", positive: " + (this1.positive == null ? "null" : "" + this1.positive) + ", value: " + this1.value + " }";
};
trilateral_angle__$Fraction_Fraction_$Impl_$.fromString = function(val) {
	var i = val.indexOf("/");
	var frac;
	if(i != -1) {
		var numerator = Std.parseInt(HxOverrides.substr(val,0,i));
		var denominator = Std.parseInt(HxOverrides.substr(val,i + 1,val.length));
		var positive = true;
		var value = null;
		var this1;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			if(positive) {
				value = numerator / denominator;
			} else {
				value = -numerator / denominator;
			}
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive = !positive;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		this1 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
		frac = this1;
	} else {
		var f = parseFloat(val);
		var arr = trilateral_angle_Fracs.approximateFractions(f);
		var dist = Infinity;
		var dif;
		var l = arr.length;
		var fracFloat;
		var frac1 = trilateral_angle__$Fraction_Fraction_$Impl_$;
		var fracStore = arr[0];
		var _g1 = 0;
		var _g = l;
		while(_g1 < _g) {
			var i1 = _g1++;
			var frac2 = arr[i1];
			if(frac2.positive) {
				fracFloat = frac2.numerator / frac2.denominator;
			} else {
				fracFloat = -frac2.numerator / frac2.denominator;
			}
			dif = Math.abs(fracFloat - f);
			if(dif < dist) {
				dist = dif;
				fracStore = frac2;
			}
		}
		frac = fracStore;
	}
	return frac;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.toString = function(this1) {
	var n = this1.numerator;
	var d = this1.denominator;
	var out = n == 0 ? "0" : n == d ? "1" : d == 1 ? this1.positive ? "" + n : "-" + n : this1.positive ? "" + n + "/" + d : "-" + n + "/" + d;
	return out;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.fromFloat = function(f) {
	var arr = trilateral_angle_Fracs.approximateFractions(f);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac = trilateral_angle__$Fraction_Fraction_$Impl_$;
	var fracStore = arr[0];
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		var frac1 = arr[i];
		if(frac1.positive) {
			fracFloat = frac1.numerator / frac1.denominator;
		} else {
			fracFloat = -frac1.numerator / frac1.denominator;
		}
		dif = Math.abs(fracFloat - f);
		if(dif < dist) {
			dist = dif;
			fracStore = frac1;
		}
	}
	return fracStore;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.firstFloat = function(f) {
	var arr = trilateral_angle_Fracs.approximateFractions(f);
	var fracStore = arr[0];
	return fracStore;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.byDenominator = function(this1,val) {
	var n = this1.numerator;
	var d = this1.denominator;
	var out = n == 0 ? "0" : n == d ? "1" : d == 1 ? this1.positive ? "" + n : "-" + n : this1.positive ? "" + n + "/" + d : "-" + n + "/" + d;
	var out1 = out;
	if(!(this1.denominator == val || out1 == "0" || out1 == "1")) {
		var dom = Math.round(this1.value * val);
		var numerator = dom;
		var denominator = val;
		var positive = true;
		var value = null;
		var this2;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			if(positive) {
				value = numerator / denominator;
			} else {
				value = -numerator / denominator;
			}
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive = !positive;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		this2 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
		var frac = this2;
		var n1 = frac.numerator;
		var d1 = frac.denominator;
		var out2 = n1 == 0 ? "0" : n1 == d1 ? "1" : d1 == 1 ? frac.positive ? "" + n1 : "-" + n1 : frac.positive ? "" + n1 + "/" + d1 : "-" + n1 + "/" + d1;
		out1 = out2;
	}
	return out1;
};
trilateral_angle__$Fraction_Fraction_$Impl_$.all = function(f) {
	return trilateral_angle_Fracs.approximateFractions(f);
};
trilateral_angle__$Fraction_Fraction_$Impl_$.similarToFraction = function(this1) {
	var f = this1.positive ? this1.numerator / this1.denominator : -this1.numerator / this1.denominator;
	return trilateral_angle_Fracs.approximateFractions(f);
};
trilateral_angle__$Fraction_Fraction_$Impl_$.similarToValue = function(this1) {
	return trilateral_angle_Fracs.approximateFractions(this1.value);
};
var trilateral_angle_Fracs = function() { };
$hxClasses["trilateral.angle.Fracs"] = trilateral_angle_Fracs;
trilateral_angle_Fracs.__name__ = true;
trilateral_angle_Fracs.grabDecimalInput = function(decimalVal) {
	var decimal = Math.abs(parseFloat(decimalVal));
	if(isNaN(decimal)) {
		return 0.;
	} else {
		return decimal;
	}
};
trilateral_angle_Fracs.approximateFractions = function(f) {
	var positive = f <= 0 ? false : true;
	var numerators = [0,1];
	var denominators = [1,0];
	var f2 = f <= 0 ? -f : f;
	var fStr = f2 == null ? "null" : "" + f2;
	var digits = "";
	var ix = fStr.indexOf(".");
	if(ix == -1) {
		digits = fStr;
	} else if(ix == 0) {
		digits = HxOverrides.substr(fStr,1,fStr.length);
	} else if(ix < fStr.length) {
		digits = HxOverrides.substr(fStr,0,ix) + HxOverrides.substr(fStr,ix + 1,fStr.length);
	}
	var LStr = digits;
	var numDigits = LStr.length;
	var L2 = f2;
	var numIntDigits = (L2 == null ? "null" : "" + L2).length;
	if(L2 == 0) {
		numIntDigits = 0;
	}
	var numDigitsPastDecimal = numDigits - numIntDigits;
	var i = numDigitsPastDecimal;
	var L = parseFloat(digits);
	while(i > 0 && L % 2 == 0) {
		L /= 2;
		--i;
	}
	i = numDigitsPastDecimal;
	while(i > 0 && L % 5 == 0) {
		L /= 5;
		--i;
	}
	var maxNumerator = L;
	var d2 = f2;
	var calcD;
	var prevCalcD = null;
	var this1 = [];
	var arrFraction = this1;
	var j = 0;
	var _g = 2;
	while(_g < 1000) {
		var i1 = _g++;
		var L21 = Math.floor(d2);
		numerators[i1] = L21 * numerators[i1 - 1] + numerators[i1 - 2] | 0;
		if(Math.abs(numerators[i1]) > maxNumerator) {
			break;
		}
		denominators[i1] = L21 * denominators[i1 - 1] + denominators[i1 - 2] | 0;
		calcD = numerators[i1] / denominators[i1];
		if(calcD == prevCalcD) {
			break;
		}
		var numerator = numerators[i1];
		var denominator = denominators[i1];
		var positive1 = positive;
		var value = f;
		var this2;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			if(positive1) {
				value = numerator / denominator;
			} else {
				value = -numerator / denominator;
			}
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive1 = !positive1;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		this2 = { numerator : numerator, denominator : denominator, positive : positive1, value : value};
		trilateral_angle__$Fraction_FractionArray_$Impl_$.add(arrFraction,this2);
		if(calcD == f2) {
			break;
		}
		prevCalcD = calcD;
		d2 = 1 / (d2 - L21);
	}
	return arrFraction;
};
trilateral_angle_Fracs.getMaxNumerator = function(f) {
	var fStr = f == null ? "null" : "" + f;
	var digits = "";
	var ix = fStr.indexOf(".");
	if(ix == -1) {
		digits = fStr;
	} else if(ix == 0) {
		digits = HxOverrides.substr(fStr,1,fStr.length);
	} else if(ix < fStr.length) {
		digits = HxOverrides.substr(fStr,0,ix) + HxOverrides.substr(fStr,ix + 1,fStr.length);
	}
	var LStr = digits;
	var numDigits = LStr.length;
	var L2 = f;
	var numIntDigits = (L2 == null ? "null" : "" + L2).length;
	if(L2 == 0) {
		numIntDigits = 0;
	}
	var numDigitsPastDecimal = numDigits - numIntDigits;
	var i = numDigitsPastDecimal;
	var L = parseFloat(digits);
	while(i > 0 && L % 2 == 0) {
		L /= 2;
		--i;
	}
	i = numDigitsPastDecimal;
	while(i > 0 && L % 5 == 0) {
		L /= 5;
		--i;
	}
	return L;
};
trilateral_angle_Fracs.extractDigitStr = function(fStr) {
	var f2 = "";
	var ixe = fStr.indexOf("E");
	if(ixe == -1) {
		ixe = fStr.indexOf("e");
	}
	if(ixe == -1) {
		f2 = fStr;
	} else {
		f2 = HxOverrides.substr(fStr,0,ixe);
	}
	var digits = "";
	var ix = f2.indexOf(".");
	if(ix == -1) {
		digits = f2;
	} else if(ix == 0) {
		digits = HxOverrides.substr(f2,1,f2.length);
	} else if(ix < f2.length) {
		digits = HxOverrides.substr(f2,0,ix) + HxOverrides.substr(f2,ix + 1,f2.length);
	}
	return digits;
};
trilateral_angle_Fracs.getMaxNumeratorStr = function(fStr) {
	var f2 = "";
	var ixe = fStr.indexOf("E");
	if(ixe == -1) {
		ixe = fStr.indexOf("e");
	}
	if(ixe == -1) {
		f2 = fStr;
	} else {
		f2 = HxOverrides.substr(fStr,0,ixe);
	}
	var digits = "";
	var ix = f2.indexOf(".");
	if(ix == -1) {
		digits = f2;
	} else if(ix == 0) {
		digits = HxOverrides.substr(f2,1,f2.length);
	} else if(ix < f2.length) {
		digits = HxOverrides.substr(f2,0,ix) + HxOverrides.substr(f2,ix + 1,f2.length);
	}
	var LStr = digits;
	var numDigits = LStr.length;
	var L2 = fStr;
	var numIntDigits = L2.length;
	if(L2 == "0") {
		numIntDigits = 0;
	}
	var numDigitsPastDecimal = numDigits - numIntDigits;
	var i = numDigitsPastDecimal;
	var L = parseFloat(fStr);
	while(i > 0 && L % 2 == 0) {
		L /= 2;
		--i;
	}
	i = numDigitsPastDecimal;
	while(i > 0 && L % 5 == 0) {
		L /= 5;
		--i;
	}
	return L;
};
var trilateral_angle__$Pi2pi_Pi2pi_$Impl_$ = {};
$hxClasses["trilateral.angle._Pi2pi.Pi2pi_Impl_"] = trilateral_angle__$Pi2pi_Pi2pi_$Impl_$;
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.__name__ = true;
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$._new = function(f) {
	var this1 = f;
	return this1;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.fromFloat = function(f) {
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		if(a >= 0) {
			f1 = a - Math.PI;
		} else {
			f1 = a + Math.PI;
		}
	}
	var this1 = f1;
	return this1;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.additionPi = function(this1,b) {
	var f = this1 + b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		if(a >= 0) {
			f1 = a - Math.PI;
		} else {
			f1 = a + Math.PI;
		}
	}
	var this2 = f1;
	var p = this2;
	var f2;
	if(f <= Math.PI && f > -Math.PI) {
		f2 = f;
	} else {
		var a1 = (f + Math.PI) % (2 * Math.PI);
		if(a1 >= 0) {
			f2 = a1 - Math.PI;
		} else {
			f2 = a1 + Math.PI;
		}
	}
	var this3 = f2;
	return this3;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.subtractionPi = function(this1,b) {
	var f = this1;
	var f2 = b;
	f -= f2;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		if(a >= 0) {
			f1 = a - Math.PI;
		} else {
			f1 = a + Math.PI;
		}
	}
	var this2 = f1;
	var p = this2;
	var f3;
	if(f <= Math.PI && f > -Math.PI) {
		f3 = f;
	} else {
		var a1 = (f + Math.PI) % (2 * Math.PI);
		if(a1 >= 0) {
			f3 = a1 - Math.PI;
		} else {
			f3 = a1 + Math.PI;
		}
	}
	var this3 = f3;
	return this3;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.dividePi = function(this1,b) {
	var f = this1;
	var f2 = b;
	f /= f2;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		if(a >= 0) {
			f1 = a - Math.PI;
		} else {
			f1 = a + Math.PI;
		}
	}
	var this2 = f1;
	var p = this2;
	var f3;
	if(f <= Math.PI && f > -Math.PI) {
		f3 = f;
	} else {
		var a1 = (f + Math.PI) % (2 * Math.PI);
		if(a1 >= 0) {
			f3 = a1 - Math.PI;
		} else {
			f3 = a1 + Math.PI;
		}
	}
	var this3 = f3;
	return this3;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.timesPi = function(this1,b) {
	var f = this1;
	var f2 = b;
	f *= f2;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		if(a >= 0) {
			f1 = a - Math.PI;
		} else {
			f1 = a + Math.PI;
		}
	}
	var this2 = f1;
	var p = this2;
	var f3;
	if(f <= Math.PI && f > -Math.PI) {
		f3 = f;
	} else {
		var a1 = (f + Math.PI) % (2 * Math.PI);
		if(a1 >= 0) {
			f3 = a1 - Math.PI;
		} else {
			f3 = a1 + Math.PI;
		}
	}
	var this3 = f3;
	return this3;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.addition = function(this1,b) {
	var f = this1;
	f += b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		if(a >= 0) {
			f1 = a - Math.PI;
		} else {
			f1 = a + Math.PI;
		}
	}
	var this2 = f1;
	var p = this2;
	var f2;
	if(f <= Math.PI && f > -Math.PI) {
		f2 = f;
	} else {
		var a1 = (f + Math.PI) % (2 * Math.PI);
		if(a1 >= 0) {
			f2 = a1 - Math.PI;
		} else {
			f2 = a1 + Math.PI;
		}
	}
	var this3 = f2;
	return this3;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.subtraction = function(this1,b) {
	var f = this1;
	f -= b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		if(a >= 0) {
			f1 = a - Math.PI;
		} else {
			f1 = a + Math.PI;
		}
	}
	var this2 = f1;
	var p = this2;
	var f2;
	if(f <= Math.PI && f > -Math.PI) {
		f2 = f;
	} else {
		var a1 = (f + Math.PI) % (2 * Math.PI);
		if(a1 >= 0) {
			f2 = a1 - Math.PI;
		} else {
			f2 = a1 + Math.PI;
		}
	}
	var this3 = f2;
	return this3;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.divide = function(this1,b) {
	var f = this1;
	f /= b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		if(a >= 0) {
			f1 = a - Math.PI;
		} else {
			f1 = a + Math.PI;
		}
	}
	var this2 = f1;
	var p = this2;
	var f2;
	if(f <= Math.PI && f > -Math.PI) {
		f2 = f;
	} else {
		var a1 = (f + Math.PI) % (2 * Math.PI);
		if(a1 >= 0) {
			f2 = a1 - Math.PI;
		} else {
			f2 = a1 + Math.PI;
		}
	}
	var this3 = f2;
	return this3;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.times = function(this1,b) {
	var f = this1;
	f *= b;
	var f1;
	if(f <= Math.PI && f > -Math.PI) {
		f1 = f;
	} else {
		var a = (f + Math.PI) % (2 * Math.PI);
		if(a >= 0) {
			f1 = a - Math.PI;
		} else {
			f1 = a + Math.PI;
		}
	}
	var this2 = f1;
	var p = this2;
	var f2;
	if(f <= Math.PI && f > -Math.PI) {
		f2 = f;
	} else {
		var a1 = (f + Math.PI) % (2 * Math.PI);
		if(a1 >= 0) {
			f2 = a1 - Math.PI;
		} else {
			f2 = a1 + Math.PI;
		}
	}
	var this3 = f2;
	return this3;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.get_degrees = function(this1) {
	var f = this1;
	return f * 180 / Math.PI;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.set_degrees = function(this1,val) {
	this1 = Math.PI * val / 180;
	return val;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.fromFraction = function(val) {
	var this1 = (val.positive ? val.numerator / val.denominator : -val.numerator / val.denominator) * Math.PI;
	return this1;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.tofraction = function(this1) {
	var f = this1;
	var f1 = this1 / Math.PI;
	var arr = trilateral_angle_Fracs.approximateFractions(f1);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac = trilateral_angle__$Fraction_Fraction_$Impl_$;
	var fracStore = arr[0];
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		var frac1 = arr[i];
		if(frac1.positive) {
			fracFloat = frac1.numerator / frac1.denominator;
		} else {
			fracFloat = -frac1.numerator / frac1.denominator;
		}
		dif = Math.abs(fracFloat - f1);
		if(dif < dist) {
			dist = dif;
			fracStore = frac1;
		}
	}
	var frac2 = fracStore;
	return frac2;
};
trilateral_angle__$Pi2pi_Pi2pi_$Impl_$.fromString = function(val) {
	var i = val.indexOf("/");
	var frac;
	if(i != -1) {
		var numerator = Std.parseInt(HxOverrides.substr(val,0,i));
		var denominator = Std.parseInt(HxOverrides.substr(val,i + 1,val.length));
		var positive = true;
		var value = null;
		var this1;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			if(positive) {
				value = numerator / denominator;
			} else {
				value = -numerator / denominator;
			}
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive = !positive;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		this1 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
		frac = this1;
	} else {
		var f = parseFloat(val);
		var arr = trilateral_angle_Fracs.approximateFractions(f);
		var dist = Infinity;
		var dif;
		var l = arr.length;
		var fracFloat;
		var frac1 = trilateral_angle__$Fraction_Fraction_$Impl_$;
		var fracStore = arr[0];
		var _g1 = 0;
		var _g = l;
		while(_g1 < _g) {
			var i1 = _g1++;
			var frac2 = arr[i1];
			if(frac2.positive) {
				fracFloat = frac2.numerator / frac2.denominator;
			} else {
				fracFloat = -frac2.numerator / frac2.denominator;
			}
			dif = Math.abs(fracFloat - f);
			if(dif < dist) {
				dist = dif;
				fracStore = frac2;
			}
		}
		frac = fracStore;
	}
	var frac3 = frac;
	var this2 = (frac3.positive ? frac3.numerator / frac3.denominator : -frac3.numerator / frac3.denominator) * Math.PI;
	return this2;
};
var trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$ = {};
$hxClasses["trilateral.angle._ZeroTo2pi.ZeroTo2pi_Impl_"] = trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$;
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.__name__ = true;
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$._new = function(f) {
	var this1 = f;
	return this1;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.fromFloat = function(f) {
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		if(a >= 0) {
			f1 = a;
		} else {
			f1 = a + 2 * Math.PI;
		}
	}
	var this1 = f1;
	return this1;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.additionPi = function(this1,b) {
	var f = this1 + b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		if(a >= 0) {
			f1 = a;
		} else {
			f1 = a + 2 * Math.PI;
		}
	}
	var this2 = f1;
	var p = this2;
	return p;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.subtractionPi = function(this1,b) {
	var f = this1;
	var f2 = b;
	f -= f2;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		if(a >= 0) {
			f1 = a;
		} else {
			f1 = a + 2 * Math.PI;
		}
	}
	var this2 = f1;
	var p = this2;
	return p;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.dividePi = function(this1,b) {
	var f = this1;
	var f2 = b;
	f /= f2;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		if(a >= 0) {
			f1 = a;
		} else {
			f1 = a + 2 * Math.PI;
		}
	}
	var this2 = f1;
	var p = this2;
	return p;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.timesPi = function(this1,b) {
	var f = this1;
	var f2 = b;
	f *= f2;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		if(a >= 0) {
			f1 = a;
		} else {
			f1 = a + 2 * Math.PI;
		}
	}
	var this2 = f1;
	var p = this2;
	return p;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.addition = function(this1,b) {
	var f = this1;
	f += b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		if(a >= 0) {
			f1 = a;
		} else {
			f1 = a + 2 * Math.PI;
		}
	}
	var this2 = f1;
	var p = this2;
	return p;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.subtraction = function(this1,b) {
	var f = this1;
	f -= b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		if(a >= 0) {
			f1 = a;
		} else {
			f1 = a + 2 * Math.PI;
		}
	}
	var this2 = f1;
	var p = this2;
	return p;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.divide = function(this1,b) {
	var f = this1;
	f /= b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		if(a >= 0) {
			f1 = a;
		} else {
			f1 = a + 2 * Math.PI;
		}
	}
	var this2 = f1;
	var p = this2;
	return p;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.times = function(this1,b) {
	var f = this1;
	f *= b;
	var f1;
	if(f >= 0 && f > Math.PI) {
		f1 = f;
	} else {
		var a = f % (2 * Math.PI);
		if(a >= 0) {
			f1 = a;
		} else {
			f1 = a + 2 * Math.PI;
		}
	}
	var this2 = f1;
	var p = this2;
	return p;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.get_degrees = function(this1) {
	var f = this1;
	return f * 180 / Math.PI;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.set_degrees = function(this1,val) {
	this1 = Math.PI * val / 180;
	return val;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.fromFraction = function(val) {
	var this1 = (val.positive ? val.numerator / val.denominator : -val.numerator / val.denominator) * Math.PI;
	return this1;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.tofraction = function(this1) {
	var f = this1;
	var f1 = this1 / Math.PI;
	var arr = trilateral_angle_Fracs.approximateFractions(f1);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var frac = trilateral_angle__$Fraction_Fraction_$Impl_$;
	var fracStore = arr[0];
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		var frac1 = arr[i];
		if(frac1.positive) {
			fracFloat = frac1.numerator / frac1.denominator;
		} else {
			fracFloat = -frac1.numerator / frac1.denominator;
		}
		dif = Math.abs(fracFloat - f1);
		if(dif < dist) {
			dist = dif;
			fracStore = frac1;
		}
	}
	var frac2 = fracStore;
	return frac2;
};
trilateral_angle__$ZeroTo2pi_ZeroTo2pi_$Impl_$.fromString = function(val) {
	var i = val.indexOf("/");
	var frac;
	if(i != -1) {
		var numerator = Std.parseInt(HxOverrides.substr(val,0,i));
		var denominator = Std.parseInt(HxOverrides.substr(val,i + 1,val.length));
		var positive = true;
		var value = null;
		var this1;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(value == null) {
			if(positive) {
				value = numerator / denominator;
			} else {
				value = -numerator / denominator;
			}
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive = !positive;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		this1 = { numerator : numerator, denominator : denominator, positive : positive, value : value};
		frac = this1;
	} else {
		var f = parseFloat(val);
		var arr = trilateral_angle_Fracs.approximateFractions(f);
		var dist = Infinity;
		var dif;
		var l = arr.length;
		var fracFloat;
		var frac1 = trilateral_angle__$Fraction_Fraction_$Impl_$;
		var fracStore = arr[0];
		var _g1 = 0;
		var _g = l;
		while(_g1 < _g) {
			var i1 = _g1++;
			var frac2 = arr[i1];
			if(frac2.positive) {
				fracFloat = frac2.numerator / frac2.denominator;
			} else {
				fracFloat = -frac2.numerator / frac2.denominator;
			}
			dif = Math.abs(fracFloat - f);
			if(dif < dist) {
				dist = dif;
				fracStore = frac2;
			}
		}
		frac = fracStore;
	}
	var frac3 = frac;
	var this2 = (frac3.positive ? frac3.numerator / frac3.denominator : -frac3.numerator / frac3.denominator) * Math.PI;
	return this2;
};
var trilateral_bits_Toggle = $hxClasses["trilateral.bits.Toggle"] = { __ename__ : true, __constructs__ : ["TOGGLE"] };
trilateral_bits_Toggle.TOGGLE = ["TOGGLE",0];
trilateral_bits_Toggle.TOGGLE.toString = $estr;
trilateral_bits_Toggle.TOGGLE.__enum__ = trilateral_bits_Toggle;
var trilateral_bits__$Binary8_Binary8_$Impl_$ = {};
$hxClasses["trilateral.bits._Binary8.Binary8_Impl_"] = trilateral_bits__$Binary8_Binary8_$Impl_$;
trilateral_bits__$Binary8_Binary8_$Impl_$.__name__ = true;
trilateral_bits__$Binary8_Binary8_$Impl_$._new = function(i) {
	if(i == null) {
		i = 0;
	}
	var this1 = i;
	return this1;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.getValue = function(this1) {
	return this1;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.get_d0 = function(this1) {
	return (this1 & 128) == 128;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.get_d1 = function(this1) {
	return (this1 & 64) == 64;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.get_d2 = function(this1) {
	return (this1 & 32) == 32;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.get_d3 = function(this1) {
	return (this1 & 16) == 16;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.get_d4 = function(this1) {
	return (this1 & 8) == 8;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.get_d5 = function(this1) {
	return (this1 & 4) == 4;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.get_d6 = function(this1) {
	return (this1 & 2) == 2;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.get_d7 = function(this1) {
	return (this1 & 1) == 1;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.set_d0 = function(this1,v) {
	if(v) {
		this1 |= 128;
	} else {
		this1 &= -129;
	}
	return v;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.set_d1 = function(this1,v) {
	if(v) {
		this1 |= 64;
	} else {
		this1 &= -65;
	}
	return v;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.set_d2 = function(this1,v) {
	if(v) {
		this1 |= 32;
	} else {
		this1 &= -33;
	}
	return v;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.set_d3 = function(this1,v) {
	if(v) {
		this1 |= 16;
	} else {
		this1 &= -17;
	}
	return v;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.set_d4 = function(this1,v) {
	if(v) {
		this1 |= 8;
	} else {
		this1 &= -9;
	}
	return v;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.set_d5 = function(this1,v) {
	if(v) {
		this1 |= 4;
	} else {
		this1 &= -5;
	}
	return v;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.set_d6 = function(this1,v) {
	if(v) {
		this1 |= 2;
	} else {
		this1 &= -3;
	}
	return v;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.set_d7 = function(this1,v) {
	if(v) {
		this1 |= 1;
	} else {
		this1 &= -2;
	}
	return v;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.get = function(this1,n) {
	switch(n) {
	case 0:
		return (this1 & 128) == 128;
	case 1:
		return (this1 & 64) == 64;
	case 2:
		return (this1 & 32) == 32;
	case 3:
		return (this1 & 16) == 16;
	case 4:
		return (this1 & 8) == 8;
	case 5:
		return (this1 & 4) == 4;
	case 6:
		return (this1 & 2) == 2;
	case 7:
		return (this1 & 1) == 1;
	default:
		return false;
	}
};
trilateral_bits__$Binary8_Binary8_$Impl_$.set = function(this1,n,v) {
	switch(n) {
	case 0:
		if(v) {
			this1 |= 128;
		} else {
			this1 &= -129;
		}
		break;
	case 1:
		if(v) {
			this1 |= 64;
		} else {
			this1 &= -65;
		}
		break;
	case 2:
		if(v) {
			this1 |= 32;
		} else {
			this1 &= -33;
		}
		break;
	case 3:
		if(v) {
			this1 |= 16;
		} else {
			this1 &= -17;
		}
		break;
	case 4:
		if(v) {
			this1 |= 8;
		} else {
			this1 &= -9;
		}
		break;
	case 5:
		if(v) {
			this1 |= 4;
		} else {
			this1 &= -5;
		}
		break;
	case 6:
		if(v) {
			this1 |= 2;
		} else {
			this1 &= -3;
		}
		break;
	case 7:
		if(v) {
			this1 |= 1;
		} else {
			this1 &= -2;
		}
		break;
	default:
	}
	return v;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.setInt = function(this1,n,v) {
	var v1 = v == 1;
	switch(n) {
	case 0:
		if(v1) {
			this1 |= 128;
		} else {
			this1 &= -129;
		}
		break;
	case 1:
		if(v1) {
			this1 |= 64;
		} else {
			this1 &= -65;
		}
		break;
	case 2:
		if(v1) {
			this1 |= 32;
		} else {
			this1 &= -33;
		}
		break;
	case 3:
		if(v1) {
			this1 |= 16;
		} else {
			this1 &= -17;
		}
		break;
	case 4:
		if(v1) {
			this1 |= 8;
		} else {
			this1 &= -9;
		}
		break;
	case 5:
		if(v1) {
			this1 |= 4;
		} else {
			this1 &= -5;
		}
		break;
	case 6:
		if(v1) {
			this1 |= 2;
		} else {
			this1 &= -3;
		}
		break;
	case 7:
		if(v1) {
			this1 |= 1;
		} else {
			this1 &= -2;
		}
		break;
	default:
	}
	return v;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.getInt = function(this1,n) {
	var b;
	switch(n) {
	case 0:
		b = (this1 & 128) == 128;
		break;
	case 1:
		b = (this1 & 64) == 64;
		break;
	case 2:
		b = (this1 & 32) == 32;
		break;
	case 3:
		b = (this1 & 16) == 16;
		break;
	case 4:
		b = (this1 & 8) == 8;
		break;
	case 5:
		b = (this1 & 4) == 4;
		break;
	case 6:
		b = (this1 & 2) == 2;
		break;
	case 7:
		b = (this1 & 1) == 1;
		break;
	default:
		b = false;
	}
	if(b == true) {
		return 1;
	} else {
		return 0;
	}
};
trilateral_bits__$Binary8_Binary8_$Impl_$.setToggle = function(this1,n,t) {
	switch(n) {
	case 0:
		this1 ^= 128;
		break;
	case 1:
		this1 ^= 64;
		break;
	case 2:
		this1 ^= 32;
		break;
	case 3:
		this1 ^= 16;
		break;
	case 4:
		this1 ^= 8;
		break;
	case 5:
		this1 ^= 4;
		break;
	case 6:
		this1 ^= 2;
		break;
	case 7:
		this1 ^= 1;
		break;
	default:
	}
	return t;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.left = function(this1,b,l) {
	if(l == null) {
		l = 0;
	}
	if(l == 0 || l > 8) {
		var d = (this1 & 1) == 1;
		this1 <<= 1;
		if(b != null) {
			if(b) {
				this1 |= 1;
			} else {
				this1 &= -2;
			}
		}
		return d;
	} else {
		var d1;
		switch(7 - l) {
		case 0:
			d1 = (this1 & 128) == 128;
			break;
		case 1:
			d1 = (this1 & 64) == 64;
			break;
		case 2:
			d1 = (this1 & 32) == 32;
			break;
		case 3:
			d1 = (this1 & 16) == 16;
			break;
		case 4:
			d1 = (this1 & 8) == 8;
			break;
		case 5:
			d1 = (this1 & 4) == 4;
			break;
		case 6:
			d1 = (this1 & 2) == 2;
			break;
		case 7:
			d1 = (this1 & 1) == 1;
			break;
		default:
			d1 = false;
		}
		this1 <<= 1;
		if(b != null) {
			switch(7 - l) {
			case 0:
				if(b) {
					this1 |= 128;
				} else {
					this1 &= -129;
				}
				break;
			case 1:
				if(b) {
					this1 |= 64;
				} else {
					this1 &= -65;
				}
				break;
			case 2:
				if(b) {
					this1 |= 32;
				} else {
					this1 &= -33;
				}
				break;
			case 3:
				if(b) {
					this1 |= 16;
				} else {
					this1 &= -17;
				}
				break;
			case 4:
				if(b) {
					this1 |= 8;
				} else {
					this1 &= -9;
				}
				break;
			case 5:
				if(b) {
					this1 |= 4;
				} else {
					this1 &= -5;
				}
				break;
			case 6:
				if(b) {
					this1 |= 2;
				} else {
					this1 &= -3;
				}
				break;
			case 7:
				if(b) {
					this1 |= 1;
				} else {
					this1 &= -2;
				}
				break;
			default:
			}
		}
		var _g1 = 0;
		var _g = 8 - l;
		while(_g1 < _g) {
			var i = _g1++;
			switch(i) {
			case 0:
				this1 &= -129;
				break;
			case 1:
				this1 &= -65;
				break;
			case 2:
				this1 &= -33;
				break;
			case 3:
				this1 &= -17;
				break;
			case 4:
				this1 &= -9;
				break;
			case 5:
				this1 &= -5;
				break;
			case 6:
				this1 &= -3;
				break;
			case 7:
				this1 &= -2;
				break;
			default:
			}
		}
		return d1;
	}
};
trilateral_bits__$Binary8_Binary8_$Impl_$.right = function(this1,b,l) {
	if(l == null) {
		l = 0;
	}
	if(l == 0 || l > 8) {
		var d = (this1 & 128) == 128;
		this1 >>= 1;
		if(b != null) {
			if(b) {
				this1 |= 128;
			} else {
				this1 &= -129;
			}
		}
		return d;
	} else {
		var d1;
		switch(7 - l) {
		case 0:
			d1 = (this1 & 128) == 128;
			break;
		case 1:
			d1 = (this1 & 64) == 64;
			break;
		case 2:
			d1 = (this1 & 32) == 32;
			break;
		case 3:
			d1 = (this1 & 16) == 16;
			break;
		case 4:
			d1 = (this1 & 8) == 8;
			break;
		case 5:
			d1 = (this1 & 4) == 4;
			break;
		case 6:
			d1 = (this1 & 2) == 2;
			break;
		case 7:
			d1 = (this1 & 1) == 1;
			break;
		default:
			d1 = false;
		}
		this1 >>= 1;
		var _g1 = 0;
		var _g = 8 - l;
		while(_g1 < _g) {
			var i = _g1++;
			switch(i) {
			case 0:
				this1 &= -129;
				break;
			case 1:
				this1 &= -65;
				break;
			case 2:
				this1 &= -33;
				break;
			case 3:
				this1 &= -17;
				break;
			case 4:
				this1 &= -9;
				break;
			case 5:
				this1 &= -5;
				break;
			case 6:
				this1 &= -3;
				break;
			case 7:
				this1 &= -2;
				break;
			default:
			}
		}
		if(b != null) {
			switch(7 - l) {
			case 0:
				if(b) {
					this1 |= 128;
				} else {
					this1 &= -129;
				}
				break;
			case 1:
				if(b) {
					this1 |= 64;
				} else {
					this1 &= -65;
				}
				break;
			case 2:
				if(b) {
					this1 |= 32;
				} else {
					this1 &= -33;
				}
				break;
			case 3:
				if(b) {
					this1 |= 16;
				} else {
					this1 &= -17;
				}
				break;
			case 4:
				if(b) {
					this1 |= 8;
				} else {
					this1 &= -9;
				}
				break;
			case 5:
				if(b) {
					this1 |= 4;
				} else {
					this1 &= -5;
				}
				break;
			case 6:
				if(b) {
					this1 |= 2;
				} else {
					this1 &= -3;
				}
				break;
			case 7:
				if(b) {
					this1 |= 1;
				} else {
					this1 &= -2;
				}
				break;
			default:
			}
		}
		return d1;
	}
};
trilateral_bits__$Binary8_Binary8_$Impl_$.fromString = function(s) {
	var this1 = 0;
	var bs = this1;
	var l = s.length;
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		var no = s.charCodeAt(i);
		if(no == null) {
			break;
		}
		var v;
		switch(no) {
		case 32:
			v = false;
			break;
		case 42:
			v = true;
			break;
		case 48:
			v = false;
			break;
		case 49:
			v = true;
			break;
		default:
			throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(s.charCodeAt(i)));
		}
		switch(i - (l - 8)) {
		case 0:
			if(v) {
				bs |= 128;
			} else {
				bs &= -129;
			}
			break;
		case 1:
			if(v) {
				bs |= 64;
			} else {
				bs &= -65;
			}
			break;
		case 2:
			if(v) {
				bs |= 32;
			} else {
				bs &= -33;
			}
			break;
		case 3:
			if(v) {
				bs |= 16;
			} else {
				bs &= -17;
			}
			break;
		case 4:
			if(v) {
				bs |= 8;
			} else {
				bs &= -9;
			}
			break;
		case 5:
			if(v) {
				bs |= 4;
			} else {
				bs &= -5;
			}
			break;
		case 6:
			if(v) {
				bs |= 2;
			} else {
				bs &= -3;
			}
			break;
		case 7:
			if(v) {
				bs |= 1;
			} else {
				bs &= -2;
			}
			break;
		default:
		}
	}
	return bs;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.toString = function(this1) {
	var out = "";
	var bs = this1;
	var _g = 0;
	while(_g < 8) {
		var i = _g++;
		var out1;
		var out2;
		switch(i) {
		case 0:
			out2 = (bs & 128) == 128;
			break;
		case 1:
			out2 = (bs & 64) == 64;
			break;
		case 2:
			out2 = (bs & 32) == 32;
			break;
		case 3:
			out2 = (bs & 16) == 16;
			break;
		case 4:
			out2 = (bs & 8) == 8;
			break;
		case 5:
			out2 = (bs & 4) == 4;
			break;
		case 6:
			out2 = (bs & 2) == 2;
			break;
		case 7:
			out2 = (bs & 1) == 1;
			break;
		default:
			out2 = false;
		}
		if(out2) {
			out1 = "1";
		} else {
			out1 = "0";
		}
		out += out1;
	}
	return out;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.toStars = function(this1) {
	var out = "";
	var bs = this1;
	var _g = 0;
	while(_g < 8) {
		var i = _g++;
		var out1;
		var out2;
		switch(i) {
		case 0:
			out2 = (bs & 128) == 128;
			break;
		case 1:
			out2 = (bs & 64) == 64;
			break;
		case 2:
			out2 = (bs & 32) == 32;
			break;
		case 3:
			out2 = (bs & 16) == 16;
			break;
		case 4:
			out2 = (bs & 8) == 8;
			break;
		case 5:
			out2 = (bs & 4) == 4;
			break;
		case 6:
			out2 = (bs & 2) == 2;
			break;
		case 7:
			out2 = (bs & 1) == 1;
			break;
		default:
			out2 = false;
		}
		if(out2) {
			out1 = "* ";
		} else {
			out1 = "  ";
		}
		out += out1;
	}
	return out;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.toBytes = function(this1) {
	var o = new haxe_io_BytesOutput();
	o.writeByte(0);
	var by = o.getBytes();
	by.b[0] = this1 & 255;
	return by;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.fromBytes = function(b) {
	var this1 = b.b[0];
	return this1;
};
trilateral_bits__$Binary8_Binary8_$Impl_$.toHexString = function(this1) {
	return "0x" + StringTools.hex(this1,2);
};
trilateral_bits__$Binary8_Binary8_$Impl_$.get_iteratorBool = function(this1) {
	return new trilateral_bits_Binary8IteratorBool(this1);
};
trilateral_bits__$Binary8_Binary8_$Impl_$.get_iteratorInt = function(this1) {
	return new trilateral_bits_Binary8IteratorInt(this1);
};
var trilateral_bits_Binary8IteratorBool = function(binary8_) {
	this.count = 0;
	this.count = 0;
	this.binary8 = binary8_;
};
$hxClasses["trilateral.bits.Binary8IteratorBool"] = trilateral_bits_Binary8IteratorBool;
trilateral_bits_Binary8IteratorBool.__name__ = true;
trilateral_bits_Binary8IteratorBool.prototype = {
	count: null
	,binary8: null
	,hasNext: function() {
		if(this.count < 8) {
			return true;
		} else {
			this.binary8 = null;
			this.count = 0;
			return false;
		}
	}
	,next: function() {
		var this1 = this.binary8;
		var b;
		switch(this.count) {
		case 0:
			b = (this1 & 128) == 128;
			break;
		case 1:
			b = (this1 & 64) == 64;
			break;
		case 2:
			b = (this1 & 32) == 32;
			break;
		case 3:
			b = (this1 & 16) == 16;
			break;
		case 4:
			b = (this1 & 8) == 8;
			break;
		case 5:
			b = (this1 & 4) == 4;
			break;
		case 6:
			b = (this1 & 2) == 2;
			break;
		case 7:
			b = (this1 & 1) == 1;
			break;
		default:
			b = false;
		}
		return b;
	}
	,__class__: trilateral_bits_Binary8IteratorBool
};
var trilateral_bits_Binary8IteratorInt = function(binary8_) {
	this.count = 0;
	this.count = 0;
	this.binary8 = binary8_;
};
$hxClasses["trilateral.bits.Binary8IteratorInt"] = trilateral_bits_Binary8IteratorInt;
trilateral_bits_Binary8IteratorInt.__name__ = true;
trilateral_bits_Binary8IteratorInt.prototype = {
	count: null
	,binary8: null
	,hasNext: function() {
		if(this.count < 8) {
			return true;
		} else {
			this.binary8 = null;
			this.count = 0;
			return false;
		}
	}
	,next: function() {
		var this1 = this.binary8;
		var b;
		switch(this.count) {
		case 0:
			b = (this1 & 128) == 128;
			break;
		case 1:
			b = (this1 & 64) == 64;
			break;
		case 2:
			b = (this1 & 32) == 32;
			break;
		case 3:
			b = (this1 & 16) == 16;
			break;
		case 4:
			b = (this1 & 8) == 8;
			break;
		case 5:
			b = (this1 & 4) == 4;
			break;
		case 6:
			b = (this1 & 2) == 2;
			break;
		case 7:
			b = (this1 & 1) == 1;
			break;
		default:
			b = false;
		}
		var b1 = b == true ? 1 : 0;
		return b1;
	}
	,__class__: trilateral_bits_Binary8IteratorInt
};
var trilateral_geom_Algebra = function() { };
$hxClasses["trilateral.geom.Algebra"] = trilateral_geom_Algebra;
trilateral_geom_Algebra.__name__ = true;
trilateral_geom_Algebra.theta = function(p0,p1) {
	var dx = p0.x - p1.x;
	var dy = p0.y - p1.y;
	return Math.atan2(dy,dx);
};
trilateral_geom_Algebra.dist = function(p0,p1) {
	var dx = p0.x - p1.x;
	var dy = p0.y - p1.y;
	return dx * dx + dy * dy;
};
trilateral_geom_Algebra.adjustWinding = function(A_,B_,C_) {
	var p0_y;
	var p0_x = B_.x - A_.x;
	p0_y = B_.y - A_.y;
	var p1_y;
	var p1_x = C_.x - A_.x;
	p1_y = C_.y - A_.y;
	var val = !(p0_x * p1_y - p0_y * p1_x < 0);
	return val;
};
trilateral_geom_Algebra.subtract = function(p0,p1) {
	return { x : p0.x - p1.x, y : p0.y - p1.y};
};
trilateral_geom_Algebra.cross = function(p0,p1) {
	return p0.x * p1.y - p0.y * p1.x;
};
trilateral_geom_Algebra.sign = function(n) {
	return Math.abs(n) / n | 0;
};
trilateral_geom_Algebra.quadratic = function(t,s,c,e) {
	var u = 1 - t;
	return Math.pow(u,2) * s + 2 * u * t * c + Math.pow(t,2) * e;
};
trilateral_geom_Algebra.cubic = function(t,s,c1,c2,e) {
	var u = 1 - t;
	return Math.pow(u,3) * s + 3 * Math.pow(u,2) * t * c1 + 3 * u * Math.pow(t,2) * c2 + Math.pow(t,3) * e;
};
trilateral_geom_Algebra.quadCurve = function(p,ax,ay,bx,by,cx,cy) {
	var x = ax - bx;
	var y = ay - by;
	var x1 = bx - cx;
	var y1 = by - cy;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	var step = Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.quadStep);
	var l = p.length;
	p[l++] = ax;
	p[l++] = ay;
	var t = step;
	while(t < 1.) {
		var u = 1 - t;
		p[l++] = Math.pow(u,2) * ax + 2 * u * t * bx + Math.pow(t,2) * cx;
		var u1 = 1 - t;
		p[l++] = Math.pow(u1,2) * ay + 2 * u1 * t * by + Math.pow(t,2) * cy;
		t += step;
	}
	p[l++] = cx;
	p[l++] = cy;
	return p;
};
trilateral_geom_Algebra.cubicCurve = function(p,ax,ay,bx,by,cx,cy,dx,dy) {
	var x = ax - bx;
	var y = ay - by;
	var x1 = bx - cx;
	var y1 = by - cy;
	var x2 = cx - dx;
	var y2 = cy - dy;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2);
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	var step = Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.cubicStep);
	var l = p.length;
	p[l++] = ax;
	p[l++] = ay;
	var t = step;
	while(t < 1.) {
		var u = 1 - t;
		p[l++] = Math.pow(u,3) * ax + 3 * Math.pow(u,2) * t * bx + 3 * u * Math.pow(t,2) * cx + Math.pow(t,3) * dx;
		var u1 = 1 - t;
		p[l++] = Math.pow(u1,3) * ay + 3 * Math.pow(u1,2) * t * by + 3 * u1 * Math.pow(t,2) * cy + Math.pow(t,3) * dy;
		t += step;
	}
	p[l++] = dx;
	p[l++] = dy;
	return p;
};
trilateral_geom_Algebra.calculateQuadStep = function(ax,ay,bx,by,cx,cy) {
	var x = ax - bx;
	var y = ay - by;
	var x1 = bx - cx;
	var y1 = by - cy;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	return Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.quadStep);
};
trilateral_geom_Algebra.calculateCubicStep = function(ax,ay,bx,by,cx,cy,dx,dy) {
	var x = ax - bx;
	var y = ay - by;
	var x1 = bx - cx;
	var y1 = by - cy;
	var x2 = cx - dx;
	var y2 = cy - dy;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2);
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	return Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.cubicStep);
};
trilateral_geom_Algebra.lineAB = function(A,B,width) {
	var dx = A.x - B.x;
	var dy = A.y - B.y;
	var P_y;
	var P_x = A.x - width / 2;
	P_y = A.y;
	var omega = Math.atan2(dy,dx);
	var dim_y;
	var dim_x = width;
	dim_y = dx * dx + dy * dy;
	var pivotX = A.x + width / 2;
	var pivotY = A.y;
	var px = P_x;
	var py = P_y;
	var dx1 = dim_x;
	var dy1 = dim_y;
	var A_ = { x : px, y : py};
	var B_ = { x : px + dx1, y : py};
	var C_ = { x : px + dx1, y : py + dy1};
	var D_ = { x : px, y : py + dy1};
	if(omega != 0.) {
		var sin = Math.sin(omega);
		var cos = Math.cos(omega);
		var px1 = A_.x - pivotX;
		var py1 = A_.y - pivotY;
		var px2 = px1 * cos - py1 * sin;
		py1 = py1 * cos + px1 * sin;
		A_ = { x : px2 + pivotX, y : py1 + pivotY};
		var px3 = B_.x - pivotX;
		var py2 = B_.y - pivotY;
		var px21 = px3 * cos - py2 * sin;
		py2 = py2 * cos + px3 * sin;
		B_ = { x : px21 + pivotX, y : py2 + pivotY};
		var px4 = C_.x - pivotX;
		var py3 = C_.y - pivotY;
		var px22 = px4 * cos - py3 * sin;
		py3 = py3 * cos + px4 * sin;
		C_ = { x : px22 + pivotX, y : py3 + pivotY};
		var px5 = D_.x - pivotX;
		var py4 = D_.y - pivotY;
		var px23 = px5 * cos - py4 * sin;
		py4 = py4 * cos + px5 * sin;
		D_ = { x : px23 + pivotX, y : py4 + pivotY};
	}
	return { A : A_, B : B_, C : C_, D : D_};
};
trilateral_geom_Algebra.lineABCoord = function(ax,ay,bx,by,width) {
	var dx = ax - bx;
	var dy = ay - by;
	var P_y;
	var P_x = ax - width / 2;
	P_y = ay;
	var omega = Math.atan2(dy,dx);
	var dim_y;
	var dim_x = width;
	dim_y = dx * dx + dy * dy;
	var pivotX = ax + width / 2;
	var px = P_x;
	var py = P_y;
	var dx1 = dim_x;
	var dy1 = dim_y;
	var A_ = { x : px, y : py};
	var B_ = { x : px + dx1, y : py};
	var C_ = { x : px + dx1, y : py + dy1};
	var D_ = { x : px, y : py + dy1};
	if(omega != 0.) {
		var sin = Math.sin(omega);
		var cos = Math.cos(omega);
		var px1 = A_.x - pivotX;
		var py1 = A_.y - ay;
		var px2 = px1 * cos - py1 * sin;
		py1 = py1 * cos + px1 * sin;
		A_ = { x : px2 + pivotX, y : py1 + ay};
		var px3 = B_.x - pivotX;
		var py2 = B_.y - ay;
		var px21 = px3 * cos - py2 * sin;
		py2 = py2 * cos + px3 * sin;
		B_ = { x : px21 + pivotX, y : py2 + ay};
		var px4 = C_.x - pivotX;
		var py3 = C_.y - ay;
		var px22 = px4 * cos - py3 * sin;
		py3 = py3 * cos + px4 * sin;
		C_ = { x : px22 + pivotX, y : py3 + ay};
		var px5 = D_.x - pivotX;
		var py4 = D_.y - ay;
		var px23 = px5 * cos - py4 * sin;
		py4 = py4 * cos + px5 * sin;
		D_ = { x : px23 + pivotX, y : py4 + ay};
	}
	return { A : A_, B : B_, C : C_, D : D_};
};
trilateral_geom_Algebra.rotateVectorLine = function(pos,dim,omega,pivotX,pivotY) {
	var px = pos.x;
	var py = pos.y;
	var dx = dim.x;
	var dy = dim.y;
	var A_ = { x : px, y : py};
	var B_ = { x : px + dx, y : py};
	var C_ = { x : px + dx, y : py + dy};
	var D_ = { x : px, y : py + dy};
	if(omega != 0.) {
		var sin = Math.sin(omega);
		var cos = Math.cos(omega);
		var px1 = A_.x - pivotX;
		var py1 = A_.y - pivotY;
		var px2 = px1 * cos - py1 * sin;
		py1 = py1 * cos + px1 * sin;
		A_ = { x : px2 + pivotX, y : py1 + pivotY};
		var px3 = B_.x - pivotX;
		var py2 = B_.y - pivotY;
		var px21 = px3 * cos - py2 * sin;
		py2 = py2 * cos + px3 * sin;
		B_ = { x : px21 + pivotX, y : py2 + pivotY};
		var px4 = C_.x - pivotX;
		var py3 = C_.y - pivotY;
		var px22 = px4 * cos - py3 * sin;
		py3 = py3 * cos + px4 * sin;
		C_ = { x : px22 + pivotX, y : py3 + pivotY};
		var px5 = D_.x - pivotX;
		var py4 = D_.y - pivotY;
		var px23 = px5 * cos - py4 * sin;
		py4 = py4 * cos + px5 * sin;
		D_ = { x : px23 + pivotX, y : py4 + pivotY};
	}
	return { A : A_, B : B_, C : C_, D : D_};
};
trilateral_geom_Algebra.pivotCheap = function(p,sin,cos,pivotX,pivotY) {
	var px = p.x - pivotX;
	var py = p.y - pivotY;
	var px2 = px * cos - py * sin;
	py = py * cos + px * sin;
	return { x : px2 + pivotX, y : py + pivotY};
};
trilateral_geom_Algebra.pivot = function(p,omega,pivotX,pivotY) {
	var px = p.x - pivotX;
	var py = p.y - pivotY;
	var px2 = px * Math.cos(omega) - py * Math.sin(omega);
	py = py * Math.cos(omega) + px * Math.sin(omega);
	return { x : px2 + pivotX, y : py + pivotY};
};
trilateral_geom_Algebra.thetaCheap = function(dx,dy) {
	return Math.atan2(dy,dx);
};
trilateral_geom_Algebra.distCheap = function(dx,dy) {
	return dx * dx + dy * dy;
};
trilateral_geom_Algebra.distance = function(px,py,qx,qy) {
	var x = px - qx;
	var y = py - qy;
	return Math.sqrt(x * x + y * y);
};
var trilateral_geom_Contour = function(triArr_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.count = 0;
	this.triArr = triArr_;
	this.endLine = endLine_;
};
$hxClasses["trilateral.geom.Contour"] = trilateral_geom_Contour;
trilateral_geom_Contour.__name__ = true;
trilateral_geom_Contour.thetaCompute = function(px,py,qx,qy) {
	return Math.atan2(py - qy,px - qx);
};
trilateral_geom_Contour.dist = function(px,py,qx,qy) {
	var x = px - qx;
	var y = py - qy;
	return x * x + y * y;
};
trilateral_geom_Contour.prototype = {
	triArr: null
	,endLine: null
	,ax: null
	,ay: null
	,bx: null
	,by: null
	,cx: null
	,cy: null
	,dx: null
	,dy: null
	,ex: null
	,ey: null
	,dxPrev: null
	,dyPrev: null
	,exPrev: null
	,eyPrev: null
	,dxOld: null
	,dyOld: null
	,exOld: null
	,eyOld: null
	,jx: null
	,jy: null
	,lastClock: null
	,jxOld: null
	,jyOld: null
	,kax: null
	,kay: null
	,kbx: null
	,kby: null
	,kcx: null
	,kcy: null
	,nax: null
	,nay: null
	,nbx: null
	,nby: null
	,ncx: null
	,ncy: null
	,quadIndex: null
	,angleA: null
	,halfA: null
	,beta: null
	,r: null
	,theta: null
	,angle1: null
	,angle2: null
	,reset: function() {
		this.angleA = 0;
		this.count = 0;
		this.kax = 0;
		this.kay = 0;
		this.kbx = 0;
		this.kby = 0;
		this.kcx = 0;
		this.kcy = 0;
		this.nax = 0;
		this.nay = 0;
		this.nbx = 0;
		this.nby = 0;
		this.ncx = 0;
		this.ncy = 0;
		this.ax = 0;
		this.ay = 0;
		this.bx = 0;
		this.by = 0;
		this.cx = 0;
		this.cy = 0;
		this.dx = null;
		this.dy = null;
		this.ex = null;
		this.ey = null;
	}
	,count: null
	,triangleJoin: function(ax_,ay_,bx_,by_,width_,curveEnds,overlap) {
		if(overlap == null) {
			overlap = false;
		}
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = this.dx != null ? this.angle1 : null;
		this.halfA = Math.PI / 2;
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var x = this.dxOld - bx_;
		var y = this.dyOld - by_;
		var x1 = this.exOld - bx_;
		var y1 = this.eyOld - by_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(this.ay - this.dyOld,this.ax - this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.eyPrev,this.ax - this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(this.ay - this.eyOld,this.ax - this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.dyPrev,this.ax - this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(trilateral_angle_DifferencePreference.SMALL[1]) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				if(a >= 0) {
					f = a;
				} else {
					f = a + 2 * Math.PI;
				}
			}
			var this1 = f;
			var za = this1;
			var f1;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f1 = theta1;
			} else {
				var a1 = theta1 % (2 * Math.PI);
				if(a1 >= 0) {
					f1 = a1;
				} else {
					f1 = a1 + 2 * Math.PI;
				}
			}
			var this2 = f1;
			var zb = this2;
			var fa = theta0;
			var fb = theta1;
			var theta = Math.abs(theta0 - theta1);
			var clockwise = theta0 < theta1;
			var dif1 = clockwise ? theta : -theta;
			if(dif1 > 0) {
				dif = dif1;
			} else {
				dif = 2 * Math.PI + dif1;
			}
			break;
		case 1:
			var f2;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f2 = theta0;
			} else {
				var a2 = theta0 % (2 * Math.PI);
				if(a2 >= 0) {
					f2 = a2;
				} else {
					f2 = a2 + 2 * Math.PI;
				}
			}
			var this3 = f2;
			var za1 = this3;
			var f3;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f3 = theta1;
			} else {
				var a3 = theta1 % (2 * Math.PI);
				if(a3 >= 0) {
					f3 = a3;
				} else {
					f3 = a3 + 2 * Math.PI;
				}
			}
			var this4 = f3;
			var zb1 = this4;
			var fa1 = theta0;
			var fb1 = theta1;
			var theta2 = Math.abs(theta0 - theta1);
			var clockwise1 = theta0 < theta1;
			var dif2 = clockwise1 ? theta2 : -theta2;
			if(dif2 < 0) {
				dif = dif2;
			} else {
				dif = -2 * Math.PI + dif2;
			}
			break;
		case 2:
			var f4;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f4 = theta0;
			} else {
				var a4 = theta0 % (2 * Math.PI);
				if(a4 >= 0) {
					f4 = a4;
				} else {
					f4 = a4 + 2 * Math.PI;
				}
			}
			var this5 = f4;
			var za2 = this5;
			var f5;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f5 = theta1;
			} else {
				var a5 = theta1 % (2 * Math.PI);
				if(a5 >= 0) {
					f5 = a5;
				} else {
					f5 = a5 + 2 * Math.PI;
				}
			}
			var this6 = f5;
			var zb2 = this6;
			var fa2 = theta0;
			var fb2 = theta1;
			var theta3 = Math.abs(theta0 - theta1);
			var smallest = theta3 <= Math.PI;
			var clockwise2 = theta0 < theta1;
			var dif3 = clockwise2 ? theta3 : -theta3;
			if(smallest) {
				dif = dif3;
			} else if(clockwise2) {
				dif = -(2 * Math.PI - theta3);
			} else {
				dif = 2 * Math.PI - theta3;
			}
			break;
		case 3:
			var f6;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f6 = theta0;
			} else {
				var a6 = theta0 % (2 * Math.PI);
				if(a6 >= 0) {
					f6 = a6;
				} else {
					f6 = a6 + 2 * Math.PI;
				}
			}
			var this7 = f6;
			var za3 = this7;
			var f7;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f7 = theta1;
			} else {
				var a7 = theta1 % (2 * Math.PI);
				if(a7 >= 0) {
					f7 = a7;
				} else {
					f7 = a7 + 2 * Math.PI;
				}
			}
			var this8 = f7;
			var zb3 = this8;
			var fa3 = theta0;
			var fb3 = theta1;
			var theta4 = Math.abs(theta0 - theta1);
			var largest = theta4 > Math.PI;
			var clockwise3 = theta0 < theta1;
			var dif4 = clockwise3 ? theta4 : -theta4;
			if(largest) {
				dif = dif4;
			} else if(clockwise3) {
				dif = -(2 * Math.PI - theta4);
			} else {
				dif = 2 * Math.PI - theta4;
			}
			break;
		}
		if(!overlap && this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ * Math.sin(gamma);
			var f8;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f8 = theta0;
			} else {
				var a8 = (theta0 + Math.PI) % (2 * Math.PI);
				if(a8 >= 0) {
					f8 = a8 - Math.PI;
				} else {
					f8 = a8 + Math.PI;
				}
			}
			var this9 = f8;
			var start = this9;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			this.jx = this.ax + h * Math.sin(delta);
			this.jy = this.ay + h * Math.cos(delta);
		}
		if(this.count == 0 && (this.endLine == 1 || this.endLine == 3)) {
			var ax = this.ax;
			var ay = this.ay;
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma1 = -this.angle1 - Math.PI / 2 + Math.PI;
			var this10 = this.triArr;
			var this11 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
			var out = this11;
			var pi = Math.PI;
			var step = pi * 2 / 36;
			var dif5;
			switch(trilateral_angle_DifferencePreference.SMALL[1]) {
			case 0:
				var f9;
				if(beta >= 0 && beta > Math.PI) {
					f9 = beta;
				} else {
					var a9 = beta % (2 * Math.PI);
					if(a9 >= 0) {
						f9 = a9;
					} else {
						f9 = a9 + 2 * Math.PI;
					}
				}
				var this12 = f9;
				var za4 = this12;
				var f10;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f10 = gamma1;
				} else {
					var a10 = gamma1 % (2 * Math.PI);
					if(a10 >= 0) {
						f10 = a10;
					} else {
						f10 = a10 + 2 * Math.PI;
					}
				}
				var this13 = f10;
				var zb4 = this13;
				var fa4 = beta;
				var fb4 = gamma1;
				var theta5 = Math.abs(beta - gamma1);
				var clockwise4 = beta < gamma1;
				var dif6 = clockwise4 ? theta5 : -theta5;
				if(dif6 > 0) {
					dif5 = dif6;
				} else {
					dif5 = 2 * Math.PI + dif6;
				}
				break;
			case 1:
				var f11;
				if(beta >= 0 && beta > Math.PI) {
					f11 = beta;
				} else {
					var a11 = beta % (2 * Math.PI);
					if(a11 >= 0) {
						f11 = a11;
					} else {
						f11 = a11 + 2 * Math.PI;
					}
				}
				var this14 = f11;
				var za5 = this14;
				var f12;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f12 = gamma1;
				} else {
					var a12 = gamma1 % (2 * Math.PI);
					if(a12 >= 0) {
						f12 = a12;
					} else {
						f12 = a12 + 2 * Math.PI;
					}
				}
				var this15 = f12;
				var zb5 = this15;
				var fa5 = beta;
				var fb5 = gamma1;
				var theta6 = Math.abs(beta - gamma1);
				var clockwise5 = beta < gamma1;
				var dif7 = clockwise5 ? theta6 : -theta6;
				if(dif7 < 0) {
					dif5 = dif7;
				} else {
					dif5 = -2 * Math.PI + dif7;
				}
				break;
			case 2:
				var f13;
				if(beta >= 0 && beta > Math.PI) {
					f13 = beta;
				} else {
					var a13 = beta % (2 * Math.PI);
					if(a13 >= 0) {
						f13 = a13;
					} else {
						f13 = a13 + 2 * Math.PI;
					}
				}
				var this16 = f13;
				var za6 = this16;
				var f14;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f14 = gamma1;
				} else {
					var a14 = gamma1 % (2 * Math.PI);
					if(a14 >= 0) {
						f14 = a14;
					} else {
						f14 = a14 + 2 * Math.PI;
					}
				}
				var this17 = f14;
				var zb6 = this17;
				var fa6 = beta;
				var fb6 = gamma1;
				var theta7 = Math.abs(beta - gamma1);
				var smallest1 = theta7 <= Math.PI;
				var clockwise6 = beta < gamma1;
				var dif8 = clockwise6 ? theta7 : -theta7;
				if(smallest1) {
					dif5 = dif8;
				} else if(clockwise6) {
					dif5 = -(2 * Math.PI - theta7);
				} else {
					dif5 = 2 * Math.PI - theta7;
				}
				break;
			case 3:
				var f15;
				if(beta >= 0 && beta > Math.PI) {
					f15 = beta;
				} else {
					var a15 = beta % (2 * Math.PI);
					if(a15 >= 0) {
						f15 = a15;
					} else {
						f15 = a15 + 2 * Math.PI;
					}
				}
				var this18 = f15;
				var za7 = this18;
				var f16;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f16 = gamma1;
				} else {
					var a16 = gamma1 % (2 * Math.PI);
					if(a16 >= 0) {
						f16 = a16;
					} else {
						f16 = a16 + 2 * Math.PI;
					}
				}
				var this19 = f16;
				var zb7 = this19;
				var fa7 = beta;
				var fb7 = gamma1;
				var theta8 = Math.abs(beta - gamma1);
				var largest1 = theta8 > Math.PI;
				var clockwise7 = beta < gamma1;
				var dif9 = clockwise7 ? theta8 : -theta8;
				if(largest1) {
					dif5 = dif9;
				} else if(clockwise7) {
					dif5 = -(2 * Math.PI - theta8);
				} else {
					dif5 = 2 * Math.PI - theta8;
				}
				break;
			}
			var positive = dif5 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif5) / step);
			var step1 = dif5 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g1 = 0;
			var _g = totalSteps + 1;
			while(_g1 < _g) {
				var i = _g1++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				if(i != 0) {
					var t = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
					out[out.length] = t;
				}
				angle += step1;
				bx = cx;
				by = cy;
			}
			var triArr = out;
			var _g2 = 0;
			while(_g2 < triArr.length) {
				var t1 = triArr[_g2];
				++_g2;
				this10[this10.length] = t1;
			}
		}
		if(curveEnds) {
			var radius1 = width_ / 2;
			var this20 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
			var out1 = this20;
			var pi1 = Math.PI;
			var step2 = pi1 * 2 / 36;
			var positive1 = dif >= 0;
			var totalSteps1 = Math.ceil(Math.abs(dif) / step2);
			var step3 = dif / totalSteps1;
			var angle1 = theta0;
			var cx1;
			var cy1;
			var bx1 = 0;
			var by1 = 0;
			var _g11 = 0;
			var _g3 = totalSteps1 + 1;
			while(_g11 < _g3) {
				var i1 = _g11++;
				cx1 = ax_ + radius1 * Math.sin(angle1);
				cy1 = ay_ + radius1 * Math.cos(angle1);
				if(i1 != 0) {
					var t2 = new trilateral_tri_Trilateral(ax_,ay_,bx1,by1,cx1,cy1);
					out1[out1.length] = t2;
				}
				angle1 += step3;
				bx1 = cx1;
				by1 = cy1;
			}
			var trilateralArray = out1;
			var this21 = this.triArr;
			var _g4 = 0;
			while(_g4 < trilateralArray.length) {
				var t3 = trilateralArray[_g4];
				++_g4;
				this21[this21.length] = t3;
			}
		} else if(this.count != 0) {
			if(overlap) {
				if(clockWise) {
					var this22 = this.triArr;
					var tri = new trilateral_tri_Trilateral(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.ax,this.ay,0);
					this22[this22.length] = tri;
				} else {
					var this23 = this.triArr;
					var tri1 = new trilateral_tri_Trilateral(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.ax,this.ay,0);
					this23[this23.length] = tri1;
				}
			} else if(clockWise) {
				var this24 = this.triArr;
				var tri2 = new trilateral_tri_Trilateral(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.jx,this.jy,0);
				this24[this24.length] = tri2;
			} else {
				var this25 = this.triArr;
				var tri3 = new trilateral_tri_Trilateral(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.jx,this.jy,0);
				this25[this25.length] = tri3;
			}
		}
		if(overlap) {
			var this26 = this.triArr;
			var tri4 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,0);
			this26[this26.length] = tri4;
			var this27 = this.triArr;
			var tri5 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,0);
			this27[this27.length] = tri5;
		} else {
			if(this.count != 0) {
				if(clockWise && !this.lastClock) {
					if(this.count == 1) {
						this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.nax,this.nay,this.nbx,this.nby,this.ncx,this.ncy);
					} else {
						this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.nax,this.nay,this.nbx,this.nby,this.jxOld,this.jyOld);
					}
					this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy);
				}
				if(clockWise && this.lastClock) {
					if(this.count == 1) {
						this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy);
						this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.nax,this.nay,this.nbx,this.nby,this.ncx,this.ncy);
					} else {
						this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.jxOld,this.jyOld,this.kbx,this.kby,this.jx,this.jy);
						this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.jxOld,this.jyOld,this.nbx,this.nby,this.ncx,this.ncy);
					}
				}
				if(!clockWise && !this.lastClock) {
					this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy);
					if(this.count == 1) {
						this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.nax,this.nay,this.jx,this.jy,this.ncx,this.ncy);
					} else {
						this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.nax,this.nay,this.jx,this.jy,this.jxOld,this.jyOld);
					}
				}
				if(!clockWise && this.lastClock) {
					if(this.count == 1) {
						this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy);
						this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.nax,this.nay,this.jx,this.jy,this.ncx,this.ncy);
					} else {
						this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.jxOld,this.jyOld,this.jx,this.jy,this.kcx,this.kcy);
						this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.jxOld,this.jyOld,this.jx,this.jy,this.ncx,this.ncy);
					}
				}
			}
			this.quadIndex = this.triArr.length;
			if(this.count == 0) {
				var this28 = this.triArr;
				var tri6 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,0);
				this28[this28.length] = tri6;
				var this29 = this.triArr;
				var tri7 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,0);
				this29[this29.length] = tri7;
			} else {
				if(clockWise && !this.lastClock) {
					var this30 = this.triArr;
					var tri8 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,0);
					this30[this30.length] = tri8;
					var this31 = this.triArr;
					var tri9 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,0);
					this31[this31.length] = tri9;
				}
				if(clockWise && this.lastClock) {
					var this32 = this.triArr;
					var tri10 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,0);
					this32[this32.length] = tri10;
					var this33 = this.triArr;
					var tri11 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,0);
					this33[this33.length] = tri11;
				}
				if(!clockWise && !this.lastClock) {
					var this34 = this.triArr;
					var tri12 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.jx,this.jy,0);
					this34[this34.length] = tri12;
					var this35 = this.triArr;
					var tri13 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,0);
					this35[this35.length] = tri13;
				}
				if(!clockWise && this.lastClock) {
					var this36 = this.triArr;
					var tri14 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,0);
					this36[this36.length] = tri14;
					var this37 = this.triArr;
					var tri15 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.jx,this.jy,this.ex,this.ey,0);
					this37[this37.length] = tri15;
				}
			}
		}
		this.nax = this.dxPrev;
		this.nay = this.dyPrev;
		this.nbx = this.dx;
		this.nby = this.dy;
		this.ncx = this.exPrev;
		this.ncy = this.eyPrev;
		this.kax = this.dxPrev;
		this.kay = this.dyPrev;
		this.kbx = this.dx;
		this.kby = this.dy;
		this.kcx = this.ex;
		this.kcy = this.ey;
		if(curveEnds && !overlap && this.count != 0) {
			if(clockWise) {
				var this38 = this.triArr;
				var tri16 = new trilateral_tri_Trilateral(this.ax,this.ay,this.dxOld,this.dyOld,this.jx,this.jy,0);
				this38[this38.length] = tri16;
				var this39 = this.triArr;
				var tri17 = new trilateral_tri_Trilateral(this.ax,this.ay,this.exPrev,this.eyPrev,this.jx,this.jy,0);
				this39[this39.length] = tri17;
			} else {
				var this40 = this.triArr;
				var tri18 = new trilateral_tri_Trilateral(this.ax,this.ay,this.exOld,this.eyOld,this.jx,this.jy,0);
				this40[this40.length] = tri18;
				var this41 = this.triArr;
				var tri19 = new trilateral_tri_Trilateral(this.ax,this.ay,this.dxPrev,this.dyPrev,this.jx,this.jy,0);
				this41[this41.length] = tri19;
			}
		}
		this.jxOld = this.jx;
		this.jyOld = this.jy;
		this.lastClock = clockWise;
		this.count++;
		return this.triArr;
	}
	,overlapQuad: function() {
		var this1 = this.triArr;
		var tri = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,0);
		this1[this1.length] = tri;
		var this2 = this.triArr;
		var tri1 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,0);
		this2[this2.length] = tri1;
	}
	,end: function(width_) {
		var ax = this.bx;
		var ay = this.by;
		var radius = width_ / 2;
		var beta = -this.angle1 - Math.PI / 2;
		var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
		var this1 = this.triArr;
		var this2 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out = this2;
		var pi = Math.PI;
		var step = pi * 2 / 36;
		var dif;
		switch(trilateral_angle_DifferencePreference.SMALL[1]) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				if(a >= 0) {
					f = a;
				} else {
					f = a + 2 * Math.PI;
				}
			}
			var this3 = f;
			var za = this3;
			var f1;
			if(gamma >= 0 && gamma > Math.PI) {
				f1 = gamma;
			} else {
				var a1 = gamma % (2 * Math.PI);
				if(a1 >= 0) {
					f1 = a1;
				} else {
					f1 = a1 + 2 * Math.PI;
				}
			}
			var this4 = f1;
			var zb = this4;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			if(dif1 > 0) {
				dif = dif1;
			} else {
				dif = 2 * Math.PI + dif1;
			}
			break;
		case 1:
			var f2;
			if(beta >= 0 && beta > Math.PI) {
				f2 = beta;
			} else {
				var a2 = beta % (2 * Math.PI);
				if(a2 >= 0) {
					f2 = a2;
				} else {
					f2 = a2 + 2 * Math.PI;
				}
			}
			var this5 = f2;
			var za1 = this5;
			var f3;
			if(gamma >= 0 && gamma > Math.PI) {
				f3 = gamma;
			} else {
				var a3 = gamma % (2 * Math.PI);
				if(a3 >= 0) {
					f3 = a3;
				} else {
					f3 = a3 + 2 * Math.PI;
				}
			}
			var this6 = f3;
			var zb1 = this6;
			var fa1 = beta;
			var fb1 = gamma;
			var theta1 = Math.abs(beta - gamma);
			var clockwise1 = beta < gamma;
			var dif2 = clockwise1 ? theta1 : -theta1;
			if(dif2 < 0) {
				dif = dif2;
			} else {
				dif = -2 * Math.PI + dif2;
			}
			break;
		case 2:
			var f4;
			if(beta >= 0 && beta > Math.PI) {
				f4 = beta;
			} else {
				var a4 = beta % (2 * Math.PI);
				if(a4 >= 0) {
					f4 = a4;
				} else {
					f4 = a4 + 2 * Math.PI;
				}
			}
			var this7 = f4;
			var za2 = this7;
			var f5;
			if(gamma >= 0 && gamma > Math.PI) {
				f5 = gamma;
			} else {
				var a5 = gamma % (2 * Math.PI);
				if(a5 >= 0) {
					f5 = a5;
				} else {
					f5 = a5 + 2 * Math.PI;
				}
			}
			var this8 = f5;
			var zb2 = this8;
			var fa2 = beta;
			var fb2 = gamma;
			var theta2 = Math.abs(beta - gamma);
			var smallest = theta2 <= Math.PI;
			var clockwise2 = beta < gamma;
			var dif3 = clockwise2 ? theta2 : -theta2;
			if(smallest) {
				dif = dif3;
			} else if(clockwise2) {
				dif = -(2 * Math.PI - theta2);
			} else {
				dif = 2 * Math.PI - theta2;
			}
			break;
		case 3:
			var f6;
			if(beta >= 0 && beta > Math.PI) {
				f6 = beta;
			} else {
				var a6 = beta % (2 * Math.PI);
				if(a6 >= 0) {
					f6 = a6;
				} else {
					f6 = a6 + 2 * Math.PI;
				}
			}
			var this9 = f6;
			var za3 = this9;
			var f7;
			if(gamma >= 0 && gamma > Math.PI) {
				f7 = gamma;
			} else {
				var a7 = gamma % (2 * Math.PI);
				if(a7 >= 0) {
					f7 = a7;
				} else {
					f7 = a7 + 2 * Math.PI;
				}
			}
			var this10 = f7;
			var zb3 = this10;
			var fa3 = beta;
			var fb3 = gamma;
			var theta3 = Math.abs(beta - gamma);
			var largest = theta3 > Math.PI;
			var clockwise3 = beta < gamma;
			var dif4 = clockwise3 ? theta3 : -theta3;
			if(largest) {
				dif = dif4;
			} else if(clockwise3) {
				dif = -(2 * Math.PI - theta3);
			} else {
				dif = 2 * Math.PI - theta3;
			}
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step1 = dif / totalSteps;
		var angle = beta;
		var cx;
		var cy;
		var bx = 0;
		var by = 0;
		var _g1 = 0;
		var _g = totalSteps + 1;
		while(_g1 < _g) {
			var i = _g1++;
			cx = ax + radius * Math.sin(angle);
			cy = ay + radius * Math.cos(angle);
			if(i != 0) {
				var t = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
				out[out.length] = t;
			}
			angle += step1;
			bx = cx;
			by = cy;
		}
		var triArr = out;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t1 = triArr[_g2];
			++_g2;
			this1[this1.length] = t1;
		}
	}
	,add: function(trilateral1) {
		var this1 = this.triArr;
		this1[this1.length] = trilateral1;
	}
	,addArray: function(trilateralArray) {
		var this1 = this.triArr;
		var _g = 0;
		while(_g < trilateralArray.length) {
			var t = trilateralArray[_g];
			++_g;
			this1[this1.length] = t;
		}
	}
	,addTri: function(ax_,ay_,bx_,by_,cx_,cy_,mark_) {
		if(mark_ == null) {
			mark_ = 0;
		}
		var this1 = this.triArr;
		var tri = new trilateral_tri_Trilateral(ax_,ay_,bx_,by_,cx_,cy_,mark_);
		this1[this1.length] = tri;
	}
	,addPie: function(ax,ay,radius,beta,gamma,prefer,mark,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(mark == null) {
			mark = 0;
		}
		var this1 = this.triArr;
		var this2 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out = this2;
		var pi = Math.PI;
		var step = pi * 2 / sides;
		var dif;
		switch(prefer[1]) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				if(a >= 0) {
					f = a;
				} else {
					f = a + 2 * Math.PI;
				}
			}
			var this3 = f;
			var za = this3;
			var f1;
			if(gamma >= 0 && gamma > Math.PI) {
				f1 = gamma;
			} else {
				var a1 = gamma % (2 * Math.PI);
				if(a1 >= 0) {
					f1 = a1;
				} else {
					f1 = a1 + 2 * Math.PI;
				}
			}
			var this4 = f1;
			var zb = this4;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			if(dif1 > 0) {
				dif = dif1;
			} else {
				dif = 2 * Math.PI + dif1;
			}
			break;
		case 1:
			var f2;
			if(beta >= 0 && beta > Math.PI) {
				f2 = beta;
			} else {
				var a2 = beta % (2 * Math.PI);
				if(a2 >= 0) {
					f2 = a2;
				} else {
					f2 = a2 + 2 * Math.PI;
				}
			}
			var this5 = f2;
			var za1 = this5;
			var f3;
			if(gamma >= 0 && gamma > Math.PI) {
				f3 = gamma;
			} else {
				var a3 = gamma % (2 * Math.PI);
				if(a3 >= 0) {
					f3 = a3;
				} else {
					f3 = a3 + 2 * Math.PI;
				}
			}
			var this6 = f3;
			var zb1 = this6;
			var fa1 = beta;
			var fb1 = gamma;
			var theta1 = Math.abs(beta - gamma);
			var clockwise1 = beta < gamma;
			var dif2 = clockwise1 ? theta1 : -theta1;
			if(dif2 < 0) {
				dif = dif2;
			} else {
				dif = -2 * Math.PI + dif2;
			}
			break;
		case 2:
			var f4;
			if(beta >= 0 && beta > Math.PI) {
				f4 = beta;
			} else {
				var a4 = beta % (2 * Math.PI);
				if(a4 >= 0) {
					f4 = a4;
				} else {
					f4 = a4 + 2 * Math.PI;
				}
			}
			var this7 = f4;
			var za2 = this7;
			var f5;
			if(gamma >= 0 && gamma > Math.PI) {
				f5 = gamma;
			} else {
				var a5 = gamma % (2 * Math.PI);
				if(a5 >= 0) {
					f5 = a5;
				} else {
					f5 = a5 + 2 * Math.PI;
				}
			}
			var this8 = f5;
			var zb2 = this8;
			var fa2 = beta;
			var fb2 = gamma;
			var theta2 = Math.abs(beta - gamma);
			var smallest = theta2 <= Math.PI;
			var clockwise2 = beta < gamma;
			var dif3 = clockwise2 ? theta2 : -theta2;
			if(smallest) {
				dif = dif3;
			} else if(clockwise2) {
				dif = -(2 * Math.PI - theta2);
			} else {
				dif = 2 * Math.PI - theta2;
			}
			break;
		case 3:
			var f6;
			if(beta >= 0 && beta > Math.PI) {
				f6 = beta;
			} else {
				var a6 = beta % (2 * Math.PI);
				if(a6 >= 0) {
					f6 = a6;
				} else {
					f6 = a6 + 2 * Math.PI;
				}
			}
			var this9 = f6;
			var za3 = this9;
			var f7;
			if(gamma >= 0 && gamma > Math.PI) {
				f7 = gamma;
			} else {
				var a7 = gamma % (2 * Math.PI);
				if(a7 >= 0) {
					f7 = a7;
				} else {
					f7 = a7 + 2 * Math.PI;
				}
			}
			var this10 = f7;
			var zb3 = this10;
			var fa3 = beta;
			var fb3 = gamma;
			var theta3 = Math.abs(beta - gamma);
			var largest = theta3 > Math.PI;
			var clockwise3 = beta < gamma;
			var dif4 = clockwise3 ? theta3 : -theta3;
			if(largest) {
				dif = dif4;
			} else if(clockwise3) {
				dif = -(2 * Math.PI - theta3);
			} else {
				dif = 2 * Math.PI - theta3;
			}
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step1 = dif / totalSteps;
		var angle = beta;
		var cx;
		var cy;
		var bx = 0;
		var by = 0;
		var _g1 = 0;
		var _g = totalSteps + 1;
		while(_g1 < _g) {
			var i = _g1++;
			cx = ax + radius * Math.sin(angle);
			cy = ay + radius * Math.cos(angle);
			if(i != 0) {
				var t = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
				out[out.length] = t;
				if(mark != 0) {
					t.mark = mark;
				}
			}
			angle += step1;
			bx = cx;
			by = cy;
		}
		var triArr = out;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t1 = triArr[_g2];
			++_g2;
			this1[this1.length] = t1;
		}
	}
	,computeJ: function(width_,theta0,dif) {
		var gamma = Math.abs(dif) / 2;
		var h = width_ * Math.sin(gamma);
		var f;
		if(theta0 <= Math.PI && theta0 > -Math.PI) {
			f = theta0;
		} else {
			var a = (theta0 + Math.PI) % (2 * Math.PI);
			if(a >= 0) {
				f = a - Math.PI;
			} else {
				f = a + Math.PI;
			}
		}
		var this1 = f;
		var start = this1;
		var start2 = start;
		var delta = start2 + dif / 2 + Math.PI;
		this.jx = this.ax + h * Math.sin(delta);
		this.jy = this.ay + h * Math.cos(delta);
	}
	,addDot: function(x,y,color) {
		var this1 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out = this1;
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g1 = 0;
		var _g = 36;
		while(_g1 < _g) {
			var i = _g1++;
			bx = x + 0.008 * Math.sin(theta);
			by = y + 0.008 * Math.cos(theta);
			theta += step;
			cx = x + 0.008 * Math.sin(theta);
			cy = y + 0.008 * Math.cos(theta);
			var t = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
			out[out.length] = t;
			t.mark = color;
		}
		var trilateralArray = out;
		var this2 = this.triArr;
		var _g2 = 0;
		while(_g2 < trilateralArray.length) {
			var t1 = trilateralArray[_g2];
			++_g2;
			this2[this2.length] = t1;
		}
	}
	,addSmallTriangles: function(clockWise) {
		if(clockWise) {
			var this1 = this.triArr;
			var tri = new trilateral_tri_Trilateral(this.ax,this.ay,this.dxOld,this.dyOld,this.jx,this.jy,0);
			this1[this1.length] = tri;
			var this2 = this.triArr;
			var tri1 = new trilateral_tri_Trilateral(this.ax,this.ay,this.exPrev,this.eyPrev,this.jx,this.jy,0);
			this2[this2.length] = tri1;
		} else {
			var this3 = this.triArr;
			var tri2 = new trilateral_tri_Trilateral(this.ax,this.ay,this.exOld,this.eyOld,this.jx,this.jy,0);
			this3[this3.length] = tri2;
			var this4 = this.triArr;
			var tri3 = new trilateral_tri_Trilateral(this.ax,this.ay,this.dxPrev,this.dyPrev,this.jx,this.jy,0);
			this4[this4.length] = tri3;
		}
	}
	,addTriangleCorners: function(oldx_,oldy_,prevx_,prevy_) {
		var this1 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out = this1;
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g1 = 0;
		var _g = 36;
		while(_g1 < _g) {
			var i = _g1++;
			bx = oldx_ + 0.01 * Math.sin(theta);
			by = oldy_ + 0.01 * Math.cos(theta);
			theta += step;
			cx = oldx_ + 0.01 * Math.sin(theta);
			cy = oldy_ + 0.01 * Math.cos(theta);
			var t = new trilateral_tri_Trilateral(oldx_,oldy_,bx,by,cx,cy);
			out[out.length] = t;
			t.mark = 4;
		}
		var trilateralArray = out;
		var this2 = this.triArr;
		var _g2 = 0;
		while(_g2 < trilateralArray.length) {
			var t1 = trilateralArray[_g2];
			++_g2;
			this2[this2.length] = t1;
		}
		var this3 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out1 = this3;
		var pi1 = Math.PI;
		var theta1 = pi1 / 2;
		var step1 = pi1 * 2 / 36;
		var bx1;
		var by1;
		var cx1;
		var cy1;
		var _g11 = 0;
		var _g3 = 36;
		while(_g11 < _g3) {
			var i1 = _g11++;
			bx1 = prevx_ + 0.01 * Math.sin(theta1);
			by1 = prevy_ + 0.01 * Math.cos(theta1);
			theta1 += step1;
			cx1 = prevx_ + 0.01 * Math.sin(theta1);
			cy1 = prevy_ + 0.01 * Math.cos(theta1);
			var t2 = new trilateral_tri_Trilateral(prevx_,prevy_,bx1,by1,cx1,cy1);
			out1[out1.length] = t2;
			t2.mark = 3;
		}
		var trilateralArray1 = out1;
		var this4 = this.triArr;
		var _g4 = 0;
		while(_g4 < trilateralArray1.length) {
			var t3 = trilateralArray1[_g4];
			++_g4;
			this4[this4.length] = t3;
		}
		var ax = this.ax;
		var ay = this.ay;
		var this5 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out2 = this5;
		var pi2 = Math.PI;
		var theta2 = pi2 / 2;
		var step2 = pi2 * 2 / 36;
		var bx2;
		var by2;
		var cx2;
		var cy2;
		var _g12 = 0;
		var _g5 = 36;
		while(_g12 < _g5) {
			var i2 = _g12++;
			bx2 = ax + 0.01 * Math.sin(theta2);
			by2 = ay + 0.01 * Math.cos(theta2);
			theta2 += step2;
			cx2 = ax + 0.01 * Math.sin(theta2);
			cy2 = ay + 0.01 * Math.cos(theta2);
			var t4 = new trilateral_tri_Trilateral(ax,ay,bx2,by2,cx2,cy2);
			out2[out2.length] = t4;
			t4.mark = 10;
		}
		var trilateralArray2 = out2;
		var this6 = this.triArr;
		var _g6 = 0;
		while(_g6 < trilateralArray2.length) {
			var t5 = trilateralArray2[_g6];
			++_g6;
			this6[this6.length] = t5;
		}
		var ax1 = this.jx;
		var ay1 = this.jy;
		var this7 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out3 = this7;
		var pi3 = Math.PI;
		var theta3 = pi3 / 2;
		var step3 = pi3 * 2 / 36;
		var bx3;
		var by3;
		var cx3;
		var cy3;
		var _g13 = 0;
		var _g7 = 36;
		while(_g13 < _g7) {
			var i3 = _g13++;
			bx3 = ax1 + 0.01 * Math.sin(theta3);
			by3 = ay1 + 0.01 * Math.cos(theta3);
			theta3 += step3;
			cx3 = ax1 + 0.01 * Math.sin(theta3);
			cy3 = ay1 + 0.01 * Math.cos(theta3);
			var t6 = new trilateral_tri_Trilateral(ax1,ay1,bx3,by3,cx3,cy3);
			out3[out3.length] = t6;
			t6.mark = 5;
		}
		var trilateralArray3 = out3;
		var this8 = this.triArr;
		var _g8 = 0;
		while(_g8 < trilateralArray3.length) {
			var t7 = trilateralArray3[_g8];
			++_g8;
			this8[this8.length] = t7;
		}
	}
	,addTriangleCornersLess: function(oldx_,oldy_,prevx_,prevy_) {
		var this1 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out = this1;
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g1 = 0;
		var _g = 36;
		while(_g1 < _g) {
			var i = _g1++;
			bx = oldx_ + 0.01 * Math.sin(theta);
			by = oldy_ + 0.01 * Math.cos(theta);
			theta += step;
			cx = oldx_ + 0.01 * Math.sin(theta);
			cy = oldy_ + 0.01 * Math.cos(theta);
			var t = new trilateral_tri_Trilateral(oldx_,oldy_,bx,by,cx,cy);
			out[out.length] = t;
			t.mark = 4;
		}
		var trilateralArray = out;
		var this2 = this.triArr;
		var _g2 = 0;
		while(_g2 < trilateralArray.length) {
			var t1 = trilateralArray[_g2];
			++_g2;
			this2[this2.length] = t1;
		}
		var this3 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out1 = this3;
		var pi1 = Math.PI;
		var theta1 = pi1 / 2;
		var step1 = pi1 * 2 / 36;
		var bx1;
		var by1;
		var cx1;
		var cy1;
		var _g11 = 0;
		var _g3 = 36;
		while(_g11 < _g3) {
			var i1 = _g11++;
			bx1 = prevx_ + 0.01 * Math.sin(theta1);
			by1 = prevy_ + 0.01 * Math.cos(theta1);
			theta1 += step1;
			cx1 = prevx_ + 0.01 * Math.sin(theta1);
			cy1 = prevy_ + 0.01 * Math.cos(theta1);
			var t2 = new trilateral_tri_Trilateral(prevx_,prevy_,bx1,by1,cx1,cy1);
			out1[out1.length] = t2;
			t2.mark = 3;
		}
		var trilateralArray1 = out1;
		var this4 = this.triArr;
		var _g4 = 0;
		while(_g4 < trilateralArray1.length) {
			var t3 = trilateralArray1[_g4];
			++_g4;
			this4[this4.length] = t3;
		}
		var ax = this.jx;
		var ay = this.jy;
		var this5 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out2 = this5;
		var pi2 = Math.PI;
		var theta2 = pi2 / 2;
		var step2 = pi2 * 2 / 36;
		var bx2;
		var by2;
		var cx2;
		var cy2;
		var _g12 = 0;
		var _g5 = 36;
		while(_g12 < _g5) {
			var i2 = _g12++;
			bx2 = ax + 0.01 * Math.sin(theta2);
			by2 = ay + 0.01 * Math.cos(theta2);
			theta2 += step2;
			cx2 = ax + 0.01 * Math.sin(theta2);
			cy2 = ay + 0.01 * Math.cos(theta2);
			var t4 = new trilateral_tri_Trilateral(ax,ay,bx2,by2,cx2,cy2);
			out2[out2.length] = t4;
			t4.mark = 5;
		}
		var trilateralArray2 = out2;
		var this6 = this.triArr;
		var _g6 = 0;
		while(_g6 < trilateralArray2.length) {
			var t5 = trilateralArray2[_g6];
			++_g6;
			this6[this6.length] = t5;
		}
	}
	,connectQuadsWhenQuadsOverlay: function(clockWise) {
		if(clockWise) {
			var this1 = this.triArr;
			var tri = new trilateral_tri_Trilateral(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.ax,this.ay,0);
			this1[this1.length] = tri;
		} else {
			var this2 = this.triArr;
			var tri1 = new trilateral_tri_Trilateral(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.ax,this.ay,0);
			this2[this2.length] = tri1;
		}
	}
	,connectQuads: function(clockWise) {
		if(clockWise) {
			var this1 = this.triArr;
			var tri = new trilateral_tri_Trilateral(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.jx,this.jy,0);
			this1[this1.length] = tri;
		} else {
			var this2 = this.triArr;
			var tri1 = new trilateral_tri_Trilateral(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.jx,this.jy,0);
			this2[this2.length] = tri1;
		}
	}
	,addInitialQuads: function(clockWise) {
		this.quadIndex = this.triArr.length;
		if(this.count == 0) {
			var this1 = this.triArr;
			var tri = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,0);
			this1[this1.length] = tri;
			var this2 = this.triArr;
			var tri1 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,0);
			this2[this2.length] = tri1;
		} else {
			if(clockWise && !this.lastClock) {
				var this3 = this.triArr;
				var tri2 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,0);
				this3[this3.length] = tri2;
				var this4 = this.triArr;
				var tri3 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,0);
				this4[this4.length] = tri3;
			}
			if(clockWise && this.lastClock) {
				var this5 = this.triArr;
				var tri4 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,0);
				this5[this5.length] = tri4;
				var this6 = this.triArr;
				var tri5 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,0);
				this6[this6.length] = tri5;
			}
			if(!clockWise && !this.lastClock) {
				var this7 = this.triArr;
				var tri6 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.jx,this.jy,0);
				this7[this7.length] = tri6;
				var this8 = this.triArr;
				var tri7 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,0);
				this8[this8.length] = tri7;
			}
			if(!clockWise && this.lastClock) {
				var this9 = this.triArr;
				var tri8 = new trilateral_tri_Trilateral(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,0);
				this9[this9.length] = tri8;
				var this10 = this.triArr;
				var tri9 = new trilateral_tri_Trilateral(this.dxPrev,this.dyPrev,this.jx,this.jy,this.ex,this.ey,0);
				this10[this10.length] = tri9;
			}
		}
	}
	,addQuads: function(clockWise) {
		if(clockWise && !this.lastClock) {
			if(this.count == 1) {
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.nax,this.nay,this.nbx,this.nby,this.ncx,this.ncy);
			} else {
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.nax,this.nay,this.nbx,this.nby,this.jxOld,this.jyOld);
			}
			this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy);
		}
		if(clockWise && this.lastClock) {
			if(this.count == 1) {
				this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy);
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.nax,this.nay,this.nbx,this.nby,this.ncx,this.ncy);
			} else {
				this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.jxOld,this.jyOld,this.kbx,this.kby,this.jx,this.jy);
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.jxOld,this.jyOld,this.nbx,this.nby,this.ncx,this.ncy);
			}
		}
		if(!clockWise && !this.lastClock) {
			this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy);
			if(this.count == 1) {
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.nax,this.nay,this.jx,this.jy,this.ncx,this.ncy);
			} else {
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.nax,this.nay,this.jx,this.jy,this.jxOld,this.jyOld);
			}
		}
		if(!clockWise && this.lastClock) {
			if(this.count == 1) {
				this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy);
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.nax,this.nay,this.jx,this.jy,this.ncx,this.ncy);
			} else {
				this.triArr[this.quadIndex] = new trilateral_tri_Trilateral(this.jxOld,this.jyOld,this.jx,this.jy,this.kcx,this.kcy);
				this.triArr[this.quadIndex + 1] = new trilateral_tri_Trilateral(this.jxOld,this.jyOld,this.jx,this.jy,this.ncx,this.ncy);
			}
		}
	}
	,storeLastQuads: function() {
		this.nax = this.dxPrev;
		this.nay = this.dyPrev;
		this.nbx = this.dx;
		this.nby = this.dy;
		this.ncx = this.exPrev;
		this.ncy = this.eyPrev;
		this.kax = this.dxPrev;
		this.kay = this.dyPrev;
		this.kbx = this.dx;
		this.kby = this.dy;
		this.kcx = this.ex;
		this.kcy = this.ey;
	}
	,isClockwise: function(x,y) {
		var x1 = this.dxOld - x;
		var y1 = this.dyOld - y;
		var x2 = this.exOld - x;
		var y2 = this.eyOld - y;
		return x1 * x1 + y1 * y1 > x2 * x2 + y2 * y2;
	}
	,line: function(ax_,ay_,bx_,by_,width_,endLineCurve) {
		if(endLineCurve == null) {
			endLineCurve = 0;
		}
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.halfA = Math.PI / 2;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var dxPrev_ = this.dx;
		var dyPrev_ = this.dy;
		var exPrev_ = this.ex;
		var eyPrev_ = this.ey;
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		if(endLineCurve == null) {
			var end = endLineCurve;
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var this1 = this.triArr;
			var this2 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
			var out = this2;
			var pi = Math.PI;
			var step = pi * 2 / 36;
			var dif;
			switch(trilateral_angle_DifferencePreference.SMALL[1]) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					if(a >= 0) {
						f = a;
					} else {
						f = a + 2 * Math.PI;
					}
				}
				var this3 = f;
				var za = this3;
				var f1;
				if(gamma >= 0 && gamma > Math.PI) {
					f1 = gamma;
				} else {
					var a1 = gamma % (2 * Math.PI);
					if(a1 >= 0) {
						f1 = a1;
					} else {
						f1 = a1 + 2 * Math.PI;
					}
				}
				var this4 = f1;
				var zb = this4;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				if(dif1 > 0) {
					dif = dif1;
				} else {
					dif = 2 * Math.PI + dif1;
				}
				break;
			case 1:
				var f2;
				if(beta >= 0 && beta > Math.PI) {
					f2 = beta;
				} else {
					var a2 = beta % (2 * Math.PI);
					if(a2 >= 0) {
						f2 = a2;
					} else {
						f2 = a2 + 2 * Math.PI;
					}
				}
				var this5 = f2;
				var za1 = this5;
				var f3;
				if(gamma >= 0 && gamma > Math.PI) {
					f3 = gamma;
				} else {
					var a3 = gamma % (2 * Math.PI);
					if(a3 >= 0) {
						f3 = a3;
					} else {
						f3 = a3 + 2 * Math.PI;
					}
				}
				var this6 = f3;
				var zb1 = this6;
				var fa1 = beta;
				var fb1 = gamma;
				var theta1 = Math.abs(beta - gamma);
				var clockwise1 = beta < gamma;
				var dif2 = clockwise1 ? theta1 : -theta1;
				if(dif2 < 0) {
					dif = dif2;
				} else {
					dif = -2 * Math.PI + dif2;
				}
				break;
			case 2:
				var f4;
				if(beta >= 0 && beta > Math.PI) {
					f4 = beta;
				} else {
					var a4 = beta % (2 * Math.PI);
					if(a4 >= 0) {
						f4 = a4;
					} else {
						f4 = a4 + 2 * Math.PI;
					}
				}
				var this7 = f4;
				var za2 = this7;
				var f5;
				if(gamma >= 0 && gamma > Math.PI) {
					f5 = gamma;
				} else {
					var a5 = gamma % (2 * Math.PI);
					if(a5 >= 0) {
						f5 = a5;
					} else {
						f5 = a5 + 2 * Math.PI;
					}
				}
				var this8 = f5;
				var zb2 = this8;
				var fa2 = beta;
				var fb2 = gamma;
				var theta2 = Math.abs(beta - gamma);
				var smallest = theta2 <= Math.PI;
				var clockwise2 = beta < gamma;
				var dif3 = clockwise2 ? theta2 : -theta2;
				if(smallest) {
					dif = dif3;
				} else if(clockwise2) {
					dif = -(2 * Math.PI - theta2);
				} else {
					dif = 2 * Math.PI - theta2;
				}
				break;
			case 3:
				var f6;
				if(beta >= 0 && beta > Math.PI) {
					f6 = beta;
				} else {
					var a6 = beta % (2 * Math.PI);
					if(a6 >= 0) {
						f6 = a6;
					} else {
						f6 = a6 + 2 * Math.PI;
					}
				}
				var this9 = f6;
				var za3 = this9;
				var f7;
				if(gamma >= 0 && gamma > Math.PI) {
					f7 = gamma;
				} else {
					var a7 = gamma % (2 * Math.PI);
					if(a7 >= 0) {
						f7 = a7;
					} else {
						f7 = a7 + 2 * Math.PI;
					}
				}
				var this10 = f7;
				var zb3 = this10;
				var fa3 = beta;
				var fb3 = gamma;
				var theta3 = Math.abs(beta - gamma);
				var largest = theta3 > Math.PI;
				var clockwise3 = beta < gamma;
				var dif4 = clockwise3 ? theta3 : -theta3;
				if(largest) {
					dif = dif4;
				} else if(clockwise3) {
					dif = -(2 * Math.PI - theta3);
				} else {
					dif = 2 * Math.PI - theta3;
				}
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step1 = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g1 = 0;
			var _g = totalSteps + 1;
			while(_g1 < _g) {
				var i = _g1++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var t = new trilateral_tri_Trilateral(bx_,by_,bx,by,cx,cy);
					out[out.length] = t;
				}
				angle += step1;
				bx = cx;
				by = cy;
			}
			var triArr = out;
			var _g2 = 0;
			while(_g2 < triArr.length) {
				var t1 = triArr[_g2];
				++_g2;
				this1[this1.length] = t1;
			}
		} else {
			switch(endLineCurve) {
			case 0:
				break;
			case 1:
				var radius1 = width_ / 2;
				var beta1 = -this.angle1 - Math.PI / 2;
				var gamma1 = -this.angle1 - Math.PI / 2 + Math.PI;
				var this11 = this.triArr;
				var this12 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
				var out1 = this12;
				var pi1 = Math.PI;
				var step2 = pi1 * 2 / 36;
				var dif5;
				switch(trilateral_angle_DifferencePreference.SMALL[1]) {
				case 0:
					var f8;
					if(beta1 >= 0 && beta1 > Math.PI) {
						f8 = beta1;
					} else {
						var a8 = beta1 % (2 * Math.PI);
						if(a8 >= 0) {
							f8 = a8;
						} else {
							f8 = a8 + 2 * Math.PI;
						}
					}
					var this13 = f8;
					var za4 = this13;
					var f9;
					if(gamma1 >= 0 && gamma1 > Math.PI) {
						f9 = gamma1;
					} else {
						var a9 = gamma1 % (2 * Math.PI);
						if(a9 >= 0) {
							f9 = a9;
						} else {
							f9 = a9 + 2 * Math.PI;
						}
					}
					var this14 = f9;
					var zb4 = this14;
					var fa4 = beta1;
					var fb4 = gamma1;
					var theta4 = Math.abs(beta1 - gamma1);
					var clockwise4 = beta1 < gamma1;
					var dif6 = clockwise4 ? theta4 : -theta4;
					if(dif6 > 0) {
						dif5 = dif6;
					} else {
						dif5 = 2 * Math.PI + dif6;
					}
					break;
				case 1:
					var f10;
					if(beta1 >= 0 && beta1 > Math.PI) {
						f10 = beta1;
					} else {
						var a10 = beta1 % (2 * Math.PI);
						if(a10 >= 0) {
							f10 = a10;
						} else {
							f10 = a10 + 2 * Math.PI;
						}
					}
					var this15 = f10;
					var za5 = this15;
					var f11;
					if(gamma1 >= 0 && gamma1 > Math.PI) {
						f11 = gamma1;
					} else {
						var a11 = gamma1 % (2 * Math.PI);
						if(a11 >= 0) {
							f11 = a11;
						} else {
							f11 = a11 + 2 * Math.PI;
						}
					}
					var this16 = f11;
					var zb5 = this16;
					var fa5 = beta1;
					var fb5 = gamma1;
					var theta5 = Math.abs(beta1 - gamma1);
					var clockwise5 = beta1 < gamma1;
					var dif7 = clockwise5 ? theta5 : -theta5;
					if(dif7 < 0) {
						dif5 = dif7;
					} else {
						dif5 = -2 * Math.PI + dif7;
					}
					break;
				case 2:
					var f12;
					if(beta1 >= 0 && beta1 > Math.PI) {
						f12 = beta1;
					} else {
						var a12 = beta1 % (2 * Math.PI);
						if(a12 >= 0) {
							f12 = a12;
						} else {
							f12 = a12 + 2 * Math.PI;
						}
					}
					var this17 = f12;
					var za6 = this17;
					var f13;
					if(gamma1 >= 0 && gamma1 > Math.PI) {
						f13 = gamma1;
					} else {
						var a13 = gamma1 % (2 * Math.PI);
						if(a13 >= 0) {
							f13 = a13;
						} else {
							f13 = a13 + 2 * Math.PI;
						}
					}
					var this18 = f13;
					var zb6 = this18;
					var fa6 = beta1;
					var fb6 = gamma1;
					var theta6 = Math.abs(beta1 - gamma1);
					var smallest1 = theta6 <= Math.PI;
					var clockwise6 = beta1 < gamma1;
					var dif8 = clockwise6 ? theta6 : -theta6;
					if(smallest1) {
						dif5 = dif8;
					} else if(clockwise6) {
						dif5 = -(2 * Math.PI - theta6);
					} else {
						dif5 = 2 * Math.PI - theta6;
					}
					break;
				case 3:
					var f14;
					if(beta1 >= 0 && beta1 > Math.PI) {
						f14 = beta1;
					} else {
						var a14 = beta1 % (2 * Math.PI);
						if(a14 >= 0) {
							f14 = a14;
						} else {
							f14 = a14 + 2 * Math.PI;
						}
					}
					var this19 = f14;
					var za7 = this19;
					var f15;
					if(gamma1 >= 0 && gamma1 > Math.PI) {
						f15 = gamma1;
					} else {
						var a15 = gamma1 % (2 * Math.PI);
						if(a15 >= 0) {
							f15 = a15;
						} else {
							f15 = a15 + 2 * Math.PI;
						}
					}
					var this20 = f15;
					var zb7 = this20;
					var fa7 = beta1;
					var fb7 = gamma1;
					var theta7 = Math.abs(beta1 - gamma1);
					var largest1 = theta7 > Math.PI;
					var clockwise7 = beta1 < gamma1;
					var dif9 = clockwise7 ? theta7 : -theta7;
					if(largest1) {
						dif5 = dif9;
					} else if(clockwise7) {
						dif5 = -(2 * Math.PI - theta7);
					} else {
						dif5 = 2 * Math.PI - theta7;
					}
					break;
				}
				var positive1 = dif5 >= 0;
				var totalSteps1 = Math.ceil(Math.abs(dif5) / step2);
				var step3 = dif5 / totalSteps1;
				var angle1 = beta1;
				var cx1;
				var cy1;
				var bx1 = 0;
				var by1 = 0;
				var _g11 = 0;
				var _g3 = totalSteps1 + 1;
				while(_g11 < _g3) {
					var i1 = _g11++;
					cx1 = ax_ + radius1 * Math.sin(angle1);
					cy1 = ay_ + radius1 * Math.cos(angle1);
					if(i1 != 0) {
						var t2 = new trilateral_tri_Trilateral(ax_,ay_,bx1,by1,cx1,cy1);
						out1[out1.length] = t2;
					}
					angle1 += step3;
					bx1 = cx1;
					by1 = cy1;
				}
				var triArr1 = out1;
				var _g4 = 0;
				while(_g4 < triArr1.length) {
					var t3 = triArr1[_g4];
					++_g4;
					this11[this11.length] = t3;
				}
				break;
			case 3:
				var end1 = endLineCurve;
				var radius2 = width_ / 2;
				var beta2 = -this.angle1 - Math.PI / 2;
				var gamma2 = -this.angle1 - Math.PI / 2 - Math.PI;
				var this21 = this.triArr;
				var this22 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
				var out2 = this22;
				var pi2 = Math.PI;
				var step4 = pi2 * 2 / 36;
				var dif10;
				switch(trilateral_angle_DifferencePreference.SMALL[1]) {
				case 0:
					var f16;
					if(beta2 >= 0 && beta2 > Math.PI) {
						f16 = beta2;
					} else {
						var a16 = beta2 % (2 * Math.PI);
						if(a16 >= 0) {
							f16 = a16;
						} else {
							f16 = a16 + 2 * Math.PI;
						}
					}
					var this23 = f16;
					var za8 = this23;
					var f17;
					if(gamma2 >= 0 && gamma2 > Math.PI) {
						f17 = gamma2;
					} else {
						var a17 = gamma2 % (2 * Math.PI);
						if(a17 >= 0) {
							f17 = a17;
						} else {
							f17 = a17 + 2 * Math.PI;
						}
					}
					var this24 = f17;
					var zb8 = this24;
					var fa8 = beta2;
					var fb8 = gamma2;
					var theta8 = Math.abs(beta2 - gamma2);
					var clockwise8 = beta2 < gamma2;
					var dif11 = clockwise8 ? theta8 : -theta8;
					if(dif11 > 0) {
						dif10 = dif11;
					} else {
						dif10 = 2 * Math.PI + dif11;
					}
					break;
				case 1:
					var f18;
					if(beta2 >= 0 && beta2 > Math.PI) {
						f18 = beta2;
					} else {
						var a18 = beta2 % (2 * Math.PI);
						if(a18 >= 0) {
							f18 = a18;
						} else {
							f18 = a18 + 2 * Math.PI;
						}
					}
					var this25 = f18;
					var za9 = this25;
					var f19;
					if(gamma2 >= 0 && gamma2 > Math.PI) {
						f19 = gamma2;
					} else {
						var a19 = gamma2 % (2 * Math.PI);
						if(a19 >= 0) {
							f19 = a19;
						} else {
							f19 = a19 + 2 * Math.PI;
						}
					}
					var this26 = f19;
					var zb9 = this26;
					var fa9 = beta2;
					var fb9 = gamma2;
					var theta9 = Math.abs(beta2 - gamma2);
					var clockwise9 = beta2 < gamma2;
					var dif12 = clockwise9 ? theta9 : -theta9;
					if(dif12 < 0) {
						dif10 = dif12;
					} else {
						dif10 = -2 * Math.PI + dif12;
					}
					break;
				case 2:
					var f20;
					if(beta2 >= 0 && beta2 > Math.PI) {
						f20 = beta2;
					} else {
						var a20 = beta2 % (2 * Math.PI);
						if(a20 >= 0) {
							f20 = a20;
						} else {
							f20 = a20 + 2 * Math.PI;
						}
					}
					var this27 = f20;
					var za10 = this27;
					var f21;
					if(gamma2 >= 0 && gamma2 > Math.PI) {
						f21 = gamma2;
					} else {
						var a21 = gamma2 % (2 * Math.PI);
						if(a21 >= 0) {
							f21 = a21;
						} else {
							f21 = a21 + 2 * Math.PI;
						}
					}
					var this28 = f21;
					var zb10 = this28;
					var fa10 = beta2;
					var fb10 = gamma2;
					var theta10 = Math.abs(beta2 - gamma2);
					var smallest2 = theta10 <= Math.PI;
					var clockwise10 = beta2 < gamma2;
					var dif13 = clockwise10 ? theta10 : -theta10;
					if(smallest2) {
						dif10 = dif13;
					} else if(clockwise10) {
						dif10 = -(2 * Math.PI - theta10);
					} else {
						dif10 = 2 * Math.PI - theta10;
					}
					break;
				case 3:
					var f22;
					if(beta2 >= 0 && beta2 > Math.PI) {
						f22 = beta2;
					} else {
						var a22 = beta2 % (2 * Math.PI);
						if(a22 >= 0) {
							f22 = a22;
						} else {
							f22 = a22 + 2 * Math.PI;
						}
					}
					var this29 = f22;
					var za11 = this29;
					var f23;
					if(gamma2 >= 0 && gamma2 > Math.PI) {
						f23 = gamma2;
					} else {
						var a23 = gamma2 % (2 * Math.PI);
						if(a23 >= 0) {
							f23 = a23;
						} else {
							f23 = a23 + 2 * Math.PI;
						}
					}
					var this30 = f23;
					var zb11 = this30;
					var fa11 = beta2;
					var fb11 = gamma2;
					var theta11 = Math.abs(beta2 - gamma2);
					var largest2 = theta11 > Math.PI;
					var clockwise11 = beta2 < gamma2;
					var dif14 = clockwise11 ? theta11 : -theta11;
					if(largest2) {
						dif10 = dif14;
					} else if(clockwise11) {
						dif10 = -(2 * Math.PI - theta11);
					} else {
						dif10 = 2 * Math.PI - theta11;
					}
					break;
				}
				var positive2 = dif10 >= 0;
				var totalSteps2 = Math.ceil(Math.abs(dif10) / step4);
				var step5 = dif10 / totalSteps2;
				var angle2 = beta2;
				var cx2;
				var cy2;
				var bx2 = 0;
				var by2 = 0;
				var _g12 = 0;
				var _g5 = totalSteps2 + 1;
				while(_g12 < _g5) {
					var i2 = _g12++;
					cx2 = bx_ + radius2 * Math.sin(angle2);
					cy2 = by_ + radius2 * Math.cos(angle2);
					if(i2 != 0) {
						var t4 = new trilateral_tri_Trilateral(bx_,by_,bx2,by2,cx2,cy2);
						out2[out2.length] = t4;
					}
					angle2 += step5;
					bx2 = cx2;
					by2 = cy2;
				}
				var triArr2 = out2;
				var _g6 = 0;
				while(_g6 < triArr2.length) {
					var t5 = triArr2[_g6];
					++_g6;
					this21[this21.length] = t5;
				}
				break;
			default:
				var end2 = endLineCurve;
				var radius3 = width_ / 2;
				var beta3 = -this.angle1 - Math.PI / 2;
				var gamma3 = -this.angle1 - Math.PI / 2 - Math.PI;
				var this31 = this.triArr;
				var this32 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
				var out3 = this32;
				var pi3 = Math.PI;
				var step6 = pi3 * 2 / 36;
				var dif15;
				switch(trilateral_angle_DifferencePreference.SMALL[1]) {
				case 0:
					var f24;
					if(beta3 >= 0 && beta3 > Math.PI) {
						f24 = beta3;
					} else {
						var a24 = beta3 % (2 * Math.PI);
						if(a24 >= 0) {
							f24 = a24;
						} else {
							f24 = a24 + 2 * Math.PI;
						}
					}
					var this33 = f24;
					var za12 = this33;
					var f25;
					if(gamma3 >= 0 && gamma3 > Math.PI) {
						f25 = gamma3;
					} else {
						var a25 = gamma3 % (2 * Math.PI);
						if(a25 >= 0) {
							f25 = a25;
						} else {
							f25 = a25 + 2 * Math.PI;
						}
					}
					var this34 = f25;
					var zb12 = this34;
					var fa12 = beta3;
					var fb12 = gamma3;
					var theta12 = Math.abs(beta3 - gamma3);
					var clockwise12 = beta3 < gamma3;
					var dif16 = clockwise12 ? theta12 : -theta12;
					if(dif16 > 0) {
						dif15 = dif16;
					} else {
						dif15 = 2 * Math.PI + dif16;
					}
					break;
				case 1:
					var f26;
					if(beta3 >= 0 && beta3 > Math.PI) {
						f26 = beta3;
					} else {
						var a26 = beta3 % (2 * Math.PI);
						if(a26 >= 0) {
							f26 = a26;
						} else {
							f26 = a26 + 2 * Math.PI;
						}
					}
					var this35 = f26;
					var za13 = this35;
					var f27;
					if(gamma3 >= 0 && gamma3 > Math.PI) {
						f27 = gamma3;
					} else {
						var a27 = gamma3 % (2 * Math.PI);
						if(a27 >= 0) {
							f27 = a27;
						} else {
							f27 = a27 + 2 * Math.PI;
						}
					}
					var this36 = f27;
					var zb13 = this36;
					var fa13 = beta3;
					var fb13 = gamma3;
					var theta13 = Math.abs(beta3 - gamma3);
					var clockwise13 = beta3 < gamma3;
					var dif17 = clockwise13 ? theta13 : -theta13;
					if(dif17 < 0) {
						dif15 = dif17;
					} else {
						dif15 = -2 * Math.PI + dif17;
					}
					break;
				case 2:
					var f28;
					if(beta3 >= 0 && beta3 > Math.PI) {
						f28 = beta3;
					} else {
						var a28 = beta3 % (2 * Math.PI);
						if(a28 >= 0) {
							f28 = a28;
						} else {
							f28 = a28 + 2 * Math.PI;
						}
					}
					var this37 = f28;
					var za14 = this37;
					var f29;
					if(gamma3 >= 0 && gamma3 > Math.PI) {
						f29 = gamma3;
					} else {
						var a29 = gamma3 % (2 * Math.PI);
						if(a29 >= 0) {
							f29 = a29;
						} else {
							f29 = a29 + 2 * Math.PI;
						}
					}
					var this38 = f29;
					var zb14 = this38;
					var fa14 = beta3;
					var fb14 = gamma3;
					var theta14 = Math.abs(beta3 - gamma3);
					var smallest3 = theta14 <= Math.PI;
					var clockwise14 = beta3 < gamma3;
					var dif18 = clockwise14 ? theta14 : -theta14;
					if(smallest3) {
						dif15 = dif18;
					} else if(clockwise14) {
						dif15 = -(2 * Math.PI - theta14);
					} else {
						dif15 = 2 * Math.PI - theta14;
					}
					break;
				case 3:
					var f30;
					if(beta3 >= 0 && beta3 > Math.PI) {
						f30 = beta3;
					} else {
						var a30 = beta3 % (2 * Math.PI);
						if(a30 >= 0) {
							f30 = a30;
						} else {
							f30 = a30 + 2 * Math.PI;
						}
					}
					var this39 = f30;
					var za15 = this39;
					var f31;
					if(gamma3 >= 0 && gamma3 > Math.PI) {
						f31 = gamma3;
					} else {
						var a31 = gamma3 % (2 * Math.PI);
						if(a31 >= 0) {
							f31 = a31;
						} else {
							f31 = a31 + 2 * Math.PI;
						}
					}
					var this40 = f31;
					var zb15 = this40;
					var fa15 = beta3;
					var fb15 = gamma3;
					var theta15 = Math.abs(beta3 - gamma3);
					var largest3 = theta15 > Math.PI;
					var clockwise15 = beta3 < gamma3;
					var dif19 = clockwise15 ? theta15 : -theta15;
					if(largest3) {
						dif15 = dif19;
					} else if(clockwise15) {
						dif15 = -(2 * Math.PI - theta15);
					} else {
						dif15 = 2 * Math.PI - theta15;
					}
					break;
				}
				var positive3 = dif15 >= 0;
				var totalSteps3 = Math.ceil(Math.abs(dif15) / step6);
				var step7 = dif15 / totalSteps3;
				var angle3 = beta3;
				var cx3;
				var cy3;
				var bx3 = 0;
				var by3 = 0;
				var _g13 = 0;
				var _g7 = totalSteps3 + 1;
				while(_g13 < _g7) {
					var i3 = _g13++;
					cx3 = bx_ + radius3 * Math.sin(angle3);
					cy3 = by_ + radius3 * Math.cos(angle3);
					if(i3 != 0) {
						var t6 = new trilateral_tri_Trilateral(bx_,by_,bx3,by3,cx3,cy3);
						out3[out3.length] = t6;
					}
					angle3 += step7;
					bx3 = cx3;
					by3 = cy3;
				}
				var triArr3 = out3;
				var _g8 = 0;
				while(_g8 < triArr3.length) {
					var t7 = triArr3[_g8];
					++_g8;
					this31[this31.length] = t7;
				}
			}
		}
		var this41 = this.triArr;
		var tri = new trilateral_tri_Trilateral(dxPrev_,dyPrev_,this.dx,this.dy,exPrev_,eyPrev_,0);
		this41[this41.length] = tri;
		var this42 = this.triArr;
		var tri1 = new trilateral_tri_Trilateral(dxPrev_,dyPrev_,this.dx,this.dy,this.ex,this.ey,0);
		this42[this42.length] = tri1;
	}
	,computeDE: function() {
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
	}
	,anglesCompute: function() {
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
	}
	,thetaComputeAdj: function(qx,qy) {
		return -Math.atan2(this.ay - qy,this.ax - qx) - Math.PI / 2;
	}
	,__class__: trilateral_geom_Contour
};
var trilateral_justPath_IPathContext = function() { };
$hxClasses["trilateral.justPath.IPathContext"] = trilateral_justPath_IPathContext;
trilateral_justPath_IPathContext.__name__ = true;
trilateral_justPath_IPathContext.prototype = {
	moveTo: null
	,lineTo: null
	,quadTo: null
	,curveTo: null
	,__class__: trilateral_justPath_IPathContext
};
var trilateral_pairs_Line = function() { };
$hxClasses["trilateral.pairs.Line"] = trilateral_pairs_Line;
trilateral_pairs_Line.__name__ = true;
trilateral_pairs_Line.create = function(A,B,width) {
	var q_D;
	var q_C;
	var q_B;
	var q_A;
	var dx = A.x - B.x;
	var dy = A.y - B.y;
	var P_y;
	var P_x = A.x - width / 2;
	P_y = A.y;
	var omega = Math.atan2(dy,dx);
	var dim_y;
	var dim_x = width;
	dim_y = dx * dx + dy * dy;
	var pivotX = A.x + width / 2;
	var pivotY = A.y;
	var px = P_x;
	var py = P_y;
	var dx1 = dim_x;
	var dy1 = dim_y;
	var A_ = { x : px, y : py};
	var B_ = { x : px + dx1, y : py};
	var C_ = { x : px + dx1, y : py + dy1};
	var D_ = { x : px, y : py + dy1};
	if(omega != 0.) {
		var sin = Math.sin(omega);
		var cos = Math.cos(omega);
		var px1 = A_.x - pivotX;
		var py1 = A_.y - pivotY;
		var px2 = px1 * cos - py1 * sin;
		py1 = py1 * cos + px1 * sin;
		A_ = { x : px2 + pivotX, y : py1 + pivotY};
		var px3 = B_.x - pivotX;
		var py2 = B_.y - pivotY;
		var px21 = px3 * cos - py2 * sin;
		py2 = py2 * cos + px3 * sin;
		B_ = { x : px21 + pivotX, y : py2 + pivotY};
		var px4 = C_.x - pivotX;
		var py3 = C_.y - pivotY;
		var px22 = px4 * cos - py3 * sin;
		py3 = py3 * cos + px4 * sin;
		C_ = { x : px22 + pivotX, y : py3 + pivotY};
		var px5 = D_.x - pivotX;
		var py4 = D_.y - pivotY;
		var px23 = px5 * cos - py4 * sin;
		py4 = py4 * cos + px5 * sin;
		D_ = { x : px23 + pivotX, y : py4 + pivotY};
	}
	q_A = A_;
	q_B = B_;
	q_C = C_;
	q_D = D_;
	return { t0 : new trilateral_tri_Trilateral(q_A.x,q_A.y,q_B.x,q_B.y,q_D.x,q_D.y), t1 : new trilateral_tri_Trilateral(q_B.x,q_B.y,q_C.x,q_C.y,q_D.x,q_D.y)};
};
trilateral_pairs_Line.fromCoord = function(ax,ay,bx,by,width) {
	var q_D;
	var q_C;
	var q_B;
	var q_A;
	var dx = ax - bx;
	var dy = ay - by;
	var P_y;
	var P_x = ax - width / 2;
	P_y = ay;
	var omega = Math.atan2(dy,dx);
	var dim_y;
	var dim_x = width;
	dim_y = dx * dx + dy * dy;
	var pivotX = ax + width / 2;
	var px = P_x;
	var py = P_y;
	var dx1 = dim_x;
	var dy1 = dim_y;
	var A_ = { x : px, y : py};
	var B_ = { x : px + dx1, y : py};
	var C_ = { x : px + dx1, y : py + dy1};
	var D_ = { x : px, y : py + dy1};
	if(omega != 0.) {
		var sin = Math.sin(omega);
		var cos = Math.cos(omega);
		var px1 = A_.x - pivotX;
		var py1 = A_.y - ay;
		var px2 = px1 * cos - py1 * sin;
		py1 = py1 * cos + px1 * sin;
		A_ = { x : px2 + pivotX, y : py1 + ay};
		var px3 = B_.x - pivotX;
		var py2 = B_.y - ay;
		var px21 = px3 * cos - py2 * sin;
		py2 = py2 * cos + px3 * sin;
		B_ = { x : px21 + pivotX, y : py2 + ay};
		var px4 = C_.x - pivotX;
		var py3 = C_.y - ay;
		var px22 = px4 * cos - py3 * sin;
		py3 = py3 * cos + px4 * sin;
		C_ = { x : px22 + pivotX, y : py3 + ay};
		var px5 = D_.x - pivotX;
		var py4 = D_.y - ay;
		var px23 = px5 * cos - py4 * sin;
		py4 = py4 * cos + px5 * sin;
		D_ = { x : px23 + pivotX, y : py4 + ay};
	}
	q_A = A_;
	q_B = B_;
	q_C = C_;
	q_D = D_;
	return { t0 : new trilateral_tri_Trilateral(q_A.x,q_A.y,q_B.x,q_B.y,q_D.x,q_D.y), t1 : new trilateral_tri_Trilateral(q_B.x,q_B.y,q_C.x,q_C.y,q_D.x,q_D.y)};
};
var trilateral_pairs_Quad = function() { };
$hxClasses["trilateral.pairs.Quad"] = trilateral_pairs_Quad;
trilateral_pairs_Quad.__name__ = true;
trilateral_pairs_Quad.rectangle = function(x,y,w,h) {
	var ax = x;
	var ay = y;
	var bx = x + w;
	var by = ay;
	var cx = bx;
	var cy = ay + h;
	var dx = x;
	var dy = cy;
	return { t0 : new trilateral_tri_Trilateral(ax,ay,bx,by,dx,dy), t1 : new trilateral_tri_Trilateral(bx,by,cx,cy,dx,dy)};
};
trilateral_pairs_Quad.squareOutline = function(px,py,radius,thick,theta) {
	if(theta == null) {
		theta = 0;
	}
	var this1 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out = this1;
	var ax = 0.;
	var ay = 0.;
	var bx = 0.;
	var by = 0.;
	var cx = 0.;
	var cy = 0.;
	var dx = 0.;
	var dy = 0.;
	var a0x = 0.;
	var a0y = 0.;
	var b0x = 0.;
	var b0y = 0.;
	var c0x = 0.;
	var c0y = 0.;
	var d0x = 0.;
	var d0y = 0.;
	if(theta != 0) {
		var pi = Math.PI;
		var pi4 = pi / 4;
		var pi2 = pi / 2;
		var sqrt2 = Math.sqrt(2);
		var r = radius * sqrt2;
		var aTheta = -pi + theta - pi4;
		var dTheta = -pi + theta + pi / 2 - pi / 4;
		var cTheta = theta - pi4;
		var bTheta = -pi + theta - pi2 - pi4;
		var $as = Math.sin(aTheta);
		var ac = Math.cos(aTheta);
		var bs = Math.sin(bTheta);
		var bc = Math.cos(bTheta);
		var cs = Math.sin(cTheta);
		var cc = Math.cos(cTheta);
		var ds = Math.sin(dTheta);
		var dc = Math.cos(dTheta);
		var r0 = r - thick;
		ax = px + r * $as;
		ay = py + r * ac;
		bx = px + r * bs;
		by = py + r * bc;
		cx = px + r * cs;
		cy = py + r * cc;
		dx = px + r * ds;
		dy = py + r * dc;
		a0x = px + r0 * $as;
		a0y = py + r0 * ac;
		b0x = px + r0 * bs;
		b0y = py + r0 * bc;
		c0x = px + r0 * cs;
		c0y = py + r0 * cc;
		d0x = px + r0 * ds;
		d0y = py + r0 * dc;
	} else {
		ax = px - radius;
		ay = py - radius;
		var lx = radius * 2;
		var ly = lx;
		bx = ax + lx;
		by = ay;
		cx = bx;
		cy = ay + ly;
		dx = ax;
		dy = cy;
		var radius0 = radius - thick;
		a0x = px - radius0;
		a0y = py - radius0;
		var l0x = radius0 * 2;
		var l0y = l0x;
		b0x = a0x + l0x;
		b0y = a0y;
		c0x = b0x;
		c0y = a0y + l0y;
		d0x = a0x;
		d0y = c0y;
	}
	var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,a0x,a0y);
	out[out.length] = tri;
	var tri1 = new trilateral_tri_Trilateral(bx,by,b0x,b0y,a0x,a0y);
	out[out.length] = tri1;
	var tri2 = new trilateral_tri_Trilateral(d0x,d0y,c0x,c0y,dx,dy);
	out[out.length] = tri2;
	var tri3 = new trilateral_tri_Trilateral(c0x,c0y,cx,cy,dx,dy);
	out[out.length] = tri3;
	var tri4 = new trilateral_tri_Trilateral(ax,ay,a0x,a0y,d0x,d0y);
	out[out.length] = tri4;
	var tri5 = new trilateral_tri_Trilateral(ax,ay,d0x,d0y,dx,dy);
	out[out.length] = tri5;
	var tri6 = new trilateral_tri_Trilateral(b0x,b0y,bx,by,c0x,c0y);
	out[out.length] = tri6;
	var tri7 = new trilateral_tri_Trilateral(bx,by,cx,cy,c0x,c0y);
	out[out.length] = tri7;
	return out;
};
trilateral_pairs_Quad.square = function(px,py,radius,theta) {
	if(theta == null) {
		theta = 0;
	}
	var ax = 0.;
	var ay = 0.;
	var bx = 0.;
	var by = 0.;
	var cx = 0.;
	var cy = 0.;
	var dx = 0.;
	var dy = 0.;
	if(theta != 0) {
		var pi = Math.PI;
		var pi4 = pi / 4;
		var pi2 = pi / 2;
		var sqrt2 = Math.sqrt(2);
		var r = radius * sqrt2;
		var aTheta = -pi + theta - pi4;
		var dTheta = -pi + theta + pi / 2 - pi / 4;
		var cTheta = theta - pi4;
		var bTheta = -pi + theta - pi2 - pi4;
		ax = px + r * Math.sin(aTheta);
		ay = py + r * Math.cos(aTheta);
		bx = px + r * Math.sin(bTheta);
		by = py + r * Math.cos(bTheta);
		cx = px + r * Math.sin(cTheta);
		cy = py + r * Math.cos(cTheta);
		dx = px + r * Math.sin(dTheta);
		dy = py + r * Math.cos(dTheta);
	} else {
		ax = px - radius;
		ay = py - radius;
		var lx = radius * 2;
		var ly = lx;
		bx = ax + lx;
		by = ay;
		cx = bx;
		cy = ay + ly;
		dx = ax;
		dy = cy;
	}
	return { t0 : new trilateral_tri_Trilateral(ax,ay,bx,by,dx,dy), t1 : new trilateral_tri_Trilateral(bx,by,cx,cy,dx,dy)};
};
trilateral_pairs_Quad.diamond = function(x,y,radius,theta) {
	if(theta == null) {
		theta = 0;
	}
	var theta1 = Math.PI / 4 + theta;
	var ax = 0.;
	var ay = 0.;
	var bx = 0.;
	var by = 0.;
	var cx = 0.;
	var cy = 0.;
	var dx = 0.;
	var dy = 0.;
	if(theta1 != 0) {
		var pi = Math.PI;
		var pi4 = pi / 4;
		var pi2 = pi / 2;
		var sqrt2 = Math.sqrt(2);
		var r = radius * sqrt2;
		var aTheta = -pi + theta1 - pi4;
		var dTheta = -pi + theta1 + pi / 2 - pi / 4;
		var cTheta = theta1 - pi4;
		var bTheta = -pi + theta1 - pi2 - pi4;
		ax = x + r * Math.sin(aTheta);
		ay = y + r * Math.cos(aTheta);
		bx = x + r * Math.sin(bTheta);
		by = y + r * Math.cos(bTheta);
		cx = x + r * Math.sin(cTheta);
		cy = y + r * Math.cos(cTheta);
		dx = x + r * Math.sin(dTheta);
		dy = y + r * Math.cos(dTheta);
	} else {
		ax = x - radius;
		ay = y - radius;
		var lx = radius * 2;
		var ly = lx;
		bx = ax + lx;
		by = ay;
		cx = bx;
		cy = ay + ly;
		dx = ax;
		dy = cy;
	}
	return { t0 : new trilateral_tri_Trilateral(ax,ay,bx,by,dx,dy), t1 : new trilateral_tri_Trilateral(bx,by,cx,cy,dx,dy)};
};
trilateral_pairs_Quad.diamondOutline = function(x,y,thick,radius,theta) {
	if(theta == null) {
		theta = 0;
	}
	var theta1 = Math.PI / 4 + theta;
	var this1 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out = this1;
	var ax = 0.;
	var ay = 0.;
	var bx = 0.;
	var by = 0.;
	var cx = 0.;
	var cy = 0.;
	var dx = 0.;
	var dy = 0.;
	var a0x = 0.;
	var a0y = 0.;
	var b0x = 0.;
	var b0y = 0.;
	var c0x = 0.;
	var c0y = 0.;
	var d0x = 0.;
	var d0y = 0.;
	if(theta1 != 0) {
		var pi = Math.PI;
		var pi4 = pi / 4;
		var pi2 = pi / 2;
		var sqrt2 = Math.sqrt(2);
		var r = radius * sqrt2;
		var aTheta = -pi + theta1 - pi4;
		var dTheta = -pi + theta1 + pi / 2 - pi / 4;
		var cTheta = theta1 - pi4;
		var bTheta = -pi + theta1 - pi2 - pi4;
		var $as = Math.sin(aTheta);
		var ac = Math.cos(aTheta);
		var bs = Math.sin(bTheta);
		var bc = Math.cos(bTheta);
		var cs = Math.sin(cTheta);
		var cc = Math.cos(cTheta);
		var ds = Math.sin(dTheta);
		var dc = Math.cos(dTheta);
		var r0 = r - thick;
		ax = x + r * $as;
		ay = y + r * ac;
		bx = x + r * bs;
		by = y + r * bc;
		cx = x + r * cs;
		cy = y + r * cc;
		dx = x + r * ds;
		dy = y + r * dc;
		a0x = x + r0 * $as;
		a0y = y + r0 * ac;
		b0x = x + r0 * bs;
		b0y = y + r0 * bc;
		c0x = x + r0 * cs;
		c0y = y + r0 * cc;
		d0x = x + r0 * ds;
		d0y = y + r0 * dc;
	} else {
		ax = x - radius;
		ay = y - radius;
		var lx = radius * 2;
		var ly = lx;
		bx = ax + lx;
		by = ay;
		cx = bx;
		cy = ay + ly;
		dx = ax;
		dy = cy;
		var radius0 = radius - thick;
		a0x = x - radius0;
		a0y = y - radius0;
		var l0x = radius0 * 2;
		var l0y = l0x;
		b0x = a0x + l0x;
		b0y = a0y;
		c0x = b0x;
		c0y = a0y + l0y;
		d0x = a0x;
		d0y = c0y;
	}
	var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,a0x,a0y);
	out[out.length] = tri;
	var tri1 = new trilateral_tri_Trilateral(bx,by,b0x,b0y,a0x,a0y);
	out[out.length] = tri1;
	var tri2 = new trilateral_tri_Trilateral(d0x,d0y,c0x,c0y,dx,dy);
	out[out.length] = tri2;
	var tri3 = new trilateral_tri_Trilateral(c0x,c0y,cx,cy,dx,dy);
	out[out.length] = tri3;
	var tri4 = new trilateral_tri_Trilateral(ax,ay,a0x,a0y,d0x,d0y);
	out[out.length] = tri4;
	var tri5 = new trilateral_tri_Trilateral(ax,ay,d0x,d0y,dx,dy);
	out[out.length] = tri5;
	var tri6 = new trilateral_tri_Trilateral(b0x,b0y,bx,by,c0x,c0y);
	out[out.length] = tri6;
	var tri7 = new trilateral_tri_Trilateral(bx,by,cx,cy,c0x,c0y);
	out[out.length] = tri7;
	return out;
};
var trilateral_pairs_Star = function() { };
$hxClasses["trilateral.pairs.Star"] = trilateral_pairs_Star;
trilateral_pairs_Star.__name__ = true;
trilateral_pairs_Star.create = function(px,py,radius,theta) {
	if(theta == null) {
		theta = 0;
	}
	var pi = Math.PI;
	var omega = -pi + theta;
	var a0x = px + radius * Math.sin(omega);
	var a0y = py + radius * Math.cos(omega);
	omega += pi / 3;
	var a1x = px + radius * Math.sin(omega);
	var a1y = py + radius * Math.cos(omega);
	omega += pi / 3;
	var b0x = px + radius * Math.sin(omega);
	var b0y = py + radius * Math.cos(omega);
	omega += pi / 3;
	var b1x = px + radius * Math.sin(omega);
	var b1y = py + radius * Math.cos(omega);
	omega += pi / 3;
	var c0x = px + radius * Math.sin(omega);
	var c0y = py + radius * Math.cos(omega);
	omega += pi / 3;
	var c1x = px + radius * Math.sin(omega);
	var c1y = py + radius * Math.cos(omega);
	return { t0 : new trilateral_tri_Trilateral(a0x,a0y,b0x,b0y,c0x,c0y), t1 : new trilateral_tri_Trilateral(a1x,a1y,b1x,b1y,c1x,c1y)};
};
var trilateral_path_Base = function(contour_,trilateralArray_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.width = 0.01;
	this.y = 0.;
	this.x = 0.;
	var tmp;
	if(trilateralArray_ == null) {
		var this1 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		tmp = this1;
	} else {
		tmp = trilateralArray_;
	}
	this.trilateralArray = tmp;
	this.contour = contour_ == null ? new trilateral_geom_Contour(this.trilateralArray,endLine_) : contour_;
	this.endLine = endLine_;
	this.points = [];
	this.points[0] = [];
	this.dim = [];
};
$hxClasses["trilateral.path.Base"] = trilateral_path_Base;
trilateral_path_Base.__name__ = true;
trilateral_path_Base.__interfaces__ = [trilateral_justPath_IPathContext];
trilateral_path_Base.prototype = {
	trilateralArray: null
	,x: null
	,y: null
	,width: null
	,widthFunction: null
	,tempArr: null
	,contour: null
	,endLine: null
	,points: null
	,dim: null
	,initDim: function() {
		return { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
	}
	,updateDim: function(x,y) {
		var d = this.dim[this.dim.length - 1];
		if(x < d.minX) {
			d.minX = x;
		}
		if(x > d.maxX) {
			d.maxX = x;
		}
		if(y < d.minY) {
			d.minY = y;
		}
		if(y > d.maxY) {
			d.maxY = y;
		}
	}
	,moveTo: function(x_,y_) {
		if(this.endLine == 2 || this.endLine == 3) {
			var _this = this.contour;
			var ax = _this.bx;
			var ay = _this.by;
			var radius = this.width / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 - Math.PI;
			var this1 = _this.triArr;
			var this2 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
			var out = this2;
			var pi = Math.PI;
			var step = pi * 2 / 36;
			var dif;
			switch(trilateral_angle_DifferencePreference.SMALL[1]) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					if(a >= 0) {
						f = a;
					} else {
						f = a + 2 * Math.PI;
					}
				}
				var this3 = f;
				var za = this3;
				var f1;
				if(gamma >= 0 && gamma > Math.PI) {
					f1 = gamma;
				} else {
					var a1 = gamma % (2 * Math.PI);
					if(a1 >= 0) {
						f1 = a1;
					} else {
						f1 = a1 + 2 * Math.PI;
					}
				}
				var this4 = f1;
				var zb = this4;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				if(dif1 > 0) {
					dif = dif1;
				} else {
					dif = 2 * Math.PI + dif1;
				}
				break;
			case 1:
				var f2;
				if(beta >= 0 && beta > Math.PI) {
					f2 = beta;
				} else {
					var a2 = beta % (2 * Math.PI);
					if(a2 >= 0) {
						f2 = a2;
					} else {
						f2 = a2 + 2 * Math.PI;
					}
				}
				var this5 = f2;
				var za1 = this5;
				var f3;
				if(gamma >= 0 && gamma > Math.PI) {
					f3 = gamma;
				} else {
					var a3 = gamma % (2 * Math.PI);
					if(a3 >= 0) {
						f3 = a3;
					} else {
						f3 = a3 + 2 * Math.PI;
					}
				}
				var this6 = f3;
				var zb1 = this6;
				var fa1 = beta;
				var fb1 = gamma;
				var theta1 = Math.abs(beta - gamma);
				var clockwise1 = beta < gamma;
				var dif2 = clockwise1 ? theta1 : -theta1;
				if(dif2 < 0) {
					dif = dif2;
				} else {
					dif = -2 * Math.PI + dif2;
				}
				break;
			case 2:
				var f4;
				if(beta >= 0 && beta > Math.PI) {
					f4 = beta;
				} else {
					var a4 = beta % (2 * Math.PI);
					if(a4 >= 0) {
						f4 = a4;
					} else {
						f4 = a4 + 2 * Math.PI;
					}
				}
				var this7 = f4;
				var za2 = this7;
				var f5;
				if(gamma >= 0 && gamma > Math.PI) {
					f5 = gamma;
				} else {
					var a5 = gamma % (2 * Math.PI);
					if(a5 >= 0) {
						f5 = a5;
					} else {
						f5 = a5 + 2 * Math.PI;
					}
				}
				var this8 = f5;
				var zb2 = this8;
				var fa2 = beta;
				var fb2 = gamma;
				var theta2 = Math.abs(beta - gamma);
				var smallest = theta2 <= Math.PI;
				var clockwise2 = beta < gamma;
				var dif3 = clockwise2 ? theta2 : -theta2;
				if(smallest) {
					dif = dif3;
				} else if(clockwise2) {
					dif = -(2 * Math.PI - theta2);
				} else {
					dif = 2 * Math.PI - theta2;
				}
				break;
			case 3:
				var f6;
				if(beta >= 0 && beta > Math.PI) {
					f6 = beta;
				} else {
					var a6 = beta % (2 * Math.PI);
					if(a6 >= 0) {
						f6 = a6;
					} else {
						f6 = a6 + 2 * Math.PI;
					}
				}
				var this9 = f6;
				var za3 = this9;
				var f7;
				if(gamma >= 0 && gamma > Math.PI) {
					f7 = gamma;
				} else {
					var a7 = gamma % (2 * Math.PI);
					if(a7 >= 0) {
						f7 = a7;
					} else {
						f7 = a7 + 2 * Math.PI;
					}
				}
				var this10 = f7;
				var zb3 = this10;
				var fa3 = beta;
				var fb3 = gamma;
				var theta3 = Math.abs(beta - gamma);
				var largest = theta3 > Math.PI;
				var clockwise3 = beta < gamma;
				var dif4 = clockwise3 ? theta3 : -theta3;
				if(largest) {
					dif = dif4;
				} else if(clockwise3) {
					dif = -(2 * Math.PI - theta3);
				} else {
					dif = 2 * Math.PI - theta3;
				}
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step1 = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g1 = 0;
			var _g = totalSteps + 1;
			while(_g1 < _g) {
				var i = _g1++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				if(i != 0) {
					var t = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
					out[out.length] = t;
				}
				angle += step1;
				bx = cx;
				by = cy;
			}
			var triArr = out;
			var _g2 = 0;
			while(_g2 < triArr.length) {
				var t1 = triArr[_g2];
				++_g2;
				this1[this1.length] = t1;
			}
		}
		this.x = x_;
		this.y = y_;
		var l = this.points.length;
		this.points[l] = [];
		this.points[l][0] = x_;
		this.points[l][1] = y_;
		this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
		var d = this.dim[this.dim.length - 1];
		if(x_ < d.minX) {
			d.minX = x_;
		}
		if(x_ > d.maxX) {
			d.maxX = x_;
		}
		if(y_ < d.minY) {
			d.minY = y_;
		}
		if(y_ > d.maxY) {
			d.maxY = y_;
		}
		this.contour.reset();
	}
	,lineTo: function(x_,y_) {
		if(this.widthFunction != null) {
			this.width = this.widthFunction(this.width,this.x,this.x,x_,y_);
		}
		this.line(x_,y_);
		var l = this.points.length;
		var p = this.points[l - 1];
		var l2 = p.length;
		p[l2] = x_;
		p[l2 + 1] = y_;
		var d = this.dim[this.dim.length - 1];
		if(x_ < d.minX) {
			d.minX = x_;
		}
		if(x_ > d.maxX) {
			d.maxX = x_;
		}
		if(y_ < d.minY) {
			d.minY = y_;
		}
		if(y_ > d.maxY) {
			d.maxY = y_;
		}
		this.x = x_;
		this.y = y_;
	}
	,line: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "Base.hx", lineNumber : 73, className : "trilateral.path.Base", methodName : "lineTrace"});
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.halfA = Math.PI / 2;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var dxPrev_ = _this.dx;
		var dyPrev_ = _this.dy;
		var exPrev_ = _this.ex;
		var eyPrev_ = _this.ey;
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var this1 = _this.triArr;
		var tri = new trilateral_tri_Trilateral(dxPrev_,dyPrev_,_this.dx,_this.dy,exPrev_,eyPrev_,0);
		this1[this1.length] = tri;
		var this2 = _this.triArr;
		var tri1 = new trilateral_tri_Trilateral(dxPrev_,dyPrev_,_this.dx,_this.dy,_this.ex,_this.ey,0);
		this2[this2.length] = tri1;
	}
	,lineTrace: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "Base.hx", lineNumber : 73, className : "trilateral.path.Base", methodName : "lineTrace"});
	}
	,quadTo: function(x1,y1,x2,y2) {
		this.tempArr = [];
		var p = this.tempArr;
		var ax = this.x;
		var ay = this.y;
		var x = ax - x1;
		var y = ay - y1;
		var x3 = x1 - x2;
		var y3 = y1 - y2;
		var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x3 * x3 + y3 * y3);
		if(approxDistance == 0) {
			approxDistance = 0.000001;
		}
		var step = Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.quadStep);
		var l = p.length;
		p[l++] = ax;
		p[l++] = ay;
		var t = step;
		while(t < 1.) {
			var u = 1 - t;
			p[l++] = Math.pow(u,2) * ax + 2 * u * t * x1 + Math.pow(t,2) * x2;
			var u1 = 1 - t;
			p[l++] = Math.pow(u1,2) * ay + 2 * u1 * t * y1 + Math.pow(t,2) * y2;
			t += step;
		}
		p[l++] = x2;
		p[l++] = y2;
		var arr = this.tempArr;
		var l1 = arr.length;
		var i = 2;
		var x_ = arr[0];
		var y_ = arr[1];
		if(this.widthFunction != null) {
			this.width = this.widthFunction(this.width,this.x,this.x,x_,y_);
		}
		this.line(x_,y_);
		var l2 = this.points.length;
		var p1 = this.points[l2 - 1];
		var l21 = p1.length;
		p1[l21] = x_;
		p1[l21 + 1] = y_;
		var d = this.dim[this.dim.length - 1];
		if(x_ < d.minX) {
			d.minX = x_;
		}
		if(x_ > d.maxX) {
			d.maxX = x_;
		}
		if(y_ < d.minY) {
			d.minY = y_;
		}
		if(y_ > d.maxY) {
			d.maxY = y_;
		}
		this.x = x_;
		this.y = y_;
		while(i < l1) {
			var x_1 = arr[i];
			var y_1 = arr[i + 1];
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.x,x_1,y_1);
			}
			this.line(x_1,y_1);
			var l3 = this.points.length;
			var p2 = this.points[l3 - 1];
			var l22 = p2.length;
			p2[l22] = x_1;
			p2[l22 + 1] = y_1;
			var d1 = this.dim[this.dim.length - 1];
			if(x_1 < d1.minX) {
				d1.minX = x_1;
			}
			if(x_1 > d1.maxX) {
				d1.maxX = x_1;
			}
			if(y_1 < d1.minY) {
				d1.minY = y_1;
			}
			if(y_1 > d1.maxY) {
				d1.maxY = y_1;
			}
			this.x = x_1;
			this.y = y_1;
			i += 2;
		}
		this.x = x2;
		this.y = y2;
	}
	,quadThru: function(x1,y1,x2,y2) {
		var newx = 2 * x1 - 0.5 * (this.x + x2);
		var newy = 2 * y1 - 0.5 * (this.y + y2);
		this.tempArr = [];
		var p = this.tempArr;
		var ax = this.x;
		var ay = this.y;
		var x = ax - newx;
		var y = ay - newy;
		var x3 = newx - x2;
		var y3 = newy - y2;
		var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x3 * x3 + y3 * y3);
		if(approxDistance == 0) {
			approxDistance = 0.000001;
		}
		var step = Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.quadStep);
		var l = p.length;
		p[l++] = ax;
		p[l++] = ay;
		var t = step;
		while(t < 1.) {
			var u = 1 - t;
			p[l++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * x2;
			var u1 = 1 - t;
			p[l++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * y2;
			t += step;
		}
		p[l++] = x2;
		p[l++] = y2;
		var arr = this.tempArr;
		var l1 = arr.length;
		var i = 2;
		var x_ = arr[0];
		var y_ = arr[1];
		if(this.widthFunction != null) {
			this.width = this.widthFunction(this.width,this.x,this.x,x_,y_);
		}
		this.line(x_,y_);
		var l2 = this.points.length;
		var p1 = this.points[l2 - 1];
		var l21 = p1.length;
		p1[l21] = x_;
		p1[l21 + 1] = y_;
		var d = this.dim[this.dim.length - 1];
		if(x_ < d.minX) {
			d.minX = x_;
		}
		if(x_ > d.maxX) {
			d.maxX = x_;
		}
		if(y_ < d.minY) {
			d.minY = y_;
		}
		if(y_ > d.maxY) {
			d.maxY = y_;
		}
		this.x = x_;
		this.y = y_;
		while(i < l1) {
			var x_1 = arr[i];
			var y_1 = arr[i + 1];
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.x,x_1,y_1);
			}
			this.line(x_1,y_1);
			var l3 = this.points.length;
			var p2 = this.points[l3 - 1];
			var l22 = p2.length;
			p2[l22] = x_1;
			p2[l22 + 1] = y_1;
			var d1 = this.dim[this.dim.length - 1];
			if(x_1 < d1.minX) {
				d1.minX = x_1;
			}
			if(x_1 > d1.maxX) {
				d1.maxX = x_1;
			}
			if(y_1 < d1.minY) {
				d1.minY = y_1;
			}
			if(y_1 > d1.maxY) {
				d1.maxY = y_1;
			}
			this.x = x_1;
			this.y = y_1;
			i += 2;
		}
		this.x = x2;
		this.y = y2;
		return;
	}
	,curveTo: function(x1,y1,x2,y2,x3,y3) {
		this.tempArr = [];
		var p = this.tempArr;
		var ax = this.x;
		var ay = this.y;
		var x = ax - x1;
		var y = ay - y1;
		var x4 = x1 - x2;
		var y4 = y1 - y2;
		var x5 = x2 - x3;
		var y5 = y2 - y3;
		var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x4 * x4 + y4 * y4) + Math.sqrt(x5 * x5 + y5 * y5);
		if(approxDistance == 0) {
			approxDistance = 0.000001;
		}
		var step = Math.min(1 / (approxDistance * 0.707),trilateral_geom_Algebra.cubicStep);
		var l = p.length;
		p[l++] = ax;
		p[l++] = ay;
		var t = step;
		while(t < 1.) {
			var u = 1 - t;
			p[l++] = Math.pow(u,3) * ax + 3 * Math.pow(u,2) * t * x1 + 3 * u * Math.pow(t,2) * x2 + Math.pow(t,3) * x3;
			var u1 = 1 - t;
			p[l++] = Math.pow(u1,3) * ay + 3 * Math.pow(u1,2) * t * y1 + 3 * u1 * Math.pow(t,2) * y2 + Math.pow(t,3) * y3;
			t += step;
		}
		p[l++] = x3;
		p[l++] = y3;
		var arr = this.tempArr;
		var l1 = arr.length;
		var i = 2;
		var x_ = arr[0];
		var y_ = arr[1];
		if(this.widthFunction != null) {
			this.width = this.widthFunction(this.width,this.x,this.x,x_,y_);
		}
		this.line(x_,y_);
		var l2 = this.points.length;
		var p1 = this.points[l2 - 1];
		var l21 = p1.length;
		p1[l21] = x_;
		p1[l21 + 1] = y_;
		var d = this.dim[this.dim.length - 1];
		if(x_ < d.minX) {
			d.minX = x_;
		}
		if(x_ > d.maxX) {
			d.maxX = x_;
		}
		if(y_ < d.minY) {
			d.minY = y_;
		}
		if(y_ > d.maxY) {
			d.maxY = y_;
		}
		this.x = x_;
		this.y = y_;
		while(i < l1) {
			var x_1 = arr[i];
			var y_1 = arr[i + 1];
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.x,x_1,y_1);
			}
			this.line(x_1,y_1);
			var l3 = this.points.length;
			var p2 = this.points[l3 - 1];
			var l22 = p2.length;
			p2[l22] = x_1;
			p2[l22 + 1] = y_1;
			var d1 = this.dim[this.dim.length - 1];
			if(x_1 < d1.minX) {
				d1.minX = x_1;
			}
			if(x_1 > d1.maxX) {
				d1.maxX = x_1;
			}
			if(y_1 < d1.minY) {
				d1.minY = y_1;
			}
			if(y_1 > d1.maxY) {
				d1.maxY = y_1;
			}
			this.x = x_1;
			this.y = y_1;
			i += 2;
		}
		this.x = x3;
		this.y = y3;
	}
	,plotCoord: function(arr,withMove) {
		if(withMove == null) {
			withMove = true;
		}
		var l = arr.length;
		var i = 2;
		if(withMove) {
			this.moveTo(arr[0],arr[1]);
		} else {
			var x_ = arr[0];
			var y_ = arr[1];
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.x,x_,y_);
			}
			this.line(x_,y_);
			var l1 = this.points.length;
			var p = this.points[l1 - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.x = x_;
			this.y = y_;
		}
		while(i < l) {
			var x_1 = arr[i];
			var y_1 = arr[i + 1];
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.x,x_1,y_1);
			}
			this.line(x_1,y_1);
			var l3 = this.points.length;
			var p1 = this.points[l3 - 1];
			var l21 = p1.length;
			p1[l21] = x_1;
			p1[l21 + 1] = y_1;
			var d1 = this.dim[this.dim.length - 1];
			if(x_1 < d1.minX) {
				d1.minX = x_1;
			}
			if(x_1 > d1.maxX) {
				d1.maxX = x_1;
			}
			if(y_1 < d1.minY) {
				d1.minY = y_1;
			}
			if(y_1 > d1.maxY) {
				d1.maxY = y_1;
			}
			this.x = x_1;
			this.y = y_1;
			i += 2;
		}
	}
	,__class__: trilateral_path_Base
};
var trilateral_path_Crude = function(contour_,trilateralArray_,endLine_) {
	trilateral_path_Base.call(this,contour_,trilateralArray_,endLine_);
};
$hxClasses["trilateral.path.Crude"] = trilateral_path_Crude;
trilateral_path_Crude.__name__ = true;
trilateral_path_Crude.__super__ = trilateral_path_Base;
trilateral_path_Crude.prototype = $extend(trilateral_path_Base.prototype,{
	line: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.halfA = Math.PI / 2;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var dxPrev_ = _this.dx;
		var dyPrev_ = _this.dy;
		var exPrev_ = _this.ex;
		var eyPrev_ = _this.ey;
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var this1 = _this.triArr;
		var tri = new trilateral_tri_Trilateral(dxPrev_,dyPrev_,_this.dx,_this.dy,exPrev_,eyPrev_,0);
		this1[this1.length] = tri;
		var this2 = _this.triArr;
		var tri1 = new trilateral_tri_Trilateral(dxPrev_,dyPrev_,_this.dx,_this.dy,_this.ex,_this.ey,0);
		this2[this2.length] = tri1;
	}
	,__class__: trilateral_path_Crude
});
var trilateral_path_Fine = function(contour_,trilateralArray_,endLine_) {
	trilateral_path_Base.call(this,contour_,trilateralArray_,endLine_);
};
$hxClasses["trilateral.path.Fine"] = trilateral_path_Fine;
trilateral_path_Fine.__name__ = true;
trilateral_path_Fine.__super__ = trilateral_path_Base;
trilateral_path_Fine.prototype = $extend(trilateral_path_Base.prototype,{
	line: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		var oldAngle = _this.dx != null ? _this.angle1 : null;
		_this.halfA = Math.PI / 2;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var x = _this.dxOld - x_;
		var y = _this.dyOld - y_;
		var x1 = _this.exOld - x_;
		var y1 = _this.eyOld - y_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(_this.ay - _this.dyOld,_this.ax - _this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.eyPrev,_this.ax - _this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(_this.ay - _this.eyOld,_this.ax - _this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.dyPrev,_this.ax - _this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(trilateral_angle_DifferencePreference.SMALL[1]) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				if(a >= 0) {
					f = a;
				} else {
					f = a + 2 * Math.PI;
				}
			}
			var this1 = f;
			var za = this1;
			var f1;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f1 = theta1;
			} else {
				var a1 = theta1 % (2 * Math.PI);
				if(a1 >= 0) {
					f1 = a1;
				} else {
					f1 = a1 + 2 * Math.PI;
				}
			}
			var this2 = f1;
			var zb = this2;
			var fa = theta0;
			var fb = theta1;
			var theta = Math.abs(theta0 - theta1);
			var clockwise = theta0 < theta1;
			var dif1 = clockwise ? theta : -theta;
			if(dif1 > 0) {
				dif = dif1;
			} else {
				dif = 2 * Math.PI + dif1;
			}
			break;
		case 1:
			var f2;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f2 = theta0;
			} else {
				var a2 = theta0 % (2 * Math.PI);
				if(a2 >= 0) {
					f2 = a2;
				} else {
					f2 = a2 + 2 * Math.PI;
				}
			}
			var this3 = f2;
			var za1 = this3;
			var f3;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f3 = theta1;
			} else {
				var a3 = theta1 % (2 * Math.PI);
				if(a3 >= 0) {
					f3 = a3;
				} else {
					f3 = a3 + 2 * Math.PI;
				}
			}
			var this4 = f3;
			var zb1 = this4;
			var fa1 = theta0;
			var fb1 = theta1;
			var theta2 = Math.abs(theta0 - theta1);
			var clockwise1 = theta0 < theta1;
			var dif2 = clockwise1 ? theta2 : -theta2;
			if(dif2 < 0) {
				dif = dif2;
			} else {
				dif = -2 * Math.PI + dif2;
			}
			break;
		case 2:
			var f4;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f4 = theta0;
			} else {
				var a4 = theta0 % (2 * Math.PI);
				if(a4 >= 0) {
					f4 = a4;
				} else {
					f4 = a4 + 2 * Math.PI;
				}
			}
			var this5 = f4;
			var za2 = this5;
			var f5;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f5 = theta1;
			} else {
				var a5 = theta1 % (2 * Math.PI);
				if(a5 >= 0) {
					f5 = a5;
				} else {
					f5 = a5 + 2 * Math.PI;
				}
			}
			var this6 = f5;
			var zb2 = this6;
			var fa2 = theta0;
			var fb2 = theta1;
			var theta3 = Math.abs(theta0 - theta1);
			var smallest = theta3 <= Math.PI;
			var clockwise2 = theta0 < theta1;
			var dif3 = clockwise2 ? theta3 : -theta3;
			if(smallest) {
				dif = dif3;
			} else if(clockwise2) {
				dif = -(2 * Math.PI - theta3);
			} else {
				dif = 2 * Math.PI - theta3;
			}
			break;
		case 3:
			var f6;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f6 = theta0;
			} else {
				var a6 = theta0 % (2 * Math.PI);
				if(a6 >= 0) {
					f6 = a6;
				} else {
					f6 = a6 + 2 * Math.PI;
				}
			}
			var this7 = f6;
			var za3 = this7;
			var f7;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f7 = theta1;
			} else {
				var a7 = theta1 % (2 * Math.PI);
				if(a7 >= 0) {
					f7 = a7;
				} else {
					f7 = a7 + 2 * Math.PI;
				}
			}
			var this8 = f7;
			var zb3 = this8;
			var fa3 = theta0;
			var fb3 = theta1;
			var theta4 = Math.abs(theta0 - theta1);
			var largest = theta4 > Math.PI;
			var clockwise3 = theta0 < theta1;
			var dif4 = clockwise3 ? theta4 : -theta4;
			if(largest) {
				dif = dif4;
			} else if(clockwise3) {
				dif = -(2 * Math.PI - theta4);
			} else {
				dif = 2 * Math.PI - theta4;
			}
			break;
		}
		if(_this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ * Math.sin(gamma);
			var f8;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f8 = theta0;
			} else {
				var a8 = (theta0 + Math.PI) % (2 * Math.PI);
				if(a8 >= 0) {
					f8 = a8 - Math.PI;
				} else {
					f8 = a8 + Math.PI;
				}
			}
			var this9 = f8;
			var start = this9;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			_this.jx = _this.ax + h * Math.sin(delta);
			_this.jy = _this.ay + h * Math.cos(delta);
		}
		if(_this.count == 0 && (_this.endLine == 1 || _this.endLine == 3)) {
			var ax = _this.ax;
			var ay = _this.ay;
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma1 = -_this.angle1 - Math.PI / 2 + Math.PI;
			var this10 = _this.triArr;
			var this11 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
			var out = this11;
			var pi = Math.PI;
			var step = pi * 2 / 36;
			var dif5;
			switch(trilateral_angle_DifferencePreference.SMALL[1]) {
			case 0:
				var f9;
				if(beta >= 0 && beta > Math.PI) {
					f9 = beta;
				} else {
					var a9 = beta % (2 * Math.PI);
					if(a9 >= 0) {
						f9 = a9;
					} else {
						f9 = a9 + 2 * Math.PI;
					}
				}
				var this12 = f9;
				var za4 = this12;
				var f10;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f10 = gamma1;
				} else {
					var a10 = gamma1 % (2 * Math.PI);
					if(a10 >= 0) {
						f10 = a10;
					} else {
						f10 = a10 + 2 * Math.PI;
					}
				}
				var this13 = f10;
				var zb4 = this13;
				var fa4 = beta;
				var fb4 = gamma1;
				var theta5 = Math.abs(beta - gamma1);
				var clockwise4 = beta < gamma1;
				var dif6 = clockwise4 ? theta5 : -theta5;
				if(dif6 > 0) {
					dif5 = dif6;
				} else {
					dif5 = 2 * Math.PI + dif6;
				}
				break;
			case 1:
				var f11;
				if(beta >= 0 && beta > Math.PI) {
					f11 = beta;
				} else {
					var a11 = beta % (2 * Math.PI);
					if(a11 >= 0) {
						f11 = a11;
					} else {
						f11 = a11 + 2 * Math.PI;
					}
				}
				var this14 = f11;
				var za5 = this14;
				var f12;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f12 = gamma1;
				} else {
					var a12 = gamma1 % (2 * Math.PI);
					if(a12 >= 0) {
						f12 = a12;
					} else {
						f12 = a12 + 2 * Math.PI;
					}
				}
				var this15 = f12;
				var zb5 = this15;
				var fa5 = beta;
				var fb5 = gamma1;
				var theta6 = Math.abs(beta - gamma1);
				var clockwise5 = beta < gamma1;
				var dif7 = clockwise5 ? theta6 : -theta6;
				if(dif7 < 0) {
					dif5 = dif7;
				} else {
					dif5 = -2 * Math.PI + dif7;
				}
				break;
			case 2:
				var f13;
				if(beta >= 0 && beta > Math.PI) {
					f13 = beta;
				} else {
					var a13 = beta % (2 * Math.PI);
					if(a13 >= 0) {
						f13 = a13;
					} else {
						f13 = a13 + 2 * Math.PI;
					}
				}
				var this16 = f13;
				var za6 = this16;
				var f14;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f14 = gamma1;
				} else {
					var a14 = gamma1 % (2 * Math.PI);
					if(a14 >= 0) {
						f14 = a14;
					} else {
						f14 = a14 + 2 * Math.PI;
					}
				}
				var this17 = f14;
				var zb6 = this17;
				var fa6 = beta;
				var fb6 = gamma1;
				var theta7 = Math.abs(beta - gamma1);
				var smallest1 = theta7 <= Math.PI;
				var clockwise6 = beta < gamma1;
				var dif8 = clockwise6 ? theta7 : -theta7;
				if(smallest1) {
					dif5 = dif8;
				} else if(clockwise6) {
					dif5 = -(2 * Math.PI - theta7);
				} else {
					dif5 = 2 * Math.PI - theta7;
				}
				break;
			case 3:
				var f15;
				if(beta >= 0 && beta > Math.PI) {
					f15 = beta;
				} else {
					var a15 = beta % (2 * Math.PI);
					if(a15 >= 0) {
						f15 = a15;
					} else {
						f15 = a15 + 2 * Math.PI;
					}
				}
				var this18 = f15;
				var za7 = this18;
				var f16;
				if(gamma1 >= 0 && gamma1 > Math.PI) {
					f16 = gamma1;
				} else {
					var a16 = gamma1 % (2 * Math.PI);
					if(a16 >= 0) {
						f16 = a16;
					} else {
						f16 = a16 + 2 * Math.PI;
					}
				}
				var this19 = f16;
				var zb7 = this19;
				var fa7 = beta;
				var fb7 = gamma1;
				var theta8 = Math.abs(beta - gamma1);
				var largest1 = theta8 > Math.PI;
				var clockwise7 = beta < gamma1;
				var dif9 = clockwise7 ? theta8 : -theta8;
				if(largest1) {
					dif5 = dif9;
				} else if(clockwise7) {
					dif5 = -(2 * Math.PI - theta8);
				} else {
					dif5 = 2 * Math.PI - theta8;
				}
				break;
			}
			var positive = dif5 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif5) / step);
			var step1 = dif5 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g1 = 0;
			var _g = totalSteps + 1;
			while(_g1 < _g) {
				var i = _g1++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				if(i != 0) {
					var t = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
					out[out.length] = t;
				}
				angle += step1;
				bx = cx;
				by = cy;
			}
			var triArr = out;
			var _g2 = 0;
			while(_g2 < triArr.length) {
				var t1 = triArr[_g2];
				++_g2;
				this10[this10.length] = t1;
			}
		}
		var radius1 = width_ / 2;
		var this20 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out1 = this20;
		var pi1 = Math.PI;
		var step2 = pi1 * 2 / 36;
		var positive1 = dif >= 0;
		var totalSteps1 = Math.ceil(Math.abs(dif) / step2);
		var step3 = dif / totalSteps1;
		var angle1 = theta0;
		var cx1;
		var cy1;
		var bx1 = 0;
		var by1 = 0;
		var _g11 = 0;
		var _g3 = totalSteps1 + 1;
		while(_g11 < _g3) {
			var i1 = _g11++;
			cx1 = ax_ + radius1 * Math.sin(angle1);
			cy1 = ay_ + radius1 * Math.cos(angle1);
			if(i1 != 0) {
				var t2 = new trilateral_tri_Trilateral(ax_,ay_,bx1,by1,cx1,cy1);
				out1[out1.length] = t2;
			}
			angle1 += step3;
			bx1 = cx1;
			by1 = cy1;
		}
		var trilateralArray = out1;
		var this21 = _this.triArr;
		var _g4 = 0;
		while(_g4 < trilateralArray.length) {
			var t3 = trilateralArray[_g4];
			++_g4;
			this21[this21.length] = t3;
		}
		if(_this.count != 0) {
			if(clockWise && !_this.lastClock) {
				if(_this.count == 1) {
					_this.triArr[_this.quadIndex + 1] = new trilateral_tri_Trilateral(_this.nax,_this.nay,_this.nbx,_this.nby,_this.ncx,_this.ncy);
				} else {
					_this.triArr[_this.quadIndex + 1] = new trilateral_tri_Trilateral(_this.nax,_this.nay,_this.nbx,_this.nby,_this.jxOld,_this.jyOld);
				}
				_this.triArr[_this.quadIndex] = new trilateral_tri_Trilateral(_this.kax,_this.kay,_this.kbx,_this.kby,_this.jx,_this.jy);
			}
			if(clockWise && _this.lastClock) {
				if(_this.count == 1) {
					_this.triArr[_this.quadIndex] = new trilateral_tri_Trilateral(_this.kax,_this.kay,_this.kbx,_this.kby,_this.jx,_this.jy);
					_this.triArr[_this.quadIndex + 1] = new trilateral_tri_Trilateral(_this.nax,_this.nay,_this.nbx,_this.nby,_this.ncx,_this.ncy);
				} else {
					_this.triArr[_this.quadIndex] = new trilateral_tri_Trilateral(_this.jxOld,_this.jyOld,_this.kbx,_this.kby,_this.jx,_this.jy);
					_this.triArr[_this.quadIndex + 1] = new trilateral_tri_Trilateral(_this.jxOld,_this.jyOld,_this.nbx,_this.nby,_this.ncx,_this.ncy);
				}
			}
			if(!clockWise && !_this.lastClock) {
				_this.triArr[_this.quadIndex] = new trilateral_tri_Trilateral(_this.kax,_this.kay,_this.jx,_this.jy,_this.kcx,_this.kcy);
				if(_this.count == 1) {
					_this.triArr[_this.quadIndex + 1] = new trilateral_tri_Trilateral(_this.nax,_this.nay,_this.jx,_this.jy,_this.ncx,_this.ncy);
				} else {
					_this.triArr[_this.quadIndex + 1] = new trilateral_tri_Trilateral(_this.nax,_this.nay,_this.jx,_this.jy,_this.jxOld,_this.jyOld);
				}
			}
			if(!clockWise && _this.lastClock) {
				if(_this.count == 1) {
					_this.triArr[_this.quadIndex] = new trilateral_tri_Trilateral(_this.kax,_this.kay,_this.jx,_this.jy,_this.kcx,_this.kcy);
					_this.triArr[_this.quadIndex + 1] = new trilateral_tri_Trilateral(_this.nax,_this.nay,_this.jx,_this.jy,_this.ncx,_this.ncy);
				} else {
					_this.triArr[_this.quadIndex] = new trilateral_tri_Trilateral(_this.jxOld,_this.jyOld,_this.jx,_this.jy,_this.kcx,_this.kcy);
					_this.triArr[_this.quadIndex + 1] = new trilateral_tri_Trilateral(_this.jxOld,_this.jyOld,_this.jx,_this.jy,_this.ncx,_this.ncy);
				}
			}
		}
		_this.quadIndex = _this.triArr.length;
		if(_this.count == 0) {
			var this22 = _this.triArr;
			var tri = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.ex,_this.ey,0);
			this22[this22.length] = tri;
			var this23 = _this.triArr;
			var tri1 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.exPrev,_this.eyPrev,0);
			this23[this23.length] = tri1;
		} else {
			if(clockWise && !_this.lastClock) {
				var this24 = _this.triArr;
				var tri2 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.ex,_this.ey,0);
				this24[this24.length] = tri2;
				var this25 = _this.triArr;
				var tri3 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.exPrev,_this.eyPrev,0);
				this25[this25.length] = tri3;
			}
			if(clockWise && _this.lastClock) {
				var this26 = _this.triArr;
				var tri4 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.ex,_this.ey,0);
				this26[this26.length] = tri4;
				var this27 = _this.triArr;
				var tri5 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.exPrev,_this.eyPrev,0);
				this27[this27.length] = tri5;
			}
			if(!clockWise && !_this.lastClock) {
				var this28 = _this.triArr;
				var tri6 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.jx,_this.jy,0);
				this28[this28.length] = tri6;
				var this29 = _this.triArr;
				var tri7 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.dx,_this.dy,_this.ex,_this.ey,0);
				this29[this29.length] = tri7;
			}
			if(!clockWise && _this.lastClock) {
				var this30 = _this.triArr;
				var tri8 = new trilateral_tri_Trilateral(_this.jx,_this.jy,_this.dx,_this.dy,_this.ex,_this.ey,0);
				this30[this30.length] = tri8;
				var this31 = _this.triArr;
				var tri9 = new trilateral_tri_Trilateral(_this.dxPrev,_this.dyPrev,_this.jx,_this.jy,_this.ex,_this.ey,0);
				this31[this31.length] = tri9;
			}
		}
		_this.nax = _this.dxPrev;
		_this.nay = _this.dyPrev;
		_this.nbx = _this.dx;
		_this.nby = _this.dy;
		_this.ncx = _this.exPrev;
		_this.ncy = _this.eyPrev;
		_this.kax = _this.dxPrev;
		_this.kay = _this.dyPrev;
		_this.kbx = _this.dx;
		_this.kby = _this.dy;
		_this.kcx = _this.ex;
		_this.kcy = _this.ey;
		if(_this.count != 0) {
			if(clockWise) {
				var this32 = _this.triArr;
				var tri10 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.dxOld,_this.dyOld,_this.jx,_this.jy,0);
				this32[this32.length] = tri10;
				var this33 = _this.triArr;
				var tri11 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.exPrev,_this.eyPrev,_this.jx,_this.jy,0);
				this33[this33.length] = tri11;
			} else {
				var this34 = _this.triArr;
				var tri12 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.exOld,_this.eyOld,_this.jx,_this.jy,0);
				this34[this34.length] = tri12;
				var this35 = _this.triArr;
				var tri13 = new trilateral_tri_Trilateral(_this.ax,_this.ay,_this.dxPrev,_this.dyPrev,_this.jx,_this.jy,0);
				this35[this35.length] = tri13;
			}
		}
		_this.jxOld = _this.jx;
		_this.jyOld = _this.jy;
		_this.lastClock = clockWise;
		_this.count++;
	}
	,__class__: trilateral_path_Fine
});
var trilateral_polys_Poly = function() { };
$hxClasses["trilateral.polys.Poly"] = trilateral_polys_Poly;
trilateral_polys_Poly.__name__ = true;
trilateral_polys_Poly.circle = function(ax,ay,radius,sides,omega) {
	if(omega == null) {
		omega = 0.;
	}
	if(sides == null) {
		sides = 36;
	}
	var this1 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out = this1;
	var pi = Math.PI;
	var theta = pi / 2 + omega;
	var step = pi * 2 / sides;
	var bx;
	var by;
	var cx;
	var cy;
	var _g1 = 0;
	var _g = sides;
	while(_g1 < _g) {
		var i = _g1++;
		bx = ax + radius * Math.sin(theta);
		by = ay + radius * Math.cos(theta);
		theta += step;
		cx = ax + radius * Math.sin(theta);
		cy = ay + radius * Math.cos(theta);
		var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
		out[out.length] = tri;
	}
	return out;
};
trilateral_polys_Poly.ellipse = function(ax,ay,rx,ry,sides) {
	if(sides == null) {
		sides = 36;
	}
	var this1 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out = this1;
	var pi = Math.PI;
	var theta = pi / 2;
	var step = pi * 2 / sides;
	var bx;
	var by;
	var cx;
	var cy;
	var _g1 = 0;
	var _g = sides;
	while(_g1 < _g) {
		var i = _g1++;
		bx = ax + rx * Math.sin(theta);
		by = ay + ry * Math.cos(theta);
		theta += step;
		cx = ax + rx * Math.sin(theta);
		cy = ay + ry * Math.cos(theta);
		var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
		out[out.length] = tri;
	}
	return out;
};
trilateral_polys_Poly.pie = function(ax,ay,radius,beta,gamma,prefer,mark,sides) {
	if(sides == null) {
		sides = 36;
	}
	if(mark == null) {
		mark = 0;
	}
	var this1 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out = this1;
	var pi = Math.PI;
	var step = pi * 2 / sides;
	var dif;
	switch(prefer[1]) {
	case 0:
		var f;
		if(beta >= 0 && beta > Math.PI) {
			f = beta;
		} else {
			var a = beta % (2 * Math.PI);
			if(a >= 0) {
				f = a;
			} else {
				f = a + 2 * Math.PI;
			}
		}
		var this2 = f;
		var za = this2;
		var f1;
		if(gamma >= 0 && gamma > Math.PI) {
			f1 = gamma;
		} else {
			var a1 = gamma % (2 * Math.PI);
			if(a1 >= 0) {
				f1 = a1;
			} else {
				f1 = a1 + 2 * Math.PI;
			}
		}
		var this3 = f1;
		var zb = this3;
		var fa = beta;
		var fb = gamma;
		var theta = Math.abs(beta - gamma);
		var clockwise = beta < gamma;
		var dif1 = clockwise ? theta : -theta;
		if(dif1 > 0) {
			dif = dif1;
		} else {
			dif = 2 * Math.PI + dif1;
		}
		break;
	case 1:
		var f2;
		if(beta >= 0 && beta > Math.PI) {
			f2 = beta;
		} else {
			var a2 = beta % (2 * Math.PI);
			if(a2 >= 0) {
				f2 = a2;
			} else {
				f2 = a2 + 2 * Math.PI;
			}
		}
		var this4 = f2;
		var za1 = this4;
		var f3;
		if(gamma >= 0 && gamma > Math.PI) {
			f3 = gamma;
		} else {
			var a3 = gamma % (2 * Math.PI);
			if(a3 >= 0) {
				f3 = a3;
			} else {
				f3 = a3 + 2 * Math.PI;
			}
		}
		var this5 = f3;
		var zb1 = this5;
		var fa1 = beta;
		var fb1 = gamma;
		var theta1 = Math.abs(beta - gamma);
		var clockwise1 = beta < gamma;
		var dif2 = clockwise1 ? theta1 : -theta1;
		if(dif2 < 0) {
			dif = dif2;
		} else {
			dif = -2 * Math.PI + dif2;
		}
		break;
	case 2:
		var f4;
		if(beta >= 0 && beta > Math.PI) {
			f4 = beta;
		} else {
			var a4 = beta % (2 * Math.PI);
			if(a4 >= 0) {
				f4 = a4;
			} else {
				f4 = a4 + 2 * Math.PI;
			}
		}
		var this6 = f4;
		var za2 = this6;
		var f5;
		if(gamma >= 0 && gamma > Math.PI) {
			f5 = gamma;
		} else {
			var a5 = gamma % (2 * Math.PI);
			if(a5 >= 0) {
				f5 = a5;
			} else {
				f5 = a5 + 2 * Math.PI;
			}
		}
		var this7 = f5;
		var zb2 = this7;
		var fa2 = beta;
		var fb2 = gamma;
		var theta2 = Math.abs(beta - gamma);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = beta < gamma;
		var dif3 = clockwise2 ? theta2 : -theta2;
		if(smallest) {
			dif = dif3;
		} else if(clockwise2) {
			dif = -(2 * Math.PI - theta2);
		} else {
			dif = 2 * Math.PI - theta2;
		}
		break;
	case 3:
		var f6;
		if(beta >= 0 && beta > Math.PI) {
			f6 = beta;
		} else {
			var a6 = beta % (2 * Math.PI);
			if(a6 >= 0) {
				f6 = a6;
			} else {
				f6 = a6 + 2 * Math.PI;
			}
		}
		var this8 = f6;
		var za3 = this8;
		var f7;
		if(gamma >= 0 && gamma > Math.PI) {
			f7 = gamma;
		} else {
			var a7 = gamma % (2 * Math.PI);
			if(a7 >= 0) {
				f7 = a7;
			} else {
				f7 = a7 + 2 * Math.PI;
			}
		}
		var this9 = f7;
		var zb3 = this9;
		var fa3 = beta;
		var fb3 = gamma;
		var theta3 = Math.abs(beta - gamma);
		var largest = theta3 > Math.PI;
		var clockwise3 = beta < gamma;
		var dif4 = clockwise3 ? theta3 : -theta3;
		if(largest) {
			dif = dif4;
		} else if(clockwise3) {
			dif = -(2 * Math.PI - theta3);
		} else {
			dif = 2 * Math.PI - theta3;
		}
		break;
	}
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx;
	var cy;
	var bx = 0;
	var by = 0;
	var _g1 = 0;
	var _g = totalSteps + 1;
	while(_g1 < _g) {
		var i = _g1++;
		cx = ax + radius * Math.sin(angle);
		cy = ay + radius * Math.cos(angle);
		if(i != 0) {
			var t = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
			out[out.length] = t;
			if(mark != 0) {
				t.mark = mark;
			}
		}
		angle += step1;
		bx = cx;
		by = cy;
	}
	return out;
};
trilateral_polys_Poly.ellpisePie = function(ax,ay,rx,ry,beta,gamma,prefer,mark,sides) {
	if(sides == null) {
		sides = 36;
	}
	if(mark == null) {
		mark = 0;
	}
	var this1 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out = this1;
	var pi = Math.PI;
	var step = pi * 2 / sides;
	var dif;
	switch(prefer[1]) {
	case 0:
		var f;
		if(beta >= 0 && beta > Math.PI) {
			f = beta;
		} else {
			var a = beta % (2 * Math.PI);
			if(a >= 0) {
				f = a;
			} else {
				f = a + 2 * Math.PI;
			}
		}
		var this2 = f;
		var za = this2;
		var f1;
		if(gamma >= 0 && gamma > Math.PI) {
			f1 = gamma;
		} else {
			var a1 = gamma % (2 * Math.PI);
			if(a1 >= 0) {
				f1 = a1;
			} else {
				f1 = a1 + 2 * Math.PI;
			}
		}
		var this3 = f1;
		var zb = this3;
		var fa = beta;
		var fb = gamma;
		var theta = Math.abs(beta - gamma);
		var clockwise = beta < gamma;
		var dif1 = clockwise ? theta : -theta;
		if(dif1 > 0) {
			dif = dif1;
		} else {
			dif = 2 * Math.PI + dif1;
		}
		break;
	case 1:
		var f2;
		if(beta >= 0 && beta > Math.PI) {
			f2 = beta;
		} else {
			var a2 = beta % (2 * Math.PI);
			if(a2 >= 0) {
				f2 = a2;
			} else {
				f2 = a2 + 2 * Math.PI;
			}
		}
		var this4 = f2;
		var za1 = this4;
		var f3;
		if(gamma >= 0 && gamma > Math.PI) {
			f3 = gamma;
		} else {
			var a3 = gamma % (2 * Math.PI);
			if(a3 >= 0) {
				f3 = a3;
			} else {
				f3 = a3 + 2 * Math.PI;
			}
		}
		var this5 = f3;
		var zb1 = this5;
		var fa1 = beta;
		var fb1 = gamma;
		var theta1 = Math.abs(beta - gamma);
		var clockwise1 = beta < gamma;
		var dif2 = clockwise1 ? theta1 : -theta1;
		if(dif2 < 0) {
			dif = dif2;
		} else {
			dif = -2 * Math.PI + dif2;
		}
		break;
	case 2:
		var f4;
		if(beta >= 0 && beta > Math.PI) {
			f4 = beta;
		} else {
			var a4 = beta % (2 * Math.PI);
			if(a4 >= 0) {
				f4 = a4;
			} else {
				f4 = a4 + 2 * Math.PI;
			}
		}
		var this6 = f4;
		var za2 = this6;
		var f5;
		if(gamma >= 0 && gamma > Math.PI) {
			f5 = gamma;
		} else {
			var a5 = gamma % (2 * Math.PI);
			if(a5 >= 0) {
				f5 = a5;
			} else {
				f5 = a5 + 2 * Math.PI;
			}
		}
		var this7 = f5;
		var zb2 = this7;
		var fa2 = beta;
		var fb2 = gamma;
		var theta2 = Math.abs(beta - gamma);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = beta < gamma;
		var dif3 = clockwise2 ? theta2 : -theta2;
		if(smallest) {
			dif = dif3;
		} else if(clockwise2) {
			dif = -(2 * Math.PI - theta2);
		} else {
			dif = 2 * Math.PI - theta2;
		}
		break;
	case 3:
		var f6;
		if(beta >= 0 && beta > Math.PI) {
			f6 = beta;
		} else {
			var a6 = beta % (2 * Math.PI);
			if(a6 >= 0) {
				f6 = a6;
			} else {
				f6 = a6 + 2 * Math.PI;
			}
		}
		var this8 = f6;
		var za3 = this8;
		var f7;
		if(gamma >= 0 && gamma > Math.PI) {
			f7 = gamma;
		} else {
			var a7 = gamma % (2 * Math.PI);
			if(a7 >= 0) {
				f7 = a7;
			} else {
				f7 = a7 + 2 * Math.PI;
			}
		}
		var this9 = f7;
		var zb3 = this9;
		var fa3 = beta;
		var fb3 = gamma;
		var theta3 = Math.abs(beta - gamma);
		var largest = theta3 > Math.PI;
		var clockwise3 = beta < gamma;
		var dif4 = clockwise3 ? theta3 : -theta3;
		if(largest) {
			dif = dif4;
		} else if(clockwise3) {
			dif = -(2 * Math.PI - theta3);
		} else {
			dif = 2 * Math.PI - theta3;
		}
		break;
	}
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx;
	var cy;
	var bx = 0;
	var by = 0;
	var _g1 = 0;
	var _g = totalSteps + 1;
	while(_g1 < _g) {
		var i = _g1++;
		cx = ax + rx * Math.sin(angle);
		cy = ay + ry * Math.cos(angle);
		if(i != 0) {
			var t = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
			out[out.length] = t;
			if(mark != 0) {
				t.mark = mark;
			}
		}
		angle += step1;
		bx = cx;
		by = cy;
	}
	return out;
};
trilateral_polys_Poly.pieDif = function(ax,ay,radius,beta,dif,mark,sides) {
	if(sides == null) {
		sides = 36;
	}
	if(mark == null) {
		mark = 0;
	}
	var this1 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out = this1;
	var pi = Math.PI;
	var step = pi * 2 / sides;
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx;
	var cy;
	var bx = 0;
	var by = 0;
	var _g1 = 0;
	var _g = totalSteps + 1;
	while(_g1 < _g) {
		var i = _g1++;
		cx = ax + radius * Math.sin(angle);
		cy = ay + radius * Math.cos(angle);
		if(i != 0) {
			var t = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
			out[out.length] = t;
			if(mark != 0) {
				t.mark = mark;
			}
		}
		angle += step1;
		bx = cx;
		by = cy;
	}
	return out;
};
trilateral_polys_Poly.arc = function(ax,ay,radius,width,beta,gamma,prefer,mark,sides) {
	if(sides == null) {
		sides = 36;
	}
	if(mark == null) {
		mark = 0;
	}
	var this1 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out = this1;
	var pi = Math.PI;
	var step = pi * 2 / sides;
	var dif;
	switch(prefer[1]) {
	case 0:
		var f;
		if(beta >= 0 && beta > Math.PI) {
			f = beta;
		} else {
			var a = beta % (2 * Math.PI);
			if(a >= 0) {
				f = a;
			} else {
				f = a + 2 * Math.PI;
			}
		}
		var this2 = f;
		var za = this2;
		var f1;
		if(gamma >= 0 && gamma > Math.PI) {
			f1 = gamma;
		} else {
			var a1 = gamma % (2 * Math.PI);
			if(a1 >= 0) {
				f1 = a1;
			} else {
				f1 = a1 + 2 * Math.PI;
			}
		}
		var this3 = f1;
		var zb = this3;
		var fa = beta;
		var fb = gamma;
		var theta = Math.abs(beta - gamma);
		var clockwise = beta < gamma;
		var dif1 = clockwise ? theta : -theta;
		if(dif1 > 0) {
			dif = dif1;
		} else {
			dif = 2 * Math.PI + dif1;
		}
		break;
	case 1:
		var f2;
		if(beta >= 0 && beta > Math.PI) {
			f2 = beta;
		} else {
			var a2 = beta % (2 * Math.PI);
			if(a2 >= 0) {
				f2 = a2;
			} else {
				f2 = a2 + 2 * Math.PI;
			}
		}
		var this4 = f2;
		var za1 = this4;
		var f3;
		if(gamma >= 0 && gamma > Math.PI) {
			f3 = gamma;
		} else {
			var a3 = gamma % (2 * Math.PI);
			if(a3 >= 0) {
				f3 = a3;
			} else {
				f3 = a3 + 2 * Math.PI;
			}
		}
		var this5 = f3;
		var zb1 = this5;
		var fa1 = beta;
		var fb1 = gamma;
		var theta1 = Math.abs(beta - gamma);
		var clockwise1 = beta < gamma;
		var dif2 = clockwise1 ? theta1 : -theta1;
		if(dif2 < 0) {
			dif = dif2;
		} else {
			dif = -2 * Math.PI + dif2;
		}
		break;
	case 2:
		var f4;
		if(beta >= 0 && beta > Math.PI) {
			f4 = beta;
		} else {
			var a4 = beta % (2 * Math.PI);
			if(a4 >= 0) {
				f4 = a4;
			} else {
				f4 = a4 + 2 * Math.PI;
			}
		}
		var this6 = f4;
		var za2 = this6;
		var f5;
		if(gamma >= 0 && gamma > Math.PI) {
			f5 = gamma;
		} else {
			var a5 = gamma % (2 * Math.PI);
			if(a5 >= 0) {
				f5 = a5;
			} else {
				f5 = a5 + 2 * Math.PI;
			}
		}
		var this7 = f5;
		var zb2 = this7;
		var fa2 = beta;
		var fb2 = gamma;
		var theta2 = Math.abs(beta - gamma);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = beta < gamma;
		var dif3 = clockwise2 ? theta2 : -theta2;
		if(smallest) {
			dif = dif3;
		} else if(clockwise2) {
			dif = -(2 * Math.PI - theta2);
		} else {
			dif = 2 * Math.PI - theta2;
		}
		break;
	case 3:
		var f6;
		if(beta >= 0 && beta > Math.PI) {
			f6 = beta;
		} else {
			var a6 = beta % (2 * Math.PI);
			if(a6 >= 0) {
				f6 = a6;
			} else {
				f6 = a6 + 2 * Math.PI;
			}
		}
		var this8 = f6;
		var za3 = this8;
		var f7;
		if(gamma >= 0 && gamma > Math.PI) {
			f7 = gamma;
		} else {
			var a7 = gamma % (2 * Math.PI);
			if(a7 >= 0) {
				f7 = a7;
			} else {
				f7 = a7 + 2 * Math.PI;
			}
		}
		var this9 = f7;
		var zb3 = this9;
		var fa3 = beta;
		var fb3 = gamma;
		var theta3 = Math.abs(beta - gamma);
		var largest = theta3 > Math.PI;
		var clockwise3 = beta < gamma;
		var dif4 = clockwise3 ? theta3 : -theta3;
		if(largest) {
			dif = dif4;
		} else if(clockwise3) {
			dif = -(2 * Math.PI - theta3);
		} else {
			dif = 2 * Math.PI - theta3;
		}
		break;
	}
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx;
	var cy;
	var bx = 0;
	var by = 0;
	var dx = 0;
	var dy = 0;
	var ex = 0;
	var ey = 0;
	var r2 = radius - width;
	var _g1 = 0;
	var _g = totalSteps + 1;
	while(_g1 < _g) {
		var i = _g1++;
		cx = ax + radius * Math.sin(angle);
		cy = ay + radius * Math.cos(angle);
		ex = ax + r2 * Math.sin(angle);
		ey = ay + r2 * Math.cos(angle);
		if(i != 0) {
			var t0 = new trilateral_tri_Trilateral(dx,dy,bx,by,cx,cy);
			var t1 = new trilateral_tri_Trilateral(dx,dy,cx,cy,ex,ey);
			out[out.length] = t0;
			out[out.length] = t1;
			if(mark != 0) {
				t0.mark = mark;
				t1.mark = mark;
			}
		}
		angle += step1;
		bx = cx;
		by = cy;
		dx = ex;
		dy = ey;
	}
	return out;
};
trilateral_polys_Poly.circleMarked = function(ax,ay,radius,mark,sides,omega) {
	if(omega == null) {
		omega = 0.;
	}
	if(sides == null) {
		sides = 36;
	}
	var this1 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out = this1;
	var pi = Math.PI;
	var theta = pi / 2 + omega;
	var step = pi * 2 / sides;
	var bx;
	var by;
	var cx;
	var cy;
	var _g1 = 0;
	var _g = sides;
	while(_g1 < _g) {
		var i = _g1++;
		bx = ax + radius * Math.sin(theta);
		by = ay + radius * Math.cos(theta);
		theta += step;
		cx = ax + radius * Math.sin(theta);
		cy = ay + radius * Math.cos(theta);
		var t = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
		out[out.length] = t;
		t.mark = mark;
	}
	return out;
};
trilateral_polys_Poly.circleOnSide = function(ax,ay,radius,sides,omega) {
	if(omega == null) {
		omega = 0.;
	}
	if(sides == null) {
		sides = 36;
	}
	var this1 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out = this1;
	var pi = Math.PI;
	var theta = pi / 2;
	var step = pi * 2 / sides;
	theta -= step / 2 + omega;
	var bx;
	var by;
	var cx;
	var cy;
	var _g1 = 0;
	var _g = sides;
	while(_g1 < _g) {
		var i = _g1++;
		bx = ax + radius * Math.sin(theta);
		by = ay + radius * Math.cos(theta);
		theta += step;
		cx = ax + radius * Math.sin(theta);
		cy = ay + radius * Math.cos(theta);
		var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
		out[out.length] = tri;
	}
	return out;
};
trilateral_polys_Poly.ellipseOnSide = function(ax,ay,rx,ry,sides) {
	if(sides == null) {
		sides = 36;
	}
	var this1 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out = this1;
	var pi = Math.PI;
	var theta = pi / 2;
	var step = pi * 2 / sides;
	theta -= step / 2;
	var bx;
	var by;
	var cx;
	var cy;
	var _g1 = 0;
	var _g = sides;
	while(_g1 < _g) {
		var i = _g1++;
		bx = ax + rx * Math.sin(theta);
		by = ay + rx * Math.cos(theta);
		theta += step;
		cx = ax + rx * Math.sin(theta);
		cy = ay + ry * Math.cos(theta);
		var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,cx,cy);
		out[out.length] = tri;
	}
	return out;
};
trilateral_polys_Poly.shape = function(x,y,radius,p,omega) {
	if(omega == null) {
		omega = 0.;
	}
	if((p & 1) == 0) {
		var this1 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out = this1;
		var pi = Math.PI;
		var theta = pi / 2;
		var step = pi * 2 / p;
		theta -= step / 2 + omega;
		var bx;
		var by;
		var cx;
		var cy;
		var _g1 = 0;
		var _g = p;
		while(_g1 < _g) {
			var i = _g1++;
			bx = x + radius * Math.sin(theta);
			by = y + radius * Math.cos(theta);
			theta += step;
			cx = x + radius * Math.sin(theta);
			cy = y + radius * Math.cos(theta);
			var tri = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
			out[out.length] = tri;
		}
		return out;
	} else {
		var this2 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out1 = this2;
		var pi1 = Math.PI;
		var theta1 = pi1 / 2 + omega;
		var step1 = pi1 * 2 / p;
		var bx1;
		var by1;
		var cx1;
		var cy1;
		var _g11 = 0;
		var _g2 = p;
		while(_g11 < _g2) {
			var i1 = _g11++;
			bx1 = x + radius * Math.sin(theta1);
			by1 = y + radius * Math.cos(theta1);
			theta1 += step1;
			cx1 = x + radius * Math.sin(theta1);
			cy1 = y + radius * Math.cos(theta1);
			var tri1 = new trilateral_tri_Trilateral(x,y,bx1,by1,cx1,cy1);
			out1[out1.length] = tri1;
		}
		return out1;
	}
};
trilateral_polys_Poly.roundedRectangle = function(x,y,width,height,radius) {
	var this1 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out = this1;
	var pi = Math.PI;
	var pi_2 = Math.PI / 2;
	var ax = x + radius;
	var ay = y + radius;
	var bx = x + width - radius;
	var by = y + radius;
	var cx = bx;
	var cy = y + height - radius;
	var dx = ax;
	var dy = cy;
	var tp_t1;
	var tp_t0;
	var ax1 = ax;
	var ay1 = y;
	var bx1 = ax + (width - radius * 2);
	var by1 = ay1;
	var cx1 = bx1;
	var cy1 = ay1 + height;
	var dx1 = ax;
	var dy1 = cy1;
	tp_t0 = new trilateral_tri_Trilateral(ax1,ay1,bx1,by1,dx1,dy1);
	tp_t1 = new trilateral_tri_Trilateral(bx1,by1,cx1,cy1,dx1,dy1);
	out[out.length] = tp_t0;
	out[out.length] = tp_t1;
	var dimY = height - 2 * radius;
	var tp_t11;
	var tp_t01;
	var ax2 = x;
	var ay2 = ay;
	var bx2 = x + radius;
	var by2 = ay2;
	var cx2 = bx2;
	var cy2 = ay2 + dimY;
	var dx2 = x;
	var dy2 = cy2;
	tp_t01 = new trilateral_tri_Trilateral(ax2,ay2,bx2,by2,dx2,dy2);
	tp_t11 = new trilateral_tri_Trilateral(bx2,by2,cx2,cy2,dx2,dy2);
	out[out.length] = tp_t01;
	out[out.length] = tp_t11;
	var tp_t12;
	var tp_t02;
	var ax3 = bx;
	var ay3 = by;
	var bx3 = bx + radius;
	var by3 = ay3;
	var cx3 = bx3;
	var cy3 = ay3 + dimY;
	var dx3 = bx;
	var dy3 = cy3;
	tp_t02 = new trilateral_tri_Trilateral(ax3,ay3,bx3,by3,dx3,dy3);
	tp_t12 = new trilateral_tri_Trilateral(bx3,by3,cx3,cy3,dx3,dy3);
	out[out.length] = tp_t02;
	out[out.length] = tp_t12;
	var beta = -pi;
	var gamma = -pi_2;
	var this2 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out1 = this2;
	var pi1 = Math.PI;
	var step = pi1 * 2 / 36;
	var dif;
	switch(trilateral_angle_DifferencePreference.CLOCKWISE[1]) {
	case 0:
		var f;
		if(beta >= 0 && beta > Math.PI) {
			f = beta;
		} else {
			var a = beta % (2 * Math.PI);
			if(a >= 0) {
				f = a;
			} else {
				f = a + 2 * Math.PI;
			}
		}
		var this3 = f;
		var za = this3;
		var f1;
		if(gamma >= 0 && gamma > Math.PI) {
			f1 = gamma;
		} else {
			var a1 = gamma % (2 * Math.PI);
			if(a1 >= 0) {
				f1 = a1;
			} else {
				f1 = a1 + 2 * Math.PI;
			}
		}
		var this4 = f1;
		var zb = this4;
		var fa = beta;
		var fb = gamma;
		var theta = Math.abs(beta - gamma);
		var clockwise = beta < gamma;
		var dif1 = clockwise ? theta : -theta;
		if(dif1 > 0) {
			dif = dif1;
		} else {
			dif = 2 * Math.PI + dif1;
		}
		break;
	case 1:
		var f2;
		if(beta >= 0 && beta > Math.PI) {
			f2 = beta;
		} else {
			var a2 = beta % (2 * Math.PI);
			if(a2 >= 0) {
				f2 = a2;
			} else {
				f2 = a2 + 2 * Math.PI;
			}
		}
		var this5 = f2;
		var za1 = this5;
		var f3;
		if(gamma >= 0 && gamma > Math.PI) {
			f3 = gamma;
		} else {
			var a3 = gamma % (2 * Math.PI);
			if(a3 >= 0) {
				f3 = a3;
			} else {
				f3 = a3 + 2 * Math.PI;
			}
		}
		var this6 = f3;
		var zb1 = this6;
		var fa1 = beta;
		var fb1 = gamma;
		var theta1 = Math.abs(beta - gamma);
		var clockwise1 = beta < gamma;
		var dif2 = clockwise1 ? theta1 : -theta1;
		if(dif2 < 0) {
			dif = dif2;
		} else {
			dif = -2 * Math.PI + dif2;
		}
		break;
	case 2:
		var f4;
		if(beta >= 0 && beta > Math.PI) {
			f4 = beta;
		} else {
			var a4 = beta % (2 * Math.PI);
			if(a4 >= 0) {
				f4 = a4;
			} else {
				f4 = a4 + 2 * Math.PI;
			}
		}
		var this7 = f4;
		var za2 = this7;
		var f5;
		if(gamma >= 0 && gamma > Math.PI) {
			f5 = gamma;
		} else {
			var a5 = gamma % (2 * Math.PI);
			if(a5 >= 0) {
				f5 = a5;
			} else {
				f5 = a5 + 2 * Math.PI;
			}
		}
		var this8 = f5;
		var zb2 = this8;
		var fa2 = beta;
		var fb2 = gamma;
		var theta2 = Math.abs(beta - gamma);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = beta < gamma;
		var dif3 = clockwise2 ? theta2 : -theta2;
		if(smallest) {
			dif = dif3;
		} else if(clockwise2) {
			dif = -(2 * Math.PI - theta2);
		} else {
			dif = 2 * Math.PI - theta2;
		}
		break;
	case 3:
		var f6;
		if(beta >= 0 && beta > Math.PI) {
			f6 = beta;
		} else {
			var a6 = beta % (2 * Math.PI);
			if(a6 >= 0) {
				f6 = a6;
			} else {
				f6 = a6 + 2 * Math.PI;
			}
		}
		var this9 = f6;
		var za3 = this9;
		var f7;
		if(gamma >= 0 && gamma > Math.PI) {
			f7 = gamma;
		} else {
			var a7 = gamma % (2 * Math.PI);
			if(a7 >= 0) {
				f7 = a7;
			} else {
				f7 = a7 + 2 * Math.PI;
			}
		}
		var this10 = f7;
		var zb3 = this10;
		var fa3 = beta;
		var fb3 = gamma;
		var theta3 = Math.abs(beta - gamma);
		var largest = theta3 > Math.PI;
		var clockwise3 = beta < gamma;
		var dif4 = clockwise3 ? theta3 : -theta3;
		if(largest) {
			dif = dif4;
		} else if(clockwise3) {
			dif = -(2 * Math.PI - theta3);
		} else {
			dif = 2 * Math.PI - theta3;
		}
		break;
	}
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx4;
	var cy4;
	var bx4 = 0;
	var by4 = 0;
	var _g1 = 0;
	var _g = totalSteps + 1;
	while(_g1 < _g) {
		var i = _g1++;
		cx4 = ax + radius * Math.sin(angle);
		cy4 = ay + radius * Math.cos(angle);
		if(i != 0) {
			var t = new trilateral_tri_Trilateral(ax,ay,bx4,by4,cx4,cy4);
			out1[out1.length] = t;
		}
		angle += step1;
		bx4 = cx4;
		by4 = cy4;
	}
	var triArr = out1;
	var _g2 = 0;
	while(_g2 < triArr.length) {
		var t1 = triArr[_g2];
		++_g2;
		out[out.length] = t1;
	}
	var this11 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out2 = this11;
	var pi2 = Math.PI;
	var step2 = pi2 * 2 / 36;
	var dif5;
	switch(trilateral_angle_DifferencePreference.CLOCKWISE[1]) {
	case 0:
		var f8;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f8 = pi_2;
		} else {
			var a8 = pi_2 % (2 * Math.PI);
			if(a8 >= 0) {
				f8 = a8;
			} else {
				f8 = a8 + 2 * Math.PI;
			}
		}
		var this12 = f8;
		var za4 = this12;
		var f9;
		if(pi >= 0 && pi > Math.PI) {
			f9 = pi;
		} else {
			var a9 = pi % (2 * Math.PI);
			if(a9 >= 0) {
				f9 = a9;
			} else {
				f9 = a9 + 2 * Math.PI;
			}
		}
		var this13 = f9;
		var zb4 = this13;
		var fa4 = pi_2;
		var fb4 = pi;
		var theta4 = Math.abs(pi_2 - pi);
		var clockwise4 = pi_2 < pi;
		var dif6 = clockwise4 ? theta4 : -theta4;
		if(dif6 > 0) {
			dif5 = dif6;
		} else {
			dif5 = 2 * Math.PI + dif6;
		}
		break;
	case 1:
		var f10;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f10 = pi_2;
		} else {
			var a10 = pi_2 % (2 * Math.PI);
			if(a10 >= 0) {
				f10 = a10;
			} else {
				f10 = a10 + 2 * Math.PI;
			}
		}
		var this14 = f10;
		var za5 = this14;
		var f11;
		if(pi >= 0 && pi > Math.PI) {
			f11 = pi;
		} else {
			var a11 = pi % (2 * Math.PI);
			if(a11 >= 0) {
				f11 = a11;
			} else {
				f11 = a11 + 2 * Math.PI;
			}
		}
		var this15 = f11;
		var zb5 = this15;
		var fa5 = pi_2;
		var fb5 = pi;
		var theta5 = Math.abs(pi_2 - pi);
		var clockwise5 = pi_2 < pi;
		var dif7 = clockwise5 ? theta5 : -theta5;
		if(dif7 < 0) {
			dif5 = dif7;
		} else {
			dif5 = -2 * Math.PI + dif7;
		}
		break;
	case 2:
		var f12;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f12 = pi_2;
		} else {
			var a12 = pi_2 % (2 * Math.PI);
			if(a12 >= 0) {
				f12 = a12;
			} else {
				f12 = a12 + 2 * Math.PI;
			}
		}
		var this16 = f12;
		var za6 = this16;
		var f13;
		if(pi >= 0 && pi > Math.PI) {
			f13 = pi;
		} else {
			var a13 = pi % (2 * Math.PI);
			if(a13 >= 0) {
				f13 = a13;
			} else {
				f13 = a13 + 2 * Math.PI;
			}
		}
		var this17 = f13;
		var zb6 = this17;
		var fa6 = pi_2;
		var fb6 = pi;
		var theta6 = Math.abs(pi_2 - pi);
		var smallest1 = theta6 <= Math.PI;
		var clockwise6 = pi_2 < pi;
		var dif8 = clockwise6 ? theta6 : -theta6;
		if(smallest1) {
			dif5 = dif8;
		} else if(clockwise6) {
			dif5 = -(2 * Math.PI - theta6);
		} else {
			dif5 = 2 * Math.PI - theta6;
		}
		break;
	case 3:
		var f14;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f14 = pi_2;
		} else {
			var a14 = pi_2 % (2 * Math.PI);
			if(a14 >= 0) {
				f14 = a14;
			} else {
				f14 = a14 + 2 * Math.PI;
			}
		}
		var this18 = f14;
		var za7 = this18;
		var f15;
		if(pi >= 0 && pi > Math.PI) {
			f15 = pi;
		} else {
			var a15 = pi % (2 * Math.PI);
			if(a15 >= 0) {
				f15 = a15;
			} else {
				f15 = a15 + 2 * Math.PI;
			}
		}
		var this19 = f15;
		var zb7 = this19;
		var fa7 = pi_2;
		var fb7 = pi;
		var theta7 = Math.abs(pi_2 - pi);
		var largest1 = theta7 > Math.PI;
		var clockwise7 = pi_2 < pi;
		var dif9 = clockwise7 ? theta7 : -theta7;
		if(largest1) {
			dif5 = dif9;
		} else if(clockwise7) {
			dif5 = -(2 * Math.PI - theta7);
		} else {
			dif5 = 2 * Math.PI - theta7;
		}
		break;
	}
	var positive1 = dif5 >= 0;
	var totalSteps1 = Math.ceil(Math.abs(dif5) / step2);
	var step3 = dif5 / totalSteps1;
	var angle1 = pi_2;
	var cx5;
	var cy5;
	var bx5 = 0;
	var by5 = 0;
	var _g11 = 0;
	var _g3 = totalSteps1 + 1;
	while(_g11 < _g3) {
		var i1 = _g11++;
		cx5 = bx + radius * Math.sin(angle1);
		cy5 = by + radius * Math.cos(angle1);
		if(i1 != 0) {
			var t2 = new trilateral_tri_Trilateral(bx,by,bx5,by5,cx5,cy5);
			out2[out2.length] = t2;
		}
		angle1 += step3;
		bx5 = cx5;
		by5 = cy5;
	}
	var triArr1 = out2;
	var _g4 = 0;
	while(_g4 < triArr1.length) {
		var t3 = triArr1[_g4];
		++_g4;
		out[out.length] = t3;
	}
	var this20 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out3 = this20;
	var pi3 = Math.PI;
	var step4 = pi3 * 2 / 36;
	var dif10;
	switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE[1]) {
	case 0:
		var f16;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f16 = pi_2;
		} else {
			var a16 = pi_2 % (2 * Math.PI);
			if(a16 >= 0) {
				f16 = a16;
			} else {
				f16 = a16 + 2 * Math.PI;
			}
		}
		var this21 = f16;
		var za8 = this21;
		var f17;
		if(0 > Math.PI) {
			f17 = 0;
		} else {
			var a17 = 0 % (2 * Math.PI);
			if(a17 >= 0) {
				f17 = a17;
			} else {
				f17 = a17 + 2 * Math.PI;
			}
		}
		var this22 = f17;
		var zb8 = this22;
		var fa8 = pi_2;
		var fb8 = 0;
		var theta8 = Math.abs(pi_2);
		var clockwise8 = pi_2 < 0;
		var dif11 = clockwise8 ? theta8 : -theta8;
		if(dif11 > 0) {
			dif10 = dif11;
		} else {
			dif10 = 2 * Math.PI + dif11;
		}
		break;
	case 1:
		var f18;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f18 = pi_2;
		} else {
			var a18 = pi_2 % (2 * Math.PI);
			if(a18 >= 0) {
				f18 = a18;
			} else {
				f18 = a18 + 2 * Math.PI;
			}
		}
		var this23 = f18;
		var za9 = this23;
		var f19;
		if(0 > Math.PI) {
			f19 = 0;
		} else {
			var a19 = 0 % (2 * Math.PI);
			if(a19 >= 0) {
				f19 = a19;
			} else {
				f19 = a19 + 2 * Math.PI;
			}
		}
		var this24 = f19;
		var zb9 = this24;
		var fa9 = pi_2;
		var fb9 = 0;
		var theta9 = Math.abs(pi_2);
		var clockwise9 = pi_2 < 0;
		var dif12 = clockwise9 ? theta9 : -theta9;
		if(dif12 < 0) {
			dif10 = dif12;
		} else {
			dif10 = -2 * Math.PI + dif12;
		}
		break;
	case 2:
		var f20;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f20 = pi_2;
		} else {
			var a20 = pi_2 % (2 * Math.PI);
			if(a20 >= 0) {
				f20 = a20;
			} else {
				f20 = a20 + 2 * Math.PI;
			}
		}
		var this25 = f20;
		var za10 = this25;
		var f21;
		if(0 > Math.PI) {
			f21 = 0;
		} else {
			var a21 = 0 % (2 * Math.PI);
			if(a21 >= 0) {
				f21 = a21;
			} else {
				f21 = a21 + 2 * Math.PI;
			}
		}
		var this26 = f21;
		var zb10 = this26;
		var fa10 = pi_2;
		var fb10 = 0;
		var theta10 = Math.abs(pi_2);
		var smallest2 = theta10 <= Math.PI;
		var clockwise10 = pi_2 < 0;
		var dif13 = clockwise10 ? theta10 : -theta10;
		if(smallest2) {
			dif10 = dif13;
		} else if(clockwise10) {
			dif10 = -(2 * Math.PI - theta10);
		} else {
			dif10 = 2 * Math.PI - theta10;
		}
		break;
	case 3:
		var f22;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f22 = pi_2;
		} else {
			var a22 = pi_2 % (2 * Math.PI);
			if(a22 >= 0) {
				f22 = a22;
			} else {
				f22 = a22 + 2 * Math.PI;
			}
		}
		var this27 = f22;
		var za11 = this27;
		var f23;
		if(0 > Math.PI) {
			f23 = 0;
		} else {
			var a23 = 0 % (2 * Math.PI);
			if(a23 >= 0) {
				f23 = a23;
			} else {
				f23 = a23 + 2 * Math.PI;
			}
		}
		var this28 = f23;
		var zb11 = this28;
		var fa11 = pi_2;
		var fb11 = 0;
		var theta11 = Math.abs(pi_2);
		var largest2 = theta11 > Math.PI;
		var clockwise11 = pi_2 < 0;
		var dif14 = clockwise11 ? theta11 : -theta11;
		if(largest2) {
			dif10 = dif14;
		} else if(clockwise11) {
			dif10 = -(2 * Math.PI - theta11);
		} else {
			dif10 = 2 * Math.PI - theta11;
		}
		break;
	}
	var positive2 = dif10 >= 0;
	var totalSteps2 = Math.ceil(Math.abs(dif10) / step4);
	var step5 = dif10 / totalSteps2;
	var angle2 = pi_2;
	var cx6;
	var cy6;
	var bx6 = 0;
	var by6 = 0;
	var _g12 = 0;
	var _g5 = totalSteps2 + 1;
	while(_g12 < _g5) {
		var i2 = _g12++;
		cx6 = cx + radius * Math.sin(angle2);
		cy6 = cy + radius * Math.cos(angle2);
		if(i2 != 0) {
			var t4 = new trilateral_tri_Trilateral(cx,cy,bx6,by6,cx6,cy6);
			out3[out3.length] = t4;
		}
		angle2 += step5;
		bx6 = cx6;
		by6 = cy6;
	}
	var triArr2 = out3;
	var _g6 = 0;
	while(_g6 < triArr2.length) {
		var t5 = triArr2[_g6];
		++_g6;
		out[out.length] = t5;
	}
	var gamma1 = -pi_2;
	var this29 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out4 = this29;
	var pi4 = Math.PI;
	var step6 = pi4 * 2 / 36;
	var dif15;
	switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE[1]) {
	case 0:
		var f24;
		if(0 > Math.PI) {
			f24 = 0;
		} else {
			var a24 = 0 % (2 * Math.PI);
			if(a24 >= 0) {
				f24 = a24;
			} else {
				f24 = a24 + 2 * Math.PI;
			}
		}
		var this30 = f24;
		var za12 = this30;
		var f25;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f25 = gamma1;
		} else {
			var a25 = gamma1 % (2 * Math.PI);
			if(a25 >= 0) {
				f25 = a25;
			} else {
				f25 = a25 + 2 * Math.PI;
			}
		}
		var this31 = f25;
		var zb12 = this31;
		var fa12 = 0;
		var fb12 = gamma1;
		var theta12 = Math.abs(0 - gamma1);
		var clockwise12 = 0 < gamma1;
		var dif16 = clockwise12 ? theta12 : -theta12;
		if(dif16 > 0) {
			dif15 = dif16;
		} else {
			dif15 = 2 * Math.PI + dif16;
		}
		break;
	case 1:
		var f26;
		if(0 > Math.PI) {
			f26 = 0;
		} else {
			var a26 = 0 % (2 * Math.PI);
			if(a26 >= 0) {
				f26 = a26;
			} else {
				f26 = a26 + 2 * Math.PI;
			}
		}
		var this32 = f26;
		var za13 = this32;
		var f27;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f27 = gamma1;
		} else {
			var a27 = gamma1 % (2 * Math.PI);
			if(a27 >= 0) {
				f27 = a27;
			} else {
				f27 = a27 + 2 * Math.PI;
			}
		}
		var this33 = f27;
		var zb13 = this33;
		var fa13 = 0;
		var fb13 = gamma1;
		var theta13 = Math.abs(0 - gamma1);
		var clockwise13 = 0 < gamma1;
		var dif17 = clockwise13 ? theta13 : -theta13;
		if(dif17 < 0) {
			dif15 = dif17;
		} else {
			dif15 = -2 * Math.PI + dif17;
		}
		break;
	case 2:
		var f28;
		if(0 > Math.PI) {
			f28 = 0;
		} else {
			var a28 = 0 % (2 * Math.PI);
			if(a28 >= 0) {
				f28 = a28;
			} else {
				f28 = a28 + 2 * Math.PI;
			}
		}
		var this34 = f28;
		var za14 = this34;
		var f29;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f29 = gamma1;
		} else {
			var a29 = gamma1 % (2 * Math.PI);
			if(a29 >= 0) {
				f29 = a29;
			} else {
				f29 = a29 + 2 * Math.PI;
			}
		}
		var this35 = f29;
		var zb14 = this35;
		var fa14 = 0;
		var fb14 = gamma1;
		var theta14 = Math.abs(0 - gamma1);
		var smallest3 = theta14 <= Math.PI;
		var clockwise14 = 0 < gamma1;
		var dif18 = clockwise14 ? theta14 : -theta14;
		if(smallest3) {
			dif15 = dif18;
		} else if(clockwise14) {
			dif15 = -(2 * Math.PI - theta14);
		} else {
			dif15 = 2 * Math.PI - theta14;
		}
		break;
	case 3:
		var f30;
		if(0 > Math.PI) {
			f30 = 0;
		} else {
			var a30 = 0 % (2 * Math.PI);
			if(a30 >= 0) {
				f30 = a30;
			} else {
				f30 = a30 + 2 * Math.PI;
			}
		}
		var this36 = f30;
		var za15 = this36;
		var f31;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f31 = gamma1;
		} else {
			var a31 = gamma1 % (2 * Math.PI);
			if(a31 >= 0) {
				f31 = a31;
			} else {
				f31 = a31 + 2 * Math.PI;
			}
		}
		var this37 = f31;
		var zb15 = this37;
		var fa15 = 0;
		var fb15 = gamma1;
		var theta15 = Math.abs(0 - gamma1);
		var largest3 = theta15 > Math.PI;
		var clockwise15 = 0 < gamma1;
		var dif19 = clockwise15 ? theta15 : -theta15;
		if(largest3) {
			dif15 = dif19;
		} else if(clockwise15) {
			dif15 = -(2 * Math.PI - theta15);
		} else {
			dif15 = 2 * Math.PI - theta15;
		}
		break;
	}
	var positive3 = dif15 >= 0;
	var totalSteps3 = Math.ceil(Math.abs(dif15) / step6);
	var step7 = dif15 / totalSteps3;
	var angle3 = 0;
	var cx7;
	var cy7;
	var bx7 = 0;
	var by7 = 0;
	var _g13 = 0;
	var _g7 = totalSteps3 + 1;
	while(_g13 < _g7) {
		var i3 = _g13++;
		cx7 = dx + radius * Math.sin(angle3);
		cy7 = dy + radius * Math.cos(angle3);
		if(i3 != 0) {
			var t6 = new trilateral_tri_Trilateral(dx,dy,bx7,by7,cx7,cy7);
			out4[out4.length] = t6;
		}
		angle3 += step7;
		bx7 = cx7;
		by7 = cy7;
	}
	var triArr3 = out4;
	var _g8 = 0;
	while(_g8 < triArr3.length) {
		var t7 = triArr3[_g8];
		++_g8;
		out[out.length] = t7;
	}
	return out;
};
trilateral_polys_Poly.roundedRectangleOutline = function(x,y,width,height,thick,radius) {
	var this1 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out = this1;
	var pi = Math.PI;
	var pi_2 = Math.PI / 2;
	var ax = x + radius;
	var ay = y + radius;
	var bx = x + width - radius;
	var by = y + radius;
	var cx = bx;
	var cy = y + height - radius;
	var dx = ax;
	var dy = cy;
	var tp_t1;
	var tp_t0;
	var ax1 = ax;
	var ay1 = y;
	var bx1 = ax + (width - radius * 2);
	var by1 = ay1;
	var cx1 = bx1;
	var cy1 = ay1 + thick;
	var dx1 = ax;
	var dy1 = cy1;
	tp_t0 = new trilateral_tri_Trilateral(ax1,ay1,bx1,by1,dx1,dy1);
	tp_t1 = new trilateral_tri_Trilateral(bx1,by1,cx1,cy1,dx1,dy1);
	out[out.length] = tp_t0;
	out[out.length] = tp_t1;
	var tp_t11;
	var tp_t01;
	var ax2 = ax;
	var ay2 = y + height - thick;
	var bx2 = ax + (width - radius * 2);
	var by2 = ay2;
	var cx2 = bx2;
	var cy2 = ay2 + thick;
	var dx2 = ax;
	var dy2 = cy2;
	tp_t01 = new trilateral_tri_Trilateral(ax2,ay2,bx2,by2,dx2,dy2);
	tp_t11 = new trilateral_tri_Trilateral(bx2,by2,cx2,cy2,dx2,dy2);
	out[out.length] = tp_t01;
	out[out.length] = tp_t11;
	var dimY = height - 2 * radius;
	var tp_t12;
	var tp_t02;
	var ax3 = x;
	var ay3 = ay;
	var bx3 = x + thick;
	var by3 = ay3;
	var cx3 = bx3;
	var cy3 = ay3 + dimY;
	var dx3 = x;
	var dy3 = cy3;
	tp_t02 = new trilateral_tri_Trilateral(ax3,ay3,bx3,by3,dx3,dy3);
	tp_t12 = new trilateral_tri_Trilateral(bx3,by3,cx3,cy3,dx3,dy3);
	out[out.length] = tp_t02;
	out[out.length] = tp_t12;
	var tp_t13;
	var tp_t03;
	var x1 = x + width - thick;
	var ax4 = x1;
	var ay4 = by;
	var bx4 = x1 + thick;
	var by4 = ay4;
	var cx4 = bx4;
	var cy4 = ay4 + dimY;
	var dx4 = x1;
	var dy4 = cy4;
	tp_t03 = new trilateral_tri_Trilateral(ax4,ay4,bx4,by4,dx4,dy4);
	tp_t13 = new trilateral_tri_Trilateral(bx4,by4,cx4,cy4,dx4,dy4);
	out[out.length] = tp_t03;
	out[out.length] = tp_t13;
	var beta = -pi;
	var gamma = -pi_2;
	var this2 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out1 = this2;
	var pi1 = Math.PI;
	var step = pi1 * 2 / 36;
	var dif;
	switch(trilateral_angle_DifferencePreference.CLOCKWISE[1]) {
	case 0:
		var f;
		if(beta >= 0 && beta > Math.PI) {
			f = beta;
		} else {
			var a = beta % (2 * Math.PI);
			if(a >= 0) {
				f = a;
			} else {
				f = a + 2 * Math.PI;
			}
		}
		var this3 = f;
		var za = this3;
		var f1;
		if(gamma >= 0 && gamma > Math.PI) {
			f1 = gamma;
		} else {
			var a1 = gamma % (2 * Math.PI);
			if(a1 >= 0) {
				f1 = a1;
			} else {
				f1 = a1 + 2 * Math.PI;
			}
		}
		var this4 = f1;
		var zb = this4;
		var fa = beta;
		var fb = gamma;
		var theta = Math.abs(beta - gamma);
		var clockwise = beta < gamma;
		var dif1 = clockwise ? theta : -theta;
		if(dif1 > 0) {
			dif = dif1;
		} else {
			dif = 2 * Math.PI + dif1;
		}
		break;
	case 1:
		var f2;
		if(beta >= 0 && beta > Math.PI) {
			f2 = beta;
		} else {
			var a2 = beta % (2 * Math.PI);
			if(a2 >= 0) {
				f2 = a2;
			} else {
				f2 = a2 + 2 * Math.PI;
			}
		}
		var this5 = f2;
		var za1 = this5;
		var f3;
		if(gamma >= 0 && gamma > Math.PI) {
			f3 = gamma;
		} else {
			var a3 = gamma % (2 * Math.PI);
			if(a3 >= 0) {
				f3 = a3;
			} else {
				f3 = a3 + 2 * Math.PI;
			}
		}
		var this6 = f3;
		var zb1 = this6;
		var fa1 = beta;
		var fb1 = gamma;
		var theta1 = Math.abs(beta - gamma);
		var clockwise1 = beta < gamma;
		var dif2 = clockwise1 ? theta1 : -theta1;
		if(dif2 < 0) {
			dif = dif2;
		} else {
			dif = -2 * Math.PI + dif2;
		}
		break;
	case 2:
		var f4;
		if(beta >= 0 && beta > Math.PI) {
			f4 = beta;
		} else {
			var a4 = beta % (2 * Math.PI);
			if(a4 >= 0) {
				f4 = a4;
			} else {
				f4 = a4 + 2 * Math.PI;
			}
		}
		var this7 = f4;
		var za2 = this7;
		var f5;
		if(gamma >= 0 && gamma > Math.PI) {
			f5 = gamma;
		} else {
			var a5 = gamma % (2 * Math.PI);
			if(a5 >= 0) {
				f5 = a5;
			} else {
				f5 = a5 + 2 * Math.PI;
			}
		}
		var this8 = f5;
		var zb2 = this8;
		var fa2 = beta;
		var fb2 = gamma;
		var theta2 = Math.abs(beta - gamma);
		var smallest = theta2 <= Math.PI;
		var clockwise2 = beta < gamma;
		var dif3 = clockwise2 ? theta2 : -theta2;
		if(smallest) {
			dif = dif3;
		} else if(clockwise2) {
			dif = -(2 * Math.PI - theta2);
		} else {
			dif = 2 * Math.PI - theta2;
		}
		break;
	case 3:
		var f6;
		if(beta >= 0 && beta > Math.PI) {
			f6 = beta;
		} else {
			var a6 = beta % (2 * Math.PI);
			if(a6 >= 0) {
				f6 = a6;
			} else {
				f6 = a6 + 2 * Math.PI;
			}
		}
		var this9 = f6;
		var za3 = this9;
		var f7;
		if(gamma >= 0 && gamma > Math.PI) {
			f7 = gamma;
		} else {
			var a7 = gamma % (2 * Math.PI);
			if(a7 >= 0) {
				f7 = a7;
			} else {
				f7 = a7 + 2 * Math.PI;
			}
		}
		var this10 = f7;
		var zb3 = this10;
		var fa3 = beta;
		var fb3 = gamma;
		var theta3 = Math.abs(beta - gamma);
		var largest = theta3 > Math.PI;
		var clockwise3 = beta < gamma;
		var dif4 = clockwise3 ? theta3 : -theta3;
		if(largest) {
			dif = dif4;
		} else if(clockwise3) {
			dif = -(2 * Math.PI - theta3);
		} else {
			dif = 2 * Math.PI - theta3;
		}
		break;
	}
	var positive = dif >= 0;
	var totalSteps = Math.ceil(Math.abs(dif) / step);
	var step1 = dif / totalSteps;
	var angle = beta;
	var cx5;
	var cy5;
	var bx5 = 0;
	var by5 = 0;
	var dx5 = 0;
	var dy5 = 0;
	var ex = 0;
	var ey = 0;
	var r2 = radius - thick;
	var _g1 = 0;
	var _g = totalSteps + 1;
	while(_g1 < _g) {
		var i = _g1++;
		cx5 = ax + radius * Math.sin(angle);
		cy5 = ay + radius * Math.cos(angle);
		ex = ax + r2 * Math.sin(angle);
		ey = ay + r2 * Math.cos(angle);
		if(i != 0) {
			var t0 = new trilateral_tri_Trilateral(dx5,dy5,bx5,by5,cx5,cy5);
			var t1 = new trilateral_tri_Trilateral(dx5,dy5,cx5,cy5,ex,ey);
			out1[out1.length] = t0;
			out1[out1.length] = t1;
		}
		angle += step1;
		bx5 = cx5;
		by5 = cy5;
		dx5 = ex;
		dy5 = ey;
	}
	var triArr = out1;
	var _g2 = 0;
	while(_g2 < triArr.length) {
		var t = triArr[_g2];
		++_g2;
		out[out.length] = t;
	}
	var this11 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out2 = this11;
	var pi2 = Math.PI;
	var step2 = pi2 * 2 / 36;
	var dif5;
	switch(trilateral_angle_DifferencePreference.CLOCKWISE[1]) {
	case 0:
		var f8;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f8 = pi_2;
		} else {
			var a8 = pi_2 % (2 * Math.PI);
			if(a8 >= 0) {
				f8 = a8;
			} else {
				f8 = a8 + 2 * Math.PI;
			}
		}
		var this12 = f8;
		var za4 = this12;
		var f9;
		if(pi >= 0 && pi > Math.PI) {
			f9 = pi;
		} else {
			var a9 = pi % (2 * Math.PI);
			if(a9 >= 0) {
				f9 = a9;
			} else {
				f9 = a9 + 2 * Math.PI;
			}
		}
		var this13 = f9;
		var zb4 = this13;
		var fa4 = pi_2;
		var fb4 = pi;
		var theta4 = Math.abs(pi_2 - pi);
		var clockwise4 = pi_2 < pi;
		var dif6 = clockwise4 ? theta4 : -theta4;
		if(dif6 > 0) {
			dif5 = dif6;
		} else {
			dif5 = 2 * Math.PI + dif6;
		}
		break;
	case 1:
		var f10;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f10 = pi_2;
		} else {
			var a10 = pi_2 % (2 * Math.PI);
			if(a10 >= 0) {
				f10 = a10;
			} else {
				f10 = a10 + 2 * Math.PI;
			}
		}
		var this14 = f10;
		var za5 = this14;
		var f11;
		if(pi >= 0 && pi > Math.PI) {
			f11 = pi;
		} else {
			var a11 = pi % (2 * Math.PI);
			if(a11 >= 0) {
				f11 = a11;
			} else {
				f11 = a11 + 2 * Math.PI;
			}
		}
		var this15 = f11;
		var zb5 = this15;
		var fa5 = pi_2;
		var fb5 = pi;
		var theta5 = Math.abs(pi_2 - pi);
		var clockwise5 = pi_2 < pi;
		var dif7 = clockwise5 ? theta5 : -theta5;
		if(dif7 < 0) {
			dif5 = dif7;
		} else {
			dif5 = -2 * Math.PI + dif7;
		}
		break;
	case 2:
		var f12;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f12 = pi_2;
		} else {
			var a12 = pi_2 % (2 * Math.PI);
			if(a12 >= 0) {
				f12 = a12;
			} else {
				f12 = a12 + 2 * Math.PI;
			}
		}
		var this16 = f12;
		var za6 = this16;
		var f13;
		if(pi >= 0 && pi > Math.PI) {
			f13 = pi;
		} else {
			var a13 = pi % (2 * Math.PI);
			if(a13 >= 0) {
				f13 = a13;
			} else {
				f13 = a13 + 2 * Math.PI;
			}
		}
		var this17 = f13;
		var zb6 = this17;
		var fa6 = pi_2;
		var fb6 = pi;
		var theta6 = Math.abs(pi_2 - pi);
		var smallest1 = theta6 <= Math.PI;
		var clockwise6 = pi_2 < pi;
		var dif8 = clockwise6 ? theta6 : -theta6;
		if(smallest1) {
			dif5 = dif8;
		} else if(clockwise6) {
			dif5 = -(2 * Math.PI - theta6);
		} else {
			dif5 = 2 * Math.PI - theta6;
		}
		break;
	case 3:
		var f14;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f14 = pi_2;
		} else {
			var a14 = pi_2 % (2 * Math.PI);
			if(a14 >= 0) {
				f14 = a14;
			} else {
				f14 = a14 + 2 * Math.PI;
			}
		}
		var this18 = f14;
		var za7 = this18;
		var f15;
		if(pi >= 0 && pi > Math.PI) {
			f15 = pi;
		} else {
			var a15 = pi % (2 * Math.PI);
			if(a15 >= 0) {
				f15 = a15;
			} else {
				f15 = a15 + 2 * Math.PI;
			}
		}
		var this19 = f15;
		var zb7 = this19;
		var fa7 = pi_2;
		var fb7 = pi;
		var theta7 = Math.abs(pi_2 - pi);
		var largest1 = theta7 > Math.PI;
		var clockwise7 = pi_2 < pi;
		var dif9 = clockwise7 ? theta7 : -theta7;
		if(largest1) {
			dif5 = dif9;
		} else if(clockwise7) {
			dif5 = -(2 * Math.PI - theta7);
		} else {
			dif5 = 2 * Math.PI - theta7;
		}
		break;
	}
	var positive1 = dif5 >= 0;
	var totalSteps1 = Math.ceil(Math.abs(dif5) / step2);
	var step3 = dif5 / totalSteps1;
	var angle1 = pi_2;
	var cx6;
	var cy6;
	var bx6 = 0;
	var by6 = 0;
	var dx6 = 0;
	var dy6 = 0;
	var ex1 = 0;
	var ey1 = 0;
	var r21 = radius - thick;
	var _g11 = 0;
	var _g3 = totalSteps1 + 1;
	while(_g11 < _g3) {
		var i1 = _g11++;
		cx6 = bx + radius * Math.sin(angle1);
		cy6 = by + radius * Math.cos(angle1);
		ex1 = bx + r21 * Math.sin(angle1);
		ey1 = by + r21 * Math.cos(angle1);
		if(i1 != 0) {
			var t01 = new trilateral_tri_Trilateral(dx6,dy6,bx6,by6,cx6,cy6);
			var t11 = new trilateral_tri_Trilateral(dx6,dy6,cx6,cy6,ex1,ey1);
			out2[out2.length] = t01;
			out2[out2.length] = t11;
		}
		angle1 += step3;
		bx6 = cx6;
		by6 = cy6;
		dx6 = ex1;
		dy6 = ey1;
	}
	var triArr1 = out2;
	var _g4 = 0;
	while(_g4 < triArr1.length) {
		var t2 = triArr1[_g4];
		++_g4;
		out[out.length] = t2;
	}
	var this20 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out3 = this20;
	var pi3 = Math.PI;
	var step4 = pi3 * 2 / 36;
	var dif10;
	switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE[1]) {
	case 0:
		var f16;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f16 = pi_2;
		} else {
			var a16 = pi_2 % (2 * Math.PI);
			if(a16 >= 0) {
				f16 = a16;
			} else {
				f16 = a16 + 2 * Math.PI;
			}
		}
		var this21 = f16;
		var za8 = this21;
		var f17;
		if(0 > Math.PI) {
			f17 = 0;
		} else {
			var a17 = 0 % (2 * Math.PI);
			if(a17 >= 0) {
				f17 = a17;
			} else {
				f17 = a17 + 2 * Math.PI;
			}
		}
		var this22 = f17;
		var zb8 = this22;
		var fa8 = pi_2;
		var fb8 = 0;
		var theta8 = Math.abs(pi_2);
		var clockwise8 = pi_2 < 0;
		var dif11 = clockwise8 ? theta8 : -theta8;
		if(dif11 > 0) {
			dif10 = dif11;
		} else {
			dif10 = 2 * Math.PI + dif11;
		}
		break;
	case 1:
		var f18;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f18 = pi_2;
		} else {
			var a18 = pi_2 % (2 * Math.PI);
			if(a18 >= 0) {
				f18 = a18;
			} else {
				f18 = a18 + 2 * Math.PI;
			}
		}
		var this23 = f18;
		var za9 = this23;
		var f19;
		if(0 > Math.PI) {
			f19 = 0;
		} else {
			var a19 = 0 % (2 * Math.PI);
			if(a19 >= 0) {
				f19 = a19;
			} else {
				f19 = a19 + 2 * Math.PI;
			}
		}
		var this24 = f19;
		var zb9 = this24;
		var fa9 = pi_2;
		var fb9 = 0;
		var theta9 = Math.abs(pi_2);
		var clockwise9 = pi_2 < 0;
		var dif12 = clockwise9 ? theta9 : -theta9;
		if(dif12 < 0) {
			dif10 = dif12;
		} else {
			dif10 = -2 * Math.PI + dif12;
		}
		break;
	case 2:
		var f20;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f20 = pi_2;
		} else {
			var a20 = pi_2 % (2 * Math.PI);
			if(a20 >= 0) {
				f20 = a20;
			} else {
				f20 = a20 + 2 * Math.PI;
			}
		}
		var this25 = f20;
		var za10 = this25;
		var f21;
		if(0 > Math.PI) {
			f21 = 0;
		} else {
			var a21 = 0 % (2 * Math.PI);
			if(a21 >= 0) {
				f21 = a21;
			} else {
				f21 = a21 + 2 * Math.PI;
			}
		}
		var this26 = f21;
		var zb10 = this26;
		var fa10 = pi_2;
		var fb10 = 0;
		var theta10 = Math.abs(pi_2);
		var smallest2 = theta10 <= Math.PI;
		var clockwise10 = pi_2 < 0;
		var dif13 = clockwise10 ? theta10 : -theta10;
		if(smallest2) {
			dif10 = dif13;
		} else if(clockwise10) {
			dif10 = -(2 * Math.PI - theta10);
		} else {
			dif10 = 2 * Math.PI - theta10;
		}
		break;
	case 3:
		var f22;
		if(pi_2 >= 0 && pi_2 > Math.PI) {
			f22 = pi_2;
		} else {
			var a22 = pi_2 % (2 * Math.PI);
			if(a22 >= 0) {
				f22 = a22;
			} else {
				f22 = a22 + 2 * Math.PI;
			}
		}
		var this27 = f22;
		var za11 = this27;
		var f23;
		if(0 > Math.PI) {
			f23 = 0;
		} else {
			var a23 = 0 % (2 * Math.PI);
			if(a23 >= 0) {
				f23 = a23;
			} else {
				f23 = a23 + 2 * Math.PI;
			}
		}
		var this28 = f23;
		var zb11 = this28;
		var fa11 = pi_2;
		var fb11 = 0;
		var theta11 = Math.abs(pi_2);
		var largest2 = theta11 > Math.PI;
		var clockwise11 = pi_2 < 0;
		var dif14 = clockwise11 ? theta11 : -theta11;
		if(largest2) {
			dif10 = dif14;
		} else if(clockwise11) {
			dif10 = -(2 * Math.PI - theta11);
		} else {
			dif10 = 2 * Math.PI - theta11;
		}
		break;
	}
	var positive2 = dif10 >= 0;
	var totalSteps2 = Math.ceil(Math.abs(dif10) / step4);
	var step5 = dif10 / totalSteps2;
	var angle2 = pi_2;
	var cx7;
	var cy7;
	var bx7 = 0;
	var by7 = 0;
	var dx7 = 0;
	var dy7 = 0;
	var ex2 = 0;
	var ey2 = 0;
	var r22 = radius - thick;
	var _g12 = 0;
	var _g5 = totalSteps2 + 1;
	while(_g12 < _g5) {
		var i2 = _g12++;
		cx7 = cx + radius * Math.sin(angle2);
		cy7 = cy + radius * Math.cos(angle2);
		ex2 = cx + r22 * Math.sin(angle2);
		ey2 = cy + r22 * Math.cos(angle2);
		if(i2 != 0) {
			var t02 = new trilateral_tri_Trilateral(dx7,dy7,bx7,by7,cx7,cy7);
			var t12 = new trilateral_tri_Trilateral(dx7,dy7,cx7,cy7,ex2,ey2);
			out3[out3.length] = t02;
			out3[out3.length] = t12;
		}
		angle2 += step5;
		bx7 = cx7;
		by7 = cy7;
		dx7 = ex2;
		dy7 = ey2;
	}
	var triArr2 = out3;
	var _g6 = 0;
	while(_g6 < triArr2.length) {
		var t3 = triArr2[_g6];
		++_g6;
		out[out.length] = t3;
	}
	var gamma1 = -pi_2;
	var this29 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	var out4 = this29;
	var pi4 = Math.PI;
	var step6 = pi4 * 2 / 36;
	var dif15;
	switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE[1]) {
	case 0:
		var f24;
		if(0 > Math.PI) {
			f24 = 0;
		} else {
			var a24 = 0 % (2 * Math.PI);
			if(a24 >= 0) {
				f24 = a24;
			} else {
				f24 = a24 + 2 * Math.PI;
			}
		}
		var this30 = f24;
		var za12 = this30;
		var f25;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f25 = gamma1;
		} else {
			var a25 = gamma1 % (2 * Math.PI);
			if(a25 >= 0) {
				f25 = a25;
			} else {
				f25 = a25 + 2 * Math.PI;
			}
		}
		var this31 = f25;
		var zb12 = this31;
		var fa12 = 0;
		var fb12 = gamma1;
		var theta12 = Math.abs(0 - gamma1);
		var clockwise12 = 0 < gamma1;
		var dif16 = clockwise12 ? theta12 : -theta12;
		if(dif16 > 0) {
			dif15 = dif16;
		} else {
			dif15 = 2 * Math.PI + dif16;
		}
		break;
	case 1:
		var f26;
		if(0 > Math.PI) {
			f26 = 0;
		} else {
			var a26 = 0 % (2 * Math.PI);
			if(a26 >= 0) {
				f26 = a26;
			} else {
				f26 = a26 + 2 * Math.PI;
			}
		}
		var this32 = f26;
		var za13 = this32;
		var f27;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f27 = gamma1;
		} else {
			var a27 = gamma1 % (2 * Math.PI);
			if(a27 >= 0) {
				f27 = a27;
			} else {
				f27 = a27 + 2 * Math.PI;
			}
		}
		var this33 = f27;
		var zb13 = this33;
		var fa13 = 0;
		var fb13 = gamma1;
		var theta13 = Math.abs(0 - gamma1);
		var clockwise13 = 0 < gamma1;
		var dif17 = clockwise13 ? theta13 : -theta13;
		if(dif17 < 0) {
			dif15 = dif17;
		} else {
			dif15 = -2 * Math.PI + dif17;
		}
		break;
	case 2:
		var f28;
		if(0 > Math.PI) {
			f28 = 0;
		} else {
			var a28 = 0 % (2 * Math.PI);
			if(a28 >= 0) {
				f28 = a28;
			} else {
				f28 = a28 + 2 * Math.PI;
			}
		}
		var this34 = f28;
		var za14 = this34;
		var f29;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f29 = gamma1;
		} else {
			var a29 = gamma1 % (2 * Math.PI);
			if(a29 >= 0) {
				f29 = a29;
			} else {
				f29 = a29 + 2 * Math.PI;
			}
		}
		var this35 = f29;
		var zb14 = this35;
		var fa14 = 0;
		var fb14 = gamma1;
		var theta14 = Math.abs(0 - gamma1);
		var smallest3 = theta14 <= Math.PI;
		var clockwise14 = 0 < gamma1;
		var dif18 = clockwise14 ? theta14 : -theta14;
		if(smallest3) {
			dif15 = dif18;
		} else if(clockwise14) {
			dif15 = -(2 * Math.PI - theta14);
		} else {
			dif15 = 2 * Math.PI - theta14;
		}
		break;
	case 3:
		var f30;
		if(0 > Math.PI) {
			f30 = 0;
		} else {
			var a30 = 0 % (2 * Math.PI);
			if(a30 >= 0) {
				f30 = a30;
			} else {
				f30 = a30 + 2 * Math.PI;
			}
		}
		var this36 = f30;
		var za15 = this36;
		var f31;
		if(gamma1 >= 0 && gamma1 > Math.PI) {
			f31 = gamma1;
		} else {
			var a31 = gamma1 % (2 * Math.PI);
			if(a31 >= 0) {
				f31 = a31;
			} else {
				f31 = a31 + 2 * Math.PI;
			}
		}
		var this37 = f31;
		var zb15 = this37;
		var fa15 = 0;
		var fb15 = gamma1;
		var theta15 = Math.abs(0 - gamma1);
		var largest3 = theta15 > Math.PI;
		var clockwise15 = 0 < gamma1;
		var dif19 = clockwise15 ? theta15 : -theta15;
		if(largest3) {
			dif15 = dif19;
		} else if(clockwise15) {
			dif15 = -(2 * Math.PI - theta15);
		} else {
			dif15 = 2 * Math.PI - theta15;
		}
		break;
	}
	var positive3 = dif15 >= 0;
	var totalSteps3 = Math.ceil(Math.abs(dif15) / step6);
	var step7 = dif15 / totalSteps3;
	var angle3 = 0;
	var cx8;
	var cy8;
	var bx8 = 0;
	var by8 = 0;
	var dx8 = 0;
	var dy8 = 0;
	var ex3 = 0;
	var ey3 = 0;
	var r23 = radius - thick;
	var _g13 = 0;
	var _g7 = totalSteps3 + 1;
	while(_g13 < _g7) {
		var i3 = _g13++;
		cx8 = dx + radius * Math.sin(angle3);
		cy8 = dy + radius * Math.cos(angle3);
		ex3 = dx + r23 * Math.sin(angle3);
		ey3 = dy + r23 * Math.cos(angle3);
		if(i3 != 0) {
			var t03 = new trilateral_tri_Trilateral(dx8,dy8,bx8,by8,cx8,cy8);
			var t13 = new trilateral_tri_Trilateral(dx8,dy8,cx8,cy8,ex3,ey3);
			out4[out4.length] = t03;
			out4[out4.length] = t13;
		}
		angle3 += step7;
		bx8 = cx8;
		by8 = cy8;
		dx8 = ex3;
		dy8 = ey3;
	}
	var triArr3 = out4;
	var _g8 = 0;
	while(_g8 < triArr3.length) {
		var t4 = triArr3[_g8];
		++_g8;
		out[out.length] = t4;
	}
	return out;
};
var trilateral_polys_Shapes = function(triangleArray_,colors_) {
	this.refCount = 0;
	this.triangles = triangleArray_;
	this.colors = colors_;
};
$hxClasses["trilateral.polys.Shapes"] = trilateral_polys_Shapes;
trilateral_polys_Shapes.__name__ = true;
trilateral_polys_Shapes.prototype = {
	triangles: null
	,colors: null
	,refCount: null
	,findShapeById: function(id) {
		var this1 = this.triangles;
		var this2 = trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]);
		var out = this2;
		var _g1 = 0;
		var _g = this1.length;
		while(_g1 < _g) {
			var i = _g1++;
			if(this1[i].id == id) {
				out[out.length] = this1[i];
			}
		}
		return out;
	}
	,star: function(x,y,radius,color,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var pi = Math.PI;
		var omega = -pi + theta;
		var a0x = x + radius * Math.sin(omega);
		var a0y = y + radius * Math.cos(omega);
		omega += pi / 3;
		var a1x = x + radius * Math.sin(omega);
		var a1y = y + radius * Math.cos(omega);
		omega += pi / 3;
		var b0x = x + radius * Math.sin(omega);
		var b0y = y + radius * Math.cos(omega);
		omega += pi / 3;
		var b1x = x + radius * Math.sin(omega);
		var b1y = y + radius * Math.cos(omega);
		omega += pi / 3;
		var c0x = x + radius * Math.sin(omega);
		var c0y = y + radius * Math.cos(omega);
		omega += pi / 3;
		var c1x = x + radius * Math.sin(omega);
		var c1y = y + radius * Math.cos(omega);
		var tri = { t0 : new trilateral_tri_Trilateral(a0x,a0y,b0x,b0y,c0x,c0y), t1 : new trilateral_tri_Trilateral(a1x,a1y,b1x,b1y,c1x,c1y)};
		var tri1 = tri.t0;
		var t = Type.createEmptyInstance(trilateral_tri_Triangle);
		t.id = id;
		t.ax = tri1.ax;
		t.ay = tri1.ay;
		t.bx = tri1.bx;
		t.by = tri1.by;
		t.cx = tri1.cx;
		t.cy = tri1.cy;
		t.mark = tri1.mark;
		t.depth = 0;
		t.alpha = 1.;
		t.colorID = color;
		t.colorA = color;
		t.colorB = color;
		t.colorC = color;
		t.windingAdjusted = tri1.windingAdjusted;
		var tri0 = t;
		this1[this1.length] = tri0;
		var tri2 = tri.t1;
		var t1 = Type.createEmptyInstance(trilateral_tri_Triangle);
		t1.id = id;
		t1.ax = tri2.ax;
		t1.ay = tri2.ay;
		t1.bx = tri2.bx;
		t1.by = tri2.by;
		t1.cx = tri2.cx;
		t1.cy = tri2.cy;
		t1.mark = tri2.mark;
		t1.depth = 0;
		t1.alpha = 1.;
		t1.colorID = color;
		t1.colorA = color;
		t1.colorB = color;
		t1.colorC = color;
		t1.windingAdjusted = tri2.windingAdjusted;
		var tri11 = t1;
		this1[this1.length] = tri11;
		return this.refCount - 1;
	}
	,diamond: function(x,y,radius,color,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var theta1 = Math.PI / 4;
		var ax = 0.;
		var ay = 0.;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var dx = 0.;
		var dy = 0.;
		if(theta1 != 0) {
			var pi = Math.PI;
			var pi4 = pi / 4;
			var pi2 = pi / 2;
			var sqrt2 = Math.sqrt(2);
			var r = radius * sqrt2;
			var aTheta = -pi + theta1 - pi4;
			var dTheta = -pi + theta1 + pi / 2 - pi / 4;
			var cTheta = theta1 - pi4;
			var bTheta = -pi + theta1 - pi2 - pi4;
			ax = x + r * Math.sin(aTheta);
			ay = y + r * Math.cos(aTheta);
			bx = x + r * Math.sin(bTheta);
			by = y + r * Math.cos(bTheta);
			cx = x + r * Math.sin(cTheta);
			cy = y + r * Math.cos(cTheta);
			dx = x + r * Math.sin(dTheta);
			dy = y + r * Math.cos(dTheta);
		} else {
			ax = x - radius;
			ay = y - radius;
			var lx = radius * 2;
			var ly = lx;
			bx = ax + lx;
			by = ay;
			cx = bx;
			cy = ay + ly;
			dx = ax;
			dy = cy;
		}
		var tri = { t0 : new trilateral_tri_Trilateral(ax,ay,bx,by,dx,dy), t1 : new trilateral_tri_Trilateral(bx,by,cx,cy,dx,dy)};
		var tri1 = tri.t0;
		var t = Type.createEmptyInstance(trilateral_tri_Triangle);
		t.id = id;
		t.ax = tri1.ax;
		t.ay = tri1.ay;
		t.bx = tri1.bx;
		t.by = tri1.by;
		t.cx = tri1.cx;
		t.cy = tri1.cy;
		t.mark = tri1.mark;
		t.depth = 0;
		t.alpha = 1.;
		t.colorID = color;
		t.colorA = color;
		t.colorB = color;
		t.colorC = color;
		t.windingAdjusted = tri1.windingAdjusted;
		var tri0 = t;
		this1[this1.length] = tri0;
		var tri2 = tri.t1;
		var t1 = Type.createEmptyInstance(trilateral_tri_Triangle);
		t1.id = id;
		t1.ax = tri2.ax;
		t1.ay = tri2.ay;
		t1.bx = tri2.bx;
		t1.by = tri2.by;
		t1.cx = tri2.cx;
		t1.cy = tri2.cy;
		t1.mark = tri2.mark;
		t1.depth = 0;
		t1.alpha = 1.;
		t1.colorID = color;
		t1.colorA = color;
		t1.colorB = color;
		t1.colorC = color;
		t1.windingAdjusted = tri2.windingAdjusted;
		var tri11 = t1;
		this1[this1.length] = tri11;
		return this.refCount - 1;
	}
	,diamondOutline: function(x,y,radius,thick,color,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var theta1 = Math.PI / 4;
		var this2 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out = this2;
		var ax = 0.;
		var ay = 0.;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var dx = 0.;
		var dy = 0.;
		var a0x = 0.;
		var a0y = 0.;
		var b0x = 0.;
		var b0y = 0.;
		var c0x = 0.;
		var c0y = 0.;
		var d0x = 0.;
		var d0y = 0.;
		if(theta1 != 0) {
			var pi = Math.PI;
			var pi4 = pi / 4;
			var pi2 = pi / 2;
			var sqrt2 = Math.sqrt(2);
			var r = radius * sqrt2;
			var aTheta = -pi + theta1 - pi4;
			var dTheta = -pi + theta1 + pi / 2 - pi / 4;
			var cTheta = theta1 - pi4;
			var bTheta = -pi + theta1 - pi2 - pi4;
			var $as = Math.sin(aTheta);
			var ac = Math.cos(aTheta);
			var bs = Math.sin(bTheta);
			var bc = Math.cos(bTheta);
			var cs = Math.sin(cTheta);
			var cc = Math.cos(cTheta);
			var ds = Math.sin(dTheta);
			var dc = Math.cos(dTheta);
			var r0 = r - thick;
			ax = x + r * $as;
			ay = y + r * ac;
			bx = x + r * bs;
			by = y + r * bc;
			cx = x + r * cs;
			cy = y + r * cc;
			dx = x + r * ds;
			dy = y + r * dc;
			a0x = x + r0 * $as;
			a0y = y + r0 * ac;
			b0x = x + r0 * bs;
			b0y = y + r0 * bc;
			c0x = x + r0 * cs;
			c0y = y + r0 * cc;
			d0x = x + r0 * ds;
			d0y = y + r0 * dc;
		} else {
			ax = x - radius;
			ay = y - radius;
			var lx = radius * 2;
			var ly = lx;
			bx = ax + lx;
			by = ay;
			cx = bx;
			cy = ay + ly;
			dx = ax;
			dy = cy;
			var radius0 = radius - thick;
			a0x = x - radius0;
			a0y = y - radius0;
			var l0x = radius0 * 2;
			var l0y = l0x;
			b0x = a0x + l0x;
			b0y = a0y;
			c0x = b0x;
			c0y = a0y + l0y;
			d0x = a0x;
			d0y = c0y;
		}
		var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,a0x,a0y);
		out[out.length] = tri;
		var tri1 = new trilateral_tri_Trilateral(bx,by,b0x,b0y,a0x,a0y);
		out[out.length] = tri1;
		var tri2 = new trilateral_tri_Trilateral(d0x,d0y,c0x,c0y,dx,dy);
		out[out.length] = tri2;
		var tri3 = new trilateral_tri_Trilateral(c0x,c0y,cx,cy,dx,dy);
		out[out.length] = tri3;
		var tri4 = new trilateral_tri_Trilateral(ax,ay,a0x,a0y,d0x,d0y);
		out[out.length] = tri4;
		var tri5 = new trilateral_tri_Trilateral(ax,ay,d0x,d0y,dx,dy);
		out[out.length] = tri5;
		var tri6 = new trilateral_tri_Trilateral(b0x,b0y,bx,by,c0x,c0y);
		out[out.length] = tri6;
		var tri7 = new trilateral_tri_Trilateral(bx,by,cx,cy,c0x,c0y);
		out[out.length] = tri7;
		var triArr = out;
		var tri8;
		var _g = 0;
		while(_g < triArr.length) {
			var t = triArr[_g];
			++_g;
			if(t != null) {
				var t1 = Type.createEmptyInstance(trilateral_tri_Triangle);
				t1.id = id;
				t1.ax = t.ax;
				t1.ay = t.ay;
				t1.bx = t.bx;
				t1.by = t.by;
				t1.cx = t.cx;
				t1.cy = t.cy;
				t1.mark = t.mark;
				t1.depth = 0;
				t1.alpha = 1.;
				t1.colorID = color;
				t1.colorA = color;
				t1.colorB = color;
				t1.colorC = color;
				t1.windingAdjusted = t.windingAdjusted;
				tri8 = t1;
				this1[this1.length] = tri8;
			}
		}
		return this.refCount - 1;
	}
	,square: function(x,y,radius,color,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var ax = 0.;
		var ay = 0.;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var dx = 0.;
		var dy = 0.;
		ax = x - radius;
		ay = y - radius;
		var lx = radius * 2;
		var ly = lx;
		bx = ax + lx;
		by = ay;
		cx = bx;
		cy = ay + ly;
		dx = ax;
		dy = cy;
		var tri = { t0 : new trilateral_tri_Trilateral(ax,ay,bx,by,dx,dy), t1 : new trilateral_tri_Trilateral(bx,by,cx,cy,dx,dy)};
		var tri1 = tri.t0;
		var t = Type.createEmptyInstance(trilateral_tri_Triangle);
		t.id = id;
		t.ax = tri1.ax;
		t.ay = tri1.ay;
		t.bx = tri1.bx;
		t.by = tri1.by;
		t.cx = tri1.cx;
		t.cy = tri1.cy;
		t.mark = tri1.mark;
		t.depth = 0;
		t.alpha = 1.;
		t.colorID = color;
		t.colorA = color;
		t.colorB = color;
		t.colorC = color;
		t.windingAdjusted = tri1.windingAdjusted;
		var tri0 = t;
		this1[this1.length] = tri0;
		var tri2 = tri.t1;
		var t1 = Type.createEmptyInstance(trilateral_tri_Triangle);
		t1.id = id;
		t1.ax = tri2.ax;
		t1.ay = tri2.ay;
		t1.bx = tri2.bx;
		t1.by = tri2.by;
		t1.cx = tri2.cx;
		t1.cy = tri2.cy;
		t1.mark = tri2.mark;
		t1.depth = 0;
		t1.alpha = 1.;
		t1.colorID = color;
		t1.colorA = color;
		t1.colorB = color;
		t1.colorC = color;
		t1.windingAdjusted = tri2.windingAdjusted;
		var tri11 = t1;
		this1[this1.length] = tri11;
		return this.refCount - 1;
	}
	,squareOutline: function(x,y,radius,thick,color,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var this2 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out = this2;
		var ax = 0.;
		var ay = 0.;
		var bx = 0.;
		var by = 0.;
		var cx = 0.;
		var cy = 0.;
		var dx = 0.;
		var dy = 0.;
		var a0x = 0.;
		var a0y = 0.;
		var b0x = 0.;
		var b0y = 0.;
		var c0x = 0.;
		var c0y = 0.;
		var d0x = 0.;
		var d0y = 0.;
		ax = x - radius;
		ay = y - radius;
		var lx = radius * 2;
		var ly = lx;
		bx = ax + lx;
		by = ay;
		cx = bx;
		cy = ay + ly;
		dx = ax;
		dy = cy;
		var radius0 = radius - thick;
		a0x = x - radius0;
		a0y = y - radius0;
		var l0x = radius0 * 2;
		var l0y = l0x;
		b0x = a0x + l0x;
		b0y = a0y;
		c0x = b0x;
		c0y = a0y + l0y;
		d0x = a0x;
		d0y = c0y;
		var tri = new trilateral_tri_Trilateral(ax,ay,bx,by,a0x,a0y);
		out[out.length] = tri;
		var tri1 = new trilateral_tri_Trilateral(bx,by,b0x,b0y,a0x,a0y);
		out[out.length] = tri1;
		var tri2 = new trilateral_tri_Trilateral(d0x,d0y,c0x,c0y,dx,dy);
		out[out.length] = tri2;
		var tri3 = new trilateral_tri_Trilateral(c0x,c0y,cx,cy,dx,dy);
		out[out.length] = tri3;
		var tri4 = new trilateral_tri_Trilateral(ax,ay,a0x,a0y,d0x,d0y);
		out[out.length] = tri4;
		var tri5 = new trilateral_tri_Trilateral(ax,ay,d0x,d0y,dx,dy);
		out[out.length] = tri5;
		var tri6 = new trilateral_tri_Trilateral(b0x,b0y,bx,by,c0x,c0y);
		out[out.length] = tri6;
		var tri7 = new trilateral_tri_Trilateral(bx,by,cx,cy,c0x,c0y);
		out[out.length] = tri7;
		var triArr = out;
		var tri8;
		var _g = 0;
		while(_g < triArr.length) {
			var t = triArr[_g];
			++_g;
			if(t != null) {
				var t1 = Type.createEmptyInstance(trilateral_tri_Triangle);
				t1.id = id;
				t1.ax = t.ax;
				t1.ay = t.ay;
				t1.bx = t.bx;
				t1.by = t.by;
				t1.cx = t.cx;
				t1.cy = t.cy;
				t1.mark = t.mark;
				t1.depth = 0;
				t1.alpha = 1.;
				t1.colorID = color;
				t1.colorA = color;
				t1.colorB = color;
				t1.colorC = color;
				t1.windingAdjusted = t.windingAdjusted;
				tri8 = t1;
				this1[this1.length] = tri8;
			}
		}
		return this.refCount - 1;
	}
	,rectangle: function(x,y,width,height,color) {
		var this1 = this.triangles;
		var id = this.refCount++;
		var ax = x;
		var ay = y;
		var bx = x + width;
		var by = ay;
		var cx = bx;
		var cy = ay + height;
		var dx = x;
		var dy = cy;
		var tri = { t0 : new trilateral_tri_Trilateral(ax,ay,bx,by,dx,dy), t1 : new trilateral_tri_Trilateral(bx,by,cx,cy,dx,dy)};
		var tri1 = tri.t0;
		var t = Type.createEmptyInstance(trilateral_tri_Triangle);
		t.id = id;
		t.ax = tri1.ax;
		t.ay = tri1.ay;
		t.bx = tri1.bx;
		t.by = tri1.by;
		t.cx = tri1.cx;
		t.cy = tri1.cy;
		t.mark = tri1.mark;
		t.depth = 0;
		t.alpha = 1.;
		t.colorID = color;
		t.colorA = color;
		t.colorB = color;
		t.colorC = color;
		t.windingAdjusted = tri1.windingAdjusted;
		var tri0 = t;
		this1[this1.length] = tri0;
		var tri2 = tri.t1;
		var t1 = Type.createEmptyInstance(trilateral_tri_Triangle);
		t1.id = id;
		t1.ax = tri2.ax;
		t1.ay = tri2.ay;
		t1.bx = tri2.bx;
		t1.by = tri2.by;
		t1.cx = tri2.cx;
		t1.cy = tri2.cy;
		t1.mark = tri2.mark;
		t1.depth = 0;
		t1.alpha = 1.;
		t1.colorID = color;
		t1.colorA = color;
		t1.colorB = color;
		t1.colorC = color;
		t1.windingAdjusted = tri2.windingAdjusted;
		var tri11 = t1;
		this1[this1.length] = tri11;
		return this.refCount - 1;
	}
	,circle: function(x,y,radius,color,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var this2 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out = this2;
		var pi = Math.PI;
		var theta1 = pi / 2;
		var step = pi * 2 / 36;
		var bx;
		var by;
		var cx;
		var cy;
		var _g1 = 0;
		var _g = 36;
		while(_g1 < _g) {
			var i = _g1++;
			bx = x + radius * Math.sin(theta1);
			by = y + radius * Math.cos(theta1);
			theta1 += step;
			cx = x + radius * Math.sin(theta1);
			cy = y + radius * Math.cos(theta1);
			var tri = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
			out[out.length] = tri;
		}
		var triArr = out;
		var tri1;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t = triArr[_g2];
			++_g2;
			if(t != null) {
				var t1 = Type.createEmptyInstance(trilateral_tri_Triangle);
				t1.id = id;
				t1.ax = t.ax;
				t1.ay = t.ay;
				t1.bx = t.bx;
				t1.by = t.by;
				t1.cx = t.cx;
				t1.cy = t.cy;
				t1.mark = t.mark;
				t1.depth = 0;
				t1.alpha = 1.;
				t1.colorID = color;
				t1.colorA = color;
				t1.colorB = color;
				t1.colorC = color;
				t1.windingAdjusted = t.windingAdjusted;
				tri1 = t1;
				this1[this1.length] = tri1;
			}
		}
		return this.refCount - 1;
	}
	,shape: function(x,y,radius,color,sides,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var triArr;
		if((sides & 1) == 0) {
			var this2 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
			var out = this2;
			var pi = Math.PI;
			var theta1 = pi / 2;
			var step = pi * 2 / sides;
			theta1 -= step / 2 + theta;
			var bx;
			var by;
			var cx;
			var cy;
			var _g1 = 0;
			var _g = sides;
			while(_g1 < _g) {
				var i = _g1++;
				bx = x + radius * Math.sin(theta1);
				by = y + radius * Math.cos(theta1);
				theta1 += step;
				cx = x + radius * Math.sin(theta1);
				cy = y + radius * Math.cos(theta1);
				var tri = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
				out[out.length] = tri;
			}
			triArr = out;
		} else {
			var this3 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
			var out1 = this3;
			var pi1 = Math.PI;
			var theta2 = pi1 / 2 + theta;
			var step1 = pi1 * 2 / sides;
			var bx1;
			var by1;
			var cx1;
			var cy1;
			var _g11 = 0;
			var _g2 = sides;
			while(_g11 < _g2) {
				var i1 = _g11++;
				bx1 = x + radius * Math.sin(theta2);
				by1 = y + radius * Math.cos(theta2);
				theta2 += step1;
				cx1 = x + radius * Math.sin(theta2);
				cy1 = y + radius * Math.cos(theta2);
				var tri1 = new trilateral_tri_Trilateral(x,y,bx1,by1,cx1,cy1);
				out1[out1.length] = tri1;
			}
			triArr = out1;
		}
		var tri2;
		var _g3 = 0;
		while(_g3 < triArr.length) {
			var t = triArr[_g3];
			++_g3;
			if(t != null) {
				var t1 = Type.createEmptyInstance(trilateral_tri_Triangle);
				t1.id = id;
				t1.ax = t.ax;
				t1.ay = t.ay;
				t1.bx = t.bx;
				t1.by = t.by;
				t1.cx = t.cx;
				t1.cy = t.cy;
				t1.mark = t.mark;
				t1.depth = 0;
				t1.alpha = 1.;
				t1.colorID = color;
				t1.colorA = color;
				t1.colorB = color;
				t1.colorC = color;
				t1.windingAdjusted = t.windingAdjusted;
				tri2 = t1;
				this1[this1.length] = tri2;
			}
		}
		return this.refCount - 1;
	}
	,ellipse: function(x,y,rx,ry,color,sides,theta) {
		if(theta == null) {
			theta = 0;
		}
		var this1 = this.triangles;
		var id = this.refCount++;
		var this2 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out = this2;
		var pi = Math.PI;
		var theta1 = pi / 2;
		var step = pi * 2 / sides;
		var bx;
		var by;
		var cx;
		var cy;
		var _g1 = 0;
		var _g = sides;
		while(_g1 < _g) {
			var i = _g1++;
			bx = x + rx * Math.sin(theta1);
			by = y + ry * Math.cos(theta1);
			theta1 += step;
			cx = x + rx * Math.sin(theta1);
			cy = y + ry * Math.cos(theta1);
			var tri = new trilateral_tri_Trilateral(x,y,bx,by,cx,cy);
			out[out.length] = tri;
		}
		var triArr = out;
		var tri1;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t = triArr[_g2];
			++_g2;
			if(t != null) {
				var t1 = Type.createEmptyInstance(trilateral_tri_Triangle);
				t1.id = id;
				t1.ax = t.ax;
				t1.ay = t.ay;
				t1.bx = t.bx;
				t1.by = t.by;
				t1.cx = t.cx;
				t1.cy = t.cy;
				t1.mark = t.mark;
				t1.depth = 0;
				t1.alpha = 1.;
				t1.colorID = color;
				t1.colorA = color;
				t1.colorB = color;
				t1.colorC = color;
				t1.windingAdjusted = t.windingAdjusted;
				tri1 = t1;
				this1[this1.length] = tri1;
			}
		}
		return this.refCount - 1;
	}
	,roundedRectangle: function(x,y,width,height,radius,color) {
		var this1 = this.triangles;
		var id = this.refCount++;
		var this2 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out = this2;
		var pi = Math.PI;
		var pi_2 = Math.PI / 2;
		var ax = x + radius;
		var ay = y + radius;
		var bx = x + width - radius;
		var by = y + radius;
		var cx = bx;
		var cy = y + height - radius;
		var dx = ax;
		var dy = cy;
		var tp_t1;
		var tp_t0;
		var ax1 = ax;
		var ay1 = y;
		var bx1 = ax + (width - radius * 2);
		var by1 = ay1;
		var cx1 = bx1;
		var cy1 = ay1 + height;
		var dx1 = ax;
		var dy1 = cy1;
		tp_t0 = new trilateral_tri_Trilateral(ax1,ay1,bx1,by1,dx1,dy1);
		tp_t1 = new trilateral_tri_Trilateral(bx1,by1,cx1,cy1,dx1,dy1);
		out[out.length] = tp_t0;
		out[out.length] = tp_t1;
		var dimY = height - 2 * radius;
		var tp_t11;
		var tp_t01;
		var ax2 = x;
		var ay2 = ay;
		var bx2 = x + radius;
		var by2 = ay2;
		var cx2 = bx2;
		var cy2 = ay2 + dimY;
		var dx2 = x;
		var dy2 = cy2;
		tp_t01 = new trilateral_tri_Trilateral(ax2,ay2,bx2,by2,dx2,dy2);
		tp_t11 = new trilateral_tri_Trilateral(bx2,by2,cx2,cy2,dx2,dy2);
		out[out.length] = tp_t01;
		out[out.length] = tp_t11;
		var tp_t12;
		var tp_t02;
		var ax3 = bx;
		var ay3 = by;
		var bx3 = bx + radius;
		var by3 = ay3;
		var cx3 = bx3;
		var cy3 = ay3 + dimY;
		var dx3 = bx;
		var dy3 = cy3;
		tp_t02 = new trilateral_tri_Trilateral(ax3,ay3,bx3,by3,dx3,dy3);
		tp_t12 = new trilateral_tri_Trilateral(bx3,by3,cx3,cy3,dx3,dy3);
		out[out.length] = tp_t02;
		out[out.length] = tp_t12;
		var beta = -pi;
		var gamma = -pi_2;
		var this3 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out1 = this3;
		var pi1 = Math.PI;
		var step = pi1 * 2 / 36;
		var dif;
		switch(trilateral_angle_DifferencePreference.CLOCKWISE[1]) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				if(a >= 0) {
					f = a;
				} else {
					f = a + 2 * Math.PI;
				}
			}
			var this4 = f;
			var za = this4;
			var f1;
			if(gamma >= 0 && gamma > Math.PI) {
				f1 = gamma;
			} else {
				var a1 = gamma % (2 * Math.PI);
				if(a1 >= 0) {
					f1 = a1;
				} else {
					f1 = a1 + 2 * Math.PI;
				}
			}
			var this5 = f1;
			var zb = this5;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			if(dif1 > 0) {
				dif = dif1;
			} else {
				dif = 2 * Math.PI + dif1;
			}
			break;
		case 1:
			var f2;
			if(beta >= 0 && beta > Math.PI) {
				f2 = beta;
			} else {
				var a2 = beta % (2 * Math.PI);
				if(a2 >= 0) {
					f2 = a2;
				} else {
					f2 = a2 + 2 * Math.PI;
				}
			}
			var this6 = f2;
			var za1 = this6;
			var f3;
			if(gamma >= 0 && gamma > Math.PI) {
				f3 = gamma;
			} else {
				var a3 = gamma % (2 * Math.PI);
				if(a3 >= 0) {
					f3 = a3;
				} else {
					f3 = a3 + 2 * Math.PI;
				}
			}
			var this7 = f3;
			var zb1 = this7;
			var fa1 = beta;
			var fb1 = gamma;
			var theta1 = Math.abs(beta - gamma);
			var clockwise1 = beta < gamma;
			var dif2 = clockwise1 ? theta1 : -theta1;
			if(dif2 < 0) {
				dif = dif2;
			} else {
				dif = -2 * Math.PI + dif2;
			}
			break;
		case 2:
			var f4;
			if(beta >= 0 && beta > Math.PI) {
				f4 = beta;
			} else {
				var a4 = beta % (2 * Math.PI);
				if(a4 >= 0) {
					f4 = a4;
				} else {
					f4 = a4 + 2 * Math.PI;
				}
			}
			var this8 = f4;
			var za2 = this8;
			var f5;
			if(gamma >= 0 && gamma > Math.PI) {
				f5 = gamma;
			} else {
				var a5 = gamma % (2 * Math.PI);
				if(a5 >= 0) {
					f5 = a5;
				} else {
					f5 = a5 + 2 * Math.PI;
				}
			}
			var this9 = f5;
			var zb2 = this9;
			var fa2 = beta;
			var fb2 = gamma;
			var theta2 = Math.abs(beta - gamma);
			var smallest = theta2 <= Math.PI;
			var clockwise2 = beta < gamma;
			var dif3 = clockwise2 ? theta2 : -theta2;
			if(smallest) {
				dif = dif3;
			} else if(clockwise2) {
				dif = -(2 * Math.PI - theta2);
			} else {
				dif = 2 * Math.PI - theta2;
			}
			break;
		case 3:
			var f6;
			if(beta >= 0 && beta > Math.PI) {
				f6 = beta;
			} else {
				var a6 = beta % (2 * Math.PI);
				if(a6 >= 0) {
					f6 = a6;
				} else {
					f6 = a6 + 2 * Math.PI;
				}
			}
			var this10 = f6;
			var za3 = this10;
			var f7;
			if(gamma >= 0 && gamma > Math.PI) {
				f7 = gamma;
			} else {
				var a7 = gamma % (2 * Math.PI);
				if(a7 >= 0) {
					f7 = a7;
				} else {
					f7 = a7 + 2 * Math.PI;
				}
			}
			var this11 = f7;
			var zb3 = this11;
			var fa3 = beta;
			var fb3 = gamma;
			var theta3 = Math.abs(beta - gamma);
			var largest = theta3 > Math.PI;
			var clockwise3 = beta < gamma;
			var dif4 = clockwise3 ? theta3 : -theta3;
			if(largest) {
				dif = dif4;
			} else if(clockwise3) {
				dif = -(2 * Math.PI - theta3);
			} else {
				dif = 2 * Math.PI - theta3;
			}
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step1 = dif / totalSteps;
		var angle = beta;
		var cx4;
		var cy4;
		var bx4 = 0;
		var by4 = 0;
		var _g1 = 0;
		var _g = totalSteps + 1;
		while(_g1 < _g) {
			var i = _g1++;
			cx4 = ax + radius * Math.sin(angle);
			cy4 = ay + radius * Math.cos(angle);
			if(i != 0) {
				var t = new trilateral_tri_Trilateral(ax,ay,bx4,by4,cx4,cy4);
				out1[out1.length] = t;
			}
			angle += step1;
			bx4 = cx4;
			by4 = cy4;
		}
		var triArr = out1;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t1 = triArr[_g2];
			++_g2;
			out[out.length] = t1;
		}
		var this12 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out2 = this12;
		var pi2 = Math.PI;
		var step2 = pi2 * 2 / 36;
		var dif5;
		switch(trilateral_angle_DifferencePreference.CLOCKWISE[1]) {
		case 0:
			var f8;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f8 = pi_2;
			} else {
				var a8 = pi_2 % (2 * Math.PI);
				if(a8 >= 0) {
					f8 = a8;
				} else {
					f8 = a8 + 2 * Math.PI;
				}
			}
			var this13 = f8;
			var za4 = this13;
			var f9;
			if(pi >= 0 && pi > Math.PI) {
				f9 = pi;
			} else {
				var a9 = pi % (2 * Math.PI);
				if(a9 >= 0) {
					f9 = a9;
				} else {
					f9 = a9 + 2 * Math.PI;
				}
			}
			var this14 = f9;
			var zb4 = this14;
			var fa4 = pi_2;
			var fb4 = pi;
			var theta4 = Math.abs(pi_2 - pi);
			var clockwise4 = pi_2 < pi;
			var dif6 = clockwise4 ? theta4 : -theta4;
			if(dif6 > 0) {
				dif5 = dif6;
			} else {
				dif5 = 2 * Math.PI + dif6;
			}
			break;
		case 1:
			var f10;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f10 = pi_2;
			} else {
				var a10 = pi_2 % (2 * Math.PI);
				if(a10 >= 0) {
					f10 = a10;
				} else {
					f10 = a10 + 2 * Math.PI;
				}
			}
			var this15 = f10;
			var za5 = this15;
			var f11;
			if(pi >= 0 && pi > Math.PI) {
				f11 = pi;
			} else {
				var a11 = pi % (2 * Math.PI);
				if(a11 >= 0) {
					f11 = a11;
				} else {
					f11 = a11 + 2 * Math.PI;
				}
			}
			var this16 = f11;
			var zb5 = this16;
			var fa5 = pi_2;
			var fb5 = pi;
			var theta5 = Math.abs(pi_2 - pi);
			var clockwise5 = pi_2 < pi;
			var dif7 = clockwise5 ? theta5 : -theta5;
			if(dif7 < 0) {
				dif5 = dif7;
			} else {
				dif5 = -2 * Math.PI + dif7;
			}
			break;
		case 2:
			var f12;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f12 = pi_2;
			} else {
				var a12 = pi_2 % (2 * Math.PI);
				if(a12 >= 0) {
					f12 = a12;
				} else {
					f12 = a12 + 2 * Math.PI;
				}
			}
			var this17 = f12;
			var za6 = this17;
			var f13;
			if(pi >= 0 && pi > Math.PI) {
				f13 = pi;
			} else {
				var a13 = pi % (2 * Math.PI);
				if(a13 >= 0) {
					f13 = a13;
				} else {
					f13 = a13 + 2 * Math.PI;
				}
			}
			var this18 = f13;
			var zb6 = this18;
			var fa6 = pi_2;
			var fb6 = pi;
			var theta6 = Math.abs(pi_2 - pi);
			var smallest1 = theta6 <= Math.PI;
			var clockwise6 = pi_2 < pi;
			var dif8 = clockwise6 ? theta6 : -theta6;
			if(smallest1) {
				dif5 = dif8;
			} else if(clockwise6) {
				dif5 = -(2 * Math.PI - theta6);
			} else {
				dif5 = 2 * Math.PI - theta6;
			}
			break;
		case 3:
			var f14;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f14 = pi_2;
			} else {
				var a14 = pi_2 % (2 * Math.PI);
				if(a14 >= 0) {
					f14 = a14;
				} else {
					f14 = a14 + 2 * Math.PI;
				}
			}
			var this19 = f14;
			var za7 = this19;
			var f15;
			if(pi >= 0 && pi > Math.PI) {
				f15 = pi;
			} else {
				var a15 = pi % (2 * Math.PI);
				if(a15 >= 0) {
					f15 = a15;
				} else {
					f15 = a15 + 2 * Math.PI;
				}
			}
			var this20 = f15;
			var zb7 = this20;
			var fa7 = pi_2;
			var fb7 = pi;
			var theta7 = Math.abs(pi_2 - pi);
			var largest1 = theta7 > Math.PI;
			var clockwise7 = pi_2 < pi;
			var dif9 = clockwise7 ? theta7 : -theta7;
			if(largest1) {
				dif5 = dif9;
			} else if(clockwise7) {
				dif5 = -(2 * Math.PI - theta7);
			} else {
				dif5 = 2 * Math.PI - theta7;
			}
			break;
		}
		var positive1 = dif5 >= 0;
		var totalSteps1 = Math.ceil(Math.abs(dif5) / step2);
		var step3 = dif5 / totalSteps1;
		var angle1 = pi_2;
		var cx5;
		var cy5;
		var bx5 = 0;
		var by5 = 0;
		var _g11 = 0;
		var _g3 = totalSteps1 + 1;
		while(_g11 < _g3) {
			var i1 = _g11++;
			cx5 = bx + radius * Math.sin(angle1);
			cy5 = by + radius * Math.cos(angle1);
			if(i1 != 0) {
				var t2 = new trilateral_tri_Trilateral(bx,by,bx5,by5,cx5,cy5);
				out2[out2.length] = t2;
			}
			angle1 += step3;
			bx5 = cx5;
			by5 = cy5;
		}
		var triArr1 = out2;
		var _g4 = 0;
		while(_g4 < triArr1.length) {
			var t3 = triArr1[_g4];
			++_g4;
			out[out.length] = t3;
		}
		var this21 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out3 = this21;
		var pi3 = Math.PI;
		var step4 = pi3 * 2 / 36;
		var dif10;
		switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE[1]) {
		case 0:
			var f16;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f16 = pi_2;
			} else {
				var a16 = pi_2 % (2 * Math.PI);
				if(a16 >= 0) {
					f16 = a16;
				} else {
					f16 = a16 + 2 * Math.PI;
				}
			}
			var this22 = f16;
			var za8 = this22;
			var f17;
			if(0 > Math.PI) {
				f17 = 0;
			} else {
				var a17 = 0 % (2 * Math.PI);
				if(a17 >= 0) {
					f17 = a17;
				} else {
					f17 = a17 + 2 * Math.PI;
				}
			}
			var this23 = f17;
			var zb8 = this23;
			var fa8 = pi_2;
			var fb8 = 0;
			var theta8 = Math.abs(pi_2);
			var clockwise8 = pi_2 < 0;
			var dif11 = clockwise8 ? theta8 : -theta8;
			if(dif11 > 0) {
				dif10 = dif11;
			} else {
				dif10 = 2 * Math.PI + dif11;
			}
			break;
		case 1:
			var f18;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f18 = pi_2;
			} else {
				var a18 = pi_2 % (2 * Math.PI);
				if(a18 >= 0) {
					f18 = a18;
				} else {
					f18 = a18 + 2 * Math.PI;
				}
			}
			var this24 = f18;
			var za9 = this24;
			var f19;
			if(0 > Math.PI) {
				f19 = 0;
			} else {
				var a19 = 0 % (2 * Math.PI);
				if(a19 >= 0) {
					f19 = a19;
				} else {
					f19 = a19 + 2 * Math.PI;
				}
			}
			var this25 = f19;
			var zb9 = this25;
			var fa9 = pi_2;
			var fb9 = 0;
			var theta9 = Math.abs(pi_2);
			var clockwise9 = pi_2 < 0;
			var dif12 = clockwise9 ? theta9 : -theta9;
			if(dif12 < 0) {
				dif10 = dif12;
			} else {
				dif10 = -2 * Math.PI + dif12;
			}
			break;
		case 2:
			var f20;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f20 = pi_2;
			} else {
				var a20 = pi_2 % (2 * Math.PI);
				if(a20 >= 0) {
					f20 = a20;
				} else {
					f20 = a20 + 2 * Math.PI;
				}
			}
			var this26 = f20;
			var za10 = this26;
			var f21;
			if(0 > Math.PI) {
				f21 = 0;
			} else {
				var a21 = 0 % (2 * Math.PI);
				if(a21 >= 0) {
					f21 = a21;
				} else {
					f21 = a21 + 2 * Math.PI;
				}
			}
			var this27 = f21;
			var zb10 = this27;
			var fa10 = pi_2;
			var fb10 = 0;
			var theta10 = Math.abs(pi_2);
			var smallest2 = theta10 <= Math.PI;
			var clockwise10 = pi_2 < 0;
			var dif13 = clockwise10 ? theta10 : -theta10;
			if(smallest2) {
				dif10 = dif13;
			} else if(clockwise10) {
				dif10 = -(2 * Math.PI - theta10);
			} else {
				dif10 = 2 * Math.PI - theta10;
			}
			break;
		case 3:
			var f22;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f22 = pi_2;
			} else {
				var a22 = pi_2 % (2 * Math.PI);
				if(a22 >= 0) {
					f22 = a22;
				} else {
					f22 = a22 + 2 * Math.PI;
				}
			}
			var this28 = f22;
			var za11 = this28;
			var f23;
			if(0 > Math.PI) {
				f23 = 0;
			} else {
				var a23 = 0 % (2 * Math.PI);
				if(a23 >= 0) {
					f23 = a23;
				} else {
					f23 = a23 + 2 * Math.PI;
				}
			}
			var this29 = f23;
			var zb11 = this29;
			var fa11 = pi_2;
			var fb11 = 0;
			var theta11 = Math.abs(pi_2);
			var largest2 = theta11 > Math.PI;
			var clockwise11 = pi_2 < 0;
			var dif14 = clockwise11 ? theta11 : -theta11;
			if(largest2) {
				dif10 = dif14;
			} else if(clockwise11) {
				dif10 = -(2 * Math.PI - theta11);
			} else {
				dif10 = 2 * Math.PI - theta11;
			}
			break;
		}
		var positive2 = dif10 >= 0;
		var totalSteps2 = Math.ceil(Math.abs(dif10) / step4);
		var step5 = dif10 / totalSteps2;
		var angle2 = pi_2;
		var cx6;
		var cy6;
		var bx6 = 0;
		var by6 = 0;
		var _g12 = 0;
		var _g5 = totalSteps2 + 1;
		while(_g12 < _g5) {
			var i2 = _g12++;
			cx6 = cx + radius * Math.sin(angle2);
			cy6 = cy + radius * Math.cos(angle2);
			if(i2 != 0) {
				var t4 = new trilateral_tri_Trilateral(cx,cy,bx6,by6,cx6,cy6);
				out3[out3.length] = t4;
			}
			angle2 += step5;
			bx6 = cx6;
			by6 = cy6;
		}
		var triArr2 = out3;
		var _g6 = 0;
		while(_g6 < triArr2.length) {
			var t5 = triArr2[_g6];
			++_g6;
			out[out.length] = t5;
		}
		var gamma1 = -pi_2;
		var this30 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out4 = this30;
		var pi4 = Math.PI;
		var step6 = pi4 * 2 / 36;
		var dif15;
		switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE[1]) {
		case 0:
			var f24;
			if(0 > Math.PI) {
				f24 = 0;
			} else {
				var a24 = 0 % (2 * Math.PI);
				if(a24 >= 0) {
					f24 = a24;
				} else {
					f24 = a24 + 2 * Math.PI;
				}
			}
			var this31 = f24;
			var za12 = this31;
			var f25;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f25 = gamma1;
			} else {
				var a25 = gamma1 % (2 * Math.PI);
				if(a25 >= 0) {
					f25 = a25;
				} else {
					f25 = a25 + 2 * Math.PI;
				}
			}
			var this32 = f25;
			var zb12 = this32;
			var fa12 = 0;
			var fb12 = gamma1;
			var theta12 = Math.abs(0 - gamma1);
			var clockwise12 = 0 < gamma1;
			var dif16 = clockwise12 ? theta12 : -theta12;
			if(dif16 > 0) {
				dif15 = dif16;
			} else {
				dif15 = 2 * Math.PI + dif16;
			}
			break;
		case 1:
			var f26;
			if(0 > Math.PI) {
				f26 = 0;
			} else {
				var a26 = 0 % (2 * Math.PI);
				if(a26 >= 0) {
					f26 = a26;
				} else {
					f26 = a26 + 2 * Math.PI;
				}
			}
			var this33 = f26;
			var za13 = this33;
			var f27;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f27 = gamma1;
			} else {
				var a27 = gamma1 % (2 * Math.PI);
				if(a27 >= 0) {
					f27 = a27;
				} else {
					f27 = a27 + 2 * Math.PI;
				}
			}
			var this34 = f27;
			var zb13 = this34;
			var fa13 = 0;
			var fb13 = gamma1;
			var theta13 = Math.abs(0 - gamma1);
			var clockwise13 = 0 < gamma1;
			var dif17 = clockwise13 ? theta13 : -theta13;
			if(dif17 < 0) {
				dif15 = dif17;
			} else {
				dif15 = -2 * Math.PI + dif17;
			}
			break;
		case 2:
			var f28;
			if(0 > Math.PI) {
				f28 = 0;
			} else {
				var a28 = 0 % (2 * Math.PI);
				if(a28 >= 0) {
					f28 = a28;
				} else {
					f28 = a28 + 2 * Math.PI;
				}
			}
			var this35 = f28;
			var za14 = this35;
			var f29;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f29 = gamma1;
			} else {
				var a29 = gamma1 % (2 * Math.PI);
				if(a29 >= 0) {
					f29 = a29;
				} else {
					f29 = a29 + 2 * Math.PI;
				}
			}
			var this36 = f29;
			var zb14 = this36;
			var fa14 = 0;
			var fb14 = gamma1;
			var theta14 = Math.abs(0 - gamma1);
			var smallest3 = theta14 <= Math.PI;
			var clockwise14 = 0 < gamma1;
			var dif18 = clockwise14 ? theta14 : -theta14;
			if(smallest3) {
				dif15 = dif18;
			} else if(clockwise14) {
				dif15 = -(2 * Math.PI - theta14);
			} else {
				dif15 = 2 * Math.PI - theta14;
			}
			break;
		case 3:
			var f30;
			if(0 > Math.PI) {
				f30 = 0;
			} else {
				var a30 = 0 % (2 * Math.PI);
				if(a30 >= 0) {
					f30 = a30;
				} else {
					f30 = a30 + 2 * Math.PI;
				}
			}
			var this37 = f30;
			var za15 = this37;
			var f31;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f31 = gamma1;
			} else {
				var a31 = gamma1 % (2 * Math.PI);
				if(a31 >= 0) {
					f31 = a31;
				} else {
					f31 = a31 + 2 * Math.PI;
				}
			}
			var this38 = f31;
			var zb15 = this38;
			var fa15 = 0;
			var fb15 = gamma1;
			var theta15 = Math.abs(0 - gamma1);
			var largest3 = theta15 > Math.PI;
			var clockwise15 = 0 < gamma1;
			var dif19 = clockwise15 ? theta15 : -theta15;
			if(largest3) {
				dif15 = dif19;
			} else if(clockwise15) {
				dif15 = -(2 * Math.PI - theta15);
			} else {
				dif15 = 2 * Math.PI - theta15;
			}
			break;
		}
		var positive3 = dif15 >= 0;
		var totalSteps3 = Math.ceil(Math.abs(dif15) / step6);
		var step7 = dif15 / totalSteps3;
		var angle3 = 0;
		var cx7;
		var cy7;
		var bx7 = 0;
		var by7 = 0;
		var _g13 = 0;
		var _g7 = totalSteps3 + 1;
		while(_g13 < _g7) {
			var i3 = _g13++;
			cx7 = dx + radius * Math.sin(angle3);
			cy7 = dy + radius * Math.cos(angle3);
			if(i3 != 0) {
				var t6 = new trilateral_tri_Trilateral(dx,dy,bx7,by7,cx7,cy7);
				out4[out4.length] = t6;
			}
			angle3 += step7;
			bx7 = cx7;
			by7 = cy7;
		}
		var triArr3 = out4;
		var _g8 = 0;
		while(_g8 < triArr3.length) {
			var t7 = triArr3[_g8];
			++_g8;
			out[out.length] = t7;
		}
		var triArr4 = out;
		var tri;
		var _g9 = 0;
		while(_g9 < triArr4.length) {
			var t8 = triArr4[_g9];
			++_g9;
			if(t8 != null) {
				var t9 = Type.createEmptyInstance(trilateral_tri_Triangle);
				t9.id = id;
				t9.ax = t8.ax;
				t9.ay = t8.ay;
				t9.bx = t8.bx;
				t9.by = t8.by;
				t9.cx = t8.cx;
				t9.cy = t8.cy;
				t9.mark = t8.mark;
				t9.depth = 0;
				t9.alpha = 1.;
				t9.colorID = color;
				t9.colorA = color;
				t9.colorB = color;
				t9.colorC = color;
				t9.windingAdjusted = t8.windingAdjusted;
				tri = t9;
				this1[this1.length] = tri;
			}
		}
		return this.refCount - 1;
	}
	,roundedRectangleOutline: function(x,y,width,height,thick,radius,color) {
		var this1 = this.triangles;
		var id = this.refCount++;
		var this2 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out = this2;
		var pi = Math.PI;
		var pi_2 = Math.PI / 2;
		var ax = x + radius;
		var ay = y + radius;
		var bx = x + width - radius;
		var by = y + radius;
		var cx = bx;
		var cy = y + height - radius;
		var dx = ax;
		var dy = cy;
		var tp_t1;
		var tp_t0;
		var ax1 = ax;
		var ay1 = y;
		var bx1 = ax + (width - radius * 2);
		var by1 = ay1;
		var cx1 = bx1;
		var cy1 = ay1 + thick;
		var dx1 = ax;
		var dy1 = cy1;
		tp_t0 = new trilateral_tri_Trilateral(ax1,ay1,bx1,by1,dx1,dy1);
		tp_t1 = new trilateral_tri_Trilateral(bx1,by1,cx1,cy1,dx1,dy1);
		out[out.length] = tp_t0;
		out[out.length] = tp_t1;
		var tp_t11;
		var tp_t01;
		var ax2 = ax;
		var ay2 = y + height - thick;
		var bx2 = ax + (width - radius * 2);
		var by2 = ay2;
		var cx2 = bx2;
		var cy2 = ay2 + thick;
		var dx2 = ax;
		var dy2 = cy2;
		tp_t01 = new trilateral_tri_Trilateral(ax2,ay2,bx2,by2,dx2,dy2);
		tp_t11 = new trilateral_tri_Trilateral(bx2,by2,cx2,cy2,dx2,dy2);
		out[out.length] = tp_t01;
		out[out.length] = tp_t11;
		var dimY = height - 2 * radius;
		var tp_t12;
		var tp_t02;
		var ax3 = x;
		var ay3 = ay;
		var bx3 = x + thick;
		var by3 = ay3;
		var cx3 = bx3;
		var cy3 = ay3 + dimY;
		var dx3 = x;
		var dy3 = cy3;
		tp_t02 = new trilateral_tri_Trilateral(ax3,ay3,bx3,by3,dx3,dy3);
		tp_t12 = new trilateral_tri_Trilateral(bx3,by3,cx3,cy3,dx3,dy3);
		out[out.length] = tp_t02;
		out[out.length] = tp_t12;
		var tp_t13;
		var tp_t03;
		var x1 = x + width - thick;
		var ax4 = x1;
		var ay4 = by;
		var bx4 = x1 + thick;
		var by4 = ay4;
		var cx4 = bx4;
		var cy4 = ay4 + dimY;
		var dx4 = x1;
		var dy4 = cy4;
		tp_t03 = new trilateral_tri_Trilateral(ax4,ay4,bx4,by4,dx4,dy4);
		tp_t13 = new trilateral_tri_Trilateral(bx4,by4,cx4,cy4,dx4,dy4);
		out[out.length] = tp_t03;
		out[out.length] = tp_t13;
		var beta = -pi;
		var gamma = -pi_2;
		var this3 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out1 = this3;
		var pi1 = Math.PI;
		var step = pi1 * 2 / 36;
		var dif;
		switch(trilateral_angle_DifferencePreference.CLOCKWISE[1]) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				if(a >= 0) {
					f = a;
				} else {
					f = a + 2 * Math.PI;
				}
			}
			var this4 = f;
			var za = this4;
			var f1;
			if(gamma >= 0 && gamma > Math.PI) {
				f1 = gamma;
			} else {
				var a1 = gamma % (2 * Math.PI);
				if(a1 >= 0) {
					f1 = a1;
				} else {
					f1 = a1 + 2 * Math.PI;
				}
			}
			var this5 = f1;
			var zb = this5;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			if(dif1 > 0) {
				dif = dif1;
			} else {
				dif = 2 * Math.PI + dif1;
			}
			break;
		case 1:
			var f2;
			if(beta >= 0 && beta > Math.PI) {
				f2 = beta;
			} else {
				var a2 = beta % (2 * Math.PI);
				if(a2 >= 0) {
					f2 = a2;
				} else {
					f2 = a2 + 2 * Math.PI;
				}
			}
			var this6 = f2;
			var za1 = this6;
			var f3;
			if(gamma >= 0 && gamma > Math.PI) {
				f3 = gamma;
			} else {
				var a3 = gamma % (2 * Math.PI);
				if(a3 >= 0) {
					f3 = a3;
				} else {
					f3 = a3 + 2 * Math.PI;
				}
			}
			var this7 = f3;
			var zb1 = this7;
			var fa1 = beta;
			var fb1 = gamma;
			var theta1 = Math.abs(beta - gamma);
			var clockwise1 = beta < gamma;
			var dif2 = clockwise1 ? theta1 : -theta1;
			if(dif2 < 0) {
				dif = dif2;
			} else {
				dif = -2 * Math.PI + dif2;
			}
			break;
		case 2:
			var f4;
			if(beta >= 0 && beta > Math.PI) {
				f4 = beta;
			} else {
				var a4 = beta % (2 * Math.PI);
				if(a4 >= 0) {
					f4 = a4;
				} else {
					f4 = a4 + 2 * Math.PI;
				}
			}
			var this8 = f4;
			var za2 = this8;
			var f5;
			if(gamma >= 0 && gamma > Math.PI) {
				f5 = gamma;
			} else {
				var a5 = gamma % (2 * Math.PI);
				if(a5 >= 0) {
					f5 = a5;
				} else {
					f5 = a5 + 2 * Math.PI;
				}
			}
			var this9 = f5;
			var zb2 = this9;
			var fa2 = beta;
			var fb2 = gamma;
			var theta2 = Math.abs(beta - gamma);
			var smallest = theta2 <= Math.PI;
			var clockwise2 = beta < gamma;
			var dif3 = clockwise2 ? theta2 : -theta2;
			if(smallest) {
				dif = dif3;
			} else if(clockwise2) {
				dif = -(2 * Math.PI - theta2);
			} else {
				dif = 2 * Math.PI - theta2;
			}
			break;
		case 3:
			var f6;
			if(beta >= 0 && beta > Math.PI) {
				f6 = beta;
			} else {
				var a6 = beta % (2 * Math.PI);
				if(a6 >= 0) {
					f6 = a6;
				} else {
					f6 = a6 + 2 * Math.PI;
				}
			}
			var this10 = f6;
			var za3 = this10;
			var f7;
			if(gamma >= 0 && gamma > Math.PI) {
				f7 = gamma;
			} else {
				var a7 = gamma % (2 * Math.PI);
				if(a7 >= 0) {
					f7 = a7;
				} else {
					f7 = a7 + 2 * Math.PI;
				}
			}
			var this11 = f7;
			var zb3 = this11;
			var fa3 = beta;
			var fb3 = gamma;
			var theta3 = Math.abs(beta - gamma);
			var largest = theta3 > Math.PI;
			var clockwise3 = beta < gamma;
			var dif4 = clockwise3 ? theta3 : -theta3;
			if(largest) {
				dif = dif4;
			} else if(clockwise3) {
				dif = -(2 * Math.PI - theta3);
			} else {
				dif = 2 * Math.PI - theta3;
			}
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step1 = dif / totalSteps;
		var angle = beta;
		var cx5;
		var cy5;
		var bx5 = 0;
		var by5 = 0;
		var dx5 = 0;
		var dy5 = 0;
		var ex = 0;
		var ey = 0;
		var r2 = radius - thick;
		var _g1 = 0;
		var _g = totalSteps + 1;
		while(_g1 < _g) {
			var i = _g1++;
			cx5 = ax + radius * Math.sin(angle);
			cy5 = ay + radius * Math.cos(angle);
			ex = ax + r2 * Math.sin(angle);
			ey = ay + r2 * Math.cos(angle);
			if(i != 0) {
				var t0 = new trilateral_tri_Trilateral(dx5,dy5,bx5,by5,cx5,cy5);
				var t1 = new trilateral_tri_Trilateral(dx5,dy5,cx5,cy5,ex,ey);
				out1[out1.length] = t0;
				out1[out1.length] = t1;
			}
			angle += step1;
			bx5 = cx5;
			by5 = cy5;
			dx5 = ex;
			dy5 = ey;
		}
		var triArr = out1;
		var _g2 = 0;
		while(_g2 < triArr.length) {
			var t = triArr[_g2];
			++_g2;
			out[out.length] = t;
		}
		var this12 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out2 = this12;
		var pi2 = Math.PI;
		var step2 = pi2 * 2 / 36;
		var dif5;
		switch(trilateral_angle_DifferencePreference.CLOCKWISE[1]) {
		case 0:
			var f8;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f8 = pi_2;
			} else {
				var a8 = pi_2 % (2 * Math.PI);
				if(a8 >= 0) {
					f8 = a8;
				} else {
					f8 = a8 + 2 * Math.PI;
				}
			}
			var this13 = f8;
			var za4 = this13;
			var f9;
			if(pi >= 0 && pi > Math.PI) {
				f9 = pi;
			} else {
				var a9 = pi % (2 * Math.PI);
				if(a9 >= 0) {
					f9 = a9;
				} else {
					f9 = a9 + 2 * Math.PI;
				}
			}
			var this14 = f9;
			var zb4 = this14;
			var fa4 = pi_2;
			var fb4 = pi;
			var theta4 = Math.abs(pi_2 - pi);
			var clockwise4 = pi_2 < pi;
			var dif6 = clockwise4 ? theta4 : -theta4;
			if(dif6 > 0) {
				dif5 = dif6;
			} else {
				dif5 = 2 * Math.PI + dif6;
			}
			break;
		case 1:
			var f10;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f10 = pi_2;
			} else {
				var a10 = pi_2 % (2 * Math.PI);
				if(a10 >= 0) {
					f10 = a10;
				} else {
					f10 = a10 + 2 * Math.PI;
				}
			}
			var this15 = f10;
			var za5 = this15;
			var f11;
			if(pi >= 0 && pi > Math.PI) {
				f11 = pi;
			} else {
				var a11 = pi % (2 * Math.PI);
				if(a11 >= 0) {
					f11 = a11;
				} else {
					f11 = a11 + 2 * Math.PI;
				}
			}
			var this16 = f11;
			var zb5 = this16;
			var fa5 = pi_2;
			var fb5 = pi;
			var theta5 = Math.abs(pi_2 - pi);
			var clockwise5 = pi_2 < pi;
			var dif7 = clockwise5 ? theta5 : -theta5;
			if(dif7 < 0) {
				dif5 = dif7;
			} else {
				dif5 = -2 * Math.PI + dif7;
			}
			break;
		case 2:
			var f12;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f12 = pi_2;
			} else {
				var a12 = pi_2 % (2 * Math.PI);
				if(a12 >= 0) {
					f12 = a12;
				} else {
					f12 = a12 + 2 * Math.PI;
				}
			}
			var this17 = f12;
			var za6 = this17;
			var f13;
			if(pi >= 0 && pi > Math.PI) {
				f13 = pi;
			} else {
				var a13 = pi % (2 * Math.PI);
				if(a13 >= 0) {
					f13 = a13;
				} else {
					f13 = a13 + 2 * Math.PI;
				}
			}
			var this18 = f13;
			var zb6 = this18;
			var fa6 = pi_2;
			var fb6 = pi;
			var theta6 = Math.abs(pi_2 - pi);
			var smallest1 = theta6 <= Math.PI;
			var clockwise6 = pi_2 < pi;
			var dif8 = clockwise6 ? theta6 : -theta6;
			if(smallest1) {
				dif5 = dif8;
			} else if(clockwise6) {
				dif5 = -(2 * Math.PI - theta6);
			} else {
				dif5 = 2 * Math.PI - theta6;
			}
			break;
		case 3:
			var f14;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f14 = pi_2;
			} else {
				var a14 = pi_2 % (2 * Math.PI);
				if(a14 >= 0) {
					f14 = a14;
				} else {
					f14 = a14 + 2 * Math.PI;
				}
			}
			var this19 = f14;
			var za7 = this19;
			var f15;
			if(pi >= 0 && pi > Math.PI) {
				f15 = pi;
			} else {
				var a15 = pi % (2 * Math.PI);
				if(a15 >= 0) {
					f15 = a15;
				} else {
					f15 = a15 + 2 * Math.PI;
				}
			}
			var this20 = f15;
			var zb7 = this20;
			var fa7 = pi_2;
			var fb7 = pi;
			var theta7 = Math.abs(pi_2 - pi);
			var largest1 = theta7 > Math.PI;
			var clockwise7 = pi_2 < pi;
			var dif9 = clockwise7 ? theta7 : -theta7;
			if(largest1) {
				dif5 = dif9;
			} else if(clockwise7) {
				dif5 = -(2 * Math.PI - theta7);
			} else {
				dif5 = 2 * Math.PI - theta7;
			}
			break;
		}
		var positive1 = dif5 >= 0;
		var totalSteps1 = Math.ceil(Math.abs(dif5) / step2);
		var step3 = dif5 / totalSteps1;
		var angle1 = pi_2;
		var cx6;
		var cy6;
		var bx6 = 0;
		var by6 = 0;
		var dx6 = 0;
		var dy6 = 0;
		var ex1 = 0;
		var ey1 = 0;
		var r21 = radius - thick;
		var _g11 = 0;
		var _g3 = totalSteps1 + 1;
		while(_g11 < _g3) {
			var i1 = _g11++;
			cx6 = bx + radius * Math.sin(angle1);
			cy6 = by + radius * Math.cos(angle1);
			ex1 = bx + r21 * Math.sin(angle1);
			ey1 = by + r21 * Math.cos(angle1);
			if(i1 != 0) {
				var t01 = new trilateral_tri_Trilateral(dx6,dy6,bx6,by6,cx6,cy6);
				var t11 = new trilateral_tri_Trilateral(dx6,dy6,cx6,cy6,ex1,ey1);
				out2[out2.length] = t01;
				out2[out2.length] = t11;
			}
			angle1 += step3;
			bx6 = cx6;
			by6 = cy6;
			dx6 = ex1;
			dy6 = ey1;
		}
		var triArr1 = out2;
		var _g4 = 0;
		while(_g4 < triArr1.length) {
			var t2 = triArr1[_g4];
			++_g4;
			out[out.length] = t2;
		}
		var this21 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out3 = this21;
		var pi3 = Math.PI;
		var step4 = pi3 * 2 / 36;
		var dif10;
		switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE[1]) {
		case 0:
			var f16;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f16 = pi_2;
			} else {
				var a16 = pi_2 % (2 * Math.PI);
				if(a16 >= 0) {
					f16 = a16;
				} else {
					f16 = a16 + 2 * Math.PI;
				}
			}
			var this22 = f16;
			var za8 = this22;
			var f17;
			if(0 > Math.PI) {
				f17 = 0;
			} else {
				var a17 = 0 % (2 * Math.PI);
				if(a17 >= 0) {
					f17 = a17;
				} else {
					f17 = a17 + 2 * Math.PI;
				}
			}
			var this23 = f17;
			var zb8 = this23;
			var fa8 = pi_2;
			var fb8 = 0;
			var theta8 = Math.abs(pi_2);
			var clockwise8 = pi_2 < 0;
			var dif11 = clockwise8 ? theta8 : -theta8;
			if(dif11 > 0) {
				dif10 = dif11;
			} else {
				dif10 = 2 * Math.PI + dif11;
			}
			break;
		case 1:
			var f18;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f18 = pi_2;
			} else {
				var a18 = pi_2 % (2 * Math.PI);
				if(a18 >= 0) {
					f18 = a18;
				} else {
					f18 = a18 + 2 * Math.PI;
				}
			}
			var this24 = f18;
			var za9 = this24;
			var f19;
			if(0 > Math.PI) {
				f19 = 0;
			} else {
				var a19 = 0 % (2 * Math.PI);
				if(a19 >= 0) {
					f19 = a19;
				} else {
					f19 = a19 + 2 * Math.PI;
				}
			}
			var this25 = f19;
			var zb9 = this25;
			var fa9 = pi_2;
			var fb9 = 0;
			var theta9 = Math.abs(pi_2);
			var clockwise9 = pi_2 < 0;
			var dif12 = clockwise9 ? theta9 : -theta9;
			if(dif12 < 0) {
				dif10 = dif12;
			} else {
				dif10 = -2 * Math.PI + dif12;
			}
			break;
		case 2:
			var f20;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f20 = pi_2;
			} else {
				var a20 = pi_2 % (2 * Math.PI);
				if(a20 >= 0) {
					f20 = a20;
				} else {
					f20 = a20 + 2 * Math.PI;
				}
			}
			var this26 = f20;
			var za10 = this26;
			var f21;
			if(0 > Math.PI) {
				f21 = 0;
			} else {
				var a21 = 0 % (2 * Math.PI);
				if(a21 >= 0) {
					f21 = a21;
				} else {
					f21 = a21 + 2 * Math.PI;
				}
			}
			var this27 = f21;
			var zb10 = this27;
			var fa10 = pi_2;
			var fb10 = 0;
			var theta10 = Math.abs(pi_2);
			var smallest2 = theta10 <= Math.PI;
			var clockwise10 = pi_2 < 0;
			var dif13 = clockwise10 ? theta10 : -theta10;
			if(smallest2) {
				dif10 = dif13;
			} else if(clockwise10) {
				dif10 = -(2 * Math.PI - theta10);
			} else {
				dif10 = 2 * Math.PI - theta10;
			}
			break;
		case 3:
			var f22;
			if(pi_2 >= 0 && pi_2 > Math.PI) {
				f22 = pi_2;
			} else {
				var a22 = pi_2 % (2 * Math.PI);
				if(a22 >= 0) {
					f22 = a22;
				} else {
					f22 = a22 + 2 * Math.PI;
				}
			}
			var this28 = f22;
			var za11 = this28;
			var f23;
			if(0 > Math.PI) {
				f23 = 0;
			} else {
				var a23 = 0 % (2 * Math.PI);
				if(a23 >= 0) {
					f23 = a23;
				} else {
					f23 = a23 + 2 * Math.PI;
				}
			}
			var this29 = f23;
			var zb11 = this29;
			var fa11 = pi_2;
			var fb11 = 0;
			var theta11 = Math.abs(pi_2);
			var largest2 = theta11 > Math.PI;
			var clockwise11 = pi_2 < 0;
			var dif14 = clockwise11 ? theta11 : -theta11;
			if(largest2) {
				dif10 = dif14;
			} else if(clockwise11) {
				dif10 = -(2 * Math.PI - theta11);
			} else {
				dif10 = 2 * Math.PI - theta11;
			}
			break;
		}
		var positive2 = dif10 >= 0;
		var totalSteps2 = Math.ceil(Math.abs(dif10) / step4);
		var step5 = dif10 / totalSteps2;
		var angle2 = pi_2;
		var cx7;
		var cy7;
		var bx7 = 0;
		var by7 = 0;
		var dx7 = 0;
		var dy7 = 0;
		var ex2 = 0;
		var ey2 = 0;
		var r22 = radius - thick;
		var _g12 = 0;
		var _g5 = totalSteps2 + 1;
		while(_g12 < _g5) {
			var i2 = _g12++;
			cx7 = cx + radius * Math.sin(angle2);
			cy7 = cy + radius * Math.cos(angle2);
			ex2 = cx + r22 * Math.sin(angle2);
			ey2 = cy + r22 * Math.cos(angle2);
			if(i2 != 0) {
				var t02 = new trilateral_tri_Trilateral(dx7,dy7,bx7,by7,cx7,cy7);
				var t12 = new trilateral_tri_Trilateral(dx7,dy7,cx7,cy7,ex2,ey2);
				out3[out3.length] = t02;
				out3[out3.length] = t12;
			}
			angle2 += step5;
			bx7 = cx7;
			by7 = cy7;
			dx7 = ex2;
			dy7 = ey2;
		}
		var triArr2 = out3;
		var _g6 = 0;
		while(_g6 < triArr2.length) {
			var t3 = triArr2[_g6];
			++_g6;
			out[out.length] = t3;
		}
		var gamma1 = -pi_2;
		var this30 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
		var out4 = this30;
		var pi4 = Math.PI;
		var step6 = pi4 * 2 / 36;
		var dif15;
		switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE[1]) {
		case 0:
			var f24;
			if(0 > Math.PI) {
				f24 = 0;
			} else {
				var a24 = 0 % (2 * Math.PI);
				if(a24 >= 0) {
					f24 = a24;
				} else {
					f24 = a24 + 2 * Math.PI;
				}
			}
			var this31 = f24;
			var za12 = this31;
			var f25;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f25 = gamma1;
			} else {
				var a25 = gamma1 % (2 * Math.PI);
				if(a25 >= 0) {
					f25 = a25;
				} else {
					f25 = a25 + 2 * Math.PI;
				}
			}
			var this32 = f25;
			var zb12 = this32;
			var fa12 = 0;
			var fb12 = gamma1;
			var theta12 = Math.abs(0 - gamma1);
			var clockwise12 = 0 < gamma1;
			var dif16 = clockwise12 ? theta12 : -theta12;
			if(dif16 > 0) {
				dif15 = dif16;
			} else {
				dif15 = 2 * Math.PI + dif16;
			}
			break;
		case 1:
			var f26;
			if(0 > Math.PI) {
				f26 = 0;
			} else {
				var a26 = 0 % (2 * Math.PI);
				if(a26 >= 0) {
					f26 = a26;
				} else {
					f26 = a26 + 2 * Math.PI;
				}
			}
			var this33 = f26;
			var za13 = this33;
			var f27;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f27 = gamma1;
			} else {
				var a27 = gamma1 % (2 * Math.PI);
				if(a27 >= 0) {
					f27 = a27;
				} else {
					f27 = a27 + 2 * Math.PI;
				}
			}
			var this34 = f27;
			var zb13 = this34;
			var fa13 = 0;
			var fb13 = gamma1;
			var theta13 = Math.abs(0 - gamma1);
			var clockwise13 = 0 < gamma1;
			var dif17 = clockwise13 ? theta13 : -theta13;
			if(dif17 < 0) {
				dif15 = dif17;
			} else {
				dif15 = -2 * Math.PI + dif17;
			}
			break;
		case 2:
			var f28;
			if(0 > Math.PI) {
				f28 = 0;
			} else {
				var a28 = 0 % (2 * Math.PI);
				if(a28 >= 0) {
					f28 = a28;
				} else {
					f28 = a28 + 2 * Math.PI;
				}
			}
			var this35 = f28;
			var za14 = this35;
			var f29;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f29 = gamma1;
			} else {
				var a29 = gamma1 % (2 * Math.PI);
				if(a29 >= 0) {
					f29 = a29;
				} else {
					f29 = a29 + 2 * Math.PI;
				}
			}
			var this36 = f29;
			var zb14 = this36;
			var fa14 = 0;
			var fb14 = gamma1;
			var theta14 = Math.abs(0 - gamma1);
			var smallest3 = theta14 <= Math.PI;
			var clockwise14 = 0 < gamma1;
			var dif18 = clockwise14 ? theta14 : -theta14;
			if(smallest3) {
				dif15 = dif18;
			} else if(clockwise14) {
				dif15 = -(2 * Math.PI - theta14);
			} else {
				dif15 = 2 * Math.PI - theta14;
			}
			break;
		case 3:
			var f30;
			if(0 > Math.PI) {
				f30 = 0;
			} else {
				var a30 = 0 % (2 * Math.PI);
				if(a30 >= 0) {
					f30 = a30;
				} else {
					f30 = a30 + 2 * Math.PI;
				}
			}
			var this37 = f30;
			var za15 = this37;
			var f31;
			if(gamma1 >= 0 && gamma1 > Math.PI) {
				f31 = gamma1;
			} else {
				var a31 = gamma1 % (2 * Math.PI);
				if(a31 >= 0) {
					f31 = a31;
				} else {
					f31 = a31 + 2 * Math.PI;
				}
			}
			var this38 = f31;
			var zb15 = this38;
			var fa15 = 0;
			var fb15 = gamma1;
			var theta15 = Math.abs(0 - gamma1);
			var largest3 = theta15 > Math.PI;
			var clockwise15 = 0 < gamma1;
			var dif19 = clockwise15 ? theta15 : -theta15;
			if(largest3) {
				dif15 = dif19;
			} else if(clockwise15) {
				dif15 = -(2 * Math.PI - theta15);
			} else {
				dif15 = 2 * Math.PI - theta15;
			}
			break;
		}
		var positive3 = dif15 >= 0;
		var totalSteps3 = Math.ceil(Math.abs(dif15) / step6);
		var step7 = dif15 / totalSteps3;
		var angle3 = 0;
		var cx8;
		var cy8;
		var bx8 = 0;
		var by8 = 0;
		var dx8 = 0;
		var dy8 = 0;
		var ex3 = 0;
		var ey3 = 0;
		var r23 = radius - thick;
		var _g13 = 0;
		var _g7 = totalSteps3 + 1;
		while(_g13 < _g7) {
			var i3 = _g13++;
			cx8 = dx + radius * Math.sin(angle3);
			cy8 = dy + radius * Math.cos(angle3);
			ex3 = dx + r23 * Math.sin(angle3);
			ey3 = dy + r23 * Math.cos(angle3);
			if(i3 != 0) {
				var t03 = new trilateral_tri_Trilateral(dx8,dy8,bx8,by8,cx8,cy8);
				var t13 = new trilateral_tri_Trilateral(dx8,dy8,cx8,cy8,ex3,ey3);
				out4[out4.length] = t03;
				out4[out4.length] = t13;
			}
			angle3 += step7;
			bx8 = cx8;
			by8 = cy8;
			dx8 = ex3;
			dy8 = ey3;
		}
		var triArr3 = out4;
		var _g8 = 0;
		while(_g8 < triArr3.length) {
			var t4 = triArr3[_g8];
			++_g8;
			out[out.length] = t4;
		}
		var triArr4 = out;
		var tri;
		var _g9 = 0;
		while(_g9 < triArr4.length) {
			var t5 = triArr4[_g9];
			++_g9;
			if(t5 != null) {
				var t6 = Type.createEmptyInstance(trilateral_tri_Triangle);
				t6.id = id;
				t6.ax = t5.ax;
				t6.ay = t5.ay;
				t6.bx = t5.bx;
				t6.by = t5.by;
				t6.cx = t5.cx;
				t6.cy = t5.cy;
				t6.mark = t5.mark;
				t6.depth = 0;
				t6.alpha = 1.;
				t6.colorID = color;
				t6.colorA = color;
				t6.colorB = color;
				t6.colorC = color;
				t6.windingAdjusted = t5.windingAdjusted;
				tri = t6;
				this1[this1.length] = tri;
			}
		}
		return this.refCount - 1;
	}
	,spiralLines: function(x,y,radius,nolines,startWid,stepWid,color) {
		var theta = 0.;
		var line;
		var wid = startWid;
		var _g1 = 0;
		var _g = nolines;
		while(_g1 < _g) {
			var i = _g1++;
			var p0_y;
			var p0_x = x;
			p0_y = y;
			var p1_y;
			var p1_x = x + radius * Math.sin(theta);
			p1_y = y + radius * Math.cos(theta);
			theta += Math.PI * 2 / nolines;
			var width = wid += stepWid;
			var q_D;
			var q_C;
			var q_B;
			var q_A;
			var dx = p0_x - p1_x;
			var dy = p0_y - p1_y;
			var P_y;
			var P_x = p0_x - width / 2;
			P_y = p0_y;
			var omega = Math.atan2(dy,dx);
			var dim_y;
			var dim_x = width;
			dim_y = dx * dx + dy * dy;
			var pivotX = p0_x + width / 2;
			var pivotY = p0_y;
			var px = P_x;
			var py = P_y;
			var dx1 = dim_x;
			var dy1 = dim_y;
			var A_ = { x : px, y : py};
			var B_ = { x : px + dx1, y : py};
			var C_ = { x : px + dx1, y : py + dy1};
			var D_ = { x : px, y : py + dy1};
			if(omega != 0.) {
				var sin = Math.sin(omega);
				var cos = Math.cos(omega);
				var px1 = A_.x - pivotX;
				var py1 = A_.y - pivotY;
				var px2 = px1 * cos - py1 * sin;
				py1 = py1 * cos + px1 * sin;
				A_ = { x : px2 + pivotX, y : py1 + pivotY};
				var px3 = B_.x - pivotX;
				var py2 = B_.y - pivotY;
				var px21 = px3 * cos - py2 * sin;
				py2 = py2 * cos + px3 * sin;
				B_ = { x : px21 + pivotX, y : py2 + pivotY};
				var px4 = C_.x - pivotX;
				var py3 = C_.y - pivotY;
				var px22 = px4 * cos - py3 * sin;
				py3 = py3 * cos + px4 * sin;
				C_ = { x : px22 + pivotX, y : py3 + pivotY};
				var px5 = D_.x - pivotX;
				var py4 = D_.y - pivotY;
				var px23 = px5 * cos - py4 * sin;
				py4 = py4 * cos + px5 * sin;
				D_ = { x : px23 + pivotX, y : py4 + pivotY};
			}
			q_A = A_;
			q_B = B_;
			q_C = C_;
			q_D = D_;
			line = { t0 : new trilateral_tri_Trilateral(q_A.x,q_A.y,q_B.x,q_B.y,q_D.x,q_D.y), t1 : new trilateral_tri_Trilateral(q_B.x,q_B.y,q_C.x,q_C.y,q_D.x,q_D.y)};
			var this1 = this.triangles;
			var id = this.refCount;
			var tri = line.t0;
			var t = Type.createEmptyInstance(trilateral_tri_Triangle);
			t.id = id;
			t.ax = tri.ax;
			t.ay = tri.ay;
			t.bx = tri.bx;
			t.by = tri.by;
			t.cx = tri.cx;
			t.cy = tri.cy;
			t.mark = tri.mark;
			t.depth = 0;
			t.alpha = 1.;
			t.colorID = color;
			t.colorA = color;
			t.colorB = color;
			t.colorC = color;
			t.windingAdjusted = tri.windingAdjusted;
			var tri0 = t;
			this1[this1.length] = tri0;
			var tri1 = line.t1;
			var t1 = Type.createEmptyInstance(trilateral_tri_Triangle);
			t1.id = id;
			t1.ax = tri1.ax;
			t1.ay = tri1.ay;
			t1.bx = tri1.bx;
			t1.by = tri1.by;
			t1.cx = tri1.cx;
			t1.cy = tri1.cy;
			t1.mark = tri1.mark;
			t1.depth = 0;
			t1.alpha = 1.;
			t1.colorID = color;
			t1.colorA = color;
			t1.colorB = color;
			t1.colorC = color;
			t1.windingAdjusted = tri1.windingAdjusted;
			var tri11 = t1;
			this1[this1.length] = tri11;
		}
		this.refCount++;
		return this.refCount - 1;
	}
	,__class__: trilateral_polys_Shapes
};
var trilateral_tri_Trilateral = function(ax_,ay_,bx_,by_,cx_,cy_,mark_) {
	if(mark_ == null) {
		mark_ = 0;
	}
	this.mark = 0;
	this.ax = ax_;
	this.ay = ay_;
	this.bx = bx_;
	this.by = by_;
	this.cx = cx_;
	this.cy = cy_;
	this.windingAdjusted = this.adjustWinding();
	if(this.windingAdjusted) {
		this.ax = ax_;
		this.ay = ay_;
		this.bx = cx_;
		this.by = cy_;
		this.cx = bx_;
		this.cy = by_;
	}
	this.mark = mark_;
};
$hxClasses["trilateral.tri.Trilateral"] = trilateral_tri_Trilateral;
trilateral_tri_Trilateral.__name__ = true;
trilateral_tri_Trilateral.prototype = {
	windingAdjusted: null
	,mark: null
	,ax: null
	,bx: null
	,cx: null
	,ay: null
	,by: null
	,cy: null
	,get_x: function() {
		return Math.min(Math.min(this.ax,this.bx),this.cx);
	}
	,set_x: function(x) {
		var dx = x - this.get_x();
		this.ax += dx;
		this.bx += dx;
		this.cx += dx;
		return x;
	}
	,get_y: function() {
		return Math.min(Math.min(this.ay,this.by),this.cy);
	}
	,set_y: function(y) {
		var dy = y - this.get_y();
		this.ay += dy;
		this.by += dy;
		this.cy += dy;
		return y;
	}
	,get_right: function() {
		return Math.max(Math.max(this.ax,this.bx),this.cx);
	}
	,get_bottom: function() {
		return Math.max(Math.max(this.ay,this.by),this.cy);
	}
	,moveDelta: function(dx,dy) {
		this.ax += dx;
		this.ay += dy;
		this.bx += dx;
		this.by += dy;
		this.cx += dx;
		this.cy += dy;
	}
	,liteHit: function(px,py) {
		var planeAB = (this.ax - px) * (this.by - py) - (this.bx - px) * (this.ay - py);
		var planeBC = (this.bx - px) * (this.cy - py) - (this.cx - px) * (this.by - py);
		var planeCA = (this.cx - px) * (this.ay - py) - (this.ax - px) * (this.cy - py);
		if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
			return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
		} else {
			return false;
		}
	}
	,fullHit: function(px,py) {
		if(px > this.get_x() && px < this.get_right() && py > this.get_y() && py < this.get_bottom()) {
			return true;
		}
		var planeAB = (this.ax - px) * (this.by - py) - (this.bx - px) * (this.ay - py);
		var planeBC = (this.bx - px) * (this.cy - py) - (this.cx - px) * (this.by - py);
		var planeCA = (this.cx - px) * (this.ay - py) - (this.ax - px) * (this.cy - py);
		if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
			return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
		} else {
			return false;
		}
	}
	,adjustWinding: function() {
		return this.ax * this.by - this.bx * this.ay + (this.bx * this.cy - this.cx * this.by) + (this.cx * this.ay - this.ax * this.cy) > 0;
	}
	,rotate: function(x,y,theta) {
		var cos = Math.cos(theta);
		var sin = Math.sin(theta);
		this.ax -= x;
		this.ay -= y;
		this.bx -= x;
		this.by -= y;
		this.cx -= x;
		this.cy -= y;
		var dx;
		var dy;
		dx = this.ax;
		dy = this.ay;
		this.ax = dx * cos - dy * sin;
		this.ay = dx * sin + dy * cos;
		dx = this.bx;
		dy = this.by;
		this.bx = dx * cos - dy * sin;
		this.by = dx * sin + dy * cos;
		dx = this.cx;
		dy = this.cy;
		this.cx = dx * cos - dy * sin;
		this.cy = dx * sin + dy * cos;
		this.ax += x;
		this.ay += y;
		this.bx += x;
		this.by += y;
		this.cx += x;
		this.cy += y;
	}
	,rotateTrig: function(x,y,cos,sin) {
		this.ax -= x;
		this.ay -= y;
		this.bx -= x;
		this.by -= y;
		this.cx -= x;
		this.cy -= y;
		var dx;
		var dy;
		dx = this.ax;
		dy = this.ay;
		this.ax = dx * cos - dy * sin;
		this.ay = dx * sin + dy * cos;
		dx = this.bx;
		dy = this.by;
		this.bx = dx * cos - dy * sin;
		this.by = dx * sin + dy * cos;
		dx = this.cx;
		dy = this.cy;
		this.cx = dx * cos - dy * sin;
		this.cy = dx * sin + dy * cos;
		this.ax += x;
		this.ay += y;
		this.bx += x;
		this.by += y;
		this.cx += x;
		this.cy += y;
	}
	,__class__: trilateral_tri_Trilateral
};
var trilateral_tri_Triangle = function(id_,A,B,C,depth_,colorID_) {
	this.id = id_;
	trilateral_tri_Trilateral.call(this,A.x,A.y,B.x,B.y,C.x,C.y);
	this.depth = depth_;
	this.alpha = 1.;
	this.colorID = colorID_;
	this.colorA = colorID_;
	this.colorB = colorID_;
	this.colorC = colorID_;
};
$hxClasses["trilateral.tri.Triangle"] = trilateral_tri_Triangle;
trilateral_tri_Triangle.__name__ = true;
trilateral_tri_Triangle.fromTrilateral = function(id_,tri,depth_,colorID_) {
	var t = Type.createEmptyInstance(trilateral_tri_Triangle);
	t.id = id_;
	t.ax = tri.ax;
	t.ay = tri.ay;
	t.bx = tri.bx;
	t.by = tri.by;
	t.cx = tri.cx;
	t.cy = tri.cy;
	t.mark = tri.mark;
	t.depth = depth_;
	t.alpha = 1.;
	t.colorID = colorID_;
	t.colorA = colorID_;
	t.colorB = colorID_;
	t.colorC = colorID_;
	t.windingAdjusted = tri.windingAdjusted;
	return t;
};
trilateral_tri_Triangle.__super__ = trilateral_tri_Trilateral;
trilateral_tri_Triangle.prototype = $extend(trilateral_tri_Trilateral.prototype,{
	id: null
	,colorID: null
	,colorA: null
	,colorB: null
	,colorC: null
	,depth: null
	,alpha: null
	,hitTest: function(P) {
		return this.fullHit(P.x,P.y);
	}
	,drawStrips: function(drawRect) {
		var xi = Math.floor(this.get_x());
		var yi = Math.floor(this.get_y());
		var righti = Math.ceil(this.get_right());
		var bottomi = Math.ceil(this.get_bottom());
		var sx = 0;
		var ex = 0;
		var sFound;
		var eFound;
		var _g1 = yi;
		var _g = bottomi;
		while(_g1 < _g) {
			var y0 = _g1++;
			sFound = false;
			eFound = false;
			var _g3 = xi;
			var _g2 = righti;
			while(_g3 < _g2) {
				var x0 = _g3++;
				var planeAB = (this.ax - x0) * (this.by - y0) - (this.bx - x0) * (this.ay - y0);
				var planeBC = (this.bx - x0) * (this.cy - y0) - (this.cx - x0) * (this.by - y0);
				var planeCA = (this.cx - x0) * (this.ay - y0) - (this.ax - x0) * (this.cy - y0);
				if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0) && (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0)) {
					sx = x0;
					sFound = true;
					break;
				}
			}
			if(sFound) {
				var _g31 = sx;
				var _g21 = righti;
				while(_g31 < _g21) {
					var x01 = _g31++;
					var planeAB1 = (this.ax - x01) * (this.by - y0) - (this.bx - x01) * (this.ay - y0);
					var planeBC1 = (this.bx - x01) * (this.cy - y0) - (this.cx - x01) * (this.by - y0);
					var planeCA1 = (this.cx - x01) * (this.ay - y0) - (this.ax - x01) * (this.cy - y0);
					if(!((Math.abs(planeAB1) / planeAB1 | 0) == (Math.abs(planeBC1) / planeBC1 | 0) && (Math.abs(planeBC1) / planeBC1 | 0) == (Math.abs(planeCA1) / planeCA1 | 0))) {
						ex = x01;
						eFound = true;
						break;
					}
				}
				if(eFound) {
					drawRect(sx,y0,ex - sx,1);
				}
			}
		}
	}
	,__class__: trilateral_tri_Triangle
});
var trilateral_tri__$TriangleArray_TriangleArray_$Impl_$ = {};
$hxClasses["trilateral.tri._TriangleArray.TriangleArray_Impl_"] = trilateral_tri__$TriangleArray_TriangleArray_$Impl_$;
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.__name__ = true;
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new = function(t) {
	var this1 = t == null ? trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]) : t;
	return this1;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.changeFillColorByID = function(this1,id,colorID,startID,endID) {
	if(endID == null) {
		endID = 0;
	}
	if(startID == null) {
		startID = 0;
	}
	var tri;
	if(endID == 0) {
		endID = this1.length;
	}
	var _g1 = startID;
	var _g = endID;
	while(_g1 < _g) {
		var i = _g1++;
		tri = this1[i];
		if(tri.id == id) {
			tri.colorID = colorID;
			tri.colorA = colorID;
			tri.colorB = colorID;
			tri.colorC = colorID;
		}
	}
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.getEmpty = function() {
	return trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]);
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.clear = function(this1) {
	var this2 = trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]);
	this1 = this2;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.pushPair = function(this1,tp) {
	this1[this1.length] = tp.t0;
	this1[this1.length] = tp.t1;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.drawTriangle = function(this1,id,p0,p1,p2,colorID) {
	var tri = new trilateral_tri_Triangle(id,p0,p1,p2,0,colorID);
	this1[this1.length] = tri;
	return tri;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.add = function(this1,id,tri,colorID) {
	var t = Type.createEmptyInstance(trilateral_tri_Triangle);
	t.id = id;
	t.ax = tri.ax;
	t.ay = tri.ay;
	t.bx = tri.bx;
	t.by = tri.by;
	t.cx = tri.cx;
	t.cy = tri.cy;
	t.mark = tri.mark;
	t.depth = 0;
	t.alpha = 1.;
	t.colorID = colorID;
	t.colorA = colorID;
	t.colorB = colorID;
	t.colorC = colorID;
	t.windingAdjusted = tri.windingAdjusted;
	var tri1 = t;
	this1[this1.length] = tri1;
	return tri1;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.addPair = function(this1,id,tri,colorID) {
	var tri1 = tri.t0;
	var t = Type.createEmptyInstance(trilateral_tri_Triangle);
	t.id = id;
	t.ax = tri1.ax;
	t.ay = tri1.ay;
	t.bx = tri1.bx;
	t.by = tri1.by;
	t.cx = tri1.cx;
	t.cy = tri1.cy;
	t.mark = tri1.mark;
	t.depth = 0;
	t.alpha = 1.;
	t.colorID = colorID;
	t.colorA = colorID;
	t.colorB = colorID;
	t.colorC = colorID;
	t.windingAdjusted = tri1.windingAdjusted;
	var tri0 = t;
	this1[this1.length] = tri0;
	var tri2 = tri.t1;
	var t1 = Type.createEmptyInstance(trilateral_tri_Triangle);
	t1.id = id;
	t1.ax = tri2.ax;
	t1.ay = tri2.ay;
	t1.bx = tri2.bx;
	t1.by = tri2.by;
	t1.cx = tri2.cx;
	t1.cy = tri2.cy;
	t1.mark = tri2.mark;
	t1.depth = 0;
	t1.alpha = 1.;
	t1.colorID = colorID;
	t1.colorA = colorID;
	t1.colorB = colorID;
	t1.colorC = colorID;
	t1.windingAdjusted = tri2.windingAdjusted;
	var tri11 = t1;
	this1[this1.length] = tri11;
	return tri;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.addArray = function(this1,id,triArr,colorID) {
	var tri;
	var _g = 0;
	while(_g < triArr.length) {
		var t = triArr[_g];
		++_g;
		if(t != null) {
			var t1 = Type.createEmptyInstance(trilateral_tri_Triangle);
			t1.id = id;
			t1.ax = t.ax;
			t1.ay = t.ay;
			t1.bx = t.bx;
			t1.by = t.by;
			t1.cx = t.cx;
			t1.cy = t.cy;
			t1.mark = t.mark;
			t1.depth = 0;
			t1.alpha = 1.;
			t1.colorID = colorID;
			t1.colorA = colorID;
			t1.colorB = colorID;
			t1.colorC = colorID;
			t1.windingAdjusted = t.windingAdjusted;
			tri = t1;
			this1[this1.length] = tri;
		}
	}
	return triArr;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.getTriangles = function(this1,id) {
	var this2 = trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]);
	var out = this2;
	var _g1 = 0;
	var _g = this1.length;
	while(_g1 < _g) {
		var i = _g1++;
		if(this1[i].id == id) {
			out[out.length] = this1[i];
		}
	}
	return out;
};
trilateral_tri__$TriangleArray_TriangleArray_$Impl_$.getHitTriangles = function(this1,p) {
	var this2 = trilateral_tri__$TriangleArray_TriangleArray_$Impl_$._new([]);
	var out = this2;
	var _g1 = 0;
	var _g = this1.length;
	while(_g1 < _g) {
		var i = _g1++;
		if(this1[i].hitTest(p)) {
			out[out.length] = this1[i];
		}
	}
	return out;
};
var trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$ = {};
$hxClasses["trilateral.tri._TrilateralArray.TrilateralArray_Impl_"] = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$;
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.__name__ = true;
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new = function(t) {
	var this1 = t == null ? trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]) : t;
	return this1;
};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.reversed = function(this1) {
	this1.reverse();
	return this1;
};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.getEmpty = function() {
	return trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.clear = function(this1) {
	var this2 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
	this1 = this2;
};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.add = function(this1,tri) {
	this1[this1.length] = tri;
};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.addPair = function(this1,tp) {
	this1[this1.length] = tp.t0;
	this1[this1.length] = tp.t1;
};
trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$.addArray = function(this1,triArr) {
	var _g = 0;
	while(_g < triArr.length) {
		var t = triArr[_g];
		++_g;
		this1[this1.length] = t;
	}
	return triArr;
};
var trilateralXtra_segment_PixelShape = $hxClasses["trilateralXtra.segment.PixelShape"] = { __ename__ : true, __constructs__ : ["Circle","Square","LandScape","Portrait","Star","RoundedLandScape","RoundedPortrait"] };
trilateralXtra_segment_PixelShape.Circle = ["Circle",0];
trilateralXtra_segment_PixelShape.Circle.toString = $estr;
trilateralXtra_segment_PixelShape.Circle.__enum__ = trilateralXtra_segment_PixelShape;
trilateralXtra_segment_PixelShape.Square = ["Square",1];
trilateralXtra_segment_PixelShape.Square.toString = $estr;
trilateralXtra_segment_PixelShape.Square.__enum__ = trilateralXtra_segment_PixelShape;
trilateralXtra_segment_PixelShape.LandScape = ["LandScape",2];
trilateralXtra_segment_PixelShape.LandScape.toString = $estr;
trilateralXtra_segment_PixelShape.LandScape.__enum__ = trilateralXtra_segment_PixelShape;
trilateralXtra_segment_PixelShape.Portrait = ["Portrait",3];
trilateralXtra_segment_PixelShape.Portrait.toString = $estr;
trilateralXtra_segment_PixelShape.Portrait.__enum__ = trilateralXtra_segment_PixelShape;
trilateralXtra_segment_PixelShape.Star = ["Star",4];
trilateralXtra_segment_PixelShape.Star.toString = $estr;
trilateralXtra_segment_PixelShape.Star.__enum__ = trilateralXtra_segment_PixelShape;
trilateralXtra_segment_PixelShape.RoundedLandScape = ["RoundedLandScape",5];
trilateralXtra_segment_PixelShape.RoundedLandScape.toString = $estr;
trilateralXtra_segment_PixelShape.RoundedLandScape.__enum__ = trilateralXtra_segment_PixelShape;
trilateralXtra_segment_PixelShape.RoundedPortrait = ["RoundedPortrait",6];
trilateralXtra_segment_PixelShape.RoundedPortrait.toString = $estr;
trilateralXtra_segment_PixelShape.RoundedPortrait.__enum__ = trilateralXtra_segment_PixelShape;
var trilateralXtra_segment_Character5x7 = function(shapes_,pixelShape_,onColor_,offColor_,bgColor_,ratio_) {
	this.ratio = this.ratio == null ? 1.4 : ratio_;
	this.pixelShape = pixelShape_;
	this.shapes = shapes_;
	this.onColor = onColor_;
	this.offColor = offColor_;
	this.bgColor = bgColor_;
};
$hxClasses["trilateralXtra.segment.Character5x7"] = trilateralXtra_segment_Character5x7;
trilateralXtra_segment_Character5x7.__name__ = true;
trilateralXtra_segment_Character5x7.prototype = {
	shapes: null
	,ratio: null
	,bgIndex: null
	,shapeIndex: null
	,endIndex: null
	,onColor: null
	,offColor: null
	,bgColor: null
	,dotMatrix: null
	,pixelShape: null
	,updateColor: function() {
		if(this.dotMatrix != null) {
			var first = 0;
			var count = this.shapeIndex;
			var tris = this.shapes.triangles;
			var len = tris.length;
			var total = 35;
			var _g1 = 0;
			var _g = len;
			while(_g1 < _g) {
				var i = _g1++;
				if(tris[i].id == count) {
					first = i;
					break;
				}
			}
			var triangle = tris[first];
			var _g11 = 0;
			var _g2 = total;
			while(_g11 < _g2) {
				var dotId = _g11++;
				var isOn = trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$.valueByIndex(this.dotMatrix,dotId,5);
				var triangle1 = tris[first];
				while(triangle1.id == count) {
					if(isOn) {
						triangle1.colorID = this.onColor;
					} else {
						triangle1.colorID = this.offColor;
					}
					++first;
					triangle1 = tris[first];
					if(triangle1 == null) {
						break;
					}
				}
				++count;
			}
		}
	}
	,draw: function(x,y,w,h,radius,bevel) {
		this.bgIndex = this.shapes.refCount;
		this.shapeIndex = this.bgIndex + 1;
		var colorID = this.offColor;
		var radiusW;
		var radiusH;
		var _g = this.pixelShape;
		switch(_g[1]) {
		case 0:
			radiusW = radius;
			radiusH = radius;
			break;
		case 1:
			radiusW = radius;
			radiusH = radius;
			break;
		case 2:
			radiusW = radius * this.ratio;
			radiusH = radius;
			break;
		case 3:
			radiusW = radius;
			radiusH = radius * this.ratio;
			break;
		case 4:
			radiusW = radius;
			radiusH = radius;
			break;
		case 5:
			radiusW = radius * this.ratio;
			radiusH = radius;
			break;
		case 6:
			radiusW = radius;
			radiusH = radius * this.ratio;
			break;
		}
		var dx = (w - radiusW - bevel * 2) / 4;
		var dy = (h - radiusH - bevel * 2) / 6;
		var _this = this.shapes;
		var color = this.bgColor;
		var this1 = _this.triangles;
		var id = _this.refCount++;
		var ax = x;
		var ay = y;
		var bx = x + w;
		var by = ay;
		var cx = bx;
		var cy = ay + h;
		var dx1 = x;
		var dy1 = cy;
		var tri = { t0 : new trilateral_tri_Trilateral(ax,ay,bx,by,dx1,dy1), t1 : new trilateral_tri_Trilateral(bx,by,cx,cy,dx1,dy1)};
		var tri1 = tri.t0;
		var t = Type.createEmptyInstance(trilateral_tri_Triangle);
		t.id = id;
		t.ax = tri1.ax;
		t.ay = tri1.ay;
		t.bx = tri1.bx;
		t.by = tri1.by;
		t.cx = tri1.cx;
		t.cy = tri1.cy;
		t.mark = tri1.mark;
		t.depth = 0;
		t.alpha = 1.;
		t.colorID = color;
		t.colorA = color;
		t.colorB = color;
		t.colorC = color;
		t.windingAdjusted = tri1.windingAdjusted;
		var tri0 = t;
		this1[this1.length] = tri0;
		var tri2 = tri.t1;
		var t1 = Type.createEmptyInstance(trilateral_tri_Triangle);
		t1.id = id;
		t1.ax = tri2.ax;
		t1.ay = tri2.ay;
		t1.bx = tri2.bx;
		t1.by = tri2.by;
		t1.cx = tri2.cx;
		t1.cy = tri2.cy;
		t1.mark = tri2.mark;
		t1.depth = 0;
		t1.alpha = 1.;
		t1.colorID = color;
		t1.colorA = color;
		t1.colorB = color;
		t1.colorC = color;
		t1.windingAdjusted = tri2.windingAdjusted;
		var tri11 = t1;
		this1[this1.length] = tri11;
		var startX = x + bevel + radiusW / 2;
		var startY = y + bevel + radiusH / 2;
		var px = startX;
		var py = startY;
		var _g1 = 0;
		while(_g1 < 7) {
			var col = _g1++;
			var _g2 = 0;
			while(_g2 < 5) {
				var i = _g2++;
				var _g3 = this.pixelShape;
				switch(_g3[1]) {
				case 0:
					var _this1 = this.shapes;
					var this2 = _this1.triangles;
					var id1 = _this1.refCount++;
					var this3 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
					var out = this3;
					var pi = Math.PI;
					var theta = pi / 2;
					var step = pi * 2 / 36;
					var bx1;
					var by1;
					var cx1;
					var cy1;
					var _g11 = 0;
					var _g4 = 36;
					while(_g11 < _g4) {
						var i1 = _g11++;
						bx1 = px + radius * Math.sin(theta);
						by1 = py + radius * Math.cos(theta);
						theta += step;
						cx1 = px + radius * Math.sin(theta);
						cy1 = py + radius * Math.cos(theta);
						var tri3 = new trilateral_tri_Trilateral(px,py,bx1,by1,cx1,cy1);
						out[out.length] = tri3;
					}
					var triArr = out;
					var tri4;
					var _g5 = 0;
					while(_g5 < triArr.length) {
						var t2 = triArr[_g5];
						++_g5;
						if(t2 != null) {
							var t3 = Type.createEmptyInstance(trilateral_tri_Triangle);
							t3.id = id1;
							t3.ax = t2.ax;
							t3.ay = t2.ay;
							t3.bx = t2.bx;
							t3.by = t2.by;
							t3.cx = t2.cx;
							t3.cy = t2.cy;
							t3.mark = t2.mark;
							t3.depth = 0;
							t3.alpha = 1.;
							t3.colorID = colorID;
							t3.colorA = colorID;
							t3.colorB = colorID;
							t3.colorC = colorID;
							t3.windingAdjusted = t2.windingAdjusted;
							tri4 = t3;
							this2[this2.length] = tri4;
						}
					}
					break;
				case 1:
					var _this2 = this.shapes;
					var this4 = _this2.triangles;
					var id2 = _this2.refCount++;
					var ax1 = 0.;
					var ay1 = 0.;
					var bx2 = 0.;
					var by2 = 0.;
					var cx2 = 0.;
					var cy2 = 0.;
					var dx2 = 0.;
					var dy2 = 0.;
					ax1 = px - radius;
					ay1 = py - radius;
					var lx = radius * 2;
					var ly = lx;
					bx2 = ax1 + lx;
					by2 = ay1;
					cx2 = bx2;
					cy2 = ay1 + ly;
					dx2 = ax1;
					dy2 = cy2;
					var tri5 = { t0 : new trilateral_tri_Trilateral(ax1,ay1,bx2,by2,dx2,dy2), t1 : new trilateral_tri_Trilateral(bx2,by2,cx2,cy2,dx2,dy2)};
					var tri6 = tri5.t0;
					var t4 = Type.createEmptyInstance(trilateral_tri_Triangle);
					t4.id = id2;
					t4.ax = tri6.ax;
					t4.ay = tri6.ay;
					t4.bx = tri6.bx;
					t4.by = tri6.by;
					t4.cx = tri6.cx;
					t4.cy = tri6.cy;
					t4.mark = tri6.mark;
					t4.depth = 0;
					t4.alpha = 1.;
					t4.colorID = colorID;
					t4.colorA = colorID;
					t4.colorB = colorID;
					t4.colorC = colorID;
					t4.windingAdjusted = tri6.windingAdjusted;
					var tri01 = t4;
					this4[this4.length] = tri01;
					var tri7 = tri5.t1;
					var t5 = Type.createEmptyInstance(trilateral_tri_Triangle);
					t5.id = id2;
					t5.ax = tri7.ax;
					t5.ay = tri7.ay;
					t5.bx = tri7.bx;
					t5.by = tri7.by;
					t5.cx = tri7.cx;
					t5.cy = tri7.cy;
					t5.mark = tri7.mark;
					t5.depth = 0;
					t5.alpha = 1.;
					t5.colorID = colorID;
					t5.colorA = colorID;
					t5.colorB = colorID;
					t5.colorC = colorID;
					t5.windingAdjusted = tri7.windingAdjusted;
					var tri12 = t5;
					this4[this4.length] = tri12;
					break;
				case 2:
					var _this3 = this.shapes;
					var x1 = px - radiusW;
					var this5 = _this3.triangles;
					var id3 = _this3.refCount++;
					var ax2 = x1;
					var ay2 = py - radiusH;
					var bx3 = x1 + radiusW * 2;
					var by3 = ay2;
					var cx3 = bx3;
					var cy3 = ay2 + radiusH * 2;
					var dx3 = x1;
					var dy3 = cy3;
					var tri8 = { t0 : new trilateral_tri_Trilateral(ax2,ay2,bx3,by3,dx3,dy3), t1 : new trilateral_tri_Trilateral(bx3,by3,cx3,cy3,dx3,dy3)};
					var tri9 = tri8.t0;
					var t6 = Type.createEmptyInstance(trilateral_tri_Triangle);
					t6.id = id3;
					t6.ax = tri9.ax;
					t6.ay = tri9.ay;
					t6.bx = tri9.bx;
					t6.by = tri9.by;
					t6.cx = tri9.cx;
					t6.cy = tri9.cy;
					t6.mark = tri9.mark;
					t6.depth = 0;
					t6.alpha = 1.;
					t6.colorID = colorID;
					t6.colorA = colorID;
					t6.colorB = colorID;
					t6.colorC = colorID;
					t6.windingAdjusted = tri9.windingAdjusted;
					var tri02 = t6;
					this5[this5.length] = tri02;
					var tri10 = tri8.t1;
					var t7 = Type.createEmptyInstance(trilateral_tri_Triangle);
					t7.id = id3;
					t7.ax = tri10.ax;
					t7.ay = tri10.ay;
					t7.bx = tri10.bx;
					t7.by = tri10.by;
					t7.cx = tri10.cx;
					t7.cy = tri10.cy;
					t7.mark = tri10.mark;
					t7.depth = 0;
					t7.alpha = 1.;
					t7.colorID = colorID;
					t7.colorA = colorID;
					t7.colorB = colorID;
					t7.colorC = colorID;
					t7.windingAdjusted = tri10.windingAdjusted;
					var tri13 = t7;
					this5[this5.length] = tri13;
					break;
				case 3:
					var _this4 = this.shapes;
					var x2 = px - radiusW;
					var this6 = _this4.triangles;
					var id4 = _this4.refCount++;
					var ax3 = x2;
					var ay3 = py - radiusH;
					var bx4 = x2 + radiusW * 2;
					var by4 = ay3;
					var cx4 = bx4;
					var cy4 = ay3 + radiusH * 2;
					var dx4 = x2;
					var dy4 = cy4;
					var tri14 = { t0 : new trilateral_tri_Trilateral(ax3,ay3,bx4,by4,dx4,dy4), t1 : new trilateral_tri_Trilateral(bx4,by4,cx4,cy4,dx4,dy4)};
					var tri15 = tri14.t0;
					var t8 = Type.createEmptyInstance(trilateral_tri_Triangle);
					t8.id = id4;
					t8.ax = tri15.ax;
					t8.ay = tri15.ay;
					t8.bx = tri15.bx;
					t8.by = tri15.by;
					t8.cx = tri15.cx;
					t8.cy = tri15.cy;
					t8.mark = tri15.mark;
					t8.depth = 0;
					t8.alpha = 1.;
					t8.colorID = colorID;
					t8.colorA = colorID;
					t8.colorB = colorID;
					t8.colorC = colorID;
					t8.windingAdjusted = tri15.windingAdjusted;
					var tri03 = t8;
					this6[this6.length] = tri03;
					var tri16 = tri14.t1;
					var t9 = Type.createEmptyInstance(trilateral_tri_Triangle);
					t9.id = id4;
					t9.ax = tri16.ax;
					t9.ay = tri16.ay;
					t9.bx = tri16.bx;
					t9.by = tri16.by;
					t9.cx = tri16.cx;
					t9.cy = tri16.cy;
					t9.mark = tri16.mark;
					t9.depth = 0;
					t9.alpha = 1.;
					t9.colorID = colorID;
					t9.colorA = colorID;
					t9.colorB = colorID;
					t9.colorC = colorID;
					t9.windingAdjusted = tri16.windingAdjusted;
					var tri17 = t9;
					this6[this6.length] = tri17;
					break;
				case 4:
					var _this5 = this.shapes;
					var this7 = _this5.triangles;
					var id5 = _this5.refCount++;
					var pi1 = Math.PI;
					var omega = -pi1;
					var a0x = px + radius * Math.sin(omega);
					var a0y = py + radius * Math.cos(omega);
					omega += pi1 / 3;
					var a1x = px + radius * Math.sin(omega);
					var a1y = py + radius * Math.cos(omega);
					omega += pi1 / 3;
					var b0x = px + radius * Math.sin(omega);
					var b0y = py + radius * Math.cos(omega);
					omega += pi1 / 3;
					var b1x = px + radius * Math.sin(omega);
					var b1y = py + radius * Math.cos(omega);
					omega += pi1 / 3;
					var c0x = px + radius * Math.sin(omega);
					var c0y = py + radius * Math.cos(omega);
					omega += pi1 / 3;
					var c1x = px + radius * Math.sin(omega);
					var c1y = py + radius * Math.cos(omega);
					var tri18 = { t0 : new trilateral_tri_Trilateral(a0x,a0y,b0x,b0y,c0x,c0y), t1 : new trilateral_tri_Trilateral(a1x,a1y,b1x,b1y,c1x,c1y)};
					var tri19 = tri18.t0;
					var t10 = Type.createEmptyInstance(trilateral_tri_Triangle);
					t10.id = id5;
					t10.ax = tri19.ax;
					t10.ay = tri19.ay;
					t10.bx = tri19.bx;
					t10.by = tri19.by;
					t10.cx = tri19.cx;
					t10.cy = tri19.cy;
					t10.mark = tri19.mark;
					t10.depth = 0;
					t10.alpha = 1.;
					t10.colorID = colorID;
					t10.colorA = colorID;
					t10.colorB = colorID;
					t10.colorC = colorID;
					t10.windingAdjusted = tri19.windingAdjusted;
					var tri04 = t10;
					this7[this7.length] = tri04;
					var tri20 = tri18.t1;
					var t11 = Type.createEmptyInstance(trilateral_tri_Triangle);
					t11.id = id5;
					t11.ax = tri20.ax;
					t11.ay = tri20.ay;
					t11.bx = tri20.bx;
					t11.by = tri20.by;
					t11.cx = tri20.cx;
					t11.cy = tri20.cy;
					t11.mark = tri20.mark;
					t11.depth = 0;
					t11.alpha = 1.;
					t11.colorID = colorID;
					t11.colorA = colorID;
					t11.colorB = colorID;
					t11.colorC = colorID;
					t11.windingAdjusted = tri20.windingAdjusted;
					var tri110 = t11;
					this7[this7.length] = tri110;
					break;
				case 5:
					var _this6 = this.shapes;
					var x3 = px - radiusW;
					var y1 = py - radiusH;
					var width = radiusW * 2;
					var height = radiusH * 2;
					var radius1 = radius / (this.ratio * 2);
					var this8 = _this6.triangles;
					var id6 = _this6.refCount++;
					var this9 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
					var out1 = this9;
					var pi2 = Math.PI;
					var pi_2 = Math.PI / 2;
					var ax4 = x3 + radius1;
					var ay4 = y1 + radius1;
					var bx5 = x3 + width - radius1;
					var by5 = y1 + radius1;
					var cx5 = bx5;
					var cy5 = y1 + height - radius1;
					var dx5 = ax4;
					var dy5 = cy5;
					var tp_t1;
					var tp_t0;
					var ax5 = ax4;
					var ay5 = y1;
					var bx6 = ax4 + (width - radius1 * 2);
					var by6 = ay5;
					var cx6 = bx6;
					var cy6 = ay5 + height;
					var dx6 = ax4;
					var dy6 = cy6;
					tp_t0 = new trilateral_tri_Trilateral(ax5,ay5,bx6,by6,dx6,dy6);
					tp_t1 = new trilateral_tri_Trilateral(bx6,by6,cx6,cy6,dx6,dy6);
					out1[out1.length] = tp_t0;
					out1[out1.length] = tp_t1;
					var dimY = height - 2 * radius1;
					var tp_t11;
					var tp_t01;
					var ax6 = x3;
					var ay6 = ay4;
					var bx7 = x3 + radius1;
					var by7 = ay6;
					var cx7 = bx7;
					var cy7 = ay6 + dimY;
					var dx7 = x3;
					var dy7 = cy7;
					tp_t01 = new trilateral_tri_Trilateral(ax6,ay6,bx7,by7,dx7,dy7);
					tp_t11 = new trilateral_tri_Trilateral(bx7,by7,cx7,cy7,dx7,dy7);
					out1[out1.length] = tp_t01;
					out1[out1.length] = tp_t11;
					var tp_t12;
					var tp_t02;
					var ax7 = bx5;
					var ay7 = by5;
					var bx8 = bx5 + radius1;
					var by8 = ay7;
					var cx8 = bx8;
					var cy8 = ay7 + dimY;
					var dx8 = bx5;
					var dy8 = cy8;
					tp_t02 = new trilateral_tri_Trilateral(ax7,ay7,bx8,by8,dx8,dy8);
					tp_t12 = new trilateral_tri_Trilateral(bx8,by8,cx8,cy8,dx8,dy8);
					out1[out1.length] = tp_t02;
					out1[out1.length] = tp_t12;
					var beta = -pi2;
					var gamma = -pi_2;
					var this10 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
					var out2 = this10;
					var pi3 = Math.PI;
					var step1 = pi3 * 2 / 36;
					var dif;
					switch(trilateral_angle_DifferencePreference.CLOCKWISE[1]) {
					case 0:
						var f;
						if(beta >= 0 && beta > Math.PI) {
							f = beta;
						} else {
							var a = beta % (2 * Math.PI);
							if(a >= 0) {
								f = a;
							} else {
								f = a + 2 * Math.PI;
							}
						}
						var this11 = f;
						var za = this11;
						var f1;
						if(gamma >= 0 && gamma > Math.PI) {
							f1 = gamma;
						} else {
							var a1 = gamma % (2 * Math.PI);
							if(a1 >= 0) {
								f1 = a1;
							} else {
								f1 = a1 + 2 * Math.PI;
							}
						}
						var this12 = f1;
						var zb = this12;
						var fa = beta;
						var fb = gamma;
						var theta1 = Math.abs(beta - gamma);
						var clockwise = beta < gamma;
						var dif1 = clockwise ? theta1 : -theta1;
						if(dif1 > 0) {
							dif = dif1;
						} else {
							dif = 2 * Math.PI + dif1;
						}
						break;
					case 1:
						var f2;
						if(beta >= 0 && beta > Math.PI) {
							f2 = beta;
						} else {
							var a2 = beta % (2 * Math.PI);
							if(a2 >= 0) {
								f2 = a2;
							} else {
								f2 = a2 + 2 * Math.PI;
							}
						}
						var this13 = f2;
						var za1 = this13;
						var f3;
						if(gamma >= 0 && gamma > Math.PI) {
							f3 = gamma;
						} else {
							var a3 = gamma % (2 * Math.PI);
							if(a3 >= 0) {
								f3 = a3;
							} else {
								f3 = a3 + 2 * Math.PI;
							}
						}
						var this14 = f3;
						var zb1 = this14;
						var fa1 = beta;
						var fb1 = gamma;
						var theta2 = Math.abs(beta - gamma);
						var clockwise1 = beta < gamma;
						var dif2 = clockwise1 ? theta2 : -theta2;
						if(dif2 < 0) {
							dif = dif2;
						} else {
							dif = -2 * Math.PI + dif2;
						}
						break;
					case 2:
						var f4;
						if(beta >= 0 && beta > Math.PI) {
							f4 = beta;
						} else {
							var a4 = beta % (2 * Math.PI);
							if(a4 >= 0) {
								f4 = a4;
							} else {
								f4 = a4 + 2 * Math.PI;
							}
						}
						var this15 = f4;
						var za2 = this15;
						var f5;
						if(gamma >= 0 && gamma > Math.PI) {
							f5 = gamma;
						} else {
							var a5 = gamma % (2 * Math.PI);
							if(a5 >= 0) {
								f5 = a5;
							} else {
								f5 = a5 + 2 * Math.PI;
							}
						}
						var this16 = f5;
						var zb2 = this16;
						var fa2 = beta;
						var fb2 = gamma;
						var theta3 = Math.abs(beta - gamma);
						var smallest = theta3 <= Math.PI;
						var clockwise2 = beta < gamma;
						var dif3 = clockwise2 ? theta3 : -theta3;
						if(smallest) {
							dif = dif3;
						} else if(clockwise2) {
							dif = -(2 * Math.PI - theta3);
						} else {
							dif = 2 * Math.PI - theta3;
						}
						break;
					case 3:
						var f6;
						if(beta >= 0 && beta > Math.PI) {
							f6 = beta;
						} else {
							var a6 = beta % (2 * Math.PI);
							if(a6 >= 0) {
								f6 = a6;
							} else {
								f6 = a6 + 2 * Math.PI;
							}
						}
						var this17 = f6;
						var za3 = this17;
						var f7;
						if(gamma >= 0 && gamma > Math.PI) {
							f7 = gamma;
						} else {
							var a7 = gamma % (2 * Math.PI);
							if(a7 >= 0) {
								f7 = a7;
							} else {
								f7 = a7 + 2 * Math.PI;
							}
						}
						var this18 = f7;
						var zb3 = this18;
						var fa3 = beta;
						var fb3 = gamma;
						var theta4 = Math.abs(beta - gamma);
						var largest = theta4 > Math.PI;
						var clockwise3 = beta < gamma;
						var dif4 = clockwise3 ? theta4 : -theta4;
						if(largest) {
							dif = dif4;
						} else if(clockwise3) {
							dif = -(2 * Math.PI - theta4);
						} else {
							dif = 2 * Math.PI - theta4;
						}
						break;
					}
					var positive = dif >= 0;
					var totalSteps = Math.ceil(Math.abs(dif) / step1);
					var step2 = dif / totalSteps;
					var angle = beta;
					var cx9;
					var cy9;
					var bx9 = 0;
					var by9 = 0;
					var _g12 = 0;
					var _g6 = totalSteps + 1;
					while(_g12 < _g6) {
						var i2 = _g12++;
						cx9 = ax4 + radius1 * Math.sin(angle);
						cy9 = ay4 + radius1 * Math.cos(angle);
						if(i2 != 0) {
							var t12 = new trilateral_tri_Trilateral(ax4,ay4,bx9,by9,cx9,cy9);
							out2[out2.length] = t12;
						}
						angle += step2;
						bx9 = cx9;
						by9 = cy9;
					}
					var triArr1 = out2;
					var _g7 = 0;
					while(_g7 < triArr1.length) {
						var t13 = triArr1[_g7];
						++_g7;
						out1[out1.length] = t13;
					}
					var this19 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
					var out3 = this19;
					var pi4 = Math.PI;
					var step3 = pi4 * 2 / 36;
					var dif5;
					switch(trilateral_angle_DifferencePreference.CLOCKWISE[1]) {
					case 0:
						var f8;
						if(pi_2 >= 0 && pi_2 > Math.PI) {
							f8 = pi_2;
						} else {
							var a8 = pi_2 % (2 * Math.PI);
							if(a8 >= 0) {
								f8 = a8;
							} else {
								f8 = a8 + 2 * Math.PI;
							}
						}
						var this20 = f8;
						var za4 = this20;
						var f9;
						if(pi2 >= 0 && pi2 > Math.PI) {
							f9 = pi2;
						} else {
							var a9 = pi2 % (2 * Math.PI);
							if(a9 >= 0) {
								f9 = a9;
							} else {
								f9 = a9 + 2 * Math.PI;
							}
						}
						var this21 = f9;
						var zb4 = this21;
						var fa4 = pi_2;
						var fb4 = pi2;
						var theta5 = Math.abs(pi_2 - pi2);
						var clockwise4 = pi_2 < pi2;
						var dif6 = clockwise4 ? theta5 : -theta5;
						if(dif6 > 0) {
							dif5 = dif6;
						} else {
							dif5 = 2 * Math.PI + dif6;
						}
						break;
					case 1:
						var f10;
						if(pi_2 >= 0 && pi_2 > Math.PI) {
							f10 = pi_2;
						} else {
							var a10 = pi_2 % (2 * Math.PI);
							if(a10 >= 0) {
								f10 = a10;
							} else {
								f10 = a10 + 2 * Math.PI;
							}
						}
						var this22 = f10;
						var za5 = this22;
						var f11;
						if(pi2 >= 0 && pi2 > Math.PI) {
							f11 = pi2;
						} else {
							var a11 = pi2 % (2 * Math.PI);
							if(a11 >= 0) {
								f11 = a11;
							} else {
								f11 = a11 + 2 * Math.PI;
							}
						}
						var this23 = f11;
						var zb5 = this23;
						var fa5 = pi_2;
						var fb5 = pi2;
						var theta6 = Math.abs(pi_2 - pi2);
						var clockwise5 = pi_2 < pi2;
						var dif7 = clockwise5 ? theta6 : -theta6;
						if(dif7 < 0) {
							dif5 = dif7;
						} else {
							dif5 = -2 * Math.PI + dif7;
						}
						break;
					case 2:
						var f12;
						if(pi_2 >= 0 && pi_2 > Math.PI) {
							f12 = pi_2;
						} else {
							var a12 = pi_2 % (2 * Math.PI);
							if(a12 >= 0) {
								f12 = a12;
							} else {
								f12 = a12 + 2 * Math.PI;
							}
						}
						var this24 = f12;
						var za6 = this24;
						var f13;
						if(pi2 >= 0 && pi2 > Math.PI) {
							f13 = pi2;
						} else {
							var a13 = pi2 % (2 * Math.PI);
							if(a13 >= 0) {
								f13 = a13;
							} else {
								f13 = a13 + 2 * Math.PI;
							}
						}
						var this25 = f13;
						var zb6 = this25;
						var fa6 = pi_2;
						var fb6 = pi2;
						var theta7 = Math.abs(pi_2 - pi2);
						var smallest1 = theta7 <= Math.PI;
						var clockwise6 = pi_2 < pi2;
						var dif8 = clockwise6 ? theta7 : -theta7;
						if(smallest1) {
							dif5 = dif8;
						} else if(clockwise6) {
							dif5 = -(2 * Math.PI - theta7);
						} else {
							dif5 = 2 * Math.PI - theta7;
						}
						break;
					case 3:
						var f14;
						if(pi_2 >= 0 && pi_2 > Math.PI) {
							f14 = pi_2;
						} else {
							var a14 = pi_2 % (2 * Math.PI);
							if(a14 >= 0) {
								f14 = a14;
							} else {
								f14 = a14 + 2 * Math.PI;
							}
						}
						var this26 = f14;
						var za7 = this26;
						var f15;
						if(pi2 >= 0 && pi2 > Math.PI) {
							f15 = pi2;
						} else {
							var a15 = pi2 % (2 * Math.PI);
							if(a15 >= 0) {
								f15 = a15;
							} else {
								f15 = a15 + 2 * Math.PI;
							}
						}
						var this27 = f15;
						var zb7 = this27;
						var fa7 = pi_2;
						var fb7 = pi2;
						var theta8 = Math.abs(pi_2 - pi2);
						var largest1 = theta8 > Math.PI;
						var clockwise7 = pi_2 < pi2;
						var dif9 = clockwise7 ? theta8 : -theta8;
						if(largest1) {
							dif5 = dif9;
						} else if(clockwise7) {
							dif5 = -(2 * Math.PI - theta8);
						} else {
							dif5 = 2 * Math.PI - theta8;
						}
						break;
					}
					var positive1 = dif5 >= 0;
					var totalSteps1 = Math.ceil(Math.abs(dif5) / step3);
					var step4 = dif5 / totalSteps1;
					var angle1 = pi_2;
					var cx10;
					var cy10;
					var bx10 = 0;
					var by10 = 0;
					var _g13 = 0;
					var _g8 = totalSteps1 + 1;
					while(_g13 < _g8) {
						var i3 = _g13++;
						cx10 = bx5 + radius1 * Math.sin(angle1);
						cy10 = by5 + radius1 * Math.cos(angle1);
						if(i3 != 0) {
							var t14 = new trilateral_tri_Trilateral(bx5,by5,bx10,by10,cx10,cy10);
							out3[out3.length] = t14;
						}
						angle1 += step4;
						bx10 = cx10;
						by10 = cy10;
					}
					var triArr2 = out3;
					var _g9 = 0;
					while(_g9 < triArr2.length) {
						var t15 = triArr2[_g9];
						++_g9;
						out1[out1.length] = t15;
					}
					var this28 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
					var out4 = this28;
					var pi5 = Math.PI;
					var step5 = pi5 * 2 / 36;
					var dif10;
					switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE[1]) {
					case 0:
						var f16;
						if(pi_2 >= 0 && pi_2 > Math.PI) {
							f16 = pi_2;
						} else {
							var a16 = pi_2 % (2 * Math.PI);
							if(a16 >= 0) {
								f16 = a16;
							} else {
								f16 = a16 + 2 * Math.PI;
							}
						}
						var this29 = f16;
						var za8 = this29;
						var f17;
						if(0 > Math.PI) {
							f17 = 0;
						} else {
							var a17 = 0 % (2 * Math.PI);
							if(a17 >= 0) {
								f17 = a17;
							} else {
								f17 = a17 + 2 * Math.PI;
							}
						}
						var this30 = f17;
						var zb8 = this30;
						var fa8 = pi_2;
						var fb8 = 0;
						var theta9 = Math.abs(pi_2);
						var clockwise8 = pi_2 < 0;
						var dif11 = clockwise8 ? theta9 : -theta9;
						if(dif11 > 0) {
							dif10 = dif11;
						} else {
							dif10 = 2 * Math.PI + dif11;
						}
						break;
					case 1:
						var f18;
						if(pi_2 >= 0 && pi_2 > Math.PI) {
							f18 = pi_2;
						} else {
							var a18 = pi_2 % (2 * Math.PI);
							if(a18 >= 0) {
								f18 = a18;
							} else {
								f18 = a18 + 2 * Math.PI;
							}
						}
						var this31 = f18;
						var za9 = this31;
						var f19;
						if(0 > Math.PI) {
							f19 = 0;
						} else {
							var a19 = 0 % (2 * Math.PI);
							if(a19 >= 0) {
								f19 = a19;
							} else {
								f19 = a19 + 2 * Math.PI;
							}
						}
						var this32 = f19;
						var zb9 = this32;
						var fa9 = pi_2;
						var fb9 = 0;
						var theta10 = Math.abs(pi_2);
						var clockwise9 = pi_2 < 0;
						var dif12 = clockwise9 ? theta10 : -theta10;
						if(dif12 < 0) {
							dif10 = dif12;
						} else {
							dif10 = -2 * Math.PI + dif12;
						}
						break;
					case 2:
						var f20;
						if(pi_2 >= 0 && pi_2 > Math.PI) {
							f20 = pi_2;
						} else {
							var a20 = pi_2 % (2 * Math.PI);
							if(a20 >= 0) {
								f20 = a20;
							} else {
								f20 = a20 + 2 * Math.PI;
							}
						}
						var this33 = f20;
						var za10 = this33;
						var f21;
						if(0 > Math.PI) {
							f21 = 0;
						} else {
							var a21 = 0 % (2 * Math.PI);
							if(a21 >= 0) {
								f21 = a21;
							} else {
								f21 = a21 + 2 * Math.PI;
							}
						}
						var this34 = f21;
						var zb10 = this34;
						var fa10 = pi_2;
						var fb10 = 0;
						var theta11 = Math.abs(pi_2);
						var smallest2 = theta11 <= Math.PI;
						var clockwise10 = pi_2 < 0;
						var dif13 = clockwise10 ? theta11 : -theta11;
						if(smallest2) {
							dif10 = dif13;
						} else if(clockwise10) {
							dif10 = -(2 * Math.PI - theta11);
						} else {
							dif10 = 2 * Math.PI - theta11;
						}
						break;
					case 3:
						var f22;
						if(pi_2 >= 0 && pi_2 > Math.PI) {
							f22 = pi_2;
						} else {
							var a22 = pi_2 % (2 * Math.PI);
							if(a22 >= 0) {
								f22 = a22;
							} else {
								f22 = a22 + 2 * Math.PI;
							}
						}
						var this35 = f22;
						var za11 = this35;
						var f23;
						if(0 > Math.PI) {
							f23 = 0;
						} else {
							var a23 = 0 % (2 * Math.PI);
							if(a23 >= 0) {
								f23 = a23;
							} else {
								f23 = a23 + 2 * Math.PI;
							}
						}
						var this36 = f23;
						var zb11 = this36;
						var fa11 = pi_2;
						var fb11 = 0;
						var theta12 = Math.abs(pi_2);
						var largest2 = theta12 > Math.PI;
						var clockwise11 = pi_2 < 0;
						var dif14 = clockwise11 ? theta12 : -theta12;
						if(largest2) {
							dif10 = dif14;
						} else if(clockwise11) {
							dif10 = -(2 * Math.PI - theta12);
						} else {
							dif10 = 2 * Math.PI - theta12;
						}
						break;
					}
					var positive2 = dif10 >= 0;
					var totalSteps2 = Math.ceil(Math.abs(dif10) / step5);
					var step6 = dif10 / totalSteps2;
					var angle2 = pi_2;
					var cx11;
					var cy11;
					var bx11 = 0;
					var by11 = 0;
					var _g14 = 0;
					var _g10 = totalSteps2 + 1;
					while(_g14 < _g10) {
						var i4 = _g14++;
						cx11 = cx5 + radius1 * Math.sin(angle2);
						cy11 = cy5 + radius1 * Math.cos(angle2);
						if(i4 != 0) {
							var t16 = new trilateral_tri_Trilateral(cx5,cy5,bx11,by11,cx11,cy11);
							out4[out4.length] = t16;
						}
						angle2 += step6;
						bx11 = cx11;
						by11 = cy11;
					}
					var triArr3 = out4;
					var _g15 = 0;
					while(_g15 < triArr3.length) {
						var t17 = triArr3[_g15];
						++_g15;
						out1[out1.length] = t17;
					}
					var gamma1 = -pi_2;
					var this37 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
					var out5 = this37;
					var pi6 = Math.PI;
					var step7 = pi6 * 2 / 36;
					var dif15;
					switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE[1]) {
					case 0:
						var f24;
						if(0 > Math.PI) {
							f24 = 0;
						} else {
							var a24 = 0 % (2 * Math.PI);
							if(a24 >= 0) {
								f24 = a24;
							} else {
								f24 = a24 + 2 * Math.PI;
							}
						}
						var this38 = f24;
						var za12 = this38;
						var f25;
						if(gamma1 >= 0 && gamma1 > Math.PI) {
							f25 = gamma1;
						} else {
							var a25 = gamma1 % (2 * Math.PI);
							if(a25 >= 0) {
								f25 = a25;
							} else {
								f25 = a25 + 2 * Math.PI;
							}
						}
						var this39 = f25;
						var zb12 = this39;
						var fa12 = 0;
						var fb12 = gamma1;
						var theta13 = Math.abs(0 - gamma1);
						var clockwise12 = 0 < gamma1;
						var dif16 = clockwise12 ? theta13 : -theta13;
						if(dif16 > 0) {
							dif15 = dif16;
						} else {
							dif15 = 2 * Math.PI + dif16;
						}
						break;
					case 1:
						var f26;
						if(0 > Math.PI) {
							f26 = 0;
						} else {
							var a26 = 0 % (2 * Math.PI);
							if(a26 >= 0) {
								f26 = a26;
							} else {
								f26 = a26 + 2 * Math.PI;
							}
						}
						var this40 = f26;
						var za13 = this40;
						var f27;
						if(gamma1 >= 0 && gamma1 > Math.PI) {
							f27 = gamma1;
						} else {
							var a27 = gamma1 % (2 * Math.PI);
							if(a27 >= 0) {
								f27 = a27;
							} else {
								f27 = a27 + 2 * Math.PI;
							}
						}
						var this41 = f27;
						var zb13 = this41;
						var fa13 = 0;
						var fb13 = gamma1;
						var theta14 = Math.abs(0 - gamma1);
						var clockwise13 = 0 < gamma1;
						var dif17 = clockwise13 ? theta14 : -theta14;
						if(dif17 < 0) {
							dif15 = dif17;
						} else {
							dif15 = -2 * Math.PI + dif17;
						}
						break;
					case 2:
						var f28;
						if(0 > Math.PI) {
							f28 = 0;
						} else {
							var a28 = 0 % (2 * Math.PI);
							if(a28 >= 0) {
								f28 = a28;
							} else {
								f28 = a28 + 2 * Math.PI;
							}
						}
						var this42 = f28;
						var za14 = this42;
						var f29;
						if(gamma1 >= 0 && gamma1 > Math.PI) {
							f29 = gamma1;
						} else {
							var a29 = gamma1 % (2 * Math.PI);
							if(a29 >= 0) {
								f29 = a29;
							} else {
								f29 = a29 + 2 * Math.PI;
							}
						}
						var this43 = f29;
						var zb14 = this43;
						var fa14 = 0;
						var fb14 = gamma1;
						var theta15 = Math.abs(0 - gamma1);
						var smallest3 = theta15 <= Math.PI;
						var clockwise14 = 0 < gamma1;
						var dif18 = clockwise14 ? theta15 : -theta15;
						if(smallest3) {
							dif15 = dif18;
						} else if(clockwise14) {
							dif15 = -(2 * Math.PI - theta15);
						} else {
							dif15 = 2 * Math.PI - theta15;
						}
						break;
					case 3:
						var f30;
						if(0 > Math.PI) {
							f30 = 0;
						} else {
							var a30 = 0 % (2 * Math.PI);
							if(a30 >= 0) {
								f30 = a30;
							} else {
								f30 = a30 + 2 * Math.PI;
							}
						}
						var this44 = f30;
						var za15 = this44;
						var f31;
						if(gamma1 >= 0 && gamma1 > Math.PI) {
							f31 = gamma1;
						} else {
							var a31 = gamma1 % (2 * Math.PI);
							if(a31 >= 0) {
								f31 = a31;
							} else {
								f31 = a31 + 2 * Math.PI;
							}
						}
						var this45 = f31;
						var zb15 = this45;
						var fa15 = 0;
						var fb15 = gamma1;
						var theta16 = Math.abs(0 - gamma1);
						var largest3 = theta16 > Math.PI;
						var clockwise15 = 0 < gamma1;
						var dif19 = clockwise15 ? theta16 : -theta16;
						if(largest3) {
							dif15 = dif19;
						} else if(clockwise15) {
							dif15 = -(2 * Math.PI - theta16);
						} else {
							dif15 = 2 * Math.PI - theta16;
						}
						break;
					}
					var positive3 = dif15 >= 0;
					var totalSteps3 = Math.ceil(Math.abs(dif15) / step7);
					var step8 = dif15 / totalSteps3;
					var angle3 = 0;
					var cx12;
					var cy12;
					var bx12 = 0;
					var by12 = 0;
					var _g16 = 0;
					var _g17 = totalSteps3 + 1;
					while(_g16 < _g17) {
						var i5 = _g16++;
						cx12 = dx5 + radius1 * Math.sin(angle3);
						cy12 = dy5 + radius1 * Math.cos(angle3);
						if(i5 != 0) {
							var t18 = new trilateral_tri_Trilateral(dx5,dy5,bx12,by12,cx12,cy12);
							out5[out5.length] = t18;
						}
						angle3 += step8;
						bx12 = cx12;
						by12 = cy12;
					}
					var triArr4 = out5;
					var _g18 = 0;
					while(_g18 < triArr4.length) {
						var t19 = triArr4[_g18];
						++_g18;
						out1[out1.length] = t19;
					}
					var triArr5 = out1;
					var tri21;
					var _g19 = 0;
					while(_g19 < triArr5.length) {
						var t20 = triArr5[_g19];
						++_g19;
						if(t20 != null) {
							var t21 = Type.createEmptyInstance(trilateral_tri_Triangle);
							t21.id = id6;
							t21.ax = t20.ax;
							t21.ay = t20.ay;
							t21.bx = t20.bx;
							t21.by = t20.by;
							t21.cx = t20.cx;
							t21.cy = t20.cy;
							t21.mark = t20.mark;
							t21.depth = 0;
							t21.alpha = 1.;
							t21.colorID = colorID;
							t21.colorA = colorID;
							t21.colorB = colorID;
							t21.colorC = colorID;
							t21.windingAdjusted = t20.windingAdjusted;
							tri21 = t21;
							this8[this8.length] = tri21;
						}
					}
					break;
				case 6:
					var _this7 = this.shapes;
					var x4 = px - radiusW;
					var y2 = py - radiusH;
					var width1 = radiusW * 2;
					var height1 = radiusH * 2;
					var radius2 = radius / (this.ratio * 2);
					var this46 = _this7.triangles;
					var id7 = _this7.refCount++;
					var this47 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
					var out6 = this47;
					var pi7 = Math.PI;
					var pi_21 = Math.PI / 2;
					var ax8 = x4 + radius2;
					var ay8 = y2 + radius2;
					var bx13 = x4 + width1 - radius2;
					var by13 = y2 + radius2;
					var cx13 = bx13;
					var cy13 = y2 + height1 - radius2;
					var dx9 = ax8;
					var dy9 = cy13;
					var tp_t13;
					var tp_t03;
					var ax9 = ax8;
					var ay9 = y2;
					var bx14 = ax8 + (width1 - radius2 * 2);
					var by14 = ay9;
					var cx14 = bx14;
					var cy14 = ay9 + height1;
					var dx10 = ax8;
					var dy10 = cy14;
					tp_t03 = new trilateral_tri_Trilateral(ax9,ay9,bx14,by14,dx10,dy10);
					tp_t13 = new trilateral_tri_Trilateral(bx14,by14,cx14,cy14,dx10,dy10);
					out6[out6.length] = tp_t03;
					out6[out6.length] = tp_t13;
					var dimY1 = height1 - 2 * radius2;
					var tp_t14;
					var tp_t04;
					var ax10 = x4;
					var ay10 = ay8;
					var bx15 = x4 + radius2;
					var by15 = ay10;
					var cx15 = bx15;
					var cy15 = ay10 + dimY1;
					var dx11 = x4;
					var dy11 = cy15;
					tp_t04 = new trilateral_tri_Trilateral(ax10,ay10,bx15,by15,dx11,dy11);
					tp_t14 = new trilateral_tri_Trilateral(bx15,by15,cx15,cy15,dx11,dy11);
					out6[out6.length] = tp_t04;
					out6[out6.length] = tp_t14;
					var tp_t15;
					var tp_t05;
					var ax11 = bx13;
					var ay11 = by13;
					var bx16 = bx13 + radius2;
					var by16 = ay11;
					var cx16 = bx16;
					var cy16 = ay11 + dimY1;
					var dx12 = bx13;
					var dy12 = cy16;
					tp_t05 = new trilateral_tri_Trilateral(ax11,ay11,bx16,by16,dx12,dy12);
					tp_t15 = new trilateral_tri_Trilateral(bx16,by16,cx16,cy16,dx12,dy12);
					out6[out6.length] = tp_t05;
					out6[out6.length] = tp_t15;
					var beta1 = -pi7;
					var gamma2 = -pi_21;
					var this48 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
					var out7 = this48;
					var pi8 = Math.PI;
					var step9 = pi8 * 2 / 36;
					var dif20;
					switch(trilateral_angle_DifferencePreference.CLOCKWISE[1]) {
					case 0:
						var f32;
						if(beta1 >= 0 && beta1 > Math.PI) {
							f32 = beta1;
						} else {
							var a32 = beta1 % (2 * Math.PI);
							if(a32 >= 0) {
								f32 = a32;
							} else {
								f32 = a32 + 2 * Math.PI;
							}
						}
						var this49 = f32;
						var za16 = this49;
						var f33;
						if(gamma2 >= 0 && gamma2 > Math.PI) {
							f33 = gamma2;
						} else {
							var a33 = gamma2 % (2 * Math.PI);
							if(a33 >= 0) {
								f33 = a33;
							} else {
								f33 = a33 + 2 * Math.PI;
							}
						}
						var this50 = f33;
						var zb16 = this50;
						var fa16 = beta1;
						var fb16 = gamma2;
						var theta17 = Math.abs(beta1 - gamma2);
						var clockwise16 = beta1 < gamma2;
						var dif21 = clockwise16 ? theta17 : -theta17;
						if(dif21 > 0) {
							dif20 = dif21;
						} else {
							dif20 = 2 * Math.PI + dif21;
						}
						break;
					case 1:
						var f34;
						if(beta1 >= 0 && beta1 > Math.PI) {
							f34 = beta1;
						} else {
							var a34 = beta1 % (2 * Math.PI);
							if(a34 >= 0) {
								f34 = a34;
							} else {
								f34 = a34 + 2 * Math.PI;
							}
						}
						var this51 = f34;
						var za17 = this51;
						var f35;
						if(gamma2 >= 0 && gamma2 > Math.PI) {
							f35 = gamma2;
						} else {
							var a35 = gamma2 % (2 * Math.PI);
							if(a35 >= 0) {
								f35 = a35;
							} else {
								f35 = a35 + 2 * Math.PI;
							}
						}
						var this52 = f35;
						var zb17 = this52;
						var fa17 = beta1;
						var fb17 = gamma2;
						var theta18 = Math.abs(beta1 - gamma2);
						var clockwise17 = beta1 < gamma2;
						var dif22 = clockwise17 ? theta18 : -theta18;
						if(dif22 < 0) {
							dif20 = dif22;
						} else {
							dif20 = -2 * Math.PI + dif22;
						}
						break;
					case 2:
						var f36;
						if(beta1 >= 0 && beta1 > Math.PI) {
							f36 = beta1;
						} else {
							var a36 = beta1 % (2 * Math.PI);
							if(a36 >= 0) {
								f36 = a36;
							} else {
								f36 = a36 + 2 * Math.PI;
							}
						}
						var this53 = f36;
						var za18 = this53;
						var f37;
						if(gamma2 >= 0 && gamma2 > Math.PI) {
							f37 = gamma2;
						} else {
							var a37 = gamma2 % (2 * Math.PI);
							if(a37 >= 0) {
								f37 = a37;
							} else {
								f37 = a37 + 2 * Math.PI;
							}
						}
						var this54 = f37;
						var zb18 = this54;
						var fa18 = beta1;
						var fb18 = gamma2;
						var theta19 = Math.abs(beta1 - gamma2);
						var smallest4 = theta19 <= Math.PI;
						var clockwise18 = beta1 < gamma2;
						var dif23 = clockwise18 ? theta19 : -theta19;
						if(smallest4) {
							dif20 = dif23;
						} else if(clockwise18) {
							dif20 = -(2 * Math.PI - theta19);
						} else {
							dif20 = 2 * Math.PI - theta19;
						}
						break;
					case 3:
						var f38;
						if(beta1 >= 0 && beta1 > Math.PI) {
							f38 = beta1;
						} else {
							var a38 = beta1 % (2 * Math.PI);
							if(a38 >= 0) {
								f38 = a38;
							} else {
								f38 = a38 + 2 * Math.PI;
							}
						}
						var this55 = f38;
						var za19 = this55;
						var f39;
						if(gamma2 >= 0 && gamma2 > Math.PI) {
							f39 = gamma2;
						} else {
							var a39 = gamma2 % (2 * Math.PI);
							if(a39 >= 0) {
								f39 = a39;
							} else {
								f39 = a39 + 2 * Math.PI;
							}
						}
						var this56 = f39;
						var zb19 = this56;
						var fa19 = beta1;
						var fb19 = gamma2;
						var theta20 = Math.abs(beta1 - gamma2);
						var largest4 = theta20 > Math.PI;
						var clockwise19 = beta1 < gamma2;
						var dif24 = clockwise19 ? theta20 : -theta20;
						if(largest4) {
							dif20 = dif24;
						} else if(clockwise19) {
							dif20 = -(2 * Math.PI - theta20);
						} else {
							dif20 = 2 * Math.PI - theta20;
						}
						break;
					}
					var positive4 = dif20 >= 0;
					var totalSteps4 = Math.ceil(Math.abs(dif20) / step9);
					var step10 = dif20 / totalSteps4;
					var angle4 = beta1;
					var cx17;
					var cy17;
					var bx17 = 0;
					var by17 = 0;
					var _g110 = 0;
					var _g20 = totalSteps4 + 1;
					while(_g110 < _g20) {
						var i6 = _g110++;
						cx17 = ax8 + radius2 * Math.sin(angle4);
						cy17 = ay8 + radius2 * Math.cos(angle4);
						if(i6 != 0) {
							var t22 = new trilateral_tri_Trilateral(ax8,ay8,bx17,by17,cx17,cy17);
							out7[out7.length] = t22;
						}
						angle4 += step10;
						bx17 = cx17;
						by17 = cy17;
					}
					var triArr6 = out7;
					var _g21 = 0;
					while(_g21 < triArr6.length) {
						var t23 = triArr6[_g21];
						++_g21;
						out6[out6.length] = t23;
					}
					var this57 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
					var out8 = this57;
					var pi9 = Math.PI;
					var step11 = pi9 * 2 / 36;
					var dif25;
					switch(trilateral_angle_DifferencePreference.CLOCKWISE[1]) {
					case 0:
						var f40;
						if(pi_21 >= 0 && pi_21 > Math.PI) {
							f40 = pi_21;
						} else {
							var a40 = pi_21 % (2 * Math.PI);
							if(a40 >= 0) {
								f40 = a40;
							} else {
								f40 = a40 + 2 * Math.PI;
							}
						}
						var this58 = f40;
						var za20 = this58;
						var f41;
						if(pi7 >= 0 && pi7 > Math.PI) {
							f41 = pi7;
						} else {
							var a41 = pi7 % (2 * Math.PI);
							if(a41 >= 0) {
								f41 = a41;
							} else {
								f41 = a41 + 2 * Math.PI;
							}
						}
						var this59 = f41;
						var zb20 = this59;
						var fa20 = pi_21;
						var fb20 = pi7;
						var theta21 = Math.abs(pi_21 - pi7);
						var clockwise20 = pi_21 < pi7;
						var dif26 = clockwise20 ? theta21 : -theta21;
						if(dif26 > 0) {
							dif25 = dif26;
						} else {
							dif25 = 2 * Math.PI + dif26;
						}
						break;
					case 1:
						var f42;
						if(pi_21 >= 0 && pi_21 > Math.PI) {
							f42 = pi_21;
						} else {
							var a42 = pi_21 % (2 * Math.PI);
							if(a42 >= 0) {
								f42 = a42;
							} else {
								f42 = a42 + 2 * Math.PI;
							}
						}
						var this60 = f42;
						var za21 = this60;
						var f43;
						if(pi7 >= 0 && pi7 > Math.PI) {
							f43 = pi7;
						} else {
							var a43 = pi7 % (2 * Math.PI);
							if(a43 >= 0) {
								f43 = a43;
							} else {
								f43 = a43 + 2 * Math.PI;
							}
						}
						var this61 = f43;
						var zb21 = this61;
						var fa21 = pi_21;
						var fb21 = pi7;
						var theta22 = Math.abs(pi_21 - pi7);
						var clockwise21 = pi_21 < pi7;
						var dif27 = clockwise21 ? theta22 : -theta22;
						if(dif27 < 0) {
							dif25 = dif27;
						} else {
							dif25 = -2 * Math.PI + dif27;
						}
						break;
					case 2:
						var f44;
						if(pi_21 >= 0 && pi_21 > Math.PI) {
							f44 = pi_21;
						} else {
							var a44 = pi_21 % (2 * Math.PI);
							if(a44 >= 0) {
								f44 = a44;
							} else {
								f44 = a44 + 2 * Math.PI;
							}
						}
						var this62 = f44;
						var za22 = this62;
						var f45;
						if(pi7 >= 0 && pi7 > Math.PI) {
							f45 = pi7;
						} else {
							var a45 = pi7 % (2 * Math.PI);
							if(a45 >= 0) {
								f45 = a45;
							} else {
								f45 = a45 + 2 * Math.PI;
							}
						}
						var this63 = f45;
						var zb22 = this63;
						var fa22 = pi_21;
						var fb22 = pi7;
						var theta23 = Math.abs(pi_21 - pi7);
						var smallest5 = theta23 <= Math.PI;
						var clockwise22 = pi_21 < pi7;
						var dif28 = clockwise22 ? theta23 : -theta23;
						if(smallest5) {
							dif25 = dif28;
						} else if(clockwise22) {
							dif25 = -(2 * Math.PI - theta23);
						} else {
							dif25 = 2 * Math.PI - theta23;
						}
						break;
					case 3:
						var f46;
						if(pi_21 >= 0 && pi_21 > Math.PI) {
							f46 = pi_21;
						} else {
							var a46 = pi_21 % (2 * Math.PI);
							if(a46 >= 0) {
								f46 = a46;
							} else {
								f46 = a46 + 2 * Math.PI;
							}
						}
						var this64 = f46;
						var za23 = this64;
						var f47;
						if(pi7 >= 0 && pi7 > Math.PI) {
							f47 = pi7;
						} else {
							var a47 = pi7 % (2 * Math.PI);
							if(a47 >= 0) {
								f47 = a47;
							} else {
								f47 = a47 + 2 * Math.PI;
							}
						}
						var this65 = f47;
						var zb23 = this65;
						var fa23 = pi_21;
						var fb23 = pi7;
						var theta24 = Math.abs(pi_21 - pi7);
						var largest5 = theta24 > Math.PI;
						var clockwise23 = pi_21 < pi7;
						var dif29 = clockwise23 ? theta24 : -theta24;
						if(largest5) {
							dif25 = dif29;
						} else if(clockwise23) {
							dif25 = -(2 * Math.PI - theta24);
						} else {
							dif25 = 2 * Math.PI - theta24;
						}
						break;
					}
					var positive5 = dif25 >= 0;
					var totalSteps5 = Math.ceil(Math.abs(dif25) / step11);
					var step12 = dif25 / totalSteps5;
					var angle5 = pi_21;
					var cx18;
					var cy18;
					var bx18 = 0;
					var by18 = 0;
					var _g111 = 0;
					var _g22 = totalSteps5 + 1;
					while(_g111 < _g22) {
						var i7 = _g111++;
						cx18 = bx13 + radius2 * Math.sin(angle5);
						cy18 = by13 + radius2 * Math.cos(angle5);
						if(i7 != 0) {
							var t24 = new trilateral_tri_Trilateral(bx13,by13,bx18,by18,cx18,cy18);
							out8[out8.length] = t24;
						}
						angle5 += step12;
						bx18 = cx18;
						by18 = cy18;
					}
					var triArr7 = out8;
					var _g23 = 0;
					while(_g23 < triArr7.length) {
						var t25 = triArr7[_g23];
						++_g23;
						out6[out6.length] = t25;
					}
					var this66 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
					var out9 = this66;
					var pi10 = Math.PI;
					var step13 = pi10 * 2 / 36;
					var dif30;
					switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE[1]) {
					case 0:
						var f48;
						if(pi_21 >= 0 && pi_21 > Math.PI) {
							f48 = pi_21;
						} else {
							var a48 = pi_21 % (2 * Math.PI);
							if(a48 >= 0) {
								f48 = a48;
							} else {
								f48 = a48 + 2 * Math.PI;
							}
						}
						var this67 = f48;
						var za24 = this67;
						var f49;
						if(0 > Math.PI) {
							f49 = 0;
						} else {
							var a49 = 0 % (2 * Math.PI);
							if(a49 >= 0) {
								f49 = a49;
							} else {
								f49 = a49 + 2 * Math.PI;
							}
						}
						var this68 = f49;
						var zb24 = this68;
						var fa24 = pi_21;
						var fb24 = 0;
						var theta25 = Math.abs(pi_21);
						var clockwise24 = pi_21 < 0;
						var dif31 = clockwise24 ? theta25 : -theta25;
						if(dif31 > 0) {
							dif30 = dif31;
						} else {
							dif30 = 2 * Math.PI + dif31;
						}
						break;
					case 1:
						var f50;
						if(pi_21 >= 0 && pi_21 > Math.PI) {
							f50 = pi_21;
						} else {
							var a50 = pi_21 % (2 * Math.PI);
							if(a50 >= 0) {
								f50 = a50;
							} else {
								f50 = a50 + 2 * Math.PI;
							}
						}
						var this69 = f50;
						var za25 = this69;
						var f51;
						if(0 > Math.PI) {
							f51 = 0;
						} else {
							var a51 = 0 % (2 * Math.PI);
							if(a51 >= 0) {
								f51 = a51;
							} else {
								f51 = a51 + 2 * Math.PI;
							}
						}
						var this70 = f51;
						var zb25 = this70;
						var fa25 = pi_21;
						var fb25 = 0;
						var theta26 = Math.abs(pi_21);
						var clockwise25 = pi_21 < 0;
						var dif32 = clockwise25 ? theta26 : -theta26;
						if(dif32 < 0) {
							dif30 = dif32;
						} else {
							dif30 = -2 * Math.PI + dif32;
						}
						break;
					case 2:
						var f52;
						if(pi_21 >= 0 && pi_21 > Math.PI) {
							f52 = pi_21;
						} else {
							var a52 = pi_21 % (2 * Math.PI);
							if(a52 >= 0) {
								f52 = a52;
							} else {
								f52 = a52 + 2 * Math.PI;
							}
						}
						var this71 = f52;
						var za26 = this71;
						var f53;
						if(0 > Math.PI) {
							f53 = 0;
						} else {
							var a53 = 0 % (2 * Math.PI);
							if(a53 >= 0) {
								f53 = a53;
							} else {
								f53 = a53 + 2 * Math.PI;
							}
						}
						var this72 = f53;
						var zb26 = this72;
						var fa26 = pi_21;
						var fb26 = 0;
						var theta27 = Math.abs(pi_21);
						var smallest6 = theta27 <= Math.PI;
						var clockwise26 = pi_21 < 0;
						var dif33 = clockwise26 ? theta27 : -theta27;
						if(smallest6) {
							dif30 = dif33;
						} else if(clockwise26) {
							dif30 = -(2 * Math.PI - theta27);
						} else {
							dif30 = 2 * Math.PI - theta27;
						}
						break;
					case 3:
						var f54;
						if(pi_21 >= 0 && pi_21 > Math.PI) {
							f54 = pi_21;
						} else {
							var a54 = pi_21 % (2 * Math.PI);
							if(a54 >= 0) {
								f54 = a54;
							} else {
								f54 = a54 + 2 * Math.PI;
							}
						}
						var this73 = f54;
						var za27 = this73;
						var f55;
						if(0 > Math.PI) {
							f55 = 0;
						} else {
							var a55 = 0 % (2 * Math.PI);
							if(a55 >= 0) {
								f55 = a55;
							} else {
								f55 = a55 + 2 * Math.PI;
							}
						}
						var this74 = f55;
						var zb27 = this74;
						var fa27 = pi_21;
						var fb27 = 0;
						var theta28 = Math.abs(pi_21);
						var largest6 = theta28 > Math.PI;
						var clockwise27 = pi_21 < 0;
						var dif34 = clockwise27 ? theta28 : -theta28;
						if(largest6) {
							dif30 = dif34;
						} else if(clockwise27) {
							dif30 = -(2 * Math.PI - theta28);
						} else {
							dif30 = 2 * Math.PI - theta28;
						}
						break;
					}
					var positive6 = dif30 >= 0;
					var totalSteps6 = Math.ceil(Math.abs(dif30) / step13);
					var step14 = dif30 / totalSteps6;
					var angle6 = pi_21;
					var cx19;
					var cy19;
					var bx19 = 0;
					var by19 = 0;
					var _g112 = 0;
					var _g24 = totalSteps6 + 1;
					while(_g112 < _g24) {
						var i8 = _g112++;
						cx19 = cx13 + radius2 * Math.sin(angle6);
						cy19 = cy13 + radius2 * Math.cos(angle6);
						if(i8 != 0) {
							var t26 = new trilateral_tri_Trilateral(cx13,cy13,bx19,by19,cx19,cy19);
							out9[out9.length] = t26;
						}
						angle6 += step14;
						bx19 = cx19;
						by19 = cy19;
					}
					var triArr8 = out9;
					var _g25 = 0;
					while(_g25 < triArr8.length) {
						var t27 = triArr8[_g25];
						++_g25;
						out6[out6.length] = t27;
					}
					var gamma3 = -pi_21;
					var this75 = trilateral_tri__$TrilateralArray_TrilateralArray_$Impl_$._new([]);
					var out10 = this75;
					var pi11 = Math.PI;
					var step15 = pi11 * 2 / 36;
					var dif35;
					switch(trilateral_angle_DifferencePreference.ANTICLOCKWISE[1]) {
					case 0:
						var f56;
						if(0 > Math.PI) {
							f56 = 0;
						} else {
							var a56 = 0 % (2 * Math.PI);
							if(a56 >= 0) {
								f56 = a56;
							} else {
								f56 = a56 + 2 * Math.PI;
							}
						}
						var this76 = f56;
						var za28 = this76;
						var f57;
						if(gamma3 >= 0 && gamma3 > Math.PI) {
							f57 = gamma3;
						} else {
							var a57 = gamma3 % (2 * Math.PI);
							if(a57 >= 0) {
								f57 = a57;
							} else {
								f57 = a57 + 2 * Math.PI;
							}
						}
						var this77 = f57;
						var zb28 = this77;
						var fa28 = 0;
						var fb28 = gamma3;
						var theta29 = Math.abs(0 - gamma3);
						var clockwise28 = 0 < gamma3;
						var dif36 = clockwise28 ? theta29 : -theta29;
						if(dif36 > 0) {
							dif35 = dif36;
						} else {
							dif35 = 2 * Math.PI + dif36;
						}
						break;
					case 1:
						var f58;
						if(0 > Math.PI) {
							f58 = 0;
						} else {
							var a58 = 0 % (2 * Math.PI);
							if(a58 >= 0) {
								f58 = a58;
							} else {
								f58 = a58 + 2 * Math.PI;
							}
						}
						var this78 = f58;
						var za29 = this78;
						var f59;
						if(gamma3 >= 0 && gamma3 > Math.PI) {
							f59 = gamma3;
						} else {
							var a59 = gamma3 % (2 * Math.PI);
							if(a59 >= 0) {
								f59 = a59;
							} else {
								f59 = a59 + 2 * Math.PI;
							}
						}
						var this79 = f59;
						var zb29 = this79;
						var fa29 = 0;
						var fb29 = gamma3;
						var theta30 = Math.abs(0 - gamma3);
						var clockwise29 = 0 < gamma3;
						var dif37 = clockwise29 ? theta30 : -theta30;
						if(dif37 < 0) {
							dif35 = dif37;
						} else {
							dif35 = -2 * Math.PI + dif37;
						}
						break;
					case 2:
						var f60;
						if(0 > Math.PI) {
							f60 = 0;
						} else {
							var a60 = 0 % (2 * Math.PI);
							if(a60 >= 0) {
								f60 = a60;
							} else {
								f60 = a60 + 2 * Math.PI;
							}
						}
						var this80 = f60;
						var za30 = this80;
						var f61;
						if(gamma3 >= 0 && gamma3 > Math.PI) {
							f61 = gamma3;
						} else {
							var a61 = gamma3 % (2 * Math.PI);
							if(a61 >= 0) {
								f61 = a61;
							} else {
								f61 = a61 + 2 * Math.PI;
							}
						}
						var this81 = f61;
						var zb30 = this81;
						var fa30 = 0;
						var fb30 = gamma3;
						var theta31 = Math.abs(0 - gamma3);
						var smallest7 = theta31 <= Math.PI;
						var clockwise30 = 0 < gamma3;
						var dif38 = clockwise30 ? theta31 : -theta31;
						if(smallest7) {
							dif35 = dif38;
						} else if(clockwise30) {
							dif35 = -(2 * Math.PI - theta31);
						} else {
							dif35 = 2 * Math.PI - theta31;
						}
						break;
					case 3:
						var f62;
						if(0 > Math.PI) {
							f62 = 0;
						} else {
							var a62 = 0 % (2 * Math.PI);
							if(a62 >= 0) {
								f62 = a62;
							} else {
								f62 = a62 + 2 * Math.PI;
							}
						}
						var this82 = f62;
						var za31 = this82;
						var f63;
						if(gamma3 >= 0 && gamma3 > Math.PI) {
							f63 = gamma3;
						} else {
							var a63 = gamma3 % (2 * Math.PI);
							if(a63 >= 0) {
								f63 = a63;
							} else {
								f63 = a63 + 2 * Math.PI;
							}
						}
						var this83 = f63;
						var zb31 = this83;
						var fa31 = 0;
						var fb31 = gamma3;
						var theta32 = Math.abs(0 - gamma3);
						var largest7 = theta32 > Math.PI;
						var clockwise31 = 0 < gamma3;
						var dif39 = clockwise31 ? theta32 : -theta32;
						if(largest7) {
							dif35 = dif39;
						} else if(clockwise31) {
							dif35 = -(2 * Math.PI - theta32);
						} else {
							dif35 = 2 * Math.PI - theta32;
						}
						break;
					}
					var positive7 = dif35 >= 0;
					var totalSteps7 = Math.ceil(Math.abs(dif35) / step15);
					var step16 = dif35 / totalSteps7;
					var angle7 = 0;
					var cx20;
					var cy20;
					var bx20 = 0;
					var by20 = 0;
					var _g113 = 0;
					var _g26 = totalSteps7 + 1;
					while(_g113 < _g26) {
						var i9 = _g113++;
						cx20 = dx9 + radius2 * Math.sin(angle7);
						cy20 = dy9 + radius2 * Math.cos(angle7);
						if(i9 != 0) {
							var t28 = new trilateral_tri_Trilateral(dx9,dy9,bx20,by20,cx20,cy20);
							out10[out10.length] = t28;
						}
						angle7 += step16;
						bx20 = cx20;
						by20 = cy20;
					}
					var triArr9 = out10;
					var _g27 = 0;
					while(_g27 < triArr9.length) {
						var t29 = triArr9[_g27];
						++_g27;
						out6[out6.length] = t29;
					}
					var triArr10 = out6;
					var tri22;
					var _g28 = 0;
					while(_g28 < triArr10.length) {
						var t30 = triArr10[_g28];
						++_g28;
						if(t30 != null) {
							var t31 = Type.createEmptyInstance(trilateral_tri_Triangle);
							t31.id = id7;
							t31.ax = t30.ax;
							t31.ay = t30.ay;
							t31.bx = t30.bx;
							t31.by = t30.by;
							t31.cx = t30.cx;
							t31.cy = t30.cy;
							t31.mark = t30.mark;
							t31.depth = 0;
							t31.alpha = 1.;
							t31.colorID = colorID;
							t31.colorA = colorID;
							t31.colorB = colorID;
							t31.colorC = colorID;
							t31.windingAdjusted = t30.windingAdjusted;
							tri22 = t31;
							this46[this46.length] = tri22;
						}
					}
					break;
				}
				px += dx;
			}
			px = startX;
			py += dy;
		}
		var endIndex = this.shapes.refCount - 1;
	}
	,__class__: trilateralXtra_segment_Character5x7
};
var trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$ = {};
$hxClasses["trilateralXtra.segment._DotMatrix.DotMatrix_Impl_"] = trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$;
trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$.__name__ = true;
trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$._new = function(arr) {
	var this1 = arr;
	return this1;
};
trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$.toString = function(this1) {
	var str = "\n";
	var b8;
	var l = this1.length;
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		b8 = this1[i];
		str += trilateral_bits__$Binary8_Binary8_$Impl_$.toString(b8) + "\n";
	}
	return str;
};
trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$.col = function(this1,n) {
	var this2 = 0;
	var b8 = this2;
	var _g1 = 0;
	var _g = this1.length;
	while(_g1 < _g) {
		var i = _g1++;
		var this3 = this1[i];
		var v;
		switch(n) {
		case 0:
			v = (this3 & 128) == 128;
			break;
		case 1:
			v = (this3 & 64) == 64;
			break;
		case 2:
			v = (this3 & 32) == 32;
			break;
		case 3:
			v = (this3 & 16) == 16;
			break;
		case 4:
			v = (this3 & 8) == 8;
			break;
		case 5:
			v = (this3 & 4) == 4;
			break;
		case 6:
			v = (this3 & 2) == 2;
			break;
		case 7:
			v = (this3 & 1) == 1;
			break;
		default:
			v = false;
		}
		switch(i) {
		case 0:
			if(v) {
				b8 |= 128;
			} else {
				b8 &= -129;
			}
			break;
		case 1:
			if(v) {
				b8 |= 64;
			} else {
				b8 &= -65;
			}
			break;
		case 2:
			if(v) {
				b8 |= 32;
			} else {
				b8 &= -33;
			}
			break;
		case 3:
			if(v) {
				b8 |= 16;
			} else {
				b8 &= -17;
			}
			break;
		case 4:
			if(v) {
				b8 |= 8;
			} else {
				b8 &= -9;
			}
			break;
		case 5:
			if(v) {
				b8 |= 4;
			} else {
				b8 &= -5;
			}
			break;
		case 6:
			if(v) {
				b8 |= 2;
			} else {
				b8 &= -3;
			}
			break;
		case 7:
			if(v) {
				b8 |= 1;
			} else {
				b8 &= -2;
			}
			break;
		default:
		}
	}
	return b8;
};
trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$.valueByIndex = function(this1,i,dig) {
	var x = i % dig;
	var y = Math.floor(i / dig);
	var this2 = this1[y];
	switch(x + 8 - dig) {
	case 0:
		return (this2 & 128) == 128;
	case 1:
		return (this2 & 64) == 64;
	case 2:
		return (this2 & 32) == 32;
	case 3:
		return (this2 & 16) == 16;
	case 4:
		return (this2 & 8) == 8;
	case 5:
		return (this2 & 4) == 4;
	case 6:
		return (this2 & 2) == 2;
	case 7:
		return (this2 & 1) == 1;
	default:
		return false;
	}
};
trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$.clone = function(this1) {
	var arr = [];
	var _g1 = 0;
	var _g = this1.length;
	while(_g1 < _g) {
		var i = _g1++;
		arr[i] = this1[i];
	}
	return trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$._new(arr);
};
trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$.displayLeft = function(arr,dig) {
	var l = arr.length;
	var this1 = arr[0];
	var n = 8 - dig;
	var this2 = 0;
	var b8 = this2;
	var _g1 = 0;
	var _g = this1.length;
	while(_g1 < _g) {
		var i = _g1++;
		var this3 = this1[i];
		var v;
		switch(n) {
		case 0:
			v = (this3 & 128) == 128;
			break;
		case 1:
			v = (this3 & 64) == 64;
			break;
		case 2:
			v = (this3 & 32) == 32;
			break;
		case 3:
			v = (this3 & 16) == 16;
			break;
		case 4:
			v = (this3 & 8) == 8;
			break;
		case 5:
			v = (this3 & 4) == 4;
			break;
		case 6:
			v = (this3 & 2) == 2;
			break;
		case 7:
			v = (this3 & 1) == 1;
			break;
		default:
			v = false;
		}
		switch(i) {
		case 0:
			if(v) {
				b8 |= 128;
			} else {
				b8 &= -129;
			}
			break;
		case 1:
			if(v) {
				b8 |= 64;
			} else {
				b8 &= -65;
			}
			break;
		case 2:
			if(v) {
				b8 |= 32;
			} else {
				b8 &= -33;
			}
			break;
		case 3:
			if(v) {
				b8 |= 16;
			} else {
				b8 &= -17;
			}
			break;
		case 4:
			if(v) {
				b8 |= 8;
			} else {
				b8 &= -9;
			}
			break;
		case 5:
			if(v) {
				b8 |= 4;
			} else {
				b8 &= -5;
			}
			break;
		case 6:
			if(v) {
				b8 |= 2;
			} else {
				b8 &= -3;
			}
			break;
		case 7:
			if(v) {
				b8 |= 1;
			} else {
				b8 &= -2;
			}
			break;
		default:
		}
	}
	var col = b8;
	var _g11 = 0;
	var _g2 = l;
	while(_g11 < _g2) {
		var i1 = _g11++;
		if(i1 + 1 < l) {
			var dm = arr[i1 + 1];
			var here = arr[i1];
			var l2 = here.length;
			var _g12 = 0;
			var _g3 = l2;
			while(_g12 < _g3) {
				var i2 = _g12++;
				if(dig == 0 || dig > 8) {
					var d = (here[i2] & 1) == 1;
					here[i2] = here[i2] << 1;
				} else {
					var d1;
					switch(7 - dig) {
					case 0:
						d1 = (here[i2] & 128) == 128;
						break;
					case 1:
						d1 = (here[i2] & 64) == 64;
						break;
					case 2:
						d1 = (here[i2] & 32) == 32;
						break;
					case 3:
						d1 = (here[i2] & 16) == 16;
						break;
					case 4:
						d1 = (here[i2] & 8) == 8;
						break;
					case 5:
						d1 = (here[i2] & 4) == 4;
						break;
					case 6:
						d1 = (here[i2] & 2) == 2;
						break;
					case 7:
						d1 = (here[i2] & 1) == 1;
						break;
					default:
						d1 = false;
					}
					here[i2] = here[i2] << 1;
					var _g13 = 0;
					var _g4 = 8 - dig;
					while(_g13 < _g4) {
						var i3 = _g13++;
						switch(i3) {
						case 0:
							here[i2] &= -129;
							break;
						case 1:
							here[i2] &= -65;
							break;
						case 2:
							here[i2] &= -33;
							break;
						case 3:
							here[i2] &= -17;
							break;
						case 4:
							here[i2] &= -9;
							break;
						case 5:
							here[i2] &= -5;
							break;
						case 6:
							here[i2] &= -3;
							break;
						case 7:
							here[i2] &= -2;
							break;
						default:
						}
					}
				}
				if(dm != null) {
					var this4 = dm[i2];
					var v1;
					switch(8 - dig) {
					case 0:
						v1 = (this4 & 128) == 128;
						break;
					case 1:
						v1 = (this4 & 64) == 64;
						break;
					case 2:
						v1 = (this4 & 32) == 32;
						break;
					case 3:
						v1 = (this4 & 16) == 16;
						break;
					case 4:
						v1 = (this4 & 8) == 8;
						break;
					case 5:
						v1 = (this4 & 4) == 4;
						break;
					case 6:
						v1 = (this4 & 2) == 2;
						break;
					case 7:
						v1 = (this4 & 1) == 1;
						break;
					default:
						v1 = false;
					}
					if(v1) {
						here[i2] |= 1;
					} else {
						here[i2] &= -2;
					}
				}
			}
		} else {
			var here1 = arr[i1];
			var l21 = here1.length;
			var _g14 = 0;
			var _g5 = l21;
			while(_g14 < _g5) {
				var i4 = _g14++;
				if(dig == 0 || dig > 8) {
					var d2 = (here1[i4] & 1) == 1;
					here1[i4] = here1[i4] << 1;
				} else {
					var d3;
					switch(7 - dig) {
					case 0:
						d3 = (here1[i4] & 128) == 128;
						break;
					case 1:
						d3 = (here1[i4] & 64) == 64;
						break;
					case 2:
						d3 = (here1[i4] & 32) == 32;
						break;
					case 3:
						d3 = (here1[i4] & 16) == 16;
						break;
					case 4:
						d3 = (here1[i4] & 8) == 8;
						break;
					case 5:
						d3 = (here1[i4] & 4) == 4;
						break;
					case 6:
						d3 = (here1[i4] & 2) == 2;
						break;
					case 7:
						d3 = (here1[i4] & 1) == 1;
						break;
					default:
						d3 = false;
					}
					here1[i4] = here1[i4] << 1;
					var _g15 = 0;
					var _g6 = 8 - dig;
					while(_g15 < _g6) {
						var i5 = _g15++;
						switch(i5) {
						case 0:
							here1[i4] &= -129;
							break;
						case 1:
							here1[i4] &= -65;
							break;
						case 2:
							here1[i4] &= -33;
							break;
						case 3:
							here1[i4] &= -17;
							break;
						case 4:
							here1[i4] &= -9;
							break;
						case 5:
							here1[i4] &= -5;
							break;
						case 6:
							here1[i4] &= -3;
							break;
						case 7:
							here1[i4] &= -2;
							break;
						default:
						}
					}
				}
				if(col != null) {
					var v2;
					switch(i4) {
					case 0:
						v2 = (col & 128) == 128;
						break;
					case 1:
						v2 = (col & 64) == 64;
						break;
					case 2:
						v2 = (col & 32) == 32;
						break;
					case 3:
						v2 = (col & 16) == 16;
						break;
					case 4:
						v2 = (col & 8) == 8;
						break;
					case 5:
						v2 = (col & 4) == 4;
						break;
					case 6:
						v2 = (col & 2) == 2;
						break;
					case 7:
						v2 = (col & 1) == 1;
						break;
					default:
						v2 = false;
					}
					if(v2) {
						here1[i4] |= 1;
					} else {
						here1[i4] &= -2;
					}
				}
			}
		}
	}
};
trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$.displayRight = function(arr,dig) {
	var l = arr.length;
	var this1 = arr[l - 1];
	var this2 = 0;
	var b8 = this2;
	var _g1 = 0;
	var _g = this1.length;
	while(_g1 < _g) {
		var i = _g1++;
		var this3 = this1[i];
		var v = (this3 & 1) == 1;
		switch(i) {
		case 0:
			if(v) {
				b8 |= 128;
			} else {
				b8 &= -129;
			}
			break;
		case 1:
			if(v) {
				b8 |= 64;
			} else {
				b8 &= -65;
			}
			break;
		case 2:
			if(v) {
				b8 |= 32;
			} else {
				b8 &= -33;
			}
			break;
		case 3:
			if(v) {
				b8 |= 16;
			} else {
				b8 &= -17;
			}
			break;
		case 4:
			if(v) {
				b8 |= 8;
			} else {
				b8 &= -9;
			}
			break;
		case 5:
			if(v) {
				b8 |= 4;
			} else {
				b8 &= -5;
			}
			break;
		case 6:
			if(v) {
				b8 |= 2;
			} else {
				b8 &= -3;
			}
			break;
		case 7:
			if(v) {
				b8 |= 1;
			} else {
				b8 &= -2;
			}
			break;
		default:
		}
	}
	var col = b8;
	var k;
	var _g11 = 0;
	var _g2 = l;
	while(_g11 < _g2) {
		var i1 = _g11++;
		k = l - i1 - 1;
		if(k > 0) {
			var dm = arr[k - 1];
			var here = arr[k];
			var l2 = here.length;
			var _g12 = 0;
			var _g3 = l2;
			while(_g12 < _g3) {
				var i2 = _g12++;
				if(dig == 0 || dig > 8) {
					var d = (here[i2] & 128) == 128;
					here[i2] = here[i2] >> 1;
				} else {
					var d1;
					switch(7 - dig) {
					case 0:
						d1 = (here[i2] & 128) == 128;
						break;
					case 1:
						d1 = (here[i2] & 64) == 64;
						break;
					case 2:
						d1 = (here[i2] & 32) == 32;
						break;
					case 3:
						d1 = (here[i2] & 16) == 16;
						break;
					case 4:
						d1 = (here[i2] & 8) == 8;
						break;
					case 5:
						d1 = (here[i2] & 4) == 4;
						break;
					case 6:
						d1 = (here[i2] & 2) == 2;
						break;
					case 7:
						d1 = (here[i2] & 1) == 1;
						break;
					default:
						d1 = false;
					}
					here[i2] = here[i2] >> 1;
					var _g13 = 0;
					var _g4 = 8 - dig;
					while(_g13 < _g4) {
						var i3 = _g13++;
						switch(i3) {
						case 0:
							here[i2] &= -129;
							break;
						case 1:
							here[i2] &= -65;
							break;
						case 2:
							here[i2] &= -33;
							break;
						case 3:
							here[i2] &= -17;
							break;
						case 4:
							here[i2] &= -9;
							break;
						case 5:
							here[i2] &= -5;
							break;
						case 6:
							here[i2] &= -3;
							break;
						case 7:
							here[i2] &= -2;
							break;
						default:
						}
					}
				}
				if(dm != null) {
					var v1 = (dm[i2] & 1) == 1;
					if(v1) {
						here[i2] |= 128;
					} else {
						here[i2] &= -129;
					}
				}
			}
		} else {
			var here1 = arr[k];
			var l21 = here1.length;
			var _g14 = 0;
			var _g5 = l21;
			while(_g14 < _g5) {
				var i4 = _g14++;
				if(dig == 0 || dig > 8) {
					var d2 = (here1[i4] & 128) == 128;
					here1[i4] = here1[i4] >> 1;
				} else {
					var d3;
					switch(7 - dig) {
					case 0:
						d3 = (here1[i4] & 128) == 128;
						break;
					case 1:
						d3 = (here1[i4] & 64) == 64;
						break;
					case 2:
						d3 = (here1[i4] & 32) == 32;
						break;
					case 3:
						d3 = (here1[i4] & 16) == 16;
						break;
					case 4:
						d3 = (here1[i4] & 8) == 8;
						break;
					case 5:
						d3 = (here1[i4] & 4) == 4;
						break;
					case 6:
						d3 = (here1[i4] & 2) == 2;
						break;
					case 7:
						d3 = (here1[i4] & 1) == 1;
						break;
					default:
						d3 = false;
					}
					here1[i4] = here1[i4] >> 1;
					var _g15 = 0;
					var _g6 = 8 - dig;
					while(_g15 < _g6) {
						var i5 = _g15++;
						switch(i5) {
						case 0:
							here1[i4] &= -129;
							break;
						case 1:
							here1[i4] &= -65;
							break;
						case 2:
							here1[i4] &= -33;
							break;
						case 3:
							here1[i4] &= -17;
							break;
						case 4:
							here1[i4] &= -9;
							break;
						case 5:
							here1[i4] &= -5;
							break;
						case 6:
							here1[i4] &= -3;
							break;
						case 7:
							here1[i4] &= -2;
							break;
						default:
						}
					}
				}
				if(col != null) {
					var v2;
					switch(i4) {
					case 0:
						v2 = (col & 128) == 128;
						break;
					case 1:
						v2 = (col & 64) == 64;
						break;
					case 2:
						v2 = (col & 32) == 32;
						break;
					case 3:
						v2 = (col & 16) == 16;
						break;
					case 4:
						v2 = (col & 8) == 8;
						break;
					case 5:
						v2 = (col & 4) == 4;
						break;
					case 6:
						v2 = (col & 2) == 2;
						break;
					case 7:
						v2 = (col & 1) == 1;
						break;
					default:
						v2 = false;
					}
					if(v2) {
						here1[i4] |= 128;
					} else {
						here1[i4] &= -129;
					}
				}
			}
		}
	}
};
trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$.leftFirst = function(this1,b8,l) {
	if(l == null) {
		l = 0;
	}
	var here = this1;
	var l2 = here.length;
	var _g1 = 0;
	var _g = l2;
	while(_g1 < _g) {
		var i = _g1++;
		if(l == 0 || l > 8) {
			var d = (here[i] & 1) == 1;
			here[i] = here[i] << 1;
		} else {
			var d1;
			switch(7 - l) {
			case 0:
				d1 = (here[i] & 128) == 128;
				break;
			case 1:
				d1 = (here[i] & 64) == 64;
				break;
			case 2:
				d1 = (here[i] & 32) == 32;
				break;
			case 3:
				d1 = (here[i] & 16) == 16;
				break;
			case 4:
				d1 = (here[i] & 8) == 8;
				break;
			case 5:
				d1 = (here[i] & 4) == 4;
				break;
			case 6:
				d1 = (here[i] & 2) == 2;
				break;
			case 7:
				d1 = (here[i] & 1) == 1;
				break;
			default:
				d1 = false;
			}
			here[i] = here[i] << 1;
			var _g11 = 0;
			var _g2 = 8 - l;
			while(_g11 < _g2) {
				var i1 = _g11++;
				switch(i1) {
				case 0:
					here[i] &= -129;
					break;
				case 1:
					here[i] &= -65;
					break;
				case 2:
					here[i] &= -33;
					break;
				case 3:
					here[i] &= -17;
					break;
				case 4:
					here[i] &= -9;
					break;
				case 5:
					here[i] &= -5;
					break;
				case 6:
					here[i] &= -3;
					break;
				case 7:
					here[i] &= -2;
					break;
				default:
				}
			}
		}
		if(b8 != null) {
			var v;
			switch(i) {
			case 0:
				v = (b8 & 128) == 128;
				break;
			case 1:
				v = (b8 & 64) == 64;
				break;
			case 2:
				v = (b8 & 32) == 32;
				break;
			case 3:
				v = (b8 & 16) == 16;
				break;
			case 4:
				v = (b8 & 8) == 8;
				break;
			case 5:
				v = (b8 & 4) == 4;
				break;
			case 6:
				v = (b8 & 2) == 2;
				break;
			case 7:
				v = (b8 & 1) == 1;
				break;
			default:
				v = false;
			}
			if(v) {
				here[i] |= 1;
			} else {
				here[i] &= -2;
			}
		}
	}
};
trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$.left = function(this1,dm,l) {
	if(l == null) {
		l = 0;
	}
	var here = this1;
	var l2 = here.length;
	var _g1 = 0;
	var _g = l2;
	while(_g1 < _g) {
		var i = _g1++;
		if(l == 0 || l > 8) {
			var d = (here[i] & 1) == 1;
			here[i] = here[i] << 1;
		} else {
			var d1;
			switch(7 - l) {
			case 0:
				d1 = (here[i] & 128) == 128;
				break;
			case 1:
				d1 = (here[i] & 64) == 64;
				break;
			case 2:
				d1 = (here[i] & 32) == 32;
				break;
			case 3:
				d1 = (here[i] & 16) == 16;
				break;
			case 4:
				d1 = (here[i] & 8) == 8;
				break;
			case 5:
				d1 = (here[i] & 4) == 4;
				break;
			case 6:
				d1 = (here[i] & 2) == 2;
				break;
			case 7:
				d1 = (here[i] & 1) == 1;
				break;
			default:
				d1 = false;
			}
			here[i] = here[i] << 1;
			var _g11 = 0;
			var _g2 = 8 - l;
			while(_g11 < _g2) {
				var i1 = _g11++;
				switch(i1) {
				case 0:
					here[i] &= -129;
					break;
				case 1:
					here[i] &= -65;
					break;
				case 2:
					here[i] &= -33;
					break;
				case 3:
					here[i] &= -17;
					break;
				case 4:
					here[i] &= -9;
					break;
				case 5:
					here[i] &= -5;
					break;
				case 6:
					here[i] &= -3;
					break;
				case 7:
					here[i] &= -2;
					break;
				default:
				}
			}
		}
		if(dm != null) {
			var this2 = dm[i];
			var v;
			switch(8 - l) {
			case 0:
				v = (this2 & 128) == 128;
				break;
			case 1:
				v = (this2 & 64) == 64;
				break;
			case 2:
				v = (this2 & 32) == 32;
				break;
			case 3:
				v = (this2 & 16) == 16;
				break;
			case 4:
				v = (this2 & 8) == 8;
				break;
			case 5:
				v = (this2 & 4) == 4;
				break;
			case 6:
				v = (this2 & 2) == 2;
				break;
			case 7:
				v = (this2 & 1) == 1;
				break;
			default:
				v = false;
			}
			if(v) {
				here[i] |= 1;
			} else {
				here[i] &= -2;
			}
		}
	}
};
trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$.rightLast = function(this1,b8,l) {
	if(l == null) {
		l = 0;
	}
	var here = this1;
	var l2 = here.length;
	var _g1 = 0;
	var _g = l2;
	while(_g1 < _g) {
		var i = _g1++;
		if(l == 0 || l > 8) {
			var d = (here[i] & 128) == 128;
			here[i] = here[i] >> 1;
		} else {
			var d1;
			switch(7 - l) {
			case 0:
				d1 = (here[i] & 128) == 128;
				break;
			case 1:
				d1 = (here[i] & 64) == 64;
				break;
			case 2:
				d1 = (here[i] & 32) == 32;
				break;
			case 3:
				d1 = (here[i] & 16) == 16;
				break;
			case 4:
				d1 = (here[i] & 8) == 8;
				break;
			case 5:
				d1 = (here[i] & 4) == 4;
				break;
			case 6:
				d1 = (here[i] & 2) == 2;
				break;
			case 7:
				d1 = (here[i] & 1) == 1;
				break;
			default:
				d1 = false;
			}
			here[i] = here[i] >> 1;
			var _g11 = 0;
			var _g2 = 8 - l;
			while(_g11 < _g2) {
				var i1 = _g11++;
				switch(i1) {
				case 0:
					here[i] &= -129;
					break;
				case 1:
					here[i] &= -65;
					break;
				case 2:
					here[i] &= -33;
					break;
				case 3:
					here[i] &= -17;
					break;
				case 4:
					here[i] &= -9;
					break;
				case 5:
					here[i] &= -5;
					break;
				case 6:
					here[i] &= -3;
					break;
				case 7:
					here[i] &= -2;
					break;
				default:
				}
			}
		}
		if(b8 != null) {
			var v;
			switch(i) {
			case 0:
				v = (b8 & 128) == 128;
				break;
			case 1:
				v = (b8 & 64) == 64;
				break;
			case 2:
				v = (b8 & 32) == 32;
				break;
			case 3:
				v = (b8 & 16) == 16;
				break;
			case 4:
				v = (b8 & 8) == 8;
				break;
			case 5:
				v = (b8 & 4) == 4;
				break;
			case 6:
				v = (b8 & 2) == 2;
				break;
			case 7:
				v = (b8 & 1) == 1;
				break;
			default:
				v = false;
			}
			if(v) {
				here[i] |= 128;
			} else {
				here[i] &= -129;
			}
		}
	}
};
trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$.right = function(this1,dm,l) {
	if(l == null) {
		l = 0;
	}
	var here = this1;
	var l2 = here.length;
	var _g1 = 0;
	var _g = l2;
	while(_g1 < _g) {
		var i = _g1++;
		if(l == 0 || l > 8) {
			var d = (here[i] & 128) == 128;
			here[i] = here[i] >> 1;
		} else {
			var d1;
			switch(7 - l) {
			case 0:
				d1 = (here[i] & 128) == 128;
				break;
			case 1:
				d1 = (here[i] & 64) == 64;
				break;
			case 2:
				d1 = (here[i] & 32) == 32;
				break;
			case 3:
				d1 = (here[i] & 16) == 16;
				break;
			case 4:
				d1 = (here[i] & 8) == 8;
				break;
			case 5:
				d1 = (here[i] & 4) == 4;
				break;
			case 6:
				d1 = (here[i] & 2) == 2;
				break;
			case 7:
				d1 = (here[i] & 1) == 1;
				break;
			default:
				d1 = false;
			}
			here[i] = here[i] >> 1;
			var _g11 = 0;
			var _g2 = 8 - l;
			while(_g11 < _g2) {
				var i1 = _g11++;
				switch(i1) {
				case 0:
					here[i] &= -129;
					break;
				case 1:
					here[i] &= -65;
					break;
				case 2:
					here[i] &= -33;
					break;
				case 3:
					here[i] &= -17;
					break;
				case 4:
					here[i] &= -9;
					break;
				case 5:
					here[i] &= -5;
					break;
				case 6:
					here[i] &= -3;
					break;
				case 7:
					here[i] &= -2;
					break;
				default:
				}
			}
		}
		if(dm != null) {
			var v = (dm[i] & 1) == 1;
			if(v) {
				here[i] |= 128;
			} else {
				here[i] &= -129;
			}
		}
	}
};
trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$.toStars = function(this1) {
	var str = "\n";
	var b8;
	var l = this1.length;
	var _g1 = 0;
	var _g = l;
	while(_g1 < _g) {
		var i = _g1++;
		b8 = this1[i];
		str += trilateral_bits__$Binary8_Binary8_$Impl_$.toStars(b8) + "\n";
	}
	return str;
};
trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$.display = function(str) {
	var arr = [];
	var _g1 = 0;
	var _g = str.length;
	while(_g1 < _g) {
		var i = _g1++;
		var charCode = HxOverrides.cca(str,i);
		var arr1 = [];
		switch(charCode) {
		case 32:
			var this1 = 0;
			var bs = this1;
			var l = "00000".length;
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i1 = _g11++;
				var no = "00000".charCodeAt(i1);
				if(no == null) {
					break;
				}
				var v;
				switch(no) {
				case 32:
					v = false;
					break;
				case 42:
					v = true;
					break;
				case 48:
					v = false;
					break;
				case 49:
					v = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i1)));
				}
				switch(i1 - (l - 8)) {
				case 0:
					if(v) {
						bs |= 128;
					} else {
						bs &= -129;
					}
					break;
				case 1:
					if(v) {
						bs |= 64;
					} else {
						bs &= -65;
					}
					break;
				case 2:
					if(v) {
						bs |= 32;
					} else {
						bs &= -33;
					}
					break;
				case 3:
					if(v) {
						bs |= 16;
					} else {
						bs &= -17;
					}
					break;
				case 4:
					if(v) {
						bs |= 8;
					} else {
						bs &= -9;
					}
					break;
				case 5:
					if(v) {
						bs |= 4;
					} else {
						bs &= -5;
					}
					break;
				case 6:
					if(v) {
						bs |= 2;
					} else {
						bs &= -3;
					}
					break;
				case 7:
					if(v) {
						bs |= 1;
					} else {
						bs &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs;
			var this2 = 0;
			var bs1 = this2;
			var l1 = "00000".length;
			var _g12 = 0;
			var _g3 = l1;
			while(_g12 < _g3) {
				var i2 = _g12++;
				var no1 = "00000".charCodeAt(i2);
				if(no1 == null) {
					break;
				}
				var v1;
				switch(no1) {
				case 32:
					v1 = false;
					break;
				case 42:
					v1 = true;
					break;
				case 48:
					v1 = false;
					break;
				case 49:
					v1 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i2)));
				}
				switch(i2 - (l1 - 8)) {
				case 0:
					if(v1) {
						bs1 |= 128;
					} else {
						bs1 &= -129;
					}
					break;
				case 1:
					if(v1) {
						bs1 |= 64;
					} else {
						bs1 &= -65;
					}
					break;
				case 2:
					if(v1) {
						bs1 |= 32;
					} else {
						bs1 &= -33;
					}
					break;
				case 3:
					if(v1) {
						bs1 |= 16;
					} else {
						bs1 &= -17;
					}
					break;
				case 4:
					if(v1) {
						bs1 |= 8;
					} else {
						bs1 &= -9;
					}
					break;
				case 5:
					if(v1) {
						bs1 |= 4;
					} else {
						bs1 &= -5;
					}
					break;
				case 6:
					if(v1) {
						bs1 |= 2;
					} else {
						bs1 &= -3;
					}
					break;
				case 7:
					if(v1) {
						bs1 |= 1;
					} else {
						bs1 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs1;
			var this3 = 0;
			var bs2 = this3;
			var l2 = "00000".length;
			var _g13 = 0;
			var _g4 = l2;
			while(_g13 < _g4) {
				var i3 = _g13++;
				var no2 = "00000".charCodeAt(i3);
				if(no2 == null) {
					break;
				}
				var v2;
				switch(no2) {
				case 32:
					v2 = false;
					break;
				case 42:
					v2 = true;
					break;
				case 48:
					v2 = false;
					break;
				case 49:
					v2 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i3)));
				}
				switch(i3 - (l2 - 8)) {
				case 0:
					if(v2) {
						bs2 |= 128;
					} else {
						bs2 &= -129;
					}
					break;
				case 1:
					if(v2) {
						bs2 |= 64;
					} else {
						bs2 &= -65;
					}
					break;
				case 2:
					if(v2) {
						bs2 |= 32;
					} else {
						bs2 &= -33;
					}
					break;
				case 3:
					if(v2) {
						bs2 |= 16;
					} else {
						bs2 &= -17;
					}
					break;
				case 4:
					if(v2) {
						bs2 |= 8;
					} else {
						bs2 &= -9;
					}
					break;
				case 5:
					if(v2) {
						bs2 |= 4;
					} else {
						bs2 &= -5;
					}
					break;
				case 6:
					if(v2) {
						bs2 |= 2;
					} else {
						bs2 &= -3;
					}
					break;
				case 7:
					if(v2) {
						bs2 |= 1;
					} else {
						bs2 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs2;
			var this4 = 0;
			var bs3 = this4;
			var l3 = "00000".length;
			var _g14 = 0;
			var _g5 = l3;
			while(_g14 < _g5) {
				var i4 = _g14++;
				var no3 = "00000".charCodeAt(i4);
				if(no3 == null) {
					break;
				}
				var v3;
				switch(no3) {
				case 32:
					v3 = false;
					break;
				case 42:
					v3 = true;
					break;
				case 48:
					v3 = false;
					break;
				case 49:
					v3 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i4)));
				}
				switch(i4 - (l3 - 8)) {
				case 0:
					if(v3) {
						bs3 |= 128;
					} else {
						bs3 &= -129;
					}
					break;
				case 1:
					if(v3) {
						bs3 |= 64;
					} else {
						bs3 &= -65;
					}
					break;
				case 2:
					if(v3) {
						bs3 |= 32;
					} else {
						bs3 &= -33;
					}
					break;
				case 3:
					if(v3) {
						bs3 |= 16;
					} else {
						bs3 &= -17;
					}
					break;
				case 4:
					if(v3) {
						bs3 |= 8;
					} else {
						bs3 &= -9;
					}
					break;
				case 5:
					if(v3) {
						bs3 |= 4;
					} else {
						bs3 &= -5;
					}
					break;
				case 6:
					if(v3) {
						bs3 |= 2;
					} else {
						bs3 &= -3;
					}
					break;
				case 7:
					if(v3) {
						bs3 |= 1;
					} else {
						bs3 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs3;
			var this5 = 0;
			var bs4 = this5;
			var l4 = "00000".length;
			var _g15 = 0;
			var _g6 = l4;
			while(_g15 < _g6) {
				var i5 = _g15++;
				var no4 = "00000".charCodeAt(i5);
				if(no4 == null) {
					break;
				}
				var v4;
				switch(no4) {
				case 32:
					v4 = false;
					break;
				case 42:
					v4 = true;
					break;
				case 48:
					v4 = false;
					break;
				case 49:
					v4 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i5)));
				}
				switch(i5 - (l4 - 8)) {
				case 0:
					if(v4) {
						bs4 |= 128;
					} else {
						bs4 &= -129;
					}
					break;
				case 1:
					if(v4) {
						bs4 |= 64;
					} else {
						bs4 &= -65;
					}
					break;
				case 2:
					if(v4) {
						bs4 |= 32;
					} else {
						bs4 &= -33;
					}
					break;
				case 3:
					if(v4) {
						bs4 |= 16;
					} else {
						bs4 &= -17;
					}
					break;
				case 4:
					if(v4) {
						bs4 |= 8;
					} else {
						bs4 &= -9;
					}
					break;
				case 5:
					if(v4) {
						bs4 |= 4;
					} else {
						bs4 &= -5;
					}
					break;
				case 6:
					if(v4) {
						bs4 |= 2;
					} else {
						bs4 &= -3;
					}
					break;
				case 7:
					if(v4) {
						bs4 |= 1;
					} else {
						bs4 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs4;
			var this6 = 0;
			var bs5 = this6;
			var l5 = "00000".length;
			var _g16 = 0;
			var _g7 = l5;
			while(_g16 < _g7) {
				var i6 = _g16++;
				var no5 = "00000".charCodeAt(i6);
				if(no5 == null) {
					break;
				}
				var v5;
				switch(no5) {
				case 32:
					v5 = false;
					break;
				case 42:
					v5 = true;
					break;
				case 48:
					v5 = false;
					break;
				case 49:
					v5 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i6)));
				}
				switch(i6 - (l5 - 8)) {
				case 0:
					if(v5) {
						bs5 |= 128;
					} else {
						bs5 &= -129;
					}
					break;
				case 1:
					if(v5) {
						bs5 |= 64;
					} else {
						bs5 &= -65;
					}
					break;
				case 2:
					if(v5) {
						bs5 |= 32;
					} else {
						bs5 &= -33;
					}
					break;
				case 3:
					if(v5) {
						bs5 |= 16;
					} else {
						bs5 &= -17;
					}
					break;
				case 4:
					if(v5) {
						bs5 |= 8;
					} else {
						bs5 &= -9;
					}
					break;
				case 5:
					if(v5) {
						bs5 |= 4;
					} else {
						bs5 &= -5;
					}
					break;
				case 6:
					if(v5) {
						bs5 |= 2;
					} else {
						bs5 &= -3;
					}
					break;
				case 7:
					if(v5) {
						bs5 |= 1;
					} else {
						bs5 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs5;
			var this7 = 0;
			var bs6 = this7;
			var l6 = "00000".length;
			var _g17 = 0;
			var _g8 = l6;
			while(_g17 < _g8) {
				var i7 = _g17++;
				var no6 = "00000".charCodeAt(i7);
				if(no6 == null) {
					break;
				}
				var v6;
				switch(no6) {
				case 32:
					v6 = false;
					break;
				case 42:
					v6 = true;
					break;
				case 48:
					v6 = false;
					break;
				case 49:
					v6 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i7)));
				}
				switch(i7 - (l6 - 8)) {
				case 0:
					if(v6) {
						bs6 |= 128;
					} else {
						bs6 &= -129;
					}
					break;
				case 1:
					if(v6) {
						bs6 |= 64;
					} else {
						bs6 &= -65;
					}
					break;
				case 2:
					if(v6) {
						bs6 |= 32;
					} else {
						bs6 &= -33;
					}
					break;
				case 3:
					if(v6) {
						bs6 |= 16;
					} else {
						bs6 &= -17;
					}
					break;
				case 4:
					if(v6) {
						bs6 |= 8;
					} else {
						bs6 &= -9;
					}
					break;
				case 5:
					if(v6) {
						bs6 |= 4;
					} else {
						bs6 &= -5;
					}
					break;
				case 6:
					if(v6) {
						bs6 |= 2;
					} else {
						bs6 &= -3;
					}
					break;
				case 7:
					if(v6) {
						bs6 |= 1;
					} else {
						bs6 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs6;
			break;
		case 33:
			var this8 = 0;
			var bs7 = this8;
			var l7 = "  *  ".length;
			var _g18 = 0;
			var _g9 = l7;
			while(_g18 < _g9) {
				var i8 = _g18++;
				var no7 = "  *  ".charCodeAt(i8);
				if(no7 == null) {
					break;
				}
				var v7;
				switch(no7) {
				case 32:
					v7 = false;
					break;
				case 42:
					v7 = true;
					break;
				case 48:
					v7 = false;
					break;
				case 49:
					v7 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i8)));
				}
				switch(i8 - (l7 - 8)) {
				case 0:
					if(v7) {
						bs7 |= 128;
					} else {
						bs7 &= -129;
					}
					break;
				case 1:
					if(v7) {
						bs7 |= 64;
					} else {
						bs7 &= -65;
					}
					break;
				case 2:
					if(v7) {
						bs7 |= 32;
					} else {
						bs7 &= -33;
					}
					break;
				case 3:
					if(v7) {
						bs7 |= 16;
					} else {
						bs7 &= -17;
					}
					break;
				case 4:
					if(v7) {
						bs7 |= 8;
					} else {
						bs7 &= -9;
					}
					break;
				case 5:
					if(v7) {
						bs7 |= 4;
					} else {
						bs7 &= -5;
					}
					break;
				case 6:
					if(v7) {
						bs7 |= 2;
					} else {
						bs7 &= -3;
					}
					break;
				case 7:
					if(v7) {
						bs7 |= 1;
					} else {
						bs7 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs7;
			var this9 = 0;
			var bs8 = this9;
			var l8 = "  *  ".length;
			var _g19 = 0;
			var _g10 = l8;
			while(_g19 < _g10) {
				var i9 = _g19++;
				var no8 = "  *  ".charCodeAt(i9);
				if(no8 == null) {
					break;
				}
				var v8;
				switch(no8) {
				case 32:
					v8 = false;
					break;
				case 42:
					v8 = true;
					break;
				case 48:
					v8 = false;
					break;
				case 49:
					v8 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i9)));
				}
				switch(i9 - (l8 - 8)) {
				case 0:
					if(v8) {
						bs8 |= 128;
					} else {
						bs8 &= -129;
					}
					break;
				case 1:
					if(v8) {
						bs8 |= 64;
					} else {
						bs8 &= -65;
					}
					break;
				case 2:
					if(v8) {
						bs8 |= 32;
					} else {
						bs8 &= -33;
					}
					break;
				case 3:
					if(v8) {
						bs8 |= 16;
					} else {
						bs8 &= -17;
					}
					break;
				case 4:
					if(v8) {
						bs8 |= 8;
					} else {
						bs8 &= -9;
					}
					break;
				case 5:
					if(v8) {
						bs8 |= 4;
					} else {
						bs8 &= -5;
					}
					break;
				case 6:
					if(v8) {
						bs8 |= 2;
					} else {
						bs8 &= -3;
					}
					break;
				case 7:
					if(v8) {
						bs8 |= 1;
					} else {
						bs8 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs8;
			var this10 = 0;
			var bs9 = this10;
			var l9 = "  *  ".length;
			var _g110 = 0;
			var _g20 = l9;
			while(_g110 < _g20) {
				var i10 = _g110++;
				var no9 = "  *  ".charCodeAt(i10);
				if(no9 == null) {
					break;
				}
				var v9;
				switch(no9) {
				case 32:
					v9 = false;
					break;
				case 42:
					v9 = true;
					break;
				case 48:
					v9 = false;
					break;
				case 49:
					v9 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i10)));
				}
				switch(i10 - (l9 - 8)) {
				case 0:
					if(v9) {
						bs9 |= 128;
					} else {
						bs9 &= -129;
					}
					break;
				case 1:
					if(v9) {
						bs9 |= 64;
					} else {
						bs9 &= -65;
					}
					break;
				case 2:
					if(v9) {
						bs9 |= 32;
					} else {
						bs9 &= -33;
					}
					break;
				case 3:
					if(v9) {
						bs9 |= 16;
					} else {
						bs9 &= -17;
					}
					break;
				case 4:
					if(v9) {
						bs9 |= 8;
					} else {
						bs9 &= -9;
					}
					break;
				case 5:
					if(v9) {
						bs9 |= 4;
					} else {
						bs9 &= -5;
					}
					break;
				case 6:
					if(v9) {
						bs9 |= 2;
					} else {
						bs9 &= -3;
					}
					break;
				case 7:
					if(v9) {
						bs9 |= 1;
					} else {
						bs9 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs9;
			var this11 = 0;
			var bs10 = this11;
			var l10 = "  *  ".length;
			var _g111 = 0;
			var _g21 = l10;
			while(_g111 < _g21) {
				var i11 = _g111++;
				var no10 = "  *  ".charCodeAt(i11);
				if(no10 == null) {
					break;
				}
				var v10;
				switch(no10) {
				case 32:
					v10 = false;
					break;
				case 42:
					v10 = true;
					break;
				case 48:
					v10 = false;
					break;
				case 49:
					v10 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i11)));
				}
				switch(i11 - (l10 - 8)) {
				case 0:
					if(v10) {
						bs10 |= 128;
					} else {
						bs10 &= -129;
					}
					break;
				case 1:
					if(v10) {
						bs10 |= 64;
					} else {
						bs10 &= -65;
					}
					break;
				case 2:
					if(v10) {
						bs10 |= 32;
					} else {
						bs10 &= -33;
					}
					break;
				case 3:
					if(v10) {
						bs10 |= 16;
					} else {
						bs10 &= -17;
					}
					break;
				case 4:
					if(v10) {
						bs10 |= 8;
					} else {
						bs10 &= -9;
					}
					break;
				case 5:
					if(v10) {
						bs10 |= 4;
					} else {
						bs10 &= -5;
					}
					break;
				case 6:
					if(v10) {
						bs10 |= 2;
					} else {
						bs10 &= -3;
					}
					break;
				case 7:
					if(v10) {
						bs10 |= 1;
					} else {
						bs10 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs10;
			var this12 = 0;
			var bs11 = this12;
			var l11 = "     ".length;
			var _g112 = 0;
			var _g22 = l11;
			while(_g112 < _g22) {
				var i12 = _g112++;
				var no11 = "     ".charCodeAt(i12);
				if(no11 == null) {
					break;
				}
				var v11;
				switch(no11) {
				case 32:
					v11 = false;
					break;
				case 42:
					v11 = true;
					break;
				case 48:
					v11 = false;
					break;
				case 49:
					v11 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i12)));
				}
				switch(i12 - (l11 - 8)) {
				case 0:
					if(v11) {
						bs11 |= 128;
					} else {
						bs11 &= -129;
					}
					break;
				case 1:
					if(v11) {
						bs11 |= 64;
					} else {
						bs11 &= -65;
					}
					break;
				case 2:
					if(v11) {
						bs11 |= 32;
					} else {
						bs11 &= -33;
					}
					break;
				case 3:
					if(v11) {
						bs11 |= 16;
					} else {
						bs11 &= -17;
					}
					break;
				case 4:
					if(v11) {
						bs11 |= 8;
					} else {
						bs11 &= -9;
					}
					break;
				case 5:
					if(v11) {
						bs11 |= 4;
					} else {
						bs11 &= -5;
					}
					break;
				case 6:
					if(v11) {
						bs11 |= 2;
					} else {
						bs11 &= -3;
					}
					break;
				case 7:
					if(v11) {
						bs11 |= 1;
					} else {
						bs11 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs11;
			var this13 = 0;
			var bs12 = this13;
			var l12 = "  *  ".length;
			var _g113 = 0;
			var _g23 = l12;
			while(_g113 < _g23) {
				var i13 = _g113++;
				var no12 = "  *  ".charCodeAt(i13);
				if(no12 == null) {
					break;
				}
				var v12;
				switch(no12) {
				case 32:
					v12 = false;
					break;
				case 42:
					v12 = true;
					break;
				case 48:
					v12 = false;
					break;
				case 49:
					v12 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i13)));
				}
				switch(i13 - (l12 - 8)) {
				case 0:
					if(v12) {
						bs12 |= 128;
					} else {
						bs12 &= -129;
					}
					break;
				case 1:
					if(v12) {
						bs12 |= 64;
					} else {
						bs12 &= -65;
					}
					break;
				case 2:
					if(v12) {
						bs12 |= 32;
					} else {
						bs12 &= -33;
					}
					break;
				case 3:
					if(v12) {
						bs12 |= 16;
					} else {
						bs12 &= -17;
					}
					break;
				case 4:
					if(v12) {
						bs12 |= 8;
					} else {
						bs12 &= -9;
					}
					break;
				case 5:
					if(v12) {
						bs12 |= 4;
					} else {
						bs12 &= -5;
					}
					break;
				case 6:
					if(v12) {
						bs12 |= 2;
					} else {
						bs12 &= -3;
					}
					break;
				case 7:
					if(v12) {
						bs12 |= 1;
					} else {
						bs12 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs12;
			var this14 = 0;
			var bs13 = this14;
			var l13 = "     ".length;
			var _g114 = 0;
			var _g24 = l13;
			while(_g114 < _g24) {
				var i14 = _g114++;
				var no13 = "     ".charCodeAt(i14);
				if(no13 == null) {
					break;
				}
				var v13;
				switch(no13) {
				case 32:
					v13 = false;
					break;
				case 42:
					v13 = true;
					break;
				case 48:
					v13 = false;
					break;
				case 49:
					v13 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i14)));
				}
				switch(i14 - (l13 - 8)) {
				case 0:
					if(v13) {
						bs13 |= 128;
					} else {
						bs13 &= -129;
					}
					break;
				case 1:
					if(v13) {
						bs13 |= 64;
					} else {
						bs13 &= -65;
					}
					break;
				case 2:
					if(v13) {
						bs13 |= 32;
					} else {
						bs13 &= -33;
					}
					break;
				case 3:
					if(v13) {
						bs13 |= 16;
					} else {
						bs13 &= -17;
					}
					break;
				case 4:
					if(v13) {
						bs13 |= 8;
					} else {
						bs13 &= -9;
					}
					break;
				case 5:
					if(v13) {
						bs13 |= 4;
					} else {
						bs13 &= -5;
					}
					break;
				case 6:
					if(v13) {
						bs13 |= 2;
					} else {
						bs13 &= -3;
					}
					break;
				case 7:
					if(v13) {
						bs13 |= 1;
					} else {
						bs13 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs13;
			break;
		case 34:
			var this15 = 0;
			var bs14 = this15;
			var l14 = "     ".length;
			var _g115 = 0;
			var _g25 = l14;
			while(_g115 < _g25) {
				var i15 = _g115++;
				var no14 = "     ".charCodeAt(i15);
				if(no14 == null) {
					break;
				}
				var v14;
				switch(no14) {
				case 32:
					v14 = false;
					break;
				case 42:
					v14 = true;
					break;
				case 48:
					v14 = false;
					break;
				case 49:
					v14 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i15)));
				}
				switch(i15 - (l14 - 8)) {
				case 0:
					if(v14) {
						bs14 |= 128;
					} else {
						bs14 &= -129;
					}
					break;
				case 1:
					if(v14) {
						bs14 |= 64;
					} else {
						bs14 &= -65;
					}
					break;
				case 2:
					if(v14) {
						bs14 |= 32;
					} else {
						bs14 &= -33;
					}
					break;
				case 3:
					if(v14) {
						bs14 |= 16;
					} else {
						bs14 &= -17;
					}
					break;
				case 4:
					if(v14) {
						bs14 |= 8;
					} else {
						bs14 &= -9;
					}
					break;
				case 5:
					if(v14) {
						bs14 |= 4;
					} else {
						bs14 &= -5;
					}
					break;
				case 6:
					if(v14) {
						bs14 |= 2;
					} else {
						bs14 &= -3;
					}
					break;
				case 7:
					if(v14) {
						bs14 |= 1;
					} else {
						bs14 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs14;
			var this16 = 0;
			var bs15 = this16;
			var l15 = " * * ".length;
			var _g116 = 0;
			var _g26 = l15;
			while(_g116 < _g26) {
				var i16 = _g116++;
				var no15 = " * * ".charCodeAt(i16);
				if(no15 == null) {
					break;
				}
				var v15;
				switch(no15) {
				case 32:
					v15 = false;
					break;
				case 42:
					v15 = true;
					break;
				case 48:
					v15 = false;
					break;
				case 49:
					v15 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i16)));
				}
				switch(i16 - (l15 - 8)) {
				case 0:
					if(v15) {
						bs15 |= 128;
					} else {
						bs15 &= -129;
					}
					break;
				case 1:
					if(v15) {
						bs15 |= 64;
					} else {
						bs15 &= -65;
					}
					break;
				case 2:
					if(v15) {
						bs15 |= 32;
					} else {
						bs15 &= -33;
					}
					break;
				case 3:
					if(v15) {
						bs15 |= 16;
					} else {
						bs15 &= -17;
					}
					break;
				case 4:
					if(v15) {
						bs15 |= 8;
					} else {
						bs15 &= -9;
					}
					break;
				case 5:
					if(v15) {
						bs15 |= 4;
					} else {
						bs15 &= -5;
					}
					break;
				case 6:
					if(v15) {
						bs15 |= 2;
					} else {
						bs15 &= -3;
					}
					break;
				case 7:
					if(v15) {
						bs15 |= 1;
					} else {
						bs15 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs15;
			var this17 = 0;
			var bs16 = this17;
			var l16 = " * * ".length;
			var _g117 = 0;
			var _g27 = l16;
			while(_g117 < _g27) {
				var i17 = _g117++;
				var no16 = " * * ".charCodeAt(i17);
				if(no16 == null) {
					break;
				}
				var v16;
				switch(no16) {
				case 32:
					v16 = false;
					break;
				case 42:
					v16 = true;
					break;
				case 48:
					v16 = false;
					break;
				case 49:
					v16 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i17)));
				}
				switch(i17 - (l16 - 8)) {
				case 0:
					if(v16) {
						bs16 |= 128;
					} else {
						bs16 &= -129;
					}
					break;
				case 1:
					if(v16) {
						bs16 |= 64;
					} else {
						bs16 &= -65;
					}
					break;
				case 2:
					if(v16) {
						bs16 |= 32;
					} else {
						bs16 &= -33;
					}
					break;
				case 3:
					if(v16) {
						bs16 |= 16;
					} else {
						bs16 &= -17;
					}
					break;
				case 4:
					if(v16) {
						bs16 |= 8;
					} else {
						bs16 &= -9;
					}
					break;
				case 5:
					if(v16) {
						bs16 |= 4;
					} else {
						bs16 &= -5;
					}
					break;
				case 6:
					if(v16) {
						bs16 |= 2;
					} else {
						bs16 &= -3;
					}
					break;
				case 7:
					if(v16) {
						bs16 |= 1;
					} else {
						bs16 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs16;
			var this18 = 0;
			var bs17 = this18;
			var l17 = " * * ".length;
			var _g118 = 0;
			var _g28 = l17;
			while(_g118 < _g28) {
				var i18 = _g118++;
				var no17 = " * * ".charCodeAt(i18);
				if(no17 == null) {
					break;
				}
				var v17;
				switch(no17) {
				case 32:
					v17 = false;
					break;
				case 42:
					v17 = true;
					break;
				case 48:
					v17 = false;
					break;
				case 49:
					v17 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i18)));
				}
				switch(i18 - (l17 - 8)) {
				case 0:
					if(v17) {
						bs17 |= 128;
					} else {
						bs17 &= -129;
					}
					break;
				case 1:
					if(v17) {
						bs17 |= 64;
					} else {
						bs17 &= -65;
					}
					break;
				case 2:
					if(v17) {
						bs17 |= 32;
					} else {
						bs17 &= -33;
					}
					break;
				case 3:
					if(v17) {
						bs17 |= 16;
					} else {
						bs17 &= -17;
					}
					break;
				case 4:
					if(v17) {
						bs17 |= 8;
					} else {
						bs17 &= -9;
					}
					break;
				case 5:
					if(v17) {
						bs17 |= 4;
					} else {
						bs17 &= -5;
					}
					break;
				case 6:
					if(v17) {
						bs17 |= 2;
					} else {
						bs17 &= -3;
					}
					break;
				case 7:
					if(v17) {
						bs17 |= 1;
					} else {
						bs17 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs17;
			var this19 = 0;
			var bs18 = this19;
			var l18 = "     ".length;
			var _g119 = 0;
			var _g29 = l18;
			while(_g119 < _g29) {
				var i19 = _g119++;
				var no18 = "     ".charCodeAt(i19);
				if(no18 == null) {
					break;
				}
				var v18;
				switch(no18) {
				case 32:
					v18 = false;
					break;
				case 42:
					v18 = true;
					break;
				case 48:
					v18 = false;
					break;
				case 49:
					v18 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i19)));
				}
				switch(i19 - (l18 - 8)) {
				case 0:
					if(v18) {
						bs18 |= 128;
					} else {
						bs18 &= -129;
					}
					break;
				case 1:
					if(v18) {
						bs18 |= 64;
					} else {
						bs18 &= -65;
					}
					break;
				case 2:
					if(v18) {
						bs18 |= 32;
					} else {
						bs18 &= -33;
					}
					break;
				case 3:
					if(v18) {
						bs18 |= 16;
					} else {
						bs18 &= -17;
					}
					break;
				case 4:
					if(v18) {
						bs18 |= 8;
					} else {
						bs18 &= -9;
					}
					break;
				case 5:
					if(v18) {
						bs18 |= 4;
					} else {
						bs18 &= -5;
					}
					break;
				case 6:
					if(v18) {
						bs18 |= 2;
					} else {
						bs18 &= -3;
					}
					break;
				case 7:
					if(v18) {
						bs18 |= 1;
					} else {
						bs18 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs18;
			var this20 = 0;
			var bs19 = this20;
			var l19 = "     ".length;
			var _g120 = 0;
			var _g30 = l19;
			while(_g120 < _g30) {
				var i20 = _g120++;
				var no19 = "     ".charCodeAt(i20);
				if(no19 == null) {
					break;
				}
				var v19;
				switch(no19) {
				case 32:
					v19 = false;
					break;
				case 42:
					v19 = true;
					break;
				case 48:
					v19 = false;
					break;
				case 49:
					v19 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i20)));
				}
				switch(i20 - (l19 - 8)) {
				case 0:
					if(v19) {
						bs19 |= 128;
					} else {
						bs19 &= -129;
					}
					break;
				case 1:
					if(v19) {
						bs19 |= 64;
					} else {
						bs19 &= -65;
					}
					break;
				case 2:
					if(v19) {
						bs19 |= 32;
					} else {
						bs19 &= -33;
					}
					break;
				case 3:
					if(v19) {
						bs19 |= 16;
					} else {
						bs19 &= -17;
					}
					break;
				case 4:
					if(v19) {
						bs19 |= 8;
					} else {
						bs19 &= -9;
					}
					break;
				case 5:
					if(v19) {
						bs19 |= 4;
					} else {
						bs19 &= -5;
					}
					break;
				case 6:
					if(v19) {
						bs19 |= 2;
					} else {
						bs19 &= -3;
					}
					break;
				case 7:
					if(v19) {
						bs19 |= 1;
					} else {
						bs19 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs19;
			var this21 = 0;
			var bs20 = this21;
			var l20 = "     ".length;
			var _g121 = 0;
			var _g31 = l20;
			while(_g121 < _g31) {
				var i21 = _g121++;
				var no20 = "     ".charCodeAt(i21);
				if(no20 == null) {
					break;
				}
				var v20;
				switch(no20) {
				case 32:
					v20 = false;
					break;
				case 42:
					v20 = true;
					break;
				case 48:
					v20 = false;
					break;
				case 49:
					v20 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i21)));
				}
				switch(i21 - (l20 - 8)) {
				case 0:
					if(v20) {
						bs20 |= 128;
					} else {
						bs20 &= -129;
					}
					break;
				case 1:
					if(v20) {
						bs20 |= 64;
					} else {
						bs20 &= -65;
					}
					break;
				case 2:
					if(v20) {
						bs20 |= 32;
					} else {
						bs20 &= -33;
					}
					break;
				case 3:
					if(v20) {
						bs20 |= 16;
					} else {
						bs20 &= -17;
					}
					break;
				case 4:
					if(v20) {
						bs20 |= 8;
					} else {
						bs20 &= -9;
					}
					break;
				case 5:
					if(v20) {
						bs20 |= 4;
					} else {
						bs20 &= -5;
					}
					break;
				case 6:
					if(v20) {
						bs20 |= 2;
					} else {
						bs20 &= -3;
					}
					break;
				case 7:
					if(v20) {
						bs20 |= 1;
					} else {
						bs20 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs20;
			break;
		case 35:
			var this22 = 0;
			var bs21 = this22;
			var l21 = " * * ".length;
			var _g122 = 0;
			var _g32 = l21;
			while(_g122 < _g32) {
				var i22 = _g122++;
				var no21 = " * * ".charCodeAt(i22);
				if(no21 == null) {
					break;
				}
				var v21;
				switch(no21) {
				case 32:
					v21 = false;
					break;
				case 42:
					v21 = true;
					break;
				case 48:
					v21 = false;
					break;
				case 49:
					v21 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i22)));
				}
				switch(i22 - (l21 - 8)) {
				case 0:
					if(v21) {
						bs21 |= 128;
					} else {
						bs21 &= -129;
					}
					break;
				case 1:
					if(v21) {
						bs21 |= 64;
					} else {
						bs21 &= -65;
					}
					break;
				case 2:
					if(v21) {
						bs21 |= 32;
					} else {
						bs21 &= -33;
					}
					break;
				case 3:
					if(v21) {
						bs21 |= 16;
					} else {
						bs21 &= -17;
					}
					break;
				case 4:
					if(v21) {
						bs21 |= 8;
					} else {
						bs21 &= -9;
					}
					break;
				case 5:
					if(v21) {
						bs21 |= 4;
					} else {
						bs21 &= -5;
					}
					break;
				case 6:
					if(v21) {
						bs21 |= 2;
					} else {
						bs21 &= -3;
					}
					break;
				case 7:
					if(v21) {
						bs21 |= 1;
					} else {
						bs21 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs21;
			var this23 = 0;
			var bs22 = this23;
			var l22 = " * * ".length;
			var _g123 = 0;
			var _g33 = l22;
			while(_g123 < _g33) {
				var i23 = _g123++;
				var no22 = " * * ".charCodeAt(i23);
				if(no22 == null) {
					break;
				}
				var v22;
				switch(no22) {
				case 32:
					v22 = false;
					break;
				case 42:
					v22 = true;
					break;
				case 48:
					v22 = false;
					break;
				case 49:
					v22 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i23)));
				}
				switch(i23 - (l22 - 8)) {
				case 0:
					if(v22) {
						bs22 |= 128;
					} else {
						bs22 &= -129;
					}
					break;
				case 1:
					if(v22) {
						bs22 |= 64;
					} else {
						bs22 &= -65;
					}
					break;
				case 2:
					if(v22) {
						bs22 |= 32;
					} else {
						bs22 &= -33;
					}
					break;
				case 3:
					if(v22) {
						bs22 |= 16;
					} else {
						bs22 &= -17;
					}
					break;
				case 4:
					if(v22) {
						bs22 |= 8;
					} else {
						bs22 &= -9;
					}
					break;
				case 5:
					if(v22) {
						bs22 |= 4;
					} else {
						bs22 &= -5;
					}
					break;
				case 6:
					if(v22) {
						bs22 |= 2;
					} else {
						bs22 &= -3;
					}
					break;
				case 7:
					if(v22) {
						bs22 |= 1;
					} else {
						bs22 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs22;
			var this24 = 0;
			var bs23 = this24;
			var l23 = "*****".length;
			var _g124 = 0;
			var _g34 = l23;
			while(_g124 < _g34) {
				var i24 = _g124++;
				var no23 = "*****".charCodeAt(i24);
				if(no23 == null) {
					break;
				}
				var v23;
				switch(no23) {
				case 32:
					v23 = false;
					break;
				case 42:
					v23 = true;
					break;
				case 48:
					v23 = false;
					break;
				case 49:
					v23 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i24)));
				}
				switch(i24 - (l23 - 8)) {
				case 0:
					if(v23) {
						bs23 |= 128;
					} else {
						bs23 &= -129;
					}
					break;
				case 1:
					if(v23) {
						bs23 |= 64;
					} else {
						bs23 &= -65;
					}
					break;
				case 2:
					if(v23) {
						bs23 |= 32;
					} else {
						bs23 &= -33;
					}
					break;
				case 3:
					if(v23) {
						bs23 |= 16;
					} else {
						bs23 &= -17;
					}
					break;
				case 4:
					if(v23) {
						bs23 |= 8;
					} else {
						bs23 &= -9;
					}
					break;
				case 5:
					if(v23) {
						bs23 |= 4;
					} else {
						bs23 &= -5;
					}
					break;
				case 6:
					if(v23) {
						bs23 |= 2;
					} else {
						bs23 &= -3;
					}
					break;
				case 7:
					if(v23) {
						bs23 |= 1;
					} else {
						bs23 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs23;
			var this25 = 0;
			var bs24 = this25;
			var l24 = " * * ".length;
			var _g125 = 0;
			var _g35 = l24;
			while(_g125 < _g35) {
				var i25 = _g125++;
				var no24 = " * * ".charCodeAt(i25);
				if(no24 == null) {
					break;
				}
				var v24;
				switch(no24) {
				case 32:
					v24 = false;
					break;
				case 42:
					v24 = true;
					break;
				case 48:
					v24 = false;
					break;
				case 49:
					v24 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i25)));
				}
				switch(i25 - (l24 - 8)) {
				case 0:
					if(v24) {
						bs24 |= 128;
					} else {
						bs24 &= -129;
					}
					break;
				case 1:
					if(v24) {
						bs24 |= 64;
					} else {
						bs24 &= -65;
					}
					break;
				case 2:
					if(v24) {
						bs24 |= 32;
					} else {
						bs24 &= -33;
					}
					break;
				case 3:
					if(v24) {
						bs24 |= 16;
					} else {
						bs24 &= -17;
					}
					break;
				case 4:
					if(v24) {
						bs24 |= 8;
					} else {
						bs24 &= -9;
					}
					break;
				case 5:
					if(v24) {
						bs24 |= 4;
					} else {
						bs24 &= -5;
					}
					break;
				case 6:
					if(v24) {
						bs24 |= 2;
					} else {
						bs24 &= -3;
					}
					break;
				case 7:
					if(v24) {
						bs24 |= 1;
					} else {
						bs24 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs24;
			var this26 = 0;
			var bs25 = this26;
			var l25 = "*****".length;
			var _g126 = 0;
			var _g36 = l25;
			while(_g126 < _g36) {
				var i26 = _g126++;
				var no25 = "*****".charCodeAt(i26);
				if(no25 == null) {
					break;
				}
				var v25;
				switch(no25) {
				case 32:
					v25 = false;
					break;
				case 42:
					v25 = true;
					break;
				case 48:
					v25 = false;
					break;
				case 49:
					v25 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i26)));
				}
				switch(i26 - (l25 - 8)) {
				case 0:
					if(v25) {
						bs25 |= 128;
					} else {
						bs25 &= -129;
					}
					break;
				case 1:
					if(v25) {
						bs25 |= 64;
					} else {
						bs25 &= -65;
					}
					break;
				case 2:
					if(v25) {
						bs25 |= 32;
					} else {
						bs25 &= -33;
					}
					break;
				case 3:
					if(v25) {
						bs25 |= 16;
					} else {
						bs25 &= -17;
					}
					break;
				case 4:
					if(v25) {
						bs25 |= 8;
					} else {
						bs25 &= -9;
					}
					break;
				case 5:
					if(v25) {
						bs25 |= 4;
					} else {
						bs25 &= -5;
					}
					break;
				case 6:
					if(v25) {
						bs25 |= 2;
					} else {
						bs25 &= -3;
					}
					break;
				case 7:
					if(v25) {
						bs25 |= 1;
					} else {
						bs25 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs25;
			var this27 = 0;
			var bs26 = this27;
			var l26 = " * * ".length;
			var _g127 = 0;
			var _g37 = l26;
			while(_g127 < _g37) {
				var i27 = _g127++;
				var no26 = " * * ".charCodeAt(i27);
				if(no26 == null) {
					break;
				}
				var v26;
				switch(no26) {
				case 32:
					v26 = false;
					break;
				case 42:
					v26 = true;
					break;
				case 48:
					v26 = false;
					break;
				case 49:
					v26 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i27)));
				}
				switch(i27 - (l26 - 8)) {
				case 0:
					if(v26) {
						bs26 |= 128;
					} else {
						bs26 &= -129;
					}
					break;
				case 1:
					if(v26) {
						bs26 |= 64;
					} else {
						bs26 &= -65;
					}
					break;
				case 2:
					if(v26) {
						bs26 |= 32;
					} else {
						bs26 &= -33;
					}
					break;
				case 3:
					if(v26) {
						bs26 |= 16;
					} else {
						bs26 &= -17;
					}
					break;
				case 4:
					if(v26) {
						bs26 |= 8;
					} else {
						bs26 &= -9;
					}
					break;
				case 5:
					if(v26) {
						bs26 |= 4;
					} else {
						bs26 &= -5;
					}
					break;
				case 6:
					if(v26) {
						bs26 |= 2;
					} else {
						bs26 &= -3;
					}
					break;
				case 7:
					if(v26) {
						bs26 |= 1;
					} else {
						bs26 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs26;
			var this28 = 0;
			var bs27 = this28;
			var l27 = " * * ".length;
			var _g128 = 0;
			var _g38 = l27;
			while(_g128 < _g38) {
				var i28 = _g128++;
				var no27 = " * * ".charCodeAt(i28);
				if(no27 == null) {
					break;
				}
				var v27;
				switch(no27) {
				case 32:
					v27 = false;
					break;
				case 42:
					v27 = true;
					break;
				case 48:
					v27 = false;
					break;
				case 49:
					v27 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i28)));
				}
				switch(i28 - (l27 - 8)) {
				case 0:
					if(v27) {
						bs27 |= 128;
					} else {
						bs27 &= -129;
					}
					break;
				case 1:
					if(v27) {
						bs27 |= 64;
					} else {
						bs27 &= -65;
					}
					break;
				case 2:
					if(v27) {
						bs27 |= 32;
					} else {
						bs27 &= -33;
					}
					break;
				case 3:
					if(v27) {
						bs27 |= 16;
					} else {
						bs27 &= -17;
					}
					break;
				case 4:
					if(v27) {
						bs27 |= 8;
					} else {
						bs27 &= -9;
					}
					break;
				case 5:
					if(v27) {
						bs27 |= 4;
					} else {
						bs27 &= -5;
					}
					break;
				case 6:
					if(v27) {
						bs27 |= 2;
					} else {
						bs27 &= -3;
					}
					break;
				case 7:
					if(v27) {
						bs27 |= 1;
					} else {
						bs27 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs27;
			break;
		case 36:
			var this29 = 0;
			var bs28 = this29;
			var l28 = "  *  ".length;
			var _g129 = 0;
			var _g39 = l28;
			while(_g129 < _g39) {
				var i29 = _g129++;
				var no28 = "  *  ".charCodeAt(i29);
				if(no28 == null) {
					break;
				}
				var v28;
				switch(no28) {
				case 32:
					v28 = false;
					break;
				case 42:
					v28 = true;
					break;
				case 48:
					v28 = false;
					break;
				case 49:
					v28 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i29)));
				}
				switch(i29 - (l28 - 8)) {
				case 0:
					if(v28) {
						bs28 |= 128;
					} else {
						bs28 &= -129;
					}
					break;
				case 1:
					if(v28) {
						bs28 |= 64;
					} else {
						bs28 &= -65;
					}
					break;
				case 2:
					if(v28) {
						bs28 |= 32;
					} else {
						bs28 &= -33;
					}
					break;
				case 3:
					if(v28) {
						bs28 |= 16;
					} else {
						bs28 &= -17;
					}
					break;
				case 4:
					if(v28) {
						bs28 |= 8;
					} else {
						bs28 &= -9;
					}
					break;
				case 5:
					if(v28) {
						bs28 |= 4;
					} else {
						bs28 &= -5;
					}
					break;
				case 6:
					if(v28) {
						bs28 |= 2;
					} else {
						bs28 &= -3;
					}
					break;
				case 7:
					if(v28) {
						bs28 |= 1;
					} else {
						bs28 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs28;
			var this30 = 0;
			var bs29 = this30;
			var l29 = " ****".length;
			var _g130 = 0;
			var _g40 = l29;
			while(_g130 < _g40) {
				var i30 = _g130++;
				var no29 = " ****".charCodeAt(i30);
				if(no29 == null) {
					break;
				}
				var v29;
				switch(no29) {
				case 32:
					v29 = false;
					break;
				case 42:
					v29 = true;
					break;
				case 48:
					v29 = false;
					break;
				case 49:
					v29 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i30)));
				}
				switch(i30 - (l29 - 8)) {
				case 0:
					if(v29) {
						bs29 |= 128;
					} else {
						bs29 &= -129;
					}
					break;
				case 1:
					if(v29) {
						bs29 |= 64;
					} else {
						bs29 &= -65;
					}
					break;
				case 2:
					if(v29) {
						bs29 |= 32;
					} else {
						bs29 &= -33;
					}
					break;
				case 3:
					if(v29) {
						bs29 |= 16;
					} else {
						bs29 &= -17;
					}
					break;
				case 4:
					if(v29) {
						bs29 |= 8;
					} else {
						bs29 &= -9;
					}
					break;
				case 5:
					if(v29) {
						bs29 |= 4;
					} else {
						bs29 &= -5;
					}
					break;
				case 6:
					if(v29) {
						bs29 |= 2;
					} else {
						bs29 &= -3;
					}
					break;
				case 7:
					if(v29) {
						bs29 |= 1;
					} else {
						bs29 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs29;
			var this31 = 0;
			var bs30 = this31;
			var l30 = "* *  ".length;
			var _g131 = 0;
			var _g41 = l30;
			while(_g131 < _g41) {
				var i31 = _g131++;
				var no30 = "* *  ".charCodeAt(i31);
				if(no30 == null) {
					break;
				}
				var v30;
				switch(no30) {
				case 32:
					v30 = false;
					break;
				case 42:
					v30 = true;
					break;
				case 48:
					v30 = false;
					break;
				case 49:
					v30 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i31)));
				}
				switch(i31 - (l30 - 8)) {
				case 0:
					if(v30) {
						bs30 |= 128;
					} else {
						bs30 &= -129;
					}
					break;
				case 1:
					if(v30) {
						bs30 |= 64;
					} else {
						bs30 &= -65;
					}
					break;
				case 2:
					if(v30) {
						bs30 |= 32;
					} else {
						bs30 &= -33;
					}
					break;
				case 3:
					if(v30) {
						bs30 |= 16;
					} else {
						bs30 &= -17;
					}
					break;
				case 4:
					if(v30) {
						bs30 |= 8;
					} else {
						bs30 &= -9;
					}
					break;
				case 5:
					if(v30) {
						bs30 |= 4;
					} else {
						bs30 &= -5;
					}
					break;
				case 6:
					if(v30) {
						bs30 |= 2;
					} else {
						bs30 &= -3;
					}
					break;
				case 7:
					if(v30) {
						bs30 |= 1;
					} else {
						bs30 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs30;
			var this32 = 0;
			var bs31 = this32;
			var l31 = " *** ".length;
			var _g132 = 0;
			var _g42 = l31;
			while(_g132 < _g42) {
				var i32 = _g132++;
				var no31 = " *** ".charCodeAt(i32);
				if(no31 == null) {
					break;
				}
				var v31;
				switch(no31) {
				case 32:
					v31 = false;
					break;
				case 42:
					v31 = true;
					break;
				case 48:
					v31 = false;
					break;
				case 49:
					v31 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i32)));
				}
				switch(i32 - (l31 - 8)) {
				case 0:
					if(v31) {
						bs31 |= 128;
					} else {
						bs31 &= -129;
					}
					break;
				case 1:
					if(v31) {
						bs31 |= 64;
					} else {
						bs31 &= -65;
					}
					break;
				case 2:
					if(v31) {
						bs31 |= 32;
					} else {
						bs31 &= -33;
					}
					break;
				case 3:
					if(v31) {
						bs31 |= 16;
					} else {
						bs31 &= -17;
					}
					break;
				case 4:
					if(v31) {
						bs31 |= 8;
					} else {
						bs31 &= -9;
					}
					break;
				case 5:
					if(v31) {
						bs31 |= 4;
					} else {
						bs31 &= -5;
					}
					break;
				case 6:
					if(v31) {
						bs31 |= 2;
					} else {
						bs31 &= -3;
					}
					break;
				case 7:
					if(v31) {
						bs31 |= 1;
					} else {
						bs31 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs31;
			var this33 = 0;
			var bs32 = this33;
			var l32 = "  * *".length;
			var _g133 = 0;
			var _g43 = l32;
			while(_g133 < _g43) {
				var i33 = _g133++;
				var no32 = "  * *".charCodeAt(i33);
				if(no32 == null) {
					break;
				}
				var v32;
				switch(no32) {
				case 32:
					v32 = false;
					break;
				case 42:
					v32 = true;
					break;
				case 48:
					v32 = false;
					break;
				case 49:
					v32 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  * *".charCodeAt(i33)));
				}
				switch(i33 - (l32 - 8)) {
				case 0:
					if(v32) {
						bs32 |= 128;
					} else {
						bs32 &= -129;
					}
					break;
				case 1:
					if(v32) {
						bs32 |= 64;
					} else {
						bs32 &= -65;
					}
					break;
				case 2:
					if(v32) {
						bs32 |= 32;
					} else {
						bs32 &= -33;
					}
					break;
				case 3:
					if(v32) {
						bs32 |= 16;
					} else {
						bs32 &= -17;
					}
					break;
				case 4:
					if(v32) {
						bs32 |= 8;
					} else {
						bs32 &= -9;
					}
					break;
				case 5:
					if(v32) {
						bs32 |= 4;
					} else {
						bs32 &= -5;
					}
					break;
				case 6:
					if(v32) {
						bs32 |= 2;
					} else {
						bs32 &= -3;
					}
					break;
				case 7:
					if(v32) {
						bs32 |= 1;
					} else {
						bs32 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs32;
			var this34 = 0;
			var bs33 = this34;
			var l33 = "**** ".length;
			var _g134 = 0;
			var _g44 = l33;
			while(_g134 < _g44) {
				var i34 = _g134++;
				var no33 = "**** ".charCodeAt(i34);
				if(no33 == null) {
					break;
				}
				var v33;
				switch(no33) {
				case 32:
					v33 = false;
					break;
				case 42:
					v33 = true;
					break;
				case 48:
					v33 = false;
					break;
				case 49:
					v33 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i34)));
				}
				switch(i34 - (l33 - 8)) {
				case 0:
					if(v33) {
						bs33 |= 128;
					} else {
						bs33 &= -129;
					}
					break;
				case 1:
					if(v33) {
						bs33 |= 64;
					} else {
						bs33 &= -65;
					}
					break;
				case 2:
					if(v33) {
						bs33 |= 32;
					} else {
						bs33 &= -33;
					}
					break;
				case 3:
					if(v33) {
						bs33 |= 16;
					} else {
						bs33 &= -17;
					}
					break;
				case 4:
					if(v33) {
						bs33 |= 8;
					} else {
						bs33 &= -9;
					}
					break;
				case 5:
					if(v33) {
						bs33 |= 4;
					} else {
						bs33 &= -5;
					}
					break;
				case 6:
					if(v33) {
						bs33 |= 2;
					} else {
						bs33 &= -3;
					}
					break;
				case 7:
					if(v33) {
						bs33 |= 1;
					} else {
						bs33 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs33;
			var this35 = 0;
			var bs34 = this35;
			var l34 = "  *  ".length;
			var _g135 = 0;
			var _g45 = l34;
			while(_g135 < _g45) {
				var i35 = _g135++;
				var no34 = "  *  ".charCodeAt(i35);
				if(no34 == null) {
					break;
				}
				var v34;
				switch(no34) {
				case 32:
					v34 = false;
					break;
				case 42:
					v34 = true;
					break;
				case 48:
					v34 = false;
					break;
				case 49:
					v34 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i35)));
				}
				switch(i35 - (l34 - 8)) {
				case 0:
					if(v34) {
						bs34 |= 128;
					} else {
						bs34 &= -129;
					}
					break;
				case 1:
					if(v34) {
						bs34 |= 64;
					} else {
						bs34 &= -65;
					}
					break;
				case 2:
					if(v34) {
						bs34 |= 32;
					} else {
						bs34 &= -33;
					}
					break;
				case 3:
					if(v34) {
						bs34 |= 16;
					} else {
						bs34 &= -17;
					}
					break;
				case 4:
					if(v34) {
						bs34 |= 8;
					} else {
						bs34 &= -9;
					}
					break;
				case 5:
					if(v34) {
						bs34 |= 4;
					} else {
						bs34 &= -5;
					}
					break;
				case 6:
					if(v34) {
						bs34 |= 2;
					} else {
						bs34 &= -3;
					}
					break;
				case 7:
					if(v34) {
						bs34 |= 1;
					} else {
						bs34 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs34;
			break;
		case 37:
			var this36 = 0;
			var bs35 = this36;
			var l35 = "**   ".length;
			var _g136 = 0;
			var _g46 = l35;
			while(_g136 < _g46) {
				var i36 = _g136++;
				var no35 = "**   ".charCodeAt(i36);
				if(no35 == null) {
					break;
				}
				var v35;
				switch(no35) {
				case 32:
					v35 = false;
					break;
				case 42:
					v35 = true;
					break;
				case 48:
					v35 = false;
					break;
				case 49:
					v35 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**   ".charCodeAt(i36)));
				}
				switch(i36 - (l35 - 8)) {
				case 0:
					if(v35) {
						bs35 |= 128;
					} else {
						bs35 &= -129;
					}
					break;
				case 1:
					if(v35) {
						bs35 |= 64;
					} else {
						bs35 &= -65;
					}
					break;
				case 2:
					if(v35) {
						bs35 |= 32;
					} else {
						bs35 &= -33;
					}
					break;
				case 3:
					if(v35) {
						bs35 |= 16;
					} else {
						bs35 &= -17;
					}
					break;
				case 4:
					if(v35) {
						bs35 |= 8;
					} else {
						bs35 &= -9;
					}
					break;
				case 5:
					if(v35) {
						bs35 |= 4;
					} else {
						bs35 &= -5;
					}
					break;
				case 6:
					if(v35) {
						bs35 |= 2;
					} else {
						bs35 &= -3;
					}
					break;
				case 7:
					if(v35) {
						bs35 |= 1;
					} else {
						bs35 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs35;
			var this37 = 0;
			var bs36 = this37;
			var l36 = "**  *".length;
			var _g137 = 0;
			var _g47 = l36;
			while(_g137 < _g47) {
				var i37 = _g137++;
				var no36 = "**  *".charCodeAt(i37);
				if(no36 == null) {
					break;
				}
				var v36;
				switch(no36) {
				case 32:
					v36 = false;
					break;
				case 42:
					v36 = true;
					break;
				case 48:
					v36 = false;
					break;
				case 49:
					v36 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i37)));
				}
				switch(i37 - (l36 - 8)) {
				case 0:
					if(v36) {
						bs36 |= 128;
					} else {
						bs36 &= -129;
					}
					break;
				case 1:
					if(v36) {
						bs36 |= 64;
					} else {
						bs36 &= -65;
					}
					break;
				case 2:
					if(v36) {
						bs36 |= 32;
					} else {
						bs36 &= -33;
					}
					break;
				case 3:
					if(v36) {
						bs36 |= 16;
					} else {
						bs36 &= -17;
					}
					break;
				case 4:
					if(v36) {
						bs36 |= 8;
					} else {
						bs36 &= -9;
					}
					break;
				case 5:
					if(v36) {
						bs36 |= 4;
					} else {
						bs36 &= -5;
					}
					break;
				case 6:
					if(v36) {
						bs36 |= 2;
					} else {
						bs36 &= -3;
					}
					break;
				case 7:
					if(v36) {
						bs36 |= 1;
					} else {
						bs36 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs36;
			var this38 = 0;
			var bs37 = this38;
			var l37 = "   * ".length;
			var _g138 = 0;
			var _g48 = l37;
			while(_g138 < _g48) {
				var i38 = _g138++;
				var no37 = "   * ".charCodeAt(i38);
				if(no37 == null) {
					break;
				}
				var v37;
				switch(no37) {
				case 32:
					v37 = false;
					break;
				case 42:
					v37 = true;
					break;
				case 48:
					v37 = false;
					break;
				case 49:
					v37 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i38)));
				}
				switch(i38 - (l37 - 8)) {
				case 0:
					if(v37) {
						bs37 |= 128;
					} else {
						bs37 &= -129;
					}
					break;
				case 1:
					if(v37) {
						bs37 |= 64;
					} else {
						bs37 &= -65;
					}
					break;
				case 2:
					if(v37) {
						bs37 |= 32;
					} else {
						bs37 &= -33;
					}
					break;
				case 3:
					if(v37) {
						bs37 |= 16;
					} else {
						bs37 &= -17;
					}
					break;
				case 4:
					if(v37) {
						bs37 |= 8;
					} else {
						bs37 &= -9;
					}
					break;
				case 5:
					if(v37) {
						bs37 |= 4;
					} else {
						bs37 &= -5;
					}
					break;
				case 6:
					if(v37) {
						bs37 |= 2;
					} else {
						bs37 &= -3;
					}
					break;
				case 7:
					if(v37) {
						bs37 |= 1;
					} else {
						bs37 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs37;
			var this39 = 0;
			var bs38 = this39;
			var l38 = "  *  ".length;
			var _g139 = 0;
			var _g49 = l38;
			while(_g139 < _g49) {
				var i39 = _g139++;
				var no38 = "  *  ".charCodeAt(i39);
				if(no38 == null) {
					break;
				}
				var v38;
				switch(no38) {
				case 32:
					v38 = false;
					break;
				case 42:
					v38 = true;
					break;
				case 48:
					v38 = false;
					break;
				case 49:
					v38 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i39)));
				}
				switch(i39 - (l38 - 8)) {
				case 0:
					if(v38) {
						bs38 |= 128;
					} else {
						bs38 &= -129;
					}
					break;
				case 1:
					if(v38) {
						bs38 |= 64;
					} else {
						bs38 &= -65;
					}
					break;
				case 2:
					if(v38) {
						bs38 |= 32;
					} else {
						bs38 &= -33;
					}
					break;
				case 3:
					if(v38) {
						bs38 |= 16;
					} else {
						bs38 &= -17;
					}
					break;
				case 4:
					if(v38) {
						bs38 |= 8;
					} else {
						bs38 &= -9;
					}
					break;
				case 5:
					if(v38) {
						bs38 |= 4;
					} else {
						bs38 &= -5;
					}
					break;
				case 6:
					if(v38) {
						bs38 |= 2;
					} else {
						bs38 &= -3;
					}
					break;
				case 7:
					if(v38) {
						bs38 |= 1;
					} else {
						bs38 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs38;
			var this40 = 0;
			var bs39 = this40;
			var l39 = " *   ".length;
			var _g140 = 0;
			var _g50 = l39;
			while(_g140 < _g50) {
				var i40 = _g140++;
				var no39 = " *   ".charCodeAt(i40);
				if(no39 == null) {
					break;
				}
				var v39;
				switch(no39) {
				case 32:
					v39 = false;
					break;
				case 42:
					v39 = true;
					break;
				case 48:
					v39 = false;
					break;
				case 49:
					v39 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i40)));
				}
				switch(i40 - (l39 - 8)) {
				case 0:
					if(v39) {
						bs39 |= 128;
					} else {
						bs39 &= -129;
					}
					break;
				case 1:
					if(v39) {
						bs39 |= 64;
					} else {
						bs39 &= -65;
					}
					break;
				case 2:
					if(v39) {
						bs39 |= 32;
					} else {
						bs39 &= -33;
					}
					break;
				case 3:
					if(v39) {
						bs39 |= 16;
					} else {
						bs39 &= -17;
					}
					break;
				case 4:
					if(v39) {
						bs39 |= 8;
					} else {
						bs39 &= -9;
					}
					break;
				case 5:
					if(v39) {
						bs39 |= 4;
					} else {
						bs39 &= -5;
					}
					break;
				case 6:
					if(v39) {
						bs39 |= 2;
					} else {
						bs39 &= -3;
					}
					break;
				case 7:
					if(v39) {
						bs39 |= 1;
					} else {
						bs39 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs39;
			var this41 = 0;
			var bs40 = this41;
			var l40 = "*  **".length;
			var _g141 = 0;
			var _g51 = l40;
			while(_g141 < _g51) {
				var i41 = _g141++;
				var no40 = "*  **".charCodeAt(i41);
				if(no40 == null) {
					break;
				}
				var v40;
				switch(no40) {
				case 32:
					v40 = false;
					break;
				case 42:
					v40 = true;
					break;
				case 48:
					v40 = false;
					break;
				case 49:
					v40 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  **".charCodeAt(i41)));
				}
				switch(i41 - (l40 - 8)) {
				case 0:
					if(v40) {
						bs40 |= 128;
					} else {
						bs40 &= -129;
					}
					break;
				case 1:
					if(v40) {
						bs40 |= 64;
					} else {
						bs40 &= -65;
					}
					break;
				case 2:
					if(v40) {
						bs40 |= 32;
					} else {
						bs40 &= -33;
					}
					break;
				case 3:
					if(v40) {
						bs40 |= 16;
					} else {
						bs40 &= -17;
					}
					break;
				case 4:
					if(v40) {
						bs40 |= 8;
					} else {
						bs40 &= -9;
					}
					break;
				case 5:
					if(v40) {
						bs40 |= 4;
					} else {
						bs40 &= -5;
					}
					break;
				case 6:
					if(v40) {
						bs40 |= 2;
					} else {
						bs40 &= -3;
					}
					break;
				case 7:
					if(v40) {
						bs40 |= 1;
					} else {
						bs40 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs40;
			var this42 = 0;
			var bs41 = this42;
			var l41 = "   **".length;
			var _g142 = 0;
			var _g52 = l41;
			while(_g142 < _g52) {
				var i42 = _g142++;
				var no41 = "   **".charCodeAt(i42);
				if(no41 == null) {
					break;
				}
				var v41;
				switch(no41) {
				case 32:
					v41 = false;
					break;
				case 42:
					v41 = true;
					break;
				case 48:
					v41 = false;
					break;
				case 49:
					v41 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   **".charCodeAt(i42)));
				}
				switch(i42 - (l41 - 8)) {
				case 0:
					if(v41) {
						bs41 |= 128;
					} else {
						bs41 &= -129;
					}
					break;
				case 1:
					if(v41) {
						bs41 |= 64;
					} else {
						bs41 &= -65;
					}
					break;
				case 2:
					if(v41) {
						bs41 |= 32;
					} else {
						bs41 &= -33;
					}
					break;
				case 3:
					if(v41) {
						bs41 |= 16;
					} else {
						bs41 &= -17;
					}
					break;
				case 4:
					if(v41) {
						bs41 |= 8;
					} else {
						bs41 &= -9;
					}
					break;
				case 5:
					if(v41) {
						bs41 |= 4;
					} else {
						bs41 &= -5;
					}
					break;
				case 6:
					if(v41) {
						bs41 |= 2;
					} else {
						bs41 &= -3;
					}
					break;
				case 7:
					if(v41) {
						bs41 |= 1;
					} else {
						bs41 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs41;
			break;
		case 38:
			var this43 = 0;
			var bs42 = this43;
			var l42 = " **  ".length;
			var _g143 = 0;
			var _g53 = l42;
			while(_g143 < _g53) {
				var i43 = _g143++;
				var no42 = " **  ".charCodeAt(i43);
				if(no42 == null) {
					break;
				}
				var v42;
				switch(no42) {
				case 32:
					v42 = false;
					break;
				case 42:
					v42 = true;
					break;
				case 48:
					v42 = false;
					break;
				case 49:
					v42 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i43)));
				}
				switch(i43 - (l42 - 8)) {
				case 0:
					if(v42) {
						bs42 |= 128;
					} else {
						bs42 &= -129;
					}
					break;
				case 1:
					if(v42) {
						bs42 |= 64;
					} else {
						bs42 &= -65;
					}
					break;
				case 2:
					if(v42) {
						bs42 |= 32;
					} else {
						bs42 &= -33;
					}
					break;
				case 3:
					if(v42) {
						bs42 |= 16;
					} else {
						bs42 &= -17;
					}
					break;
				case 4:
					if(v42) {
						bs42 |= 8;
					} else {
						bs42 &= -9;
					}
					break;
				case 5:
					if(v42) {
						bs42 |= 4;
					} else {
						bs42 &= -5;
					}
					break;
				case 6:
					if(v42) {
						bs42 |= 2;
					} else {
						bs42 &= -3;
					}
					break;
				case 7:
					if(v42) {
						bs42 |= 1;
					} else {
						bs42 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs42;
			var this44 = 0;
			var bs43 = this44;
			var l43 = "*  * ".length;
			var _g144 = 0;
			var _g54 = l43;
			while(_g144 < _g54) {
				var i44 = _g144++;
				var no43 = "*  * ".charCodeAt(i44);
				if(no43 == null) {
					break;
				}
				var v43;
				switch(no43) {
				case 32:
					v43 = false;
					break;
				case 42:
					v43 = true;
					break;
				case 48:
					v43 = false;
					break;
				case 49:
					v43 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i44)));
				}
				switch(i44 - (l43 - 8)) {
				case 0:
					if(v43) {
						bs43 |= 128;
					} else {
						bs43 &= -129;
					}
					break;
				case 1:
					if(v43) {
						bs43 |= 64;
					} else {
						bs43 &= -65;
					}
					break;
				case 2:
					if(v43) {
						bs43 |= 32;
					} else {
						bs43 &= -33;
					}
					break;
				case 3:
					if(v43) {
						bs43 |= 16;
					} else {
						bs43 &= -17;
					}
					break;
				case 4:
					if(v43) {
						bs43 |= 8;
					} else {
						bs43 &= -9;
					}
					break;
				case 5:
					if(v43) {
						bs43 |= 4;
					} else {
						bs43 &= -5;
					}
					break;
				case 6:
					if(v43) {
						bs43 |= 2;
					} else {
						bs43 &= -3;
					}
					break;
				case 7:
					if(v43) {
						bs43 |= 1;
					} else {
						bs43 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs43;
			var this45 = 0;
			var bs44 = this45;
			var l44 = "* *  ".length;
			var _g145 = 0;
			var _g55 = l44;
			while(_g145 < _g55) {
				var i45 = _g145++;
				var no44 = "* *  ".charCodeAt(i45);
				if(no44 == null) {
					break;
				}
				var v44;
				switch(no44) {
				case 32:
					v44 = false;
					break;
				case 42:
					v44 = true;
					break;
				case 48:
					v44 = false;
					break;
				case 49:
					v44 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i45)));
				}
				switch(i45 - (l44 - 8)) {
				case 0:
					if(v44) {
						bs44 |= 128;
					} else {
						bs44 &= -129;
					}
					break;
				case 1:
					if(v44) {
						bs44 |= 64;
					} else {
						bs44 &= -65;
					}
					break;
				case 2:
					if(v44) {
						bs44 |= 32;
					} else {
						bs44 &= -33;
					}
					break;
				case 3:
					if(v44) {
						bs44 |= 16;
					} else {
						bs44 &= -17;
					}
					break;
				case 4:
					if(v44) {
						bs44 |= 8;
					} else {
						bs44 &= -9;
					}
					break;
				case 5:
					if(v44) {
						bs44 |= 4;
					} else {
						bs44 &= -5;
					}
					break;
				case 6:
					if(v44) {
						bs44 |= 2;
					} else {
						bs44 &= -3;
					}
					break;
				case 7:
					if(v44) {
						bs44 |= 1;
					} else {
						bs44 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs44;
			var this46 = 0;
			var bs45 = this46;
			var l45 = " *   ".length;
			var _g146 = 0;
			var _g56 = l45;
			while(_g146 < _g56) {
				var i46 = _g146++;
				var no45 = " *   ".charCodeAt(i46);
				if(no45 == null) {
					break;
				}
				var v45;
				switch(no45) {
				case 32:
					v45 = false;
					break;
				case 42:
					v45 = true;
					break;
				case 48:
					v45 = false;
					break;
				case 49:
					v45 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i46)));
				}
				switch(i46 - (l45 - 8)) {
				case 0:
					if(v45) {
						bs45 |= 128;
					} else {
						bs45 &= -129;
					}
					break;
				case 1:
					if(v45) {
						bs45 |= 64;
					} else {
						bs45 &= -65;
					}
					break;
				case 2:
					if(v45) {
						bs45 |= 32;
					} else {
						bs45 &= -33;
					}
					break;
				case 3:
					if(v45) {
						bs45 |= 16;
					} else {
						bs45 &= -17;
					}
					break;
				case 4:
					if(v45) {
						bs45 |= 8;
					} else {
						bs45 &= -9;
					}
					break;
				case 5:
					if(v45) {
						bs45 |= 4;
					} else {
						bs45 &= -5;
					}
					break;
				case 6:
					if(v45) {
						bs45 |= 2;
					} else {
						bs45 &= -3;
					}
					break;
				case 7:
					if(v45) {
						bs45 |= 1;
					} else {
						bs45 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs45;
			var this47 = 0;
			var bs46 = this47;
			var l46 = "* * *".length;
			var _g147 = 0;
			var _g57 = l46;
			while(_g147 < _g57) {
				var i47 = _g147++;
				var no46 = "* * *".charCodeAt(i47);
				if(no46 == null) {
					break;
				}
				var v46;
				switch(no46) {
				case 32:
					v46 = false;
					break;
				case 42:
					v46 = true;
					break;
				case 48:
					v46 = false;
					break;
				case 49:
					v46 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i47)));
				}
				switch(i47 - (l46 - 8)) {
				case 0:
					if(v46) {
						bs46 |= 128;
					} else {
						bs46 &= -129;
					}
					break;
				case 1:
					if(v46) {
						bs46 |= 64;
					} else {
						bs46 &= -65;
					}
					break;
				case 2:
					if(v46) {
						bs46 |= 32;
					} else {
						bs46 &= -33;
					}
					break;
				case 3:
					if(v46) {
						bs46 |= 16;
					} else {
						bs46 &= -17;
					}
					break;
				case 4:
					if(v46) {
						bs46 |= 8;
					} else {
						bs46 &= -9;
					}
					break;
				case 5:
					if(v46) {
						bs46 |= 4;
					} else {
						bs46 &= -5;
					}
					break;
				case 6:
					if(v46) {
						bs46 |= 2;
					} else {
						bs46 &= -3;
					}
					break;
				case 7:
					if(v46) {
						bs46 |= 1;
					} else {
						bs46 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs46;
			var this48 = 0;
			var bs47 = this48;
			var l47 = "*  * ".length;
			var _g148 = 0;
			var _g58 = l47;
			while(_g148 < _g58) {
				var i48 = _g148++;
				var no47 = "*  * ".charCodeAt(i48);
				if(no47 == null) {
					break;
				}
				var v47;
				switch(no47) {
				case 32:
					v47 = false;
					break;
				case 42:
					v47 = true;
					break;
				case 48:
					v47 = false;
					break;
				case 49:
					v47 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i48)));
				}
				switch(i48 - (l47 - 8)) {
				case 0:
					if(v47) {
						bs47 |= 128;
					} else {
						bs47 &= -129;
					}
					break;
				case 1:
					if(v47) {
						bs47 |= 64;
					} else {
						bs47 &= -65;
					}
					break;
				case 2:
					if(v47) {
						bs47 |= 32;
					} else {
						bs47 &= -33;
					}
					break;
				case 3:
					if(v47) {
						bs47 |= 16;
					} else {
						bs47 &= -17;
					}
					break;
				case 4:
					if(v47) {
						bs47 |= 8;
					} else {
						bs47 &= -9;
					}
					break;
				case 5:
					if(v47) {
						bs47 |= 4;
					} else {
						bs47 &= -5;
					}
					break;
				case 6:
					if(v47) {
						bs47 |= 2;
					} else {
						bs47 &= -3;
					}
					break;
				case 7:
					if(v47) {
						bs47 |= 1;
					} else {
						bs47 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs47;
			var this49 = 0;
			var bs48 = this49;
			var l48 = " ** *".length;
			var _g149 = 0;
			var _g59 = l48;
			while(_g149 < _g59) {
				var i49 = _g149++;
				var no48 = " ** *".charCodeAt(i49);
				if(no48 == null) {
					break;
				}
				var v48;
				switch(no48) {
				case 32:
					v48 = false;
					break;
				case 42:
					v48 = true;
					break;
				case 48:
					v48 = false;
					break;
				case 49:
					v48 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i49)));
				}
				switch(i49 - (l48 - 8)) {
				case 0:
					if(v48) {
						bs48 |= 128;
					} else {
						bs48 &= -129;
					}
					break;
				case 1:
					if(v48) {
						bs48 |= 64;
					} else {
						bs48 &= -65;
					}
					break;
				case 2:
					if(v48) {
						bs48 |= 32;
					} else {
						bs48 &= -33;
					}
					break;
				case 3:
					if(v48) {
						bs48 |= 16;
					} else {
						bs48 &= -17;
					}
					break;
				case 4:
					if(v48) {
						bs48 |= 8;
					} else {
						bs48 &= -9;
					}
					break;
				case 5:
					if(v48) {
						bs48 |= 4;
					} else {
						bs48 &= -5;
					}
					break;
				case 6:
					if(v48) {
						bs48 |= 2;
					} else {
						bs48 &= -3;
					}
					break;
				case 7:
					if(v48) {
						bs48 |= 1;
					} else {
						bs48 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs48;
			break;
		case 39:
			var this50 = 0;
			var bs49 = this50;
			var l49 = "  ** ".length;
			var _g150 = 0;
			var _g60 = l49;
			while(_g150 < _g60) {
				var i50 = _g150++;
				var no49 = "  ** ".charCodeAt(i50);
				if(no49 == null) {
					break;
				}
				var v49;
				switch(no49) {
				case 32:
					v49 = false;
					break;
				case 42:
					v49 = true;
					break;
				case 48:
					v49 = false;
					break;
				case 49:
					v49 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i50)));
				}
				switch(i50 - (l49 - 8)) {
				case 0:
					if(v49) {
						bs49 |= 128;
					} else {
						bs49 &= -129;
					}
					break;
				case 1:
					if(v49) {
						bs49 |= 64;
					} else {
						bs49 &= -65;
					}
					break;
				case 2:
					if(v49) {
						bs49 |= 32;
					} else {
						bs49 &= -33;
					}
					break;
				case 3:
					if(v49) {
						bs49 |= 16;
					} else {
						bs49 &= -17;
					}
					break;
				case 4:
					if(v49) {
						bs49 |= 8;
					} else {
						bs49 &= -9;
					}
					break;
				case 5:
					if(v49) {
						bs49 |= 4;
					} else {
						bs49 &= -5;
					}
					break;
				case 6:
					if(v49) {
						bs49 |= 2;
					} else {
						bs49 &= -3;
					}
					break;
				case 7:
					if(v49) {
						bs49 |= 1;
					} else {
						bs49 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs49;
			var this51 = 0;
			var bs50 = this51;
			var l50 = "   * ".length;
			var _g151 = 0;
			var _g61 = l50;
			while(_g151 < _g61) {
				var i51 = _g151++;
				var no50 = "   * ".charCodeAt(i51);
				if(no50 == null) {
					break;
				}
				var v50;
				switch(no50) {
				case 32:
					v50 = false;
					break;
				case 42:
					v50 = true;
					break;
				case 48:
					v50 = false;
					break;
				case 49:
					v50 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i51)));
				}
				switch(i51 - (l50 - 8)) {
				case 0:
					if(v50) {
						bs50 |= 128;
					} else {
						bs50 &= -129;
					}
					break;
				case 1:
					if(v50) {
						bs50 |= 64;
					} else {
						bs50 &= -65;
					}
					break;
				case 2:
					if(v50) {
						bs50 |= 32;
					} else {
						bs50 &= -33;
					}
					break;
				case 3:
					if(v50) {
						bs50 |= 16;
					} else {
						bs50 &= -17;
					}
					break;
				case 4:
					if(v50) {
						bs50 |= 8;
					} else {
						bs50 &= -9;
					}
					break;
				case 5:
					if(v50) {
						bs50 |= 4;
					} else {
						bs50 &= -5;
					}
					break;
				case 6:
					if(v50) {
						bs50 |= 2;
					} else {
						bs50 &= -3;
					}
					break;
				case 7:
					if(v50) {
						bs50 |= 1;
					} else {
						bs50 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs50;
			var this52 = 0;
			var bs51 = this52;
			var l51 = "  *  ".length;
			var _g152 = 0;
			var _g62 = l51;
			while(_g152 < _g62) {
				var i52 = _g152++;
				var no51 = "  *  ".charCodeAt(i52);
				if(no51 == null) {
					break;
				}
				var v51;
				switch(no51) {
				case 32:
					v51 = false;
					break;
				case 42:
					v51 = true;
					break;
				case 48:
					v51 = false;
					break;
				case 49:
					v51 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i52)));
				}
				switch(i52 - (l51 - 8)) {
				case 0:
					if(v51) {
						bs51 |= 128;
					} else {
						bs51 &= -129;
					}
					break;
				case 1:
					if(v51) {
						bs51 |= 64;
					} else {
						bs51 &= -65;
					}
					break;
				case 2:
					if(v51) {
						bs51 |= 32;
					} else {
						bs51 &= -33;
					}
					break;
				case 3:
					if(v51) {
						bs51 |= 16;
					} else {
						bs51 &= -17;
					}
					break;
				case 4:
					if(v51) {
						bs51 |= 8;
					} else {
						bs51 &= -9;
					}
					break;
				case 5:
					if(v51) {
						bs51 |= 4;
					} else {
						bs51 &= -5;
					}
					break;
				case 6:
					if(v51) {
						bs51 |= 2;
					} else {
						bs51 &= -3;
					}
					break;
				case 7:
					if(v51) {
						bs51 |= 1;
					} else {
						bs51 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs51;
			var this53 = 0;
			var bs52 = this53;
			var l52 = "     ".length;
			var _g153 = 0;
			var _g63 = l52;
			while(_g153 < _g63) {
				var i53 = _g153++;
				var no52 = "     ".charCodeAt(i53);
				if(no52 == null) {
					break;
				}
				var v52;
				switch(no52) {
				case 32:
					v52 = false;
					break;
				case 42:
					v52 = true;
					break;
				case 48:
					v52 = false;
					break;
				case 49:
					v52 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i53)));
				}
				switch(i53 - (l52 - 8)) {
				case 0:
					if(v52) {
						bs52 |= 128;
					} else {
						bs52 &= -129;
					}
					break;
				case 1:
					if(v52) {
						bs52 |= 64;
					} else {
						bs52 &= -65;
					}
					break;
				case 2:
					if(v52) {
						bs52 |= 32;
					} else {
						bs52 &= -33;
					}
					break;
				case 3:
					if(v52) {
						bs52 |= 16;
					} else {
						bs52 &= -17;
					}
					break;
				case 4:
					if(v52) {
						bs52 |= 8;
					} else {
						bs52 &= -9;
					}
					break;
				case 5:
					if(v52) {
						bs52 |= 4;
					} else {
						bs52 &= -5;
					}
					break;
				case 6:
					if(v52) {
						bs52 |= 2;
					} else {
						bs52 &= -3;
					}
					break;
				case 7:
					if(v52) {
						bs52 |= 1;
					} else {
						bs52 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs52;
			var this54 = 0;
			var bs53 = this54;
			var l53 = "     ".length;
			var _g154 = 0;
			var _g64 = l53;
			while(_g154 < _g64) {
				var i54 = _g154++;
				var no53 = "     ".charCodeAt(i54);
				if(no53 == null) {
					break;
				}
				var v53;
				switch(no53) {
				case 32:
					v53 = false;
					break;
				case 42:
					v53 = true;
					break;
				case 48:
					v53 = false;
					break;
				case 49:
					v53 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i54)));
				}
				switch(i54 - (l53 - 8)) {
				case 0:
					if(v53) {
						bs53 |= 128;
					} else {
						bs53 &= -129;
					}
					break;
				case 1:
					if(v53) {
						bs53 |= 64;
					} else {
						bs53 &= -65;
					}
					break;
				case 2:
					if(v53) {
						bs53 |= 32;
					} else {
						bs53 &= -33;
					}
					break;
				case 3:
					if(v53) {
						bs53 |= 16;
					} else {
						bs53 &= -17;
					}
					break;
				case 4:
					if(v53) {
						bs53 |= 8;
					} else {
						bs53 &= -9;
					}
					break;
				case 5:
					if(v53) {
						bs53 |= 4;
					} else {
						bs53 &= -5;
					}
					break;
				case 6:
					if(v53) {
						bs53 |= 2;
					} else {
						bs53 &= -3;
					}
					break;
				case 7:
					if(v53) {
						bs53 |= 1;
					} else {
						bs53 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs53;
			var this55 = 0;
			var bs54 = this55;
			var l54 = "     ".length;
			var _g155 = 0;
			var _g65 = l54;
			while(_g155 < _g65) {
				var i55 = _g155++;
				var no54 = "     ".charCodeAt(i55);
				if(no54 == null) {
					break;
				}
				var v54;
				switch(no54) {
				case 32:
					v54 = false;
					break;
				case 42:
					v54 = true;
					break;
				case 48:
					v54 = false;
					break;
				case 49:
					v54 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i55)));
				}
				switch(i55 - (l54 - 8)) {
				case 0:
					if(v54) {
						bs54 |= 128;
					} else {
						bs54 &= -129;
					}
					break;
				case 1:
					if(v54) {
						bs54 |= 64;
					} else {
						bs54 &= -65;
					}
					break;
				case 2:
					if(v54) {
						bs54 |= 32;
					} else {
						bs54 &= -33;
					}
					break;
				case 3:
					if(v54) {
						bs54 |= 16;
					} else {
						bs54 &= -17;
					}
					break;
				case 4:
					if(v54) {
						bs54 |= 8;
					} else {
						bs54 &= -9;
					}
					break;
				case 5:
					if(v54) {
						bs54 |= 4;
					} else {
						bs54 &= -5;
					}
					break;
				case 6:
					if(v54) {
						bs54 |= 2;
					} else {
						bs54 &= -3;
					}
					break;
				case 7:
					if(v54) {
						bs54 |= 1;
					} else {
						bs54 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs54;
			var this56 = 0;
			var bs55 = this56;
			var l55 = "     ".length;
			var _g156 = 0;
			var _g66 = l55;
			while(_g156 < _g66) {
				var i56 = _g156++;
				var no55 = "     ".charCodeAt(i56);
				if(no55 == null) {
					break;
				}
				var v55;
				switch(no55) {
				case 32:
					v55 = false;
					break;
				case 42:
					v55 = true;
					break;
				case 48:
					v55 = false;
					break;
				case 49:
					v55 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i56)));
				}
				switch(i56 - (l55 - 8)) {
				case 0:
					if(v55) {
						bs55 |= 128;
					} else {
						bs55 &= -129;
					}
					break;
				case 1:
					if(v55) {
						bs55 |= 64;
					} else {
						bs55 &= -65;
					}
					break;
				case 2:
					if(v55) {
						bs55 |= 32;
					} else {
						bs55 &= -33;
					}
					break;
				case 3:
					if(v55) {
						bs55 |= 16;
					} else {
						bs55 &= -17;
					}
					break;
				case 4:
					if(v55) {
						bs55 |= 8;
					} else {
						bs55 &= -9;
					}
					break;
				case 5:
					if(v55) {
						bs55 |= 4;
					} else {
						bs55 &= -5;
					}
					break;
				case 6:
					if(v55) {
						bs55 |= 2;
					} else {
						bs55 &= -3;
					}
					break;
				case 7:
					if(v55) {
						bs55 |= 1;
					} else {
						bs55 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs55;
			break;
		case 40:
			var this57 = 0;
			var bs56 = this57;
			var l56 = "  *  ".length;
			var _g157 = 0;
			var _g67 = l56;
			while(_g157 < _g67) {
				var i57 = _g157++;
				var no56 = "  *  ".charCodeAt(i57);
				if(no56 == null) {
					break;
				}
				var v56;
				switch(no56) {
				case 32:
					v56 = false;
					break;
				case 42:
					v56 = true;
					break;
				case 48:
					v56 = false;
					break;
				case 49:
					v56 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i57)));
				}
				switch(i57 - (l56 - 8)) {
				case 0:
					if(v56) {
						bs56 |= 128;
					} else {
						bs56 &= -129;
					}
					break;
				case 1:
					if(v56) {
						bs56 |= 64;
					} else {
						bs56 &= -65;
					}
					break;
				case 2:
					if(v56) {
						bs56 |= 32;
					} else {
						bs56 &= -33;
					}
					break;
				case 3:
					if(v56) {
						bs56 |= 16;
					} else {
						bs56 &= -17;
					}
					break;
				case 4:
					if(v56) {
						bs56 |= 8;
					} else {
						bs56 &= -9;
					}
					break;
				case 5:
					if(v56) {
						bs56 |= 4;
					} else {
						bs56 &= -5;
					}
					break;
				case 6:
					if(v56) {
						bs56 |= 2;
					} else {
						bs56 &= -3;
					}
					break;
				case 7:
					if(v56) {
						bs56 |= 1;
					} else {
						bs56 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs56;
			var this58 = 0;
			var bs57 = this58;
			var l57 = " *   ".length;
			var _g158 = 0;
			var _g68 = l57;
			while(_g158 < _g68) {
				var i58 = _g158++;
				var no57 = " *   ".charCodeAt(i58);
				if(no57 == null) {
					break;
				}
				var v57;
				switch(no57) {
				case 32:
					v57 = false;
					break;
				case 42:
					v57 = true;
					break;
				case 48:
					v57 = false;
					break;
				case 49:
					v57 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i58)));
				}
				switch(i58 - (l57 - 8)) {
				case 0:
					if(v57) {
						bs57 |= 128;
					} else {
						bs57 &= -129;
					}
					break;
				case 1:
					if(v57) {
						bs57 |= 64;
					} else {
						bs57 &= -65;
					}
					break;
				case 2:
					if(v57) {
						bs57 |= 32;
					} else {
						bs57 &= -33;
					}
					break;
				case 3:
					if(v57) {
						bs57 |= 16;
					} else {
						bs57 &= -17;
					}
					break;
				case 4:
					if(v57) {
						bs57 |= 8;
					} else {
						bs57 &= -9;
					}
					break;
				case 5:
					if(v57) {
						bs57 |= 4;
					} else {
						bs57 &= -5;
					}
					break;
				case 6:
					if(v57) {
						bs57 |= 2;
					} else {
						bs57 &= -3;
					}
					break;
				case 7:
					if(v57) {
						bs57 |= 1;
					} else {
						bs57 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs57;
			var this59 = 0;
			var bs58 = this59;
			var l58 = "*    ".length;
			var _g159 = 0;
			var _g69 = l58;
			while(_g159 < _g69) {
				var i59 = _g159++;
				var no58 = "*    ".charCodeAt(i59);
				if(no58 == null) {
					break;
				}
				var v58;
				switch(no58) {
				case 32:
					v58 = false;
					break;
				case 42:
					v58 = true;
					break;
				case 48:
					v58 = false;
					break;
				case 49:
					v58 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i59)));
				}
				switch(i59 - (l58 - 8)) {
				case 0:
					if(v58) {
						bs58 |= 128;
					} else {
						bs58 &= -129;
					}
					break;
				case 1:
					if(v58) {
						bs58 |= 64;
					} else {
						bs58 &= -65;
					}
					break;
				case 2:
					if(v58) {
						bs58 |= 32;
					} else {
						bs58 &= -33;
					}
					break;
				case 3:
					if(v58) {
						bs58 |= 16;
					} else {
						bs58 &= -17;
					}
					break;
				case 4:
					if(v58) {
						bs58 |= 8;
					} else {
						bs58 &= -9;
					}
					break;
				case 5:
					if(v58) {
						bs58 |= 4;
					} else {
						bs58 &= -5;
					}
					break;
				case 6:
					if(v58) {
						bs58 |= 2;
					} else {
						bs58 &= -3;
					}
					break;
				case 7:
					if(v58) {
						bs58 |= 1;
					} else {
						bs58 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs58;
			var this60 = 0;
			var bs59 = this60;
			var l59 = "*    ".length;
			var _g160 = 0;
			var _g70 = l59;
			while(_g160 < _g70) {
				var i60 = _g160++;
				var no59 = "*    ".charCodeAt(i60);
				if(no59 == null) {
					break;
				}
				var v59;
				switch(no59) {
				case 32:
					v59 = false;
					break;
				case 42:
					v59 = true;
					break;
				case 48:
					v59 = false;
					break;
				case 49:
					v59 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i60)));
				}
				switch(i60 - (l59 - 8)) {
				case 0:
					if(v59) {
						bs59 |= 128;
					} else {
						bs59 &= -129;
					}
					break;
				case 1:
					if(v59) {
						bs59 |= 64;
					} else {
						bs59 &= -65;
					}
					break;
				case 2:
					if(v59) {
						bs59 |= 32;
					} else {
						bs59 &= -33;
					}
					break;
				case 3:
					if(v59) {
						bs59 |= 16;
					} else {
						bs59 &= -17;
					}
					break;
				case 4:
					if(v59) {
						bs59 |= 8;
					} else {
						bs59 &= -9;
					}
					break;
				case 5:
					if(v59) {
						bs59 |= 4;
					} else {
						bs59 &= -5;
					}
					break;
				case 6:
					if(v59) {
						bs59 |= 2;
					} else {
						bs59 &= -3;
					}
					break;
				case 7:
					if(v59) {
						bs59 |= 1;
					} else {
						bs59 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs59;
			var this61 = 0;
			var bs60 = this61;
			var l60 = "*    ".length;
			var _g161 = 0;
			var _g71 = l60;
			while(_g161 < _g71) {
				var i61 = _g161++;
				var no60 = "*    ".charCodeAt(i61);
				if(no60 == null) {
					break;
				}
				var v60;
				switch(no60) {
				case 32:
					v60 = false;
					break;
				case 42:
					v60 = true;
					break;
				case 48:
					v60 = false;
					break;
				case 49:
					v60 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i61)));
				}
				switch(i61 - (l60 - 8)) {
				case 0:
					if(v60) {
						bs60 |= 128;
					} else {
						bs60 &= -129;
					}
					break;
				case 1:
					if(v60) {
						bs60 |= 64;
					} else {
						bs60 &= -65;
					}
					break;
				case 2:
					if(v60) {
						bs60 |= 32;
					} else {
						bs60 &= -33;
					}
					break;
				case 3:
					if(v60) {
						bs60 |= 16;
					} else {
						bs60 &= -17;
					}
					break;
				case 4:
					if(v60) {
						bs60 |= 8;
					} else {
						bs60 &= -9;
					}
					break;
				case 5:
					if(v60) {
						bs60 |= 4;
					} else {
						bs60 &= -5;
					}
					break;
				case 6:
					if(v60) {
						bs60 |= 2;
					} else {
						bs60 &= -3;
					}
					break;
				case 7:
					if(v60) {
						bs60 |= 1;
					} else {
						bs60 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs60;
			var this62 = 0;
			var bs61 = this62;
			var l61 = " *   ".length;
			var _g162 = 0;
			var _g72 = l61;
			while(_g162 < _g72) {
				var i62 = _g162++;
				var no61 = " *   ".charCodeAt(i62);
				if(no61 == null) {
					break;
				}
				var v61;
				switch(no61) {
				case 32:
					v61 = false;
					break;
				case 42:
					v61 = true;
					break;
				case 48:
					v61 = false;
					break;
				case 49:
					v61 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i62)));
				}
				switch(i62 - (l61 - 8)) {
				case 0:
					if(v61) {
						bs61 |= 128;
					} else {
						bs61 &= -129;
					}
					break;
				case 1:
					if(v61) {
						bs61 |= 64;
					} else {
						bs61 &= -65;
					}
					break;
				case 2:
					if(v61) {
						bs61 |= 32;
					} else {
						bs61 &= -33;
					}
					break;
				case 3:
					if(v61) {
						bs61 |= 16;
					} else {
						bs61 &= -17;
					}
					break;
				case 4:
					if(v61) {
						bs61 |= 8;
					} else {
						bs61 &= -9;
					}
					break;
				case 5:
					if(v61) {
						bs61 |= 4;
					} else {
						bs61 &= -5;
					}
					break;
				case 6:
					if(v61) {
						bs61 |= 2;
					} else {
						bs61 &= -3;
					}
					break;
				case 7:
					if(v61) {
						bs61 |= 1;
					} else {
						bs61 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs61;
			var this63 = 0;
			var bs62 = this63;
			var l62 = "  *  ".length;
			var _g163 = 0;
			var _g73 = l62;
			while(_g163 < _g73) {
				var i63 = _g163++;
				var no62 = "  *  ".charCodeAt(i63);
				if(no62 == null) {
					break;
				}
				var v62;
				switch(no62) {
				case 32:
					v62 = false;
					break;
				case 42:
					v62 = true;
					break;
				case 48:
					v62 = false;
					break;
				case 49:
					v62 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i63)));
				}
				switch(i63 - (l62 - 8)) {
				case 0:
					if(v62) {
						bs62 |= 128;
					} else {
						bs62 &= -129;
					}
					break;
				case 1:
					if(v62) {
						bs62 |= 64;
					} else {
						bs62 &= -65;
					}
					break;
				case 2:
					if(v62) {
						bs62 |= 32;
					} else {
						bs62 &= -33;
					}
					break;
				case 3:
					if(v62) {
						bs62 |= 16;
					} else {
						bs62 &= -17;
					}
					break;
				case 4:
					if(v62) {
						bs62 |= 8;
					} else {
						bs62 &= -9;
					}
					break;
				case 5:
					if(v62) {
						bs62 |= 4;
					} else {
						bs62 &= -5;
					}
					break;
				case 6:
					if(v62) {
						bs62 |= 2;
					} else {
						bs62 &= -3;
					}
					break;
				case 7:
					if(v62) {
						bs62 |= 1;
					} else {
						bs62 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs62;
			break;
		case 41:
			var this64 = 0;
			var bs63 = this64;
			var l63 = "  *  ".length;
			var _g164 = 0;
			var _g74 = l63;
			while(_g164 < _g74) {
				var i64 = _g164++;
				var no63 = "  *  ".charCodeAt(i64);
				if(no63 == null) {
					break;
				}
				var v63;
				switch(no63) {
				case 32:
					v63 = false;
					break;
				case 42:
					v63 = true;
					break;
				case 48:
					v63 = false;
					break;
				case 49:
					v63 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i64)));
				}
				switch(i64 - (l63 - 8)) {
				case 0:
					if(v63) {
						bs63 |= 128;
					} else {
						bs63 &= -129;
					}
					break;
				case 1:
					if(v63) {
						bs63 |= 64;
					} else {
						bs63 &= -65;
					}
					break;
				case 2:
					if(v63) {
						bs63 |= 32;
					} else {
						bs63 &= -33;
					}
					break;
				case 3:
					if(v63) {
						bs63 |= 16;
					} else {
						bs63 &= -17;
					}
					break;
				case 4:
					if(v63) {
						bs63 |= 8;
					} else {
						bs63 &= -9;
					}
					break;
				case 5:
					if(v63) {
						bs63 |= 4;
					} else {
						bs63 &= -5;
					}
					break;
				case 6:
					if(v63) {
						bs63 |= 2;
					} else {
						bs63 &= -3;
					}
					break;
				case 7:
					if(v63) {
						bs63 |= 1;
					} else {
						bs63 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs63;
			var this65 = 0;
			var bs64 = this65;
			var l64 = "   * ".length;
			var _g165 = 0;
			var _g75 = l64;
			while(_g165 < _g75) {
				var i65 = _g165++;
				var no64 = "   * ".charCodeAt(i65);
				if(no64 == null) {
					break;
				}
				var v64;
				switch(no64) {
				case 32:
					v64 = false;
					break;
				case 42:
					v64 = true;
					break;
				case 48:
					v64 = false;
					break;
				case 49:
					v64 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i65)));
				}
				switch(i65 - (l64 - 8)) {
				case 0:
					if(v64) {
						bs64 |= 128;
					} else {
						bs64 &= -129;
					}
					break;
				case 1:
					if(v64) {
						bs64 |= 64;
					} else {
						bs64 &= -65;
					}
					break;
				case 2:
					if(v64) {
						bs64 |= 32;
					} else {
						bs64 &= -33;
					}
					break;
				case 3:
					if(v64) {
						bs64 |= 16;
					} else {
						bs64 &= -17;
					}
					break;
				case 4:
					if(v64) {
						bs64 |= 8;
					} else {
						bs64 &= -9;
					}
					break;
				case 5:
					if(v64) {
						bs64 |= 4;
					} else {
						bs64 &= -5;
					}
					break;
				case 6:
					if(v64) {
						bs64 |= 2;
					} else {
						bs64 &= -3;
					}
					break;
				case 7:
					if(v64) {
						bs64 |= 1;
					} else {
						bs64 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs64;
			var this66 = 0;
			var bs65 = this66;
			var l65 = "    *".length;
			var _g166 = 0;
			var _g76 = l65;
			while(_g166 < _g76) {
				var i66 = _g166++;
				var no65 = "    *".charCodeAt(i66);
				if(no65 == null) {
					break;
				}
				var v65;
				switch(no65) {
				case 32:
					v65 = false;
					break;
				case 42:
					v65 = true;
					break;
				case 48:
					v65 = false;
					break;
				case 49:
					v65 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i66)));
				}
				switch(i66 - (l65 - 8)) {
				case 0:
					if(v65) {
						bs65 |= 128;
					} else {
						bs65 &= -129;
					}
					break;
				case 1:
					if(v65) {
						bs65 |= 64;
					} else {
						bs65 &= -65;
					}
					break;
				case 2:
					if(v65) {
						bs65 |= 32;
					} else {
						bs65 &= -33;
					}
					break;
				case 3:
					if(v65) {
						bs65 |= 16;
					} else {
						bs65 &= -17;
					}
					break;
				case 4:
					if(v65) {
						bs65 |= 8;
					} else {
						bs65 &= -9;
					}
					break;
				case 5:
					if(v65) {
						bs65 |= 4;
					} else {
						bs65 &= -5;
					}
					break;
				case 6:
					if(v65) {
						bs65 |= 2;
					} else {
						bs65 &= -3;
					}
					break;
				case 7:
					if(v65) {
						bs65 |= 1;
					} else {
						bs65 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs65;
			var this67 = 0;
			var bs66 = this67;
			var l66 = "    *".length;
			var _g167 = 0;
			var _g77 = l66;
			while(_g167 < _g77) {
				var i67 = _g167++;
				var no66 = "    *".charCodeAt(i67);
				if(no66 == null) {
					break;
				}
				var v66;
				switch(no66) {
				case 32:
					v66 = false;
					break;
				case 42:
					v66 = true;
					break;
				case 48:
					v66 = false;
					break;
				case 49:
					v66 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i67)));
				}
				switch(i67 - (l66 - 8)) {
				case 0:
					if(v66) {
						bs66 |= 128;
					} else {
						bs66 &= -129;
					}
					break;
				case 1:
					if(v66) {
						bs66 |= 64;
					} else {
						bs66 &= -65;
					}
					break;
				case 2:
					if(v66) {
						bs66 |= 32;
					} else {
						bs66 &= -33;
					}
					break;
				case 3:
					if(v66) {
						bs66 |= 16;
					} else {
						bs66 &= -17;
					}
					break;
				case 4:
					if(v66) {
						bs66 |= 8;
					} else {
						bs66 &= -9;
					}
					break;
				case 5:
					if(v66) {
						bs66 |= 4;
					} else {
						bs66 &= -5;
					}
					break;
				case 6:
					if(v66) {
						bs66 |= 2;
					} else {
						bs66 &= -3;
					}
					break;
				case 7:
					if(v66) {
						bs66 |= 1;
					} else {
						bs66 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs66;
			var this68 = 0;
			var bs67 = this68;
			var l67 = "    *".length;
			var _g168 = 0;
			var _g78 = l67;
			while(_g168 < _g78) {
				var i68 = _g168++;
				var no67 = "    *".charCodeAt(i68);
				if(no67 == null) {
					break;
				}
				var v67;
				switch(no67) {
				case 32:
					v67 = false;
					break;
				case 42:
					v67 = true;
					break;
				case 48:
					v67 = false;
					break;
				case 49:
					v67 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i68)));
				}
				switch(i68 - (l67 - 8)) {
				case 0:
					if(v67) {
						bs67 |= 128;
					} else {
						bs67 &= -129;
					}
					break;
				case 1:
					if(v67) {
						bs67 |= 64;
					} else {
						bs67 &= -65;
					}
					break;
				case 2:
					if(v67) {
						bs67 |= 32;
					} else {
						bs67 &= -33;
					}
					break;
				case 3:
					if(v67) {
						bs67 |= 16;
					} else {
						bs67 &= -17;
					}
					break;
				case 4:
					if(v67) {
						bs67 |= 8;
					} else {
						bs67 &= -9;
					}
					break;
				case 5:
					if(v67) {
						bs67 |= 4;
					} else {
						bs67 &= -5;
					}
					break;
				case 6:
					if(v67) {
						bs67 |= 2;
					} else {
						bs67 &= -3;
					}
					break;
				case 7:
					if(v67) {
						bs67 |= 1;
					} else {
						bs67 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs67;
			var this69 = 0;
			var bs68 = this69;
			var l68 = "   * ".length;
			var _g169 = 0;
			var _g79 = l68;
			while(_g169 < _g79) {
				var i69 = _g169++;
				var no68 = "   * ".charCodeAt(i69);
				if(no68 == null) {
					break;
				}
				var v68;
				switch(no68) {
				case 32:
					v68 = false;
					break;
				case 42:
					v68 = true;
					break;
				case 48:
					v68 = false;
					break;
				case 49:
					v68 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i69)));
				}
				switch(i69 - (l68 - 8)) {
				case 0:
					if(v68) {
						bs68 |= 128;
					} else {
						bs68 &= -129;
					}
					break;
				case 1:
					if(v68) {
						bs68 |= 64;
					} else {
						bs68 &= -65;
					}
					break;
				case 2:
					if(v68) {
						bs68 |= 32;
					} else {
						bs68 &= -33;
					}
					break;
				case 3:
					if(v68) {
						bs68 |= 16;
					} else {
						bs68 &= -17;
					}
					break;
				case 4:
					if(v68) {
						bs68 |= 8;
					} else {
						bs68 &= -9;
					}
					break;
				case 5:
					if(v68) {
						bs68 |= 4;
					} else {
						bs68 &= -5;
					}
					break;
				case 6:
					if(v68) {
						bs68 |= 2;
					} else {
						bs68 &= -3;
					}
					break;
				case 7:
					if(v68) {
						bs68 |= 1;
					} else {
						bs68 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs68;
			var this70 = 0;
			var bs69 = this70;
			var l69 = "  *  ".length;
			var _g170 = 0;
			var _g80 = l69;
			while(_g170 < _g80) {
				var i70 = _g170++;
				var no69 = "  *  ".charCodeAt(i70);
				if(no69 == null) {
					break;
				}
				var v69;
				switch(no69) {
				case 32:
					v69 = false;
					break;
				case 42:
					v69 = true;
					break;
				case 48:
					v69 = false;
					break;
				case 49:
					v69 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i70)));
				}
				switch(i70 - (l69 - 8)) {
				case 0:
					if(v69) {
						bs69 |= 128;
					} else {
						bs69 &= -129;
					}
					break;
				case 1:
					if(v69) {
						bs69 |= 64;
					} else {
						bs69 &= -65;
					}
					break;
				case 2:
					if(v69) {
						bs69 |= 32;
					} else {
						bs69 &= -33;
					}
					break;
				case 3:
					if(v69) {
						bs69 |= 16;
					} else {
						bs69 &= -17;
					}
					break;
				case 4:
					if(v69) {
						bs69 |= 8;
					} else {
						bs69 &= -9;
					}
					break;
				case 5:
					if(v69) {
						bs69 |= 4;
					} else {
						bs69 &= -5;
					}
					break;
				case 6:
					if(v69) {
						bs69 |= 2;
					} else {
						bs69 &= -3;
					}
					break;
				case 7:
					if(v69) {
						bs69 |= 1;
					} else {
						bs69 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs69;
			break;
		case 42:
			var this71 = 0;
			var bs70 = this71;
			var l70 = "  *  ".length;
			var _g171 = 0;
			var _g81 = l70;
			while(_g171 < _g81) {
				var i71 = _g171++;
				var no70 = "  *  ".charCodeAt(i71);
				if(no70 == null) {
					break;
				}
				var v70;
				switch(no70) {
				case 32:
					v70 = false;
					break;
				case 42:
					v70 = true;
					break;
				case 48:
					v70 = false;
					break;
				case 49:
					v70 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i71)));
				}
				switch(i71 - (l70 - 8)) {
				case 0:
					if(v70) {
						bs70 |= 128;
					} else {
						bs70 &= -129;
					}
					break;
				case 1:
					if(v70) {
						bs70 |= 64;
					} else {
						bs70 &= -65;
					}
					break;
				case 2:
					if(v70) {
						bs70 |= 32;
					} else {
						bs70 &= -33;
					}
					break;
				case 3:
					if(v70) {
						bs70 |= 16;
					} else {
						bs70 &= -17;
					}
					break;
				case 4:
					if(v70) {
						bs70 |= 8;
					} else {
						bs70 &= -9;
					}
					break;
				case 5:
					if(v70) {
						bs70 |= 4;
					} else {
						bs70 &= -5;
					}
					break;
				case 6:
					if(v70) {
						bs70 |= 2;
					} else {
						bs70 &= -3;
					}
					break;
				case 7:
					if(v70) {
						bs70 |= 1;
					} else {
						bs70 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs70;
			var this72 = 0;
			var bs71 = this72;
			var l71 = "  *  ".length;
			var _g172 = 0;
			var _g82 = l71;
			while(_g172 < _g82) {
				var i72 = _g172++;
				var no71 = "  *  ".charCodeAt(i72);
				if(no71 == null) {
					break;
				}
				var v71;
				switch(no71) {
				case 32:
					v71 = false;
					break;
				case 42:
					v71 = true;
					break;
				case 48:
					v71 = false;
					break;
				case 49:
					v71 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i72)));
				}
				switch(i72 - (l71 - 8)) {
				case 0:
					if(v71) {
						bs71 |= 128;
					} else {
						bs71 &= -129;
					}
					break;
				case 1:
					if(v71) {
						bs71 |= 64;
					} else {
						bs71 &= -65;
					}
					break;
				case 2:
					if(v71) {
						bs71 |= 32;
					} else {
						bs71 &= -33;
					}
					break;
				case 3:
					if(v71) {
						bs71 |= 16;
					} else {
						bs71 &= -17;
					}
					break;
				case 4:
					if(v71) {
						bs71 |= 8;
					} else {
						bs71 &= -9;
					}
					break;
				case 5:
					if(v71) {
						bs71 |= 4;
					} else {
						bs71 &= -5;
					}
					break;
				case 6:
					if(v71) {
						bs71 |= 2;
					} else {
						bs71 &= -3;
					}
					break;
				case 7:
					if(v71) {
						bs71 |= 1;
					} else {
						bs71 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs71;
			var this73 = 0;
			var bs72 = this73;
			var l72 = "* * *".length;
			var _g173 = 0;
			var _g83 = l72;
			while(_g173 < _g83) {
				var i73 = _g173++;
				var no72 = "* * *".charCodeAt(i73);
				if(no72 == null) {
					break;
				}
				var v72;
				switch(no72) {
				case 32:
					v72 = false;
					break;
				case 42:
					v72 = true;
					break;
				case 48:
					v72 = false;
					break;
				case 49:
					v72 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i73)));
				}
				switch(i73 - (l72 - 8)) {
				case 0:
					if(v72) {
						bs72 |= 128;
					} else {
						bs72 &= -129;
					}
					break;
				case 1:
					if(v72) {
						bs72 |= 64;
					} else {
						bs72 &= -65;
					}
					break;
				case 2:
					if(v72) {
						bs72 |= 32;
					} else {
						bs72 &= -33;
					}
					break;
				case 3:
					if(v72) {
						bs72 |= 16;
					} else {
						bs72 &= -17;
					}
					break;
				case 4:
					if(v72) {
						bs72 |= 8;
					} else {
						bs72 &= -9;
					}
					break;
				case 5:
					if(v72) {
						bs72 |= 4;
					} else {
						bs72 &= -5;
					}
					break;
				case 6:
					if(v72) {
						bs72 |= 2;
					} else {
						bs72 &= -3;
					}
					break;
				case 7:
					if(v72) {
						bs72 |= 1;
					} else {
						bs72 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs72;
			var this74 = 0;
			var bs73 = this74;
			var l73 = " *** ".length;
			var _g174 = 0;
			var _g84 = l73;
			while(_g174 < _g84) {
				var i74 = _g174++;
				var no73 = " *** ".charCodeAt(i74);
				if(no73 == null) {
					break;
				}
				var v73;
				switch(no73) {
				case 32:
					v73 = false;
					break;
				case 42:
					v73 = true;
					break;
				case 48:
					v73 = false;
					break;
				case 49:
					v73 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i74)));
				}
				switch(i74 - (l73 - 8)) {
				case 0:
					if(v73) {
						bs73 |= 128;
					} else {
						bs73 &= -129;
					}
					break;
				case 1:
					if(v73) {
						bs73 |= 64;
					} else {
						bs73 &= -65;
					}
					break;
				case 2:
					if(v73) {
						bs73 |= 32;
					} else {
						bs73 &= -33;
					}
					break;
				case 3:
					if(v73) {
						bs73 |= 16;
					} else {
						bs73 &= -17;
					}
					break;
				case 4:
					if(v73) {
						bs73 |= 8;
					} else {
						bs73 &= -9;
					}
					break;
				case 5:
					if(v73) {
						bs73 |= 4;
					} else {
						bs73 &= -5;
					}
					break;
				case 6:
					if(v73) {
						bs73 |= 2;
					} else {
						bs73 &= -3;
					}
					break;
				case 7:
					if(v73) {
						bs73 |= 1;
					} else {
						bs73 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs73;
			var this75 = 0;
			var bs74 = this75;
			var l74 = "* * *".length;
			var _g175 = 0;
			var _g85 = l74;
			while(_g175 < _g85) {
				var i75 = _g175++;
				var no74 = "* * *".charCodeAt(i75);
				if(no74 == null) {
					break;
				}
				var v74;
				switch(no74) {
				case 32:
					v74 = false;
					break;
				case 42:
					v74 = true;
					break;
				case 48:
					v74 = false;
					break;
				case 49:
					v74 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i75)));
				}
				switch(i75 - (l74 - 8)) {
				case 0:
					if(v74) {
						bs74 |= 128;
					} else {
						bs74 &= -129;
					}
					break;
				case 1:
					if(v74) {
						bs74 |= 64;
					} else {
						bs74 &= -65;
					}
					break;
				case 2:
					if(v74) {
						bs74 |= 32;
					} else {
						bs74 &= -33;
					}
					break;
				case 3:
					if(v74) {
						bs74 |= 16;
					} else {
						bs74 &= -17;
					}
					break;
				case 4:
					if(v74) {
						bs74 |= 8;
					} else {
						bs74 &= -9;
					}
					break;
				case 5:
					if(v74) {
						bs74 |= 4;
					} else {
						bs74 &= -5;
					}
					break;
				case 6:
					if(v74) {
						bs74 |= 2;
					} else {
						bs74 &= -3;
					}
					break;
				case 7:
					if(v74) {
						bs74 |= 1;
					} else {
						bs74 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs74;
			var this76 = 0;
			var bs75 = this76;
			var l75 = "  *  ".length;
			var _g176 = 0;
			var _g86 = l75;
			while(_g176 < _g86) {
				var i76 = _g176++;
				var no75 = "  *  ".charCodeAt(i76);
				if(no75 == null) {
					break;
				}
				var v75;
				switch(no75) {
				case 32:
					v75 = false;
					break;
				case 42:
					v75 = true;
					break;
				case 48:
					v75 = false;
					break;
				case 49:
					v75 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i76)));
				}
				switch(i76 - (l75 - 8)) {
				case 0:
					if(v75) {
						bs75 |= 128;
					} else {
						bs75 &= -129;
					}
					break;
				case 1:
					if(v75) {
						bs75 |= 64;
					} else {
						bs75 &= -65;
					}
					break;
				case 2:
					if(v75) {
						bs75 |= 32;
					} else {
						bs75 &= -33;
					}
					break;
				case 3:
					if(v75) {
						bs75 |= 16;
					} else {
						bs75 &= -17;
					}
					break;
				case 4:
					if(v75) {
						bs75 |= 8;
					} else {
						bs75 &= -9;
					}
					break;
				case 5:
					if(v75) {
						bs75 |= 4;
					} else {
						bs75 &= -5;
					}
					break;
				case 6:
					if(v75) {
						bs75 |= 2;
					} else {
						bs75 &= -3;
					}
					break;
				case 7:
					if(v75) {
						bs75 |= 1;
					} else {
						bs75 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs75;
			var this77 = 0;
			var bs76 = this77;
			var l76 = "     ".length;
			var _g177 = 0;
			var _g87 = l76;
			while(_g177 < _g87) {
				var i77 = _g177++;
				var no76 = "     ".charCodeAt(i77);
				if(no76 == null) {
					break;
				}
				var v76;
				switch(no76) {
				case 32:
					v76 = false;
					break;
				case 42:
					v76 = true;
					break;
				case 48:
					v76 = false;
					break;
				case 49:
					v76 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i77)));
				}
				switch(i77 - (l76 - 8)) {
				case 0:
					if(v76) {
						bs76 |= 128;
					} else {
						bs76 &= -129;
					}
					break;
				case 1:
					if(v76) {
						bs76 |= 64;
					} else {
						bs76 &= -65;
					}
					break;
				case 2:
					if(v76) {
						bs76 |= 32;
					} else {
						bs76 &= -33;
					}
					break;
				case 3:
					if(v76) {
						bs76 |= 16;
					} else {
						bs76 &= -17;
					}
					break;
				case 4:
					if(v76) {
						bs76 |= 8;
					} else {
						bs76 &= -9;
					}
					break;
				case 5:
					if(v76) {
						bs76 |= 4;
					} else {
						bs76 &= -5;
					}
					break;
				case 6:
					if(v76) {
						bs76 |= 2;
					} else {
						bs76 &= -3;
					}
					break;
				case 7:
					if(v76) {
						bs76 |= 1;
					} else {
						bs76 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs76;
			break;
		case 43:
			var this78 = 0;
			var bs77 = this78;
			var l77 = "     ".length;
			var _g178 = 0;
			var _g88 = l77;
			while(_g178 < _g88) {
				var i78 = _g178++;
				var no77 = "     ".charCodeAt(i78);
				if(no77 == null) {
					break;
				}
				var v77;
				switch(no77) {
				case 32:
					v77 = false;
					break;
				case 42:
					v77 = true;
					break;
				case 48:
					v77 = false;
					break;
				case 49:
					v77 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i78)));
				}
				switch(i78 - (l77 - 8)) {
				case 0:
					if(v77) {
						bs77 |= 128;
					} else {
						bs77 &= -129;
					}
					break;
				case 1:
					if(v77) {
						bs77 |= 64;
					} else {
						bs77 &= -65;
					}
					break;
				case 2:
					if(v77) {
						bs77 |= 32;
					} else {
						bs77 &= -33;
					}
					break;
				case 3:
					if(v77) {
						bs77 |= 16;
					} else {
						bs77 &= -17;
					}
					break;
				case 4:
					if(v77) {
						bs77 |= 8;
					} else {
						bs77 &= -9;
					}
					break;
				case 5:
					if(v77) {
						bs77 |= 4;
					} else {
						bs77 &= -5;
					}
					break;
				case 6:
					if(v77) {
						bs77 |= 2;
					} else {
						bs77 &= -3;
					}
					break;
				case 7:
					if(v77) {
						bs77 |= 1;
					} else {
						bs77 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs77;
			var this79 = 0;
			var bs78 = this79;
			var l78 = "  *  ".length;
			var _g179 = 0;
			var _g89 = l78;
			while(_g179 < _g89) {
				var i79 = _g179++;
				var no78 = "  *  ".charCodeAt(i79);
				if(no78 == null) {
					break;
				}
				var v78;
				switch(no78) {
				case 32:
					v78 = false;
					break;
				case 42:
					v78 = true;
					break;
				case 48:
					v78 = false;
					break;
				case 49:
					v78 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i79)));
				}
				switch(i79 - (l78 - 8)) {
				case 0:
					if(v78) {
						bs78 |= 128;
					} else {
						bs78 &= -129;
					}
					break;
				case 1:
					if(v78) {
						bs78 |= 64;
					} else {
						bs78 &= -65;
					}
					break;
				case 2:
					if(v78) {
						bs78 |= 32;
					} else {
						bs78 &= -33;
					}
					break;
				case 3:
					if(v78) {
						bs78 |= 16;
					} else {
						bs78 &= -17;
					}
					break;
				case 4:
					if(v78) {
						bs78 |= 8;
					} else {
						bs78 &= -9;
					}
					break;
				case 5:
					if(v78) {
						bs78 |= 4;
					} else {
						bs78 &= -5;
					}
					break;
				case 6:
					if(v78) {
						bs78 |= 2;
					} else {
						bs78 &= -3;
					}
					break;
				case 7:
					if(v78) {
						bs78 |= 1;
					} else {
						bs78 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs78;
			var this80 = 0;
			var bs79 = this80;
			var l79 = "  *  ".length;
			var _g180 = 0;
			var _g90 = l79;
			while(_g180 < _g90) {
				var i80 = _g180++;
				var no79 = "  *  ".charCodeAt(i80);
				if(no79 == null) {
					break;
				}
				var v79;
				switch(no79) {
				case 32:
					v79 = false;
					break;
				case 42:
					v79 = true;
					break;
				case 48:
					v79 = false;
					break;
				case 49:
					v79 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i80)));
				}
				switch(i80 - (l79 - 8)) {
				case 0:
					if(v79) {
						bs79 |= 128;
					} else {
						bs79 &= -129;
					}
					break;
				case 1:
					if(v79) {
						bs79 |= 64;
					} else {
						bs79 &= -65;
					}
					break;
				case 2:
					if(v79) {
						bs79 |= 32;
					} else {
						bs79 &= -33;
					}
					break;
				case 3:
					if(v79) {
						bs79 |= 16;
					} else {
						bs79 &= -17;
					}
					break;
				case 4:
					if(v79) {
						bs79 |= 8;
					} else {
						bs79 &= -9;
					}
					break;
				case 5:
					if(v79) {
						bs79 |= 4;
					} else {
						bs79 &= -5;
					}
					break;
				case 6:
					if(v79) {
						bs79 |= 2;
					} else {
						bs79 &= -3;
					}
					break;
				case 7:
					if(v79) {
						bs79 |= 1;
					} else {
						bs79 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs79;
			var this81 = 0;
			var bs80 = this81;
			var l80 = "*****".length;
			var _g181 = 0;
			var _g91 = l80;
			while(_g181 < _g91) {
				var i81 = _g181++;
				var no80 = "*****".charCodeAt(i81);
				if(no80 == null) {
					break;
				}
				var v80;
				switch(no80) {
				case 32:
					v80 = false;
					break;
				case 42:
					v80 = true;
					break;
				case 48:
					v80 = false;
					break;
				case 49:
					v80 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i81)));
				}
				switch(i81 - (l80 - 8)) {
				case 0:
					if(v80) {
						bs80 |= 128;
					} else {
						bs80 &= -129;
					}
					break;
				case 1:
					if(v80) {
						bs80 |= 64;
					} else {
						bs80 &= -65;
					}
					break;
				case 2:
					if(v80) {
						bs80 |= 32;
					} else {
						bs80 &= -33;
					}
					break;
				case 3:
					if(v80) {
						bs80 |= 16;
					} else {
						bs80 &= -17;
					}
					break;
				case 4:
					if(v80) {
						bs80 |= 8;
					} else {
						bs80 &= -9;
					}
					break;
				case 5:
					if(v80) {
						bs80 |= 4;
					} else {
						bs80 &= -5;
					}
					break;
				case 6:
					if(v80) {
						bs80 |= 2;
					} else {
						bs80 &= -3;
					}
					break;
				case 7:
					if(v80) {
						bs80 |= 1;
					} else {
						bs80 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs80;
			var this82 = 0;
			var bs81 = this82;
			var l81 = "  *  ".length;
			var _g182 = 0;
			var _g92 = l81;
			while(_g182 < _g92) {
				var i82 = _g182++;
				var no81 = "  *  ".charCodeAt(i82);
				if(no81 == null) {
					break;
				}
				var v81;
				switch(no81) {
				case 32:
					v81 = false;
					break;
				case 42:
					v81 = true;
					break;
				case 48:
					v81 = false;
					break;
				case 49:
					v81 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i82)));
				}
				switch(i82 - (l81 - 8)) {
				case 0:
					if(v81) {
						bs81 |= 128;
					} else {
						bs81 &= -129;
					}
					break;
				case 1:
					if(v81) {
						bs81 |= 64;
					} else {
						bs81 &= -65;
					}
					break;
				case 2:
					if(v81) {
						bs81 |= 32;
					} else {
						bs81 &= -33;
					}
					break;
				case 3:
					if(v81) {
						bs81 |= 16;
					} else {
						bs81 &= -17;
					}
					break;
				case 4:
					if(v81) {
						bs81 |= 8;
					} else {
						bs81 &= -9;
					}
					break;
				case 5:
					if(v81) {
						bs81 |= 4;
					} else {
						bs81 &= -5;
					}
					break;
				case 6:
					if(v81) {
						bs81 |= 2;
					} else {
						bs81 &= -3;
					}
					break;
				case 7:
					if(v81) {
						bs81 |= 1;
					} else {
						bs81 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs81;
			var this83 = 0;
			var bs82 = this83;
			var l82 = "  *  ".length;
			var _g183 = 0;
			var _g93 = l82;
			while(_g183 < _g93) {
				var i83 = _g183++;
				var no82 = "  *  ".charCodeAt(i83);
				if(no82 == null) {
					break;
				}
				var v82;
				switch(no82) {
				case 32:
					v82 = false;
					break;
				case 42:
					v82 = true;
					break;
				case 48:
					v82 = false;
					break;
				case 49:
					v82 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i83)));
				}
				switch(i83 - (l82 - 8)) {
				case 0:
					if(v82) {
						bs82 |= 128;
					} else {
						bs82 &= -129;
					}
					break;
				case 1:
					if(v82) {
						bs82 |= 64;
					} else {
						bs82 &= -65;
					}
					break;
				case 2:
					if(v82) {
						bs82 |= 32;
					} else {
						bs82 &= -33;
					}
					break;
				case 3:
					if(v82) {
						bs82 |= 16;
					} else {
						bs82 &= -17;
					}
					break;
				case 4:
					if(v82) {
						bs82 |= 8;
					} else {
						bs82 &= -9;
					}
					break;
				case 5:
					if(v82) {
						bs82 |= 4;
					} else {
						bs82 &= -5;
					}
					break;
				case 6:
					if(v82) {
						bs82 |= 2;
					} else {
						bs82 &= -3;
					}
					break;
				case 7:
					if(v82) {
						bs82 |= 1;
					} else {
						bs82 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs82;
			var this84 = 0;
			var bs83 = this84;
			var l83 = "     ".length;
			var _g184 = 0;
			var _g94 = l83;
			while(_g184 < _g94) {
				var i84 = _g184++;
				var no83 = "     ".charCodeAt(i84);
				if(no83 == null) {
					break;
				}
				var v83;
				switch(no83) {
				case 32:
					v83 = false;
					break;
				case 42:
					v83 = true;
					break;
				case 48:
					v83 = false;
					break;
				case 49:
					v83 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i84)));
				}
				switch(i84 - (l83 - 8)) {
				case 0:
					if(v83) {
						bs83 |= 128;
					} else {
						bs83 &= -129;
					}
					break;
				case 1:
					if(v83) {
						bs83 |= 64;
					} else {
						bs83 &= -65;
					}
					break;
				case 2:
					if(v83) {
						bs83 |= 32;
					} else {
						bs83 &= -33;
					}
					break;
				case 3:
					if(v83) {
						bs83 |= 16;
					} else {
						bs83 &= -17;
					}
					break;
				case 4:
					if(v83) {
						bs83 |= 8;
					} else {
						bs83 &= -9;
					}
					break;
				case 5:
					if(v83) {
						bs83 |= 4;
					} else {
						bs83 &= -5;
					}
					break;
				case 6:
					if(v83) {
						bs83 |= 2;
					} else {
						bs83 &= -3;
					}
					break;
				case 7:
					if(v83) {
						bs83 |= 1;
					} else {
						bs83 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs83;
			break;
		case 44:
			var this85 = 0;
			var bs84 = this85;
			var l84 = "     ".length;
			var _g185 = 0;
			var _g95 = l84;
			while(_g185 < _g95) {
				var i85 = _g185++;
				var no84 = "     ".charCodeAt(i85);
				if(no84 == null) {
					break;
				}
				var v84;
				switch(no84) {
				case 32:
					v84 = false;
					break;
				case 42:
					v84 = true;
					break;
				case 48:
					v84 = false;
					break;
				case 49:
					v84 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i85)));
				}
				switch(i85 - (l84 - 8)) {
				case 0:
					if(v84) {
						bs84 |= 128;
					} else {
						bs84 &= -129;
					}
					break;
				case 1:
					if(v84) {
						bs84 |= 64;
					} else {
						bs84 &= -65;
					}
					break;
				case 2:
					if(v84) {
						bs84 |= 32;
					} else {
						bs84 &= -33;
					}
					break;
				case 3:
					if(v84) {
						bs84 |= 16;
					} else {
						bs84 &= -17;
					}
					break;
				case 4:
					if(v84) {
						bs84 |= 8;
					} else {
						bs84 &= -9;
					}
					break;
				case 5:
					if(v84) {
						bs84 |= 4;
					} else {
						bs84 &= -5;
					}
					break;
				case 6:
					if(v84) {
						bs84 |= 2;
					} else {
						bs84 &= -3;
					}
					break;
				case 7:
					if(v84) {
						bs84 |= 1;
					} else {
						bs84 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs84;
			var this86 = 0;
			var bs85 = this86;
			var l85 = "     ".length;
			var _g186 = 0;
			var _g96 = l85;
			while(_g186 < _g96) {
				var i86 = _g186++;
				var no85 = "     ".charCodeAt(i86);
				if(no85 == null) {
					break;
				}
				var v85;
				switch(no85) {
				case 32:
					v85 = false;
					break;
				case 42:
					v85 = true;
					break;
				case 48:
					v85 = false;
					break;
				case 49:
					v85 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i86)));
				}
				switch(i86 - (l85 - 8)) {
				case 0:
					if(v85) {
						bs85 |= 128;
					} else {
						bs85 &= -129;
					}
					break;
				case 1:
					if(v85) {
						bs85 |= 64;
					} else {
						bs85 &= -65;
					}
					break;
				case 2:
					if(v85) {
						bs85 |= 32;
					} else {
						bs85 &= -33;
					}
					break;
				case 3:
					if(v85) {
						bs85 |= 16;
					} else {
						bs85 &= -17;
					}
					break;
				case 4:
					if(v85) {
						bs85 |= 8;
					} else {
						bs85 &= -9;
					}
					break;
				case 5:
					if(v85) {
						bs85 |= 4;
					} else {
						bs85 &= -5;
					}
					break;
				case 6:
					if(v85) {
						bs85 |= 2;
					} else {
						bs85 &= -3;
					}
					break;
				case 7:
					if(v85) {
						bs85 |= 1;
					} else {
						bs85 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs85;
			var this87 = 0;
			var bs86 = this87;
			var l86 = "     ".length;
			var _g187 = 0;
			var _g97 = l86;
			while(_g187 < _g97) {
				var i87 = _g187++;
				var no86 = "     ".charCodeAt(i87);
				if(no86 == null) {
					break;
				}
				var v86;
				switch(no86) {
				case 32:
					v86 = false;
					break;
				case 42:
					v86 = true;
					break;
				case 48:
					v86 = false;
					break;
				case 49:
					v86 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i87)));
				}
				switch(i87 - (l86 - 8)) {
				case 0:
					if(v86) {
						bs86 |= 128;
					} else {
						bs86 &= -129;
					}
					break;
				case 1:
					if(v86) {
						bs86 |= 64;
					} else {
						bs86 &= -65;
					}
					break;
				case 2:
					if(v86) {
						bs86 |= 32;
					} else {
						bs86 &= -33;
					}
					break;
				case 3:
					if(v86) {
						bs86 |= 16;
					} else {
						bs86 &= -17;
					}
					break;
				case 4:
					if(v86) {
						bs86 |= 8;
					} else {
						bs86 &= -9;
					}
					break;
				case 5:
					if(v86) {
						bs86 |= 4;
					} else {
						bs86 &= -5;
					}
					break;
				case 6:
					if(v86) {
						bs86 |= 2;
					} else {
						bs86 &= -3;
					}
					break;
				case 7:
					if(v86) {
						bs86 |= 1;
					} else {
						bs86 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs86;
			var this88 = 0;
			var bs87 = this88;
			var l87 = "     ".length;
			var _g188 = 0;
			var _g98 = l87;
			while(_g188 < _g98) {
				var i88 = _g188++;
				var no87 = "     ".charCodeAt(i88);
				if(no87 == null) {
					break;
				}
				var v87;
				switch(no87) {
				case 32:
					v87 = false;
					break;
				case 42:
					v87 = true;
					break;
				case 48:
					v87 = false;
					break;
				case 49:
					v87 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i88)));
				}
				switch(i88 - (l87 - 8)) {
				case 0:
					if(v87) {
						bs87 |= 128;
					} else {
						bs87 &= -129;
					}
					break;
				case 1:
					if(v87) {
						bs87 |= 64;
					} else {
						bs87 &= -65;
					}
					break;
				case 2:
					if(v87) {
						bs87 |= 32;
					} else {
						bs87 &= -33;
					}
					break;
				case 3:
					if(v87) {
						bs87 |= 16;
					} else {
						bs87 &= -17;
					}
					break;
				case 4:
					if(v87) {
						bs87 |= 8;
					} else {
						bs87 &= -9;
					}
					break;
				case 5:
					if(v87) {
						bs87 |= 4;
					} else {
						bs87 &= -5;
					}
					break;
				case 6:
					if(v87) {
						bs87 |= 2;
					} else {
						bs87 &= -3;
					}
					break;
				case 7:
					if(v87) {
						bs87 |= 1;
					} else {
						bs87 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs87;
			var this89 = 0;
			var bs88 = this89;
			var l88 = " **  ".length;
			var _g189 = 0;
			var _g99 = l88;
			while(_g189 < _g99) {
				var i89 = _g189++;
				var no88 = " **  ".charCodeAt(i89);
				if(no88 == null) {
					break;
				}
				var v88;
				switch(no88) {
				case 32:
					v88 = false;
					break;
				case 42:
					v88 = true;
					break;
				case 48:
					v88 = false;
					break;
				case 49:
					v88 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i89)));
				}
				switch(i89 - (l88 - 8)) {
				case 0:
					if(v88) {
						bs88 |= 128;
					} else {
						bs88 &= -129;
					}
					break;
				case 1:
					if(v88) {
						bs88 |= 64;
					} else {
						bs88 &= -65;
					}
					break;
				case 2:
					if(v88) {
						bs88 |= 32;
					} else {
						bs88 &= -33;
					}
					break;
				case 3:
					if(v88) {
						bs88 |= 16;
					} else {
						bs88 &= -17;
					}
					break;
				case 4:
					if(v88) {
						bs88 |= 8;
					} else {
						bs88 &= -9;
					}
					break;
				case 5:
					if(v88) {
						bs88 |= 4;
					} else {
						bs88 &= -5;
					}
					break;
				case 6:
					if(v88) {
						bs88 |= 2;
					} else {
						bs88 &= -3;
					}
					break;
				case 7:
					if(v88) {
						bs88 |= 1;
					} else {
						bs88 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs88;
			var this90 = 0;
			var bs89 = this90;
			var l89 = "  *  ".length;
			var _g190 = 0;
			var _g100 = l89;
			while(_g190 < _g100) {
				var i90 = _g190++;
				var no89 = "  *  ".charCodeAt(i90);
				if(no89 == null) {
					break;
				}
				var v89;
				switch(no89) {
				case 32:
					v89 = false;
					break;
				case 42:
					v89 = true;
					break;
				case 48:
					v89 = false;
					break;
				case 49:
					v89 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i90)));
				}
				switch(i90 - (l89 - 8)) {
				case 0:
					if(v89) {
						bs89 |= 128;
					} else {
						bs89 &= -129;
					}
					break;
				case 1:
					if(v89) {
						bs89 |= 64;
					} else {
						bs89 &= -65;
					}
					break;
				case 2:
					if(v89) {
						bs89 |= 32;
					} else {
						bs89 &= -33;
					}
					break;
				case 3:
					if(v89) {
						bs89 |= 16;
					} else {
						bs89 &= -17;
					}
					break;
				case 4:
					if(v89) {
						bs89 |= 8;
					} else {
						bs89 &= -9;
					}
					break;
				case 5:
					if(v89) {
						bs89 |= 4;
					} else {
						bs89 &= -5;
					}
					break;
				case 6:
					if(v89) {
						bs89 |= 2;
					} else {
						bs89 &= -3;
					}
					break;
				case 7:
					if(v89) {
						bs89 |= 1;
					} else {
						bs89 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs89;
			var this91 = 0;
			var bs90 = this91;
			var l90 = " *   ".length;
			var _g191 = 0;
			var _g101 = l90;
			while(_g191 < _g101) {
				var i91 = _g191++;
				var no90 = " *   ".charCodeAt(i91);
				if(no90 == null) {
					break;
				}
				var v90;
				switch(no90) {
				case 32:
					v90 = false;
					break;
				case 42:
					v90 = true;
					break;
				case 48:
					v90 = false;
					break;
				case 49:
					v90 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i91)));
				}
				switch(i91 - (l90 - 8)) {
				case 0:
					if(v90) {
						bs90 |= 128;
					} else {
						bs90 &= -129;
					}
					break;
				case 1:
					if(v90) {
						bs90 |= 64;
					} else {
						bs90 &= -65;
					}
					break;
				case 2:
					if(v90) {
						bs90 |= 32;
					} else {
						bs90 &= -33;
					}
					break;
				case 3:
					if(v90) {
						bs90 |= 16;
					} else {
						bs90 &= -17;
					}
					break;
				case 4:
					if(v90) {
						bs90 |= 8;
					} else {
						bs90 &= -9;
					}
					break;
				case 5:
					if(v90) {
						bs90 |= 4;
					} else {
						bs90 &= -5;
					}
					break;
				case 6:
					if(v90) {
						bs90 |= 2;
					} else {
						bs90 &= -3;
					}
					break;
				case 7:
					if(v90) {
						bs90 |= 1;
					} else {
						bs90 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs90;
			break;
		case 45:
			var this92 = 0;
			var bs91 = this92;
			var l91 = "     ".length;
			var _g192 = 0;
			var _g102 = l91;
			while(_g192 < _g102) {
				var i92 = _g192++;
				var no91 = "     ".charCodeAt(i92);
				if(no91 == null) {
					break;
				}
				var v91;
				switch(no91) {
				case 32:
					v91 = false;
					break;
				case 42:
					v91 = true;
					break;
				case 48:
					v91 = false;
					break;
				case 49:
					v91 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i92)));
				}
				switch(i92 - (l91 - 8)) {
				case 0:
					if(v91) {
						bs91 |= 128;
					} else {
						bs91 &= -129;
					}
					break;
				case 1:
					if(v91) {
						bs91 |= 64;
					} else {
						bs91 &= -65;
					}
					break;
				case 2:
					if(v91) {
						bs91 |= 32;
					} else {
						bs91 &= -33;
					}
					break;
				case 3:
					if(v91) {
						bs91 |= 16;
					} else {
						bs91 &= -17;
					}
					break;
				case 4:
					if(v91) {
						bs91 |= 8;
					} else {
						bs91 &= -9;
					}
					break;
				case 5:
					if(v91) {
						bs91 |= 4;
					} else {
						bs91 &= -5;
					}
					break;
				case 6:
					if(v91) {
						bs91 |= 2;
					} else {
						bs91 &= -3;
					}
					break;
				case 7:
					if(v91) {
						bs91 |= 1;
					} else {
						bs91 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs91;
			var this93 = 0;
			var bs92 = this93;
			var l92 = "     ".length;
			var _g193 = 0;
			var _g103 = l92;
			while(_g193 < _g103) {
				var i93 = _g193++;
				var no92 = "     ".charCodeAt(i93);
				if(no92 == null) {
					break;
				}
				var v92;
				switch(no92) {
				case 32:
					v92 = false;
					break;
				case 42:
					v92 = true;
					break;
				case 48:
					v92 = false;
					break;
				case 49:
					v92 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i93)));
				}
				switch(i93 - (l92 - 8)) {
				case 0:
					if(v92) {
						bs92 |= 128;
					} else {
						bs92 &= -129;
					}
					break;
				case 1:
					if(v92) {
						bs92 |= 64;
					} else {
						bs92 &= -65;
					}
					break;
				case 2:
					if(v92) {
						bs92 |= 32;
					} else {
						bs92 &= -33;
					}
					break;
				case 3:
					if(v92) {
						bs92 |= 16;
					} else {
						bs92 &= -17;
					}
					break;
				case 4:
					if(v92) {
						bs92 |= 8;
					} else {
						bs92 &= -9;
					}
					break;
				case 5:
					if(v92) {
						bs92 |= 4;
					} else {
						bs92 &= -5;
					}
					break;
				case 6:
					if(v92) {
						bs92 |= 2;
					} else {
						bs92 &= -3;
					}
					break;
				case 7:
					if(v92) {
						bs92 |= 1;
					} else {
						bs92 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs92;
			var this94 = 0;
			var bs93 = this94;
			var l93 = "     ".length;
			var _g194 = 0;
			var _g104 = l93;
			while(_g194 < _g104) {
				var i94 = _g194++;
				var no93 = "     ".charCodeAt(i94);
				if(no93 == null) {
					break;
				}
				var v93;
				switch(no93) {
				case 32:
					v93 = false;
					break;
				case 42:
					v93 = true;
					break;
				case 48:
					v93 = false;
					break;
				case 49:
					v93 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i94)));
				}
				switch(i94 - (l93 - 8)) {
				case 0:
					if(v93) {
						bs93 |= 128;
					} else {
						bs93 &= -129;
					}
					break;
				case 1:
					if(v93) {
						bs93 |= 64;
					} else {
						bs93 &= -65;
					}
					break;
				case 2:
					if(v93) {
						bs93 |= 32;
					} else {
						bs93 &= -33;
					}
					break;
				case 3:
					if(v93) {
						bs93 |= 16;
					} else {
						bs93 &= -17;
					}
					break;
				case 4:
					if(v93) {
						bs93 |= 8;
					} else {
						bs93 &= -9;
					}
					break;
				case 5:
					if(v93) {
						bs93 |= 4;
					} else {
						bs93 &= -5;
					}
					break;
				case 6:
					if(v93) {
						bs93 |= 2;
					} else {
						bs93 &= -3;
					}
					break;
				case 7:
					if(v93) {
						bs93 |= 1;
					} else {
						bs93 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs93;
			var this95 = 0;
			var bs94 = this95;
			var l94 = "*****".length;
			var _g195 = 0;
			var _g105 = l94;
			while(_g195 < _g105) {
				var i95 = _g195++;
				var no94 = "*****".charCodeAt(i95);
				if(no94 == null) {
					break;
				}
				var v94;
				switch(no94) {
				case 32:
					v94 = false;
					break;
				case 42:
					v94 = true;
					break;
				case 48:
					v94 = false;
					break;
				case 49:
					v94 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i95)));
				}
				switch(i95 - (l94 - 8)) {
				case 0:
					if(v94) {
						bs94 |= 128;
					} else {
						bs94 &= -129;
					}
					break;
				case 1:
					if(v94) {
						bs94 |= 64;
					} else {
						bs94 &= -65;
					}
					break;
				case 2:
					if(v94) {
						bs94 |= 32;
					} else {
						bs94 &= -33;
					}
					break;
				case 3:
					if(v94) {
						bs94 |= 16;
					} else {
						bs94 &= -17;
					}
					break;
				case 4:
					if(v94) {
						bs94 |= 8;
					} else {
						bs94 &= -9;
					}
					break;
				case 5:
					if(v94) {
						bs94 |= 4;
					} else {
						bs94 &= -5;
					}
					break;
				case 6:
					if(v94) {
						bs94 |= 2;
					} else {
						bs94 &= -3;
					}
					break;
				case 7:
					if(v94) {
						bs94 |= 1;
					} else {
						bs94 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs94;
			var this96 = 0;
			var bs95 = this96;
			var l95 = "     ".length;
			var _g196 = 0;
			var _g106 = l95;
			while(_g196 < _g106) {
				var i96 = _g196++;
				var no95 = "     ".charCodeAt(i96);
				if(no95 == null) {
					break;
				}
				var v95;
				switch(no95) {
				case 32:
					v95 = false;
					break;
				case 42:
					v95 = true;
					break;
				case 48:
					v95 = false;
					break;
				case 49:
					v95 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i96)));
				}
				switch(i96 - (l95 - 8)) {
				case 0:
					if(v95) {
						bs95 |= 128;
					} else {
						bs95 &= -129;
					}
					break;
				case 1:
					if(v95) {
						bs95 |= 64;
					} else {
						bs95 &= -65;
					}
					break;
				case 2:
					if(v95) {
						bs95 |= 32;
					} else {
						bs95 &= -33;
					}
					break;
				case 3:
					if(v95) {
						bs95 |= 16;
					} else {
						bs95 &= -17;
					}
					break;
				case 4:
					if(v95) {
						bs95 |= 8;
					} else {
						bs95 &= -9;
					}
					break;
				case 5:
					if(v95) {
						bs95 |= 4;
					} else {
						bs95 &= -5;
					}
					break;
				case 6:
					if(v95) {
						bs95 |= 2;
					} else {
						bs95 &= -3;
					}
					break;
				case 7:
					if(v95) {
						bs95 |= 1;
					} else {
						bs95 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs95;
			var this97 = 0;
			var bs96 = this97;
			var l96 = "     ".length;
			var _g197 = 0;
			var _g107 = l96;
			while(_g197 < _g107) {
				var i97 = _g197++;
				var no96 = "     ".charCodeAt(i97);
				if(no96 == null) {
					break;
				}
				var v96;
				switch(no96) {
				case 32:
					v96 = false;
					break;
				case 42:
					v96 = true;
					break;
				case 48:
					v96 = false;
					break;
				case 49:
					v96 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i97)));
				}
				switch(i97 - (l96 - 8)) {
				case 0:
					if(v96) {
						bs96 |= 128;
					} else {
						bs96 &= -129;
					}
					break;
				case 1:
					if(v96) {
						bs96 |= 64;
					} else {
						bs96 &= -65;
					}
					break;
				case 2:
					if(v96) {
						bs96 |= 32;
					} else {
						bs96 &= -33;
					}
					break;
				case 3:
					if(v96) {
						bs96 |= 16;
					} else {
						bs96 &= -17;
					}
					break;
				case 4:
					if(v96) {
						bs96 |= 8;
					} else {
						bs96 &= -9;
					}
					break;
				case 5:
					if(v96) {
						bs96 |= 4;
					} else {
						bs96 &= -5;
					}
					break;
				case 6:
					if(v96) {
						bs96 |= 2;
					} else {
						bs96 &= -3;
					}
					break;
				case 7:
					if(v96) {
						bs96 |= 1;
					} else {
						bs96 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs96;
			var this98 = 0;
			var bs97 = this98;
			var l97 = "     ".length;
			var _g198 = 0;
			var _g108 = l97;
			while(_g198 < _g108) {
				var i98 = _g198++;
				var no97 = "     ".charCodeAt(i98);
				if(no97 == null) {
					break;
				}
				var v97;
				switch(no97) {
				case 32:
					v97 = false;
					break;
				case 42:
					v97 = true;
					break;
				case 48:
					v97 = false;
					break;
				case 49:
					v97 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i98)));
				}
				switch(i98 - (l97 - 8)) {
				case 0:
					if(v97) {
						bs97 |= 128;
					} else {
						bs97 &= -129;
					}
					break;
				case 1:
					if(v97) {
						bs97 |= 64;
					} else {
						bs97 &= -65;
					}
					break;
				case 2:
					if(v97) {
						bs97 |= 32;
					} else {
						bs97 &= -33;
					}
					break;
				case 3:
					if(v97) {
						bs97 |= 16;
					} else {
						bs97 &= -17;
					}
					break;
				case 4:
					if(v97) {
						bs97 |= 8;
					} else {
						bs97 &= -9;
					}
					break;
				case 5:
					if(v97) {
						bs97 |= 4;
					} else {
						bs97 &= -5;
					}
					break;
				case 6:
					if(v97) {
						bs97 |= 2;
					} else {
						bs97 &= -3;
					}
					break;
				case 7:
					if(v97) {
						bs97 |= 1;
					} else {
						bs97 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs97;
			break;
		case 46:
			var this99 = 0;
			var bs98 = this99;
			var l98 = "     ".length;
			var _g199 = 0;
			var _g109 = l98;
			while(_g199 < _g109) {
				var i99 = _g199++;
				var no98 = "     ".charCodeAt(i99);
				if(no98 == null) {
					break;
				}
				var v98;
				switch(no98) {
				case 32:
					v98 = false;
					break;
				case 42:
					v98 = true;
					break;
				case 48:
					v98 = false;
					break;
				case 49:
					v98 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i99)));
				}
				switch(i99 - (l98 - 8)) {
				case 0:
					if(v98) {
						bs98 |= 128;
					} else {
						bs98 &= -129;
					}
					break;
				case 1:
					if(v98) {
						bs98 |= 64;
					} else {
						bs98 &= -65;
					}
					break;
				case 2:
					if(v98) {
						bs98 |= 32;
					} else {
						bs98 &= -33;
					}
					break;
				case 3:
					if(v98) {
						bs98 |= 16;
					} else {
						bs98 &= -17;
					}
					break;
				case 4:
					if(v98) {
						bs98 |= 8;
					} else {
						bs98 &= -9;
					}
					break;
				case 5:
					if(v98) {
						bs98 |= 4;
					} else {
						bs98 &= -5;
					}
					break;
				case 6:
					if(v98) {
						bs98 |= 2;
					} else {
						bs98 &= -3;
					}
					break;
				case 7:
					if(v98) {
						bs98 |= 1;
					} else {
						bs98 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs98;
			var this100 = 0;
			var bs99 = this100;
			var l99 = "     ".length;
			var _g1100 = 0;
			var _g200 = l99;
			while(_g1100 < _g200) {
				var i100 = _g1100++;
				var no99 = "     ".charCodeAt(i100);
				if(no99 == null) {
					break;
				}
				var v99;
				switch(no99) {
				case 32:
					v99 = false;
					break;
				case 42:
					v99 = true;
					break;
				case 48:
					v99 = false;
					break;
				case 49:
					v99 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i100)));
				}
				switch(i100 - (l99 - 8)) {
				case 0:
					if(v99) {
						bs99 |= 128;
					} else {
						bs99 &= -129;
					}
					break;
				case 1:
					if(v99) {
						bs99 |= 64;
					} else {
						bs99 &= -65;
					}
					break;
				case 2:
					if(v99) {
						bs99 |= 32;
					} else {
						bs99 &= -33;
					}
					break;
				case 3:
					if(v99) {
						bs99 |= 16;
					} else {
						bs99 &= -17;
					}
					break;
				case 4:
					if(v99) {
						bs99 |= 8;
					} else {
						bs99 &= -9;
					}
					break;
				case 5:
					if(v99) {
						bs99 |= 4;
					} else {
						bs99 &= -5;
					}
					break;
				case 6:
					if(v99) {
						bs99 |= 2;
					} else {
						bs99 &= -3;
					}
					break;
				case 7:
					if(v99) {
						bs99 |= 1;
					} else {
						bs99 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs99;
			var this101 = 0;
			var bs100 = this101;
			var l100 = "     ".length;
			var _g1101 = 0;
			var _g201 = l100;
			while(_g1101 < _g201) {
				var i101 = _g1101++;
				var no100 = "     ".charCodeAt(i101);
				if(no100 == null) {
					break;
				}
				var v100;
				switch(no100) {
				case 32:
					v100 = false;
					break;
				case 42:
					v100 = true;
					break;
				case 48:
					v100 = false;
					break;
				case 49:
					v100 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i101)));
				}
				switch(i101 - (l100 - 8)) {
				case 0:
					if(v100) {
						bs100 |= 128;
					} else {
						bs100 &= -129;
					}
					break;
				case 1:
					if(v100) {
						bs100 |= 64;
					} else {
						bs100 &= -65;
					}
					break;
				case 2:
					if(v100) {
						bs100 |= 32;
					} else {
						bs100 &= -33;
					}
					break;
				case 3:
					if(v100) {
						bs100 |= 16;
					} else {
						bs100 &= -17;
					}
					break;
				case 4:
					if(v100) {
						bs100 |= 8;
					} else {
						bs100 &= -9;
					}
					break;
				case 5:
					if(v100) {
						bs100 |= 4;
					} else {
						bs100 &= -5;
					}
					break;
				case 6:
					if(v100) {
						bs100 |= 2;
					} else {
						bs100 &= -3;
					}
					break;
				case 7:
					if(v100) {
						bs100 |= 1;
					} else {
						bs100 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs100;
			var this102 = 0;
			var bs101 = this102;
			var l101 = "     ".length;
			var _g1102 = 0;
			var _g202 = l101;
			while(_g1102 < _g202) {
				var i102 = _g1102++;
				var no101 = "     ".charCodeAt(i102);
				if(no101 == null) {
					break;
				}
				var v101;
				switch(no101) {
				case 32:
					v101 = false;
					break;
				case 42:
					v101 = true;
					break;
				case 48:
					v101 = false;
					break;
				case 49:
					v101 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i102)));
				}
				switch(i102 - (l101 - 8)) {
				case 0:
					if(v101) {
						bs101 |= 128;
					} else {
						bs101 &= -129;
					}
					break;
				case 1:
					if(v101) {
						bs101 |= 64;
					} else {
						bs101 &= -65;
					}
					break;
				case 2:
					if(v101) {
						bs101 |= 32;
					} else {
						bs101 &= -33;
					}
					break;
				case 3:
					if(v101) {
						bs101 |= 16;
					} else {
						bs101 &= -17;
					}
					break;
				case 4:
					if(v101) {
						bs101 |= 8;
					} else {
						bs101 &= -9;
					}
					break;
				case 5:
					if(v101) {
						bs101 |= 4;
					} else {
						bs101 &= -5;
					}
					break;
				case 6:
					if(v101) {
						bs101 |= 2;
					} else {
						bs101 &= -3;
					}
					break;
				case 7:
					if(v101) {
						bs101 |= 1;
					} else {
						bs101 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs101;
			var this103 = 0;
			var bs102 = this103;
			var l102 = "     ".length;
			var _g1103 = 0;
			var _g203 = l102;
			while(_g1103 < _g203) {
				var i103 = _g1103++;
				var no102 = "     ".charCodeAt(i103);
				if(no102 == null) {
					break;
				}
				var v102;
				switch(no102) {
				case 32:
					v102 = false;
					break;
				case 42:
					v102 = true;
					break;
				case 48:
					v102 = false;
					break;
				case 49:
					v102 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i103)));
				}
				switch(i103 - (l102 - 8)) {
				case 0:
					if(v102) {
						bs102 |= 128;
					} else {
						bs102 &= -129;
					}
					break;
				case 1:
					if(v102) {
						bs102 |= 64;
					} else {
						bs102 &= -65;
					}
					break;
				case 2:
					if(v102) {
						bs102 |= 32;
					} else {
						bs102 &= -33;
					}
					break;
				case 3:
					if(v102) {
						bs102 |= 16;
					} else {
						bs102 &= -17;
					}
					break;
				case 4:
					if(v102) {
						bs102 |= 8;
					} else {
						bs102 &= -9;
					}
					break;
				case 5:
					if(v102) {
						bs102 |= 4;
					} else {
						bs102 &= -5;
					}
					break;
				case 6:
					if(v102) {
						bs102 |= 2;
					} else {
						bs102 &= -3;
					}
					break;
				case 7:
					if(v102) {
						bs102 |= 1;
					} else {
						bs102 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs102;
			var this104 = 0;
			var bs103 = this104;
			var l103 = "  ** ".length;
			var _g1104 = 0;
			var _g204 = l103;
			while(_g1104 < _g204) {
				var i104 = _g1104++;
				var no103 = "  ** ".charCodeAt(i104);
				if(no103 == null) {
					break;
				}
				var v103;
				switch(no103) {
				case 32:
					v103 = false;
					break;
				case 42:
					v103 = true;
					break;
				case 48:
					v103 = false;
					break;
				case 49:
					v103 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i104)));
				}
				switch(i104 - (l103 - 8)) {
				case 0:
					if(v103) {
						bs103 |= 128;
					} else {
						bs103 &= -129;
					}
					break;
				case 1:
					if(v103) {
						bs103 |= 64;
					} else {
						bs103 &= -65;
					}
					break;
				case 2:
					if(v103) {
						bs103 |= 32;
					} else {
						bs103 &= -33;
					}
					break;
				case 3:
					if(v103) {
						bs103 |= 16;
					} else {
						bs103 &= -17;
					}
					break;
				case 4:
					if(v103) {
						bs103 |= 8;
					} else {
						bs103 &= -9;
					}
					break;
				case 5:
					if(v103) {
						bs103 |= 4;
					} else {
						bs103 &= -5;
					}
					break;
				case 6:
					if(v103) {
						bs103 |= 2;
					} else {
						bs103 &= -3;
					}
					break;
				case 7:
					if(v103) {
						bs103 |= 1;
					} else {
						bs103 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs103;
			var this105 = 0;
			var bs104 = this105;
			var l104 = "  ** ".length;
			var _g1105 = 0;
			var _g205 = l104;
			while(_g1105 < _g205) {
				var i105 = _g1105++;
				var no104 = "  ** ".charCodeAt(i105);
				if(no104 == null) {
					break;
				}
				var v104;
				switch(no104) {
				case 32:
					v104 = false;
					break;
				case 42:
					v104 = true;
					break;
				case 48:
					v104 = false;
					break;
				case 49:
					v104 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i105)));
				}
				switch(i105 - (l104 - 8)) {
				case 0:
					if(v104) {
						bs104 |= 128;
					} else {
						bs104 &= -129;
					}
					break;
				case 1:
					if(v104) {
						bs104 |= 64;
					} else {
						bs104 &= -65;
					}
					break;
				case 2:
					if(v104) {
						bs104 |= 32;
					} else {
						bs104 &= -33;
					}
					break;
				case 3:
					if(v104) {
						bs104 |= 16;
					} else {
						bs104 &= -17;
					}
					break;
				case 4:
					if(v104) {
						bs104 |= 8;
					} else {
						bs104 &= -9;
					}
					break;
				case 5:
					if(v104) {
						bs104 |= 4;
					} else {
						bs104 &= -5;
					}
					break;
				case 6:
					if(v104) {
						bs104 |= 2;
					} else {
						bs104 &= -3;
					}
					break;
				case 7:
					if(v104) {
						bs104 |= 1;
					} else {
						bs104 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs104;
			break;
		case 47:
			var this106 = 0;
			var bs105 = this106;
			var l105 = "    *".length;
			var _g1106 = 0;
			var _g206 = l105;
			while(_g1106 < _g206) {
				var i106 = _g1106++;
				var no105 = "    *".charCodeAt(i106);
				if(no105 == null) {
					break;
				}
				var v105;
				switch(no105) {
				case 32:
					v105 = false;
					break;
				case 42:
					v105 = true;
					break;
				case 48:
					v105 = false;
					break;
				case 49:
					v105 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i106)));
				}
				switch(i106 - (l105 - 8)) {
				case 0:
					if(v105) {
						bs105 |= 128;
					} else {
						bs105 &= -129;
					}
					break;
				case 1:
					if(v105) {
						bs105 |= 64;
					} else {
						bs105 &= -65;
					}
					break;
				case 2:
					if(v105) {
						bs105 |= 32;
					} else {
						bs105 &= -33;
					}
					break;
				case 3:
					if(v105) {
						bs105 |= 16;
					} else {
						bs105 &= -17;
					}
					break;
				case 4:
					if(v105) {
						bs105 |= 8;
					} else {
						bs105 &= -9;
					}
					break;
				case 5:
					if(v105) {
						bs105 |= 4;
					} else {
						bs105 &= -5;
					}
					break;
				case 6:
					if(v105) {
						bs105 |= 2;
					} else {
						bs105 &= -3;
					}
					break;
				case 7:
					if(v105) {
						bs105 |= 1;
					} else {
						bs105 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs105;
			var this107 = 0;
			var bs106 = this107;
			var l106 = "   * ".length;
			var _g1107 = 0;
			var _g207 = l106;
			while(_g1107 < _g207) {
				var i107 = _g1107++;
				var no106 = "   * ".charCodeAt(i107);
				if(no106 == null) {
					break;
				}
				var v106;
				switch(no106) {
				case 32:
					v106 = false;
					break;
				case 42:
					v106 = true;
					break;
				case 48:
					v106 = false;
					break;
				case 49:
					v106 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i107)));
				}
				switch(i107 - (l106 - 8)) {
				case 0:
					if(v106) {
						bs106 |= 128;
					} else {
						bs106 &= -129;
					}
					break;
				case 1:
					if(v106) {
						bs106 |= 64;
					} else {
						bs106 &= -65;
					}
					break;
				case 2:
					if(v106) {
						bs106 |= 32;
					} else {
						bs106 &= -33;
					}
					break;
				case 3:
					if(v106) {
						bs106 |= 16;
					} else {
						bs106 &= -17;
					}
					break;
				case 4:
					if(v106) {
						bs106 |= 8;
					} else {
						bs106 &= -9;
					}
					break;
				case 5:
					if(v106) {
						bs106 |= 4;
					} else {
						bs106 &= -5;
					}
					break;
				case 6:
					if(v106) {
						bs106 |= 2;
					} else {
						bs106 &= -3;
					}
					break;
				case 7:
					if(v106) {
						bs106 |= 1;
					} else {
						bs106 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs106;
			var this108 = 0;
			var bs107 = this108;
			var l107 = "   * ".length;
			var _g1108 = 0;
			var _g208 = l107;
			while(_g1108 < _g208) {
				var i108 = _g1108++;
				var no107 = "   * ".charCodeAt(i108);
				if(no107 == null) {
					break;
				}
				var v107;
				switch(no107) {
				case 32:
					v107 = false;
					break;
				case 42:
					v107 = true;
					break;
				case 48:
					v107 = false;
					break;
				case 49:
					v107 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i108)));
				}
				switch(i108 - (l107 - 8)) {
				case 0:
					if(v107) {
						bs107 |= 128;
					} else {
						bs107 &= -129;
					}
					break;
				case 1:
					if(v107) {
						bs107 |= 64;
					} else {
						bs107 &= -65;
					}
					break;
				case 2:
					if(v107) {
						bs107 |= 32;
					} else {
						bs107 &= -33;
					}
					break;
				case 3:
					if(v107) {
						bs107 |= 16;
					} else {
						bs107 &= -17;
					}
					break;
				case 4:
					if(v107) {
						bs107 |= 8;
					} else {
						bs107 &= -9;
					}
					break;
				case 5:
					if(v107) {
						bs107 |= 4;
					} else {
						bs107 &= -5;
					}
					break;
				case 6:
					if(v107) {
						bs107 |= 2;
					} else {
						bs107 &= -3;
					}
					break;
				case 7:
					if(v107) {
						bs107 |= 1;
					} else {
						bs107 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs107;
			var this109 = 0;
			var bs108 = this109;
			var l108 = "  *  ".length;
			var _g1109 = 0;
			var _g209 = l108;
			while(_g1109 < _g209) {
				var i109 = _g1109++;
				var no108 = "  *  ".charCodeAt(i109);
				if(no108 == null) {
					break;
				}
				var v108;
				switch(no108) {
				case 32:
					v108 = false;
					break;
				case 42:
					v108 = true;
					break;
				case 48:
					v108 = false;
					break;
				case 49:
					v108 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i109)));
				}
				switch(i109 - (l108 - 8)) {
				case 0:
					if(v108) {
						bs108 |= 128;
					} else {
						bs108 &= -129;
					}
					break;
				case 1:
					if(v108) {
						bs108 |= 64;
					} else {
						bs108 &= -65;
					}
					break;
				case 2:
					if(v108) {
						bs108 |= 32;
					} else {
						bs108 &= -33;
					}
					break;
				case 3:
					if(v108) {
						bs108 |= 16;
					} else {
						bs108 &= -17;
					}
					break;
				case 4:
					if(v108) {
						bs108 |= 8;
					} else {
						bs108 &= -9;
					}
					break;
				case 5:
					if(v108) {
						bs108 |= 4;
					} else {
						bs108 &= -5;
					}
					break;
				case 6:
					if(v108) {
						bs108 |= 2;
					} else {
						bs108 &= -3;
					}
					break;
				case 7:
					if(v108) {
						bs108 |= 1;
					} else {
						bs108 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs108;
			var this110 = 0;
			var bs109 = this110;
			var l109 = "  *  ".length;
			var _g1110 = 0;
			var _g210 = l109;
			while(_g1110 < _g210) {
				var i110 = _g1110++;
				var no109 = "  *  ".charCodeAt(i110);
				if(no109 == null) {
					break;
				}
				var v109;
				switch(no109) {
				case 32:
					v109 = false;
					break;
				case 42:
					v109 = true;
					break;
				case 48:
					v109 = false;
					break;
				case 49:
					v109 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i110)));
				}
				switch(i110 - (l109 - 8)) {
				case 0:
					if(v109) {
						bs109 |= 128;
					} else {
						bs109 &= -129;
					}
					break;
				case 1:
					if(v109) {
						bs109 |= 64;
					} else {
						bs109 &= -65;
					}
					break;
				case 2:
					if(v109) {
						bs109 |= 32;
					} else {
						bs109 &= -33;
					}
					break;
				case 3:
					if(v109) {
						bs109 |= 16;
					} else {
						bs109 &= -17;
					}
					break;
				case 4:
					if(v109) {
						bs109 |= 8;
					} else {
						bs109 &= -9;
					}
					break;
				case 5:
					if(v109) {
						bs109 |= 4;
					} else {
						bs109 &= -5;
					}
					break;
				case 6:
					if(v109) {
						bs109 |= 2;
					} else {
						bs109 &= -3;
					}
					break;
				case 7:
					if(v109) {
						bs109 |= 1;
					} else {
						bs109 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs109;
			var this111 = 0;
			var bs110 = this111;
			var l110 = " *   ".length;
			var _g1111 = 0;
			var _g211 = l110;
			while(_g1111 < _g211) {
				var i111 = _g1111++;
				var no110 = " *   ".charCodeAt(i111);
				if(no110 == null) {
					break;
				}
				var v110;
				switch(no110) {
				case 32:
					v110 = false;
					break;
				case 42:
					v110 = true;
					break;
				case 48:
					v110 = false;
					break;
				case 49:
					v110 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i111)));
				}
				switch(i111 - (l110 - 8)) {
				case 0:
					if(v110) {
						bs110 |= 128;
					} else {
						bs110 &= -129;
					}
					break;
				case 1:
					if(v110) {
						bs110 |= 64;
					} else {
						bs110 &= -65;
					}
					break;
				case 2:
					if(v110) {
						bs110 |= 32;
					} else {
						bs110 &= -33;
					}
					break;
				case 3:
					if(v110) {
						bs110 |= 16;
					} else {
						bs110 &= -17;
					}
					break;
				case 4:
					if(v110) {
						bs110 |= 8;
					} else {
						bs110 &= -9;
					}
					break;
				case 5:
					if(v110) {
						bs110 |= 4;
					} else {
						bs110 &= -5;
					}
					break;
				case 6:
					if(v110) {
						bs110 |= 2;
					} else {
						bs110 &= -3;
					}
					break;
				case 7:
					if(v110) {
						bs110 |= 1;
					} else {
						bs110 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs110;
			var this112 = 0;
			var bs111 = this112;
			var l111 = "*    ".length;
			var _g1112 = 0;
			var _g212 = l111;
			while(_g1112 < _g212) {
				var i112 = _g1112++;
				var no111 = "*    ".charCodeAt(i112);
				if(no111 == null) {
					break;
				}
				var v111;
				switch(no111) {
				case 32:
					v111 = false;
					break;
				case 42:
					v111 = true;
					break;
				case 48:
					v111 = false;
					break;
				case 49:
					v111 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i112)));
				}
				switch(i112 - (l111 - 8)) {
				case 0:
					if(v111) {
						bs111 |= 128;
					} else {
						bs111 &= -129;
					}
					break;
				case 1:
					if(v111) {
						bs111 |= 64;
					} else {
						bs111 &= -65;
					}
					break;
				case 2:
					if(v111) {
						bs111 |= 32;
					} else {
						bs111 &= -33;
					}
					break;
				case 3:
					if(v111) {
						bs111 |= 16;
					} else {
						bs111 &= -17;
					}
					break;
				case 4:
					if(v111) {
						bs111 |= 8;
					} else {
						bs111 &= -9;
					}
					break;
				case 5:
					if(v111) {
						bs111 |= 4;
					} else {
						bs111 &= -5;
					}
					break;
				case 6:
					if(v111) {
						bs111 |= 2;
					} else {
						bs111 &= -3;
					}
					break;
				case 7:
					if(v111) {
						bs111 |= 1;
					} else {
						bs111 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs111;
			break;
		case 48:
			var this113 = 0;
			var bs112 = this113;
			var l112 = " *** ".length;
			var _g1113 = 0;
			var _g213 = l112;
			while(_g1113 < _g213) {
				var i113 = _g1113++;
				var no112 = " *** ".charCodeAt(i113);
				if(no112 == null) {
					break;
				}
				var v112;
				switch(no112) {
				case 32:
					v112 = false;
					break;
				case 42:
					v112 = true;
					break;
				case 48:
					v112 = false;
					break;
				case 49:
					v112 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i113)));
				}
				switch(i113 - (l112 - 8)) {
				case 0:
					if(v112) {
						bs112 |= 128;
					} else {
						bs112 &= -129;
					}
					break;
				case 1:
					if(v112) {
						bs112 |= 64;
					} else {
						bs112 &= -65;
					}
					break;
				case 2:
					if(v112) {
						bs112 |= 32;
					} else {
						bs112 &= -33;
					}
					break;
				case 3:
					if(v112) {
						bs112 |= 16;
					} else {
						bs112 &= -17;
					}
					break;
				case 4:
					if(v112) {
						bs112 |= 8;
					} else {
						bs112 &= -9;
					}
					break;
				case 5:
					if(v112) {
						bs112 |= 4;
					} else {
						bs112 &= -5;
					}
					break;
				case 6:
					if(v112) {
						bs112 |= 2;
					} else {
						bs112 &= -3;
					}
					break;
				case 7:
					if(v112) {
						bs112 |= 1;
					} else {
						bs112 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs112;
			var this114 = 0;
			var bs113 = this114;
			var l113 = "*   *".length;
			var _g1114 = 0;
			var _g214 = l113;
			while(_g1114 < _g214) {
				var i114 = _g1114++;
				var no113 = "*   *".charCodeAt(i114);
				if(no113 == null) {
					break;
				}
				var v113;
				switch(no113) {
				case 32:
					v113 = false;
					break;
				case 42:
					v113 = true;
					break;
				case 48:
					v113 = false;
					break;
				case 49:
					v113 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i114)));
				}
				switch(i114 - (l113 - 8)) {
				case 0:
					if(v113) {
						bs113 |= 128;
					} else {
						bs113 &= -129;
					}
					break;
				case 1:
					if(v113) {
						bs113 |= 64;
					} else {
						bs113 &= -65;
					}
					break;
				case 2:
					if(v113) {
						bs113 |= 32;
					} else {
						bs113 &= -33;
					}
					break;
				case 3:
					if(v113) {
						bs113 |= 16;
					} else {
						bs113 &= -17;
					}
					break;
				case 4:
					if(v113) {
						bs113 |= 8;
					} else {
						bs113 &= -9;
					}
					break;
				case 5:
					if(v113) {
						bs113 |= 4;
					} else {
						bs113 &= -5;
					}
					break;
				case 6:
					if(v113) {
						bs113 |= 2;
					} else {
						bs113 &= -3;
					}
					break;
				case 7:
					if(v113) {
						bs113 |= 1;
					} else {
						bs113 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs113;
			var this115 = 0;
			var bs114 = this115;
			var l114 = "*  **".length;
			var _g1115 = 0;
			var _g215 = l114;
			while(_g1115 < _g215) {
				var i115 = _g1115++;
				var no114 = "*  **".charCodeAt(i115);
				if(no114 == null) {
					break;
				}
				var v114;
				switch(no114) {
				case 32:
					v114 = false;
					break;
				case 42:
					v114 = true;
					break;
				case 48:
					v114 = false;
					break;
				case 49:
					v114 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  **".charCodeAt(i115)));
				}
				switch(i115 - (l114 - 8)) {
				case 0:
					if(v114) {
						bs114 |= 128;
					} else {
						bs114 &= -129;
					}
					break;
				case 1:
					if(v114) {
						bs114 |= 64;
					} else {
						bs114 &= -65;
					}
					break;
				case 2:
					if(v114) {
						bs114 |= 32;
					} else {
						bs114 &= -33;
					}
					break;
				case 3:
					if(v114) {
						bs114 |= 16;
					} else {
						bs114 &= -17;
					}
					break;
				case 4:
					if(v114) {
						bs114 |= 8;
					} else {
						bs114 &= -9;
					}
					break;
				case 5:
					if(v114) {
						bs114 |= 4;
					} else {
						bs114 &= -5;
					}
					break;
				case 6:
					if(v114) {
						bs114 |= 2;
					} else {
						bs114 &= -3;
					}
					break;
				case 7:
					if(v114) {
						bs114 |= 1;
					} else {
						bs114 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs114;
			var this116 = 0;
			var bs115 = this116;
			var l115 = "* * *".length;
			var _g1116 = 0;
			var _g216 = l115;
			while(_g1116 < _g216) {
				var i116 = _g1116++;
				var no115 = "* * *".charCodeAt(i116);
				if(no115 == null) {
					break;
				}
				var v115;
				switch(no115) {
				case 32:
					v115 = false;
					break;
				case 42:
					v115 = true;
					break;
				case 48:
					v115 = false;
					break;
				case 49:
					v115 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i116)));
				}
				switch(i116 - (l115 - 8)) {
				case 0:
					if(v115) {
						bs115 |= 128;
					} else {
						bs115 &= -129;
					}
					break;
				case 1:
					if(v115) {
						bs115 |= 64;
					} else {
						bs115 &= -65;
					}
					break;
				case 2:
					if(v115) {
						bs115 |= 32;
					} else {
						bs115 &= -33;
					}
					break;
				case 3:
					if(v115) {
						bs115 |= 16;
					} else {
						bs115 &= -17;
					}
					break;
				case 4:
					if(v115) {
						bs115 |= 8;
					} else {
						bs115 &= -9;
					}
					break;
				case 5:
					if(v115) {
						bs115 |= 4;
					} else {
						bs115 &= -5;
					}
					break;
				case 6:
					if(v115) {
						bs115 |= 2;
					} else {
						bs115 &= -3;
					}
					break;
				case 7:
					if(v115) {
						bs115 |= 1;
					} else {
						bs115 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs115;
			var this117 = 0;
			var bs116 = this117;
			var l116 = "**  *".length;
			var _g1117 = 0;
			var _g217 = l116;
			while(_g1117 < _g217) {
				var i117 = _g1117++;
				var no116 = "**  *".charCodeAt(i117);
				if(no116 == null) {
					break;
				}
				var v116;
				switch(no116) {
				case 32:
					v116 = false;
					break;
				case 42:
					v116 = true;
					break;
				case 48:
					v116 = false;
					break;
				case 49:
					v116 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i117)));
				}
				switch(i117 - (l116 - 8)) {
				case 0:
					if(v116) {
						bs116 |= 128;
					} else {
						bs116 &= -129;
					}
					break;
				case 1:
					if(v116) {
						bs116 |= 64;
					} else {
						bs116 &= -65;
					}
					break;
				case 2:
					if(v116) {
						bs116 |= 32;
					} else {
						bs116 &= -33;
					}
					break;
				case 3:
					if(v116) {
						bs116 |= 16;
					} else {
						bs116 &= -17;
					}
					break;
				case 4:
					if(v116) {
						bs116 |= 8;
					} else {
						bs116 &= -9;
					}
					break;
				case 5:
					if(v116) {
						bs116 |= 4;
					} else {
						bs116 &= -5;
					}
					break;
				case 6:
					if(v116) {
						bs116 |= 2;
					} else {
						bs116 &= -3;
					}
					break;
				case 7:
					if(v116) {
						bs116 |= 1;
					} else {
						bs116 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs116;
			var this118 = 0;
			var bs117 = this118;
			var l117 = "*   *".length;
			var _g1118 = 0;
			var _g218 = l117;
			while(_g1118 < _g218) {
				var i118 = _g1118++;
				var no117 = "*   *".charCodeAt(i118);
				if(no117 == null) {
					break;
				}
				var v117;
				switch(no117) {
				case 32:
					v117 = false;
					break;
				case 42:
					v117 = true;
					break;
				case 48:
					v117 = false;
					break;
				case 49:
					v117 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i118)));
				}
				switch(i118 - (l117 - 8)) {
				case 0:
					if(v117) {
						bs117 |= 128;
					} else {
						bs117 &= -129;
					}
					break;
				case 1:
					if(v117) {
						bs117 |= 64;
					} else {
						bs117 &= -65;
					}
					break;
				case 2:
					if(v117) {
						bs117 |= 32;
					} else {
						bs117 &= -33;
					}
					break;
				case 3:
					if(v117) {
						bs117 |= 16;
					} else {
						bs117 &= -17;
					}
					break;
				case 4:
					if(v117) {
						bs117 |= 8;
					} else {
						bs117 &= -9;
					}
					break;
				case 5:
					if(v117) {
						bs117 |= 4;
					} else {
						bs117 &= -5;
					}
					break;
				case 6:
					if(v117) {
						bs117 |= 2;
					} else {
						bs117 &= -3;
					}
					break;
				case 7:
					if(v117) {
						bs117 |= 1;
					} else {
						bs117 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs117;
			var this119 = 0;
			var bs118 = this119;
			var l118 = " *** ".length;
			var _g1119 = 0;
			var _g219 = l118;
			while(_g1119 < _g219) {
				var i119 = _g1119++;
				var no118 = " *** ".charCodeAt(i119);
				if(no118 == null) {
					break;
				}
				var v118;
				switch(no118) {
				case 32:
					v118 = false;
					break;
				case 42:
					v118 = true;
					break;
				case 48:
					v118 = false;
					break;
				case 49:
					v118 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i119)));
				}
				switch(i119 - (l118 - 8)) {
				case 0:
					if(v118) {
						bs118 |= 128;
					} else {
						bs118 &= -129;
					}
					break;
				case 1:
					if(v118) {
						bs118 |= 64;
					} else {
						bs118 &= -65;
					}
					break;
				case 2:
					if(v118) {
						bs118 |= 32;
					} else {
						bs118 &= -33;
					}
					break;
				case 3:
					if(v118) {
						bs118 |= 16;
					} else {
						bs118 &= -17;
					}
					break;
				case 4:
					if(v118) {
						bs118 |= 8;
					} else {
						bs118 &= -9;
					}
					break;
				case 5:
					if(v118) {
						bs118 |= 4;
					} else {
						bs118 &= -5;
					}
					break;
				case 6:
					if(v118) {
						bs118 |= 2;
					} else {
						bs118 &= -3;
					}
					break;
				case 7:
					if(v118) {
						bs118 |= 1;
					} else {
						bs118 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs118;
			break;
		case 49:
			var this120 = 0;
			var bs119 = this120;
			var l119 = "  *  ".length;
			var _g1120 = 0;
			var _g220 = l119;
			while(_g1120 < _g220) {
				var i120 = _g1120++;
				var no119 = "  *  ".charCodeAt(i120);
				if(no119 == null) {
					break;
				}
				var v119;
				switch(no119) {
				case 32:
					v119 = false;
					break;
				case 42:
					v119 = true;
					break;
				case 48:
					v119 = false;
					break;
				case 49:
					v119 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i120)));
				}
				switch(i120 - (l119 - 8)) {
				case 0:
					if(v119) {
						bs119 |= 128;
					} else {
						bs119 &= -129;
					}
					break;
				case 1:
					if(v119) {
						bs119 |= 64;
					} else {
						bs119 &= -65;
					}
					break;
				case 2:
					if(v119) {
						bs119 |= 32;
					} else {
						bs119 &= -33;
					}
					break;
				case 3:
					if(v119) {
						bs119 |= 16;
					} else {
						bs119 &= -17;
					}
					break;
				case 4:
					if(v119) {
						bs119 |= 8;
					} else {
						bs119 &= -9;
					}
					break;
				case 5:
					if(v119) {
						bs119 |= 4;
					} else {
						bs119 &= -5;
					}
					break;
				case 6:
					if(v119) {
						bs119 |= 2;
					} else {
						bs119 &= -3;
					}
					break;
				case 7:
					if(v119) {
						bs119 |= 1;
					} else {
						bs119 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs119;
			var this121 = 0;
			var bs120 = this121;
			var l120 = " **  ".length;
			var _g1121 = 0;
			var _g221 = l120;
			while(_g1121 < _g221) {
				var i121 = _g1121++;
				var no120 = " **  ".charCodeAt(i121);
				if(no120 == null) {
					break;
				}
				var v120;
				switch(no120) {
				case 32:
					v120 = false;
					break;
				case 42:
					v120 = true;
					break;
				case 48:
					v120 = false;
					break;
				case 49:
					v120 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i121)));
				}
				switch(i121 - (l120 - 8)) {
				case 0:
					if(v120) {
						bs120 |= 128;
					} else {
						bs120 &= -129;
					}
					break;
				case 1:
					if(v120) {
						bs120 |= 64;
					} else {
						bs120 &= -65;
					}
					break;
				case 2:
					if(v120) {
						bs120 |= 32;
					} else {
						bs120 &= -33;
					}
					break;
				case 3:
					if(v120) {
						bs120 |= 16;
					} else {
						bs120 &= -17;
					}
					break;
				case 4:
					if(v120) {
						bs120 |= 8;
					} else {
						bs120 &= -9;
					}
					break;
				case 5:
					if(v120) {
						bs120 |= 4;
					} else {
						bs120 &= -5;
					}
					break;
				case 6:
					if(v120) {
						bs120 |= 2;
					} else {
						bs120 &= -3;
					}
					break;
				case 7:
					if(v120) {
						bs120 |= 1;
					} else {
						bs120 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs120;
			var this122 = 0;
			var bs121 = this122;
			var l121 = "  *  ".length;
			var _g1122 = 0;
			var _g222 = l121;
			while(_g1122 < _g222) {
				var i122 = _g1122++;
				var no121 = "  *  ".charCodeAt(i122);
				if(no121 == null) {
					break;
				}
				var v121;
				switch(no121) {
				case 32:
					v121 = false;
					break;
				case 42:
					v121 = true;
					break;
				case 48:
					v121 = false;
					break;
				case 49:
					v121 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i122)));
				}
				switch(i122 - (l121 - 8)) {
				case 0:
					if(v121) {
						bs121 |= 128;
					} else {
						bs121 &= -129;
					}
					break;
				case 1:
					if(v121) {
						bs121 |= 64;
					} else {
						bs121 &= -65;
					}
					break;
				case 2:
					if(v121) {
						bs121 |= 32;
					} else {
						bs121 &= -33;
					}
					break;
				case 3:
					if(v121) {
						bs121 |= 16;
					} else {
						bs121 &= -17;
					}
					break;
				case 4:
					if(v121) {
						bs121 |= 8;
					} else {
						bs121 &= -9;
					}
					break;
				case 5:
					if(v121) {
						bs121 |= 4;
					} else {
						bs121 &= -5;
					}
					break;
				case 6:
					if(v121) {
						bs121 |= 2;
					} else {
						bs121 &= -3;
					}
					break;
				case 7:
					if(v121) {
						bs121 |= 1;
					} else {
						bs121 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs121;
			var this123 = 0;
			var bs122 = this123;
			var l122 = "  *  ".length;
			var _g1123 = 0;
			var _g223 = l122;
			while(_g1123 < _g223) {
				var i123 = _g1123++;
				var no122 = "  *  ".charCodeAt(i123);
				if(no122 == null) {
					break;
				}
				var v122;
				switch(no122) {
				case 32:
					v122 = false;
					break;
				case 42:
					v122 = true;
					break;
				case 48:
					v122 = false;
					break;
				case 49:
					v122 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i123)));
				}
				switch(i123 - (l122 - 8)) {
				case 0:
					if(v122) {
						bs122 |= 128;
					} else {
						bs122 &= -129;
					}
					break;
				case 1:
					if(v122) {
						bs122 |= 64;
					} else {
						bs122 &= -65;
					}
					break;
				case 2:
					if(v122) {
						bs122 |= 32;
					} else {
						bs122 &= -33;
					}
					break;
				case 3:
					if(v122) {
						bs122 |= 16;
					} else {
						bs122 &= -17;
					}
					break;
				case 4:
					if(v122) {
						bs122 |= 8;
					} else {
						bs122 &= -9;
					}
					break;
				case 5:
					if(v122) {
						bs122 |= 4;
					} else {
						bs122 &= -5;
					}
					break;
				case 6:
					if(v122) {
						bs122 |= 2;
					} else {
						bs122 &= -3;
					}
					break;
				case 7:
					if(v122) {
						bs122 |= 1;
					} else {
						bs122 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs122;
			var this124 = 0;
			var bs123 = this124;
			var l123 = "  *  ".length;
			var _g1124 = 0;
			var _g224 = l123;
			while(_g1124 < _g224) {
				var i124 = _g1124++;
				var no123 = "  *  ".charCodeAt(i124);
				if(no123 == null) {
					break;
				}
				var v123;
				switch(no123) {
				case 32:
					v123 = false;
					break;
				case 42:
					v123 = true;
					break;
				case 48:
					v123 = false;
					break;
				case 49:
					v123 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i124)));
				}
				switch(i124 - (l123 - 8)) {
				case 0:
					if(v123) {
						bs123 |= 128;
					} else {
						bs123 &= -129;
					}
					break;
				case 1:
					if(v123) {
						bs123 |= 64;
					} else {
						bs123 &= -65;
					}
					break;
				case 2:
					if(v123) {
						bs123 |= 32;
					} else {
						bs123 &= -33;
					}
					break;
				case 3:
					if(v123) {
						bs123 |= 16;
					} else {
						bs123 &= -17;
					}
					break;
				case 4:
					if(v123) {
						bs123 |= 8;
					} else {
						bs123 &= -9;
					}
					break;
				case 5:
					if(v123) {
						bs123 |= 4;
					} else {
						bs123 &= -5;
					}
					break;
				case 6:
					if(v123) {
						bs123 |= 2;
					} else {
						bs123 &= -3;
					}
					break;
				case 7:
					if(v123) {
						bs123 |= 1;
					} else {
						bs123 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs123;
			var this125 = 0;
			var bs124 = this125;
			var l124 = "  *  ".length;
			var _g1125 = 0;
			var _g225 = l124;
			while(_g1125 < _g225) {
				var i125 = _g1125++;
				var no124 = "  *  ".charCodeAt(i125);
				if(no124 == null) {
					break;
				}
				var v124;
				switch(no124) {
				case 32:
					v124 = false;
					break;
				case 42:
					v124 = true;
					break;
				case 48:
					v124 = false;
					break;
				case 49:
					v124 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i125)));
				}
				switch(i125 - (l124 - 8)) {
				case 0:
					if(v124) {
						bs124 |= 128;
					} else {
						bs124 &= -129;
					}
					break;
				case 1:
					if(v124) {
						bs124 |= 64;
					} else {
						bs124 &= -65;
					}
					break;
				case 2:
					if(v124) {
						bs124 |= 32;
					} else {
						bs124 &= -33;
					}
					break;
				case 3:
					if(v124) {
						bs124 |= 16;
					} else {
						bs124 &= -17;
					}
					break;
				case 4:
					if(v124) {
						bs124 |= 8;
					} else {
						bs124 &= -9;
					}
					break;
				case 5:
					if(v124) {
						bs124 |= 4;
					} else {
						bs124 &= -5;
					}
					break;
				case 6:
					if(v124) {
						bs124 |= 2;
					} else {
						bs124 &= -3;
					}
					break;
				case 7:
					if(v124) {
						bs124 |= 1;
					} else {
						bs124 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs124;
			var this126 = 0;
			var bs125 = this126;
			var l125 = " *** ".length;
			var _g1126 = 0;
			var _g226 = l125;
			while(_g1126 < _g226) {
				var i126 = _g1126++;
				var no125 = " *** ".charCodeAt(i126);
				if(no125 == null) {
					break;
				}
				var v125;
				switch(no125) {
				case 32:
					v125 = false;
					break;
				case 42:
					v125 = true;
					break;
				case 48:
					v125 = false;
					break;
				case 49:
					v125 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i126)));
				}
				switch(i126 - (l125 - 8)) {
				case 0:
					if(v125) {
						bs125 |= 128;
					} else {
						bs125 &= -129;
					}
					break;
				case 1:
					if(v125) {
						bs125 |= 64;
					} else {
						bs125 &= -65;
					}
					break;
				case 2:
					if(v125) {
						bs125 |= 32;
					} else {
						bs125 &= -33;
					}
					break;
				case 3:
					if(v125) {
						bs125 |= 16;
					} else {
						bs125 &= -17;
					}
					break;
				case 4:
					if(v125) {
						bs125 |= 8;
					} else {
						bs125 &= -9;
					}
					break;
				case 5:
					if(v125) {
						bs125 |= 4;
					} else {
						bs125 &= -5;
					}
					break;
				case 6:
					if(v125) {
						bs125 |= 2;
					} else {
						bs125 &= -3;
					}
					break;
				case 7:
					if(v125) {
						bs125 |= 1;
					} else {
						bs125 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs125;
			break;
		case 50:
			var this127 = 0;
			var bs126 = this127;
			var l126 = " *** ".length;
			var _g1127 = 0;
			var _g227 = l126;
			while(_g1127 < _g227) {
				var i127 = _g1127++;
				var no126 = " *** ".charCodeAt(i127);
				if(no126 == null) {
					break;
				}
				var v126;
				switch(no126) {
				case 32:
					v126 = false;
					break;
				case 42:
					v126 = true;
					break;
				case 48:
					v126 = false;
					break;
				case 49:
					v126 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i127)));
				}
				switch(i127 - (l126 - 8)) {
				case 0:
					if(v126) {
						bs126 |= 128;
					} else {
						bs126 &= -129;
					}
					break;
				case 1:
					if(v126) {
						bs126 |= 64;
					} else {
						bs126 &= -65;
					}
					break;
				case 2:
					if(v126) {
						bs126 |= 32;
					} else {
						bs126 &= -33;
					}
					break;
				case 3:
					if(v126) {
						bs126 |= 16;
					} else {
						bs126 &= -17;
					}
					break;
				case 4:
					if(v126) {
						bs126 |= 8;
					} else {
						bs126 &= -9;
					}
					break;
				case 5:
					if(v126) {
						bs126 |= 4;
					} else {
						bs126 &= -5;
					}
					break;
				case 6:
					if(v126) {
						bs126 |= 2;
					} else {
						bs126 &= -3;
					}
					break;
				case 7:
					if(v126) {
						bs126 |= 1;
					} else {
						bs126 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs126;
			var this128 = 0;
			var bs127 = this128;
			var l127 = "*   *".length;
			var _g1128 = 0;
			var _g228 = l127;
			while(_g1128 < _g228) {
				var i128 = _g1128++;
				var no127 = "*   *".charCodeAt(i128);
				if(no127 == null) {
					break;
				}
				var v127;
				switch(no127) {
				case 32:
					v127 = false;
					break;
				case 42:
					v127 = true;
					break;
				case 48:
					v127 = false;
					break;
				case 49:
					v127 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i128)));
				}
				switch(i128 - (l127 - 8)) {
				case 0:
					if(v127) {
						bs127 |= 128;
					} else {
						bs127 &= -129;
					}
					break;
				case 1:
					if(v127) {
						bs127 |= 64;
					} else {
						bs127 &= -65;
					}
					break;
				case 2:
					if(v127) {
						bs127 |= 32;
					} else {
						bs127 &= -33;
					}
					break;
				case 3:
					if(v127) {
						bs127 |= 16;
					} else {
						bs127 &= -17;
					}
					break;
				case 4:
					if(v127) {
						bs127 |= 8;
					} else {
						bs127 &= -9;
					}
					break;
				case 5:
					if(v127) {
						bs127 |= 4;
					} else {
						bs127 &= -5;
					}
					break;
				case 6:
					if(v127) {
						bs127 |= 2;
					} else {
						bs127 &= -3;
					}
					break;
				case 7:
					if(v127) {
						bs127 |= 1;
					} else {
						bs127 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs127;
			var this129 = 0;
			var bs128 = this129;
			var l128 = "    *".length;
			var _g1129 = 0;
			var _g229 = l128;
			while(_g1129 < _g229) {
				var i129 = _g1129++;
				var no128 = "    *".charCodeAt(i129);
				if(no128 == null) {
					break;
				}
				var v128;
				switch(no128) {
				case 32:
					v128 = false;
					break;
				case 42:
					v128 = true;
					break;
				case 48:
					v128 = false;
					break;
				case 49:
					v128 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i129)));
				}
				switch(i129 - (l128 - 8)) {
				case 0:
					if(v128) {
						bs128 |= 128;
					} else {
						bs128 &= -129;
					}
					break;
				case 1:
					if(v128) {
						bs128 |= 64;
					} else {
						bs128 &= -65;
					}
					break;
				case 2:
					if(v128) {
						bs128 |= 32;
					} else {
						bs128 &= -33;
					}
					break;
				case 3:
					if(v128) {
						bs128 |= 16;
					} else {
						bs128 &= -17;
					}
					break;
				case 4:
					if(v128) {
						bs128 |= 8;
					} else {
						bs128 &= -9;
					}
					break;
				case 5:
					if(v128) {
						bs128 |= 4;
					} else {
						bs128 &= -5;
					}
					break;
				case 6:
					if(v128) {
						bs128 |= 2;
					} else {
						bs128 &= -3;
					}
					break;
				case 7:
					if(v128) {
						bs128 |= 1;
					} else {
						bs128 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs128;
			var this130 = 0;
			var bs129 = this130;
			var l129 = "  *  ".length;
			var _g1130 = 0;
			var _g230 = l129;
			while(_g1130 < _g230) {
				var i130 = _g1130++;
				var no129 = "  *  ".charCodeAt(i130);
				if(no129 == null) {
					break;
				}
				var v129;
				switch(no129) {
				case 32:
					v129 = false;
					break;
				case 42:
					v129 = true;
					break;
				case 48:
					v129 = false;
					break;
				case 49:
					v129 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i130)));
				}
				switch(i130 - (l129 - 8)) {
				case 0:
					if(v129) {
						bs129 |= 128;
					} else {
						bs129 &= -129;
					}
					break;
				case 1:
					if(v129) {
						bs129 |= 64;
					} else {
						bs129 &= -65;
					}
					break;
				case 2:
					if(v129) {
						bs129 |= 32;
					} else {
						bs129 &= -33;
					}
					break;
				case 3:
					if(v129) {
						bs129 |= 16;
					} else {
						bs129 &= -17;
					}
					break;
				case 4:
					if(v129) {
						bs129 |= 8;
					} else {
						bs129 &= -9;
					}
					break;
				case 5:
					if(v129) {
						bs129 |= 4;
					} else {
						bs129 &= -5;
					}
					break;
				case 6:
					if(v129) {
						bs129 |= 2;
					} else {
						bs129 &= -3;
					}
					break;
				case 7:
					if(v129) {
						bs129 |= 1;
					} else {
						bs129 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs129;
			var this131 = 0;
			var bs130 = this131;
			var l130 = " *   ".length;
			var _g1131 = 0;
			var _g231 = l130;
			while(_g1131 < _g231) {
				var i131 = _g1131++;
				var no130 = " *   ".charCodeAt(i131);
				if(no130 == null) {
					break;
				}
				var v130;
				switch(no130) {
				case 32:
					v130 = false;
					break;
				case 42:
					v130 = true;
					break;
				case 48:
					v130 = false;
					break;
				case 49:
					v130 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i131)));
				}
				switch(i131 - (l130 - 8)) {
				case 0:
					if(v130) {
						bs130 |= 128;
					} else {
						bs130 &= -129;
					}
					break;
				case 1:
					if(v130) {
						bs130 |= 64;
					} else {
						bs130 &= -65;
					}
					break;
				case 2:
					if(v130) {
						bs130 |= 32;
					} else {
						bs130 &= -33;
					}
					break;
				case 3:
					if(v130) {
						bs130 |= 16;
					} else {
						bs130 &= -17;
					}
					break;
				case 4:
					if(v130) {
						bs130 |= 8;
					} else {
						bs130 &= -9;
					}
					break;
				case 5:
					if(v130) {
						bs130 |= 4;
					} else {
						bs130 &= -5;
					}
					break;
				case 6:
					if(v130) {
						bs130 |= 2;
					} else {
						bs130 &= -3;
					}
					break;
				case 7:
					if(v130) {
						bs130 |= 1;
					} else {
						bs130 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs130;
			var this132 = 0;
			var bs131 = this132;
			var l131 = "*    ".length;
			var _g1132 = 0;
			var _g232 = l131;
			while(_g1132 < _g232) {
				var i132 = _g1132++;
				var no131 = "*    ".charCodeAt(i132);
				if(no131 == null) {
					break;
				}
				var v131;
				switch(no131) {
				case 32:
					v131 = false;
					break;
				case 42:
					v131 = true;
					break;
				case 48:
					v131 = false;
					break;
				case 49:
					v131 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i132)));
				}
				switch(i132 - (l131 - 8)) {
				case 0:
					if(v131) {
						bs131 |= 128;
					} else {
						bs131 &= -129;
					}
					break;
				case 1:
					if(v131) {
						bs131 |= 64;
					} else {
						bs131 &= -65;
					}
					break;
				case 2:
					if(v131) {
						bs131 |= 32;
					} else {
						bs131 &= -33;
					}
					break;
				case 3:
					if(v131) {
						bs131 |= 16;
					} else {
						bs131 &= -17;
					}
					break;
				case 4:
					if(v131) {
						bs131 |= 8;
					} else {
						bs131 &= -9;
					}
					break;
				case 5:
					if(v131) {
						bs131 |= 4;
					} else {
						bs131 &= -5;
					}
					break;
				case 6:
					if(v131) {
						bs131 |= 2;
					} else {
						bs131 &= -3;
					}
					break;
				case 7:
					if(v131) {
						bs131 |= 1;
					} else {
						bs131 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs131;
			var this133 = 0;
			var bs132 = this133;
			var l132 = "*****".length;
			var _g1133 = 0;
			var _g233 = l132;
			while(_g1133 < _g233) {
				var i133 = _g1133++;
				var no132 = "*****".charCodeAt(i133);
				if(no132 == null) {
					break;
				}
				var v132;
				switch(no132) {
				case 32:
					v132 = false;
					break;
				case 42:
					v132 = true;
					break;
				case 48:
					v132 = false;
					break;
				case 49:
					v132 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i133)));
				}
				switch(i133 - (l132 - 8)) {
				case 0:
					if(v132) {
						bs132 |= 128;
					} else {
						bs132 &= -129;
					}
					break;
				case 1:
					if(v132) {
						bs132 |= 64;
					} else {
						bs132 &= -65;
					}
					break;
				case 2:
					if(v132) {
						bs132 |= 32;
					} else {
						bs132 &= -33;
					}
					break;
				case 3:
					if(v132) {
						bs132 |= 16;
					} else {
						bs132 &= -17;
					}
					break;
				case 4:
					if(v132) {
						bs132 |= 8;
					} else {
						bs132 &= -9;
					}
					break;
				case 5:
					if(v132) {
						bs132 |= 4;
					} else {
						bs132 &= -5;
					}
					break;
				case 6:
					if(v132) {
						bs132 |= 2;
					} else {
						bs132 &= -3;
					}
					break;
				case 7:
					if(v132) {
						bs132 |= 1;
					} else {
						bs132 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs132;
			break;
		case 51:
			var this134 = 0;
			var bs133 = this134;
			var l133 = "*****".length;
			var _g1134 = 0;
			var _g234 = l133;
			while(_g1134 < _g234) {
				var i134 = _g1134++;
				var no133 = "*****".charCodeAt(i134);
				if(no133 == null) {
					break;
				}
				var v133;
				switch(no133) {
				case 32:
					v133 = false;
					break;
				case 42:
					v133 = true;
					break;
				case 48:
					v133 = false;
					break;
				case 49:
					v133 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i134)));
				}
				switch(i134 - (l133 - 8)) {
				case 0:
					if(v133) {
						bs133 |= 128;
					} else {
						bs133 &= -129;
					}
					break;
				case 1:
					if(v133) {
						bs133 |= 64;
					} else {
						bs133 &= -65;
					}
					break;
				case 2:
					if(v133) {
						bs133 |= 32;
					} else {
						bs133 &= -33;
					}
					break;
				case 3:
					if(v133) {
						bs133 |= 16;
					} else {
						bs133 &= -17;
					}
					break;
				case 4:
					if(v133) {
						bs133 |= 8;
					} else {
						bs133 &= -9;
					}
					break;
				case 5:
					if(v133) {
						bs133 |= 4;
					} else {
						bs133 &= -5;
					}
					break;
				case 6:
					if(v133) {
						bs133 |= 2;
					} else {
						bs133 &= -3;
					}
					break;
				case 7:
					if(v133) {
						bs133 |= 1;
					} else {
						bs133 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs133;
			var this135 = 0;
			var bs134 = this135;
			var l134 = "   * ".length;
			var _g1135 = 0;
			var _g235 = l134;
			while(_g1135 < _g235) {
				var i135 = _g1135++;
				var no134 = "   * ".charCodeAt(i135);
				if(no134 == null) {
					break;
				}
				var v134;
				switch(no134) {
				case 32:
					v134 = false;
					break;
				case 42:
					v134 = true;
					break;
				case 48:
					v134 = false;
					break;
				case 49:
					v134 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i135)));
				}
				switch(i135 - (l134 - 8)) {
				case 0:
					if(v134) {
						bs134 |= 128;
					} else {
						bs134 &= -129;
					}
					break;
				case 1:
					if(v134) {
						bs134 |= 64;
					} else {
						bs134 &= -65;
					}
					break;
				case 2:
					if(v134) {
						bs134 |= 32;
					} else {
						bs134 &= -33;
					}
					break;
				case 3:
					if(v134) {
						bs134 |= 16;
					} else {
						bs134 &= -17;
					}
					break;
				case 4:
					if(v134) {
						bs134 |= 8;
					} else {
						bs134 &= -9;
					}
					break;
				case 5:
					if(v134) {
						bs134 |= 4;
					} else {
						bs134 &= -5;
					}
					break;
				case 6:
					if(v134) {
						bs134 |= 2;
					} else {
						bs134 &= -3;
					}
					break;
				case 7:
					if(v134) {
						bs134 |= 1;
					} else {
						bs134 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs134;
			var this136 = 0;
			var bs135 = this136;
			var l135 = "  *  ".length;
			var _g1136 = 0;
			var _g236 = l135;
			while(_g1136 < _g236) {
				var i136 = _g1136++;
				var no135 = "  *  ".charCodeAt(i136);
				if(no135 == null) {
					break;
				}
				var v135;
				switch(no135) {
				case 32:
					v135 = false;
					break;
				case 42:
					v135 = true;
					break;
				case 48:
					v135 = false;
					break;
				case 49:
					v135 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i136)));
				}
				switch(i136 - (l135 - 8)) {
				case 0:
					if(v135) {
						bs135 |= 128;
					} else {
						bs135 &= -129;
					}
					break;
				case 1:
					if(v135) {
						bs135 |= 64;
					} else {
						bs135 &= -65;
					}
					break;
				case 2:
					if(v135) {
						bs135 |= 32;
					} else {
						bs135 &= -33;
					}
					break;
				case 3:
					if(v135) {
						bs135 |= 16;
					} else {
						bs135 &= -17;
					}
					break;
				case 4:
					if(v135) {
						bs135 |= 8;
					} else {
						bs135 &= -9;
					}
					break;
				case 5:
					if(v135) {
						bs135 |= 4;
					} else {
						bs135 &= -5;
					}
					break;
				case 6:
					if(v135) {
						bs135 |= 2;
					} else {
						bs135 &= -3;
					}
					break;
				case 7:
					if(v135) {
						bs135 |= 1;
					} else {
						bs135 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs135;
			var this137 = 0;
			var bs136 = this137;
			var l136 = "   * ".length;
			var _g1137 = 0;
			var _g237 = l136;
			while(_g1137 < _g237) {
				var i137 = _g1137++;
				var no136 = "   * ".charCodeAt(i137);
				if(no136 == null) {
					break;
				}
				var v136;
				switch(no136) {
				case 32:
					v136 = false;
					break;
				case 42:
					v136 = true;
					break;
				case 48:
					v136 = false;
					break;
				case 49:
					v136 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i137)));
				}
				switch(i137 - (l136 - 8)) {
				case 0:
					if(v136) {
						bs136 |= 128;
					} else {
						bs136 &= -129;
					}
					break;
				case 1:
					if(v136) {
						bs136 |= 64;
					} else {
						bs136 &= -65;
					}
					break;
				case 2:
					if(v136) {
						bs136 |= 32;
					} else {
						bs136 &= -33;
					}
					break;
				case 3:
					if(v136) {
						bs136 |= 16;
					} else {
						bs136 &= -17;
					}
					break;
				case 4:
					if(v136) {
						bs136 |= 8;
					} else {
						bs136 &= -9;
					}
					break;
				case 5:
					if(v136) {
						bs136 |= 4;
					} else {
						bs136 &= -5;
					}
					break;
				case 6:
					if(v136) {
						bs136 |= 2;
					} else {
						bs136 &= -3;
					}
					break;
				case 7:
					if(v136) {
						bs136 |= 1;
					} else {
						bs136 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs136;
			var this138 = 0;
			var bs137 = this138;
			var l137 = "    *".length;
			var _g1138 = 0;
			var _g238 = l137;
			while(_g1138 < _g238) {
				var i138 = _g1138++;
				var no137 = "    *".charCodeAt(i138);
				if(no137 == null) {
					break;
				}
				var v137;
				switch(no137) {
				case 32:
					v137 = false;
					break;
				case 42:
					v137 = true;
					break;
				case 48:
					v137 = false;
					break;
				case 49:
					v137 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i138)));
				}
				switch(i138 - (l137 - 8)) {
				case 0:
					if(v137) {
						bs137 |= 128;
					} else {
						bs137 &= -129;
					}
					break;
				case 1:
					if(v137) {
						bs137 |= 64;
					} else {
						bs137 &= -65;
					}
					break;
				case 2:
					if(v137) {
						bs137 |= 32;
					} else {
						bs137 &= -33;
					}
					break;
				case 3:
					if(v137) {
						bs137 |= 16;
					} else {
						bs137 &= -17;
					}
					break;
				case 4:
					if(v137) {
						bs137 |= 8;
					} else {
						bs137 &= -9;
					}
					break;
				case 5:
					if(v137) {
						bs137 |= 4;
					} else {
						bs137 &= -5;
					}
					break;
				case 6:
					if(v137) {
						bs137 |= 2;
					} else {
						bs137 &= -3;
					}
					break;
				case 7:
					if(v137) {
						bs137 |= 1;
					} else {
						bs137 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs137;
			var this139 = 0;
			var bs138 = this139;
			var l138 = "*   *".length;
			var _g1139 = 0;
			var _g239 = l138;
			while(_g1139 < _g239) {
				var i139 = _g1139++;
				var no138 = "*   *".charCodeAt(i139);
				if(no138 == null) {
					break;
				}
				var v138;
				switch(no138) {
				case 32:
					v138 = false;
					break;
				case 42:
					v138 = true;
					break;
				case 48:
					v138 = false;
					break;
				case 49:
					v138 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i139)));
				}
				switch(i139 - (l138 - 8)) {
				case 0:
					if(v138) {
						bs138 |= 128;
					} else {
						bs138 &= -129;
					}
					break;
				case 1:
					if(v138) {
						bs138 |= 64;
					} else {
						bs138 &= -65;
					}
					break;
				case 2:
					if(v138) {
						bs138 |= 32;
					} else {
						bs138 &= -33;
					}
					break;
				case 3:
					if(v138) {
						bs138 |= 16;
					} else {
						bs138 &= -17;
					}
					break;
				case 4:
					if(v138) {
						bs138 |= 8;
					} else {
						bs138 &= -9;
					}
					break;
				case 5:
					if(v138) {
						bs138 |= 4;
					} else {
						bs138 &= -5;
					}
					break;
				case 6:
					if(v138) {
						bs138 |= 2;
					} else {
						bs138 &= -3;
					}
					break;
				case 7:
					if(v138) {
						bs138 |= 1;
					} else {
						bs138 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs138;
			var this140 = 0;
			var bs139 = this140;
			var l139 = " *** ".length;
			var _g1140 = 0;
			var _g240 = l139;
			while(_g1140 < _g240) {
				var i140 = _g1140++;
				var no139 = " *** ".charCodeAt(i140);
				if(no139 == null) {
					break;
				}
				var v139;
				switch(no139) {
				case 32:
					v139 = false;
					break;
				case 42:
					v139 = true;
					break;
				case 48:
					v139 = false;
					break;
				case 49:
					v139 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i140)));
				}
				switch(i140 - (l139 - 8)) {
				case 0:
					if(v139) {
						bs139 |= 128;
					} else {
						bs139 &= -129;
					}
					break;
				case 1:
					if(v139) {
						bs139 |= 64;
					} else {
						bs139 &= -65;
					}
					break;
				case 2:
					if(v139) {
						bs139 |= 32;
					} else {
						bs139 &= -33;
					}
					break;
				case 3:
					if(v139) {
						bs139 |= 16;
					} else {
						bs139 &= -17;
					}
					break;
				case 4:
					if(v139) {
						bs139 |= 8;
					} else {
						bs139 &= -9;
					}
					break;
				case 5:
					if(v139) {
						bs139 |= 4;
					} else {
						bs139 &= -5;
					}
					break;
				case 6:
					if(v139) {
						bs139 |= 2;
					} else {
						bs139 &= -3;
					}
					break;
				case 7:
					if(v139) {
						bs139 |= 1;
					} else {
						bs139 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs139;
			break;
		case 52:
			var this141 = 0;
			var bs140 = this141;
			var l140 = "   * ".length;
			var _g1141 = 0;
			var _g241 = l140;
			while(_g1141 < _g241) {
				var i141 = _g1141++;
				var no140 = "   * ".charCodeAt(i141);
				if(no140 == null) {
					break;
				}
				var v140;
				switch(no140) {
				case 32:
					v140 = false;
					break;
				case 42:
					v140 = true;
					break;
				case 48:
					v140 = false;
					break;
				case 49:
					v140 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i141)));
				}
				switch(i141 - (l140 - 8)) {
				case 0:
					if(v140) {
						bs140 |= 128;
					} else {
						bs140 &= -129;
					}
					break;
				case 1:
					if(v140) {
						bs140 |= 64;
					} else {
						bs140 &= -65;
					}
					break;
				case 2:
					if(v140) {
						bs140 |= 32;
					} else {
						bs140 &= -33;
					}
					break;
				case 3:
					if(v140) {
						bs140 |= 16;
					} else {
						bs140 &= -17;
					}
					break;
				case 4:
					if(v140) {
						bs140 |= 8;
					} else {
						bs140 &= -9;
					}
					break;
				case 5:
					if(v140) {
						bs140 |= 4;
					} else {
						bs140 &= -5;
					}
					break;
				case 6:
					if(v140) {
						bs140 |= 2;
					} else {
						bs140 &= -3;
					}
					break;
				case 7:
					if(v140) {
						bs140 |= 1;
					} else {
						bs140 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs140;
			var this142 = 0;
			var bs141 = this142;
			var l141 = "  ** ".length;
			var _g1142 = 0;
			var _g242 = l141;
			while(_g1142 < _g242) {
				var i142 = _g1142++;
				var no141 = "  ** ".charCodeAt(i142);
				if(no141 == null) {
					break;
				}
				var v141;
				switch(no141) {
				case 32:
					v141 = false;
					break;
				case 42:
					v141 = true;
					break;
				case 48:
					v141 = false;
					break;
				case 49:
					v141 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i142)));
				}
				switch(i142 - (l141 - 8)) {
				case 0:
					if(v141) {
						bs141 |= 128;
					} else {
						bs141 &= -129;
					}
					break;
				case 1:
					if(v141) {
						bs141 |= 64;
					} else {
						bs141 &= -65;
					}
					break;
				case 2:
					if(v141) {
						bs141 |= 32;
					} else {
						bs141 &= -33;
					}
					break;
				case 3:
					if(v141) {
						bs141 |= 16;
					} else {
						bs141 &= -17;
					}
					break;
				case 4:
					if(v141) {
						bs141 |= 8;
					} else {
						bs141 &= -9;
					}
					break;
				case 5:
					if(v141) {
						bs141 |= 4;
					} else {
						bs141 &= -5;
					}
					break;
				case 6:
					if(v141) {
						bs141 |= 2;
					} else {
						bs141 &= -3;
					}
					break;
				case 7:
					if(v141) {
						bs141 |= 1;
					} else {
						bs141 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs141;
			var this143 = 0;
			var bs142 = this143;
			var l142 = " * * ".length;
			var _g1143 = 0;
			var _g243 = l142;
			while(_g1143 < _g243) {
				var i143 = _g1143++;
				var no142 = " * * ".charCodeAt(i143);
				if(no142 == null) {
					break;
				}
				var v142;
				switch(no142) {
				case 32:
					v142 = false;
					break;
				case 42:
					v142 = true;
					break;
				case 48:
					v142 = false;
					break;
				case 49:
					v142 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i143)));
				}
				switch(i143 - (l142 - 8)) {
				case 0:
					if(v142) {
						bs142 |= 128;
					} else {
						bs142 &= -129;
					}
					break;
				case 1:
					if(v142) {
						bs142 |= 64;
					} else {
						bs142 &= -65;
					}
					break;
				case 2:
					if(v142) {
						bs142 |= 32;
					} else {
						bs142 &= -33;
					}
					break;
				case 3:
					if(v142) {
						bs142 |= 16;
					} else {
						bs142 &= -17;
					}
					break;
				case 4:
					if(v142) {
						bs142 |= 8;
					} else {
						bs142 &= -9;
					}
					break;
				case 5:
					if(v142) {
						bs142 |= 4;
					} else {
						bs142 &= -5;
					}
					break;
				case 6:
					if(v142) {
						bs142 |= 2;
					} else {
						bs142 &= -3;
					}
					break;
				case 7:
					if(v142) {
						bs142 |= 1;
					} else {
						bs142 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs142;
			var this144 = 0;
			var bs143 = this144;
			var l143 = "*  * ".length;
			var _g1144 = 0;
			var _g244 = l143;
			while(_g1144 < _g244) {
				var i144 = _g1144++;
				var no143 = "*  * ".charCodeAt(i144);
				if(no143 == null) {
					break;
				}
				var v143;
				switch(no143) {
				case 32:
					v143 = false;
					break;
				case 42:
					v143 = true;
					break;
				case 48:
					v143 = false;
					break;
				case 49:
					v143 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i144)));
				}
				switch(i144 - (l143 - 8)) {
				case 0:
					if(v143) {
						bs143 |= 128;
					} else {
						bs143 &= -129;
					}
					break;
				case 1:
					if(v143) {
						bs143 |= 64;
					} else {
						bs143 &= -65;
					}
					break;
				case 2:
					if(v143) {
						bs143 |= 32;
					} else {
						bs143 &= -33;
					}
					break;
				case 3:
					if(v143) {
						bs143 |= 16;
					} else {
						bs143 &= -17;
					}
					break;
				case 4:
					if(v143) {
						bs143 |= 8;
					} else {
						bs143 &= -9;
					}
					break;
				case 5:
					if(v143) {
						bs143 |= 4;
					} else {
						bs143 &= -5;
					}
					break;
				case 6:
					if(v143) {
						bs143 |= 2;
					} else {
						bs143 &= -3;
					}
					break;
				case 7:
					if(v143) {
						bs143 |= 1;
					} else {
						bs143 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs143;
			var this145 = 0;
			var bs144 = this145;
			var l144 = "*****".length;
			var _g1145 = 0;
			var _g245 = l144;
			while(_g1145 < _g245) {
				var i145 = _g1145++;
				var no144 = "*****".charCodeAt(i145);
				if(no144 == null) {
					break;
				}
				var v144;
				switch(no144) {
				case 32:
					v144 = false;
					break;
				case 42:
					v144 = true;
					break;
				case 48:
					v144 = false;
					break;
				case 49:
					v144 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i145)));
				}
				switch(i145 - (l144 - 8)) {
				case 0:
					if(v144) {
						bs144 |= 128;
					} else {
						bs144 &= -129;
					}
					break;
				case 1:
					if(v144) {
						bs144 |= 64;
					} else {
						bs144 &= -65;
					}
					break;
				case 2:
					if(v144) {
						bs144 |= 32;
					} else {
						bs144 &= -33;
					}
					break;
				case 3:
					if(v144) {
						bs144 |= 16;
					} else {
						bs144 &= -17;
					}
					break;
				case 4:
					if(v144) {
						bs144 |= 8;
					} else {
						bs144 &= -9;
					}
					break;
				case 5:
					if(v144) {
						bs144 |= 4;
					} else {
						bs144 &= -5;
					}
					break;
				case 6:
					if(v144) {
						bs144 |= 2;
					} else {
						bs144 &= -3;
					}
					break;
				case 7:
					if(v144) {
						bs144 |= 1;
					} else {
						bs144 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs144;
			var this146 = 0;
			var bs145 = this146;
			var l145 = "   * ".length;
			var _g1146 = 0;
			var _g246 = l145;
			while(_g1146 < _g246) {
				var i146 = _g1146++;
				var no145 = "   * ".charCodeAt(i146);
				if(no145 == null) {
					break;
				}
				var v145;
				switch(no145) {
				case 32:
					v145 = false;
					break;
				case 42:
					v145 = true;
					break;
				case 48:
					v145 = false;
					break;
				case 49:
					v145 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i146)));
				}
				switch(i146 - (l145 - 8)) {
				case 0:
					if(v145) {
						bs145 |= 128;
					} else {
						bs145 &= -129;
					}
					break;
				case 1:
					if(v145) {
						bs145 |= 64;
					} else {
						bs145 &= -65;
					}
					break;
				case 2:
					if(v145) {
						bs145 |= 32;
					} else {
						bs145 &= -33;
					}
					break;
				case 3:
					if(v145) {
						bs145 |= 16;
					} else {
						bs145 &= -17;
					}
					break;
				case 4:
					if(v145) {
						bs145 |= 8;
					} else {
						bs145 &= -9;
					}
					break;
				case 5:
					if(v145) {
						bs145 |= 4;
					} else {
						bs145 &= -5;
					}
					break;
				case 6:
					if(v145) {
						bs145 |= 2;
					} else {
						bs145 &= -3;
					}
					break;
				case 7:
					if(v145) {
						bs145 |= 1;
					} else {
						bs145 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs145;
			var this147 = 0;
			var bs146 = this147;
			var l146 = "   * ".length;
			var _g1147 = 0;
			var _g247 = l146;
			while(_g1147 < _g247) {
				var i147 = _g1147++;
				var no146 = "   * ".charCodeAt(i147);
				if(no146 == null) {
					break;
				}
				var v146;
				switch(no146) {
				case 32:
					v146 = false;
					break;
				case 42:
					v146 = true;
					break;
				case 48:
					v146 = false;
					break;
				case 49:
					v146 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i147)));
				}
				switch(i147 - (l146 - 8)) {
				case 0:
					if(v146) {
						bs146 |= 128;
					} else {
						bs146 &= -129;
					}
					break;
				case 1:
					if(v146) {
						bs146 |= 64;
					} else {
						bs146 &= -65;
					}
					break;
				case 2:
					if(v146) {
						bs146 |= 32;
					} else {
						bs146 &= -33;
					}
					break;
				case 3:
					if(v146) {
						bs146 |= 16;
					} else {
						bs146 &= -17;
					}
					break;
				case 4:
					if(v146) {
						bs146 |= 8;
					} else {
						bs146 &= -9;
					}
					break;
				case 5:
					if(v146) {
						bs146 |= 4;
					} else {
						bs146 &= -5;
					}
					break;
				case 6:
					if(v146) {
						bs146 |= 2;
					} else {
						bs146 &= -3;
					}
					break;
				case 7:
					if(v146) {
						bs146 |= 1;
					} else {
						bs146 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs146;
			break;
		case 53:
			var this148 = 0;
			var bs147 = this148;
			var l147 = "*****".length;
			var _g1148 = 0;
			var _g248 = l147;
			while(_g1148 < _g248) {
				var i148 = _g1148++;
				var no147 = "*****".charCodeAt(i148);
				if(no147 == null) {
					break;
				}
				var v147;
				switch(no147) {
				case 32:
					v147 = false;
					break;
				case 42:
					v147 = true;
					break;
				case 48:
					v147 = false;
					break;
				case 49:
					v147 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i148)));
				}
				switch(i148 - (l147 - 8)) {
				case 0:
					if(v147) {
						bs147 |= 128;
					} else {
						bs147 &= -129;
					}
					break;
				case 1:
					if(v147) {
						bs147 |= 64;
					} else {
						bs147 &= -65;
					}
					break;
				case 2:
					if(v147) {
						bs147 |= 32;
					} else {
						bs147 &= -33;
					}
					break;
				case 3:
					if(v147) {
						bs147 |= 16;
					} else {
						bs147 &= -17;
					}
					break;
				case 4:
					if(v147) {
						bs147 |= 8;
					} else {
						bs147 &= -9;
					}
					break;
				case 5:
					if(v147) {
						bs147 |= 4;
					} else {
						bs147 &= -5;
					}
					break;
				case 6:
					if(v147) {
						bs147 |= 2;
					} else {
						bs147 &= -3;
					}
					break;
				case 7:
					if(v147) {
						bs147 |= 1;
					} else {
						bs147 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs147;
			var this149 = 0;
			var bs148 = this149;
			var l148 = "*    ".length;
			var _g1149 = 0;
			var _g249 = l148;
			while(_g1149 < _g249) {
				var i149 = _g1149++;
				var no148 = "*    ".charCodeAt(i149);
				if(no148 == null) {
					break;
				}
				var v148;
				switch(no148) {
				case 32:
					v148 = false;
					break;
				case 42:
					v148 = true;
					break;
				case 48:
					v148 = false;
					break;
				case 49:
					v148 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i149)));
				}
				switch(i149 - (l148 - 8)) {
				case 0:
					if(v148) {
						bs148 |= 128;
					} else {
						bs148 &= -129;
					}
					break;
				case 1:
					if(v148) {
						bs148 |= 64;
					} else {
						bs148 &= -65;
					}
					break;
				case 2:
					if(v148) {
						bs148 |= 32;
					} else {
						bs148 &= -33;
					}
					break;
				case 3:
					if(v148) {
						bs148 |= 16;
					} else {
						bs148 &= -17;
					}
					break;
				case 4:
					if(v148) {
						bs148 |= 8;
					} else {
						bs148 &= -9;
					}
					break;
				case 5:
					if(v148) {
						bs148 |= 4;
					} else {
						bs148 &= -5;
					}
					break;
				case 6:
					if(v148) {
						bs148 |= 2;
					} else {
						bs148 &= -3;
					}
					break;
				case 7:
					if(v148) {
						bs148 |= 1;
					} else {
						bs148 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs148;
			var this150 = 0;
			var bs149 = this150;
			var l149 = "**** ".length;
			var _g1150 = 0;
			var _g250 = l149;
			while(_g1150 < _g250) {
				var i150 = _g1150++;
				var no149 = "**** ".charCodeAt(i150);
				if(no149 == null) {
					break;
				}
				var v149;
				switch(no149) {
				case 32:
					v149 = false;
					break;
				case 42:
					v149 = true;
					break;
				case 48:
					v149 = false;
					break;
				case 49:
					v149 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i150)));
				}
				switch(i150 - (l149 - 8)) {
				case 0:
					if(v149) {
						bs149 |= 128;
					} else {
						bs149 &= -129;
					}
					break;
				case 1:
					if(v149) {
						bs149 |= 64;
					} else {
						bs149 &= -65;
					}
					break;
				case 2:
					if(v149) {
						bs149 |= 32;
					} else {
						bs149 &= -33;
					}
					break;
				case 3:
					if(v149) {
						bs149 |= 16;
					} else {
						bs149 &= -17;
					}
					break;
				case 4:
					if(v149) {
						bs149 |= 8;
					} else {
						bs149 &= -9;
					}
					break;
				case 5:
					if(v149) {
						bs149 |= 4;
					} else {
						bs149 &= -5;
					}
					break;
				case 6:
					if(v149) {
						bs149 |= 2;
					} else {
						bs149 &= -3;
					}
					break;
				case 7:
					if(v149) {
						bs149 |= 1;
					} else {
						bs149 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs149;
			var this151 = 0;
			var bs150 = this151;
			var l150 = "    *".length;
			var _g1151 = 0;
			var _g251 = l150;
			while(_g1151 < _g251) {
				var i151 = _g1151++;
				var no150 = "    *".charCodeAt(i151);
				if(no150 == null) {
					break;
				}
				var v150;
				switch(no150) {
				case 32:
					v150 = false;
					break;
				case 42:
					v150 = true;
					break;
				case 48:
					v150 = false;
					break;
				case 49:
					v150 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i151)));
				}
				switch(i151 - (l150 - 8)) {
				case 0:
					if(v150) {
						bs150 |= 128;
					} else {
						bs150 &= -129;
					}
					break;
				case 1:
					if(v150) {
						bs150 |= 64;
					} else {
						bs150 &= -65;
					}
					break;
				case 2:
					if(v150) {
						bs150 |= 32;
					} else {
						bs150 &= -33;
					}
					break;
				case 3:
					if(v150) {
						bs150 |= 16;
					} else {
						bs150 &= -17;
					}
					break;
				case 4:
					if(v150) {
						bs150 |= 8;
					} else {
						bs150 &= -9;
					}
					break;
				case 5:
					if(v150) {
						bs150 |= 4;
					} else {
						bs150 &= -5;
					}
					break;
				case 6:
					if(v150) {
						bs150 |= 2;
					} else {
						bs150 &= -3;
					}
					break;
				case 7:
					if(v150) {
						bs150 |= 1;
					} else {
						bs150 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs150;
			var this152 = 0;
			var bs151 = this152;
			var l151 = "    *".length;
			var _g1152 = 0;
			var _g252 = l151;
			while(_g1152 < _g252) {
				var i152 = _g1152++;
				var no151 = "    *".charCodeAt(i152);
				if(no151 == null) {
					break;
				}
				var v151;
				switch(no151) {
				case 32:
					v151 = false;
					break;
				case 42:
					v151 = true;
					break;
				case 48:
					v151 = false;
					break;
				case 49:
					v151 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i152)));
				}
				switch(i152 - (l151 - 8)) {
				case 0:
					if(v151) {
						bs151 |= 128;
					} else {
						bs151 &= -129;
					}
					break;
				case 1:
					if(v151) {
						bs151 |= 64;
					} else {
						bs151 &= -65;
					}
					break;
				case 2:
					if(v151) {
						bs151 |= 32;
					} else {
						bs151 &= -33;
					}
					break;
				case 3:
					if(v151) {
						bs151 |= 16;
					} else {
						bs151 &= -17;
					}
					break;
				case 4:
					if(v151) {
						bs151 |= 8;
					} else {
						bs151 &= -9;
					}
					break;
				case 5:
					if(v151) {
						bs151 |= 4;
					} else {
						bs151 &= -5;
					}
					break;
				case 6:
					if(v151) {
						bs151 |= 2;
					} else {
						bs151 &= -3;
					}
					break;
				case 7:
					if(v151) {
						bs151 |= 1;
					} else {
						bs151 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs151;
			var this153 = 0;
			var bs152 = this153;
			var l152 = "*   *".length;
			var _g1153 = 0;
			var _g253 = l152;
			while(_g1153 < _g253) {
				var i153 = _g1153++;
				var no152 = "*   *".charCodeAt(i153);
				if(no152 == null) {
					break;
				}
				var v152;
				switch(no152) {
				case 32:
					v152 = false;
					break;
				case 42:
					v152 = true;
					break;
				case 48:
					v152 = false;
					break;
				case 49:
					v152 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i153)));
				}
				switch(i153 - (l152 - 8)) {
				case 0:
					if(v152) {
						bs152 |= 128;
					} else {
						bs152 &= -129;
					}
					break;
				case 1:
					if(v152) {
						bs152 |= 64;
					} else {
						bs152 &= -65;
					}
					break;
				case 2:
					if(v152) {
						bs152 |= 32;
					} else {
						bs152 &= -33;
					}
					break;
				case 3:
					if(v152) {
						bs152 |= 16;
					} else {
						bs152 &= -17;
					}
					break;
				case 4:
					if(v152) {
						bs152 |= 8;
					} else {
						bs152 &= -9;
					}
					break;
				case 5:
					if(v152) {
						bs152 |= 4;
					} else {
						bs152 &= -5;
					}
					break;
				case 6:
					if(v152) {
						bs152 |= 2;
					} else {
						bs152 &= -3;
					}
					break;
				case 7:
					if(v152) {
						bs152 |= 1;
					} else {
						bs152 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs152;
			var this154 = 0;
			var bs153 = this154;
			var l153 = " *** ".length;
			var _g1154 = 0;
			var _g254 = l153;
			while(_g1154 < _g254) {
				var i154 = _g1154++;
				var no153 = " *** ".charCodeAt(i154);
				if(no153 == null) {
					break;
				}
				var v153;
				switch(no153) {
				case 32:
					v153 = false;
					break;
				case 42:
					v153 = true;
					break;
				case 48:
					v153 = false;
					break;
				case 49:
					v153 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i154)));
				}
				switch(i154 - (l153 - 8)) {
				case 0:
					if(v153) {
						bs153 |= 128;
					} else {
						bs153 &= -129;
					}
					break;
				case 1:
					if(v153) {
						bs153 |= 64;
					} else {
						bs153 &= -65;
					}
					break;
				case 2:
					if(v153) {
						bs153 |= 32;
					} else {
						bs153 &= -33;
					}
					break;
				case 3:
					if(v153) {
						bs153 |= 16;
					} else {
						bs153 &= -17;
					}
					break;
				case 4:
					if(v153) {
						bs153 |= 8;
					} else {
						bs153 &= -9;
					}
					break;
				case 5:
					if(v153) {
						bs153 |= 4;
					} else {
						bs153 &= -5;
					}
					break;
				case 6:
					if(v153) {
						bs153 |= 2;
					} else {
						bs153 &= -3;
					}
					break;
				case 7:
					if(v153) {
						bs153 |= 1;
					} else {
						bs153 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs153;
			break;
		case 54:
			var this155 = 0;
			var bs154 = this155;
			var l154 = "  ** ".length;
			var _g1155 = 0;
			var _g255 = l154;
			while(_g1155 < _g255) {
				var i155 = _g1155++;
				var no154 = "  ** ".charCodeAt(i155);
				if(no154 == null) {
					break;
				}
				var v154;
				switch(no154) {
				case 32:
					v154 = false;
					break;
				case 42:
					v154 = true;
					break;
				case 48:
					v154 = false;
					break;
				case 49:
					v154 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i155)));
				}
				switch(i155 - (l154 - 8)) {
				case 0:
					if(v154) {
						bs154 |= 128;
					} else {
						bs154 &= -129;
					}
					break;
				case 1:
					if(v154) {
						bs154 |= 64;
					} else {
						bs154 &= -65;
					}
					break;
				case 2:
					if(v154) {
						bs154 |= 32;
					} else {
						bs154 &= -33;
					}
					break;
				case 3:
					if(v154) {
						bs154 |= 16;
					} else {
						bs154 &= -17;
					}
					break;
				case 4:
					if(v154) {
						bs154 |= 8;
					} else {
						bs154 &= -9;
					}
					break;
				case 5:
					if(v154) {
						bs154 |= 4;
					} else {
						bs154 &= -5;
					}
					break;
				case 6:
					if(v154) {
						bs154 |= 2;
					} else {
						bs154 &= -3;
					}
					break;
				case 7:
					if(v154) {
						bs154 |= 1;
					} else {
						bs154 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs154;
			var this156 = 0;
			var bs155 = this156;
			var l155 = " *   ".length;
			var _g1156 = 0;
			var _g256 = l155;
			while(_g1156 < _g256) {
				var i156 = _g1156++;
				var no155 = " *   ".charCodeAt(i156);
				if(no155 == null) {
					break;
				}
				var v155;
				switch(no155) {
				case 32:
					v155 = false;
					break;
				case 42:
					v155 = true;
					break;
				case 48:
					v155 = false;
					break;
				case 49:
					v155 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i156)));
				}
				switch(i156 - (l155 - 8)) {
				case 0:
					if(v155) {
						bs155 |= 128;
					} else {
						bs155 &= -129;
					}
					break;
				case 1:
					if(v155) {
						bs155 |= 64;
					} else {
						bs155 &= -65;
					}
					break;
				case 2:
					if(v155) {
						bs155 |= 32;
					} else {
						bs155 &= -33;
					}
					break;
				case 3:
					if(v155) {
						bs155 |= 16;
					} else {
						bs155 &= -17;
					}
					break;
				case 4:
					if(v155) {
						bs155 |= 8;
					} else {
						bs155 &= -9;
					}
					break;
				case 5:
					if(v155) {
						bs155 |= 4;
					} else {
						bs155 &= -5;
					}
					break;
				case 6:
					if(v155) {
						bs155 |= 2;
					} else {
						bs155 &= -3;
					}
					break;
				case 7:
					if(v155) {
						bs155 |= 1;
					} else {
						bs155 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs155;
			var this157 = 0;
			var bs156 = this157;
			var l156 = "*    ".length;
			var _g1157 = 0;
			var _g257 = l156;
			while(_g1157 < _g257) {
				var i157 = _g1157++;
				var no156 = "*    ".charCodeAt(i157);
				if(no156 == null) {
					break;
				}
				var v156;
				switch(no156) {
				case 32:
					v156 = false;
					break;
				case 42:
					v156 = true;
					break;
				case 48:
					v156 = false;
					break;
				case 49:
					v156 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i157)));
				}
				switch(i157 - (l156 - 8)) {
				case 0:
					if(v156) {
						bs156 |= 128;
					} else {
						bs156 &= -129;
					}
					break;
				case 1:
					if(v156) {
						bs156 |= 64;
					} else {
						bs156 &= -65;
					}
					break;
				case 2:
					if(v156) {
						bs156 |= 32;
					} else {
						bs156 &= -33;
					}
					break;
				case 3:
					if(v156) {
						bs156 |= 16;
					} else {
						bs156 &= -17;
					}
					break;
				case 4:
					if(v156) {
						bs156 |= 8;
					} else {
						bs156 &= -9;
					}
					break;
				case 5:
					if(v156) {
						bs156 |= 4;
					} else {
						bs156 &= -5;
					}
					break;
				case 6:
					if(v156) {
						bs156 |= 2;
					} else {
						bs156 &= -3;
					}
					break;
				case 7:
					if(v156) {
						bs156 |= 1;
					} else {
						bs156 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs156;
			var this158 = 0;
			var bs157 = this158;
			var l157 = "**** ".length;
			var _g1158 = 0;
			var _g258 = l157;
			while(_g1158 < _g258) {
				var i158 = _g1158++;
				var no157 = "**** ".charCodeAt(i158);
				if(no157 == null) {
					break;
				}
				var v157;
				switch(no157) {
				case 32:
					v157 = false;
					break;
				case 42:
					v157 = true;
					break;
				case 48:
					v157 = false;
					break;
				case 49:
					v157 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i158)));
				}
				switch(i158 - (l157 - 8)) {
				case 0:
					if(v157) {
						bs157 |= 128;
					} else {
						bs157 &= -129;
					}
					break;
				case 1:
					if(v157) {
						bs157 |= 64;
					} else {
						bs157 &= -65;
					}
					break;
				case 2:
					if(v157) {
						bs157 |= 32;
					} else {
						bs157 &= -33;
					}
					break;
				case 3:
					if(v157) {
						bs157 |= 16;
					} else {
						bs157 &= -17;
					}
					break;
				case 4:
					if(v157) {
						bs157 |= 8;
					} else {
						bs157 &= -9;
					}
					break;
				case 5:
					if(v157) {
						bs157 |= 4;
					} else {
						bs157 &= -5;
					}
					break;
				case 6:
					if(v157) {
						bs157 |= 2;
					} else {
						bs157 &= -3;
					}
					break;
				case 7:
					if(v157) {
						bs157 |= 1;
					} else {
						bs157 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs157;
			var this159 = 0;
			var bs158 = this159;
			var l158 = "*   *".length;
			var _g1159 = 0;
			var _g259 = l158;
			while(_g1159 < _g259) {
				var i159 = _g1159++;
				var no158 = "*   *".charCodeAt(i159);
				if(no158 == null) {
					break;
				}
				var v158;
				switch(no158) {
				case 32:
					v158 = false;
					break;
				case 42:
					v158 = true;
					break;
				case 48:
					v158 = false;
					break;
				case 49:
					v158 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i159)));
				}
				switch(i159 - (l158 - 8)) {
				case 0:
					if(v158) {
						bs158 |= 128;
					} else {
						bs158 &= -129;
					}
					break;
				case 1:
					if(v158) {
						bs158 |= 64;
					} else {
						bs158 &= -65;
					}
					break;
				case 2:
					if(v158) {
						bs158 |= 32;
					} else {
						bs158 &= -33;
					}
					break;
				case 3:
					if(v158) {
						bs158 |= 16;
					} else {
						bs158 &= -17;
					}
					break;
				case 4:
					if(v158) {
						bs158 |= 8;
					} else {
						bs158 &= -9;
					}
					break;
				case 5:
					if(v158) {
						bs158 |= 4;
					} else {
						bs158 &= -5;
					}
					break;
				case 6:
					if(v158) {
						bs158 |= 2;
					} else {
						bs158 &= -3;
					}
					break;
				case 7:
					if(v158) {
						bs158 |= 1;
					} else {
						bs158 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs158;
			var this160 = 0;
			var bs159 = this160;
			var l159 = "*   *".length;
			var _g1160 = 0;
			var _g260 = l159;
			while(_g1160 < _g260) {
				var i160 = _g1160++;
				var no159 = "*   *".charCodeAt(i160);
				if(no159 == null) {
					break;
				}
				var v159;
				switch(no159) {
				case 32:
					v159 = false;
					break;
				case 42:
					v159 = true;
					break;
				case 48:
					v159 = false;
					break;
				case 49:
					v159 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i160)));
				}
				switch(i160 - (l159 - 8)) {
				case 0:
					if(v159) {
						bs159 |= 128;
					} else {
						bs159 &= -129;
					}
					break;
				case 1:
					if(v159) {
						bs159 |= 64;
					} else {
						bs159 &= -65;
					}
					break;
				case 2:
					if(v159) {
						bs159 |= 32;
					} else {
						bs159 &= -33;
					}
					break;
				case 3:
					if(v159) {
						bs159 |= 16;
					} else {
						bs159 &= -17;
					}
					break;
				case 4:
					if(v159) {
						bs159 |= 8;
					} else {
						bs159 &= -9;
					}
					break;
				case 5:
					if(v159) {
						bs159 |= 4;
					} else {
						bs159 &= -5;
					}
					break;
				case 6:
					if(v159) {
						bs159 |= 2;
					} else {
						bs159 &= -3;
					}
					break;
				case 7:
					if(v159) {
						bs159 |= 1;
					} else {
						bs159 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs159;
			var this161 = 0;
			var bs160 = this161;
			var l160 = " *** ".length;
			var _g1161 = 0;
			var _g261 = l160;
			while(_g1161 < _g261) {
				var i161 = _g1161++;
				var no160 = " *** ".charCodeAt(i161);
				if(no160 == null) {
					break;
				}
				var v160;
				switch(no160) {
				case 32:
					v160 = false;
					break;
				case 42:
					v160 = true;
					break;
				case 48:
					v160 = false;
					break;
				case 49:
					v160 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i161)));
				}
				switch(i161 - (l160 - 8)) {
				case 0:
					if(v160) {
						bs160 |= 128;
					} else {
						bs160 &= -129;
					}
					break;
				case 1:
					if(v160) {
						bs160 |= 64;
					} else {
						bs160 &= -65;
					}
					break;
				case 2:
					if(v160) {
						bs160 |= 32;
					} else {
						bs160 &= -33;
					}
					break;
				case 3:
					if(v160) {
						bs160 |= 16;
					} else {
						bs160 &= -17;
					}
					break;
				case 4:
					if(v160) {
						bs160 |= 8;
					} else {
						bs160 &= -9;
					}
					break;
				case 5:
					if(v160) {
						bs160 |= 4;
					} else {
						bs160 &= -5;
					}
					break;
				case 6:
					if(v160) {
						bs160 |= 2;
					} else {
						bs160 &= -3;
					}
					break;
				case 7:
					if(v160) {
						bs160 |= 1;
					} else {
						bs160 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs160;
			break;
		case 55:
			var this162 = 0;
			var bs161 = this162;
			var l161 = "*****".length;
			var _g1162 = 0;
			var _g262 = l161;
			while(_g1162 < _g262) {
				var i162 = _g1162++;
				var no161 = "*****".charCodeAt(i162);
				if(no161 == null) {
					break;
				}
				var v161;
				switch(no161) {
				case 32:
					v161 = false;
					break;
				case 42:
					v161 = true;
					break;
				case 48:
					v161 = false;
					break;
				case 49:
					v161 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i162)));
				}
				switch(i162 - (l161 - 8)) {
				case 0:
					if(v161) {
						bs161 |= 128;
					} else {
						bs161 &= -129;
					}
					break;
				case 1:
					if(v161) {
						bs161 |= 64;
					} else {
						bs161 &= -65;
					}
					break;
				case 2:
					if(v161) {
						bs161 |= 32;
					} else {
						bs161 &= -33;
					}
					break;
				case 3:
					if(v161) {
						bs161 |= 16;
					} else {
						bs161 &= -17;
					}
					break;
				case 4:
					if(v161) {
						bs161 |= 8;
					} else {
						bs161 &= -9;
					}
					break;
				case 5:
					if(v161) {
						bs161 |= 4;
					} else {
						bs161 &= -5;
					}
					break;
				case 6:
					if(v161) {
						bs161 |= 2;
					} else {
						bs161 &= -3;
					}
					break;
				case 7:
					if(v161) {
						bs161 |= 1;
					} else {
						bs161 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs161;
			var this163 = 0;
			var bs162 = this163;
			var l162 = "    *".length;
			var _g1163 = 0;
			var _g263 = l162;
			while(_g1163 < _g263) {
				var i163 = _g1163++;
				var no162 = "    *".charCodeAt(i163);
				if(no162 == null) {
					break;
				}
				var v162;
				switch(no162) {
				case 32:
					v162 = false;
					break;
				case 42:
					v162 = true;
					break;
				case 48:
					v162 = false;
					break;
				case 49:
					v162 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i163)));
				}
				switch(i163 - (l162 - 8)) {
				case 0:
					if(v162) {
						bs162 |= 128;
					} else {
						bs162 &= -129;
					}
					break;
				case 1:
					if(v162) {
						bs162 |= 64;
					} else {
						bs162 &= -65;
					}
					break;
				case 2:
					if(v162) {
						bs162 |= 32;
					} else {
						bs162 &= -33;
					}
					break;
				case 3:
					if(v162) {
						bs162 |= 16;
					} else {
						bs162 &= -17;
					}
					break;
				case 4:
					if(v162) {
						bs162 |= 8;
					} else {
						bs162 &= -9;
					}
					break;
				case 5:
					if(v162) {
						bs162 |= 4;
					} else {
						bs162 &= -5;
					}
					break;
				case 6:
					if(v162) {
						bs162 |= 2;
					} else {
						bs162 &= -3;
					}
					break;
				case 7:
					if(v162) {
						bs162 |= 1;
					} else {
						bs162 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs162;
			var this164 = 0;
			var bs163 = this164;
			var l163 = "   * ".length;
			var _g1164 = 0;
			var _g264 = l163;
			while(_g1164 < _g264) {
				var i164 = _g1164++;
				var no163 = "   * ".charCodeAt(i164);
				if(no163 == null) {
					break;
				}
				var v163;
				switch(no163) {
				case 32:
					v163 = false;
					break;
				case 42:
					v163 = true;
					break;
				case 48:
					v163 = false;
					break;
				case 49:
					v163 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i164)));
				}
				switch(i164 - (l163 - 8)) {
				case 0:
					if(v163) {
						bs163 |= 128;
					} else {
						bs163 &= -129;
					}
					break;
				case 1:
					if(v163) {
						bs163 |= 64;
					} else {
						bs163 &= -65;
					}
					break;
				case 2:
					if(v163) {
						bs163 |= 32;
					} else {
						bs163 &= -33;
					}
					break;
				case 3:
					if(v163) {
						bs163 |= 16;
					} else {
						bs163 &= -17;
					}
					break;
				case 4:
					if(v163) {
						bs163 |= 8;
					} else {
						bs163 &= -9;
					}
					break;
				case 5:
					if(v163) {
						bs163 |= 4;
					} else {
						bs163 &= -5;
					}
					break;
				case 6:
					if(v163) {
						bs163 |= 2;
					} else {
						bs163 &= -3;
					}
					break;
				case 7:
					if(v163) {
						bs163 |= 1;
					} else {
						bs163 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs163;
			var this165 = 0;
			var bs164 = this165;
			var l164 = "  *  ".length;
			var _g1165 = 0;
			var _g265 = l164;
			while(_g1165 < _g265) {
				var i165 = _g1165++;
				var no164 = "  *  ".charCodeAt(i165);
				if(no164 == null) {
					break;
				}
				var v164;
				switch(no164) {
				case 32:
					v164 = false;
					break;
				case 42:
					v164 = true;
					break;
				case 48:
					v164 = false;
					break;
				case 49:
					v164 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i165)));
				}
				switch(i165 - (l164 - 8)) {
				case 0:
					if(v164) {
						bs164 |= 128;
					} else {
						bs164 &= -129;
					}
					break;
				case 1:
					if(v164) {
						bs164 |= 64;
					} else {
						bs164 &= -65;
					}
					break;
				case 2:
					if(v164) {
						bs164 |= 32;
					} else {
						bs164 &= -33;
					}
					break;
				case 3:
					if(v164) {
						bs164 |= 16;
					} else {
						bs164 &= -17;
					}
					break;
				case 4:
					if(v164) {
						bs164 |= 8;
					} else {
						bs164 &= -9;
					}
					break;
				case 5:
					if(v164) {
						bs164 |= 4;
					} else {
						bs164 &= -5;
					}
					break;
				case 6:
					if(v164) {
						bs164 |= 2;
					} else {
						bs164 &= -3;
					}
					break;
				case 7:
					if(v164) {
						bs164 |= 1;
					} else {
						bs164 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs164;
			var this166 = 0;
			var bs165 = this166;
			var l165 = " *   ".length;
			var _g1166 = 0;
			var _g266 = l165;
			while(_g1166 < _g266) {
				var i166 = _g1166++;
				var no165 = " *   ".charCodeAt(i166);
				if(no165 == null) {
					break;
				}
				var v165;
				switch(no165) {
				case 32:
					v165 = false;
					break;
				case 42:
					v165 = true;
					break;
				case 48:
					v165 = false;
					break;
				case 49:
					v165 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i166)));
				}
				switch(i166 - (l165 - 8)) {
				case 0:
					if(v165) {
						bs165 |= 128;
					} else {
						bs165 &= -129;
					}
					break;
				case 1:
					if(v165) {
						bs165 |= 64;
					} else {
						bs165 &= -65;
					}
					break;
				case 2:
					if(v165) {
						bs165 |= 32;
					} else {
						bs165 &= -33;
					}
					break;
				case 3:
					if(v165) {
						bs165 |= 16;
					} else {
						bs165 &= -17;
					}
					break;
				case 4:
					if(v165) {
						bs165 |= 8;
					} else {
						bs165 &= -9;
					}
					break;
				case 5:
					if(v165) {
						bs165 |= 4;
					} else {
						bs165 &= -5;
					}
					break;
				case 6:
					if(v165) {
						bs165 |= 2;
					} else {
						bs165 &= -3;
					}
					break;
				case 7:
					if(v165) {
						bs165 |= 1;
					} else {
						bs165 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs165;
			var this167 = 0;
			var bs166 = this167;
			var l166 = " *   ".length;
			var _g1167 = 0;
			var _g267 = l166;
			while(_g1167 < _g267) {
				var i167 = _g1167++;
				var no166 = " *   ".charCodeAt(i167);
				if(no166 == null) {
					break;
				}
				var v166;
				switch(no166) {
				case 32:
					v166 = false;
					break;
				case 42:
					v166 = true;
					break;
				case 48:
					v166 = false;
					break;
				case 49:
					v166 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i167)));
				}
				switch(i167 - (l166 - 8)) {
				case 0:
					if(v166) {
						bs166 |= 128;
					} else {
						bs166 &= -129;
					}
					break;
				case 1:
					if(v166) {
						bs166 |= 64;
					} else {
						bs166 &= -65;
					}
					break;
				case 2:
					if(v166) {
						bs166 |= 32;
					} else {
						bs166 &= -33;
					}
					break;
				case 3:
					if(v166) {
						bs166 |= 16;
					} else {
						bs166 &= -17;
					}
					break;
				case 4:
					if(v166) {
						bs166 |= 8;
					} else {
						bs166 &= -9;
					}
					break;
				case 5:
					if(v166) {
						bs166 |= 4;
					} else {
						bs166 &= -5;
					}
					break;
				case 6:
					if(v166) {
						bs166 |= 2;
					} else {
						bs166 &= -3;
					}
					break;
				case 7:
					if(v166) {
						bs166 |= 1;
					} else {
						bs166 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs166;
			var this168 = 0;
			var bs167 = this168;
			var l167 = " *   ".length;
			var _g1168 = 0;
			var _g268 = l167;
			while(_g1168 < _g268) {
				var i168 = _g1168++;
				var no167 = " *   ".charCodeAt(i168);
				if(no167 == null) {
					break;
				}
				var v167;
				switch(no167) {
				case 32:
					v167 = false;
					break;
				case 42:
					v167 = true;
					break;
				case 48:
					v167 = false;
					break;
				case 49:
					v167 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i168)));
				}
				switch(i168 - (l167 - 8)) {
				case 0:
					if(v167) {
						bs167 |= 128;
					} else {
						bs167 &= -129;
					}
					break;
				case 1:
					if(v167) {
						bs167 |= 64;
					} else {
						bs167 &= -65;
					}
					break;
				case 2:
					if(v167) {
						bs167 |= 32;
					} else {
						bs167 &= -33;
					}
					break;
				case 3:
					if(v167) {
						bs167 |= 16;
					} else {
						bs167 &= -17;
					}
					break;
				case 4:
					if(v167) {
						bs167 |= 8;
					} else {
						bs167 &= -9;
					}
					break;
				case 5:
					if(v167) {
						bs167 |= 4;
					} else {
						bs167 &= -5;
					}
					break;
				case 6:
					if(v167) {
						bs167 |= 2;
					} else {
						bs167 &= -3;
					}
					break;
				case 7:
					if(v167) {
						bs167 |= 1;
					} else {
						bs167 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs167;
			break;
		case 56:
			var this169 = 0;
			var bs168 = this169;
			var l168 = " *** ".length;
			var _g1169 = 0;
			var _g269 = l168;
			while(_g1169 < _g269) {
				var i169 = _g1169++;
				var no168 = " *** ".charCodeAt(i169);
				if(no168 == null) {
					break;
				}
				var v168;
				switch(no168) {
				case 32:
					v168 = false;
					break;
				case 42:
					v168 = true;
					break;
				case 48:
					v168 = false;
					break;
				case 49:
					v168 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i169)));
				}
				switch(i169 - (l168 - 8)) {
				case 0:
					if(v168) {
						bs168 |= 128;
					} else {
						bs168 &= -129;
					}
					break;
				case 1:
					if(v168) {
						bs168 |= 64;
					} else {
						bs168 &= -65;
					}
					break;
				case 2:
					if(v168) {
						bs168 |= 32;
					} else {
						bs168 &= -33;
					}
					break;
				case 3:
					if(v168) {
						bs168 |= 16;
					} else {
						bs168 &= -17;
					}
					break;
				case 4:
					if(v168) {
						bs168 |= 8;
					} else {
						bs168 &= -9;
					}
					break;
				case 5:
					if(v168) {
						bs168 |= 4;
					} else {
						bs168 &= -5;
					}
					break;
				case 6:
					if(v168) {
						bs168 |= 2;
					} else {
						bs168 &= -3;
					}
					break;
				case 7:
					if(v168) {
						bs168 |= 1;
					} else {
						bs168 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs168;
			var this170 = 0;
			var bs169 = this170;
			var l169 = "*   *".length;
			var _g1170 = 0;
			var _g270 = l169;
			while(_g1170 < _g270) {
				var i170 = _g1170++;
				var no169 = "*   *".charCodeAt(i170);
				if(no169 == null) {
					break;
				}
				var v169;
				switch(no169) {
				case 32:
					v169 = false;
					break;
				case 42:
					v169 = true;
					break;
				case 48:
					v169 = false;
					break;
				case 49:
					v169 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i170)));
				}
				switch(i170 - (l169 - 8)) {
				case 0:
					if(v169) {
						bs169 |= 128;
					} else {
						bs169 &= -129;
					}
					break;
				case 1:
					if(v169) {
						bs169 |= 64;
					} else {
						bs169 &= -65;
					}
					break;
				case 2:
					if(v169) {
						bs169 |= 32;
					} else {
						bs169 &= -33;
					}
					break;
				case 3:
					if(v169) {
						bs169 |= 16;
					} else {
						bs169 &= -17;
					}
					break;
				case 4:
					if(v169) {
						bs169 |= 8;
					} else {
						bs169 &= -9;
					}
					break;
				case 5:
					if(v169) {
						bs169 |= 4;
					} else {
						bs169 &= -5;
					}
					break;
				case 6:
					if(v169) {
						bs169 |= 2;
					} else {
						bs169 &= -3;
					}
					break;
				case 7:
					if(v169) {
						bs169 |= 1;
					} else {
						bs169 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs169;
			var this171 = 0;
			var bs170 = this171;
			var l170 = "*   *".length;
			var _g1171 = 0;
			var _g271 = l170;
			while(_g1171 < _g271) {
				var i171 = _g1171++;
				var no170 = "*   *".charCodeAt(i171);
				if(no170 == null) {
					break;
				}
				var v170;
				switch(no170) {
				case 32:
					v170 = false;
					break;
				case 42:
					v170 = true;
					break;
				case 48:
					v170 = false;
					break;
				case 49:
					v170 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i171)));
				}
				switch(i171 - (l170 - 8)) {
				case 0:
					if(v170) {
						bs170 |= 128;
					} else {
						bs170 &= -129;
					}
					break;
				case 1:
					if(v170) {
						bs170 |= 64;
					} else {
						bs170 &= -65;
					}
					break;
				case 2:
					if(v170) {
						bs170 |= 32;
					} else {
						bs170 &= -33;
					}
					break;
				case 3:
					if(v170) {
						bs170 |= 16;
					} else {
						bs170 &= -17;
					}
					break;
				case 4:
					if(v170) {
						bs170 |= 8;
					} else {
						bs170 &= -9;
					}
					break;
				case 5:
					if(v170) {
						bs170 |= 4;
					} else {
						bs170 &= -5;
					}
					break;
				case 6:
					if(v170) {
						bs170 |= 2;
					} else {
						bs170 &= -3;
					}
					break;
				case 7:
					if(v170) {
						bs170 |= 1;
					} else {
						bs170 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs170;
			var this172 = 0;
			var bs171 = this172;
			var l171 = " *** ".length;
			var _g1172 = 0;
			var _g272 = l171;
			while(_g1172 < _g272) {
				var i172 = _g1172++;
				var no171 = " *** ".charCodeAt(i172);
				if(no171 == null) {
					break;
				}
				var v171;
				switch(no171) {
				case 32:
					v171 = false;
					break;
				case 42:
					v171 = true;
					break;
				case 48:
					v171 = false;
					break;
				case 49:
					v171 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i172)));
				}
				switch(i172 - (l171 - 8)) {
				case 0:
					if(v171) {
						bs171 |= 128;
					} else {
						bs171 &= -129;
					}
					break;
				case 1:
					if(v171) {
						bs171 |= 64;
					} else {
						bs171 &= -65;
					}
					break;
				case 2:
					if(v171) {
						bs171 |= 32;
					} else {
						bs171 &= -33;
					}
					break;
				case 3:
					if(v171) {
						bs171 |= 16;
					} else {
						bs171 &= -17;
					}
					break;
				case 4:
					if(v171) {
						bs171 |= 8;
					} else {
						bs171 &= -9;
					}
					break;
				case 5:
					if(v171) {
						bs171 |= 4;
					} else {
						bs171 &= -5;
					}
					break;
				case 6:
					if(v171) {
						bs171 |= 2;
					} else {
						bs171 &= -3;
					}
					break;
				case 7:
					if(v171) {
						bs171 |= 1;
					} else {
						bs171 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs171;
			var this173 = 0;
			var bs172 = this173;
			var l172 = "*   *".length;
			var _g1173 = 0;
			var _g273 = l172;
			while(_g1173 < _g273) {
				var i173 = _g1173++;
				var no172 = "*   *".charCodeAt(i173);
				if(no172 == null) {
					break;
				}
				var v172;
				switch(no172) {
				case 32:
					v172 = false;
					break;
				case 42:
					v172 = true;
					break;
				case 48:
					v172 = false;
					break;
				case 49:
					v172 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i173)));
				}
				switch(i173 - (l172 - 8)) {
				case 0:
					if(v172) {
						bs172 |= 128;
					} else {
						bs172 &= -129;
					}
					break;
				case 1:
					if(v172) {
						bs172 |= 64;
					} else {
						bs172 &= -65;
					}
					break;
				case 2:
					if(v172) {
						bs172 |= 32;
					} else {
						bs172 &= -33;
					}
					break;
				case 3:
					if(v172) {
						bs172 |= 16;
					} else {
						bs172 &= -17;
					}
					break;
				case 4:
					if(v172) {
						bs172 |= 8;
					} else {
						bs172 &= -9;
					}
					break;
				case 5:
					if(v172) {
						bs172 |= 4;
					} else {
						bs172 &= -5;
					}
					break;
				case 6:
					if(v172) {
						bs172 |= 2;
					} else {
						bs172 &= -3;
					}
					break;
				case 7:
					if(v172) {
						bs172 |= 1;
					} else {
						bs172 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs172;
			var this174 = 0;
			var bs173 = this174;
			var l173 = "*   *".length;
			var _g1174 = 0;
			var _g274 = l173;
			while(_g1174 < _g274) {
				var i174 = _g1174++;
				var no173 = "*   *".charCodeAt(i174);
				if(no173 == null) {
					break;
				}
				var v173;
				switch(no173) {
				case 32:
					v173 = false;
					break;
				case 42:
					v173 = true;
					break;
				case 48:
					v173 = false;
					break;
				case 49:
					v173 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i174)));
				}
				switch(i174 - (l173 - 8)) {
				case 0:
					if(v173) {
						bs173 |= 128;
					} else {
						bs173 &= -129;
					}
					break;
				case 1:
					if(v173) {
						bs173 |= 64;
					} else {
						bs173 &= -65;
					}
					break;
				case 2:
					if(v173) {
						bs173 |= 32;
					} else {
						bs173 &= -33;
					}
					break;
				case 3:
					if(v173) {
						bs173 |= 16;
					} else {
						bs173 &= -17;
					}
					break;
				case 4:
					if(v173) {
						bs173 |= 8;
					} else {
						bs173 &= -9;
					}
					break;
				case 5:
					if(v173) {
						bs173 |= 4;
					} else {
						bs173 &= -5;
					}
					break;
				case 6:
					if(v173) {
						bs173 |= 2;
					} else {
						bs173 &= -3;
					}
					break;
				case 7:
					if(v173) {
						bs173 |= 1;
					} else {
						bs173 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs173;
			var this175 = 0;
			var bs174 = this175;
			var l174 = " *** ".length;
			var _g1175 = 0;
			var _g275 = l174;
			while(_g1175 < _g275) {
				var i175 = _g1175++;
				var no174 = " *** ".charCodeAt(i175);
				if(no174 == null) {
					break;
				}
				var v174;
				switch(no174) {
				case 32:
					v174 = false;
					break;
				case 42:
					v174 = true;
					break;
				case 48:
					v174 = false;
					break;
				case 49:
					v174 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i175)));
				}
				switch(i175 - (l174 - 8)) {
				case 0:
					if(v174) {
						bs174 |= 128;
					} else {
						bs174 &= -129;
					}
					break;
				case 1:
					if(v174) {
						bs174 |= 64;
					} else {
						bs174 &= -65;
					}
					break;
				case 2:
					if(v174) {
						bs174 |= 32;
					} else {
						bs174 &= -33;
					}
					break;
				case 3:
					if(v174) {
						bs174 |= 16;
					} else {
						bs174 &= -17;
					}
					break;
				case 4:
					if(v174) {
						bs174 |= 8;
					} else {
						bs174 &= -9;
					}
					break;
				case 5:
					if(v174) {
						bs174 |= 4;
					} else {
						bs174 &= -5;
					}
					break;
				case 6:
					if(v174) {
						bs174 |= 2;
					} else {
						bs174 &= -3;
					}
					break;
				case 7:
					if(v174) {
						bs174 |= 1;
					} else {
						bs174 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs174;
			break;
		case 57:
			var this176 = 0;
			var bs175 = this176;
			var l175 = " *** ".length;
			var _g1176 = 0;
			var _g276 = l175;
			while(_g1176 < _g276) {
				var i176 = _g1176++;
				var no175 = " *** ".charCodeAt(i176);
				if(no175 == null) {
					break;
				}
				var v175;
				switch(no175) {
				case 32:
					v175 = false;
					break;
				case 42:
					v175 = true;
					break;
				case 48:
					v175 = false;
					break;
				case 49:
					v175 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i176)));
				}
				switch(i176 - (l175 - 8)) {
				case 0:
					if(v175) {
						bs175 |= 128;
					} else {
						bs175 &= -129;
					}
					break;
				case 1:
					if(v175) {
						bs175 |= 64;
					} else {
						bs175 &= -65;
					}
					break;
				case 2:
					if(v175) {
						bs175 |= 32;
					} else {
						bs175 &= -33;
					}
					break;
				case 3:
					if(v175) {
						bs175 |= 16;
					} else {
						bs175 &= -17;
					}
					break;
				case 4:
					if(v175) {
						bs175 |= 8;
					} else {
						bs175 &= -9;
					}
					break;
				case 5:
					if(v175) {
						bs175 |= 4;
					} else {
						bs175 &= -5;
					}
					break;
				case 6:
					if(v175) {
						bs175 |= 2;
					} else {
						bs175 &= -3;
					}
					break;
				case 7:
					if(v175) {
						bs175 |= 1;
					} else {
						bs175 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs175;
			var this177 = 0;
			var bs176 = this177;
			var l176 = "*   *".length;
			var _g1177 = 0;
			var _g277 = l176;
			while(_g1177 < _g277) {
				var i177 = _g1177++;
				var no176 = "*   *".charCodeAt(i177);
				if(no176 == null) {
					break;
				}
				var v176;
				switch(no176) {
				case 32:
					v176 = false;
					break;
				case 42:
					v176 = true;
					break;
				case 48:
					v176 = false;
					break;
				case 49:
					v176 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i177)));
				}
				switch(i177 - (l176 - 8)) {
				case 0:
					if(v176) {
						bs176 |= 128;
					} else {
						bs176 &= -129;
					}
					break;
				case 1:
					if(v176) {
						bs176 |= 64;
					} else {
						bs176 &= -65;
					}
					break;
				case 2:
					if(v176) {
						bs176 |= 32;
					} else {
						bs176 &= -33;
					}
					break;
				case 3:
					if(v176) {
						bs176 |= 16;
					} else {
						bs176 &= -17;
					}
					break;
				case 4:
					if(v176) {
						bs176 |= 8;
					} else {
						bs176 &= -9;
					}
					break;
				case 5:
					if(v176) {
						bs176 |= 4;
					} else {
						bs176 &= -5;
					}
					break;
				case 6:
					if(v176) {
						bs176 |= 2;
					} else {
						bs176 &= -3;
					}
					break;
				case 7:
					if(v176) {
						bs176 |= 1;
					} else {
						bs176 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs176;
			var this178 = 0;
			var bs177 = this178;
			var l177 = "*   *".length;
			var _g1178 = 0;
			var _g278 = l177;
			while(_g1178 < _g278) {
				var i178 = _g1178++;
				var no177 = "*   *".charCodeAt(i178);
				if(no177 == null) {
					break;
				}
				var v177;
				switch(no177) {
				case 32:
					v177 = false;
					break;
				case 42:
					v177 = true;
					break;
				case 48:
					v177 = false;
					break;
				case 49:
					v177 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i178)));
				}
				switch(i178 - (l177 - 8)) {
				case 0:
					if(v177) {
						bs177 |= 128;
					} else {
						bs177 &= -129;
					}
					break;
				case 1:
					if(v177) {
						bs177 |= 64;
					} else {
						bs177 &= -65;
					}
					break;
				case 2:
					if(v177) {
						bs177 |= 32;
					} else {
						bs177 &= -33;
					}
					break;
				case 3:
					if(v177) {
						bs177 |= 16;
					} else {
						bs177 &= -17;
					}
					break;
				case 4:
					if(v177) {
						bs177 |= 8;
					} else {
						bs177 &= -9;
					}
					break;
				case 5:
					if(v177) {
						bs177 |= 4;
					} else {
						bs177 &= -5;
					}
					break;
				case 6:
					if(v177) {
						bs177 |= 2;
					} else {
						bs177 &= -3;
					}
					break;
				case 7:
					if(v177) {
						bs177 |= 1;
					} else {
						bs177 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs177;
			var this179 = 0;
			var bs178 = this179;
			var l178 = " ****".length;
			var _g1179 = 0;
			var _g279 = l178;
			while(_g1179 < _g279) {
				var i179 = _g1179++;
				var no178 = " ****".charCodeAt(i179);
				if(no178 == null) {
					break;
				}
				var v178;
				switch(no178) {
				case 32:
					v178 = false;
					break;
				case 42:
					v178 = true;
					break;
				case 48:
					v178 = false;
					break;
				case 49:
					v178 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i179)));
				}
				switch(i179 - (l178 - 8)) {
				case 0:
					if(v178) {
						bs178 |= 128;
					} else {
						bs178 &= -129;
					}
					break;
				case 1:
					if(v178) {
						bs178 |= 64;
					} else {
						bs178 &= -65;
					}
					break;
				case 2:
					if(v178) {
						bs178 |= 32;
					} else {
						bs178 &= -33;
					}
					break;
				case 3:
					if(v178) {
						bs178 |= 16;
					} else {
						bs178 &= -17;
					}
					break;
				case 4:
					if(v178) {
						bs178 |= 8;
					} else {
						bs178 &= -9;
					}
					break;
				case 5:
					if(v178) {
						bs178 |= 4;
					} else {
						bs178 &= -5;
					}
					break;
				case 6:
					if(v178) {
						bs178 |= 2;
					} else {
						bs178 &= -3;
					}
					break;
				case 7:
					if(v178) {
						bs178 |= 1;
					} else {
						bs178 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs178;
			var this180 = 0;
			var bs179 = this180;
			var l179 = "    *".length;
			var _g1180 = 0;
			var _g280 = l179;
			while(_g1180 < _g280) {
				var i180 = _g1180++;
				var no179 = "    *".charCodeAt(i180);
				if(no179 == null) {
					break;
				}
				var v179;
				switch(no179) {
				case 32:
					v179 = false;
					break;
				case 42:
					v179 = true;
					break;
				case 48:
					v179 = false;
					break;
				case 49:
					v179 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i180)));
				}
				switch(i180 - (l179 - 8)) {
				case 0:
					if(v179) {
						bs179 |= 128;
					} else {
						bs179 &= -129;
					}
					break;
				case 1:
					if(v179) {
						bs179 |= 64;
					} else {
						bs179 &= -65;
					}
					break;
				case 2:
					if(v179) {
						bs179 |= 32;
					} else {
						bs179 &= -33;
					}
					break;
				case 3:
					if(v179) {
						bs179 |= 16;
					} else {
						bs179 &= -17;
					}
					break;
				case 4:
					if(v179) {
						bs179 |= 8;
					} else {
						bs179 &= -9;
					}
					break;
				case 5:
					if(v179) {
						bs179 |= 4;
					} else {
						bs179 &= -5;
					}
					break;
				case 6:
					if(v179) {
						bs179 |= 2;
					} else {
						bs179 &= -3;
					}
					break;
				case 7:
					if(v179) {
						bs179 |= 1;
					} else {
						bs179 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs179;
			var this181 = 0;
			var bs180 = this181;
			var l180 = "   * ".length;
			var _g1181 = 0;
			var _g281 = l180;
			while(_g1181 < _g281) {
				var i181 = _g1181++;
				var no180 = "   * ".charCodeAt(i181);
				if(no180 == null) {
					break;
				}
				var v180;
				switch(no180) {
				case 32:
					v180 = false;
					break;
				case 42:
					v180 = true;
					break;
				case 48:
					v180 = false;
					break;
				case 49:
					v180 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i181)));
				}
				switch(i181 - (l180 - 8)) {
				case 0:
					if(v180) {
						bs180 |= 128;
					} else {
						bs180 &= -129;
					}
					break;
				case 1:
					if(v180) {
						bs180 |= 64;
					} else {
						bs180 &= -65;
					}
					break;
				case 2:
					if(v180) {
						bs180 |= 32;
					} else {
						bs180 &= -33;
					}
					break;
				case 3:
					if(v180) {
						bs180 |= 16;
					} else {
						bs180 &= -17;
					}
					break;
				case 4:
					if(v180) {
						bs180 |= 8;
					} else {
						bs180 &= -9;
					}
					break;
				case 5:
					if(v180) {
						bs180 |= 4;
					} else {
						bs180 &= -5;
					}
					break;
				case 6:
					if(v180) {
						bs180 |= 2;
					} else {
						bs180 &= -3;
					}
					break;
				case 7:
					if(v180) {
						bs180 |= 1;
					} else {
						bs180 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs180;
			var this182 = 0;
			var bs181 = this182;
			var l181 = " **  ".length;
			var _g1182 = 0;
			var _g282 = l181;
			while(_g1182 < _g282) {
				var i182 = _g1182++;
				var no181 = " **  ".charCodeAt(i182);
				if(no181 == null) {
					break;
				}
				var v181;
				switch(no181) {
				case 32:
					v181 = false;
					break;
				case 42:
					v181 = true;
					break;
				case 48:
					v181 = false;
					break;
				case 49:
					v181 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i182)));
				}
				switch(i182 - (l181 - 8)) {
				case 0:
					if(v181) {
						bs181 |= 128;
					} else {
						bs181 &= -129;
					}
					break;
				case 1:
					if(v181) {
						bs181 |= 64;
					} else {
						bs181 &= -65;
					}
					break;
				case 2:
					if(v181) {
						bs181 |= 32;
					} else {
						bs181 &= -33;
					}
					break;
				case 3:
					if(v181) {
						bs181 |= 16;
					} else {
						bs181 &= -17;
					}
					break;
				case 4:
					if(v181) {
						bs181 |= 8;
					} else {
						bs181 &= -9;
					}
					break;
				case 5:
					if(v181) {
						bs181 |= 4;
					} else {
						bs181 &= -5;
					}
					break;
				case 6:
					if(v181) {
						bs181 |= 2;
					} else {
						bs181 &= -3;
					}
					break;
				case 7:
					if(v181) {
						bs181 |= 1;
					} else {
						bs181 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs181;
			break;
		case 58:
			var this183 = 0;
			var bs182 = this183;
			var l182 = "     ".length;
			var _g1183 = 0;
			var _g283 = l182;
			while(_g1183 < _g283) {
				var i183 = _g1183++;
				var no182 = "     ".charCodeAt(i183);
				if(no182 == null) {
					break;
				}
				var v182;
				switch(no182) {
				case 32:
					v182 = false;
					break;
				case 42:
					v182 = true;
					break;
				case 48:
					v182 = false;
					break;
				case 49:
					v182 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i183)));
				}
				switch(i183 - (l182 - 8)) {
				case 0:
					if(v182) {
						bs182 |= 128;
					} else {
						bs182 &= -129;
					}
					break;
				case 1:
					if(v182) {
						bs182 |= 64;
					} else {
						bs182 &= -65;
					}
					break;
				case 2:
					if(v182) {
						bs182 |= 32;
					} else {
						bs182 &= -33;
					}
					break;
				case 3:
					if(v182) {
						bs182 |= 16;
					} else {
						bs182 &= -17;
					}
					break;
				case 4:
					if(v182) {
						bs182 |= 8;
					} else {
						bs182 &= -9;
					}
					break;
				case 5:
					if(v182) {
						bs182 |= 4;
					} else {
						bs182 &= -5;
					}
					break;
				case 6:
					if(v182) {
						bs182 |= 2;
					} else {
						bs182 &= -3;
					}
					break;
				case 7:
					if(v182) {
						bs182 |= 1;
					} else {
						bs182 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs182;
			var this184 = 0;
			var bs183 = this184;
			var l183 = "  ** ".length;
			var _g1184 = 0;
			var _g284 = l183;
			while(_g1184 < _g284) {
				var i184 = _g1184++;
				var no183 = "  ** ".charCodeAt(i184);
				if(no183 == null) {
					break;
				}
				var v183;
				switch(no183) {
				case 32:
					v183 = false;
					break;
				case 42:
					v183 = true;
					break;
				case 48:
					v183 = false;
					break;
				case 49:
					v183 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i184)));
				}
				switch(i184 - (l183 - 8)) {
				case 0:
					if(v183) {
						bs183 |= 128;
					} else {
						bs183 &= -129;
					}
					break;
				case 1:
					if(v183) {
						bs183 |= 64;
					} else {
						bs183 &= -65;
					}
					break;
				case 2:
					if(v183) {
						bs183 |= 32;
					} else {
						bs183 &= -33;
					}
					break;
				case 3:
					if(v183) {
						bs183 |= 16;
					} else {
						bs183 &= -17;
					}
					break;
				case 4:
					if(v183) {
						bs183 |= 8;
					} else {
						bs183 &= -9;
					}
					break;
				case 5:
					if(v183) {
						bs183 |= 4;
					} else {
						bs183 &= -5;
					}
					break;
				case 6:
					if(v183) {
						bs183 |= 2;
					} else {
						bs183 &= -3;
					}
					break;
				case 7:
					if(v183) {
						bs183 |= 1;
					} else {
						bs183 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs183;
			var this185 = 0;
			var bs184 = this185;
			var l184 = "  ** ".length;
			var _g1185 = 0;
			var _g285 = l184;
			while(_g1185 < _g285) {
				var i185 = _g1185++;
				var no184 = "  ** ".charCodeAt(i185);
				if(no184 == null) {
					break;
				}
				var v184;
				switch(no184) {
				case 32:
					v184 = false;
					break;
				case 42:
					v184 = true;
					break;
				case 48:
					v184 = false;
					break;
				case 49:
					v184 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i185)));
				}
				switch(i185 - (l184 - 8)) {
				case 0:
					if(v184) {
						bs184 |= 128;
					} else {
						bs184 &= -129;
					}
					break;
				case 1:
					if(v184) {
						bs184 |= 64;
					} else {
						bs184 &= -65;
					}
					break;
				case 2:
					if(v184) {
						bs184 |= 32;
					} else {
						bs184 &= -33;
					}
					break;
				case 3:
					if(v184) {
						bs184 |= 16;
					} else {
						bs184 &= -17;
					}
					break;
				case 4:
					if(v184) {
						bs184 |= 8;
					} else {
						bs184 &= -9;
					}
					break;
				case 5:
					if(v184) {
						bs184 |= 4;
					} else {
						bs184 &= -5;
					}
					break;
				case 6:
					if(v184) {
						bs184 |= 2;
					} else {
						bs184 &= -3;
					}
					break;
				case 7:
					if(v184) {
						bs184 |= 1;
					} else {
						bs184 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs184;
			var this186 = 0;
			var bs185 = this186;
			var l185 = "     ".length;
			var _g1186 = 0;
			var _g286 = l185;
			while(_g1186 < _g286) {
				var i186 = _g1186++;
				var no185 = "     ".charCodeAt(i186);
				if(no185 == null) {
					break;
				}
				var v185;
				switch(no185) {
				case 32:
					v185 = false;
					break;
				case 42:
					v185 = true;
					break;
				case 48:
					v185 = false;
					break;
				case 49:
					v185 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i186)));
				}
				switch(i186 - (l185 - 8)) {
				case 0:
					if(v185) {
						bs185 |= 128;
					} else {
						bs185 &= -129;
					}
					break;
				case 1:
					if(v185) {
						bs185 |= 64;
					} else {
						bs185 &= -65;
					}
					break;
				case 2:
					if(v185) {
						bs185 |= 32;
					} else {
						bs185 &= -33;
					}
					break;
				case 3:
					if(v185) {
						bs185 |= 16;
					} else {
						bs185 &= -17;
					}
					break;
				case 4:
					if(v185) {
						bs185 |= 8;
					} else {
						bs185 &= -9;
					}
					break;
				case 5:
					if(v185) {
						bs185 |= 4;
					} else {
						bs185 &= -5;
					}
					break;
				case 6:
					if(v185) {
						bs185 |= 2;
					} else {
						bs185 &= -3;
					}
					break;
				case 7:
					if(v185) {
						bs185 |= 1;
					} else {
						bs185 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs185;
			var this187 = 0;
			var bs186 = this187;
			var l186 = "  ** ".length;
			var _g1187 = 0;
			var _g287 = l186;
			while(_g1187 < _g287) {
				var i187 = _g1187++;
				var no186 = "  ** ".charCodeAt(i187);
				if(no186 == null) {
					break;
				}
				var v186;
				switch(no186) {
				case 32:
					v186 = false;
					break;
				case 42:
					v186 = true;
					break;
				case 48:
					v186 = false;
					break;
				case 49:
					v186 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i187)));
				}
				switch(i187 - (l186 - 8)) {
				case 0:
					if(v186) {
						bs186 |= 128;
					} else {
						bs186 &= -129;
					}
					break;
				case 1:
					if(v186) {
						bs186 |= 64;
					} else {
						bs186 &= -65;
					}
					break;
				case 2:
					if(v186) {
						bs186 |= 32;
					} else {
						bs186 &= -33;
					}
					break;
				case 3:
					if(v186) {
						bs186 |= 16;
					} else {
						bs186 &= -17;
					}
					break;
				case 4:
					if(v186) {
						bs186 |= 8;
					} else {
						bs186 &= -9;
					}
					break;
				case 5:
					if(v186) {
						bs186 |= 4;
					} else {
						bs186 &= -5;
					}
					break;
				case 6:
					if(v186) {
						bs186 |= 2;
					} else {
						bs186 &= -3;
					}
					break;
				case 7:
					if(v186) {
						bs186 |= 1;
					} else {
						bs186 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs186;
			var this188 = 0;
			var bs187 = this188;
			var l187 = "  ** ".length;
			var _g1188 = 0;
			var _g288 = l187;
			while(_g1188 < _g288) {
				var i188 = _g1188++;
				var no187 = "  ** ".charCodeAt(i188);
				if(no187 == null) {
					break;
				}
				var v187;
				switch(no187) {
				case 32:
					v187 = false;
					break;
				case 42:
					v187 = true;
					break;
				case 48:
					v187 = false;
					break;
				case 49:
					v187 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i188)));
				}
				switch(i188 - (l187 - 8)) {
				case 0:
					if(v187) {
						bs187 |= 128;
					} else {
						bs187 &= -129;
					}
					break;
				case 1:
					if(v187) {
						bs187 |= 64;
					} else {
						bs187 &= -65;
					}
					break;
				case 2:
					if(v187) {
						bs187 |= 32;
					} else {
						bs187 &= -33;
					}
					break;
				case 3:
					if(v187) {
						bs187 |= 16;
					} else {
						bs187 &= -17;
					}
					break;
				case 4:
					if(v187) {
						bs187 |= 8;
					} else {
						bs187 &= -9;
					}
					break;
				case 5:
					if(v187) {
						bs187 |= 4;
					} else {
						bs187 &= -5;
					}
					break;
				case 6:
					if(v187) {
						bs187 |= 2;
					} else {
						bs187 &= -3;
					}
					break;
				case 7:
					if(v187) {
						bs187 |= 1;
					} else {
						bs187 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs187;
			var this189 = 0;
			var bs188 = this189;
			var l188 = "     ".length;
			var _g1189 = 0;
			var _g289 = l188;
			while(_g1189 < _g289) {
				var i189 = _g1189++;
				var no188 = "     ".charCodeAt(i189);
				if(no188 == null) {
					break;
				}
				var v188;
				switch(no188) {
				case 32:
					v188 = false;
					break;
				case 42:
					v188 = true;
					break;
				case 48:
					v188 = false;
					break;
				case 49:
					v188 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i189)));
				}
				switch(i189 - (l188 - 8)) {
				case 0:
					if(v188) {
						bs188 |= 128;
					} else {
						bs188 &= -129;
					}
					break;
				case 1:
					if(v188) {
						bs188 |= 64;
					} else {
						bs188 &= -65;
					}
					break;
				case 2:
					if(v188) {
						bs188 |= 32;
					} else {
						bs188 &= -33;
					}
					break;
				case 3:
					if(v188) {
						bs188 |= 16;
					} else {
						bs188 &= -17;
					}
					break;
				case 4:
					if(v188) {
						bs188 |= 8;
					} else {
						bs188 &= -9;
					}
					break;
				case 5:
					if(v188) {
						bs188 |= 4;
					} else {
						bs188 &= -5;
					}
					break;
				case 6:
					if(v188) {
						bs188 |= 2;
					} else {
						bs188 &= -3;
					}
					break;
				case 7:
					if(v188) {
						bs188 |= 1;
					} else {
						bs188 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs188;
			break;
		case 59:
			var this190 = 0;
			var bs189 = this190;
			var l189 = "     ".length;
			var _g1190 = 0;
			var _g290 = l189;
			while(_g1190 < _g290) {
				var i190 = _g1190++;
				var no189 = "     ".charCodeAt(i190);
				if(no189 == null) {
					break;
				}
				var v189;
				switch(no189) {
				case 32:
					v189 = false;
					break;
				case 42:
					v189 = true;
					break;
				case 48:
					v189 = false;
					break;
				case 49:
					v189 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i190)));
				}
				switch(i190 - (l189 - 8)) {
				case 0:
					if(v189) {
						bs189 |= 128;
					} else {
						bs189 &= -129;
					}
					break;
				case 1:
					if(v189) {
						bs189 |= 64;
					} else {
						bs189 &= -65;
					}
					break;
				case 2:
					if(v189) {
						bs189 |= 32;
					} else {
						bs189 &= -33;
					}
					break;
				case 3:
					if(v189) {
						bs189 |= 16;
					} else {
						bs189 &= -17;
					}
					break;
				case 4:
					if(v189) {
						bs189 |= 8;
					} else {
						bs189 &= -9;
					}
					break;
				case 5:
					if(v189) {
						bs189 |= 4;
					} else {
						bs189 &= -5;
					}
					break;
				case 6:
					if(v189) {
						bs189 |= 2;
					} else {
						bs189 &= -3;
					}
					break;
				case 7:
					if(v189) {
						bs189 |= 1;
					} else {
						bs189 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs189;
			var this191 = 0;
			var bs190 = this191;
			var l190 = "  ** ".length;
			var _g1191 = 0;
			var _g291 = l190;
			while(_g1191 < _g291) {
				var i191 = _g1191++;
				var no190 = "  ** ".charCodeAt(i191);
				if(no190 == null) {
					break;
				}
				var v190;
				switch(no190) {
				case 32:
					v190 = false;
					break;
				case 42:
					v190 = true;
					break;
				case 48:
					v190 = false;
					break;
				case 49:
					v190 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i191)));
				}
				switch(i191 - (l190 - 8)) {
				case 0:
					if(v190) {
						bs190 |= 128;
					} else {
						bs190 &= -129;
					}
					break;
				case 1:
					if(v190) {
						bs190 |= 64;
					} else {
						bs190 &= -65;
					}
					break;
				case 2:
					if(v190) {
						bs190 |= 32;
					} else {
						bs190 &= -33;
					}
					break;
				case 3:
					if(v190) {
						bs190 |= 16;
					} else {
						bs190 &= -17;
					}
					break;
				case 4:
					if(v190) {
						bs190 |= 8;
					} else {
						bs190 &= -9;
					}
					break;
				case 5:
					if(v190) {
						bs190 |= 4;
					} else {
						bs190 &= -5;
					}
					break;
				case 6:
					if(v190) {
						bs190 |= 2;
					} else {
						bs190 &= -3;
					}
					break;
				case 7:
					if(v190) {
						bs190 |= 1;
					} else {
						bs190 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs190;
			var this192 = 0;
			var bs191 = this192;
			var l191 = "  ** ".length;
			var _g1192 = 0;
			var _g292 = l191;
			while(_g1192 < _g292) {
				var i192 = _g1192++;
				var no191 = "  ** ".charCodeAt(i192);
				if(no191 == null) {
					break;
				}
				var v191;
				switch(no191) {
				case 32:
					v191 = false;
					break;
				case 42:
					v191 = true;
					break;
				case 48:
					v191 = false;
					break;
				case 49:
					v191 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i192)));
				}
				switch(i192 - (l191 - 8)) {
				case 0:
					if(v191) {
						bs191 |= 128;
					} else {
						bs191 &= -129;
					}
					break;
				case 1:
					if(v191) {
						bs191 |= 64;
					} else {
						bs191 &= -65;
					}
					break;
				case 2:
					if(v191) {
						bs191 |= 32;
					} else {
						bs191 &= -33;
					}
					break;
				case 3:
					if(v191) {
						bs191 |= 16;
					} else {
						bs191 &= -17;
					}
					break;
				case 4:
					if(v191) {
						bs191 |= 8;
					} else {
						bs191 &= -9;
					}
					break;
				case 5:
					if(v191) {
						bs191 |= 4;
					} else {
						bs191 &= -5;
					}
					break;
				case 6:
					if(v191) {
						bs191 |= 2;
					} else {
						bs191 &= -3;
					}
					break;
				case 7:
					if(v191) {
						bs191 |= 1;
					} else {
						bs191 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs191;
			var this193 = 0;
			var bs192 = this193;
			var l192 = "     ".length;
			var _g1193 = 0;
			var _g293 = l192;
			while(_g1193 < _g293) {
				var i193 = _g1193++;
				var no192 = "     ".charCodeAt(i193);
				if(no192 == null) {
					break;
				}
				var v192;
				switch(no192) {
				case 32:
					v192 = false;
					break;
				case 42:
					v192 = true;
					break;
				case 48:
					v192 = false;
					break;
				case 49:
					v192 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i193)));
				}
				switch(i193 - (l192 - 8)) {
				case 0:
					if(v192) {
						bs192 |= 128;
					} else {
						bs192 &= -129;
					}
					break;
				case 1:
					if(v192) {
						bs192 |= 64;
					} else {
						bs192 &= -65;
					}
					break;
				case 2:
					if(v192) {
						bs192 |= 32;
					} else {
						bs192 &= -33;
					}
					break;
				case 3:
					if(v192) {
						bs192 |= 16;
					} else {
						bs192 &= -17;
					}
					break;
				case 4:
					if(v192) {
						bs192 |= 8;
					} else {
						bs192 &= -9;
					}
					break;
				case 5:
					if(v192) {
						bs192 |= 4;
					} else {
						bs192 &= -5;
					}
					break;
				case 6:
					if(v192) {
						bs192 |= 2;
					} else {
						bs192 &= -3;
					}
					break;
				case 7:
					if(v192) {
						bs192 |= 1;
					} else {
						bs192 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs192;
			var this194 = 0;
			var bs193 = this194;
			var l193 = "  ** ".length;
			var _g1194 = 0;
			var _g294 = l193;
			while(_g1194 < _g294) {
				var i194 = _g1194++;
				var no193 = "  ** ".charCodeAt(i194);
				if(no193 == null) {
					break;
				}
				var v193;
				switch(no193) {
				case 32:
					v193 = false;
					break;
				case 42:
					v193 = true;
					break;
				case 48:
					v193 = false;
					break;
				case 49:
					v193 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i194)));
				}
				switch(i194 - (l193 - 8)) {
				case 0:
					if(v193) {
						bs193 |= 128;
					} else {
						bs193 &= -129;
					}
					break;
				case 1:
					if(v193) {
						bs193 |= 64;
					} else {
						bs193 &= -65;
					}
					break;
				case 2:
					if(v193) {
						bs193 |= 32;
					} else {
						bs193 &= -33;
					}
					break;
				case 3:
					if(v193) {
						bs193 |= 16;
					} else {
						bs193 &= -17;
					}
					break;
				case 4:
					if(v193) {
						bs193 |= 8;
					} else {
						bs193 &= -9;
					}
					break;
				case 5:
					if(v193) {
						bs193 |= 4;
					} else {
						bs193 &= -5;
					}
					break;
				case 6:
					if(v193) {
						bs193 |= 2;
					} else {
						bs193 &= -3;
					}
					break;
				case 7:
					if(v193) {
						bs193 |= 1;
					} else {
						bs193 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs193;
			var this195 = 0;
			var bs194 = this195;
			var l194 = "   * ".length;
			var _g1195 = 0;
			var _g295 = l194;
			while(_g1195 < _g295) {
				var i195 = _g1195++;
				var no194 = "   * ".charCodeAt(i195);
				if(no194 == null) {
					break;
				}
				var v194;
				switch(no194) {
				case 32:
					v194 = false;
					break;
				case 42:
					v194 = true;
					break;
				case 48:
					v194 = false;
					break;
				case 49:
					v194 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i195)));
				}
				switch(i195 - (l194 - 8)) {
				case 0:
					if(v194) {
						bs194 |= 128;
					} else {
						bs194 &= -129;
					}
					break;
				case 1:
					if(v194) {
						bs194 |= 64;
					} else {
						bs194 &= -65;
					}
					break;
				case 2:
					if(v194) {
						bs194 |= 32;
					} else {
						bs194 &= -33;
					}
					break;
				case 3:
					if(v194) {
						bs194 |= 16;
					} else {
						bs194 &= -17;
					}
					break;
				case 4:
					if(v194) {
						bs194 |= 8;
					} else {
						bs194 &= -9;
					}
					break;
				case 5:
					if(v194) {
						bs194 |= 4;
					} else {
						bs194 &= -5;
					}
					break;
				case 6:
					if(v194) {
						bs194 |= 2;
					} else {
						bs194 &= -3;
					}
					break;
				case 7:
					if(v194) {
						bs194 |= 1;
					} else {
						bs194 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs194;
			var this196 = 0;
			var bs195 = this196;
			var l195 = "  *  ".length;
			var _g1196 = 0;
			var _g296 = l195;
			while(_g1196 < _g296) {
				var i196 = _g1196++;
				var no195 = "  *  ".charCodeAt(i196);
				if(no195 == null) {
					break;
				}
				var v195;
				switch(no195) {
				case 32:
					v195 = false;
					break;
				case 42:
					v195 = true;
					break;
				case 48:
					v195 = false;
					break;
				case 49:
					v195 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i196)));
				}
				switch(i196 - (l195 - 8)) {
				case 0:
					if(v195) {
						bs195 |= 128;
					} else {
						bs195 &= -129;
					}
					break;
				case 1:
					if(v195) {
						bs195 |= 64;
					} else {
						bs195 &= -65;
					}
					break;
				case 2:
					if(v195) {
						bs195 |= 32;
					} else {
						bs195 &= -33;
					}
					break;
				case 3:
					if(v195) {
						bs195 |= 16;
					} else {
						bs195 &= -17;
					}
					break;
				case 4:
					if(v195) {
						bs195 |= 8;
					} else {
						bs195 &= -9;
					}
					break;
				case 5:
					if(v195) {
						bs195 |= 4;
					} else {
						bs195 &= -5;
					}
					break;
				case 6:
					if(v195) {
						bs195 |= 2;
					} else {
						bs195 &= -3;
					}
					break;
				case 7:
					if(v195) {
						bs195 |= 1;
					} else {
						bs195 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs195;
			break;
		case 60:
			var this197 = 0;
			var bs196 = this197;
			var l196 = "   * ".length;
			var _g1197 = 0;
			var _g297 = l196;
			while(_g1197 < _g297) {
				var i197 = _g1197++;
				var no196 = "   * ".charCodeAt(i197);
				if(no196 == null) {
					break;
				}
				var v196;
				switch(no196) {
				case 32:
					v196 = false;
					break;
				case 42:
					v196 = true;
					break;
				case 48:
					v196 = false;
					break;
				case 49:
					v196 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i197)));
				}
				switch(i197 - (l196 - 8)) {
				case 0:
					if(v196) {
						bs196 |= 128;
					} else {
						bs196 &= -129;
					}
					break;
				case 1:
					if(v196) {
						bs196 |= 64;
					} else {
						bs196 &= -65;
					}
					break;
				case 2:
					if(v196) {
						bs196 |= 32;
					} else {
						bs196 &= -33;
					}
					break;
				case 3:
					if(v196) {
						bs196 |= 16;
					} else {
						bs196 &= -17;
					}
					break;
				case 4:
					if(v196) {
						bs196 |= 8;
					} else {
						bs196 &= -9;
					}
					break;
				case 5:
					if(v196) {
						bs196 |= 4;
					} else {
						bs196 &= -5;
					}
					break;
				case 6:
					if(v196) {
						bs196 |= 2;
					} else {
						bs196 &= -3;
					}
					break;
				case 7:
					if(v196) {
						bs196 |= 1;
					} else {
						bs196 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs196;
			var this198 = 0;
			var bs197 = this198;
			var l197 = "  *  ".length;
			var _g1198 = 0;
			var _g298 = l197;
			while(_g1198 < _g298) {
				var i198 = _g1198++;
				var no197 = "  *  ".charCodeAt(i198);
				if(no197 == null) {
					break;
				}
				var v197;
				switch(no197) {
				case 32:
					v197 = false;
					break;
				case 42:
					v197 = true;
					break;
				case 48:
					v197 = false;
					break;
				case 49:
					v197 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i198)));
				}
				switch(i198 - (l197 - 8)) {
				case 0:
					if(v197) {
						bs197 |= 128;
					} else {
						bs197 &= -129;
					}
					break;
				case 1:
					if(v197) {
						bs197 |= 64;
					} else {
						bs197 &= -65;
					}
					break;
				case 2:
					if(v197) {
						bs197 |= 32;
					} else {
						bs197 &= -33;
					}
					break;
				case 3:
					if(v197) {
						bs197 |= 16;
					} else {
						bs197 &= -17;
					}
					break;
				case 4:
					if(v197) {
						bs197 |= 8;
					} else {
						bs197 &= -9;
					}
					break;
				case 5:
					if(v197) {
						bs197 |= 4;
					} else {
						bs197 &= -5;
					}
					break;
				case 6:
					if(v197) {
						bs197 |= 2;
					} else {
						bs197 &= -3;
					}
					break;
				case 7:
					if(v197) {
						bs197 |= 1;
					} else {
						bs197 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs197;
			var this199 = 0;
			var bs198 = this199;
			var l198 = " *   ".length;
			var _g1199 = 0;
			var _g299 = l198;
			while(_g1199 < _g299) {
				var i199 = _g1199++;
				var no198 = " *   ".charCodeAt(i199);
				if(no198 == null) {
					break;
				}
				var v198;
				switch(no198) {
				case 32:
					v198 = false;
					break;
				case 42:
					v198 = true;
					break;
				case 48:
					v198 = false;
					break;
				case 49:
					v198 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i199)));
				}
				switch(i199 - (l198 - 8)) {
				case 0:
					if(v198) {
						bs198 |= 128;
					} else {
						bs198 &= -129;
					}
					break;
				case 1:
					if(v198) {
						bs198 |= 64;
					} else {
						bs198 &= -65;
					}
					break;
				case 2:
					if(v198) {
						bs198 |= 32;
					} else {
						bs198 &= -33;
					}
					break;
				case 3:
					if(v198) {
						bs198 |= 16;
					} else {
						bs198 &= -17;
					}
					break;
				case 4:
					if(v198) {
						bs198 |= 8;
					} else {
						bs198 &= -9;
					}
					break;
				case 5:
					if(v198) {
						bs198 |= 4;
					} else {
						bs198 &= -5;
					}
					break;
				case 6:
					if(v198) {
						bs198 |= 2;
					} else {
						bs198 &= -3;
					}
					break;
				case 7:
					if(v198) {
						bs198 |= 1;
					} else {
						bs198 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs198;
			var this200 = 0;
			var bs199 = this200;
			var l199 = "*    ".length;
			var _g1200 = 0;
			var _g300 = l199;
			while(_g1200 < _g300) {
				var i200 = _g1200++;
				var no199 = "*    ".charCodeAt(i200);
				if(no199 == null) {
					break;
				}
				var v199;
				switch(no199) {
				case 32:
					v199 = false;
					break;
				case 42:
					v199 = true;
					break;
				case 48:
					v199 = false;
					break;
				case 49:
					v199 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i200)));
				}
				switch(i200 - (l199 - 8)) {
				case 0:
					if(v199) {
						bs199 |= 128;
					} else {
						bs199 &= -129;
					}
					break;
				case 1:
					if(v199) {
						bs199 |= 64;
					} else {
						bs199 &= -65;
					}
					break;
				case 2:
					if(v199) {
						bs199 |= 32;
					} else {
						bs199 &= -33;
					}
					break;
				case 3:
					if(v199) {
						bs199 |= 16;
					} else {
						bs199 &= -17;
					}
					break;
				case 4:
					if(v199) {
						bs199 |= 8;
					} else {
						bs199 &= -9;
					}
					break;
				case 5:
					if(v199) {
						bs199 |= 4;
					} else {
						bs199 &= -5;
					}
					break;
				case 6:
					if(v199) {
						bs199 |= 2;
					} else {
						bs199 &= -3;
					}
					break;
				case 7:
					if(v199) {
						bs199 |= 1;
					} else {
						bs199 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs199;
			var this201 = 0;
			var bs200 = this201;
			var l200 = " *   ".length;
			var _g1201 = 0;
			var _g301 = l200;
			while(_g1201 < _g301) {
				var i201 = _g1201++;
				var no200 = " *   ".charCodeAt(i201);
				if(no200 == null) {
					break;
				}
				var v200;
				switch(no200) {
				case 32:
					v200 = false;
					break;
				case 42:
					v200 = true;
					break;
				case 48:
					v200 = false;
					break;
				case 49:
					v200 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i201)));
				}
				switch(i201 - (l200 - 8)) {
				case 0:
					if(v200) {
						bs200 |= 128;
					} else {
						bs200 &= -129;
					}
					break;
				case 1:
					if(v200) {
						bs200 |= 64;
					} else {
						bs200 &= -65;
					}
					break;
				case 2:
					if(v200) {
						bs200 |= 32;
					} else {
						bs200 &= -33;
					}
					break;
				case 3:
					if(v200) {
						bs200 |= 16;
					} else {
						bs200 &= -17;
					}
					break;
				case 4:
					if(v200) {
						bs200 |= 8;
					} else {
						bs200 &= -9;
					}
					break;
				case 5:
					if(v200) {
						bs200 |= 4;
					} else {
						bs200 &= -5;
					}
					break;
				case 6:
					if(v200) {
						bs200 |= 2;
					} else {
						bs200 &= -3;
					}
					break;
				case 7:
					if(v200) {
						bs200 |= 1;
					} else {
						bs200 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs200;
			var this202 = 0;
			var bs201 = this202;
			var l201 = "  *  ".length;
			var _g1202 = 0;
			var _g302 = l201;
			while(_g1202 < _g302) {
				var i202 = _g1202++;
				var no201 = "  *  ".charCodeAt(i202);
				if(no201 == null) {
					break;
				}
				var v201;
				switch(no201) {
				case 32:
					v201 = false;
					break;
				case 42:
					v201 = true;
					break;
				case 48:
					v201 = false;
					break;
				case 49:
					v201 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i202)));
				}
				switch(i202 - (l201 - 8)) {
				case 0:
					if(v201) {
						bs201 |= 128;
					} else {
						bs201 &= -129;
					}
					break;
				case 1:
					if(v201) {
						bs201 |= 64;
					} else {
						bs201 &= -65;
					}
					break;
				case 2:
					if(v201) {
						bs201 |= 32;
					} else {
						bs201 &= -33;
					}
					break;
				case 3:
					if(v201) {
						bs201 |= 16;
					} else {
						bs201 &= -17;
					}
					break;
				case 4:
					if(v201) {
						bs201 |= 8;
					} else {
						bs201 &= -9;
					}
					break;
				case 5:
					if(v201) {
						bs201 |= 4;
					} else {
						bs201 &= -5;
					}
					break;
				case 6:
					if(v201) {
						bs201 |= 2;
					} else {
						bs201 &= -3;
					}
					break;
				case 7:
					if(v201) {
						bs201 |= 1;
					} else {
						bs201 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs201;
			var this203 = 0;
			var bs202 = this203;
			var l202 = "   * ".length;
			var _g1203 = 0;
			var _g303 = l202;
			while(_g1203 < _g303) {
				var i203 = _g1203++;
				var no202 = "   * ".charCodeAt(i203);
				if(no202 == null) {
					break;
				}
				var v202;
				switch(no202) {
				case 32:
					v202 = false;
					break;
				case 42:
					v202 = true;
					break;
				case 48:
					v202 = false;
					break;
				case 49:
					v202 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i203)));
				}
				switch(i203 - (l202 - 8)) {
				case 0:
					if(v202) {
						bs202 |= 128;
					} else {
						bs202 &= -129;
					}
					break;
				case 1:
					if(v202) {
						bs202 |= 64;
					} else {
						bs202 &= -65;
					}
					break;
				case 2:
					if(v202) {
						bs202 |= 32;
					} else {
						bs202 &= -33;
					}
					break;
				case 3:
					if(v202) {
						bs202 |= 16;
					} else {
						bs202 &= -17;
					}
					break;
				case 4:
					if(v202) {
						bs202 |= 8;
					} else {
						bs202 &= -9;
					}
					break;
				case 5:
					if(v202) {
						bs202 |= 4;
					} else {
						bs202 &= -5;
					}
					break;
				case 6:
					if(v202) {
						bs202 |= 2;
					} else {
						bs202 &= -3;
					}
					break;
				case 7:
					if(v202) {
						bs202 |= 1;
					} else {
						bs202 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs202;
			break;
		case 61:
			var this204 = 0;
			var bs203 = this204;
			var l203 = "     ".length;
			var _g1204 = 0;
			var _g304 = l203;
			while(_g1204 < _g304) {
				var i204 = _g1204++;
				var no203 = "     ".charCodeAt(i204);
				if(no203 == null) {
					break;
				}
				var v203;
				switch(no203) {
				case 32:
					v203 = false;
					break;
				case 42:
					v203 = true;
					break;
				case 48:
					v203 = false;
					break;
				case 49:
					v203 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i204)));
				}
				switch(i204 - (l203 - 8)) {
				case 0:
					if(v203) {
						bs203 |= 128;
					} else {
						bs203 &= -129;
					}
					break;
				case 1:
					if(v203) {
						bs203 |= 64;
					} else {
						bs203 &= -65;
					}
					break;
				case 2:
					if(v203) {
						bs203 |= 32;
					} else {
						bs203 &= -33;
					}
					break;
				case 3:
					if(v203) {
						bs203 |= 16;
					} else {
						bs203 &= -17;
					}
					break;
				case 4:
					if(v203) {
						bs203 |= 8;
					} else {
						bs203 &= -9;
					}
					break;
				case 5:
					if(v203) {
						bs203 |= 4;
					} else {
						bs203 &= -5;
					}
					break;
				case 6:
					if(v203) {
						bs203 |= 2;
					} else {
						bs203 &= -3;
					}
					break;
				case 7:
					if(v203) {
						bs203 |= 1;
					} else {
						bs203 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs203;
			var this205 = 0;
			var bs204 = this205;
			var l204 = "     ".length;
			var _g1205 = 0;
			var _g305 = l204;
			while(_g1205 < _g305) {
				var i205 = _g1205++;
				var no204 = "     ".charCodeAt(i205);
				if(no204 == null) {
					break;
				}
				var v204;
				switch(no204) {
				case 32:
					v204 = false;
					break;
				case 42:
					v204 = true;
					break;
				case 48:
					v204 = false;
					break;
				case 49:
					v204 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i205)));
				}
				switch(i205 - (l204 - 8)) {
				case 0:
					if(v204) {
						bs204 |= 128;
					} else {
						bs204 &= -129;
					}
					break;
				case 1:
					if(v204) {
						bs204 |= 64;
					} else {
						bs204 &= -65;
					}
					break;
				case 2:
					if(v204) {
						bs204 |= 32;
					} else {
						bs204 &= -33;
					}
					break;
				case 3:
					if(v204) {
						bs204 |= 16;
					} else {
						bs204 &= -17;
					}
					break;
				case 4:
					if(v204) {
						bs204 |= 8;
					} else {
						bs204 &= -9;
					}
					break;
				case 5:
					if(v204) {
						bs204 |= 4;
					} else {
						bs204 &= -5;
					}
					break;
				case 6:
					if(v204) {
						bs204 |= 2;
					} else {
						bs204 &= -3;
					}
					break;
				case 7:
					if(v204) {
						bs204 |= 1;
					} else {
						bs204 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs204;
			var this206 = 0;
			var bs205 = this206;
			var l205 = "*****".length;
			var _g1206 = 0;
			var _g306 = l205;
			while(_g1206 < _g306) {
				var i206 = _g1206++;
				var no205 = "*****".charCodeAt(i206);
				if(no205 == null) {
					break;
				}
				var v205;
				switch(no205) {
				case 32:
					v205 = false;
					break;
				case 42:
					v205 = true;
					break;
				case 48:
					v205 = false;
					break;
				case 49:
					v205 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i206)));
				}
				switch(i206 - (l205 - 8)) {
				case 0:
					if(v205) {
						bs205 |= 128;
					} else {
						bs205 &= -129;
					}
					break;
				case 1:
					if(v205) {
						bs205 |= 64;
					} else {
						bs205 &= -65;
					}
					break;
				case 2:
					if(v205) {
						bs205 |= 32;
					} else {
						bs205 &= -33;
					}
					break;
				case 3:
					if(v205) {
						bs205 |= 16;
					} else {
						bs205 &= -17;
					}
					break;
				case 4:
					if(v205) {
						bs205 |= 8;
					} else {
						bs205 &= -9;
					}
					break;
				case 5:
					if(v205) {
						bs205 |= 4;
					} else {
						bs205 &= -5;
					}
					break;
				case 6:
					if(v205) {
						bs205 |= 2;
					} else {
						bs205 &= -3;
					}
					break;
				case 7:
					if(v205) {
						bs205 |= 1;
					} else {
						bs205 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs205;
			var this207 = 0;
			var bs206 = this207;
			var l206 = "     ".length;
			var _g1207 = 0;
			var _g307 = l206;
			while(_g1207 < _g307) {
				var i207 = _g1207++;
				var no206 = "     ".charCodeAt(i207);
				if(no206 == null) {
					break;
				}
				var v206;
				switch(no206) {
				case 32:
					v206 = false;
					break;
				case 42:
					v206 = true;
					break;
				case 48:
					v206 = false;
					break;
				case 49:
					v206 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i207)));
				}
				switch(i207 - (l206 - 8)) {
				case 0:
					if(v206) {
						bs206 |= 128;
					} else {
						bs206 &= -129;
					}
					break;
				case 1:
					if(v206) {
						bs206 |= 64;
					} else {
						bs206 &= -65;
					}
					break;
				case 2:
					if(v206) {
						bs206 |= 32;
					} else {
						bs206 &= -33;
					}
					break;
				case 3:
					if(v206) {
						bs206 |= 16;
					} else {
						bs206 &= -17;
					}
					break;
				case 4:
					if(v206) {
						bs206 |= 8;
					} else {
						bs206 &= -9;
					}
					break;
				case 5:
					if(v206) {
						bs206 |= 4;
					} else {
						bs206 &= -5;
					}
					break;
				case 6:
					if(v206) {
						bs206 |= 2;
					} else {
						bs206 &= -3;
					}
					break;
				case 7:
					if(v206) {
						bs206 |= 1;
					} else {
						bs206 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs206;
			var this208 = 0;
			var bs207 = this208;
			var l207 = "*****".length;
			var _g1208 = 0;
			var _g308 = l207;
			while(_g1208 < _g308) {
				var i208 = _g1208++;
				var no207 = "*****".charCodeAt(i208);
				if(no207 == null) {
					break;
				}
				var v207;
				switch(no207) {
				case 32:
					v207 = false;
					break;
				case 42:
					v207 = true;
					break;
				case 48:
					v207 = false;
					break;
				case 49:
					v207 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i208)));
				}
				switch(i208 - (l207 - 8)) {
				case 0:
					if(v207) {
						bs207 |= 128;
					} else {
						bs207 &= -129;
					}
					break;
				case 1:
					if(v207) {
						bs207 |= 64;
					} else {
						bs207 &= -65;
					}
					break;
				case 2:
					if(v207) {
						bs207 |= 32;
					} else {
						bs207 &= -33;
					}
					break;
				case 3:
					if(v207) {
						bs207 |= 16;
					} else {
						bs207 &= -17;
					}
					break;
				case 4:
					if(v207) {
						bs207 |= 8;
					} else {
						bs207 &= -9;
					}
					break;
				case 5:
					if(v207) {
						bs207 |= 4;
					} else {
						bs207 &= -5;
					}
					break;
				case 6:
					if(v207) {
						bs207 |= 2;
					} else {
						bs207 &= -3;
					}
					break;
				case 7:
					if(v207) {
						bs207 |= 1;
					} else {
						bs207 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs207;
			var this209 = 0;
			var bs208 = this209;
			var l208 = "     ".length;
			var _g1209 = 0;
			var _g309 = l208;
			while(_g1209 < _g309) {
				var i209 = _g1209++;
				var no208 = "     ".charCodeAt(i209);
				if(no208 == null) {
					break;
				}
				var v208;
				switch(no208) {
				case 32:
					v208 = false;
					break;
				case 42:
					v208 = true;
					break;
				case 48:
					v208 = false;
					break;
				case 49:
					v208 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i209)));
				}
				switch(i209 - (l208 - 8)) {
				case 0:
					if(v208) {
						bs208 |= 128;
					} else {
						bs208 &= -129;
					}
					break;
				case 1:
					if(v208) {
						bs208 |= 64;
					} else {
						bs208 &= -65;
					}
					break;
				case 2:
					if(v208) {
						bs208 |= 32;
					} else {
						bs208 &= -33;
					}
					break;
				case 3:
					if(v208) {
						bs208 |= 16;
					} else {
						bs208 &= -17;
					}
					break;
				case 4:
					if(v208) {
						bs208 |= 8;
					} else {
						bs208 &= -9;
					}
					break;
				case 5:
					if(v208) {
						bs208 |= 4;
					} else {
						bs208 &= -5;
					}
					break;
				case 6:
					if(v208) {
						bs208 |= 2;
					} else {
						bs208 &= -3;
					}
					break;
				case 7:
					if(v208) {
						bs208 |= 1;
					} else {
						bs208 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs208;
			var this210 = 0;
			var bs209 = this210;
			var l209 = "     ".length;
			var _g1210 = 0;
			var _g310 = l209;
			while(_g1210 < _g310) {
				var i210 = _g1210++;
				var no209 = "     ".charCodeAt(i210);
				if(no209 == null) {
					break;
				}
				var v209;
				switch(no209) {
				case 32:
					v209 = false;
					break;
				case 42:
					v209 = true;
					break;
				case 48:
					v209 = false;
					break;
				case 49:
					v209 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i210)));
				}
				switch(i210 - (l209 - 8)) {
				case 0:
					if(v209) {
						bs209 |= 128;
					} else {
						bs209 &= -129;
					}
					break;
				case 1:
					if(v209) {
						bs209 |= 64;
					} else {
						bs209 &= -65;
					}
					break;
				case 2:
					if(v209) {
						bs209 |= 32;
					} else {
						bs209 &= -33;
					}
					break;
				case 3:
					if(v209) {
						bs209 |= 16;
					} else {
						bs209 &= -17;
					}
					break;
				case 4:
					if(v209) {
						bs209 |= 8;
					} else {
						bs209 &= -9;
					}
					break;
				case 5:
					if(v209) {
						bs209 |= 4;
					} else {
						bs209 &= -5;
					}
					break;
				case 6:
					if(v209) {
						bs209 |= 2;
					} else {
						bs209 &= -3;
					}
					break;
				case 7:
					if(v209) {
						bs209 |= 1;
					} else {
						bs209 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs209;
			break;
		case 62:
			var this211 = 0;
			var bs210 = this211;
			var l210 = " *   ".length;
			var _g1211 = 0;
			var _g311 = l210;
			while(_g1211 < _g311) {
				var i211 = _g1211++;
				var no210 = " *   ".charCodeAt(i211);
				if(no210 == null) {
					break;
				}
				var v210;
				switch(no210) {
				case 32:
					v210 = false;
					break;
				case 42:
					v210 = true;
					break;
				case 48:
					v210 = false;
					break;
				case 49:
					v210 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i211)));
				}
				switch(i211 - (l210 - 8)) {
				case 0:
					if(v210) {
						bs210 |= 128;
					} else {
						bs210 &= -129;
					}
					break;
				case 1:
					if(v210) {
						bs210 |= 64;
					} else {
						bs210 &= -65;
					}
					break;
				case 2:
					if(v210) {
						bs210 |= 32;
					} else {
						bs210 &= -33;
					}
					break;
				case 3:
					if(v210) {
						bs210 |= 16;
					} else {
						bs210 &= -17;
					}
					break;
				case 4:
					if(v210) {
						bs210 |= 8;
					} else {
						bs210 &= -9;
					}
					break;
				case 5:
					if(v210) {
						bs210 |= 4;
					} else {
						bs210 &= -5;
					}
					break;
				case 6:
					if(v210) {
						bs210 |= 2;
					} else {
						bs210 &= -3;
					}
					break;
				case 7:
					if(v210) {
						bs210 |= 1;
					} else {
						bs210 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs210;
			var this212 = 0;
			var bs211 = this212;
			var l211 = "  *  ".length;
			var _g1212 = 0;
			var _g312 = l211;
			while(_g1212 < _g312) {
				var i212 = _g1212++;
				var no211 = "  *  ".charCodeAt(i212);
				if(no211 == null) {
					break;
				}
				var v211;
				switch(no211) {
				case 32:
					v211 = false;
					break;
				case 42:
					v211 = true;
					break;
				case 48:
					v211 = false;
					break;
				case 49:
					v211 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i212)));
				}
				switch(i212 - (l211 - 8)) {
				case 0:
					if(v211) {
						bs211 |= 128;
					} else {
						bs211 &= -129;
					}
					break;
				case 1:
					if(v211) {
						bs211 |= 64;
					} else {
						bs211 &= -65;
					}
					break;
				case 2:
					if(v211) {
						bs211 |= 32;
					} else {
						bs211 &= -33;
					}
					break;
				case 3:
					if(v211) {
						bs211 |= 16;
					} else {
						bs211 &= -17;
					}
					break;
				case 4:
					if(v211) {
						bs211 |= 8;
					} else {
						bs211 &= -9;
					}
					break;
				case 5:
					if(v211) {
						bs211 |= 4;
					} else {
						bs211 &= -5;
					}
					break;
				case 6:
					if(v211) {
						bs211 |= 2;
					} else {
						bs211 &= -3;
					}
					break;
				case 7:
					if(v211) {
						bs211 |= 1;
					} else {
						bs211 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs211;
			var this213 = 0;
			var bs212 = this213;
			var l212 = "   * ".length;
			var _g1213 = 0;
			var _g313 = l212;
			while(_g1213 < _g313) {
				var i213 = _g1213++;
				var no212 = "   * ".charCodeAt(i213);
				if(no212 == null) {
					break;
				}
				var v212;
				switch(no212) {
				case 32:
					v212 = false;
					break;
				case 42:
					v212 = true;
					break;
				case 48:
					v212 = false;
					break;
				case 49:
					v212 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i213)));
				}
				switch(i213 - (l212 - 8)) {
				case 0:
					if(v212) {
						bs212 |= 128;
					} else {
						bs212 &= -129;
					}
					break;
				case 1:
					if(v212) {
						bs212 |= 64;
					} else {
						bs212 &= -65;
					}
					break;
				case 2:
					if(v212) {
						bs212 |= 32;
					} else {
						bs212 &= -33;
					}
					break;
				case 3:
					if(v212) {
						bs212 |= 16;
					} else {
						bs212 &= -17;
					}
					break;
				case 4:
					if(v212) {
						bs212 |= 8;
					} else {
						bs212 &= -9;
					}
					break;
				case 5:
					if(v212) {
						bs212 |= 4;
					} else {
						bs212 &= -5;
					}
					break;
				case 6:
					if(v212) {
						bs212 |= 2;
					} else {
						bs212 &= -3;
					}
					break;
				case 7:
					if(v212) {
						bs212 |= 1;
					} else {
						bs212 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs212;
			var this214 = 0;
			var bs213 = this214;
			var l213 = "    *".length;
			var _g1214 = 0;
			var _g314 = l213;
			while(_g1214 < _g314) {
				var i214 = _g1214++;
				var no213 = "    *".charCodeAt(i214);
				if(no213 == null) {
					break;
				}
				var v213;
				switch(no213) {
				case 32:
					v213 = false;
					break;
				case 42:
					v213 = true;
					break;
				case 48:
					v213 = false;
					break;
				case 49:
					v213 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i214)));
				}
				switch(i214 - (l213 - 8)) {
				case 0:
					if(v213) {
						bs213 |= 128;
					} else {
						bs213 &= -129;
					}
					break;
				case 1:
					if(v213) {
						bs213 |= 64;
					} else {
						bs213 &= -65;
					}
					break;
				case 2:
					if(v213) {
						bs213 |= 32;
					} else {
						bs213 &= -33;
					}
					break;
				case 3:
					if(v213) {
						bs213 |= 16;
					} else {
						bs213 &= -17;
					}
					break;
				case 4:
					if(v213) {
						bs213 |= 8;
					} else {
						bs213 &= -9;
					}
					break;
				case 5:
					if(v213) {
						bs213 |= 4;
					} else {
						bs213 &= -5;
					}
					break;
				case 6:
					if(v213) {
						bs213 |= 2;
					} else {
						bs213 &= -3;
					}
					break;
				case 7:
					if(v213) {
						bs213 |= 1;
					} else {
						bs213 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs213;
			var this215 = 0;
			var bs214 = this215;
			var l214 = "   * ".length;
			var _g1215 = 0;
			var _g315 = l214;
			while(_g1215 < _g315) {
				var i215 = _g1215++;
				var no214 = "   * ".charCodeAt(i215);
				if(no214 == null) {
					break;
				}
				var v214;
				switch(no214) {
				case 32:
					v214 = false;
					break;
				case 42:
					v214 = true;
					break;
				case 48:
					v214 = false;
					break;
				case 49:
					v214 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i215)));
				}
				switch(i215 - (l214 - 8)) {
				case 0:
					if(v214) {
						bs214 |= 128;
					} else {
						bs214 &= -129;
					}
					break;
				case 1:
					if(v214) {
						bs214 |= 64;
					} else {
						bs214 &= -65;
					}
					break;
				case 2:
					if(v214) {
						bs214 |= 32;
					} else {
						bs214 &= -33;
					}
					break;
				case 3:
					if(v214) {
						bs214 |= 16;
					} else {
						bs214 &= -17;
					}
					break;
				case 4:
					if(v214) {
						bs214 |= 8;
					} else {
						bs214 &= -9;
					}
					break;
				case 5:
					if(v214) {
						bs214 |= 4;
					} else {
						bs214 &= -5;
					}
					break;
				case 6:
					if(v214) {
						bs214 |= 2;
					} else {
						bs214 &= -3;
					}
					break;
				case 7:
					if(v214) {
						bs214 |= 1;
					} else {
						bs214 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs214;
			var this216 = 0;
			var bs215 = this216;
			var l215 = "  *  ".length;
			var _g1216 = 0;
			var _g316 = l215;
			while(_g1216 < _g316) {
				var i216 = _g1216++;
				var no215 = "  *  ".charCodeAt(i216);
				if(no215 == null) {
					break;
				}
				var v215;
				switch(no215) {
				case 32:
					v215 = false;
					break;
				case 42:
					v215 = true;
					break;
				case 48:
					v215 = false;
					break;
				case 49:
					v215 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i216)));
				}
				switch(i216 - (l215 - 8)) {
				case 0:
					if(v215) {
						bs215 |= 128;
					} else {
						bs215 &= -129;
					}
					break;
				case 1:
					if(v215) {
						bs215 |= 64;
					} else {
						bs215 &= -65;
					}
					break;
				case 2:
					if(v215) {
						bs215 |= 32;
					} else {
						bs215 &= -33;
					}
					break;
				case 3:
					if(v215) {
						bs215 |= 16;
					} else {
						bs215 &= -17;
					}
					break;
				case 4:
					if(v215) {
						bs215 |= 8;
					} else {
						bs215 &= -9;
					}
					break;
				case 5:
					if(v215) {
						bs215 |= 4;
					} else {
						bs215 &= -5;
					}
					break;
				case 6:
					if(v215) {
						bs215 |= 2;
					} else {
						bs215 &= -3;
					}
					break;
				case 7:
					if(v215) {
						bs215 |= 1;
					} else {
						bs215 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs215;
			var this217 = 0;
			var bs216 = this217;
			var l216 = " *   ".length;
			var _g1217 = 0;
			var _g317 = l216;
			while(_g1217 < _g317) {
				var i217 = _g1217++;
				var no216 = " *   ".charCodeAt(i217);
				if(no216 == null) {
					break;
				}
				var v216;
				switch(no216) {
				case 32:
					v216 = false;
					break;
				case 42:
					v216 = true;
					break;
				case 48:
					v216 = false;
					break;
				case 49:
					v216 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i217)));
				}
				switch(i217 - (l216 - 8)) {
				case 0:
					if(v216) {
						bs216 |= 128;
					} else {
						bs216 &= -129;
					}
					break;
				case 1:
					if(v216) {
						bs216 |= 64;
					} else {
						bs216 &= -65;
					}
					break;
				case 2:
					if(v216) {
						bs216 |= 32;
					} else {
						bs216 &= -33;
					}
					break;
				case 3:
					if(v216) {
						bs216 |= 16;
					} else {
						bs216 &= -17;
					}
					break;
				case 4:
					if(v216) {
						bs216 |= 8;
					} else {
						bs216 &= -9;
					}
					break;
				case 5:
					if(v216) {
						bs216 |= 4;
					} else {
						bs216 &= -5;
					}
					break;
				case 6:
					if(v216) {
						bs216 |= 2;
					} else {
						bs216 &= -3;
					}
					break;
				case 7:
					if(v216) {
						bs216 |= 1;
					} else {
						bs216 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs216;
			break;
		case 63:
			var this218 = 0;
			var bs217 = this218;
			var l217 = " *** ".length;
			var _g1218 = 0;
			var _g318 = l217;
			while(_g1218 < _g318) {
				var i218 = _g1218++;
				var no217 = " *** ".charCodeAt(i218);
				if(no217 == null) {
					break;
				}
				var v217;
				switch(no217) {
				case 32:
					v217 = false;
					break;
				case 42:
					v217 = true;
					break;
				case 48:
					v217 = false;
					break;
				case 49:
					v217 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i218)));
				}
				switch(i218 - (l217 - 8)) {
				case 0:
					if(v217) {
						bs217 |= 128;
					} else {
						bs217 &= -129;
					}
					break;
				case 1:
					if(v217) {
						bs217 |= 64;
					} else {
						bs217 &= -65;
					}
					break;
				case 2:
					if(v217) {
						bs217 |= 32;
					} else {
						bs217 &= -33;
					}
					break;
				case 3:
					if(v217) {
						bs217 |= 16;
					} else {
						bs217 &= -17;
					}
					break;
				case 4:
					if(v217) {
						bs217 |= 8;
					} else {
						bs217 &= -9;
					}
					break;
				case 5:
					if(v217) {
						bs217 |= 4;
					} else {
						bs217 &= -5;
					}
					break;
				case 6:
					if(v217) {
						bs217 |= 2;
					} else {
						bs217 &= -3;
					}
					break;
				case 7:
					if(v217) {
						bs217 |= 1;
					} else {
						bs217 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs217;
			var this219 = 0;
			var bs218 = this219;
			var l218 = "*   *".length;
			var _g1219 = 0;
			var _g319 = l218;
			while(_g1219 < _g319) {
				var i219 = _g1219++;
				var no218 = "*   *".charCodeAt(i219);
				if(no218 == null) {
					break;
				}
				var v218;
				switch(no218) {
				case 32:
					v218 = false;
					break;
				case 42:
					v218 = true;
					break;
				case 48:
					v218 = false;
					break;
				case 49:
					v218 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i219)));
				}
				switch(i219 - (l218 - 8)) {
				case 0:
					if(v218) {
						bs218 |= 128;
					} else {
						bs218 &= -129;
					}
					break;
				case 1:
					if(v218) {
						bs218 |= 64;
					} else {
						bs218 &= -65;
					}
					break;
				case 2:
					if(v218) {
						bs218 |= 32;
					} else {
						bs218 &= -33;
					}
					break;
				case 3:
					if(v218) {
						bs218 |= 16;
					} else {
						bs218 &= -17;
					}
					break;
				case 4:
					if(v218) {
						bs218 |= 8;
					} else {
						bs218 &= -9;
					}
					break;
				case 5:
					if(v218) {
						bs218 |= 4;
					} else {
						bs218 &= -5;
					}
					break;
				case 6:
					if(v218) {
						bs218 |= 2;
					} else {
						bs218 &= -3;
					}
					break;
				case 7:
					if(v218) {
						bs218 |= 1;
					} else {
						bs218 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs218;
			var this220 = 0;
			var bs219 = this220;
			var l219 = "    *".length;
			var _g1220 = 0;
			var _g320 = l219;
			while(_g1220 < _g320) {
				var i220 = _g1220++;
				var no219 = "    *".charCodeAt(i220);
				if(no219 == null) {
					break;
				}
				var v219;
				switch(no219) {
				case 32:
					v219 = false;
					break;
				case 42:
					v219 = true;
					break;
				case 48:
					v219 = false;
					break;
				case 49:
					v219 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i220)));
				}
				switch(i220 - (l219 - 8)) {
				case 0:
					if(v219) {
						bs219 |= 128;
					} else {
						bs219 &= -129;
					}
					break;
				case 1:
					if(v219) {
						bs219 |= 64;
					} else {
						bs219 &= -65;
					}
					break;
				case 2:
					if(v219) {
						bs219 |= 32;
					} else {
						bs219 &= -33;
					}
					break;
				case 3:
					if(v219) {
						bs219 |= 16;
					} else {
						bs219 &= -17;
					}
					break;
				case 4:
					if(v219) {
						bs219 |= 8;
					} else {
						bs219 &= -9;
					}
					break;
				case 5:
					if(v219) {
						bs219 |= 4;
					} else {
						bs219 &= -5;
					}
					break;
				case 6:
					if(v219) {
						bs219 |= 2;
					} else {
						bs219 &= -3;
					}
					break;
				case 7:
					if(v219) {
						bs219 |= 1;
					} else {
						bs219 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs219;
			var this221 = 0;
			var bs220 = this221;
			var l220 = "   * ".length;
			var _g1221 = 0;
			var _g321 = l220;
			while(_g1221 < _g321) {
				var i221 = _g1221++;
				var no220 = "   * ".charCodeAt(i221);
				if(no220 == null) {
					break;
				}
				var v220;
				switch(no220) {
				case 32:
					v220 = false;
					break;
				case 42:
					v220 = true;
					break;
				case 48:
					v220 = false;
					break;
				case 49:
					v220 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i221)));
				}
				switch(i221 - (l220 - 8)) {
				case 0:
					if(v220) {
						bs220 |= 128;
					} else {
						bs220 &= -129;
					}
					break;
				case 1:
					if(v220) {
						bs220 |= 64;
					} else {
						bs220 &= -65;
					}
					break;
				case 2:
					if(v220) {
						bs220 |= 32;
					} else {
						bs220 &= -33;
					}
					break;
				case 3:
					if(v220) {
						bs220 |= 16;
					} else {
						bs220 &= -17;
					}
					break;
				case 4:
					if(v220) {
						bs220 |= 8;
					} else {
						bs220 &= -9;
					}
					break;
				case 5:
					if(v220) {
						bs220 |= 4;
					} else {
						bs220 &= -5;
					}
					break;
				case 6:
					if(v220) {
						bs220 |= 2;
					} else {
						bs220 &= -3;
					}
					break;
				case 7:
					if(v220) {
						bs220 |= 1;
					} else {
						bs220 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs220;
			var this222 = 0;
			var bs221 = this222;
			var l221 = "  *  ".length;
			var _g1222 = 0;
			var _g322 = l221;
			while(_g1222 < _g322) {
				var i222 = _g1222++;
				var no221 = "  *  ".charCodeAt(i222);
				if(no221 == null) {
					break;
				}
				var v221;
				switch(no221) {
				case 32:
					v221 = false;
					break;
				case 42:
					v221 = true;
					break;
				case 48:
					v221 = false;
					break;
				case 49:
					v221 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i222)));
				}
				switch(i222 - (l221 - 8)) {
				case 0:
					if(v221) {
						bs221 |= 128;
					} else {
						bs221 &= -129;
					}
					break;
				case 1:
					if(v221) {
						bs221 |= 64;
					} else {
						bs221 &= -65;
					}
					break;
				case 2:
					if(v221) {
						bs221 |= 32;
					} else {
						bs221 &= -33;
					}
					break;
				case 3:
					if(v221) {
						bs221 |= 16;
					} else {
						bs221 &= -17;
					}
					break;
				case 4:
					if(v221) {
						bs221 |= 8;
					} else {
						bs221 &= -9;
					}
					break;
				case 5:
					if(v221) {
						bs221 |= 4;
					} else {
						bs221 &= -5;
					}
					break;
				case 6:
					if(v221) {
						bs221 |= 2;
					} else {
						bs221 &= -3;
					}
					break;
				case 7:
					if(v221) {
						bs221 |= 1;
					} else {
						bs221 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs221;
			var this223 = 0;
			var bs222 = this223;
			var l222 = "     ".length;
			var _g1223 = 0;
			var _g323 = l222;
			while(_g1223 < _g323) {
				var i223 = _g1223++;
				var no222 = "     ".charCodeAt(i223);
				if(no222 == null) {
					break;
				}
				var v222;
				switch(no222) {
				case 32:
					v222 = false;
					break;
				case 42:
					v222 = true;
					break;
				case 48:
					v222 = false;
					break;
				case 49:
					v222 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i223)));
				}
				switch(i223 - (l222 - 8)) {
				case 0:
					if(v222) {
						bs222 |= 128;
					} else {
						bs222 &= -129;
					}
					break;
				case 1:
					if(v222) {
						bs222 |= 64;
					} else {
						bs222 &= -65;
					}
					break;
				case 2:
					if(v222) {
						bs222 |= 32;
					} else {
						bs222 &= -33;
					}
					break;
				case 3:
					if(v222) {
						bs222 |= 16;
					} else {
						bs222 &= -17;
					}
					break;
				case 4:
					if(v222) {
						bs222 |= 8;
					} else {
						bs222 &= -9;
					}
					break;
				case 5:
					if(v222) {
						bs222 |= 4;
					} else {
						bs222 &= -5;
					}
					break;
				case 6:
					if(v222) {
						bs222 |= 2;
					} else {
						bs222 &= -3;
					}
					break;
				case 7:
					if(v222) {
						bs222 |= 1;
					} else {
						bs222 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs222;
			var this224 = 0;
			var bs223 = this224;
			var l223 = "  *  ".length;
			var _g1224 = 0;
			var _g324 = l223;
			while(_g1224 < _g324) {
				var i224 = _g1224++;
				var no223 = "  *  ".charCodeAt(i224);
				if(no223 == null) {
					break;
				}
				var v223;
				switch(no223) {
				case 32:
					v223 = false;
					break;
				case 42:
					v223 = true;
					break;
				case 48:
					v223 = false;
					break;
				case 49:
					v223 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i224)));
				}
				switch(i224 - (l223 - 8)) {
				case 0:
					if(v223) {
						bs223 |= 128;
					} else {
						bs223 &= -129;
					}
					break;
				case 1:
					if(v223) {
						bs223 |= 64;
					} else {
						bs223 &= -65;
					}
					break;
				case 2:
					if(v223) {
						bs223 |= 32;
					} else {
						bs223 &= -33;
					}
					break;
				case 3:
					if(v223) {
						bs223 |= 16;
					} else {
						bs223 &= -17;
					}
					break;
				case 4:
					if(v223) {
						bs223 |= 8;
					} else {
						bs223 &= -9;
					}
					break;
				case 5:
					if(v223) {
						bs223 |= 4;
					} else {
						bs223 &= -5;
					}
					break;
				case 6:
					if(v223) {
						bs223 |= 2;
					} else {
						bs223 &= -3;
					}
					break;
				case 7:
					if(v223) {
						bs223 |= 1;
					} else {
						bs223 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs223;
			break;
		case 64:
			var this225 = 0;
			var bs224 = this225;
			var l224 = " *** ".length;
			var _g1225 = 0;
			var _g325 = l224;
			while(_g1225 < _g325) {
				var i225 = _g1225++;
				var no224 = " *** ".charCodeAt(i225);
				if(no224 == null) {
					break;
				}
				var v224;
				switch(no224) {
				case 32:
					v224 = false;
					break;
				case 42:
					v224 = true;
					break;
				case 48:
					v224 = false;
					break;
				case 49:
					v224 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i225)));
				}
				switch(i225 - (l224 - 8)) {
				case 0:
					if(v224) {
						bs224 |= 128;
					} else {
						bs224 &= -129;
					}
					break;
				case 1:
					if(v224) {
						bs224 |= 64;
					} else {
						bs224 &= -65;
					}
					break;
				case 2:
					if(v224) {
						bs224 |= 32;
					} else {
						bs224 &= -33;
					}
					break;
				case 3:
					if(v224) {
						bs224 |= 16;
					} else {
						bs224 &= -17;
					}
					break;
				case 4:
					if(v224) {
						bs224 |= 8;
					} else {
						bs224 &= -9;
					}
					break;
				case 5:
					if(v224) {
						bs224 |= 4;
					} else {
						bs224 &= -5;
					}
					break;
				case 6:
					if(v224) {
						bs224 |= 2;
					} else {
						bs224 &= -3;
					}
					break;
				case 7:
					if(v224) {
						bs224 |= 1;
					} else {
						bs224 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs224;
			var this226 = 0;
			var bs225 = this226;
			var l225 = "*   *".length;
			var _g1226 = 0;
			var _g326 = l225;
			while(_g1226 < _g326) {
				var i226 = _g1226++;
				var no225 = "*   *".charCodeAt(i226);
				if(no225 == null) {
					break;
				}
				var v225;
				switch(no225) {
				case 32:
					v225 = false;
					break;
				case 42:
					v225 = true;
					break;
				case 48:
					v225 = false;
					break;
				case 49:
					v225 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i226)));
				}
				switch(i226 - (l225 - 8)) {
				case 0:
					if(v225) {
						bs225 |= 128;
					} else {
						bs225 &= -129;
					}
					break;
				case 1:
					if(v225) {
						bs225 |= 64;
					} else {
						bs225 &= -65;
					}
					break;
				case 2:
					if(v225) {
						bs225 |= 32;
					} else {
						bs225 &= -33;
					}
					break;
				case 3:
					if(v225) {
						bs225 |= 16;
					} else {
						bs225 &= -17;
					}
					break;
				case 4:
					if(v225) {
						bs225 |= 8;
					} else {
						bs225 &= -9;
					}
					break;
				case 5:
					if(v225) {
						bs225 |= 4;
					} else {
						bs225 &= -5;
					}
					break;
				case 6:
					if(v225) {
						bs225 |= 2;
					} else {
						bs225 &= -3;
					}
					break;
				case 7:
					if(v225) {
						bs225 |= 1;
					} else {
						bs225 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs225;
			var this227 = 0;
			var bs226 = this227;
			var l226 = "    *".length;
			var _g1227 = 0;
			var _g327 = l226;
			while(_g1227 < _g327) {
				var i227 = _g1227++;
				var no226 = "    *".charCodeAt(i227);
				if(no226 == null) {
					break;
				}
				var v226;
				switch(no226) {
				case 32:
					v226 = false;
					break;
				case 42:
					v226 = true;
					break;
				case 48:
					v226 = false;
					break;
				case 49:
					v226 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i227)));
				}
				switch(i227 - (l226 - 8)) {
				case 0:
					if(v226) {
						bs226 |= 128;
					} else {
						bs226 &= -129;
					}
					break;
				case 1:
					if(v226) {
						bs226 |= 64;
					} else {
						bs226 &= -65;
					}
					break;
				case 2:
					if(v226) {
						bs226 |= 32;
					} else {
						bs226 &= -33;
					}
					break;
				case 3:
					if(v226) {
						bs226 |= 16;
					} else {
						bs226 &= -17;
					}
					break;
				case 4:
					if(v226) {
						bs226 |= 8;
					} else {
						bs226 &= -9;
					}
					break;
				case 5:
					if(v226) {
						bs226 |= 4;
					} else {
						bs226 &= -5;
					}
					break;
				case 6:
					if(v226) {
						bs226 |= 2;
					} else {
						bs226 &= -3;
					}
					break;
				case 7:
					if(v226) {
						bs226 |= 1;
					} else {
						bs226 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs226;
			var this228 = 0;
			var bs227 = this228;
			var l227 = " ** *".length;
			var _g1228 = 0;
			var _g328 = l227;
			while(_g1228 < _g328) {
				var i228 = _g1228++;
				var no227 = " ** *".charCodeAt(i228);
				if(no227 == null) {
					break;
				}
				var v227;
				switch(no227) {
				case 32:
					v227 = false;
					break;
				case 42:
					v227 = true;
					break;
				case 48:
					v227 = false;
					break;
				case 49:
					v227 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i228)));
				}
				switch(i228 - (l227 - 8)) {
				case 0:
					if(v227) {
						bs227 |= 128;
					} else {
						bs227 &= -129;
					}
					break;
				case 1:
					if(v227) {
						bs227 |= 64;
					} else {
						bs227 &= -65;
					}
					break;
				case 2:
					if(v227) {
						bs227 |= 32;
					} else {
						bs227 &= -33;
					}
					break;
				case 3:
					if(v227) {
						bs227 |= 16;
					} else {
						bs227 &= -17;
					}
					break;
				case 4:
					if(v227) {
						bs227 |= 8;
					} else {
						bs227 &= -9;
					}
					break;
				case 5:
					if(v227) {
						bs227 |= 4;
					} else {
						bs227 &= -5;
					}
					break;
				case 6:
					if(v227) {
						bs227 |= 2;
					} else {
						bs227 &= -3;
					}
					break;
				case 7:
					if(v227) {
						bs227 |= 1;
					} else {
						bs227 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs227;
			var this229 = 0;
			var bs228 = this229;
			var l228 = "* * *".length;
			var _g1229 = 0;
			var _g329 = l228;
			while(_g1229 < _g329) {
				var i229 = _g1229++;
				var no228 = "* * *".charCodeAt(i229);
				if(no228 == null) {
					break;
				}
				var v228;
				switch(no228) {
				case 32:
					v228 = false;
					break;
				case 42:
					v228 = true;
					break;
				case 48:
					v228 = false;
					break;
				case 49:
					v228 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i229)));
				}
				switch(i229 - (l228 - 8)) {
				case 0:
					if(v228) {
						bs228 |= 128;
					} else {
						bs228 &= -129;
					}
					break;
				case 1:
					if(v228) {
						bs228 |= 64;
					} else {
						bs228 &= -65;
					}
					break;
				case 2:
					if(v228) {
						bs228 |= 32;
					} else {
						bs228 &= -33;
					}
					break;
				case 3:
					if(v228) {
						bs228 |= 16;
					} else {
						bs228 &= -17;
					}
					break;
				case 4:
					if(v228) {
						bs228 |= 8;
					} else {
						bs228 &= -9;
					}
					break;
				case 5:
					if(v228) {
						bs228 |= 4;
					} else {
						bs228 &= -5;
					}
					break;
				case 6:
					if(v228) {
						bs228 |= 2;
					} else {
						bs228 &= -3;
					}
					break;
				case 7:
					if(v228) {
						bs228 |= 1;
					} else {
						bs228 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs228;
			var this230 = 0;
			var bs229 = this230;
			var l229 = "* * *".length;
			var _g1230 = 0;
			var _g330 = l229;
			while(_g1230 < _g330) {
				var i230 = _g1230++;
				var no229 = "* * *".charCodeAt(i230);
				if(no229 == null) {
					break;
				}
				var v229;
				switch(no229) {
				case 32:
					v229 = false;
					break;
				case 42:
					v229 = true;
					break;
				case 48:
					v229 = false;
					break;
				case 49:
					v229 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i230)));
				}
				switch(i230 - (l229 - 8)) {
				case 0:
					if(v229) {
						bs229 |= 128;
					} else {
						bs229 &= -129;
					}
					break;
				case 1:
					if(v229) {
						bs229 |= 64;
					} else {
						bs229 &= -65;
					}
					break;
				case 2:
					if(v229) {
						bs229 |= 32;
					} else {
						bs229 &= -33;
					}
					break;
				case 3:
					if(v229) {
						bs229 |= 16;
					} else {
						bs229 &= -17;
					}
					break;
				case 4:
					if(v229) {
						bs229 |= 8;
					} else {
						bs229 &= -9;
					}
					break;
				case 5:
					if(v229) {
						bs229 |= 4;
					} else {
						bs229 &= -5;
					}
					break;
				case 6:
					if(v229) {
						bs229 |= 2;
					} else {
						bs229 &= -3;
					}
					break;
				case 7:
					if(v229) {
						bs229 |= 1;
					} else {
						bs229 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs229;
			var this231 = 0;
			var bs230 = this231;
			var l230 = " *** ".length;
			var _g1231 = 0;
			var _g331 = l230;
			while(_g1231 < _g331) {
				var i231 = _g1231++;
				var no230 = " *** ".charCodeAt(i231);
				if(no230 == null) {
					break;
				}
				var v230;
				switch(no230) {
				case 32:
					v230 = false;
					break;
				case 42:
					v230 = true;
					break;
				case 48:
					v230 = false;
					break;
				case 49:
					v230 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i231)));
				}
				switch(i231 - (l230 - 8)) {
				case 0:
					if(v230) {
						bs230 |= 128;
					} else {
						bs230 &= -129;
					}
					break;
				case 1:
					if(v230) {
						bs230 |= 64;
					} else {
						bs230 &= -65;
					}
					break;
				case 2:
					if(v230) {
						bs230 |= 32;
					} else {
						bs230 &= -33;
					}
					break;
				case 3:
					if(v230) {
						bs230 |= 16;
					} else {
						bs230 &= -17;
					}
					break;
				case 4:
					if(v230) {
						bs230 |= 8;
					} else {
						bs230 &= -9;
					}
					break;
				case 5:
					if(v230) {
						bs230 |= 4;
					} else {
						bs230 &= -5;
					}
					break;
				case 6:
					if(v230) {
						bs230 |= 2;
					} else {
						bs230 &= -3;
					}
					break;
				case 7:
					if(v230) {
						bs230 |= 1;
					} else {
						bs230 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs230;
			break;
		case 65:
			var this232 = 0;
			var bs231 = this232;
			var l231 = " *** ".length;
			var _g1232 = 0;
			var _g332 = l231;
			while(_g1232 < _g332) {
				var i232 = _g1232++;
				var no231 = " *** ".charCodeAt(i232);
				if(no231 == null) {
					break;
				}
				var v231;
				switch(no231) {
				case 32:
					v231 = false;
					break;
				case 42:
					v231 = true;
					break;
				case 48:
					v231 = false;
					break;
				case 49:
					v231 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i232)));
				}
				switch(i232 - (l231 - 8)) {
				case 0:
					if(v231) {
						bs231 |= 128;
					} else {
						bs231 &= -129;
					}
					break;
				case 1:
					if(v231) {
						bs231 |= 64;
					} else {
						bs231 &= -65;
					}
					break;
				case 2:
					if(v231) {
						bs231 |= 32;
					} else {
						bs231 &= -33;
					}
					break;
				case 3:
					if(v231) {
						bs231 |= 16;
					} else {
						bs231 &= -17;
					}
					break;
				case 4:
					if(v231) {
						bs231 |= 8;
					} else {
						bs231 &= -9;
					}
					break;
				case 5:
					if(v231) {
						bs231 |= 4;
					} else {
						bs231 &= -5;
					}
					break;
				case 6:
					if(v231) {
						bs231 |= 2;
					} else {
						bs231 &= -3;
					}
					break;
				case 7:
					if(v231) {
						bs231 |= 1;
					} else {
						bs231 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs231;
			var this233 = 0;
			var bs232 = this233;
			var l232 = "*   *".length;
			var _g1233 = 0;
			var _g333 = l232;
			while(_g1233 < _g333) {
				var i233 = _g1233++;
				var no232 = "*   *".charCodeAt(i233);
				if(no232 == null) {
					break;
				}
				var v232;
				switch(no232) {
				case 32:
					v232 = false;
					break;
				case 42:
					v232 = true;
					break;
				case 48:
					v232 = false;
					break;
				case 49:
					v232 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i233)));
				}
				switch(i233 - (l232 - 8)) {
				case 0:
					if(v232) {
						bs232 |= 128;
					} else {
						bs232 &= -129;
					}
					break;
				case 1:
					if(v232) {
						bs232 |= 64;
					} else {
						bs232 &= -65;
					}
					break;
				case 2:
					if(v232) {
						bs232 |= 32;
					} else {
						bs232 &= -33;
					}
					break;
				case 3:
					if(v232) {
						bs232 |= 16;
					} else {
						bs232 &= -17;
					}
					break;
				case 4:
					if(v232) {
						bs232 |= 8;
					} else {
						bs232 &= -9;
					}
					break;
				case 5:
					if(v232) {
						bs232 |= 4;
					} else {
						bs232 &= -5;
					}
					break;
				case 6:
					if(v232) {
						bs232 |= 2;
					} else {
						bs232 &= -3;
					}
					break;
				case 7:
					if(v232) {
						bs232 |= 1;
					} else {
						bs232 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs232;
			var this234 = 0;
			var bs233 = this234;
			var l233 = "*   *".length;
			var _g1234 = 0;
			var _g334 = l233;
			while(_g1234 < _g334) {
				var i234 = _g1234++;
				var no233 = "*   *".charCodeAt(i234);
				if(no233 == null) {
					break;
				}
				var v233;
				switch(no233) {
				case 32:
					v233 = false;
					break;
				case 42:
					v233 = true;
					break;
				case 48:
					v233 = false;
					break;
				case 49:
					v233 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i234)));
				}
				switch(i234 - (l233 - 8)) {
				case 0:
					if(v233) {
						bs233 |= 128;
					} else {
						bs233 &= -129;
					}
					break;
				case 1:
					if(v233) {
						bs233 |= 64;
					} else {
						bs233 &= -65;
					}
					break;
				case 2:
					if(v233) {
						bs233 |= 32;
					} else {
						bs233 &= -33;
					}
					break;
				case 3:
					if(v233) {
						bs233 |= 16;
					} else {
						bs233 &= -17;
					}
					break;
				case 4:
					if(v233) {
						bs233 |= 8;
					} else {
						bs233 &= -9;
					}
					break;
				case 5:
					if(v233) {
						bs233 |= 4;
					} else {
						bs233 &= -5;
					}
					break;
				case 6:
					if(v233) {
						bs233 |= 2;
					} else {
						bs233 &= -3;
					}
					break;
				case 7:
					if(v233) {
						bs233 |= 1;
					} else {
						bs233 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs233;
			var this235 = 0;
			var bs234 = this235;
			var l234 = "*   *".length;
			var _g1235 = 0;
			var _g335 = l234;
			while(_g1235 < _g335) {
				var i235 = _g1235++;
				var no234 = "*   *".charCodeAt(i235);
				if(no234 == null) {
					break;
				}
				var v234;
				switch(no234) {
				case 32:
					v234 = false;
					break;
				case 42:
					v234 = true;
					break;
				case 48:
					v234 = false;
					break;
				case 49:
					v234 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i235)));
				}
				switch(i235 - (l234 - 8)) {
				case 0:
					if(v234) {
						bs234 |= 128;
					} else {
						bs234 &= -129;
					}
					break;
				case 1:
					if(v234) {
						bs234 |= 64;
					} else {
						bs234 &= -65;
					}
					break;
				case 2:
					if(v234) {
						bs234 |= 32;
					} else {
						bs234 &= -33;
					}
					break;
				case 3:
					if(v234) {
						bs234 |= 16;
					} else {
						bs234 &= -17;
					}
					break;
				case 4:
					if(v234) {
						bs234 |= 8;
					} else {
						bs234 &= -9;
					}
					break;
				case 5:
					if(v234) {
						bs234 |= 4;
					} else {
						bs234 &= -5;
					}
					break;
				case 6:
					if(v234) {
						bs234 |= 2;
					} else {
						bs234 &= -3;
					}
					break;
				case 7:
					if(v234) {
						bs234 |= 1;
					} else {
						bs234 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs234;
			var this236 = 0;
			var bs235 = this236;
			var l235 = "*****".length;
			var _g1236 = 0;
			var _g336 = l235;
			while(_g1236 < _g336) {
				var i236 = _g1236++;
				var no235 = "*****".charCodeAt(i236);
				if(no235 == null) {
					break;
				}
				var v235;
				switch(no235) {
				case 32:
					v235 = false;
					break;
				case 42:
					v235 = true;
					break;
				case 48:
					v235 = false;
					break;
				case 49:
					v235 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i236)));
				}
				switch(i236 - (l235 - 8)) {
				case 0:
					if(v235) {
						bs235 |= 128;
					} else {
						bs235 &= -129;
					}
					break;
				case 1:
					if(v235) {
						bs235 |= 64;
					} else {
						bs235 &= -65;
					}
					break;
				case 2:
					if(v235) {
						bs235 |= 32;
					} else {
						bs235 &= -33;
					}
					break;
				case 3:
					if(v235) {
						bs235 |= 16;
					} else {
						bs235 &= -17;
					}
					break;
				case 4:
					if(v235) {
						bs235 |= 8;
					} else {
						bs235 &= -9;
					}
					break;
				case 5:
					if(v235) {
						bs235 |= 4;
					} else {
						bs235 &= -5;
					}
					break;
				case 6:
					if(v235) {
						bs235 |= 2;
					} else {
						bs235 &= -3;
					}
					break;
				case 7:
					if(v235) {
						bs235 |= 1;
					} else {
						bs235 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs235;
			var this237 = 0;
			var bs236 = this237;
			var l236 = "*   *".length;
			var _g1237 = 0;
			var _g337 = l236;
			while(_g1237 < _g337) {
				var i237 = _g1237++;
				var no236 = "*   *".charCodeAt(i237);
				if(no236 == null) {
					break;
				}
				var v236;
				switch(no236) {
				case 32:
					v236 = false;
					break;
				case 42:
					v236 = true;
					break;
				case 48:
					v236 = false;
					break;
				case 49:
					v236 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i237)));
				}
				switch(i237 - (l236 - 8)) {
				case 0:
					if(v236) {
						bs236 |= 128;
					} else {
						bs236 &= -129;
					}
					break;
				case 1:
					if(v236) {
						bs236 |= 64;
					} else {
						bs236 &= -65;
					}
					break;
				case 2:
					if(v236) {
						bs236 |= 32;
					} else {
						bs236 &= -33;
					}
					break;
				case 3:
					if(v236) {
						bs236 |= 16;
					} else {
						bs236 &= -17;
					}
					break;
				case 4:
					if(v236) {
						bs236 |= 8;
					} else {
						bs236 &= -9;
					}
					break;
				case 5:
					if(v236) {
						bs236 |= 4;
					} else {
						bs236 &= -5;
					}
					break;
				case 6:
					if(v236) {
						bs236 |= 2;
					} else {
						bs236 &= -3;
					}
					break;
				case 7:
					if(v236) {
						bs236 |= 1;
					} else {
						bs236 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs236;
			var this238 = 0;
			var bs237 = this238;
			var l237 = "*   *".length;
			var _g1238 = 0;
			var _g338 = l237;
			while(_g1238 < _g338) {
				var i238 = _g1238++;
				var no237 = "*   *".charCodeAt(i238);
				if(no237 == null) {
					break;
				}
				var v237;
				switch(no237) {
				case 32:
					v237 = false;
					break;
				case 42:
					v237 = true;
					break;
				case 48:
					v237 = false;
					break;
				case 49:
					v237 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i238)));
				}
				switch(i238 - (l237 - 8)) {
				case 0:
					if(v237) {
						bs237 |= 128;
					} else {
						bs237 &= -129;
					}
					break;
				case 1:
					if(v237) {
						bs237 |= 64;
					} else {
						bs237 &= -65;
					}
					break;
				case 2:
					if(v237) {
						bs237 |= 32;
					} else {
						bs237 &= -33;
					}
					break;
				case 3:
					if(v237) {
						bs237 |= 16;
					} else {
						bs237 &= -17;
					}
					break;
				case 4:
					if(v237) {
						bs237 |= 8;
					} else {
						bs237 &= -9;
					}
					break;
				case 5:
					if(v237) {
						bs237 |= 4;
					} else {
						bs237 &= -5;
					}
					break;
				case 6:
					if(v237) {
						bs237 |= 2;
					} else {
						bs237 &= -3;
					}
					break;
				case 7:
					if(v237) {
						bs237 |= 1;
					} else {
						bs237 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs237;
			break;
		case 66:
			var this239 = 0;
			var bs238 = this239;
			var l238 = "**** ".length;
			var _g1239 = 0;
			var _g339 = l238;
			while(_g1239 < _g339) {
				var i239 = _g1239++;
				var no238 = "**** ".charCodeAt(i239);
				if(no238 == null) {
					break;
				}
				var v238;
				switch(no238) {
				case 32:
					v238 = false;
					break;
				case 42:
					v238 = true;
					break;
				case 48:
					v238 = false;
					break;
				case 49:
					v238 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i239)));
				}
				switch(i239 - (l238 - 8)) {
				case 0:
					if(v238) {
						bs238 |= 128;
					} else {
						bs238 &= -129;
					}
					break;
				case 1:
					if(v238) {
						bs238 |= 64;
					} else {
						bs238 &= -65;
					}
					break;
				case 2:
					if(v238) {
						bs238 |= 32;
					} else {
						bs238 &= -33;
					}
					break;
				case 3:
					if(v238) {
						bs238 |= 16;
					} else {
						bs238 &= -17;
					}
					break;
				case 4:
					if(v238) {
						bs238 |= 8;
					} else {
						bs238 &= -9;
					}
					break;
				case 5:
					if(v238) {
						bs238 |= 4;
					} else {
						bs238 &= -5;
					}
					break;
				case 6:
					if(v238) {
						bs238 |= 2;
					} else {
						bs238 &= -3;
					}
					break;
				case 7:
					if(v238) {
						bs238 |= 1;
					} else {
						bs238 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs238;
			var this240 = 0;
			var bs239 = this240;
			var l239 = "*   *".length;
			var _g1240 = 0;
			var _g340 = l239;
			while(_g1240 < _g340) {
				var i240 = _g1240++;
				var no239 = "*   *".charCodeAt(i240);
				if(no239 == null) {
					break;
				}
				var v239;
				switch(no239) {
				case 32:
					v239 = false;
					break;
				case 42:
					v239 = true;
					break;
				case 48:
					v239 = false;
					break;
				case 49:
					v239 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i240)));
				}
				switch(i240 - (l239 - 8)) {
				case 0:
					if(v239) {
						bs239 |= 128;
					} else {
						bs239 &= -129;
					}
					break;
				case 1:
					if(v239) {
						bs239 |= 64;
					} else {
						bs239 &= -65;
					}
					break;
				case 2:
					if(v239) {
						bs239 |= 32;
					} else {
						bs239 &= -33;
					}
					break;
				case 3:
					if(v239) {
						bs239 |= 16;
					} else {
						bs239 &= -17;
					}
					break;
				case 4:
					if(v239) {
						bs239 |= 8;
					} else {
						bs239 &= -9;
					}
					break;
				case 5:
					if(v239) {
						bs239 |= 4;
					} else {
						bs239 &= -5;
					}
					break;
				case 6:
					if(v239) {
						bs239 |= 2;
					} else {
						bs239 &= -3;
					}
					break;
				case 7:
					if(v239) {
						bs239 |= 1;
					} else {
						bs239 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs239;
			var this241 = 0;
			var bs240 = this241;
			var l240 = "*   *".length;
			var _g1241 = 0;
			var _g341 = l240;
			while(_g1241 < _g341) {
				var i241 = _g1241++;
				var no240 = "*   *".charCodeAt(i241);
				if(no240 == null) {
					break;
				}
				var v240;
				switch(no240) {
				case 32:
					v240 = false;
					break;
				case 42:
					v240 = true;
					break;
				case 48:
					v240 = false;
					break;
				case 49:
					v240 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i241)));
				}
				switch(i241 - (l240 - 8)) {
				case 0:
					if(v240) {
						bs240 |= 128;
					} else {
						bs240 &= -129;
					}
					break;
				case 1:
					if(v240) {
						bs240 |= 64;
					} else {
						bs240 &= -65;
					}
					break;
				case 2:
					if(v240) {
						bs240 |= 32;
					} else {
						bs240 &= -33;
					}
					break;
				case 3:
					if(v240) {
						bs240 |= 16;
					} else {
						bs240 &= -17;
					}
					break;
				case 4:
					if(v240) {
						bs240 |= 8;
					} else {
						bs240 &= -9;
					}
					break;
				case 5:
					if(v240) {
						bs240 |= 4;
					} else {
						bs240 &= -5;
					}
					break;
				case 6:
					if(v240) {
						bs240 |= 2;
					} else {
						bs240 &= -3;
					}
					break;
				case 7:
					if(v240) {
						bs240 |= 1;
					} else {
						bs240 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs240;
			var this242 = 0;
			var bs241 = this242;
			var l241 = "**** ".length;
			var _g1242 = 0;
			var _g342 = l241;
			while(_g1242 < _g342) {
				var i242 = _g1242++;
				var no241 = "**** ".charCodeAt(i242);
				if(no241 == null) {
					break;
				}
				var v241;
				switch(no241) {
				case 32:
					v241 = false;
					break;
				case 42:
					v241 = true;
					break;
				case 48:
					v241 = false;
					break;
				case 49:
					v241 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i242)));
				}
				switch(i242 - (l241 - 8)) {
				case 0:
					if(v241) {
						bs241 |= 128;
					} else {
						bs241 &= -129;
					}
					break;
				case 1:
					if(v241) {
						bs241 |= 64;
					} else {
						bs241 &= -65;
					}
					break;
				case 2:
					if(v241) {
						bs241 |= 32;
					} else {
						bs241 &= -33;
					}
					break;
				case 3:
					if(v241) {
						bs241 |= 16;
					} else {
						bs241 &= -17;
					}
					break;
				case 4:
					if(v241) {
						bs241 |= 8;
					} else {
						bs241 &= -9;
					}
					break;
				case 5:
					if(v241) {
						bs241 |= 4;
					} else {
						bs241 &= -5;
					}
					break;
				case 6:
					if(v241) {
						bs241 |= 2;
					} else {
						bs241 &= -3;
					}
					break;
				case 7:
					if(v241) {
						bs241 |= 1;
					} else {
						bs241 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs241;
			var this243 = 0;
			var bs242 = this243;
			var l242 = "*   *".length;
			var _g1243 = 0;
			var _g343 = l242;
			while(_g1243 < _g343) {
				var i243 = _g1243++;
				var no242 = "*   *".charCodeAt(i243);
				if(no242 == null) {
					break;
				}
				var v242;
				switch(no242) {
				case 32:
					v242 = false;
					break;
				case 42:
					v242 = true;
					break;
				case 48:
					v242 = false;
					break;
				case 49:
					v242 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i243)));
				}
				switch(i243 - (l242 - 8)) {
				case 0:
					if(v242) {
						bs242 |= 128;
					} else {
						bs242 &= -129;
					}
					break;
				case 1:
					if(v242) {
						bs242 |= 64;
					} else {
						bs242 &= -65;
					}
					break;
				case 2:
					if(v242) {
						bs242 |= 32;
					} else {
						bs242 &= -33;
					}
					break;
				case 3:
					if(v242) {
						bs242 |= 16;
					} else {
						bs242 &= -17;
					}
					break;
				case 4:
					if(v242) {
						bs242 |= 8;
					} else {
						bs242 &= -9;
					}
					break;
				case 5:
					if(v242) {
						bs242 |= 4;
					} else {
						bs242 &= -5;
					}
					break;
				case 6:
					if(v242) {
						bs242 |= 2;
					} else {
						bs242 &= -3;
					}
					break;
				case 7:
					if(v242) {
						bs242 |= 1;
					} else {
						bs242 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs242;
			var this244 = 0;
			var bs243 = this244;
			var l243 = "*   *".length;
			var _g1244 = 0;
			var _g344 = l243;
			while(_g1244 < _g344) {
				var i244 = _g1244++;
				var no243 = "*   *".charCodeAt(i244);
				if(no243 == null) {
					break;
				}
				var v243;
				switch(no243) {
				case 32:
					v243 = false;
					break;
				case 42:
					v243 = true;
					break;
				case 48:
					v243 = false;
					break;
				case 49:
					v243 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i244)));
				}
				switch(i244 - (l243 - 8)) {
				case 0:
					if(v243) {
						bs243 |= 128;
					} else {
						bs243 &= -129;
					}
					break;
				case 1:
					if(v243) {
						bs243 |= 64;
					} else {
						bs243 &= -65;
					}
					break;
				case 2:
					if(v243) {
						bs243 |= 32;
					} else {
						bs243 &= -33;
					}
					break;
				case 3:
					if(v243) {
						bs243 |= 16;
					} else {
						bs243 &= -17;
					}
					break;
				case 4:
					if(v243) {
						bs243 |= 8;
					} else {
						bs243 &= -9;
					}
					break;
				case 5:
					if(v243) {
						bs243 |= 4;
					} else {
						bs243 &= -5;
					}
					break;
				case 6:
					if(v243) {
						bs243 |= 2;
					} else {
						bs243 &= -3;
					}
					break;
				case 7:
					if(v243) {
						bs243 |= 1;
					} else {
						bs243 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs243;
			var this245 = 0;
			var bs244 = this245;
			var l244 = "**** ".length;
			var _g1245 = 0;
			var _g345 = l244;
			while(_g1245 < _g345) {
				var i245 = _g1245++;
				var no244 = "**** ".charCodeAt(i245);
				if(no244 == null) {
					break;
				}
				var v244;
				switch(no244) {
				case 32:
					v244 = false;
					break;
				case 42:
					v244 = true;
					break;
				case 48:
					v244 = false;
					break;
				case 49:
					v244 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i245)));
				}
				switch(i245 - (l244 - 8)) {
				case 0:
					if(v244) {
						bs244 |= 128;
					} else {
						bs244 &= -129;
					}
					break;
				case 1:
					if(v244) {
						bs244 |= 64;
					} else {
						bs244 &= -65;
					}
					break;
				case 2:
					if(v244) {
						bs244 |= 32;
					} else {
						bs244 &= -33;
					}
					break;
				case 3:
					if(v244) {
						bs244 |= 16;
					} else {
						bs244 &= -17;
					}
					break;
				case 4:
					if(v244) {
						bs244 |= 8;
					} else {
						bs244 &= -9;
					}
					break;
				case 5:
					if(v244) {
						bs244 |= 4;
					} else {
						bs244 &= -5;
					}
					break;
				case 6:
					if(v244) {
						bs244 |= 2;
					} else {
						bs244 &= -3;
					}
					break;
				case 7:
					if(v244) {
						bs244 |= 1;
					} else {
						bs244 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs244;
			break;
		case 67:
			var this246 = 0;
			var bs245 = this246;
			var l245 = " *** ".length;
			var _g1246 = 0;
			var _g346 = l245;
			while(_g1246 < _g346) {
				var i246 = _g1246++;
				var no245 = " *** ".charCodeAt(i246);
				if(no245 == null) {
					break;
				}
				var v245;
				switch(no245) {
				case 32:
					v245 = false;
					break;
				case 42:
					v245 = true;
					break;
				case 48:
					v245 = false;
					break;
				case 49:
					v245 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i246)));
				}
				switch(i246 - (l245 - 8)) {
				case 0:
					if(v245) {
						bs245 |= 128;
					} else {
						bs245 &= -129;
					}
					break;
				case 1:
					if(v245) {
						bs245 |= 64;
					} else {
						bs245 &= -65;
					}
					break;
				case 2:
					if(v245) {
						bs245 |= 32;
					} else {
						bs245 &= -33;
					}
					break;
				case 3:
					if(v245) {
						bs245 |= 16;
					} else {
						bs245 &= -17;
					}
					break;
				case 4:
					if(v245) {
						bs245 |= 8;
					} else {
						bs245 &= -9;
					}
					break;
				case 5:
					if(v245) {
						bs245 |= 4;
					} else {
						bs245 &= -5;
					}
					break;
				case 6:
					if(v245) {
						bs245 |= 2;
					} else {
						bs245 &= -3;
					}
					break;
				case 7:
					if(v245) {
						bs245 |= 1;
					} else {
						bs245 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs245;
			var this247 = 0;
			var bs246 = this247;
			var l246 = "*   *".length;
			var _g1247 = 0;
			var _g347 = l246;
			while(_g1247 < _g347) {
				var i247 = _g1247++;
				var no246 = "*   *".charCodeAt(i247);
				if(no246 == null) {
					break;
				}
				var v246;
				switch(no246) {
				case 32:
					v246 = false;
					break;
				case 42:
					v246 = true;
					break;
				case 48:
					v246 = false;
					break;
				case 49:
					v246 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i247)));
				}
				switch(i247 - (l246 - 8)) {
				case 0:
					if(v246) {
						bs246 |= 128;
					} else {
						bs246 &= -129;
					}
					break;
				case 1:
					if(v246) {
						bs246 |= 64;
					} else {
						bs246 &= -65;
					}
					break;
				case 2:
					if(v246) {
						bs246 |= 32;
					} else {
						bs246 &= -33;
					}
					break;
				case 3:
					if(v246) {
						bs246 |= 16;
					} else {
						bs246 &= -17;
					}
					break;
				case 4:
					if(v246) {
						bs246 |= 8;
					} else {
						bs246 &= -9;
					}
					break;
				case 5:
					if(v246) {
						bs246 |= 4;
					} else {
						bs246 &= -5;
					}
					break;
				case 6:
					if(v246) {
						bs246 |= 2;
					} else {
						bs246 &= -3;
					}
					break;
				case 7:
					if(v246) {
						bs246 |= 1;
					} else {
						bs246 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs246;
			var this248 = 0;
			var bs247 = this248;
			var l247 = "*    ".length;
			var _g1248 = 0;
			var _g348 = l247;
			while(_g1248 < _g348) {
				var i248 = _g1248++;
				var no247 = "*    ".charCodeAt(i248);
				if(no247 == null) {
					break;
				}
				var v247;
				switch(no247) {
				case 32:
					v247 = false;
					break;
				case 42:
					v247 = true;
					break;
				case 48:
					v247 = false;
					break;
				case 49:
					v247 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i248)));
				}
				switch(i248 - (l247 - 8)) {
				case 0:
					if(v247) {
						bs247 |= 128;
					} else {
						bs247 &= -129;
					}
					break;
				case 1:
					if(v247) {
						bs247 |= 64;
					} else {
						bs247 &= -65;
					}
					break;
				case 2:
					if(v247) {
						bs247 |= 32;
					} else {
						bs247 &= -33;
					}
					break;
				case 3:
					if(v247) {
						bs247 |= 16;
					} else {
						bs247 &= -17;
					}
					break;
				case 4:
					if(v247) {
						bs247 |= 8;
					} else {
						bs247 &= -9;
					}
					break;
				case 5:
					if(v247) {
						bs247 |= 4;
					} else {
						bs247 &= -5;
					}
					break;
				case 6:
					if(v247) {
						bs247 |= 2;
					} else {
						bs247 &= -3;
					}
					break;
				case 7:
					if(v247) {
						bs247 |= 1;
					} else {
						bs247 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs247;
			var this249 = 0;
			var bs248 = this249;
			var l248 = "*    ".length;
			var _g1249 = 0;
			var _g349 = l248;
			while(_g1249 < _g349) {
				var i249 = _g1249++;
				var no248 = "*    ".charCodeAt(i249);
				if(no248 == null) {
					break;
				}
				var v248;
				switch(no248) {
				case 32:
					v248 = false;
					break;
				case 42:
					v248 = true;
					break;
				case 48:
					v248 = false;
					break;
				case 49:
					v248 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i249)));
				}
				switch(i249 - (l248 - 8)) {
				case 0:
					if(v248) {
						bs248 |= 128;
					} else {
						bs248 &= -129;
					}
					break;
				case 1:
					if(v248) {
						bs248 |= 64;
					} else {
						bs248 &= -65;
					}
					break;
				case 2:
					if(v248) {
						bs248 |= 32;
					} else {
						bs248 &= -33;
					}
					break;
				case 3:
					if(v248) {
						bs248 |= 16;
					} else {
						bs248 &= -17;
					}
					break;
				case 4:
					if(v248) {
						bs248 |= 8;
					} else {
						bs248 &= -9;
					}
					break;
				case 5:
					if(v248) {
						bs248 |= 4;
					} else {
						bs248 &= -5;
					}
					break;
				case 6:
					if(v248) {
						bs248 |= 2;
					} else {
						bs248 &= -3;
					}
					break;
				case 7:
					if(v248) {
						bs248 |= 1;
					} else {
						bs248 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs248;
			var this250 = 0;
			var bs249 = this250;
			var l249 = "*    ".length;
			var _g1250 = 0;
			var _g350 = l249;
			while(_g1250 < _g350) {
				var i250 = _g1250++;
				var no249 = "*    ".charCodeAt(i250);
				if(no249 == null) {
					break;
				}
				var v249;
				switch(no249) {
				case 32:
					v249 = false;
					break;
				case 42:
					v249 = true;
					break;
				case 48:
					v249 = false;
					break;
				case 49:
					v249 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i250)));
				}
				switch(i250 - (l249 - 8)) {
				case 0:
					if(v249) {
						bs249 |= 128;
					} else {
						bs249 &= -129;
					}
					break;
				case 1:
					if(v249) {
						bs249 |= 64;
					} else {
						bs249 &= -65;
					}
					break;
				case 2:
					if(v249) {
						bs249 |= 32;
					} else {
						bs249 &= -33;
					}
					break;
				case 3:
					if(v249) {
						bs249 |= 16;
					} else {
						bs249 &= -17;
					}
					break;
				case 4:
					if(v249) {
						bs249 |= 8;
					} else {
						bs249 &= -9;
					}
					break;
				case 5:
					if(v249) {
						bs249 |= 4;
					} else {
						bs249 &= -5;
					}
					break;
				case 6:
					if(v249) {
						bs249 |= 2;
					} else {
						bs249 &= -3;
					}
					break;
				case 7:
					if(v249) {
						bs249 |= 1;
					} else {
						bs249 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs249;
			var this251 = 0;
			var bs250 = this251;
			var l250 = "*   *".length;
			var _g1251 = 0;
			var _g351 = l250;
			while(_g1251 < _g351) {
				var i251 = _g1251++;
				var no250 = "*   *".charCodeAt(i251);
				if(no250 == null) {
					break;
				}
				var v250;
				switch(no250) {
				case 32:
					v250 = false;
					break;
				case 42:
					v250 = true;
					break;
				case 48:
					v250 = false;
					break;
				case 49:
					v250 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i251)));
				}
				switch(i251 - (l250 - 8)) {
				case 0:
					if(v250) {
						bs250 |= 128;
					} else {
						bs250 &= -129;
					}
					break;
				case 1:
					if(v250) {
						bs250 |= 64;
					} else {
						bs250 &= -65;
					}
					break;
				case 2:
					if(v250) {
						bs250 |= 32;
					} else {
						bs250 &= -33;
					}
					break;
				case 3:
					if(v250) {
						bs250 |= 16;
					} else {
						bs250 &= -17;
					}
					break;
				case 4:
					if(v250) {
						bs250 |= 8;
					} else {
						bs250 &= -9;
					}
					break;
				case 5:
					if(v250) {
						bs250 |= 4;
					} else {
						bs250 &= -5;
					}
					break;
				case 6:
					if(v250) {
						bs250 |= 2;
					} else {
						bs250 &= -3;
					}
					break;
				case 7:
					if(v250) {
						bs250 |= 1;
					} else {
						bs250 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs250;
			var this252 = 0;
			var bs251 = this252;
			var l251 = " *** ".length;
			var _g1252 = 0;
			var _g352 = l251;
			while(_g1252 < _g352) {
				var i252 = _g1252++;
				var no251 = " *** ".charCodeAt(i252);
				if(no251 == null) {
					break;
				}
				var v251;
				switch(no251) {
				case 32:
					v251 = false;
					break;
				case 42:
					v251 = true;
					break;
				case 48:
					v251 = false;
					break;
				case 49:
					v251 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i252)));
				}
				switch(i252 - (l251 - 8)) {
				case 0:
					if(v251) {
						bs251 |= 128;
					} else {
						bs251 &= -129;
					}
					break;
				case 1:
					if(v251) {
						bs251 |= 64;
					} else {
						bs251 &= -65;
					}
					break;
				case 2:
					if(v251) {
						bs251 |= 32;
					} else {
						bs251 &= -33;
					}
					break;
				case 3:
					if(v251) {
						bs251 |= 16;
					} else {
						bs251 &= -17;
					}
					break;
				case 4:
					if(v251) {
						bs251 |= 8;
					} else {
						bs251 &= -9;
					}
					break;
				case 5:
					if(v251) {
						bs251 |= 4;
					} else {
						bs251 &= -5;
					}
					break;
				case 6:
					if(v251) {
						bs251 |= 2;
					} else {
						bs251 &= -3;
					}
					break;
				case 7:
					if(v251) {
						bs251 |= 1;
					} else {
						bs251 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs251;
			break;
		case 68:
			var this253 = 0;
			var bs252 = this253;
			var l252 = "***  ".length;
			var _g1253 = 0;
			var _g353 = l252;
			while(_g1253 < _g353) {
				var i253 = _g1253++;
				var no252 = "***  ".charCodeAt(i253);
				if(no252 == null) {
					break;
				}
				var v252;
				switch(no252) {
				case 32:
					v252 = false;
					break;
				case 42:
					v252 = true;
					break;
				case 48:
					v252 = false;
					break;
				case 49:
					v252 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("***  ".charCodeAt(i253)));
				}
				switch(i253 - (l252 - 8)) {
				case 0:
					if(v252) {
						bs252 |= 128;
					} else {
						bs252 &= -129;
					}
					break;
				case 1:
					if(v252) {
						bs252 |= 64;
					} else {
						bs252 &= -65;
					}
					break;
				case 2:
					if(v252) {
						bs252 |= 32;
					} else {
						bs252 &= -33;
					}
					break;
				case 3:
					if(v252) {
						bs252 |= 16;
					} else {
						bs252 &= -17;
					}
					break;
				case 4:
					if(v252) {
						bs252 |= 8;
					} else {
						bs252 &= -9;
					}
					break;
				case 5:
					if(v252) {
						bs252 |= 4;
					} else {
						bs252 &= -5;
					}
					break;
				case 6:
					if(v252) {
						bs252 |= 2;
					} else {
						bs252 &= -3;
					}
					break;
				case 7:
					if(v252) {
						bs252 |= 1;
					} else {
						bs252 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs252;
			var this254 = 0;
			var bs253 = this254;
			var l253 = "*  * ".length;
			var _g1254 = 0;
			var _g354 = l253;
			while(_g1254 < _g354) {
				var i254 = _g1254++;
				var no253 = "*  * ".charCodeAt(i254);
				if(no253 == null) {
					break;
				}
				var v253;
				switch(no253) {
				case 32:
					v253 = false;
					break;
				case 42:
					v253 = true;
					break;
				case 48:
					v253 = false;
					break;
				case 49:
					v253 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i254)));
				}
				switch(i254 - (l253 - 8)) {
				case 0:
					if(v253) {
						bs253 |= 128;
					} else {
						bs253 &= -129;
					}
					break;
				case 1:
					if(v253) {
						bs253 |= 64;
					} else {
						bs253 &= -65;
					}
					break;
				case 2:
					if(v253) {
						bs253 |= 32;
					} else {
						bs253 &= -33;
					}
					break;
				case 3:
					if(v253) {
						bs253 |= 16;
					} else {
						bs253 &= -17;
					}
					break;
				case 4:
					if(v253) {
						bs253 |= 8;
					} else {
						bs253 &= -9;
					}
					break;
				case 5:
					if(v253) {
						bs253 |= 4;
					} else {
						bs253 &= -5;
					}
					break;
				case 6:
					if(v253) {
						bs253 |= 2;
					} else {
						bs253 &= -3;
					}
					break;
				case 7:
					if(v253) {
						bs253 |= 1;
					} else {
						bs253 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs253;
			var this255 = 0;
			var bs254 = this255;
			var l254 = "*   *".length;
			var _g1255 = 0;
			var _g355 = l254;
			while(_g1255 < _g355) {
				var i255 = _g1255++;
				var no254 = "*   *".charCodeAt(i255);
				if(no254 == null) {
					break;
				}
				var v254;
				switch(no254) {
				case 32:
					v254 = false;
					break;
				case 42:
					v254 = true;
					break;
				case 48:
					v254 = false;
					break;
				case 49:
					v254 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i255)));
				}
				switch(i255 - (l254 - 8)) {
				case 0:
					if(v254) {
						bs254 |= 128;
					} else {
						bs254 &= -129;
					}
					break;
				case 1:
					if(v254) {
						bs254 |= 64;
					} else {
						bs254 &= -65;
					}
					break;
				case 2:
					if(v254) {
						bs254 |= 32;
					} else {
						bs254 &= -33;
					}
					break;
				case 3:
					if(v254) {
						bs254 |= 16;
					} else {
						bs254 &= -17;
					}
					break;
				case 4:
					if(v254) {
						bs254 |= 8;
					} else {
						bs254 &= -9;
					}
					break;
				case 5:
					if(v254) {
						bs254 |= 4;
					} else {
						bs254 &= -5;
					}
					break;
				case 6:
					if(v254) {
						bs254 |= 2;
					} else {
						bs254 &= -3;
					}
					break;
				case 7:
					if(v254) {
						bs254 |= 1;
					} else {
						bs254 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs254;
			var this256 = 0;
			var bs255 = this256;
			var l255 = "*   *".length;
			var _g1256 = 0;
			var _g356 = l255;
			while(_g1256 < _g356) {
				var i256 = _g1256++;
				var no255 = "*   *".charCodeAt(i256);
				if(no255 == null) {
					break;
				}
				var v255;
				switch(no255) {
				case 32:
					v255 = false;
					break;
				case 42:
					v255 = true;
					break;
				case 48:
					v255 = false;
					break;
				case 49:
					v255 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i256)));
				}
				switch(i256 - (l255 - 8)) {
				case 0:
					if(v255) {
						bs255 |= 128;
					} else {
						bs255 &= -129;
					}
					break;
				case 1:
					if(v255) {
						bs255 |= 64;
					} else {
						bs255 &= -65;
					}
					break;
				case 2:
					if(v255) {
						bs255 |= 32;
					} else {
						bs255 &= -33;
					}
					break;
				case 3:
					if(v255) {
						bs255 |= 16;
					} else {
						bs255 &= -17;
					}
					break;
				case 4:
					if(v255) {
						bs255 |= 8;
					} else {
						bs255 &= -9;
					}
					break;
				case 5:
					if(v255) {
						bs255 |= 4;
					} else {
						bs255 &= -5;
					}
					break;
				case 6:
					if(v255) {
						bs255 |= 2;
					} else {
						bs255 &= -3;
					}
					break;
				case 7:
					if(v255) {
						bs255 |= 1;
					} else {
						bs255 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs255;
			var this257 = 0;
			var bs256 = this257;
			var l256 = "*   *".length;
			var _g1257 = 0;
			var _g357 = l256;
			while(_g1257 < _g357) {
				var i257 = _g1257++;
				var no256 = "*   *".charCodeAt(i257);
				if(no256 == null) {
					break;
				}
				var v256;
				switch(no256) {
				case 32:
					v256 = false;
					break;
				case 42:
					v256 = true;
					break;
				case 48:
					v256 = false;
					break;
				case 49:
					v256 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i257)));
				}
				switch(i257 - (l256 - 8)) {
				case 0:
					if(v256) {
						bs256 |= 128;
					} else {
						bs256 &= -129;
					}
					break;
				case 1:
					if(v256) {
						bs256 |= 64;
					} else {
						bs256 &= -65;
					}
					break;
				case 2:
					if(v256) {
						bs256 |= 32;
					} else {
						bs256 &= -33;
					}
					break;
				case 3:
					if(v256) {
						bs256 |= 16;
					} else {
						bs256 &= -17;
					}
					break;
				case 4:
					if(v256) {
						bs256 |= 8;
					} else {
						bs256 &= -9;
					}
					break;
				case 5:
					if(v256) {
						bs256 |= 4;
					} else {
						bs256 &= -5;
					}
					break;
				case 6:
					if(v256) {
						bs256 |= 2;
					} else {
						bs256 &= -3;
					}
					break;
				case 7:
					if(v256) {
						bs256 |= 1;
					} else {
						bs256 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs256;
			var this258 = 0;
			var bs257 = this258;
			var l257 = "*  * ".length;
			var _g1258 = 0;
			var _g358 = l257;
			while(_g1258 < _g358) {
				var i258 = _g1258++;
				var no257 = "*  * ".charCodeAt(i258);
				if(no257 == null) {
					break;
				}
				var v257;
				switch(no257) {
				case 32:
					v257 = false;
					break;
				case 42:
					v257 = true;
					break;
				case 48:
					v257 = false;
					break;
				case 49:
					v257 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i258)));
				}
				switch(i258 - (l257 - 8)) {
				case 0:
					if(v257) {
						bs257 |= 128;
					} else {
						bs257 &= -129;
					}
					break;
				case 1:
					if(v257) {
						bs257 |= 64;
					} else {
						bs257 &= -65;
					}
					break;
				case 2:
					if(v257) {
						bs257 |= 32;
					} else {
						bs257 &= -33;
					}
					break;
				case 3:
					if(v257) {
						bs257 |= 16;
					} else {
						bs257 &= -17;
					}
					break;
				case 4:
					if(v257) {
						bs257 |= 8;
					} else {
						bs257 &= -9;
					}
					break;
				case 5:
					if(v257) {
						bs257 |= 4;
					} else {
						bs257 &= -5;
					}
					break;
				case 6:
					if(v257) {
						bs257 |= 2;
					} else {
						bs257 &= -3;
					}
					break;
				case 7:
					if(v257) {
						bs257 |= 1;
					} else {
						bs257 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs257;
			var this259 = 0;
			var bs258 = this259;
			var l258 = "***  ".length;
			var _g1259 = 0;
			var _g359 = l258;
			while(_g1259 < _g359) {
				var i259 = _g1259++;
				var no258 = "***  ".charCodeAt(i259);
				if(no258 == null) {
					break;
				}
				var v258;
				switch(no258) {
				case 32:
					v258 = false;
					break;
				case 42:
					v258 = true;
					break;
				case 48:
					v258 = false;
					break;
				case 49:
					v258 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("***  ".charCodeAt(i259)));
				}
				switch(i259 - (l258 - 8)) {
				case 0:
					if(v258) {
						bs258 |= 128;
					} else {
						bs258 &= -129;
					}
					break;
				case 1:
					if(v258) {
						bs258 |= 64;
					} else {
						bs258 &= -65;
					}
					break;
				case 2:
					if(v258) {
						bs258 |= 32;
					} else {
						bs258 &= -33;
					}
					break;
				case 3:
					if(v258) {
						bs258 |= 16;
					} else {
						bs258 &= -17;
					}
					break;
				case 4:
					if(v258) {
						bs258 |= 8;
					} else {
						bs258 &= -9;
					}
					break;
				case 5:
					if(v258) {
						bs258 |= 4;
					} else {
						bs258 &= -5;
					}
					break;
				case 6:
					if(v258) {
						bs258 |= 2;
					} else {
						bs258 &= -3;
					}
					break;
				case 7:
					if(v258) {
						bs258 |= 1;
					} else {
						bs258 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs258;
			break;
		case 69:
			var this260 = 0;
			var bs259 = this260;
			var l259 = "*****".length;
			var _g1260 = 0;
			var _g360 = l259;
			while(_g1260 < _g360) {
				var i260 = _g1260++;
				var no259 = "*****".charCodeAt(i260);
				if(no259 == null) {
					break;
				}
				var v259;
				switch(no259) {
				case 32:
					v259 = false;
					break;
				case 42:
					v259 = true;
					break;
				case 48:
					v259 = false;
					break;
				case 49:
					v259 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i260)));
				}
				switch(i260 - (l259 - 8)) {
				case 0:
					if(v259) {
						bs259 |= 128;
					} else {
						bs259 &= -129;
					}
					break;
				case 1:
					if(v259) {
						bs259 |= 64;
					} else {
						bs259 &= -65;
					}
					break;
				case 2:
					if(v259) {
						bs259 |= 32;
					} else {
						bs259 &= -33;
					}
					break;
				case 3:
					if(v259) {
						bs259 |= 16;
					} else {
						bs259 &= -17;
					}
					break;
				case 4:
					if(v259) {
						bs259 |= 8;
					} else {
						bs259 &= -9;
					}
					break;
				case 5:
					if(v259) {
						bs259 |= 4;
					} else {
						bs259 &= -5;
					}
					break;
				case 6:
					if(v259) {
						bs259 |= 2;
					} else {
						bs259 &= -3;
					}
					break;
				case 7:
					if(v259) {
						bs259 |= 1;
					} else {
						bs259 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs259;
			var this261 = 0;
			var bs260 = this261;
			var l260 = "*    ".length;
			var _g1261 = 0;
			var _g361 = l260;
			while(_g1261 < _g361) {
				var i261 = _g1261++;
				var no260 = "*    ".charCodeAt(i261);
				if(no260 == null) {
					break;
				}
				var v260;
				switch(no260) {
				case 32:
					v260 = false;
					break;
				case 42:
					v260 = true;
					break;
				case 48:
					v260 = false;
					break;
				case 49:
					v260 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i261)));
				}
				switch(i261 - (l260 - 8)) {
				case 0:
					if(v260) {
						bs260 |= 128;
					} else {
						bs260 &= -129;
					}
					break;
				case 1:
					if(v260) {
						bs260 |= 64;
					} else {
						bs260 &= -65;
					}
					break;
				case 2:
					if(v260) {
						bs260 |= 32;
					} else {
						bs260 &= -33;
					}
					break;
				case 3:
					if(v260) {
						bs260 |= 16;
					} else {
						bs260 &= -17;
					}
					break;
				case 4:
					if(v260) {
						bs260 |= 8;
					} else {
						bs260 &= -9;
					}
					break;
				case 5:
					if(v260) {
						bs260 |= 4;
					} else {
						bs260 &= -5;
					}
					break;
				case 6:
					if(v260) {
						bs260 |= 2;
					} else {
						bs260 &= -3;
					}
					break;
				case 7:
					if(v260) {
						bs260 |= 1;
					} else {
						bs260 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs260;
			var this262 = 0;
			var bs261 = this262;
			var l261 = "*    ".length;
			var _g1262 = 0;
			var _g362 = l261;
			while(_g1262 < _g362) {
				var i262 = _g1262++;
				var no261 = "*    ".charCodeAt(i262);
				if(no261 == null) {
					break;
				}
				var v261;
				switch(no261) {
				case 32:
					v261 = false;
					break;
				case 42:
					v261 = true;
					break;
				case 48:
					v261 = false;
					break;
				case 49:
					v261 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i262)));
				}
				switch(i262 - (l261 - 8)) {
				case 0:
					if(v261) {
						bs261 |= 128;
					} else {
						bs261 &= -129;
					}
					break;
				case 1:
					if(v261) {
						bs261 |= 64;
					} else {
						bs261 &= -65;
					}
					break;
				case 2:
					if(v261) {
						bs261 |= 32;
					} else {
						bs261 &= -33;
					}
					break;
				case 3:
					if(v261) {
						bs261 |= 16;
					} else {
						bs261 &= -17;
					}
					break;
				case 4:
					if(v261) {
						bs261 |= 8;
					} else {
						bs261 &= -9;
					}
					break;
				case 5:
					if(v261) {
						bs261 |= 4;
					} else {
						bs261 &= -5;
					}
					break;
				case 6:
					if(v261) {
						bs261 |= 2;
					} else {
						bs261 &= -3;
					}
					break;
				case 7:
					if(v261) {
						bs261 |= 1;
					} else {
						bs261 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs261;
			var this263 = 0;
			var bs262 = this263;
			var l262 = "**** ".length;
			var _g1263 = 0;
			var _g363 = l262;
			while(_g1263 < _g363) {
				var i263 = _g1263++;
				var no262 = "**** ".charCodeAt(i263);
				if(no262 == null) {
					break;
				}
				var v262;
				switch(no262) {
				case 32:
					v262 = false;
					break;
				case 42:
					v262 = true;
					break;
				case 48:
					v262 = false;
					break;
				case 49:
					v262 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i263)));
				}
				switch(i263 - (l262 - 8)) {
				case 0:
					if(v262) {
						bs262 |= 128;
					} else {
						bs262 &= -129;
					}
					break;
				case 1:
					if(v262) {
						bs262 |= 64;
					} else {
						bs262 &= -65;
					}
					break;
				case 2:
					if(v262) {
						bs262 |= 32;
					} else {
						bs262 &= -33;
					}
					break;
				case 3:
					if(v262) {
						bs262 |= 16;
					} else {
						bs262 &= -17;
					}
					break;
				case 4:
					if(v262) {
						bs262 |= 8;
					} else {
						bs262 &= -9;
					}
					break;
				case 5:
					if(v262) {
						bs262 |= 4;
					} else {
						bs262 &= -5;
					}
					break;
				case 6:
					if(v262) {
						bs262 |= 2;
					} else {
						bs262 &= -3;
					}
					break;
				case 7:
					if(v262) {
						bs262 |= 1;
					} else {
						bs262 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs262;
			var this264 = 0;
			var bs263 = this264;
			var l263 = "*    ".length;
			var _g1264 = 0;
			var _g364 = l263;
			while(_g1264 < _g364) {
				var i264 = _g1264++;
				var no263 = "*    ".charCodeAt(i264);
				if(no263 == null) {
					break;
				}
				var v263;
				switch(no263) {
				case 32:
					v263 = false;
					break;
				case 42:
					v263 = true;
					break;
				case 48:
					v263 = false;
					break;
				case 49:
					v263 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i264)));
				}
				switch(i264 - (l263 - 8)) {
				case 0:
					if(v263) {
						bs263 |= 128;
					} else {
						bs263 &= -129;
					}
					break;
				case 1:
					if(v263) {
						bs263 |= 64;
					} else {
						bs263 &= -65;
					}
					break;
				case 2:
					if(v263) {
						bs263 |= 32;
					} else {
						bs263 &= -33;
					}
					break;
				case 3:
					if(v263) {
						bs263 |= 16;
					} else {
						bs263 &= -17;
					}
					break;
				case 4:
					if(v263) {
						bs263 |= 8;
					} else {
						bs263 &= -9;
					}
					break;
				case 5:
					if(v263) {
						bs263 |= 4;
					} else {
						bs263 &= -5;
					}
					break;
				case 6:
					if(v263) {
						bs263 |= 2;
					} else {
						bs263 &= -3;
					}
					break;
				case 7:
					if(v263) {
						bs263 |= 1;
					} else {
						bs263 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs263;
			var this265 = 0;
			var bs264 = this265;
			var l264 = "*    ".length;
			var _g1265 = 0;
			var _g365 = l264;
			while(_g1265 < _g365) {
				var i265 = _g1265++;
				var no264 = "*    ".charCodeAt(i265);
				if(no264 == null) {
					break;
				}
				var v264;
				switch(no264) {
				case 32:
					v264 = false;
					break;
				case 42:
					v264 = true;
					break;
				case 48:
					v264 = false;
					break;
				case 49:
					v264 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i265)));
				}
				switch(i265 - (l264 - 8)) {
				case 0:
					if(v264) {
						bs264 |= 128;
					} else {
						bs264 &= -129;
					}
					break;
				case 1:
					if(v264) {
						bs264 |= 64;
					} else {
						bs264 &= -65;
					}
					break;
				case 2:
					if(v264) {
						bs264 |= 32;
					} else {
						bs264 &= -33;
					}
					break;
				case 3:
					if(v264) {
						bs264 |= 16;
					} else {
						bs264 &= -17;
					}
					break;
				case 4:
					if(v264) {
						bs264 |= 8;
					} else {
						bs264 &= -9;
					}
					break;
				case 5:
					if(v264) {
						bs264 |= 4;
					} else {
						bs264 &= -5;
					}
					break;
				case 6:
					if(v264) {
						bs264 |= 2;
					} else {
						bs264 &= -3;
					}
					break;
				case 7:
					if(v264) {
						bs264 |= 1;
					} else {
						bs264 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs264;
			var this266 = 0;
			var bs265 = this266;
			var l265 = "*****".length;
			var _g1266 = 0;
			var _g366 = l265;
			while(_g1266 < _g366) {
				var i266 = _g1266++;
				var no265 = "*****".charCodeAt(i266);
				if(no265 == null) {
					break;
				}
				var v265;
				switch(no265) {
				case 32:
					v265 = false;
					break;
				case 42:
					v265 = true;
					break;
				case 48:
					v265 = false;
					break;
				case 49:
					v265 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i266)));
				}
				switch(i266 - (l265 - 8)) {
				case 0:
					if(v265) {
						bs265 |= 128;
					} else {
						bs265 &= -129;
					}
					break;
				case 1:
					if(v265) {
						bs265 |= 64;
					} else {
						bs265 &= -65;
					}
					break;
				case 2:
					if(v265) {
						bs265 |= 32;
					} else {
						bs265 &= -33;
					}
					break;
				case 3:
					if(v265) {
						bs265 |= 16;
					} else {
						bs265 &= -17;
					}
					break;
				case 4:
					if(v265) {
						bs265 |= 8;
					} else {
						bs265 &= -9;
					}
					break;
				case 5:
					if(v265) {
						bs265 |= 4;
					} else {
						bs265 &= -5;
					}
					break;
				case 6:
					if(v265) {
						bs265 |= 2;
					} else {
						bs265 &= -3;
					}
					break;
				case 7:
					if(v265) {
						bs265 |= 1;
					} else {
						bs265 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs265;
			break;
		case 70:
			var this267 = 0;
			var bs266 = this267;
			var l266 = "*****".length;
			var _g1267 = 0;
			var _g367 = l266;
			while(_g1267 < _g367) {
				var i267 = _g1267++;
				var no266 = "*****".charCodeAt(i267);
				if(no266 == null) {
					break;
				}
				var v266;
				switch(no266) {
				case 32:
					v266 = false;
					break;
				case 42:
					v266 = true;
					break;
				case 48:
					v266 = false;
					break;
				case 49:
					v266 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i267)));
				}
				switch(i267 - (l266 - 8)) {
				case 0:
					if(v266) {
						bs266 |= 128;
					} else {
						bs266 &= -129;
					}
					break;
				case 1:
					if(v266) {
						bs266 |= 64;
					} else {
						bs266 &= -65;
					}
					break;
				case 2:
					if(v266) {
						bs266 |= 32;
					} else {
						bs266 &= -33;
					}
					break;
				case 3:
					if(v266) {
						bs266 |= 16;
					} else {
						bs266 &= -17;
					}
					break;
				case 4:
					if(v266) {
						bs266 |= 8;
					} else {
						bs266 &= -9;
					}
					break;
				case 5:
					if(v266) {
						bs266 |= 4;
					} else {
						bs266 &= -5;
					}
					break;
				case 6:
					if(v266) {
						bs266 |= 2;
					} else {
						bs266 &= -3;
					}
					break;
				case 7:
					if(v266) {
						bs266 |= 1;
					} else {
						bs266 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs266;
			var this268 = 0;
			var bs267 = this268;
			var l267 = "*    ".length;
			var _g1268 = 0;
			var _g368 = l267;
			while(_g1268 < _g368) {
				var i268 = _g1268++;
				var no267 = "*    ".charCodeAt(i268);
				if(no267 == null) {
					break;
				}
				var v267;
				switch(no267) {
				case 32:
					v267 = false;
					break;
				case 42:
					v267 = true;
					break;
				case 48:
					v267 = false;
					break;
				case 49:
					v267 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i268)));
				}
				switch(i268 - (l267 - 8)) {
				case 0:
					if(v267) {
						bs267 |= 128;
					} else {
						bs267 &= -129;
					}
					break;
				case 1:
					if(v267) {
						bs267 |= 64;
					} else {
						bs267 &= -65;
					}
					break;
				case 2:
					if(v267) {
						bs267 |= 32;
					} else {
						bs267 &= -33;
					}
					break;
				case 3:
					if(v267) {
						bs267 |= 16;
					} else {
						bs267 &= -17;
					}
					break;
				case 4:
					if(v267) {
						bs267 |= 8;
					} else {
						bs267 &= -9;
					}
					break;
				case 5:
					if(v267) {
						bs267 |= 4;
					} else {
						bs267 &= -5;
					}
					break;
				case 6:
					if(v267) {
						bs267 |= 2;
					} else {
						bs267 &= -3;
					}
					break;
				case 7:
					if(v267) {
						bs267 |= 1;
					} else {
						bs267 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs267;
			var this269 = 0;
			var bs268 = this269;
			var l268 = "*    ".length;
			var _g1269 = 0;
			var _g369 = l268;
			while(_g1269 < _g369) {
				var i269 = _g1269++;
				var no268 = "*    ".charCodeAt(i269);
				if(no268 == null) {
					break;
				}
				var v268;
				switch(no268) {
				case 32:
					v268 = false;
					break;
				case 42:
					v268 = true;
					break;
				case 48:
					v268 = false;
					break;
				case 49:
					v268 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i269)));
				}
				switch(i269 - (l268 - 8)) {
				case 0:
					if(v268) {
						bs268 |= 128;
					} else {
						bs268 &= -129;
					}
					break;
				case 1:
					if(v268) {
						bs268 |= 64;
					} else {
						bs268 &= -65;
					}
					break;
				case 2:
					if(v268) {
						bs268 |= 32;
					} else {
						bs268 &= -33;
					}
					break;
				case 3:
					if(v268) {
						bs268 |= 16;
					} else {
						bs268 &= -17;
					}
					break;
				case 4:
					if(v268) {
						bs268 |= 8;
					} else {
						bs268 &= -9;
					}
					break;
				case 5:
					if(v268) {
						bs268 |= 4;
					} else {
						bs268 &= -5;
					}
					break;
				case 6:
					if(v268) {
						bs268 |= 2;
					} else {
						bs268 &= -3;
					}
					break;
				case 7:
					if(v268) {
						bs268 |= 1;
					} else {
						bs268 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs268;
			var this270 = 0;
			var bs269 = this270;
			var l269 = "**** ".length;
			var _g1270 = 0;
			var _g370 = l269;
			while(_g1270 < _g370) {
				var i270 = _g1270++;
				var no269 = "**** ".charCodeAt(i270);
				if(no269 == null) {
					break;
				}
				var v269;
				switch(no269) {
				case 32:
					v269 = false;
					break;
				case 42:
					v269 = true;
					break;
				case 48:
					v269 = false;
					break;
				case 49:
					v269 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i270)));
				}
				switch(i270 - (l269 - 8)) {
				case 0:
					if(v269) {
						bs269 |= 128;
					} else {
						bs269 &= -129;
					}
					break;
				case 1:
					if(v269) {
						bs269 |= 64;
					} else {
						bs269 &= -65;
					}
					break;
				case 2:
					if(v269) {
						bs269 |= 32;
					} else {
						bs269 &= -33;
					}
					break;
				case 3:
					if(v269) {
						bs269 |= 16;
					} else {
						bs269 &= -17;
					}
					break;
				case 4:
					if(v269) {
						bs269 |= 8;
					} else {
						bs269 &= -9;
					}
					break;
				case 5:
					if(v269) {
						bs269 |= 4;
					} else {
						bs269 &= -5;
					}
					break;
				case 6:
					if(v269) {
						bs269 |= 2;
					} else {
						bs269 &= -3;
					}
					break;
				case 7:
					if(v269) {
						bs269 |= 1;
					} else {
						bs269 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs269;
			var this271 = 0;
			var bs270 = this271;
			var l270 = "*    ".length;
			var _g1271 = 0;
			var _g371 = l270;
			while(_g1271 < _g371) {
				var i271 = _g1271++;
				var no270 = "*    ".charCodeAt(i271);
				if(no270 == null) {
					break;
				}
				var v270;
				switch(no270) {
				case 32:
					v270 = false;
					break;
				case 42:
					v270 = true;
					break;
				case 48:
					v270 = false;
					break;
				case 49:
					v270 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i271)));
				}
				switch(i271 - (l270 - 8)) {
				case 0:
					if(v270) {
						bs270 |= 128;
					} else {
						bs270 &= -129;
					}
					break;
				case 1:
					if(v270) {
						bs270 |= 64;
					} else {
						bs270 &= -65;
					}
					break;
				case 2:
					if(v270) {
						bs270 |= 32;
					} else {
						bs270 &= -33;
					}
					break;
				case 3:
					if(v270) {
						bs270 |= 16;
					} else {
						bs270 &= -17;
					}
					break;
				case 4:
					if(v270) {
						bs270 |= 8;
					} else {
						bs270 &= -9;
					}
					break;
				case 5:
					if(v270) {
						bs270 |= 4;
					} else {
						bs270 &= -5;
					}
					break;
				case 6:
					if(v270) {
						bs270 |= 2;
					} else {
						bs270 &= -3;
					}
					break;
				case 7:
					if(v270) {
						bs270 |= 1;
					} else {
						bs270 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs270;
			var this272 = 0;
			var bs271 = this272;
			var l271 = "*    ".length;
			var _g1272 = 0;
			var _g372 = l271;
			while(_g1272 < _g372) {
				var i272 = _g1272++;
				var no271 = "*    ".charCodeAt(i272);
				if(no271 == null) {
					break;
				}
				var v271;
				switch(no271) {
				case 32:
					v271 = false;
					break;
				case 42:
					v271 = true;
					break;
				case 48:
					v271 = false;
					break;
				case 49:
					v271 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i272)));
				}
				switch(i272 - (l271 - 8)) {
				case 0:
					if(v271) {
						bs271 |= 128;
					} else {
						bs271 &= -129;
					}
					break;
				case 1:
					if(v271) {
						bs271 |= 64;
					} else {
						bs271 &= -65;
					}
					break;
				case 2:
					if(v271) {
						bs271 |= 32;
					} else {
						bs271 &= -33;
					}
					break;
				case 3:
					if(v271) {
						bs271 |= 16;
					} else {
						bs271 &= -17;
					}
					break;
				case 4:
					if(v271) {
						bs271 |= 8;
					} else {
						bs271 &= -9;
					}
					break;
				case 5:
					if(v271) {
						bs271 |= 4;
					} else {
						bs271 &= -5;
					}
					break;
				case 6:
					if(v271) {
						bs271 |= 2;
					} else {
						bs271 &= -3;
					}
					break;
				case 7:
					if(v271) {
						bs271 |= 1;
					} else {
						bs271 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs271;
			var this273 = 0;
			var bs272 = this273;
			var l272 = "*    ".length;
			var _g1273 = 0;
			var _g373 = l272;
			while(_g1273 < _g373) {
				var i273 = _g1273++;
				var no272 = "*    ".charCodeAt(i273);
				if(no272 == null) {
					break;
				}
				var v272;
				switch(no272) {
				case 32:
					v272 = false;
					break;
				case 42:
					v272 = true;
					break;
				case 48:
					v272 = false;
					break;
				case 49:
					v272 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i273)));
				}
				switch(i273 - (l272 - 8)) {
				case 0:
					if(v272) {
						bs272 |= 128;
					} else {
						bs272 &= -129;
					}
					break;
				case 1:
					if(v272) {
						bs272 |= 64;
					} else {
						bs272 &= -65;
					}
					break;
				case 2:
					if(v272) {
						bs272 |= 32;
					} else {
						bs272 &= -33;
					}
					break;
				case 3:
					if(v272) {
						bs272 |= 16;
					} else {
						bs272 &= -17;
					}
					break;
				case 4:
					if(v272) {
						bs272 |= 8;
					} else {
						bs272 &= -9;
					}
					break;
				case 5:
					if(v272) {
						bs272 |= 4;
					} else {
						bs272 &= -5;
					}
					break;
				case 6:
					if(v272) {
						bs272 |= 2;
					} else {
						bs272 &= -3;
					}
					break;
				case 7:
					if(v272) {
						bs272 |= 1;
					} else {
						bs272 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs272;
			break;
		case 71:
			var this274 = 0;
			var bs273 = this274;
			var l273 = " *** ".length;
			var _g1274 = 0;
			var _g374 = l273;
			while(_g1274 < _g374) {
				var i274 = _g1274++;
				var no273 = " *** ".charCodeAt(i274);
				if(no273 == null) {
					break;
				}
				var v273;
				switch(no273) {
				case 32:
					v273 = false;
					break;
				case 42:
					v273 = true;
					break;
				case 48:
					v273 = false;
					break;
				case 49:
					v273 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i274)));
				}
				switch(i274 - (l273 - 8)) {
				case 0:
					if(v273) {
						bs273 |= 128;
					} else {
						bs273 &= -129;
					}
					break;
				case 1:
					if(v273) {
						bs273 |= 64;
					} else {
						bs273 &= -65;
					}
					break;
				case 2:
					if(v273) {
						bs273 |= 32;
					} else {
						bs273 &= -33;
					}
					break;
				case 3:
					if(v273) {
						bs273 |= 16;
					} else {
						bs273 &= -17;
					}
					break;
				case 4:
					if(v273) {
						bs273 |= 8;
					} else {
						bs273 &= -9;
					}
					break;
				case 5:
					if(v273) {
						bs273 |= 4;
					} else {
						bs273 &= -5;
					}
					break;
				case 6:
					if(v273) {
						bs273 |= 2;
					} else {
						bs273 &= -3;
					}
					break;
				case 7:
					if(v273) {
						bs273 |= 1;
					} else {
						bs273 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs273;
			var this275 = 0;
			var bs274 = this275;
			var l274 = "*   *".length;
			var _g1275 = 0;
			var _g375 = l274;
			while(_g1275 < _g375) {
				var i275 = _g1275++;
				var no274 = "*   *".charCodeAt(i275);
				if(no274 == null) {
					break;
				}
				var v274;
				switch(no274) {
				case 32:
					v274 = false;
					break;
				case 42:
					v274 = true;
					break;
				case 48:
					v274 = false;
					break;
				case 49:
					v274 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i275)));
				}
				switch(i275 - (l274 - 8)) {
				case 0:
					if(v274) {
						bs274 |= 128;
					} else {
						bs274 &= -129;
					}
					break;
				case 1:
					if(v274) {
						bs274 |= 64;
					} else {
						bs274 &= -65;
					}
					break;
				case 2:
					if(v274) {
						bs274 |= 32;
					} else {
						bs274 &= -33;
					}
					break;
				case 3:
					if(v274) {
						bs274 |= 16;
					} else {
						bs274 &= -17;
					}
					break;
				case 4:
					if(v274) {
						bs274 |= 8;
					} else {
						bs274 &= -9;
					}
					break;
				case 5:
					if(v274) {
						bs274 |= 4;
					} else {
						bs274 &= -5;
					}
					break;
				case 6:
					if(v274) {
						bs274 |= 2;
					} else {
						bs274 &= -3;
					}
					break;
				case 7:
					if(v274) {
						bs274 |= 1;
					} else {
						bs274 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs274;
			var this276 = 0;
			var bs275 = this276;
			var l275 = "*    ".length;
			var _g1276 = 0;
			var _g376 = l275;
			while(_g1276 < _g376) {
				var i276 = _g1276++;
				var no275 = "*    ".charCodeAt(i276);
				if(no275 == null) {
					break;
				}
				var v275;
				switch(no275) {
				case 32:
					v275 = false;
					break;
				case 42:
					v275 = true;
					break;
				case 48:
					v275 = false;
					break;
				case 49:
					v275 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i276)));
				}
				switch(i276 - (l275 - 8)) {
				case 0:
					if(v275) {
						bs275 |= 128;
					} else {
						bs275 &= -129;
					}
					break;
				case 1:
					if(v275) {
						bs275 |= 64;
					} else {
						bs275 &= -65;
					}
					break;
				case 2:
					if(v275) {
						bs275 |= 32;
					} else {
						bs275 &= -33;
					}
					break;
				case 3:
					if(v275) {
						bs275 |= 16;
					} else {
						bs275 &= -17;
					}
					break;
				case 4:
					if(v275) {
						bs275 |= 8;
					} else {
						bs275 &= -9;
					}
					break;
				case 5:
					if(v275) {
						bs275 |= 4;
					} else {
						bs275 &= -5;
					}
					break;
				case 6:
					if(v275) {
						bs275 |= 2;
					} else {
						bs275 &= -3;
					}
					break;
				case 7:
					if(v275) {
						bs275 |= 1;
					} else {
						bs275 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs275;
			var this277 = 0;
			var bs276 = this277;
			var l276 = "* ***".length;
			var _g1277 = 0;
			var _g377 = l276;
			while(_g1277 < _g377) {
				var i277 = _g1277++;
				var no276 = "* ***".charCodeAt(i277);
				if(no276 == null) {
					break;
				}
				var v276;
				switch(no276) {
				case 32:
					v276 = false;
					break;
				case 42:
					v276 = true;
					break;
				case 48:
					v276 = false;
					break;
				case 49:
					v276 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* ***".charCodeAt(i277)));
				}
				switch(i277 - (l276 - 8)) {
				case 0:
					if(v276) {
						bs276 |= 128;
					} else {
						bs276 &= -129;
					}
					break;
				case 1:
					if(v276) {
						bs276 |= 64;
					} else {
						bs276 &= -65;
					}
					break;
				case 2:
					if(v276) {
						bs276 |= 32;
					} else {
						bs276 &= -33;
					}
					break;
				case 3:
					if(v276) {
						bs276 |= 16;
					} else {
						bs276 &= -17;
					}
					break;
				case 4:
					if(v276) {
						bs276 |= 8;
					} else {
						bs276 &= -9;
					}
					break;
				case 5:
					if(v276) {
						bs276 |= 4;
					} else {
						bs276 &= -5;
					}
					break;
				case 6:
					if(v276) {
						bs276 |= 2;
					} else {
						bs276 &= -3;
					}
					break;
				case 7:
					if(v276) {
						bs276 |= 1;
					} else {
						bs276 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs276;
			var this278 = 0;
			var bs277 = this278;
			var l277 = "*   *".length;
			var _g1278 = 0;
			var _g378 = l277;
			while(_g1278 < _g378) {
				var i278 = _g1278++;
				var no277 = "*   *".charCodeAt(i278);
				if(no277 == null) {
					break;
				}
				var v277;
				switch(no277) {
				case 32:
					v277 = false;
					break;
				case 42:
					v277 = true;
					break;
				case 48:
					v277 = false;
					break;
				case 49:
					v277 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i278)));
				}
				switch(i278 - (l277 - 8)) {
				case 0:
					if(v277) {
						bs277 |= 128;
					} else {
						bs277 &= -129;
					}
					break;
				case 1:
					if(v277) {
						bs277 |= 64;
					} else {
						bs277 &= -65;
					}
					break;
				case 2:
					if(v277) {
						bs277 |= 32;
					} else {
						bs277 &= -33;
					}
					break;
				case 3:
					if(v277) {
						bs277 |= 16;
					} else {
						bs277 &= -17;
					}
					break;
				case 4:
					if(v277) {
						bs277 |= 8;
					} else {
						bs277 &= -9;
					}
					break;
				case 5:
					if(v277) {
						bs277 |= 4;
					} else {
						bs277 &= -5;
					}
					break;
				case 6:
					if(v277) {
						bs277 |= 2;
					} else {
						bs277 &= -3;
					}
					break;
				case 7:
					if(v277) {
						bs277 |= 1;
					} else {
						bs277 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs277;
			var this279 = 0;
			var bs278 = this279;
			var l278 = "*   *".length;
			var _g1279 = 0;
			var _g379 = l278;
			while(_g1279 < _g379) {
				var i279 = _g1279++;
				var no278 = "*   *".charCodeAt(i279);
				if(no278 == null) {
					break;
				}
				var v278;
				switch(no278) {
				case 32:
					v278 = false;
					break;
				case 42:
					v278 = true;
					break;
				case 48:
					v278 = false;
					break;
				case 49:
					v278 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i279)));
				}
				switch(i279 - (l278 - 8)) {
				case 0:
					if(v278) {
						bs278 |= 128;
					} else {
						bs278 &= -129;
					}
					break;
				case 1:
					if(v278) {
						bs278 |= 64;
					} else {
						bs278 &= -65;
					}
					break;
				case 2:
					if(v278) {
						bs278 |= 32;
					} else {
						bs278 &= -33;
					}
					break;
				case 3:
					if(v278) {
						bs278 |= 16;
					} else {
						bs278 &= -17;
					}
					break;
				case 4:
					if(v278) {
						bs278 |= 8;
					} else {
						bs278 &= -9;
					}
					break;
				case 5:
					if(v278) {
						bs278 |= 4;
					} else {
						bs278 &= -5;
					}
					break;
				case 6:
					if(v278) {
						bs278 |= 2;
					} else {
						bs278 &= -3;
					}
					break;
				case 7:
					if(v278) {
						bs278 |= 1;
					} else {
						bs278 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs278;
			var this280 = 0;
			var bs279 = this280;
			var l279 = " ****".length;
			var _g1280 = 0;
			var _g380 = l279;
			while(_g1280 < _g380) {
				var i280 = _g1280++;
				var no279 = " ****".charCodeAt(i280);
				if(no279 == null) {
					break;
				}
				var v279;
				switch(no279) {
				case 32:
					v279 = false;
					break;
				case 42:
					v279 = true;
					break;
				case 48:
					v279 = false;
					break;
				case 49:
					v279 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i280)));
				}
				switch(i280 - (l279 - 8)) {
				case 0:
					if(v279) {
						bs279 |= 128;
					} else {
						bs279 &= -129;
					}
					break;
				case 1:
					if(v279) {
						bs279 |= 64;
					} else {
						bs279 &= -65;
					}
					break;
				case 2:
					if(v279) {
						bs279 |= 32;
					} else {
						bs279 &= -33;
					}
					break;
				case 3:
					if(v279) {
						bs279 |= 16;
					} else {
						bs279 &= -17;
					}
					break;
				case 4:
					if(v279) {
						bs279 |= 8;
					} else {
						bs279 &= -9;
					}
					break;
				case 5:
					if(v279) {
						bs279 |= 4;
					} else {
						bs279 &= -5;
					}
					break;
				case 6:
					if(v279) {
						bs279 |= 2;
					} else {
						bs279 &= -3;
					}
					break;
				case 7:
					if(v279) {
						bs279 |= 1;
					} else {
						bs279 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs279;
			break;
		case 72:
			var this281 = 0;
			var bs280 = this281;
			var l280 = "*   *".length;
			var _g1281 = 0;
			var _g381 = l280;
			while(_g1281 < _g381) {
				var i281 = _g1281++;
				var no280 = "*   *".charCodeAt(i281);
				if(no280 == null) {
					break;
				}
				var v280;
				switch(no280) {
				case 32:
					v280 = false;
					break;
				case 42:
					v280 = true;
					break;
				case 48:
					v280 = false;
					break;
				case 49:
					v280 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i281)));
				}
				switch(i281 - (l280 - 8)) {
				case 0:
					if(v280) {
						bs280 |= 128;
					} else {
						bs280 &= -129;
					}
					break;
				case 1:
					if(v280) {
						bs280 |= 64;
					} else {
						bs280 &= -65;
					}
					break;
				case 2:
					if(v280) {
						bs280 |= 32;
					} else {
						bs280 &= -33;
					}
					break;
				case 3:
					if(v280) {
						bs280 |= 16;
					} else {
						bs280 &= -17;
					}
					break;
				case 4:
					if(v280) {
						bs280 |= 8;
					} else {
						bs280 &= -9;
					}
					break;
				case 5:
					if(v280) {
						bs280 |= 4;
					} else {
						bs280 &= -5;
					}
					break;
				case 6:
					if(v280) {
						bs280 |= 2;
					} else {
						bs280 &= -3;
					}
					break;
				case 7:
					if(v280) {
						bs280 |= 1;
					} else {
						bs280 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs280;
			var this282 = 0;
			var bs281 = this282;
			var l281 = "*   *".length;
			var _g1282 = 0;
			var _g382 = l281;
			while(_g1282 < _g382) {
				var i282 = _g1282++;
				var no281 = "*   *".charCodeAt(i282);
				if(no281 == null) {
					break;
				}
				var v281;
				switch(no281) {
				case 32:
					v281 = false;
					break;
				case 42:
					v281 = true;
					break;
				case 48:
					v281 = false;
					break;
				case 49:
					v281 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i282)));
				}
				switch(i282 - (l281 - 8)) {
				case 0:
					if(v281) {
						bs281 |= 128;
					} else {
						bs281 &= -129;
					}
					break;
				case 1:
					if(v281) {
						bs281 |= 64;
					} else {
						bs281 &= -65;
					}
					break;
				case 2:
					if(v281) {
						bs281 |= 32;
					} else {
						bs281 &= -33;
					}
					break;
				case 3:
					if(v281) {
						bs281 |= 16;
					} else {
						bs281 &= -17;
					}
					break;
				case 4:
					if(v281) {
						bs281 |= 8;
					} else {
						bs281 &= -9;
					}
					break;
				case 5:
					if(v281) {
						bs281 |= 4;
					} else {
						bs281 &= -5;
					}
					break;
				case 6:
					if(v281) {
						bs281 |= 2;
					} else {
						bs281 &= -3;
					}
					break;
				case 7:
					if(v281) {
						bs281 |= 1;
					} else {
						bs281 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs281;
			var this283 = 0;
			var bs282 = this283;
			var l282 = "*   *".length;
			var _g1283 = 0;
			var _g383 = l282;
			while(_g1283 < _g383) {
				var i283 = _g1283++;
				var no282 = "*   *".charCodeAt(i283);
				if(no282 == null) {
					break;
				}
				var v282;
				switch(no282) {
				case 32:
					v282 = false;
					break;
				case 42:
					v282 = true;
					break;
				case 48:
					v282 = false;
					break;
				case 49:
					v282 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i283)));
				}
				switch(i283 - (l282 - 8)) {
				case 0:
					if(v282) {
						bs282 |= 128;
					} else {
						bs282 &= -129;
					}
					break;
				case 1:
					if(v282) {
						bs282 |= 64;
					} else {
						bs282 &= -65;
					}
					break;
				case 2:
					if(v282) {
						bs282 |= 32;
					} else {
						bs282 &= -33;
					}
					break;
				case 3:
					if(v282) {
						bs282 |= 16;
					} else {
						bs282 &= -17;
					}
					break;
				case 4:
					if(v282) {
						bs282 |= 8;
					} else {
						bs282 &= -9;
					}
					break;
				case 5:
					if(v282) {
						bs282 |= 4;
					} else {
						bs282 &= -5;
					}
					break;
				case 6:
					if(v282) {
						bs282 |= 2;
					} else {
						bs282 &= -3;
					}
					break;
				case 7:
					if(v282) {
						bs282 |= 1;
					} else {
						bs282 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs282;
			var this284 = 0;
			var bs283 = this284;
			var l283 = "*****".length;
			var _g1284 = 0;
			var _g384 = l283;
			while(_g1284 < _g384) {
				var i284 = _g1284++;
				var no283 = "*****".charCodeAt(i284);
				if(no283 == null) {
					break;
				}
				var v283;
				switch(no283) {
				case 32:
					v283 = false;
					break;
				case 42:
					v283 = true;
					break;
				case 48:
					v283 = false;
					break;
				case 49:
					v283 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i284)));
				}
				switch(i284 - (l283 - 8)) {
				case 0:
					if(v283) {
						bs283 |= 128;
					} else {
						bs283 &= -129;
					}
					break;
				case 1:
					if(v283) {
						bs283 |= 64;
					} else {
						bs283 &= -65;
					}
					break;
				case 2:
					if(v283) {
						bs283 |= 32;
					} else {
						bs283 &= -33;
					}
					break;
				case 3:
					if(v283) {
						bs283 |= 16;
					} else {
						bs283 &= -17;
					}
					break;
				case 4:
					if(v283) {
						bs283 |= 8;
					} else {
						bs283 &= -9;
					}
					break;
				case 5:
					if(v283) {
						bs283 |= 4;
					} else {
						bs283 &= -5;
					}
					break;
				case 6:
					if(v283) {
						bs283 |= 2;
					} else {
						bs283 &= -3;
					}
					break;
				case 7:
					if(v283) {
						bs283 |= 1;
					} else {
						bs283 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs283;
			var this285 = 0;
			var bs284 = this285;
			var l284 = "*   *".length;
			var _g1285 = 0;
			var _g385 = l284;
			while(_g1285 < _g385) {
				var i285 = _g1285++;
				var no284 = "*   *".charCodeAt(i285);
				if(no284 == null) {
					break;
				}
				var v284;
				switch(no284) {
				case 32:
					v284 = false;
					break;
				case 42:
					v284 = true;
					break;
				case 48:
					v284 = false;
					break;
				case 49:
					v284 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i285)));
				}
				switch(i285 - (l284 - 8)) {
				case 0:
					if(v284) {
						bs284 |= 128;
					} else {
						bs284 &= -129;
					}
					break;
				case 1:
					if(v284) {
						bs284 |= 64;
					} else {
						bs284 &= -65;
					}
					break;
				case 2:
					if(v284) {
						bs284 |= 32;
					} else {
						bs284 &= -33;
					}
					break;
				case 3:
					if(v284) {
						bs284 |= 16;
					} else {
						bs284 &= -17;
					}
					break;
				case 4:
					if(v284) {
						bs284 |= 8;
					} else {
						bs284 &= -9;
					}
					break;
				case 5:
					if(v284) {
						bs284 |= 4;
					} else {
						bs284 &= -5;
					}
					break;
				case 6:
					if(v284) {
						bs284 |= 2;
					} else {
						bs284 &= -3;
					}
					break;
				case 7:
					if(v284) {
						bs284 |= 1;
					} else {
						bs284 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs284;
			var this286 = 0;
			var bs285 = this286;
			var l285 = "*   *".length;
			var _g1286 = 0;
			var _g386 = l285;
			while(_g1286 < _g386) {
				var i286 = _g1286++;
				var no285 = "*   *".charCodeAt(i286);
				if(no285 == null) {
					break;
				}
				var v285;
				switch(no285) {
				case 32:
					v285 = false;
					break;
				case 42:
					v285 = true;
					break;
				case 48:
					v285 = false;
					break;
				case 49:
					v285 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i286)));
				}
				switch(i286 - (l285 - 8)) {
				case 0:
					if(v285) {
						bs285 |= 128;
					} else {
						bs285 &= -129;
					}
					break;
				case 1:
					if(v285) {
						bs285 |= 64;
					} else {
						bs285 &= -65;
					}
					break;
				case 2:
					if(v285) {
						bs285 |= 32;
					} else {
						bs285 &= -33;
					}
					break;
				case 3:
					if(v285) {
						bs285 |= 16;
					} else {
						bs285 &= -17;
					}
					break;
				case 4:
					if(v285) {
						bs285 |= 8;
					} else {
						bs285 &= -9;
					}
					break;
				case 5:
					if(v285) {
						bs285 |= 4;
					} else {
						bs285 &= -5;
					}
					break;
				case 6:
					if(v285) {
						bs285 |= 2;
					} else {
						bs285 &= -3;
					}
					break;
				case 7:
					if(v285) {
						bs285 |= 1;
					} else {
						bs285 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs285;
			var this287 = 0;
			var bs286 = this287;
			var l286 = "*   *".length;
			var _g1287 = 0;
			var _g387 = l286;
			while(_g1287 < _g387) {
				var i287 = _g1287++;
				var no286 = "*   *".charCodeAt(i287);
				if(no286 == null) {
					break;
				}
				var v286;
				switch(no286) {
				case 32:
					v286 = false;
					break;
				case 42:
					v286 = true;
					break;
				case 48:
					v286 = false;
					break;
				case 49:
					v286 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i287)));
				}
				switch(i287 - (l286 - 8)) {
				case 0:
					if(v286) {
						bs286 |= 128;
					} else {
						bs286 &= -129;
					}
					break;
				case 1:
					if(v286) {
						bs286 |= 64;
					} else {
						bs286 &= -65;
					}
					break;
				case 2:
					if(v286) {
						bs286 |= 32;
					} else {
						bs286 &= -33;
					}
					break;
				case 3:
					if(v286) {
						bs286 |= 16;
					} else {
						bs286 &= -17;
					}
					break;
				case 4:
					if(v286) {
						bs286 |= 8;
					} else {
						bs286 &= -9;
					}
					break;
				case 5:
					if(v286) {
						bs286 |= 4;
					} else {
						bs286 &= -5;
					}
					break;
				case 6:
					if(v286) {
						bs286 |= 2;
					} else {
						bs286 &= -3;
					}
					break;
				case 7:
					if(v286) {
						bs286 |= 1;
					} else {
						bs286 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs286;
			break;
		case 73:
			var this288 = 0;
			var bs287 = this288;
			var l287 = " *** ".length;
			var _g1288 = 0;
			var _g388 = l287;
			while(_g1288 < _g388) {
				var i288 = _g1288++;
				var no287 = " *** ".charCodeAt(i288);
				if(no287 == null) {
					break;
				}
				var v287;
				switch(no287) {
				case 32:
					v287 = false;
					break;
				case 42:
					v287 = true;
					break;
				case 48:
					v287 = false;
					break;
				case 49:
					v287 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i288)));
				}
				switch(i288 - (l287 - 8)) {
				case 0:
					if(v287) {
						bs287 |= 128;
					} else {
						bs287 &= -129;
					}
					break;
				case 1:
					if(v287) {
						bs287 |= 64;
					} else {
						bs287 &= -65;
					}
					break;
				case 2:
					if(v287) {
						bs287 |= 32;
					} else {
						bs287 &= -33;
					}
					break;
				case 3:
					if(v287) {
						bs287 |= 16;
					} else {
						bs287 &= -17;
					}
					break;
				case 4:
					if(v287) {
						bs287 |= 8;
					} else {
						bs287 &= -9;
					}
					break;
				case 5:
					if(v287) {
						bs287 |= 4;
					} else {
						bs287 &= -5;
					}
					break;
				case 6:
					if(v287) {
						bs287 |= 2;
					} else {
						bs287 &= -3;
					}
					break;
				case 7:
					if(v287) {
						bs287 |= 1;
					} else {
						bs287 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs287;
			var this289 = 0;
			var bs288 = this289;
			var l288 = "  *  ".length;
			var _g1289 = 0;
			var _g389 = l288;
			while(_g1289 < _g389) {
				var i289 = _g1289++;
				var no288 = "  *  ".charCodeAt(i289);
				if(no288 == null) {
					break;
				}
				var v288;
				switch(no288) {
				case 32:
					v288 = false;
					break;
				case 42:
					v288 = true;
					break;
				case 48:
					v288 = false;
					break;
				case 49:
					v288 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i289)));
				}
				switch(i289 - (l288 - 8)) {
				case 0:
					if(v288) {
						bs288 |= 128;
					} else {
						bs288 &= -129;
					}
					break;
				case 1:
					if(v288) {
						bs288 |= 64;
					} else {
						bs288 &= -65;
					}
					break;
				case 2:
					if(v288) {
						bs288 |= 32;
					} else {
						bs288 &= -33;
					}
					break;
				case 3:
					if(v288) {
						bs288 |= 16;
					} else {
						bs288 &= -17;
					}
					break;
				case 4:
					if(v288) {
						bs288 |= 8;
					} else {
						bs288 &= -9;
					}
					break;
				case 5:
					if(v288) {
						bs288 |= 4;
					} else {
						bs288 &= -5;
					}
					break;
				case 6:
					if(v288) {
						bs288 |= 2;
					} else {
						bs288 &= -3;
					}
					break;
				case 7:
					if(v288) {
						bs288 |= 1;
					} else {
						bs288 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs288;
			var this290 = 0;
			var bs289 = this290;
			var l289 = "  *  ".length;
			var _g1290 = 0;
			var _g390 = l289;
			while(_g1290 < _g390) {
				var i290 = _g1290++;
				var no289 = "  *  ".charCodeAt(i290);
				if(no289 == null) {
					break;
				}
				var v289;
				switch(no289) {
				case 32:
					v289 = false;
					break;
				case 42:
					v289 = true;
					break;
				case 48:
					v289 = false;
					break;
				case 49:
					v289 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i290)));
				}
				switch(i290 - (l289 - 8)) {
				case 0:
					if(v289) {
						bs289 |= 128;
					} else {
						bs289 &= -129;
					}
					break;
				case 1:
					if(v289) {
						bs289 |= 64;
					} else {
						bs289 &= -65;
					}
					break;
				case 2:
					if(v289) {
						bs289 |= 32;
					} else {
						bs289 &= -33;
					}
					break;
				case 3:
					if(v289) {
						bs289 |= 16;
					} else {
						bs289 &= -17;
					}
					break;
				case 4:
					if(v289) {
						bs289 |= 8;
					} else {
						bs289 &= -9;
					}
					break;
				case 5:
					if(v289) {
						bs289 |= 4;
					} else {
						bs289 &= -5;
					}
					break;
				case 6:
					if(v289) {
						bs289 |= 2;
					} else {
						bs289 &= -3;
					}
					break;
				case 7:
					if(v289) {
						bs289 |= 1;
					} else {
						bs289 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs289;
			var this291 = 0;
			var bs290 = this291;
			var l290 = "  *  ".length;
			var _g1291 = 0;
			var _g391 = l290;
			while(_g1291 < _g391) {
				var i291 = _g1291++;
				var no290 = "  *  ".charCodeAt(i291);
				if(no290 == null) {
					break;
				}
				var v290;
				switch(no290) {
				case 32:
					v290 = false;
					break;
				case 42:
					v290 = true;
					break;
				case 48:
					v290 = false;
					break;
				case 49:
					v290 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i291)));
				}
				switch(i291 - (l290 - 8)) {
				case 0:
					if(v290) {
						bs290 |= 128;
					} else {
						bs290 &= -129;
					}
					break;
				case 1:
					if(v290) {
						bs290 |= 64;
					} else {
						bs290 &= -65;
					}
					break;
				case 2:
					if(v290) {
						bs290 |= 32;
					} else {
						bs290 &= -33;
					}
					break;
				case 3:
					if(v290) {
						bs290 |= 16;
					} else {
						bs290 &= -17;
					}
					break;
				case 4:
					if(v290) {
						bs290 |= 8;
					} else {
						bs290 &= -9;
					}
					break;
				case 5:
					if(v290) {
						bs290 |= 4;
					} else {
						bs290 &= -5;
					}
					break;
				case 6:
					if(v290) {
						bs290 |= 2;
					} else {
						bs290 &= -3;
					}
					break;
				case 7:
					if(v290) {
						bs290 |= 1;
					} else {
						bs290 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs290;
			var this292 = 0;
			var bs291 = this292;
			var l291 = "  *  ".length;
			var _g1292 = 0;
			var _g392 = l291;
			while(_g1292 < _g392) {
				var i292 = _g1292++;
				var no291 = "  *  ".charCodeAt(i292);
				if(no291 == null) {
					break;
				}
				var v291;
				switch(no291) {
				case 32:
					v291 = false;
					break;
				case 42:
					v291 = true;
					break;
				case 48:
					v291 = false;
					break;
				case 49:
					v291 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i292)));
				}
				switch(i292 - (l291 - 8)) {
				case 0:
					if(v291) {
						bs291 |= 128;
					} else {
						bs291 &= -129;
					}
					break;
				case 1:
					if(v291) {
						bs291 |= 64;
					} else {
						bs291 &= -65;
					}
					break;
				case 2:
					if(v291) {
						bs291 |= 32;
					} else {
						bs291 &= -33;
					}
					break;
				case 3:
					if(v291) {
						bs291 |= 16;
					} else {
						bs291 &= -17;
					}
					break;
				case 4:
					if(v291) {
						bs291 |= 8;
					} else {
						bs291 &= -9;
					}
					break;
				case 5:
					if(v291) {
						bs291 |= 4;
					} else {
						bs291 &= -5;
					}
					break;
				case 6:
					if(v291) {
						bs291 |= 2;
					} else {
						bs291 &= -3;
					}
					break;
				case 7:
					if(v291) {
						bs291 |= 1;
					} else {
						bs291 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs291;
			var this293 = 0;
			var bs292 = this293;
			var l292 = "  *  ".length;
			var _g1293 = 0;
			var _g393 = l292;
			while(_g1293 < _g393) {
				var i293 = _g1293++;
				var no292 = "  *  ".charCodeAt(i293);
				if(no292 == null) {
					break;
				}
				var v292;
				switch(no292) {
				case 32:
					v292 = false;
					break;
				case 42:
					v292 = true;
					break;
				case 48:
					v292 = false;
					break;
				case 49:
					v292 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i293)));
				}
				switch(i293 - (l292 - 8)) {
				case 0:
					if(v292) {
						bs292 |= 128;
					} else {
						bs292 &= -129;
					}
					break;
				case 1:
					if(v292) {
						bs292 |= 64;
					} else {
						bs292 &= -65;
					}
					break;
				case 2:
					if(v292) {
						bs292 |= 32;
					} else {
						bs292 &= -33;
					}
					break;
				case 3:
					if(v292) {
						bs292 |= 16;
					} else {
						bs292 &= -17;
					}
					break;
				case 4:
					if(v292) {
						bs292 |= 8;
					} else {
						bs292 &= -9;
					}
					break;
				case 5:
					if(v292) {
						bs292 |= 4;
					} else {
						bs292 &= -5;
					}
					break;
				case 6:
					if(v292) {
						bs292 |= 2;
					} else {
						bs292 &= -3;
					}
					break;
				case 7:
					if(v292) {
						bs292 |= 1;
					} else {
						bs292 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs292;
			var this294 = 0;
			var bs293 = this294;
			var l293 = " *** ".length;
			var _g1294 = 0;
			var _g394 = l293;
			while(_g1294 < _g394) {
				var i294 = _g1294++;
				var no293 = " *** ".charCodeAt(i294);
				if(no293 == null) {
					break;
				}
				var v293;
				switch(no293) {
				case 32:
					v293 = false;
					break;
				case 42:
					v293 = true;
					break;
				case 48:
					v293 = false;
					break;
				case 49:
					v293 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i294)));
				}
				switch(i294 - (l293 - 8)) {
				case 0:
					if(v293) {
						bs293 |= 128;
					} else {
						bs293 &= -129;
					}
					break;
				case 1:
					if(v293) {
						bs293 |= 64;
					} else {
						bs293 &= -65;
					}
					break;
				case 2:
					if(v293) {
						bs293 |= 32;
					} else {
						bs293 &= -33;
					}
					break;
				case 3:
					if(v293) {
						bs293 |= 16;
					} else {
						bs293 &= -17;
					}
					break;
				case 4:
					if(v293) {
						bs293 |= 8;
					} else {
						bs293 &= -9;
					}
					break;
				case 5:
					if(v293) {
						bs293 |= 4;
					} else {
						bs293 &= -5;
					}
					break;
				case 6:
					if(v293) {
						bs293 |= 2;
					} else {
						bs293 &= -3;
					}
					break;
				case 7:
					if(v293) {
						bs293 |= 1;
					} else {
						bs293 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs293;
			break;
		case 74:
			var this295 = 0;
			var bs294 = this295;
			var l294 = " ****".length;
			var _g1295 = 0;
			var _g395 = l294;
			while(_g1295 < _g395) {
				var i295 = _g1295++;
				var no294 = " ****".charCodeAt(i295);
				if(no294 == null) {
					break;
				}
				var v294;
				switch(no294) {
				case 32:
					v294 = false;
					break;
				case 42:
					v294 = true;
					break;
				case 48:
					v294 = false;
					break;
				case 49:
					v294 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i295)));
				}
				switch(i295 - (l294 - 8)) {
				case 0:
					if(v294) {
						bs294 |= 128;
					} else {
						bs294 &= -129;
					}
					break;
				case 1:
					if(v294) {
						bs294 |= 64;
					} else {
						bs294 &= -65;
					}
					break;
				case 2:
					if(v294) {
						bs294 |= 32;
					} else {
						bs294 &= -33;
					}
					break;
				case 3:
					if(v294) {
						bs294 |= 16;
					} else {
						bs294 &= -17;
					}
					break;
				case 4:
					if(v294) {
						bs294 |= 8;
					} else {
						bs294 &= -9;
					}
					break;
				case 5:
					if(v294) {
						bs294 |= 4;
					} else {
						bs294 &= -5;
					}
					break;
				case 6:
					if(v294) {
						bs294 |= 2;
					} else {
						bs294 &= -3;
					}
					break;
				case 7:
					if(v294) {
						bs294 |= 1;
					} else {
						bs294 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs294;
			var this296 = 0;
			var bs295 = this296;
			var l295 = "   * ".length;
			var _g1296 = 0;
			var _g396 = l295;
			while(_g1296 < _g396) {
				var i296 = _g1296++;
				var no295 = "   * ".charCodeAt(i296);
				if(no295 == null) {
					break;
				}
				var v295;
				switch(no295) {
				case 32:
					v295 = false;
					break;
				case 42:
					v295 = true;
					break;
				case 48:
					v295 = false;
					break;
				case 49:
					v295 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i296)));
				}
				switch(i296 - (l295 - 8)) {
				case 0:
					if(v295) {
						bs295 |= 128;
					} else {
						bs295 &= -129;
					}
					break;
				case 1:
					if(v295) {
						bs295 |= 64;
					} else {
						bs295 &= -65;
					}
					break;
				case 2:
					if(v295) {
						bs295 |= 32;
					} else {
						bs295 &= -33;
					}
					break;
				case 3:
					if(v295) {
						bs295 |= 16;
					} else {
						bs295 &= -17;
					}
					break;
				case 4:
					if(v295) {
						bs295 |= 8;
					} else {
						bs295 &= -9;
					}
					break;
				case 5:
					if(v295) {
						bs295 |= 4;
					} else {
						bs295 &= -5;
					}
					break;
				case 6:
					if(v295) {
						bs295 |= 2;
					} else {
						bs295 &= -3;
					}
					break;
				case 7:
					if(v295) {
						bs295 |= 1;
					} else {
						bs295 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs295;
			var this297 = 0;
			var bs296 = this297;
			var l296 = "   * ".length;
			var _g1297 = 0;
			var _g397 = l296;
			while(_g1297 < _g397) {
				var i297 = _g1297++;
				var no296 = "   * ".charCodeAt(i297);
				if(no296 == null) {
					break;
				}
				var v296;
				switch(no296) {
				case 32:
					v296 = false;
					break;
				case 42:
					v296 = true;
					break;
				case 48:
					v296 = false;
					break;
				case 49:
					v296 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i297)));
				}
				switch(i297 - (l296 - 8)) {
				case 0:
					if(v296) {
						bs296 |= 128;
					} else {
						bs296 &= -129;
					}
					break;
				case 1:
					if(v296) {
						bs296 |= 64;
					} else {
						bs296 &= -65;
					}
					break;
				case 2:
					if(v296) {
						bs296 |= 32;
					} else {
						bs296 &= -33;
					}
					break;
				case 3:
					if(v296) {
						bs296 |= 16;
					} else {
						bs296 &= -17;
					}
					break;
				case 4:
					if(v296) {
						bs296 |= 8;
					} else {
						bs296 &= -9;
					}
					break;
				case 5:
					if(v296) {
						bs296 |= 4;
					} else {
						bs296 &= -5;
					}
					break;
				case 6:
					if(v296) {
						bs296 |= 2;
					} else {
						bs296 &= -3;
					}
					break;
				case 7:
					if(v296) {
						bs296 |= 1;
					} else {
						bs296 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs296;
			var this298 = 0;
			var bs297 = this298;
			var l297 = "   * ".length;
			var _g1298 = 0;
			var _g398 = l297;
			while(_g1298 < _g398) {
				var i298 = _g1298++;
				var no297 = "   * ".charCodeAt(i298);
				if(no297 == null) {
					break;
				}
				var v297;
				switch(no297) {
				case 32:
					v297 = false;
					break;
				case 42:
					v297 = true;
					break;
				case 48:
					v297 = false;
					break;
				case 49:
					v297 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i298)));
				}
				switch(i298 - (l297 - 8)) {
				case 0:
					if(v297) {
						bs297 |= 128;
					} else {
						bs297 &= -129;
					}
					break;
				case 1:
					if(v297) {
						bs297 |= 64;
					} else {
						bs297 &= -65;
					}
					break;
				case 2:
					if(v297) {
						bs297 |= 32;
					} else {
						bs297 &= -33;
					}
					break;
				case 3:
					if(v297) {
						bs297 |= 16;
					} else {
						bs297 &= -17;
					}
					break;
				case 4:
					if(v297) {
						bs297 |= 8;
					} else {
						bs297 &= -9;
					}
					break;
				case 5:
					if(v297) {
						bs297 |= 4;
					} else {
						bs297 &= -5;
					}
					break;
				case 6:
					if(v297) {
						bs297 |= 2;
					} else {
						bs297 &= -3;
					}
					break;
				case 7:
					if(v297) {
						bs297 |= 1;
					} else {
						bs297 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs297;
			var this299 = 0;
			var bs298 = this299;
			var l298 = "   * ".length;
			var _g1299 = 0;
			var _g399 = l298;
			while(_g1299 < _g399) {
				var i299 = _g1299++;
				var no298 = "   * ".charCodeAt(i299);
				if(no298 == null) {
					break;
				}
				var v298;
				switch(no298) {
				case 32:
					v298 = false;
					break;
				case 42:
					v298 = true;
					break;
				case 48:
					v298 = false;
					break;
				case 49:
					v298 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i299)));
				}
				switch(i299 - (l298 - 8)) {
				case 0:
					if(v298) {
						bs298 |= 128;
					} else {
						bs298 &= -129;
					}
					break;
				case 1:
					if(v298) {
						bs298 |= 64;
					} else {
						bs298 &= -65;
					}
					break;
				case 2:
					if(v298) {
						bs298 |= 32;
					} else {
						bs298 &= -33;
					}
					break;
				case 3:
					if(v298) {
						bs298 |= 16;
					} else {
						bs298 &= -17;
					}
					break;
				case 4:
					if(v298) {
						bs298 |= 8;
					} else {
						bs298 &= -9;
					}
					break;
				case 5:
					if(v298) {
						bs298 |= 4;
					} else {
						bs298 &= -5;
					}
					break;
				case 6:
					if(v298) {
						bs298 |= 2;
					} else {
						bs298 &= -3;
					}
					break;
				case 7:
					if(v298) {
						bs298 |= 1;
					} else {
						bs298 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs298;
			var this300 = 0;
			var bs299 = this300;
			var l299 = "*  * ".length;
			var _g1300 = 0;
			var _g400 = l299;
			while(_g1300 < _g400) {
				var i300 = _g1300++;
				var no299 = "*  * ".charCodeAt(i300);
				if(no299 == null) {
					break;
				}
				var v299;
				switch(no299) {
				case 32:
					v299 = false;
					break;
				case 42:
					v299 = true;
					break;
				case 48:
					v299 = false;
					break;
				case 49:
					v299 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i300)));
				}
				switch(i300 - (l299 - 8)) {
				case 0:
					if(v299) {
						bs299 |= 128;
					} else {
						bs299 &= -129;
					}
					break;
				case 1:
					if(v299) {
						bs299 |= 64;
					} else {
						bs299 &= -65;
					}
					break;
				case 2:
					if(v299) {
						bs299 |= 32;
					} else {
						bs299 &= -33;
					}
					break;
				case 3:
					if(v299) {
						bs299 |= 16;
					} else {
						bs299 &= -17;
					}
					break;
				case 4:
					if(v299) {
						bs299 |= 8;
					} else {
						bs299 &= -9;
					}
					break;
				case 5:
					if(v299) {
						bs299 |= 4;
					} else {
						bs299 &= -5;
					}
					break;
				case 6:
					if(v299) {
						bs299 |= 2;
					} else {
						bs299 &= -3;
					}
					break;
				case 7:
					if(v299) {
						bs299 |= 1;
					} else {
						bs299 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs299;
			var this301 = 0;
			var bs300 = this301;
			var l300 = " **  ".length;
			var _g1301 = 0;
			var _g401 = l300;
			while(_g1301 < _g401) {
				var i301 = _g1301++;
				var no300 = " **  ".charCodeAt(i301);
				if(no300 == null) {
					break;
				}
				var v300;
				switch(no300) {
				case 32:
					v300 = false;
					break;
				case 42:
					v300 = true;
					break;
				case 48:
					v300 = false;
					break;
				case 49:
					v300 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i301)));
				}
				switch(i301 - (l300 - 8)) {
				case 0:
					if(v300) {
						bs300 |= 128;
					} else {
						bs300 &= -129;
					}
					break;
				case 1:
					if(v300) {
						bs300 |= 64;
					} else {
						bs300 &= -65;
					}
					break;
				case 2:
					if(v300) {
						bs300 |= 32;
					} else {
						bs300 &= -33;
					}
					break;
				case 3:
					if(v300) {
						bs300 |= 16;
					} else {
						bs300 &= -17;
					}
					break;
				case 4:
					if(v300) {
						bs300 |= 8;
					} else {
						bs300 &= -9;
					}
					break;
				case 5:
					if(v300) {
						bs300 |= 4;
					} else {
						bs300 &= -5;
					}
					break;
				case 6:
					if(v300) {
						bs300 |= 2;
					} else {
						bs300 &= -3;
					}
					break;
				case 7:
					if(v300) {
						bs300 |= 1;
					} else {
						bs300 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs300;
			break;
		case 75:
			var this302 = 0;
			var bs301 = this302;
			var l301 = "*   *".length;
			var _g1302 = 0;
			var _g402 = l301;
			while(_g1302 < _g402) {
				var i302 = _g1302++;
				var no301 = "*   *".charCodeAt(i302);
				if(no301 == null) {
					break;
				}
				var v301;
				switch(no301) {
				case 32:
					v301 = false;
					break;
				case 42:
					v301 = true;
					break;
				case 48:
					v301 = false;
					break;
				case 49:
					v301 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i302)));
				}
				switch(i302 - (l301 - 8)) {
				case 0:
					if(v301) {
						bs301 |= 128;
					} else {
						bs301 &= -129;
					}
					break;
				case 1:
					if(v301) {
						bs301 |= 64;
					} else {
						bs301 &= -65;
					}
					break;
				case 2:
					if(v301) {
						bs301 |= 32;
					} else {
						bs301 &= -33;
					}
					break;
				case 3:
					if(v301) {
						bs301 |= 16;
					} else {
						bs301 &= -17;
					}
					break;
				case 4:
					if(v301) {
						bs301 |= 8;
					} else {
						bs301 &= -9;
					}
					break;
				case 5:
					if(v301) {
						bs301 |= 4;
					} else {
						bs301 &= -5;
					}
					break;
				case 6:
					if(v301) {
						bs301 |= 2;
					} else {
						bs301 &= -3;
					}
					break;
				case 7:
					if(v301) {
						bs301 |= 1;
					} else {
						bs301 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs301;
			var this303 = 0;
			var bs302 = this303;
			var l302 = "*  * ".length;
			var _g1303 = 0;
			var _g403 = l302;
			while(_g1303 < _g403) {
				var i303 = _g1303++;
				var no302 = "*  * ".charCodeAt(i303);
				if(no302 == null) {
					break;
				}
				var v302;
				switch(no302) {
				case 32:
					v302 = false;
					break;
				case 42:
					v302 = true;
					break;
				case 48:
					v302 = false;
					break;
				case 49:
					v302 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i303)));
				}
				switch(i303 - (l302 - 8)) {
				case 0:
					if(v302) {
						bs302 |= 128;
					} else {
						bs302 &= -129;
					}
					break;
				case 1:
					if(v302) {
						bs302 |= 64;
					} else {
						bs302 &= -65;
					}
					break;
				case 2:
					if(v302) {
						bs302 |= 32;
					} else {
						bs302 &= -33;
					}
					break;
				case 3:
					if(v302) {
						bs302 |= 16;
					} else {
						bs302 &= -17;
					}
					break;
				case 4:
					if(v302) {
						bs302 |= 8;
					} else {
						bs302 &= -9;
					}
					break;
				case 5:
					if(v302) {
						bs302 |= 4;
					} else {
						bs302 &= -5;
					}
					break;
				case 6:
					if(v302) {
						bs302 |= 2;
					} else {
						bs302 &= -3;
					}
					break;
				case 7:
					if(v302) {
						bs302 |= 1;
					} else {
						bs302 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs302;
			var this304 = 0;
			var bs303 = this304;
			var l303 = "* *  ".length;
			var _g1304 = 0;
			var _g404 = l303;
			while(_g1304 < _g404) {
				var i304 = _g1304++;
				var no303 = "* *  ".charCodeAt(i304);
				if(no303 == null) {
					break;
				}
				var v303;
				switch(no303) {
				case 32:
					v303 = false;
					break;
				case 42:
					v303 = true;
					break;
				case 48:
					v303 = false;
					break;
				case 49:
					v303 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i304)));
				}
				switch(i304 - (l303 - 8)) {
				case 0:
					if(v303) {
						bs303 |= 128;
					} else {
						bs303 &= -129;
					}
					break;
				case 1:
					if(v303) {
						bs303 |= 64;
					} else {
						bs303 &= -65;
					}
					break;
				case 2:
					if(v303) {
						bs303 |= 32;
					} else {
						bs303 &= -33;
					}
					break;
				case 3:
					if(v303) {
						bs303 |= 16;
					} else {
						bs303 &= -17;
					}
					break;
				case 4:
					if(v303) {
						bs303 |= 8;
					} else {
						bs303 &= -9;
					}
					break;
				case 5:
					if(v303) {
						bs303 |= 4;
					} else {
						bs303 &= -5;
					}
					break;
				case 6:
					if(v303) {
						bs303 |= 2;
					} else {
						bs303 &= -3;
					}
					break;
				case 7:
					if(v303) {
						bs303 |= 1;
					} else {
						bs303 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs303;
			var this305 = 0;
			var bs304 = this305;
			var l304 = "**   ".length;
			var _g1305 = 0;
			var _g405 = l304;
			while(_g1305 < _g405) {
				var i305 = _g1305++;
				var no304 = "**   ".charCodeAt(i305);
				if(no304 == null) {
					break;
				}
				var v304;
				switch(no304) {
				case 32:
					v304 = false;
					break;
				case 42:
					v304 = true;
					break;
				case 48:
					v304 = false;
					break;
				case 49:
					v304 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**   ".charCodeAt(i305)));
				}
				switch(i305 - (l304 - 8)) {
				case 0:
					if(v304) {
						bs304 |= 128;
					} else {
						bs304 &= -129;
					}
					break;
				case 1:
					if(v304) {
						bs304 |= 64;
					} else {
						bs304 &= -65;
					}
					break;
				case 2:
					if(v304) {
						bs304 |= 32;
					} else {
						bs304 &= -33;
					}
					break;
				case 3:
					if(v304) {
						bs304 |= 16;
					} else {
						bs304 &= -17;
					}
					break;
				case 4:
					if(v304) {
						bs304 |= 8;
					} else {
						bs304 &= -9;
					}
					break;
				case 5:
					if(v304) {
						bs304 |= 4;
					} else {
						bs304 &= -5;
					}
					break;
				case 6:
					if(v304) {
						bs304 |= 2;
					} else {
						bs304 &= -3;
					}
					break;
				case 7:
					if(v304) {
						bs304 |= 1;
					} else {
						bs304 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs304;
			var this306 = 0;
			var bs305 = this306;
			var l305 = "* *  ".length;
			var _g1306 = 0;
			var _g406 = l305;
			while(_g1306 < _g406) {
				var i306 = _g1306++;
				var no305 = "* *  ".charCodeAt(i306);
				if(no305 == null) {
					break;
				}
				var v305;
				switch(no305) {
				case 32:
					v305 = false;
					break;
				case 42:
					v305 = true;
					break;
				case 48:
					v305 = false;
					break;
				case 49:
					v305 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i306)));
				}
				switch(i306 - (l305 - 8)) {
				case 0:
					if(v305) {
						bs305 |= 128;
					} else {
						bs305 &= -129;
					}
					break;
				case 1:
					if(v305) {
						bs305 |= 64;
					} else {
						bs305 &= -65;
					}
					break;
				case 2:
					if(v305) {
						bs305 |= 32;
					} else {
						bs305 &= -33;
					}
					break;
				case 3:
					if(v305) {
						bs305 |= 16;
					} else {
						bs305 &= -17;
					}
					break;
				case 4:
					if(v305) {
						bs305 |= 8;
					} else {
						bs305 &= -9;
					}
					break;
				case 5:
					if(v305) {
						bs305 |= 4;
					} else {
						bs305 &= -5;
					}
					break;
				case 6:
					if(v305) {
						bs305 |= 2;
					} else {
						bs305 &= -3;
					}
					break;
				case 7:
					if(v305) {
						bs305 |= 1;
					} else {
						bs305 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs305;
			var this307 = 0;
			var bs306 = this307;
			var l306 = "*  * ".length;
			var _g1307 = 0;
			var _g407 = l306;
			while(_g1307 < _g407) {
				var i307 = _g1307++;
				var no306 = "*  * ".charCodeAt(i307);
				if(no306 == null) {
					break;
				}
				var v306;
				switch(no306) {
				case 32:
					v306 = false;
					break;
				case 42:
					v306 = true;
					break;
				case 48:
					v306 = false;
					break;
				case 49:
					v306 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i307)));
				}
				switch(i307 - (l306 - 8)) {
				case 0:
					if(v306) {
						bs306 |= 128;
					} else {
						bs306 &= -129;
					}
					break;
				case 1:
					if(v306) {
						bs306 |= 64;
					} else {
						bs306 &= -65;
					}
					break;
				case 2:
					if(v306) {
						bs306 |= 32;
					} else {
						bs306 &= -33;
					}
					break;
				case 3:
					if(v306) {
						bs306 |= 16;
					} else {
						bs306 &= -17;
					}
					break;
				case 4:
					if(v306) {
						bs306 |= 8;
					} else {
						bs306 &= -9;
					}
					break;
				case 5:
					if(v306) {
						bs306 |= 4;
					} else {
						bs306 &= -5;
					}
					break;
				case 6:
					if(v306) {
						bs306 |= 2;
					} else {
						bs306 &= -3;
					}
					break;
				case 7:
					if(v306) {
						bs306 |= 1;
					} else {
						bs306 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs306;
			var this308 = 0;
			var bs307 = this308;
			var l307 = "*   *".length;
			var _g1308 = 0;
			var _g408 = l307;
			while(_g1308 < _g408) {
				var i308 = _g1308++;
				var no307 = "*   *".charCodeAt(i308);
				if(no307 == null) {
					break;
				}
				var v307;
				switch(no307) {
				case 32:
					v307 = false;
					break;
				case 42:
					v307 = true;
					break;
				case 48:
					v307 = false;
					break;
				case 49:
					v307 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i308)));
				}
				switch(i308 - (l307 - 8)) {
				case 0:
					if(v307) {
						bs307 |= 128;
					} else {
						bs307 &= -129;
					}
					break;
				case 1:
					if(v307) {
						bs307 |= 64;
					} else {
						bs307 &= -65;
					}
					break;
				case 2:
					if(v307) {
						bs307 |= 32;
					} else {
						bs307 &= -33;
					}
					break;
				case 3:
					if(v307) {
						bs307 |= 16;
					} else {
						bs307 &= -17;
					}
					break;
				case 4:
					if(v307) {
						bs307 |= 8;
					} else {
						bs307 &= -9;
					}
					break;
				case 5:
					if(v307) {
						bs307 |= 4;
					} else {
						bs307 &= -5;
					}
					break;
				case 6:
					if(v307) {
						bs307 |= 2;
					} else {
						bs307 &= -3;
					}
					break;
				case 7:
					if(v307) {
						bs307 |= 1;
					} else {
						bs307 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs307;
			break;
		case 76:
			var this309 = 0;
			var bs308 = this309;
			var l308 = "*    ".length;
			var _g1309 = 0;
			var _g409 = l308;
			while(_g1309 < _g409) {
				var i309 = _g1309++;
				var no308 = "*    ".charCodeAt(i309);
				if(no308 == null) {
					break;
				}
				var v308;
				switch(no308) {
				case 32:
					v308 = false;
					break;
				case 42:
					v308 = true;
					break;
				case 48:
					v308 = false;
					break;
				case 49:
					v308 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i309)));
				}
				switch(i309 - (l308 - 8)) {
				case 0:
					if(v308) {
						bs308 |= 128;
					} else {
						bs308 &= -129;
					}
					break;
				case 1:
					if(v308) {
						bs308 |= 64;
					} else {
						bs308 &= -65;
					}
					break;
				case 2:
					if(v308) {
						bs308 |= 32;
					} else {
						bs308 &= -33;
					}
					break;
				case 3:
					if(v308) {
						bs308 |= 16;
					} else {
						bs308 &= -17;
					}
					break;
				case 4:
					if(v308) {
						bs308 |= 8;
					} else {
						bs308 &= -9;
					}
					break;
				case 5:
					if(v308) {
						bs308 |= 4;
					} else {
						bs308 &= -5;
					}
					break;
				case 6:
					if(v308) {
						bs308 |= 2;
					} else {
						bs308 &= -3;
					}
					break;
				case 7:
					if(v308) {
						bs308 |= 1;
					} else {
						bs308 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs308;
			var this310 = 0;
			var bs309 = this310;
			var l309 = "*    ".length;
			var _g1310 = 0;
			var _g410 = l309;
			while(_g1310 < _g410) {
				var i310 = _g1310++;
				var no309 = "*    ".charCodeAt(i310);
				if(no309 == null) {
					break;
				}
				var v309;
				switch(no309) {
				case 32:
					v309 = false;
					break;
				case 42:
					v309 = true;
					break;
				case 48:
					v309 = false;
					break;
				case 49:
					v309 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i310)));
				}
				switch(i310 - (l309 - 8)) {
				case 0:
					if(v309) {
						bs309 |= 128;
					} else {
						bs309 &= -129;
					}
					break;
				case 1:
					if(v309) {
						bs309 |= 64;
					} else {
						bs309 &= -65;
					}
					break;
				case 2:
					if(v309) {
						bs309 |= 32;
					} else {
						bs309 &= -33;
					}
					break;
				case 3:
					if(v309) {
						bs309 |= 16;
					} else {
						bs309 &= -17;
					}
					break;
				case 4:
					if(v309) {
						bs309 |= 8;
					} else {
						bs309 &= -9;
					}
					break;
				case 5:
					if(v309) {
						bs309 |= 4;
					} else {
						bs309 &= -5;
					}
					break;
				case 6:
					if(v309) {
						bs309 |= 2;
					} else {
						bs309 &= -3;
					}
					break;
				case 7:
					if(v309) {
						bs309 |= 1;
					} else {
						bs309 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs309;
			var this311 = 0;
			var bs310 = this311;
			var l310 = "*    ".length;
			var _g1311 = 0;
			var _g411 = l310;
			while(_g1311 < _g411) {
				var i311 = _g1311++;
				var no310 = "*    ".charCodeAt(i311);
				if(no310 == null) {
					break;
				}
				var v310;
				switch(no310) {
				case 32:
					v310 = false;
					break;
				case 42:
					v310 = true;
					break;
				case 48:
					v310 = false;
					break;
				case 49:
					v310 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i311)));
				}
				switch(i311 - (l310 - 8)) {
				case 0:
					if(v310) {
						bs310 |= 128;
					} else {
						bs310 &= -129;
					}
					break;
				case 1:
					if(v310) {
						bs310 |= 64;
					} else {
						bs310 &= -65;
					}
					break;
				case 2:
					if(v310) {
						bs310 |= 32;
					} else {
						bs310 &= -33;
					}
					break;
				case 3:
					if(v310) {
						bs310 |= 16;
					} else {
						bs310 &= -17;
					}
					break;
				case 4:
					if(v310) {
						bs310 |= 8;
					} else {
						bs310 &= -9;
					}
					break;
				case 5:
					if(v310) {
						bs310 |= 4;
					} else {
						bs310 &= -5;
					}
					break;
				case 6:
					if(v310) {
						bs310 |= 2;
					} else {
						bs310 &= -3;
					}
					break;
				case 7:
					if(v310) {
						bs310 |= 1;
					} else {
						bs310 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs310;
			var this312 = 0;
			var bs311 = this312;
			var l311 = "*    ".length;
			var _g1312 = 0;
			var _g412 = l311;
			while(_g1312 < _g412) {
				var i312 = _g1312++;
				var no311 = "*    ".charCodeAt(i312);
				if(no311 == null) {
					break;
				}
				var v311;
				switch(no311) {
				case 32:
					v311 = false;
					break;
				case 42:
					v311 = true;
					break;
				case 48:
					v311 = false;
					break;
				case 49:
					v311 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i312)));
				}
				switch(i312 - (l311 - 8)) {
				case 0:
					if(v311) {
						bs311 |= 128;
					} else {
						bs311 &= -129;
					}
					break;
				case 1:
					if(v311) {
						bs311 |= 64;
					} else {
						bs311 &= -65;
					}
					break;
				case 2:
					if(v311) {
						bs311 |= 32;
					} else {
						bs311 &= -33;
					}
					break;
				case 3:
					if(v311) {
						bs311 |= 16;
					} else {
						bs311 &= -17;
					}
					break;
				case 4:
					if(v311) {
						bs311 |= 8;
					} else {
						bs311 &= -9;
					}
					break;
				case 5:
					if(v311) {
						bs311 |= 4;
					} else {
						bs311 &= -5;
					}
					break;
				case 6:
					if(v311) {
						bs311 |= 2;
					} else {
						bs311 &= -3;
					}
					break;
				case 7:
					if(v311) {
						bs311 |= 1;
					} else {
						bs311 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs311;
			var this313 = 0;
			var bs312 = this313;
			var l312 = "*    ".length;
			var _g1313 = 0;
			var _g413 = l312;
			while(_g1313 < _g413) {
				var i313 = _g1313++;
				var no312 = "*    ".charCodeAt(i313);
				if(no312 == null) {
					break;
				}
				var v312;
				switch(no312) {
				case 32:
					v312 = false;
					break;
				case 42:
					v312 = true;
					break;
				case 48:
					v312 = false;
					break;
				case 49:
					v312 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i313)));
				}
				switch(i313 - (l312 - 8)) {
				case 0:
					if(v312) {
						bs312 |= 128;
					} else {
						bs312 &= -129;
					}
					break;
				case 1:
					if(v312) {
						bs312 |= 64;
					} else {
						bs312 &= -65;
					}
					break;
				case 2:
					if(v312) {
						bs312 |= 32;
					} else {
						bs312 &= -33;
					}
					break;
				case 3:
					if(v312) {
						bs312 |= 16;
					} else {
						bs312 &= -17;
					}
					break;
				case 4:
					if(v312) {
						bs312 |= 8;
					} else {
						bs312 &= -9;
					}
					break;
				case 5:
					if(v312) {
						bs312 |= 4;
					} else {
						bs312 &= -5;
					}
					break;
				case 6:
					if(v312) {
						bs312 |= 2;
					} else {
						bs312 &= -3;
					}
					break;
				case 7:
					if(v312) {
						bs312 |= 1;
					} else {
						bs312 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs312;
			var this314 = 0;
			var bs313 = this314;
			var l313 = "*    ".length;
			var _g1314 = 0;
			var _g414 = l313;
			while(_g1314 < _g414) {
				var i314 = _g1314++;
				var no313 = "*    ".charCodeAt(i314);
				if(no313 == null) {
					break;
				}
				var v313;
				switch(no313) {
				case 32:
					v313 = false;
					break;
				case 42:
					v313 = true;
					break;
				case 48:
					v313 = false;
					break;
				case 49:
					v313 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i314)));
				}
				switch(i314 - (l313 - 8)) {
				case 0:
					if(v313) {
						bs313 |= 128;
					} else {
						bs313 &= -129;
					}
					break;
				case 1:
					if(v313) {
						bs313 |= 64;
					} else {
						bs313 &= -65;
					}
					break;
				case 2:
					if(v313) {
						bs313 |= 32;
					} else {
						bs313 &= -33;
					}
					break;
				case 3:
					if(v313) {
						bs313 |= 16;
					} else {
						bs313 &= -17;
					}
					break;
				case 4:
					if(v313) {
						bs313 |= 8;
					} else {
						bs313 &= -9;
					}
					break;
				case 5:
					if(v313) {
						bs313 |= 4;
					} else {
						bs313 &= -5;
					}
					break;
				case 6:
					if(v313) {
						bs313 |= 2;
					} else {
						bs313 &= -3;
					}
					break;
				case 7:
					if(v313) {
						bs313 |= 1;
					} else {
						bs313 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs313;
			var this315 = 0;
			var bs314 = this315;
			var l314 = "*****".length;
			var _g1315 = 0;
			var _g415 = l314;
			while(_g1315 < _g415) {
				var i315 = _g1315++;
				var no314 = "*****".charCodeAt(i315);
				if(no314 == null) {
					break;
				}
				var v314;
				switch(no314) {
				case 32:
					v314 = false;
					break;
				case 42:
					v314 = true;
					break;
				case 48:
					v314 = false;
					break;
				case 49:
					v314 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i315)));
				}
				switch(i315 - (l314 - 8)) {
				case 0:
					if(v314) {
						bs314 |= 128;
					} else {
						bs314 &= -129;
					}
					break;
				case 1:
					if(v314) {
						bs314 |= 64;
					} else {
						bs314 &= -65;
					}
					break;
				case 2:
					if(v314) {
						bs314 |= 32;
					} else {
						bs314 &= -33;
					}
					break;
				case 3:
					if(v314) {
						bs314 |= 16;
					} else {
						bs314 &= -17;
					}
					break;
				case 4:
					if(v314) {
						bs314 |= 8;
					} else {
						bs314 &= -9;
					}
					break;
				case 5:
					if(v314) {
						bs314 |= 4;
					} else {
						bs314 &= -5;
					}
					break;
				case 6:
					if(v314) {
						bs314 |= 2;
					} else {
						bs314 &= -3;
					}
					break;
				case 7:
					if(v314) {
						bs314 |= 1;
					} else {
						bs314 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs314;
			break;
		case 77:
			var this316 = 0;
			var bs315 = this316;
			var l315 = "*   *".length;
			var _g1316 = 0;
			var _g416 = l315;
			while(_g1316 < _g416) {
				var i316 = _g1316++;
				var no315 = "*   *".charCodeAt(i316);
				if(no315 == null) {
					break;
				}
				var v315;
				switch(no315) {
				case 32:
					v315 = false;
					break;
				case 42:
					v315 = true;
					break;
				case 48:
					v315 = false;
					break;
				case 49:
					v315 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i316)));
				}
				switch(i316 - (l315 - 8)) {
				case 0:
					if(v315) {
						bs315 |= 128;
					} else {
						bs315 &= -129;
					}
					break;
				case 1:
					if(v315) {
						bs315 |= 64;
					} else {
						bs315 &= -65;
					}
					break;
				case 2:
					if(v315) {
						bs315 |= 32;
					} else {
						bs315 &= -33;
					}
					break;
				case 3:
					if(v315) {
						bs315 |= 16;
					} else {
						bs315 &= -17;
					}
					break;
				case 4:
					if(v315) {
						bs315 |= 8;
					} else {
						bs315 &= -9;
					}
					break;
				case 5:
					if(v315) {
						bs315 |= 4;
					} else {
						bs315 &= -5;
					}
					break;
				case 6:
					if(v315) {
						bs315 |= 2;
					} else {
						bs315 &= -3;
					}
					break;
				case 7:
					if(v315) {
						bs315 |= 1;
					} else {
						bs315 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs315;
			var this317 = 0;
			var bs316 = this317;
			var l316 = "** **".length;
			var _g1317 = 0;
			var _g417 = l316;
			while(_g1317 < _g417) {
				var i317 = _g1317++;
				var no316 = "** **".charCodeAt(i317);
				if(no316 == null) {
					break;
				}
				var v316;
				switch(no316) {
				case 32:
					v316 = false;
					break;
				case 42:
					v316 = true;
					break;
				case 48:
					v316 = false;
					break;
				case 49:
					v316 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("** **".charCodeAt(i317)));
				}
				switch(i317 - (l316 - 8)) {
				case 0:
					if(v316) {
						bs316 |= 128;
					} else {
						bs316 &= -129;
					}
					break;
				case 1:
					if(v316) {
						bs316 |= 64;
					} else {
						bs316 &= -65;
					}
					break;
				case 2:
					if(v316) {
						bs316 |= 32;
					} else {
						bs316 &= -33;
					}
					break;
				case 3:
					if(v316) {
						bs316 |= 16;
					} else {
						bs316 &= -17;
					}
					break;
				case 4:
					if(v316) {
						bs316 |= 8;
					} else {
						bs316 &= -9;
					}
					break;
				case 5:
					if(v316) {
						bs316 |= 4;
					} else {
						bs316 &= -5;
					}
					break;
				case 6:
					if(v316) {
						bs316 |= 2;
					} else {
						bs316 &= -3;
					}
					break;
				case 7:
					if(v316) {
						bs316 |= 1;
					} else {
						bs316 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs316;
			var this318 = 0;
			var bs317 = this318;
			var l317 = "* * *".length;
			var _g1318 = 0;
			var _g418 = l317;
			while(_g1318 < _g418) {
				var i318 = _g1318++;
				var no317 = "* * *".charCodeAt(i318);
				if(no317 == null) {
					break;
				}
				var v317;
				switch(no317) {
				case 32:
					v317 = false;
					break;
				case 42:
					v317 = true;
					break;
				case 48:
					v317 = false;
					break;
				case 49:
					v317 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i318)));
				}
				switch(i318 - (l317 - 8)) {
				case 0:
					if(v317) {
						bs317 |= 128;
					} else {
						bs317 &= -129;
					}
					break;
				case 1:
					if(v317) {
						bs317 |= 64;
					} else {
						bs317 &= -65;
					}
					break;
				case 2:
					if(v317) {
						bs317 |= 32;
					} else {
						bs317 &= -33;
					}
					break;
				case 3:
					if(v317) {
						bs317 |= 16;
					} else {
						bs317 &= -17;
					}
					break;
				case 4:
					if(v317) {
						bs317 |= 8;
					} else {
						bs317 &= -9;
					}
					break;
				case 5:
					if(v317) {
						bs317 |= 4;
					} else {
						bs317 &= -5;
					}
					break;
				case 6:
					if(v317) {
						bs317 |= 2;
					} else {
						bs317 &= -3;
					}
					break;
				case 7:
					if(v317) {
						bs317 |= 1;
					} else {
						bs317 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs317;
			var this319 = 0;
			var bs318 = this319;
			var l318 = "* * *".length;
			var _g1319 = 0;
			var _g419 = l318;
			while(_g1319 < _g419) {
				var i319 = _g1319++;
				var no318 = "* * *".charCodeAt(i319);
				if(no318 == null) {
					break;
				}
				var v318;
				switch(no318) {
				case 32:
					v318 = false;
					break;
				case 42:
					v318 = true;
					break;
				case 48:
					v318 = false;
					break;
				case 49:
					v318 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i319)));
				}
				switch(i319 - (l318 - 8)) {
				case 0:
					if(v318) {
						bs318 |= 128;
					} else {
						bs318 &= -129;
					}
					break;
				case 1:
					if(v318) {
						bs318 |= 64;
					} else {
						bs318 &= -65;
					}
					break;
				case 2:
					if(v318) {
						bs318 |= 32;
					} else {
						bs318 &= -33;
					}
					break;
				case 3:
					if(v318) {
						bs318 |= 16;
					} else {
						bs318 &= -17;
					}
					break;
				case 4:
					if(v318) {
						bs318 |= 8;
					} else {
						bs318 &= -9;
					}
					break;
				case 5:
					if(v318) {
						bs318 |= 4;
					} else {
						bs318 &= -5;
					}
					break;
				case 6:
					if(v318) {
						bs318 |= 2;
					} else {
						bs318 &= -3;
					}
					break;
				case 7:
					if(v318) {
						bs318 |= 1;
					} else {
						bs318 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs318;
			var this320 = 0;
			var bs319 = this320;
			var l319 = "*   *".length;
			var _g1320 = 0;
			var _g420 = l319;
			while(_g1320 < _g420) {
				var i320 = _g1320++;
				var no319 = "*   *".charCodeAt(i320);
				if(no319 == null) {
					break;
				}
				var v319;
				switch(no319) {
				case 32:
					v319 = false;
					break;
				case 42:
					v319 = true;
					break;
				case 48:
					v319 = false;
					break;
				case 49:
					v319 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i320)));
				}
				switch(i320 - (l319 - 8)) {
				case 0:
					if(v319) {
						bs319 |= 128;
					} else {
						bs319 &= -129;
					}
					break;
				case 1:
					if(v319) {
						bs319 |= 64;
					} else {
						bs319 &= -65;
					}
					break;
				case 2:
					if(v319) {
						bs319 |= 32;
					} else {
						bs319 &= -33;
					}
					break;
				case 3:
					if(v319) {
						bs319 |= 16;
					} else {
						bs319 &= -17;
					}
					break;
				case 4:
					if(v319) {
						bs319 |= 8;
					} else {
						bs319 &= -9;
					}
					break;
				case 5:
					if(v319) {
						bs319 |= 4;
					} else {
						bs319 &= -5;
					}
					break;
				case 6:
					if(v319) {
						bs319 |= 2;
					} else {
						bs319 &= -3;
					}
					break;
				case 7:
					if(v319) {
						bs319 |= 1;
					} else {
						bs319 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs319;
			var this321 = 0;
			var bs320 = this321;
			var l320 = "*   *".length;
			var _g1321 = 0;
			var _g421 = l320;
			while(_g1321 < _g421) {
				var i321 = _g1321++;
				var no320 = "*   *".charCodeAt(i321);
				if(no320 == null) {
					break;
				}
				var v320;
				switch(no320) {
				case 32:
					v320 = false;
					break;
				case 42:
					v320 = true;
					break;
				case 48:
					v320 = false;
					break;
				case 49:
					v320 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i321)));
				}
				switch(i321 - (l320 - 8)) {
				case 0:
					if(v320) {
						bs320 |= 128;
					} else {
						bs320 &= -129;
					}
					break;
				case 1:
					if(v320) {
						bs320 |= 64;
					} else {
						bs320 &= -65;
					}
					break;
				case 2:
					if(v320) {
						bs320 |= 32;
					} else {
						bs320 &= -33;
					}
					break;
				case 3:
					if(v320) {
						bs320 |= 16;
					} else {
						bs320 &= -17;
					}
					break;
				case 4:
					if(v320) {
						bs320 |= 8;
					} else {
						bs320 &= -9;
					}
					break;
				case 5:
					if(v320) {
						bs320 |= 4;
					} else {
						bs320 &= -5;
					}
					break;
				case 6:
					if(v320) {
						bs320 |= 2;
					} else {
						bs320 &= -3;
					}
					break;
				case 7:
					if(v320) {
						bs320 |= 1;
					} else {
						bs320 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs320;
			var this322 = 0;
			var bs321 = this322;
			var l321 = "*   *".length;
			var _g1322 = 0;
			var _g422 = l321;
			while(_g1322 < _g422) {
				var i322 = _g1322++;
				var no321 = "*   *".charCodeAt(i322);
				if(no321 == null) {
					break;
				}
				var v321;
				switch(no321) {
				case 32:
					v321 = false;
					break;
				case 42:
					v321 = true;
					break;
				case 48:
					v321 = false;
					break;
				case 49:
					v321 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i322)));
				}
				switch(i322 - (l321 - 8)) {
				case 0:
					if(v321) {
						bs321 |= 128;
					} else {
						bs321 &= -129;
					}
					break;
				case 1:
					if(v321) {
						bs321 |= 64;
					} else {
						bs321 &= -65;
					}
					break;
				case 2:
					if(v321) {
						bs321 |= 32;
					} else {
						bs321 &= -33;
					}
					break;
				case 3:
					if(v321) {
						bs321 |= 16;
					} else {
						bs321 &= -17;
					}
					break;
				case 4:
					if(v321) {
						bs321 |= 8;
					} else {
						bs321 &= -9;
					}
					break;
				case 5:
					if(v321) {
						bs321 |= 4;
					} else {
						bs321 &= -5;
					}
					break;
				case 6:
					if(v321) {
						bs321 |= 2;
					} else {
						bs321 &= -3;
					}
					break;
				case 7:
					if(v321) {
						bs321 |= 1;
					} else {
						bs321 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs321;
			break;
		case 78:
			var this323 = 0;
			var bs322 = this323;
			var l322 = "*   *".length;
			var _g1323 = 0;
			var _g423 = l322;
			while(_g1323 < _g423) {
				var i323 = _g1323++;
				var no322 = "*   *".charCodeAt(i323);
				if(no322 == null) {
					break;
				}
				var v322;
				switch(no322) {
				case 32:
					v322 = false;
					break;
				case 42:
					v322 = true;
					break;
				case 48:
					v322 = false;
					break;
				case 49:
					v322 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i323)));
				}
				switch(i323 - (l322 - 8)) {
				case 0:
					if(v322) {
						bs322 |= 128;
					} else {
						bs322 &= -129;
					}
					break;
				case 1:
					if(v322) {
						bs322 |= 64;
					} else {
						bs322 &= -65;
					}
					break;
				case 2:
					if(v322) {
						bs322 |= 32;
					} else {
						bs322 &= -33;
					}
					break;
				case 3:
					if(v322) {
						bs322 |= 16;
					} else {
						bs322 &= -17;
					}
					break;
				case 4:
					if(v322) {
						bs322 |= 8;
					} else {
						bs322 &= -9;
					}
					break;
				case 5:
					if(v322) {
						bs322 |= 4;
					} else {
						bs322 &= -5;
					}
					break;
				case 6:
					if(v322) {
						bs322 |= 2;
					} else {
						bs322 &= -3;
					}
					break;
				case 7:
					if(v322) {
						bs322 |= 1;
					} else {
						bs322 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs322;
			var this324 = 0;
			var bs323 = this324;
			var l323 = "*   *".length;
			var _g1324 = 0;
			var _g424 = l323;
			while(_g1324 < _g424) {
				var i324 = _g1324++;
				var no323 = "*   *".charCodeAt(i324);
				if(no323 == null) {
					break;
				}
				var v323;
				switch(no323) {
				case 32:
					v323 = false;
					break;
				case 42:
					v323 = true;
					break;
				case 48:
					v323 = false;
					break;
				case 49:
					v323 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i324)));
				}
				switch(i324 - (l323 - 8)) {
				case 0:
					if(v323) {
						bs323 |= 128;
					} else {
						bs323 &= -129;
					}
					break;
				case 1:
					if(v323) {
						bs323 |= 64;
					} else {
						bs323 &= -65;
					}
					break;
				case 2:
					if(v323) {
						bs323 |= 32;
					} else {
						bs323 &= -33;
					}
					break;
				case 3:
					if(v323) {
						bs323 |= 16;
					} else {
						bs323 &= -17;
					}
					break;
				case 4:
					if(v323) {
						bs323 |= 8;
					} else {
						bs323 &= -9;
					}
					break;
				case 5:
					if(v323) {
						bs323 |= 4;
					} else {
						bs323 &= -5;
					}
					break;
				case 6:
					if(v323) {
						bs323 |= 2;
					} else {
						bs323 &= -3;
					}
					break;
				case 7:
					if(v323) {
						bs323 |= 1;
					} else {
						bs323 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs323;
			var this325 = 0;
			var bs324 = this325;
			var l324 = "**  *".length;
			var _g1325 = 0;
			var _g425 = l324;
			while(_g1325 < _g425) {
				var i325 = _g1325++;
				var no324 = "**  *".charCodeAt(i325);
				if(no324 == null) {
					break;
				}
				var v324;
				switch(no324) {
				case 32:
					v324 = false;
					break;
				case 42:
					v324 = true;
					break;
				case 48:
					v324 = false;
					break;
				case 49:
					v324 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i325)));
				}
				switch(i325 - (l324 - 8)) {
				case 0:
					if(v324) {
						bs324 |= 128;
					} else {
						bs324 &= -129;
					}
					break;
				case 1:
					if(v324) {
						bs324 |= 64;
					} else {
						bs324 &= -65;
					}
					break;
				case 2:
					if(v324) {
						bs324 |= 32;
					} else {
						bs324 &= -33;
					}
					break;
				case 3:
					if(v324) {
						bs324 |= 16;
					} else {
						bs324 &= -17;
					}
					break;
				case 4:
					if(v324) {
						bs324 |= 8;
					} else {
						bs324 &= -9;
					}
					break;
				case 5:
					if(v324) {
						bs324 |= 4;
					} else {
						bs324 &= -5;
					}
					break;
				case 6:
					if(v324) {
						bs324 |= 2;
					} else {
						bs324 &= -3;
					}
					break;
				case 7:
					if(v324) {
						bs324 |= 1;
					} else {
						bs324 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs324;
			var this326 = 0;
			var bs325 = this326;
			var l325 = "* * *".length;
			var _g1326 = 0;
			var _g426 = l325;
			while(_g1326 < _g426) {
				var i326 = _g1326++;
				var no325 = "* * *".charCodeAt(i326);
				if(no325 == null) {
					break;
				}
				var v325;
				switch(no325) {
				case 32:
					v325 = false;
					break;
				case 42:
					v325 = true;
					break;
				case 48:
					v325 = false;
					break;
				case 49:
					v325 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i326)));
				}
				switch(i326 - (l325 - 8)) {
				case 0:
					if(v325) {
						bs325 |= 128;
					} else {
						bs325 &= -129;
					}
					break;
				case 1:
					if(v325) {
						bs325 |= 64;
					} else {
						bs325 &= -65;
					}
					break;
				case 2:
					if(v325) {
						bs325 |= 32;
					} else {
						bs325 &= -33;
					}
					break;
				case 3:
					if(v325) {
						bs325 |= 16;
					} else {
						bs325 &= -17;
					}
					break;
				case 4:
					if(v325) {
						bs325 |= 8;
					} else {
						bs325 &= -9;
					}
					break;
				case 5:
					if(v325) {
						bs325 |= 4;
					} else {
						bs325 &= -5;
					}
					break;
				case 6:
					if(v325) {
						bs325 |= 2;
					} else {
						bs325 &= -3;
					}
					break;
				case 7:
					if(v325) {
						bs325 |= 1;
					} else {
						bs325 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs325;
			var this327 = 0;
			var bs326 = this327;
			var l326 = "*  **".length;
			var _g1327 = 0;
			var _g427 = l326;
			while(_g1327 < _g427) {
				var i327 = _g1327++;
				var no326 = "*  **".charCodeAt(i327);
				if(no326 == null) {
					break;
				}
				var v326;
				switch(no326) {
				case 32:
					v326 = false;
					break;
				case 42:
					v326 = true;
					break;
				case 48:
					v326 = false;
					break;
				case 49:
					v326 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  **".charCodeAt(i327)));
				}
				switch(i327 - (l326 - 8)) {
				case 0:
					if(v326) {
						bs326 |= 128;
					} else {
						bs326 &= -129;
					}
					break;
				case 1:
					if(v326) {
						bs326 |= 64;
					} else {
						bs326 &= -65;
					}
					break;
				case 2:
					if(v326) {
						bs326 |= 32;
					} else {
						bs326 &= -33;
					}
					break;
				case 3:
					if(v326) {
						bs326 |= 16;
					} else {
						bs326 &= -17;
					}
					break;
				case 4:
					if(v326) {
						bs326 |= 8;
					} else {
						bs326 &= -9;
					}
					break;
				case 5:
					if(v326) {
						bs326 |= 4;
					} else {
						bs326 &= -5;
					}
					break;
				case 6:
					if(v326) {
						bs326 |= 2;
					} else {
						bs326 &= -3;
					}
					break;
				case 7:
					if(v326) {
						bs326 |= 1;
					} else {
						bs326 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs326;
			var this328 = 0;
			var bs327 = this328;
			var l327 = "*   *".length;
			var _g1328 = 0;
			var _g428 = l327;
			while(_g1328 < _g428) {
				var i328 = _g1328++;
				var no327 = "*   *".charCodeAt(i328);
				if(no327 == null) {
					break;
				}
				var v327;
				switch(no327) {
				case 32:
					v327 = false;
					break;
				case 42:
					v327 = true;
					break;
				case 48:
					v327 = false;
					break;
				case 49:
					v327 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i328)));
				}
				switch(i328 - (l327 - 8)) {
				case 0:
					if(v327) {
						bs327 |= 128;
					} else {
						bs327 &= -129;
					}
					break;
				case 1:
					if(v327) {
						bs327 |= 64;
					} else {
						bs327 &= -65;
					}
					break;
				case 2:
					if(v327) {
						bs327 |= 32;
					} else {
						bs327 &= -33;
					}
					break;
				case 3:
					if(v327) {
						bs327 |= 16;
					} else {
						bs327 &= -17;
					}
					break;
				case 4:
					if(v327) {
						bs327 |= 8;
					} else {
						bs327 &= -9;
					}
					break;
				case 5:
					if(v327) {
						bs327 |= 4;
					} else {
						bs327 &= -5;
					}
					break;
				case 6:
					if(v327) {
						bs327 |= 2;
					} else {
						bs327 &= -3;
					}
					break;
				case 7:
					if(v327) {
						bs327 |= 1;
					} else {
						bs327 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs327;
			var this329 = 0;
			var bs328 = this329;
			var l328 = "*   *".length;
			var _g1329 = 0;
			var _g429 = l328;
			while(_g1329 < _g429) {
				var i329 = _g1329++;
				var no328 = "*   *".charCodeAt(i329);
				if(no328 == null) {
					break;
				}
				var v328;
				switch(no328) {
				case 32:
					v328 = false;
					break;
				case 42:
					v328 = true;
					break;
				case 48:
					v328 = false;
					break;
				case 49:
					v328 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i329)));
				}
				switch(i329 - (l328 - 8)) {
				case 0:
					if(v328) {
						bs328 |= 128;
					} else {
						bs328 &= -129;
					}
					break;
				case 1:
					if(v328) {
						bs328 |= 64;
					} else {
						bs328 &= -65;
					}
					break;
				case 2:
					if(v328) {
						bs328 |= 32;
					} else {
						bs328 &= -33;
					}
					break;
				case 3:
					if(v328) {
						bs328 |= 16;
					} else {
						bs328 &= -17;
					}
					break;
				case 4:
					if(v328) {
						bs328 |= 8;
					} else {
						bs328 &= -9;
					}
					break;
				case 5:
					if(v328) {
						bs328 |= 4;
					} else {
						bs328 &= -5;
					}
					break;
				case 6:
					if(v328) {
						bs328 |= 2;
					} else {
						bs328 &= -3;
					}
					break;
				case 7:
					if(v328) {
						bs328 |= 1;
					} else {
						bs328 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs328;
			break;
		case 79:
			var this330 = 0;
			var bs329 = this330;
			var l329 = " *** ".length;
			var _g1330 = 0;
			var _g430 = l329;
			while(_g1330 < _g430) {
				var i330 = _g1330++;
				var no329 = " *** ".charCodeAt(i330);
				if(no329 == null) {
					break;
				}
				var v329;
				switch(no329) {
				case 32:
					v329 = false;
					break;
				case 42:
					v329 = true;
					break;
				case 48:
					v329 = false;
					break;
				case 49:
					v329 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i330)));
				}
				switch(i330 - (l329 - 8)) {
				case 0:
					if(v329) {
						bs329 |= 128;
					} else {
						bs329 &= -129;
					}
					break;
				case 1:
					if(v329) {
						bs329 |= 64;
					} else {
						bs329 &= -65;
					}
					break;
				case 2:
					if(v329) {
						bs329 |= 32;
					} else {
						bs329 &= -33;
					}
					break;
				case 3:
					if(v329) {
						bs329 |= 16;
					} else {
						bs329 &= -17;
					}
					break;
				case 4:
					if(v329) {
						bs329 |= 8;
					} else {
						bs329 &= -9;
					}
					break;
				case 5:
					if(v329) {
						bs329 |= 4;
					} else {
						bs329 &= -5;
					}
					break;
				case 6:
					if(v329) {
						bs329 |= 2;
					} else {
						bs329 &= -3;
					}
					break;
				case 7:
					if(v329) {
						bs329 |= 1;
					} else {
						bs329 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs329;
			var this331 = 0;
			var bs330 = this331;
			var l330 = "*   *".length;
			var _g1331 = 0;
			var _g431 = l330;
			while(_g1331 < _g431) {
				var i331 = _g1331++;
				var no330 = "*   *".charCodeAt(i331);
				if(no330 == null) {
					break;
				}
				var v330;
				switch(no330) {
				case 32:
					v330 = false;
					break;
				case 42:
					v330 = true;
					break;
				case 48:
					v330 = false;
					break;
				case 49:
					v330 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i331)));
				}
				switch(i331 - (l330 - 8)) {
				case 0:
					if(v330) {
						bs330 |= 128;
					} else {
						bs330 &= -129;
					}
					break;
				case 1:
					if(v330) {
						bs330 |= 64;
					} else {
						bs330 &= -65;
					}
					break;
				case 2:
					if(v330) {
						bs330 |= 32;
					} else {
						bs330 &= -33;
					}
					break;
				case 3:
					if(v330) {
						bs330 |= 16;
					} else {
						bs330 &= -17;
					}
					break;
				case 4:
					if(v330) {
						bs330 |= 8;
					} else {
						bs330 &= -9;
					}
					break;
				case 5:
					if(v330) {
						bs330 |= 4;
					} else {
						bs330 &= -5;
					}
					break;
				case 6:
					if(v330) {
						bs330 |= 2;
					} else {
						bs330 &= -3;
					}
					break;
				case 7:
					if(v330) {
						bs330 |= 1;
					} else {
						bs330 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs330;
			var this332 = 0;
			var bs331 = this332;
			var l331 = "*   *".length;
			var _g1332 = 0;
			var _g432 = l331;
			while(_g1332 < _g432) {
				var i332 = _g1332++;
				var no331 = "*   *".charCodeAt(i332);
				if(no331 == null) {
					break;
				}
				var v331;
				switch(no331) {
				case 32:
					v331 = false;
					break;
				case 42:
					v331 = true;
					break;
				case 48:
					v331 = false;
					break;
				case 49:
					v331 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i332)));
				}
				switch(i332 - (l331 - 8)) {
				case 0:
					if(v331) {
						bs331 |= 128;
					} else {
						bs331 &= -129;
					}
					break;
				case 1:
					if(v331) {
						bs331 |= 64;
					} else {
						bs331 &= -65;
					}
					break;
				case 2:
					if(v331) {
						bs331 |= 32;
					} else {
						bs331 &= -33;
					}
					break;
				case 3:
					if(v331) {
						bs331 |= 16;
					} else {
						bs331 &= -17;
					}
					break;
				case 4:
					if(v331) {
						bs331 |= 8;
					} else {
						bs331 &= -9;
					}
					break;
				case 5:
					if(v331) {
						bs331 |= 4;
					} else {
						bs331 &= -5;
					}
					break;
				case 6:
					if(v331) {
						bs331 |= 2;
					} else {
						bs331 &= -3;
					}
					break;
				case 7:
					if(v331) {
						bs331 |= 1;
					} else {
						bs331 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs331;
			var this333 = 0;
			var bs332 = this333;
			var l332 = "*   *".length;
			var _g1333 = 0;
			var _g433 = l332;
			while(_g1333 < _g433) {
				var i333 = _g1333++;
				var no332 = "*   *".charCodeAt(i333);
				if(no332 == null) {
					break;
				}
				var v332;
				switch(no332) {
				case 32:
					v332 = false;
					break;
				case 42:
					v332 = true;
					break;
				case 48:
					v332 = false;
					break;
				case 49:
					v332 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i333)));
				}
				switch(i333 - (l332 - 8)) {
				case 0:
					if(v332) {
						bs332 |= 128;
					} else {
						bs332 &= -129;
					}
					break;
				case 1:
					if(v332) {
						bs332 |= 64;
					} else {
						bs332 &= -65;
					}
					break;
				case 2:
					if(v332) {
						bs332 |= 32;
					} else {
						bs332 &= -33;
					}
					break;
				case 3:
					if(v332) {
						bs332 |= 16;
					} else {
						bs332 &= -17;
					}
					break;
				case 4:
					if(v332) {
						bs332 |= 8;
					} else {
						bs332 &= -9;
					}
					break;
				case 5:
					if(v332) {
						bs332 |= 4;
					} else {
						bs332 &= -5;
					}
					break;
				case 6:
					if(v332) {
						bs332 |= 2;
					} else {
						bs332 &= -3;
					}
					break;
				case 7:
					if(v332) {
						bs332 |= 1;
					} else {
						bs332 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs332;
			var this334 = 0;
			var bs333 = this334;
			var l333 = "*   *".length;
			var _g1334 = 0;
			var _g434 = l333;
			while(_g1334 < _g434) {
				var i334 = _g1334++;
				var no333 = "*   *".charCodeAt(i334);
				if(no333 == null) {
					break;
				}
				var v333;
				switch(no333) {
				case 32:
					v333 = false;
					break;
				case 42:
					v333 = true;
					break;
				case 48:
					v333 = false;
					break;
				case 49:
					v333 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i334)));
				}
				switch(i334 - (l333 - 8)) {
				case 0:
					if(v333) {
						bs333 |= 128;
					} else {
						bs333 &= -129;
					}
					break;
				case 1:
					if(v333) {
						bs333 |= 64;
					} else {
						bs333 &= -65;
					}
					break;
				case 2:
					if(v333) {
						bs333 |= 32;
					} else {
						bs333 &= -33;
					}
					break;
				case 3:
					if(v333) {
						bs333 |= 16;
					} else {
						bs333 &= -17;
					}
					break;
				case 4:
					if(v333) {
						bs333 |= 8;
					} else {
						bs333 &= -9;
					}
					break;
				case 5:
					if(v333) {
						bs333 |= 4;
					} else {
						bs333 &= -5;
					}
					break;
				case 6:
					if(v333) {
						bs333 |= 2;
					} else {
						bs333 &= -3;
					}
					break;
				case 7:
					if(v333) {
						bs333 |= 1;
					} else {
						bs333 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs333;
			var this335 = 0;
			var bs334 = this335;
			var l334 = "*   *".length;
			var _g1335 = 0;
			var _g435 = l334;
			while(_g1335 < _g435) {
				var i335 = _g1335++;
				var no334 = "*   *".charCodeAt(i335);
				if(no334 == null) {
					break;
				}
				var v334;
				switch(no334) {
				case 32:
					v334 = false;
					break;
				case 42:
					v334 = true;
					break;
				case 48:
					v334 = false;
					break;
				case 49:
					v334 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i335)));
				}
				switch(i335 - (l334 - 8)) {
				case 0:
					if(v334) {
						bs334 |= 128;
					} else {
						bs334 &= -129;
					}
					break;
				case 1:
					if(v334) {
						bs334 |= 64;
					} else {
						bs334 &= -65;
					}
					break;
				case 2:
					if(v334) {
						bs334 |= 32;
					} else {
						bs334 &= -33;
					}
					break;
				case 3:
					if(v334) {
						bs334 |= 16;
					} else {
						bs334 &= -17;
					}
					break;
				case 4:
					if(v334) {
						bs334 |= 8;
					} else {
						bs334 &= -9;
					}
					break;
				case 5:
					if(v334) {
						bs334 |= 4;
					} else {
						bs334 &= -5;
					}
					break;
				case 6:
					if(v334) {
						bs334 |= 2;
					} else {
						bs334 &= -3;
					}
					break;
				case 7:
					if(v334) {
						bs334 |= 1;
					} else {
						bs334 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs334;
			var this336 = 0;
			var bs335 = this336;
			var l335 = " *** ".length;
			var _g1336 = 0;
			var _g436 = l335;
			while(_g1336 < _g436) {
				var i336 = _g1336++;
				var no335 = " *** ".charCodeAt(i336);
				if(no335 == null) {
					break;
				}
				var v335;
				switch(no335) {
				case 32:
					v335 = false;
					break;
				case 42:
					v335 = true;
					break;
				case 48:
					v335 = false;
					break;
				case 49:
					v335 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i336)));
				}
				switch(i336 - (l335 - 8)) {
				case 0:
					if(v335) {
						bs335 |= 128;
					} else {
						bs335 &= -129;
					}
					break;
				case 1:
					if(v335) {
						bs335 |= 64;
					} else {
						bs335 &= -65;
					}
					break;
				case 2:
					if(v335) {
						bs335 |= 32;
					} else {
						bs335 &= -33;
					}
					break;
				case 3:
					if(v335) {
						bs335 |= 16;
					} else {
						bs335 &= -17;
					}
					break;
				case 4:
					if(v335) {
						bs335 |= 8;
					} else {
						bs335 &= -9;
					}
					break;
				case 5:
					if(v335) {
						bs335 |= 4;
					} else {
						bs335 &= -5;
					}
					break;
				case 6:
					if(v335) {
						bs335 |= 2;
					} else {
						bs335 &= -3;
					}
					break;
				case 7:
					if(v335) {
						bs335 |= 1;
					} else {
						bs335 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs335;
			break;
		case 80:
			var this337 = 0;
			var bs336 = this337;
			var l336 = "**** ".length;
			var _g1337 = 0;
			var _g437 = l336;
			while(_g1337 < _g437) {
				var i337 = _g1337++;
				var no336 = "**** ".charCodeAt(i337);
				if(no336 == null) {
					break;
				}
				var v336;
				switch(no336) {
				case 32:
					v336 = false;
					break;
				case 42:
					v336 = true;
					break;
				case 48:
					v336 = false;
					break;
				case 49:
					v336 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i337)));
				}
				switch(i337 - (l336 - 8)) {
				case 0:
					if(v336) {
						bs336 |= 128;
					} else {
						bs336 &= -129;
					}
					break;
				case 1:
					if(v336) {
						bs336 |= 64;
					} else {
						bs336 &= -65;
					}
					break;
				case 2:
					if(v336) {
						bs336 |= 32;
					} else {
						bs336 &= -33;
					}
					break;
				case 3:
					if(v336) {
						bs336 |= 16;
					} else {
						bs336 &= -17;
					}
					break;
				case 4:
					if(v336) {
						bs336 |= 8;
					} else {
						bs336 &= -9;
					}
					break;
				case 5:
					if(v336) {
						bs336 |= 4;
					} else {
						bs336 &= -5;
					}
					break;
				case 6:
					if(v336) {
						bs336 |= 2;
					} else {
						bs336 &= -3;
					}
					break;
				case 7:
					if(v336) {
						bs336 |= 1;
					} else {
						bs336 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs336;
			var this338 = 0;
			var bs337 = this338;
			var l337 = "*   *".length;
			var _g1338 = 0;
			var _g438 = l337;
			while(_g1338 < _g438) {
				var i338 = _g1338++;
				var no337 = "*   *".charCodeAt(i338);
				if(no337 == null) {
					break;
				}
				var v337;
				switch(no337) {
				case 32:
					v337 = false;
					break;
				case 42:
					v337 = true;
					break;
				case 48:
					v337 = false;
					break;
				case 49:
					v337 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i338)));
				}
				switch(i338 - (l337 - 8)) {
				case 0:
					if(v337) {
						bs337 |= 128;
					} else {
						bs337 &= -129;
					}
					break;
				case 1:
					if(v337) {
						bs337 |= 64;
					} else {
						bs337 &= -65;
					}
					break;
				case 2:
					if(v337) {
						bs337 |= 32;
					} else {
						bs337 &= -33;
					}
					break;
				case 3:
					if(v337) {
						bs337 |= 16;
					} else {
						bs337 &= -17;
					}
					break;
				case 4:
					if(v337) {
						bs337 |= 8;
					} else {
						bs337 &= -9;
					}
					break;
				case 5:
					if(v337) {
						bs337 |= 4;
					} else {
						bs337 &= -5;
					}
					break;
				case 6:
					if(v337) {
						bs337 |= 2;
					} else {
						bs337 &= -3;
					}
					break;
				case 7:
					if(v337) {
						bs337 |= 1;
					} else {
						bs337 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs337;
			var this339 = 0;
			var bs338 = this339;
			var l338 = "*   *".length;
			var _g1339 = 0;
			var _g439 = l338;
			while(_g1339 < _g439) {
				var i339 = _g1339++;
				var no338 = "*   *".charCodeAt(i339);
				if(no338 == null) {
					break;
				}
				var v338;
				switch(no338) {
				case 32:
					v338 = false;
					break;
				case 42:
					v338 = true;
					break;
				case 48:
					v338 = false;
					break;
				case 49:
					v338 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i339)));
				}
				switch(i339 - (l338 - 8)) {
				case 0:
					if(v338) {
						bs338 |= 128;
					} else {
						bs338 &= -129;
					}
					break;
				case 1:
					if(v338) {
						bs338 |= 64;
					} else {
						bs338 &= -65;
					}
					break;
				case 2:
					if(v338) {
						bs338 |= 32;
					} else {
						bs338 &= -33;
					}
					break;
				case 3:
					if(v338) {
						bs338 |= 16;
					} else {
						bs338 &= -17;
					}
					break;
				case 4:
					if(v338) {
						bs338 |= 8;
					} else {
						bs338 &= -9;
					}
					break;
				case 5:
					if(v338) {
						bs338 |= 4;
					} else {
						bs338 &= -5;
					}
					break;
				case 6:
					if(v338) {
						bs338 |= 2;
					} else {
						bs338 &= -3;
					}
					break;
				case 7:
					if(v338) {
						bs338 |= 1;
					} else {
						bs338 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs338;
			var this340 = 0;
			var bs339 = this340;
			var l339 = "**** ".length;
			var _g1340 = 0;
			var _g440 = l339;
			while(_g1340 < _g440) {
				var i340 = _g1340++;
				var no339 = "**** ".charCodeAt(i340);
				if(no339 == null) {
					break;
				}
				var v339;
				switch(no339) {
				case 32:
					v339 = false;
					break;
				case 42:
					v339 = true;
					break;
				case 48:
					v339 = false;
					break;
				case 49:
					v339 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i340)));
				}
				switch(i340 - (l339 - 8)) {
				case 0:
					if(v339) {
						bs339 |= 128;
					} else {
						bs339 &= -129;
					}
					break;
				case 1:
					if(v339) {
						bs339 |= 64;
					} else {
						bs339 &= -65;
					}
					break;
				case 2:
					if(v339) {
						bs339 |= 32;
					} else {
						bs339 &= -33;
					}
					break;
				case 3:
					if(v339) {
						bs339 |= 16;
					} else {
						bs339 &= -17;
					}
					break;
				case 4:
					if(v339) {
						bs339 |= 8;
					} else {
						bs339 &= -9;
					}
					break;
				case 5:
					if(v339) {
						bs339 |= 4;
					} else {
						bs339 &= -5;
					}
					break;
				case 6:
					if(v339) {
						bs339 |= 2;
					} else {
						bs339 &= -3;
					}
					break;
				case 7:
					if(v339) {
						bs339 |= 1;
					} else {
						bs339 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs339;
			var this341 = 0;
			var bs340 = this341;
			var l340 = "*    ".length;
			var _g1341 = 0;
			var _g441 = l340;
			while(_g1341 < _g441) {
				var i341 = _g1341++;
				var no340 = "*    ".charCodeAt(i341);
				if(no340 == null) {
					break;
				}
				var v340;
				switch(no340) {
				case 32:
					v340 = false;
					break;
				case 42:
					v340 = true;
					break;
				case 48:
					v340 = false;
					break;
				case 49:
					v340 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i341)));
				}
				switch(i341 - (l340 - 8)) {
				case 0:
					if(v340) {
						bs340 |= 128;
					} else {
						bs340 &= -129;
					}
					break;
				case 1:
					if(v340) {
						bs340 |= 64;
					} else {
						bs340 &= -65;
					}
					break;
				case 2:
					if(v340) {
						bs340 |= 32;
					} else {
						bs340 &= -33;
					}
					break;
				case 3:
					if(v340) {
						bs340 |= 16;
					} else {
						bs340 &= -17;
					}
					break;
				case 4:
					if(v340) {
						bs340 |= 8;
					} else {
						bs340 &= -9;
					}
					break;
				case 5:
					if(v340) {
						bs340 |= 4;
					} else {
						bs340 &= -5;
					}
					break;
				case 6:
					if(v340) {
						bs340 |= 2;
					} else {
						bs340 &= -3;
					}
					break;
				case 7:
					if(v340) {
						bs340 |= 1;
					} else {
						bs340 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs340;
			var this342 = 0;
			var bs341 = this342;
			var l341 = "*    ".length;
			var _g1342 = 0;
			var _g442 = l341;
			while(_g1342 < _g442) {
				var i342 = _g1342++;
				var no341 = "*    ".charCodeAt(i342);
				if(no341 == null) {
					break;
				}
				var v341;
				switch(no341) {
				case 32:
					v341 = false;
					break;
				case 42:
					v341 = true;
					break;
				case 48:
					v341 = false;
					break;
				case 49:
					v341 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i342)));
				}
				switch(i342 - (l341 - 8)) {
				case 0:
					if(v341) {
						bs341 |= 128;
					} else {
						bs341 &= -129;
					}
					break;
				case 1:
					if(v341) {
						bs341 |= 64;
					} else {
						bs341 &= -65;
					}
					break;
				case 2:
					if(v341) {
						bs341 |= 32;
					} else {
						bs341 &= -33;
					}
					break;
				case 3:
					if(v341) {
						bs341 |= 16;
					} else {
						bs341 &= -17;
					}
					break;
				case 4:
					if(v341) {
						bs341 |= 8;
					} else {
						bs341 &= -9;
					}
					break;
				case 5:
					if(v341) {
						bs341 |= 4;
					} else {
						bs341 &= -5;
					}
					break;
				case 6:
					if(v341) {
						bs341 |= 2;
					} else {
						bs341 &= -3;
					}
					break;
				case 7:
					if(v341) {
						bs341 |= 1;
					} else {
						bs341 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs341;
			var this343 = 0;
			var bs342 = this343;
			var l342 = "*    ".length;
			var _g1343 = 0;
			var _g443 = l342;
			while(_g1343 < _g443) {
				var i343 = _g1343++;
				var no342 = "*    ".charCodeAt(i343);
				if(no342 == null) {
					break;
				}
				var v342;
				switch(no342) {
				case 32:
					v342 = false;
					break;
				case 42:
					v342 = true;
					break;
				case 48:
					v342 = false;
					break;
				case 49:
					v342 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i343)));
				}
				switch(i343 - (l342 - 8)) {
				case 0:
					if(v342) {
						bs342 |= 128;
					} else {
						bs342 &= -129;
					}
					break;
				case 1:
					if(v342) {
						bs342 |= 64;
					} else {
						bs342 &= -65;
					}
					break;
				case 2:
					if(v342) {
						bs342 |= 32;
					} else {
						bs342 &= -33;
					}
					break;
				case 3:
					if(v342) {
						bs342 |= 16;
					} else {
						bs342 &= -17;
					}
					break;
				case 4:
					if(v342) {
						bs342 |= 8;
					} else {
						bs342 &= -9;
					}
					break;
				case 5:
					if(v342) {
						bs342 |= 4;
					} else {
						bs342 &= -5;
					}
					break;
				case 6:
					if(v342) {
						bs342 |= 2;
					} else {
						bs342 &= -3;
					}
					break;
				case 7:
					if(v342) {
						bs342 |= 1;
					} else {
						bs342 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs342;
			break;
		case 81:
			var this344 = 0;
			var bs343 = this344;
			var l343 = " *** ".length;
			var _g1344 = 0;
			var _g444 = l343;
			while(_g1344 < _g444) {
				var i344 = _g1344++;
				var no343 = " *** ".charCodeAt(i344);
				if(no343 == null) {
					break;
				}
				var v343;
				switch(no343) {
				case 32:
					v343 = false;
					break;
				case 42:
					v343 = true;
					break;
				case 48:
					v343 = false;
					break;
				case 49:
					v343 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i344)));
				}
				switch(i344 - (l343 - 8)) {
				case 0:
					if(v343) {
						bs343 |= 128;
					} else {
						bs343 &= -129;
					}
					break;
				case 1:
					if(v343) {
						bs343 |= 64;
					} else {
						bs343 &= -65;
					}
					break;
				case 2:
					if(v343) {
						bs343 |= 32;
					} else {
						bs343 &= -33;
					}
					break;
				case 3:
					if(v343) {
						bs343 |= 16;
					} else {
						bs343 &= -17;
					}
					break;
				case 4:
					if(v343) {
						bs343 |= 8;
					} else {
						bs343 &= -9;
					}
					break;
				case 5:
					if(v343) {
						bs343 |= 4;
					} else {
						bs343 &= -5;
					}
					break;
				case 6:
					if(v343) {
						bs343 |= 2;
					} else {
						bs343 &= -3;
					}
					break;
				case 7:
					if(v343) {
						bs343 |= 1;
					} else {
						bs343 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs343;
			var this345 = 0;
			var bs344 = this345;
			var l344 = "*   *".length;
			var _g1345 = 0;
			var _g445 = l344;
			while(_g1345 < _g445) {
				var i345 = _g1345++;
				var no344 = "*   *".charCodeAt(i345);
				if(no344 == null) {
					break;
				}
				var v344;
				switch(no344) {
				case 32:
					v344 = false;
					break;
				case 42:
					v344 = true;
					break;
				case 48:
					v344 = false;
					break;
				case 49:
					v344 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i345)));
				}
				switch(i345 - (l344 - 8)) {
				case 0:
					if(v344) {
						bs344 |= 128;
					} else {
						bs344 &= -129;
					}
					break;
				case 1:
					if(v344) {
						bs344 |= 64;
					} else {
						bs344 &= -65;
					}
					break;
				case 2:
					if(v344) {
						bs344 |= 32;
					} else {
						bs344 &= -33;
					}
					break;
				case 3:
					if(v344) {
						bs344 |= 16;
					} else {
						bs344 &= -17;
					}
					break;
				case 4:
					if(v344) {
						bs344 |= 8;
					} else {
						bs344 &= -9;
					}
					break;
				case 5:
					if(v344) {
						bs344 |= 4;
					} else {
						bs344 &= -5;
					}
					break;
				case 6:
					if(v344) {
						bs344 |= 2;
					} else {
						bs344 &= -3;
					}
					break;
				case 7:
					if(v344) {
						bs344 |= 1;
					} else {
						bs344 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs344;
			var this346 = 0;
			var bs345 = this346;
			var l345 = "*   *".length;
			var _g1346 = 0;
			var _g446 = l345;
			while(_g1346 < _g446) {
				var i346 = _g1346++;
				var no345 = "*   *".charCodeAt(i346);
				if(no345 == null) {
					break;
				}
				var v345;
				switch(no345) {
				case 32:
					v345 = false;
					break;
				case 42:
					v345 = true;
					break;
				case 48:
					v345 = false;
					break;
				case 49:
					v345 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i346)));
				}
				switch(i346 - (l345 - 8)) {
				case 0:
					if(v345) {
						bs345 |= 128;
					} else {
						bs345 &= -129;
					}
					break;
				case 1:
					if(v345) {
						bs345 |= 64;
					} else {
						bs345 &= -65;
					}
					break;
				case 2:
					if(v345) {
						bs345 |= 32;
					} else {
						bs345 &= -33;
					}
					break;
				case 3:
					if(v345) {
						bs345 |= 16;
					} else {
						bs345 &= -17;
					}
					break;
				case 4:
					if(v345) {
						bs345 |= 8;
					} else {
						bs345 &= -9;
					}
					break;
				case 5:
					if(v345) {
						bs345 |= 4;
					} else {
						bs345 &= -5;
					}
					break;
				case 6:
					if(v345) {
						bs345 |= 2;
					} else {
						bs345 &= -3;
					}
					break;
				case 7:
					if(v345) {
						bs345 |= 1;
					} else {
						bs345 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs345;
			var this347 = 0;
			var bs346 = this347;
			var l346 = "*   *".length;
			var _g1347 = 0;
			var _g447 = l346;
			while(_g1347 < _g447) {
				var i347 = _g1347++;
				var no346 = "*   *".charCodeAt(i347);
				if(no346 == null) {
					break;
				}
				var v346;
				switch(no346) {
				case 32:
					v346 = false;
					break;
				case 42:
					v346 = true;
					break;
				case 48:
					v346 = false;
					break;
				case 49:
					v346 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i347)));
				}
				switch(i347 - (l346 - 8)) {
				case 0:
					if(v346) {
						bs346 |= 128;
					} else {
						bs346 &= -129;
					}
					break;
				case 1:
					if(v346) {
						bs346 |= 64;
					} else {
						bs346 &= -65;
					}
					break;
				case 2:
					if(v346) {
						bs346 |= 32;
					} else {
						bs346 &= -33;
					}
					break;
				case 3:
					if(v346) {
						bs346 |= 16;
					} else {
						bs346 &= -17;
					}
					break;
				case 4:
					if(v346) {
						bs346 |= 8;
					} else {
						bs346 &= -9;
					}
					break;
				case 5:
					if(v346) {
						bs346 |= 4;
					} else {
						bs346 &= -5;
					}
					break;
				case 6:
					if(v346) {
						bs346 |= 2;
					} else {
						bs346 &= -3;
					}
					break;
				case 7:
					if(v346) {
						bs346 |= 1;
					} else {
						bs346 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs346;
			var this348 = 0;
			var bs347 = this348;
			var l347 = "* * *".length;
			var _g1348 = 0;
			var _g448 = l347;
			while(_g1348 < _g448) {
				var i348 = _g1348++;
				var no347 = "* * *".charCodeAt(i348);
				if(no347 == null) {
					break;
				}
				var v347;
				switch(no347) {
				case 32:
					v347 = false;
					break;
				case 42:
					v347 = true;
					break;
				case 48:
					v347 = false;
					break;
				case 49:
					v347 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i348)));
				}
				switch(i348 - (l347 - 8)) {
				case 0:
					if(v347) {
						bs347 |= 128;
					} else {
						bs347 &= -129;
					}
					break;
				case 1:
					if(v347) {
						bs347 |= 64;
					} else {
						bs347 &= -65;
					}
					break;
				case 2:
					if(v347) {
						bs347 |= 32;
					} else {
						bs347 &= -33;
					}
					break;
				case 3:
					if(v347) {
						bs347 |= 16;
					} else {
						bs347 &= -17;
					}
					break;
				case 4:
					if(v347) {
						bs347 |= 8;
					} else {
						bs347 &= -9;
					}
					break;
				case 5:
					if(v347) {
						bs347 |= 4;
					} else {
						bs347 &= -5;
					}
					break;
				case 6:
					if(v347) {
						bs347 |= 2;
					} else {
						bs347 &= -3;
					}
					break;
				case 7:
					if(v347) {
						bs347 |= 1;
					} else {
						bs347 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs347;
			var this349 = 0;
			var bs348 = this349;
			var l348 = "*  * ".length;
			var _g1349 = 0;
			var _g449 = l348;
			while(_g1349 < _g449) {
				var i349 = _g1349++;
				var no348 = "*  * ".charCodeAt(i349);
				if(no348 == null) {
					break;
				}
				var v348;
				switch(no348) {
				case 32:
					v348 = false;
					break;
				case 42:
					v348 = true;
					break;
				case 48:
					v348 = false;
					break;
				case 49:
					v348 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i349)));
				}
				switch(i349 - (l348 - 8)) {
				case 0:
					if(v348) {
						bs348 |= 128;
					} else {
						bs348 &= -129;
					}
					break;
				case 1:
					if(v348) {
						bs348 |= 64;
					} else {
						bs348 &= -65;
					}
					break;
				case 2:
					if(v348) {
						bs348 |= 32;
					} else {
						bs348 &= -33;
					}
					break;
				case 3:
					if(v348) {
						bs348 |= 16;
					} else {
						bs348 &= -17;
					}
					break;
				case 4:
					if(v348) {
						bs348 |= 8;
					} else {
						bs348 &= -9;
					}
					break;
				case 5:
					if(v348) {
						bs348 |= 4;
					} else {
						bs348 &= -5;
					}
					break;
				case 6:
					if(v348) {
						bs348 |= 2;
					} else {
						bs348 &= -3;
					}
					break;
				case 7:
					if(v348) {
						bs348 |= 1;
					} else {
						bs348 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs348;
			var this350 = 0;
			var bs349 = this350;
			var l349 = " ** *".length;
			var _g1350 = 0;
			var _g450 = l349;
			while(_g1350 < _g450) {
				var i350 = _g1350++;
				var no349 = " ** *".charCodeAt(i350);
				if(no349 == null) {
					break;
				}
				var v349;
				switch(no349) {
				case 32:
					v349 = false;
					break;
				case 42:
					v349 = true;
					break;
				case 48:
					v349 = false;
					break;
				case 49:
					v349 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i350)));
				}
				switch(i350 - (l349 - 8)) {
				case 0:
					if(v349) {
						bs349 |= 128;
					} else {
						bs349 &= -129;
					}
					break;
				case 1:
					if(v349) {
						bs349 |= 64;
					} else {
						bs349 &= -65;
					}
					break;
				case 2:
					if(v349) {
						bs349 |= 32;
					} else {
						bs349 &= -33;
					}
					break;
				case 3:
					if(v349) {
						bs349 |= 16;
					} else {
						bs349 &= -17;
					}
					break;
				case 4:
					if(v349) {
						bs349 |= 8;
					} else {
						bs349 &= -9;
					}
					break;
				case 5:
					if(v349) {
						bs349 |= 4;
					} else {
						bs349 &= -5;
					}
					break;
				case 6:
					if(v349) {
						bs349 |= 2;
					} else {
						bs349 &= -3;
					}
					break;
				case 7:
					if(v349) {
						bs349 |= 1;
					} else {
						bs349 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs349;
			break;
		case 82:
			var this351 = 0;
			var bs350 = this351;
			var l350 = "**** ".length;
			var _g1351 = 0;
			var _g451 = l350;
			while(_g1351 < _g451) {
				var i351 = _g1351++;
				var no350 = "**** ".charCodeAt(i351);
				if(no350 == null) {
					break;
				}
				var v350;
				switch(no350) {
				case 32:
					v350 = false;
					break;
				case 42:
					v350 = true;
					break;
				case 48:
					v350 = false;
					break;
				case 49:
					v350 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i351)));
				}
				switch(i351 - (l350 - 8)) {
				case 0:
					if(v350) {
						bs350 |= 128;
					} else {
						bs350 &= -129;
					}
					break;
				case 1:
					if(v350) {
						bs350 |= 64;
					} else {
						bs350 &= -65;
					}
					break;
				case 2:
					if(v350) {
						bs350 |= 32;
					} else {
						bs350 &= -33;
					}
					break;
				case 3:
					if(v350) {
						bs350 |= 16;
					} else {
						bs350 &= -17;
					}
					break;
				case 4:
					if(v350) {
						bs350 |= 8;
					} else {
						bs350 &= -9;
					}
					break;
				case 5:
					if(v350) {
						bs350 |= 4;
					} else {
						bs350 &= -5;
					}
					break;
				case 6:
					if(v350) {
						bs350 |= 2;
					} else {
						bs350 &= -3;
					}
					break;
				case 7:
					if(v350) {
						bs350 |= 1;
					} else {
						bs350 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs350;
			var this352 = 0;
			var bs351 = this352;
			var l351 = "*   *".length;
			var _g1352 = 0;
			var _g452 = l351;
			while(_g1352 < _g452) {
				var i352 = _g1352++;
				var no351 = "*   *".charCodeAt(i352);
				if(no351 == null) {
					break;
				}
				var v351;
				switch(no351) {
				case 32:
					v351 = false;
					break;
				case 42:
					v351 = true;
					break;
				case 48:
					v351 = false;
					break;
				case 49:
					v351 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i352)));
				}
				switch(i352 - (l351 - 8)) {
				case 0:
					if(v351) {
						bs351 |= 128;
					} else {
						bs351 &= -129;
					}
					break;
				case 1:
					if(v351) {
						bs351 |= 64;
					} else {
						bs351 &= -65;
					}
					break;
				case 2:
					if(v351) {
						bs351 |= 32;
					} else {
						bs351 &= -33;
					}
					break;
				case 3:
					if(v351) {
						bs351 |= 16;
					} else {
						bs351 &= -17;
					}
					break;
				case 4:
					if(v351) {
						bs351 |= 8;
					} else {
						bs351 &= -9;
					}
					break;
				case 5:
					if(v351) {
						bs351 |= 4;
					} else {
						bs351 &= -5;
					}
					break;
				case 6:
					if(v351) {
						bs351 |= 2;
					} else {
						bs351 &= -3;
					}
					break;
				case 7:
					if(v351) {
						bs351 |= 1;
					} else {
						bs351 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs351;
			var this353 = 0;
			var bs352 = this353;
			var l352 = "*   *".length;
			var _g1353 = 0;
			var _g453 = l352;
			while(_g1353 < _g453) {
				var i353 = _g1353++;
				var no352 = "*   *".charCodeAt(i353);
				if(no352 == null) {
					break;
				}
				var v352;
				switch(no352) {
				case 32:
					v352 = false;
					break;
				case 42:
					v352 = true;
					break;
				case 48:
					v352 = false;
					break;
				case 49:
					v352 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i353)));
				}
				switch(i353 - (l352 - 8)) {
				case 0:
					if(v352) {
						bs352 |= 128;
					} else {
						bs352 &= -129;
					}
					break;
				case 1:
					if(v352) {
						bs352 |= 64;
					} else {
						bs352 &= -65;
					}
					break;
				case 2:
					if(v352) {
						bs352 |= 32;
					} else {
						bs352 &= -33;
					}
					break;
				case 3:
					if(v352) {
						bs352 |= 16;
					} else {
						bs352 &= -17;
					}
					break;
				case 4:
					if(v352) {
						bs352 |= 8;
					} else {
						bs352 &= -9;
					}
					break;
				case 5:
					if(v352) {
						bs352 |= 4;
					} else {
						bs352 &= -5;
					}
					break;
				case 6:
					if(v352) {
						bs352 |= 2;
					} else {
						bs352 &= -3;
					}
					break;
				case 7:
					if(v352) {
						bs352 |= 1;
					} else {
						bs352 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs352;
			var this354 = 0;
			var bs353 = this354;
			var l353 = "**** ".length;
			var _g1354 = 0;
			var _g454 = l353;
			while(_g1354 < _g454) {
				var i354 = _g1354++;
				var no353 = "**** ".charCodeAt(i354);
				if(no353 == null) {
					break;
				}
				var v353;
				switch(no353) {
				case 32:
					v353 = false;
					break;
				case 42:
					v353 = true;
					break;
				case 48:
					v353 = false;
					break;
				case 49:
					v353 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i354)));
				}
				switch(i354 - (l353 - 8)) {
				case 0:
					if(v353) {
						bs353 |= 128;
					} else {
						bs353 &= -129;
					}
					break;
				case 1:
					if(v353) {
						bs353 |= 64;
					} else {
						bs353 &= -65;
					}
					break;
				case 2:
					if(v353) {
						bs353 |= 32;
					} else {
						bs353 &= -33;
					}
					break;
				case 3:
					if(v353) {
						bs353 |= 16;
					} else {
						bs353 &= -17;
					}
					break;
				case 4:
					if(v353) {
						bs353 |= 8;
					} else {
						bs353 &= -9;
					}
					break;
				case 5:
					if(v353) {
						bs353 |= 4;
					} else {
						bs353 &= -5;
					}
					break;
				case 6:
					if(v353) {
						bs353 |= 2;
					} else {
						bs353 &= -3;
					}
					break;
				case 7:
					if(v353) {
						bs353 |= 1;
					} else {
						bs353 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs353;
			var this355 = 0;
			var bs354 = this355;
			var l354 = "* *  ".length;
			var _g1355 = 0;
			var _g455 = l354;
			while(_g1355 < _g455) {
				var i355 = _g1355++;
				var no354 = "* *  ".charCodeAt(i355);
				if(no354 == null) {
					break;
				}
				var v354;
				switch(no354) {
				case 32:
					v354 = false;
					break;
				case 42:
					v354 = true;
					break;
				case 48:
					v354 = false;
					break;
				case 49:
					v354 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i355)));
				}
				switch(i355 - (l354 - 8)) {
				case 0:
					if(v354) {
						bs354 |= 128;
					} else {
						bs354 &= -129;
					}
					break;
				case 1:
					if(v354) {
						bs354 |= 64;
					} else {
						bs354 &= -65;
					}
					break;
				case 2:
					if(v354) {
						bs354 |= 32;
					} else {
						bs354 &= -33;
					}
					break;
				case 3:
					if(v354) {
						bs354 |= 16;
					} else {
						bs354 &= -17;
					}
					break;
				case 4:
					if(v354) {
						bs354 |= 8;
					} else {
						bs354 &= -9;
					}
					break;
				case 5:
					if(v354) {
						bs354 |= 4;
					} else {
						bs354 &= -5;
					}
					break;
				case 6:
					if(v354) {
						bs354 |= 2;
					} else {
						bs354 &= -3;
					}
					break;
				case 7:
					if(v354) {
						bs354 |= 1;
					} else {
						bs354 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs354;
			var this356 = 0;
			var bs355 = this356;
			var l355 = "*  * ".length;
			var _g1356 = 0;
			var _g456 = l355;
			while(_g1356 < _g456) {
				var i356 = _g1356++;
				var no355 = "*  * ".charCodeAt(i356);
				if(no355 == null) {
					break;
				}
				var v355;
				switch(no355) {
				case 32:
					v355 = false;
					break;
				case 42:
					v355 = true;
					break;
				case 48:
					v355 = false;
					break;
				case 49:
					v355 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i356)));
				}
				switch(i356 - (l355 - 8)) {
				case 0:
					if(v355) {
						bs355 |= 128;
					} else {
						bs355 &= -129;
					}
					break;
				case 1:
					if(v355) {
						bs355 |= 64;
					} else {
						bs355 &= -65;
					}
					break;
				case 2:
					if(v355) {
						bs355 |= 32;
					} else {
						bs355 &= -33;
					}
					break;
				case 3:
					if(v355) {
						bs355 |= 16;
					} else {
						bs355 &= -17;
					}
					break;
				case 4:
					if(v355) {
						bs355 |= 8;
					} else {
						bs355 &= -9;
					}
					break;
				case 5:
					if(v355) {
						bs355 |= 4;
					} else {
						bs355 &= -5;
					}
					break;
				case 6:
					if(v355) {
						bs355 |= 2;
					} else {
						bs355 &= -3;
					}
					break;
				case 7:
					if(v355) {
						bs355 |= 1;
					} else {
						bs355 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs355;
			var this357 = 0;
			var bs356 = this357;
			var l356 = "*   *".length;
			var _g1357 = 0;
			var _g457 = l356;
			while(_g1357 < _g457) {
				var i357 = _g1357++;
				var no356 = "*   *".charCodeAt(i357);
				if(no356 == null) {
					break;
				}
				var v356;
				switch(no356) {
				case 32:
					v356 = false;
					break;
				case 42:
					v356 = true;
					break;
				case 48:
					v356 = false;
					break;
				case 49:
					v356 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i357)));
				}
				switch(i357 - (l356 - 8)) {
				case 0:
					if(v356) {
						bs356 |= 128;
					} else {
						bs356 &= -129;
					}
					break;
				case 1:
					if(v356) {
						bs356 |= 64;
					} else {
						bs356 &= -65;
					}
					break;
				case 2:
					if(v356) {
						bs356 |= 32;
					} else {
						bs356 &= -33;
					}
					break;
				case 3:
					if(v356) {
						bs356 |= 16;
					} else {
						bs356 &= -17;
					}
					break;
				case 4:
					if(v356) {
						bs356 |= 8;
					} else {
						bs356 &= -9;
					}
					break;
				case 5:
					if(v356) {
						bs356 |= 4;
					} else {
						bs356 &= -5;
					}
					break;
				case 6:
					if(v356) {
						bs356 |= 2;
					} else {
						bs356 &= -3;
					}
					break;
				case 7:
					if(v356) {
						bs356 |= 1;
					} else {
						bs356 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs356;
			break;
		case 83:
			var this358 = 0;
			var bs357 = this358;
			var l357 = " ****".length;
			var _g1358 = 0;
			var _g458 = l357;
			while(_g1358 < _g458) {
				var i358 = _g1358++;
				var no357 = " ****".charCodeAt(i358);
				if(no357 == null) {
					break;
				}
				var v357;
				switch(no357) {
				case 32:
					v357 = false;
					break;
				case 42:
					v357 = true;
					break;
				case 48:
					v357 = false;
					break;
				case 49:
					v357 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i358)));
				}
				switch(i358 - (l357 - 8)) {
				case 0:
					if(v357) {
						bs357 |= 128;
					} else {
						bs357 &= -129;
					}
					break;
				case 1:
					if(v357) {
						bs357 |= 64;
					} else {
						bs357 &= -65;
					}
					break;
				case 2:
					if(v357) {
						bs357 |= 32;
					} else {
						bs357 &= -33;
					}
					break;
				case 3:
					if(v357) {
						bs357 |= 16;
					} else {
						bs357 &= -17;
					}
					break;
				case 4:
					if(v357) {
						bs357 |= 8;
					} else {
						bs357 &= -9;
					}
					break;
				case 5:
					if(v357) {
						bs357 |= 4;
					} else {
						bs357 &= -5;
					}
					break;
				case 6:
					if(v357) {
						bs357 |= 2;
					} else {
						bs357 &= -3;
					}
					break;
				case 7:
					if(v357) {
						bs357 |= 1;
					} else {
						bs357 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs357;
			var this359 = 0;
			var bs358 = this359;
			var l358 = "*    ".length;
			var _g1359 = 0;
			var _g459 = l358;
			while(_g1359 < _g459) {
				var i359 = _g1359++;
				var no358 = "*    ".charCodeAt(i359);
				if(no358 == null) {
					break;
				}
				var v358;
				switch(no358) {
				case 32:
					v358 = false;
					break;
				case 42:
					v358 = true;
					break;
				case 48:
					v358 = false;
					break;
				case 49:
					v358 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i359)));
				}
				switch(i359 - (l358 - 8)) {
				case 0:
					if(v358) {
						bs358 |= 128;
					} else {
						bs358 &= -129;
					}
					break;
				case 1:
					if(v358) {
						bs358 |= 64;
					} else {
						bs358 &= -65;
					}
					break;
				case 2:
					if(v358) {
						bs358 |= 32;
					} else {
						bs358 &= -33;
					}
					break;
				case 3:
					if(v358) {
						bs358 |= 16;
					} else {
						bs358 &= -17;
					}
					break;
				case 4:
					if(v358) {
						bs358 |= 8;
					} else {
						bs358 &= -9;
					}
					break;
				case 5:
					if(v358) {
						bs358 |= 4;
					} else {
						bs358 &= -5;
					}
					break;
				case 6:
					if(v358) {
						bs358 |= 2;
					} else {
						bs358 &= -3;
					}
					break;
				case 7:
					if(v358) {
						bs358 |= 1;
					} else {
						bs358 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs358;
			var this360 = 0;
			var bs359 = this360;
			var l359 = "*    ".length;
			var _g1360 = 0;
			var _g460 = l359;
			while(_g1360 < _g460) {
				var i360 = _g1360++;
				var no359 = "*    ".charCodeAt(i360);
				if(no359 == null) {
					break;
				}
				var v359;
				switch(no359) {
				case 32:
					v359 = false;
					break;
				case 42:
					v359 = true;
					break;
				case 48:
					v359 = false;
					break;
				case 49:
					v359 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i360)));
				}
				switch(i360 - (l359 - 8)) {
				case 0:
					if(v359) {
						bs359 |= 128;
					} else {
						bs359 &= -129;
					}
					break;
				case 1:
					if(v359) {
						bs359 |= 64;
					} else {
						bs359 &= -65;
					}
					break;
				case 2:
					if(v359) {
						bs359 |= 32;
					} else {
						bs359 &= -33;
					}
					break;
				case 3:
					if(v359) {
						bs359 |= 16;
					} else {
						bs359 &= -17;
					}
					break;
				case 4:
					if(v359) {
						bs359 |= 8;
					} else {
						bs359 &= -9;
					}
					break;
				case 5:
					if(v359) {
						bs359 |= 4;
					} else {
						bs359 &= -5;
					}
					break;
				case 6:
					if(v359) {
						bs359 |= 2;
					} else {
						bs359 &= -3;
					}
					break;
				case 7:
					if(v359) {
						bs359 |= 1;
					} else {
						bs359 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs359;
			var this361 = 0;
			var bs360 = this361;
			var l360 = " *** ".length;
			var _g1361 = 0;
			var _g461 = l360;
			while(_g1361 < _g461) {
				var i361 = _g1361++;
				var no360 = " *** ".charCodeAt(i361);
				if(no360 == null) {
					break;
				}
				var v360;
				switch(no360) {
				case 32:
					v360 = false;
					break;
				case 42:
					v360 = true;
					break;
				case 48:
					v360 = false;
					break;
				case 49:
					v360 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i361)));
				}
				switch(i361 - (l360 - 8)) {
				case 0:
					if(v360) {
						bs360 |= 128;
					} else {
						bs360 &= -129;
					}
					break;
				case 1:
					if(v360) {
						bs360 |= 64;
					} else {
						bs360 &= -65;
					}
					break;
				case 2:
					if(v360) {
						bs360 |= 32;
					} else {
						bs360 &= -33;
					}
					break;
				case 3:
					if(v360) {
						bs360 |= 16;
					} else {
						bs360 &= -17;
					}
					break;
				case 4:
					if(v360) {
						bs360 |= 8;
					} else {
						bs360 &= -9;
					}
					break;
				case 5:
					if(v360) {
						bs360 |= 4;
					} else {
						bs360 &= -5;
					}
					break;
				case 6:
					if(v360) {
						bs360 |= 2;
					} else {
						bs360 &= -3;
					}
					break;
				case 7:
					if(v360) {
						bs360 |= 1;
					} else {
						bs360 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs360;
			var this362 = 0;
			var bs361 = this362;
			var l361 = "    *".length;
			var _g1362 = 0;
			var _g462 = l361;
			while(_g1362 < _g462) {
				var i362 = _g1362++;
				var no361 = "    *".charCodeAt(i362);
				if(no361 == null) {
					break;
				}
				var v361;
				switch(no361) {
				case 32:
					v361 = false;
					break;
				case 42:
					v361 = true;
					break;
				case 48:
					v361 = false;
					break;
				case 49:
					v361 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i362)));
				}
				switch(i362 - (l361 - 8)) {
				case 0:
					if(v361) {
						bs361 |= 128;
					} else {
						bs361 &= -129;
					}
					break;
				case 1:
					if(v361) {
						bs361 |= 64;
					} else {
						bs361 &= -65;
					}
					break;
				case 2:
					if(v361) {
						bs361 |= 32;
					} else {
						bs361 &= -33;
					}
					break;
				case 3:
					if(v361) {
						bs361 |= 16;
					} else {
						bs361 &= -17;
					}
					break;
				case 4:
					if(v361) {
						bs361 |= 8;
					} else {
						bs361 &= -9;
					}
					break;
				case 5:
					if(v361) {
						bs361 |= 4;
					} else {
						bs361 &= -5;
					}
					break;
				case 6:
					if(v361) {
						bs361 |= 2;
					} else {
						bs361 &= -3;
					}
					break;
				case 7:
					if(v361) {
						bs361 |= 1;
					} else {
						bs361 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs361;
			var this363 = 0;
			var bs362 = this363;
			var l362 = "    *".length;
			var _g1363 = 0;
			var _g463 = l362;
			while(_g1363 < _g463) {
				var i363 = _g1363++;
				var no362 = "    *".charCodeAt(i363);
				if(no362 == null) {
					break;
				}
				var v362;
				switch(no362) {
				case 32:
					v362 = false;
					break;
				case 42:
					v362 = true;
					break;
				case 48:
					v362 = false;
					break;
				case 49:
					v362 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i363)));
				}
				switch(i363 - (l362 - 8)) {
				case 0:
					if(v362) {
						bs362 |= 128;
					} else {
						bs362 &= -129;
					}
					break;
				case 1:
					if(v362) {
						bs362 |= 64;
					} else {
						bs362 &= -65;
					}
					break;
				case 2:
					if(v362) {
						bs362 |= 32;
					} else {
						bs362 &= -33;
					}
					break;
				case 3:
					if(v362) {
						bs362 |= 16;
					} else {
						bs362 &= -17;
					}
					break;
				case 4:
					if(v362) {
						bs362 |= 8;
					} else {
						bs362 &= -9;
					}
					break;
				case 5:
					if(v362) {
						bs362 |= 4;
					} else {
						bs362 &= -5;
					}
					break;
				case 6:
					if(v362) {
						bs362 |= 2;
					} else {
						bs362 &= -3;
					}
					break;
				case 7:
					if(v362) {
						bs362 |= 1;
					} else {
						bs362 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs362;
			var this364 = 0;
			var bs363 = this364;
			var l363 = "**** ".length;
			var _g1364 = 0;
			var _g464 = l363;
			while(_g1364 < _g464) {
				var i364 = _g1364++;
				var no363 = "**** ".charCodeAt(i364);
				if(no363 == null) {
					break;
				}
				var v363;
				switch(no363) {
				case 32:
					v363 = false;
					break;
				case 42:
					v363 = true;
					break;
				case 48:
					v363 = false;
					break;
				case 49:
					v363 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i364)));
				}
				switch(i364 - (l363 - 8)) {
				case 0:
					if(v363) {
						bs363 |= 128;
					} else {
						bs363 &= -129;
					}
					break;
				case 1:
					if(v363) {
						bs363 |= 64;
					} else {
						bs363 &= -65;
					}
					break;
				case 2:
					if(v363) {
						bs363 |= 32;
					} else {
						bs363 &= -33;
					}
					break;
				case 3:
					if(v363) {
						bs363 |= 16;
					} else {
						bs363 &= -17;
					}
					break;
				case 4:
					if(v363) {
						bs363 |= 8;
					} else {
						bs363 &= -9;
					}
					break;
				case 5:
					if(v363) {
						bs363 |= 4;
					} else {
						bs363 &= -5;
					}
					break;
				case 6:
					if(v363) {
						bs363 |= 2;
					} else {
						bs363 &= -3;
					}
					break;
				case 7:
					if(v363) {
						bs363 |= 1;
					} else {
						bs363 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs363;
			break;
		case 84:
			var this365 = 0;
			var bs364 = this365;
			var l364 = "*****".length;
			var _g1365 = 0;
			var _g465 = l364;
			while(_g1365 < _g465) {
				var i365 = _g1365++;
				var no364 = "*****".charCodeAt(i365);
				if(no364 == null) {
					break;
				}
				var v364;
				switch(no364) {
				case 32:
					v364 = false;
					break;
				case 42:
					v364 = true;
					break;
				case 48:
					v364 = false;
					break;
				case 49:
					v364 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i365)));
				}
				switch(i365 - (l364 - 8)) {
				case 0:
					if(v364) {
						bs364 |= 128;
					} else {
						bs364 &= -129;
					}
					break;
				case 1:
					if(v364) {
						bs364 |= 64;
					} else {
						bs364 &= -65;
					}
					break;
				case 2:
					if(v364) {
						bs364 |= 32;
					} else {
						bs364 &= -33;
					}
					break;
				case 3:
					if(v364) {
						bs364 |= 16;
					} else {
						bs364 &= -17;
					}
					break;
				case 4:
					if(v364) {
						bs364 |= 8;
					} else {
						bs364 &= -9;
					}
					break;
				case 5:
					if(v364) {
						bs364 |= 4;
					} else {
						bs364 &= -5;
					}
					break;
				case 6:
					if(v364) {
						bs364 |= 2;
					} else {
						bs364 &= -3;
					}
					break;
				case 7:
					if(v364) {
						bs364 |= 1;
					} else {
						bs364 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs364;
			var this366 = 0;
			var bs365 = this366;
			var l365 = "  *  ".length;
			var _g1366 = 0;
			var _g466 = l365;
			while(_g1366 < _g466) {
				var i366 = _g1366++;
				var no365 = "  *  ".charCodeAt(i366);
				if(no365 == null) {
					break;
				}
				var v365;
				switch(no365) {
				case 32:
					v365 = false;
					break;
				case 42:
					v365 = true;
					break;
				case 48:
					v365 = false;
					break;
				case 49:
					v365 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i366)));
				}
				switch(i366 - (l365 - 8)) {
				case 0:
					if(v365) {
						bs365 |= 128;
					} else {
						bs365 &= -129;
					}
					break;
				case 1:
					if(v365) {
						bs365 |= 64;
					} else {
						bs365 &= -65;
					}
					break;
				case 2:
					if(v365) {
						bs365 |= 32;
					} else {
						bs365 &= -33;
					}
					break;
				case 3:
					if(v365) {
						bs365 |= 16;
					} else {
						bs365 &= -17;
					}
					break;
				case 4:
					if(v365) {
						bs365 |= 8;
					} else {
						bs365 &= -9;
					}
					break;
				case 5:
					if(v365) {
						bs365 |= 4;
					} else {
						bs365 &= -5;
					}
					break;
				case 6:
					if(v365) {
						bs365 |= 2;
					} else {
						bs365 &= -3;
					}
					break;
				case 7:
					if(v365) {
						bs365 |= 1;
					} else {
						bs365 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs365;
			var this367 = 0;
			var bs366 = this367;
			var l366 = "  *  ".length;
			var _g1367 = 0;
			var _g467 = l366;
			while(_g1367 < _g467) {
				var i367 = _g1367++;
				var no366 = "  *  ".charCodeAt(i367);
				if(no366 == null) {
					break;
				}
				var v366;
				switch(no366) {
				case 32:
					v366 = false;
					break;
				case 42:
					v366 = true;
					break;
				case 48:
					v366 = false;
					break;
				case 49:
					v366 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i367)));
				}
				switch(i367 - (l366 - 8)) {
				case 0:
					if(v366) {
						bs366 |= 128;
					} else {
						bs366 &= -129;
					}
					break;
				case 1:
					if(v366) {
						bs366 |= 64;
					} else {
						bs366 &= -65;
					}
					break;
				case 2:
					if(v366) {
						bs366 |= 32;
					} else {
						bs366 &= -33;
					}
					break;
				case 3:
					if(v366) {
						bs366 |= 16;
					} else {
						bs366 &= -17;
					}
					break;
				case 4:
					if(v366) {
						bs366 |= 8;
					} else {
						bs366 &= -9;
					}
					break;
				case 5:
					if(v366) {
						bs366 |= 4;
					} else {
						bs366 &= -5;
					}
					break;
				case 6:
					if(v366) {
						bs366 |= 2;
					} else {
						bs366 &= -3;
					}
					break;
				case 7:
					if(v366) {
						bs366 |= 1;
					} else {
						bs366 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs366;
			var this368 = 0;
			var bs367 = this368;
			var l367 = "  *  ".length;
			var _g1368 = 0;
			var _g468 = l367;
			while(_g1368 < _g468) {
				var i368 = _g1368++;
				var no367 = "  *  ".charCodeAt(i368);
				if(no367 == null) {
					break;
				}
				var v367;
				switch(no367) {
				case 32:
					v367 = false;
					break;
				case 42:
					v367 = true;
					break;
				case 48:
					v367 = false;
					break;
				case 49:
					v367 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i368)));
				}
				switch(i368 - (l367 - 8)) {
				case 0:
					if(v367) {
						bs367 |= 128;
					} else {
						bs367 &= -129;
					}
					break;
				case 1:
					if(v367) {
						bs367 |= 64;
					} else {
						bs367 &= -65;
					}
					break;
				case 2:
					if(v367) {
						bs367 |= 32;
					} else {
						bs367 &= -33;
					}
					break;
				case 3:
					if(v367) {
						bs367 |= 16;
					} else {
						bs367 &= -17;
					}
					break;
				case 4:
					if(v367) {
						bs367 |= 8;
					} else {
						bs367 &= -9;
					}
					break;
				case 5:
					if(v367) {
						bs367 |= 4;
					} else {
						bs367 &= -5;
					}
					break;
				case 6:
					if(v367) {
						bs367 |= 2;
					} else {
						bs367 &= -3;
					}
					break;
				case 7:
					if(v367) {
						bs367 |= 1;
					} else {
						bs367 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs367;
			var this369 = 0;
			var bs368 = this369;
			var l368 = "  *  ".length;
			var _g1369 = 0;
			var _g469 = l368;
			while(_g1369 < _g469) {
				var i369 = _g1369++;
				var no368 = "  *  ".charCodeAt(i369);
				if(no368 == null) {
					break;
				}
				var v368;
				switch(no368) {
				case 32:
					v368 = false;
					break;
				case 42:
					v368 = true;
					break;
				case 48:
					v368 = false;
					break;
				case 49:
					v368 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i369)));
				}
				switch(i369 - (l368 - 8)) {
				case 0:
					if(v368) {
						bs368 |= 128;
					} else {
						bs368 &= -129;
					}
					break;
				case 1:
					if(v368) {
						bs368 |= 64;
					} else {
						bs368 &= -65;
					}
					break;
				case 2:
					if(v368) {
						bs368 |= 32;
					} else {
						bs368 &= -33;
					}
					break;
				case 3:
					if(v368) {
						bs368 |= 16;
					} else {
						bs368 &= -17;
					}
					break;
				case 4:
					if(v368) {
						bs368 |= 8;
					} else {
						bs368 &= -9;
					}
					break;
				case 5:
					if(v368) {
						bs368 |= 4;
					} else {
						bs368 &= -5;
					}
					break;
				case 6:
					if(v368) {
						bs368 |= 2;
					} else {
						bs368 &= -3;
					}
					break;
				case 7:
					if(v368) {
						bs368 |= 1;
					} else {
						bs368 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs368;
			var this370 = 0;
			var bs369 = this370;
			var l369 = "  *  ".length;
			var _g1370 = 0;
			var _g470 = l369;
			while(_g1370 < _g470) {
				var i370 = _g1370++;
				var no369 = "  *  ".charCodeAt(i370);
				if(no369 == null) {
					break;
				}
				var v369;
				switch(no369) {
				case 32:
					v369 = false;
					break;
				case 42:
					v369 = true;
					break;
				case 48:
					v369 = false;
					break;
				case 49:
					v369 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i370)));
				}
				switch(i370 - (l369 - 8)) {
				case 0:
					if(v369) {
						bs369 |= 128;
					} else {
						bs369 &= -129;
					}
					break;
				case 1:
					if(v369) {
						bs369 |= 64;
					} else {
						bs369 &= -65;
					}
					break;
				case 2:
					if(v369) {
						bs369 |= 32;
					} else {
						bs369 &= -33;
					}
					break;
				case 3:
					if(v369) {
						bs369 |= 16;
					} else {
						bs369 &= -17;
					}
					break;
				case 4:
					if(v369) {
						bs369 |= 8;
					} else {
						bs369 &= -9;
					}
					break;
				case 5:
					if(v369) {
						bs369 |= 4;
					} else {
						bs369 &= -5;
					}
					break;
				case 6:
					if(v369) {
						bs369 |= 2;
					} else {
						bs369 &= -3;
					}
					break;
				case 7:
					if(v369) {
						bs369 |= 1;
					} else {
						bs369 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs369;
			var this371 = 0;
			var bs370 = this371;
			var l370 = "  *  ".length;
			var _g1371 = 0;
			var _g471 = l370;
			while(_g1371 < _g471) {
				var i371 = _g1371++;
				var no370 = "  *  ".charCodeAt(i371);
				if(no370 == null) {
					break;
				}
				var v370;
				switch(no370) {
				case 32:
					v370 = false;
					break;
				case 42:
					v370 = true;
					break;
				case 48:
					v370 = false;
					break;
				case 49:
					v370 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i371)));
				}
				switch(i371 - (l370 - 8)) {
				case 0:
					if(v370) {
						bs370 |= 128;
					} else {
						bs370 &= -129;
					}
					break;
				case 1:
					if(v370) {
						bs370 |= 64;
					} else {
						bs370 &= -65;
					}
					break;
				case 2:
					if(v370) {
						bs370 |= 32;
					} else {
						bs370 &= -33;
					}
					break;
				case 3:
					if(v370) {
						bs370 |= 16;
					} else {
						bs370 &= -17;
					}
					break;
				case 4:
					if(v370) {
						bs370 |= 8;
					} else {
						bs370 &= -9;
					}
					break;
				case 5:
					if(v370) {
						bs370 |= 4;
					} else {
						bs370 &= -5;
					}
					break;
				case 6:
					if(v370) {
						bs370 |= 2;
					} else {
						bs370 &= -3;
					}
					break;
				case 7:
					if(v370) {
						bs370 |= 1;
					} else {
						bs370 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs370;
			break;
		case 85:
			var this372 = 0;
			var bs371 = this372;
			var l371 = "*   *".length;
			var _g1372 = 0;
			var _g472 = l371;
			while(_g1372 < _g472) {
				var i372 = _g1372++;
				var no371 = "*   *".charCodeAt(i372);
				if(no371 == null) {
					break;
				}
				var v371;
				switch(no371) {
				case 32:
					v371 = false;
					break;
				case 42:
					v371 = true;
					break;
				case 48:
					v371 = false;
					break;
				case 49:
					v371 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i372)));
				}
				switch(i372 - (l371 - 8)) {
				case 0:
					if(v371) {
						bs371 |= 128;
					} else {
						bs371 &= -129;
					}
					break;
				case 1:
					if(v371) {
						bs371 |= 64;
					} else {
						bs371 &= -65;
					}
					break;
				case 2:
					if(v371) {
						bs371 |= 32;
					} else {
						bs371 &= -33;
					}
					break;
				case 3:
					if(v371) {
						bs371 |= 16;
					} else {
						bs371 &= -17;
					}
					break;
				case 4:
					if(v371) {
						bs371 |= 8;
					} else {
						bs371 &= -9;
					}
					break;
				case 5:
					if(v371) {
						bs371 |= 4;
					} else {
						bs371 &= -5;
					}
					break;
				case 6:
					if(v371) {
						bs371 |= 2;
					} else {
						bs371 &= -3;
					}
					break;
				case 7:
					if(v371) {
						bs371 |= 1;
					} else {
						bs371 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs371;
			var this373 = 0;
			var bs372 = this373;
			var l372 = "*   *".length;
			var _g1373 = 0;
			var _g473 = l372;
			while(_g1373 < _g473) {
				var i373 = _g1373++;
				var no372 = "*   *".charCodeAt(i373);
				if(no372 == null) {
					break;
				}
				var v372;
				switch(no372) {
				case 32:
					v372 = false;
					break;
				case 42:
					v372 = true;
					break;
				case 48:
					v372 = false;
					break;
				case 49:
					v372 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i373)));
				}
				switch(i373 - (l372 - 8)) {
				case 0:
					if(v372) {
						bs372 |= 128;
					} else {
						bs372 &= -129;
					}
					break;
				case 1:
					if(v372) {
						bs372 |= 64;
					} else {
						bs372 &= -65;
					}
					break;
				case 2:
					if(v372) {
						bs372 |= 32;
					} else {
						bs372 &= -33;
					}
					break;
				case 3:
					if(v372) {
						bs372 |= 16;
					} else {
						bs372 &= -17;
					}
					break;
				case 4:
					if(v372) {
						bs372 |= 8;
					} else {
						bs372 &= -9;
					}
					break;
				case 5:
					if(v372) {
						bs372 |= 4;
					} else {
						bs372 &= -5;
					}
					break;
				case 6:
					if(v372) {
						bs372 |= 2;
					} else {
						bs372 &= -3;
					}
					break;
				case 7:
					if(v372) {
						bs372 |= 1;
					} else {
						bs372 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs372;
			var this374 = 0;
			var bs373 = this374;
			var l373 = "*   *".length;
			var _g1374 = 0;
			var _g474 = l373;
			while(_g1374 < _g474) {
				var i374 = _g1374++;
				var no373 = "*   *".charCodeAt(i374);
				if(no373 == null) {
					break;
				}
				var v373;
				switch(no373) {
				case 32:
					v373 = false;
					break;
				case 42:
					v373 = true;
					break;
				case 48:
					v373 = false;
					break;
				case 49:
					v373 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i374)));
				}
				switch(i374 - (l373 - 8)) {
				case 0:
					if(v373) {
						bs373 |= 128;
					} else {
						bs373 &= -129;
					}
					break;
				case 1:
					if(v373) {
						bs373 |= 64;
					} else {
						bs373 &= -65;
					}
					break;
				case 2:
					if(v373) {
						bs373 |= 32;
					} else {
						bs373 &= -33;
					}
					break;
				case 3:
					if(v373) {
						bs373 |= 16;
					} else {
						bs373 &= -17;
					}
					break;
				case 4:
					if(v373) {
						bs373 |= 8;
					} else {
						bs373 &= -9;
					}
					break;
				case 5:
					if(v373) {
						bs373 |= 4;
					} else {
						bs373 &= -5;
					}
					break;
				case 6:
					if(v373) {
						bs373 |= 2;
					} else {
						bs373 &= -3;
					}
					break;
				case 7:
					if(v373) {
						bs373 |= 1;
					} else {
						bs373 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs373;
			var this375 = 0;
			var bs374 = this375;
			var l374 = "*   *".length;
			var _g1375 = 0;
			var _g475 = l374;
			while(_g1375 < _g475) {
				var i375 = _g1375++;
				var no374 = "*   *".charCodeAt(i375);
				if(no374 == null) {
					break;
				}
				var v374;
				switch(no374) {
				case 32:
					v374 = false;
					break;
				case 42:
					v374 = true;
					break;
				case 48:
					v374 = false;
					break;
				case 49:
					v374 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i375)));
				}
				switch(i375 - (l374 - 8)) {
				case 0:
					if(v374) {
						bs374 |= 128;
					} else {
						bs374 &= -129;
					}
					break;
				case 1:
					if(v374) {
						bs374 |= 64;
					} else {
						bs374 &= -65;
					}
					break;
				case 2:
					if(v374) {
						bs374 |= 32;
					} else {
						bs374 &= -33;
					}
					break;
				case 3:
					if(v374) {
						bs374 |= 16;
					} else {
						bs374 &= -17;
					}
					break;
				case 4:
					if(v374) {
						bs374 |= 8;
					} else {
						bs374 &= -9;
					}
					break;
				case 5:
					if(v374) {
						bs374 |= 4;
					} else {
						bs374 &= -5;
					}
					break;
				case 6:
					if(v374) {
						bs374 |= 2;
					} else {
						bs374 &= -3;
					}
					break;
				case 7:
					if(v374) {
						bs374 |= 1;
					} else {
						bs374 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs374;
			var this376 = 0;
			var bs375 = this376;
			var l375 = "*   *".length;
			var _g1376 = 0;
			var _g476 = l375;
			while(_g1376 < _g476) {
				var i376 = _g1376++;
				var no375 = "*   *".charCodeAt(i376);
				if(no375 == null) {
					break;
				}
				var v375;
				switch(no375) {
				case 32:
					v375 = false;
					break;
				case 42:
					v375 = true;
					break;
				case 48:
					v375 = false;
					break;
				case 49:
					v375 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i376)));
				}
				switch(i376 - (l375 - 8)) {
				case 0:
					if(v375) {
						bs375 |= 128;
					} else {
						bs375 &= -129;
					}
					break;
				case 1:
					if(v375) {
						bs375 |= 64;
					} else {
						bs375 &= -65;
					}
					break;
				case 2:
					if(v375) {
						bs375 |= 32;
					} else {
						bs375 &= -33;
					}
					break;
				case 3:
					if(v375) {
						bs375 |= 16;
					} else {
						bs375 &= -17;
					}
					break;
				case 4:
					if(v375) {
						bs375 |= 8;
					} else {
						bs375 &= -9;
					}
					break;
				case 5:
					if(v375) {
						bs375 |= 4;
					} else {
						bs375 &= -5;
					}
					break;
				case 6:
					if(v375) {
						bs375 |= 2;
					} else {
						bs375 &= -3;
					}
					break;
				case 7:
					if(v375) {
						bs375 |= 1;
					} else {
						bs375 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs375;
			var this377 = 0;
			var bs376 = this377;
			var l376 = "*   *".length;
			var _g1377 = 0;
			var _g477 = l376;
			while(_g1377 < _g477) {
				var i377 = _g1377++;
				var no376 = "*   *".charCodeAt(i377);
				if(no376 == null) {
					break;
				}
				var v376;
				switch(no376) {
				case 32:
					v376 = false;
					break;
				case 42:
					v376 = true;
					break;
				case 48:
					v376 = false;
					break;
				case 49:
					v376 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i377)));
				}
				switch(i377 - (l376 - 8)) {
				case 0:
					if(v376) {
						bs376 |= 128;
					} else {
						bs376 &= -129;
					}
					break;
				case 1:
					if(v376) {
						bs376 |= 64;
					} else {
						bs376 &= -65;
					}
					break;
				case 2:
					if(v376) {
						bs376 |= 32;
					} else {
						bs376 &= -33;
					}
					break;
				case 3:
					if(v376) {
						bs376 |= 16;
					} else {
						bs376 &= -17;
					}
					break;
				case 4:
					if(v376) {
						bs376 |= 8;
					} else {
						bs376 &= -9;
					}
					break;
				case 5:
					if(v376) {
						bs376 |= 4;
					} else {
						bs376 &= -5;
					}
					break;
				case 6:
					if(v376) {
						bs376 |= 2;
					} else {
						bs376 &= -3;
					}
					break;
				case 7:
					if(v376) {
						bs376 |= 1;
					} else {
						bs376 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs376;
			var this378 = 0;
			var bs377 = this378;
			var l377 = " *** ".length;
			var _g1378 = 0;
			var _g478 = l377;
			while(_g1378 < _g478) {
				var i378 = _g1378++;
				var no377 = " *** ".charCodeAt(i378);
				if(no377 == null) {
					break;
				}
				var v377;
				switch(no377) {
				case 32:
					v377 = false;
					break;
				case 42:
					v377 = true;
					break;
				case 48:
					v377 = false;
					break;
				case 49:
					v377 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i378)));
				}
				switch(i378 - (l377 - 8)) {
				case 0:
					if(v377) {
						bs377 |= 128;
					} else {
						bs377 &= -129;
					}
					break;
				case 1:
					if(v377) {
						bs377 |= 64;
					} else {
						bs377 &= -65;
					}
					break;
				case 2:
					if(v377) {
						bs377 |= 32;
					} else {
						bs377 &= -33;
					}
					break;
				case 3:
					if(v377) {
						bs377 |= 16;
					} else {
						bs377 &= -17;
					}
					break;
				case 4:
					if(v377) {
						bs377 |= 8;
					} else {
						bs377 &= -9;
					}
					break;
				case 5:
					if(v377) {
						bs377 |= 4;
					} else {
						bs377 &= -5;
					}
					break;
				case 6:
					if(v377) {
						bs377 |= 2;
					} else {
						bs377 &= -3;
					}
					break;
				case 7:
					if(v377) {
						bs377 |= 1;
					} else {
						bs377 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs377;
			break;
		case 86:
			var this379 = 0;
			var bs378 = this379;
			var l378 = "*   *".length;
			var _g1379 = 0;
			var _g479 = l378;
			while(_g1379 < _g479) {
				var i379 = _g1379++;
				var no378 = "*   *".charCodeAt(i379);
				if(no378 == null) {
					break;
				}
				var v378;
				switch(no378) {
				case 32:
					v378 = false;
					break;
				case 42:
					v378 = true;
					break;
				case 48:
					v378 = false;
					break;
				case 49:
					v378 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i379)));
				}
				switch(i379 - (l378 - 8)) {
				case 0:
					if(v378) {
						bs378 |= 128;
					} else {
						bs378 &= -129;
					}
					break;
				case 1:
					if(v378) {
						bs378 |= 64;
					} else {
						bs378 &= -65;
					}
					break;
				case 2:
					if(v378) {
						bs378 |= 32;
					} else {
						bs378 &= -33;
					}
					break;
				case 3:
					if(v378) {
						bs378 |= 16;
					} else {
						bs378 &= -17;
					}
					break;
				case 4:
					if(v378) {
						bs378 |= 8;
					} else {
						bs378 &= -9;
					}
					break;
				case 5:
					if(v378) {
						bs378 |= 4;
					} else {
						bs378 &= -5;
					}
					break;
				case 6:
					if(v378) {
						bs378 |= 2;
					} else {
						bs378 &= -3;
					}
					break;
				case 7:
					if(v378) {
						bs378 |= 1;
					} else {
						bs378 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs378;
			var this380 = 0;
			var bs379 = this380;
			var l379 = "*   *".length;
			var _g1380 = 0;
			var _g480 = l379;
			while(_g1380 < _g480) {
				var i380 = _g1380++;
				var no379 = "*   *".charCodeAt(i380);
				if(no379 == null) {
					break;
				}
				var v379;
				switch(no379) {
				case 32:
					v379 = false;
					break;
				case 42:
					v379 = true;
					break;
				case 48:
					v379 = false;
					break;
				case 49:
					v379 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i380)));
				}
				switch(i380 - (l379 - 8)) {
				case 0:
					if(v379) {
						bs379 |= 128;
					} else {
						bs379 &= -129;
					}
					break;
				case 1:
					if(v379) {
						bs379 |= 64;
					} else {
						bs379 &= -65;
					}
					break;
				case 2:
					if(v379) {
						bs379 |= 32;
					} else {
						bs379 &= -33;
					}
					break;
				case 3:
					if(v379) {
						bs379 |= 16;
					} else {
						bs379 &= -17;
					}
					break;
				case 4:
					if(v379) {
						bs379 |= 8;
					} else {
						bs379 &= -9;
					}
					break;
				case 5:
					if(v379) {
						bs379 |= 4;
					} else {
						bs379 &= -5;
					}
					break;
				case 6:
					if(v379) {
						bs379 |= 2;
					} else {
						bs379 &= -3;
					}
					break;
				case 7:
					if(v379) {
						bs379 |= 1;
					} else {
						bs379 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs379;
			var this381 = 0;
			var bs380 = this381;
			var l380 = "*   *".length;
			var _g1381 = 0;
			var _g481 = l380;
			while(_g1381 < _g481) {
				var i381 = _g1381++;
				var no380 = "*   *".charCodeAt(i381);
				if(no380 == null) {
					break;
				}
				var v380;
				switch(no380) {
				case 32:
					v380 = false;
					break;
				case 42:
					v380 = true;
					break;
				case 48:
					v380 = false;
					break;
				case 49:
					v380 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i381)));
				}
				switch(i381 - (l380 - 8)) {
				case 0:
					if(v380) {
						bs380 |= 128;
					} else {
						bs380 &= -129;
					}
					break;
				case 1:
					if(v380) {
						bs380 |= 64;
					} else {
						bs380 &= -65;
					}
					break;
				case 2:
					if(v380) {
						bs380 |= 32;
					} else {
						bs380 &= -33;
					}
					break;
				case 3:
					if(v380) {
						bs380 |= 16;
					} else {
						bs380 &= -17;
					}
					break;
				case 4:
					if(v380) {
						bs380 |= 8;
					} else {
						bs380 &= -9;
					}
					break;
				case 5:
					if(v380) {
						bs380 |= 4;
					} else {
						bs380 &= -5;
					}
					break;
				case 6:
					if(v380) {
						bs380 |= 2;
					} else {
						bs380 &= -3;
					}
					break;
				case 7:
					if(v380) {
						bs380 |= 1;
					} else {
						bs380 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs380;
			var this382 = 0;
			var bs381 = this382;
			var l381 = "*   *".length;
			var _g1382 = 0;
			var _g482 = l381;
			while(_g1382 < _g482) {
				var i382 = _g1382++;
				var no381 = "*   *".charCodeAt(i382);
				if(no381 == null) {
					break;
				}
				var v381;
				switch(no381) {
				case 32:
					v381 = false;
					break;
				case 42:
					v381 = true;
					break;
				case 48:
					v381 = false;
					break;
				case 49:
					v381 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i382)));
				}
				switch(i382 - (l381 - 8)) {
				case 0:
					if(v381) {
						bs381 |= 128;
					} else {
						bs381 &= -129;
					}
					break;
				case 1:
					if(v381) {
						bs381 |= 64;
					} else {
						bs381 &= -65;
					}
					break;
				case 2:
					if(v381) {
						bs381 |= 32;
					} else {
						bs381 &= -33;
					}
					break;
				case 3:
					if(v381) {
						bs381 |= 16;
					} else {
						bs381 &= -17;
					}
					break;
				case 4:
					if(v381) {
						bs381 |= 8;
					} else {
						bs381 &= -9;
					}
					break;
				case 5:
					if(v381) {
						bs381 |= 4;
					} else {
						bs381 &= -5;
					}
					break;
				case 6:
					if(v381) {
						bs381 |= 2;
					} else {
						bs381 &= -3;
					}
					break;
				case 7:
					if(v381) {
						bs381 |= 1;
					} else {
						bs381 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs381;
			var this383 = 0;
			var bs382 = this383;
			var l382 = "*   *".length;
			var _g1383 = 0;
			var _g483 = l382;
			while(_g1383 < _g483) {
				var i383 = _g1383++;
				var no382 = "*   *".charCodeAt(i383);
				if(no382 == null) {
					break;
				}
				var v382;
				switch(no382) {
				case 32:
					v382 = false;
					break;
				case 42:
					v382 = true;
					break;
				case 48:
					v382 = false;
					break;
				case 49:
					v382 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i383)));
				}
				switch(i383 - (l382 - 8)) {
				case 0:
					if(v382) {
						bs382 |= 128;
					} else {
						bs382 &= -129;
					}
					break;
				case 1:
					if(v382) {
						bs382 |= 64;
					} else {
						bs382 &= -65;
					}
					break;
				case 2:
					if(v382) {
						bs382 |= 32;
					} else {
						bs382 &= -33;
					}
					break;
				case 3:
					if(v382) {
						bs382 |= 16;
					} else {
						bs382 &= -17;
					}
					break;
				case 4:
					if(v382) {
						bs382 |= 8;
					} else {
						bs382 &= -9;
					}
					break;
				case 5:
					if(v382) {
						bs382 |= 4;
					} else {
						bs382 &= -5;
					}
					break;
				case 6:
					if(v382) {
						bs382 |= 2;
					} else {
						bs382 &= -3;
					}
					break;
				case 7:
					if(v382) {
						bs382 |= 1;
					} else {
						bs382 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs382;
			var this384 = 0;
			var bs383 = this384;
			var l383 = " * * ".length;
			var _g1384 = 0;
			var _g484 = l383;
			while(_g1384 < _g484) {
				var i384 = _g1384++;
				var no383 = " * * ".charCodeAt(i384);
				if(no383 == null) {
					break;
				}
				var v383;
				switch(no383) {
				case 32:
					v383 = false;
					break;
				case 42:
					v383 = true;
					break;
				case 48:
					v383 = false;
					break;
				case 49:
					v383 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i384)));
				}
				switch(i384 - (l383 - 8)) {
				case 0:
					if(v383) {
						bs383 |= 128;
					} else {
						bs383 &= -129;
					}
					break;
				case 1:
					if(v383) {
						bs383 |= 64;
					} else {
						bs383 &= -65;
					}
					break;
				case 2:
					if(v383) {
						bs383 |= 32;
					} else {
						bs383 &= -33;
					}
					break;
				case 3:
					if(v383) {
						bs383 |= 16;
					} else {
						bs383 &= -17;
					}
					break;
				case 4:
					if(v383) {
						bs383 |= 8;
					} else {
						bs383 &= -9;
					}
					break;
				case 5:
					if(v383) {
						bs383 |= 4;
					} else {
						bs383 &= -5;
					}
					break;
				case 6:
					if(v383) {
						bs383 |= 2;
					} else {
						bs383 &= -3;
					}
					break;
				case 7:
					if(v383) {
						bs383 |= 1;
					} else {
						bs383 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs383;
			var this385 = 0;
			var bs384 = this385;
			var l384 = "  *  ".length;
			var _g1385 = 0;
			var _g485 = l384;
			while(_g1385 < _g485) {
				var i385 = _g1385++;
				var no384 = "  *  ".charCodeAt(i385);
				if(no384 == null) {
					break;
				}
				var v384;
				switch(no384) {
				case 32:
					v384 = false;
					break;
				case 42:
					v384 = true;
					break;
				case 48:
					v384 = false;
					break;
				case 49:
					v384 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i385)));
				}
				switch(i385 - (l384 - 8)) {
				case 0:
					if(v384) {
						bs384 |= 128;
					} else {
						bs384 &= -129;
					}
					break;
				case 1:
					if(v384) {
						bs384 |= 64;
					} else {
						bs384 &= -65;
					}
					break;
				case 2:
					if(v384) {
						bs384 |= 32;
					} else {
						bs384 &= -33;
					}
					break;
				case 3:
					if(v384) {
						bs384 |= 16;
					} else {
						bs384 &= -17;
					}
					break;
				case 4:
					if(v384) {
						bs384 |= 8;
					} else {
						bs384 &= -9;
					}
					break;
				case 5:
					if(v384) {
						bs384 |= 4;
					} else {
						bs384 &= -5;
					}
					break;
				case 6:
					if(v384) {
						bs384 |= 2;
					} else {
						bs384 &= -3;
					}
					break;
				case 7:
					if(v384) {
						bs384 |= 1;
					} else {
						bs384 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs384;
			break;
		case 87:
			var this386 = 0;
			var bs385 = this386;
			var l385 = "*   *".length;
			var _g1386 = 0;
			var _g486 = l385;
			while(_g1386 < _g486) {
				var i386 = _g1386++;
				var no385 = "*   *".charCodeAt(i386);
				if(no385 == null) {
					break;
				}
				var v385;
				switch(no385) {
				case 32:
					v385 = false;
					break;
				case 42:
					v385 = true;
					break;
				case 48:
					v385 = false;
					break;
				case 49:
					v385 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i386)));
				}
				switch(i386 - (l385 - 8)) {
				case 0:
					if(v385) {
						bs385 |= 128;
					} else {
						bs385 &= -129;
					}
					break;
				case 1:
					if(v385) {
						bs385 |= 64;
					} else {
						bs385 &= -65;
					}
					break;
				case 2:
					if(v385) {
						bs385 |= 32;
					} else {
						bs385 &= -33;
					}
					break;
				case 3:
					if(v385) {
						bs385 |= 16;
					} else {
						bs385 &= -17;
					}
					break;
				case 4:
					if(v385) {
						bs385 |= 8;
					} else {
						bs385 &= -9;
					}
					break;
				case 5:
					if(v385) {
						bs385 |= 4;
					} else {
						bs385 &= -5;
					}
					break;
				case 6:
					if(v385) {
						bs385 |= 2;
					} else {
						bs385 &= -3;
					}
					break;
				case 7:
					if(v385) {
						bs385 |= 1;
					} else {
						bs385 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs385;
			var this387 = 0;
			var bs386 = this387;
			var l386 = "*   *".length;
			var _g1387 = 0;
			var _g487 = l386;
			while(_g1387 < _g487) {
				var i387 = _g1387++;
				var no386 = "*   *".charCodeAt(i387);
				if(no386 == null) {
					break;
				}
				var v386;
				switch(no386) {
				case 32:
					v386 = false;
					break;
				case 42:
					v386 = true;
					break;
				case 48:
					v386 = false;
					break;
				case 49:
					v386 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i387)));
				}
				switch(i387 - (l386 - 8)) {
				case 0:
					if(v386) {
						bs386 |= 128;
					} else {
						bs386 &= -129;
					}
					break;
				case 1:
					if(v386) {
						bs386 |= 64;
					} else {
						bs386 &= -65;
					}
					break;
				case 2:
					if(v386) {
						bs386 |= 32;
					} else {
						bs386 &= -33;
					}
					break;
				case 3:
					if(v386) {
						bs386 |= 16;
					} else {
						bs386 &= -17;
					}
					break;
				case 4:
					if(v386) {
						bs386 |= 8;
					} else {
						bs386 &= -9;
					}
					break;
				case 5:
					if(v386) {
						bs386 |= 4;
					} else {
						bs386 &= -5;
					}
					break;
				case 6:
					if(v386) {
						bs386 |= 2;
					} else {
						bs386 &= -3;
					}
					break;
				case 7:
					if(v386) {
						bs386 |= 1;
					} else {
						bs386 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs386;
			var this388 = 0;
			var bs387 = this388;
			var l387 = "*   *".length;
			var _g1388 = 0;
			var _g488 = l387;
			while(_g1388 < _g488) {
				var i388 = _g1388++;
				var no387 = "*   *".charCodeAt(i388);
				if(no387 == null) {
					break;
				}
				var v387;
				switch(no387) {
				case 32:
					v387 = false;
					break;
				case 42:
					v387 = true;
					break;
				case 48:
					v387 = false;
					break;
				case 49:
					v387 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i388)));
				}
				switch(i388 - (l387 - 8)) {
				case 0:
					if(v387) {
						bs387 |= 128;
					} else {
						bs387 &= -129;
					}
					break;
				case 1:
					if(v387) {
						bs387 |= 64;
					} else {
						bs387 &= -65;
					}
					break;
				case 2:
					if(v387) {
						bs387 |= 32;
					} else {
						bs387 &= -33;
					}
					break;
				case 3:
					if(v387) {
						bs387 |= 16;
					} else {
						bs387 &= -17;
					}
					break;
				case 4:
					if(v387) {
						bs387 |= 8;
					} else {
						bs387 &= -9;
					}
					break;
				case 5:
					if(v387) {
						bs387 |= 4;
					} else {
						bs387 &= -5;
					}
					break;
				case 6:
					if(v387) {
						bs387 |= 2;
					} else {
						bs387 &= -3;
					}
					break;
				case 7:
					if(v387) {
						bs387 |= 1;
					} else {
						bs387 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs387;
			var this389 = 0;
			var bs388 = this389;
			var l388 = "* * *".length;
			var _g1389 = 0;
			var _g489 = l388;
			while(_g1389 < _g489) {
				var i389 = _g1389++;
				var no388 = "* * *".charCodeAt(i389);
				if(no388 == null) {
					break;
				}
				var v388;
				switch(no388) {
				case 32:
					v388 = false;
					break;
				case 42:
					v388 = true;
					break;
				case 48:
					v388 = false;
					break;
				case 49:
					v388 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i389)));
				}
				switch(i389 - (l388 - 8)) {
				case 0:
					if(v388) {
						bs388 |= 128;
					} else {
						bs388 &= -129;
					}
					break;
				case 1:
					if(v388) {
						bs388 |= 64;
					} else {
						bs388 &= -65;
					}
					break;
				case 2:
					if(v388) {
						bs388 |= 32;
					} else {
						bs388 &= -33;
					}
					break;
				case 3:
					if(v388) {
						bs388 |= 16;
					} else {
						bs388 &= -17;
					}
					break;
				case 4:
					if(v388) {
						bs388 |= 8;
					} else {
						bs388 &= -9;
					}
					break;
				case 5:
					if(v388) {
						bs388 |= 4;
					} else {
						bs388 &= -5;
					}
					break;
				case 6:
					if(v388) {
						bs388 |= 2;
					} else {
						bs388 &= -3;
					}
					break;
				case 7:
					if(v388) {
						bs388 |= 1;
					} else {
						bs388 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs388;
			var this390 = 0;
			var bs389 = this390;
			var l389 = "* * *".length;
			var _g1390 = 0;
			var _g490 = l389;
			while(_g1390 < _g490) {
				var i390 = _g1390++;
				var no389 = "* * *".charCodeAt(i390);
				if(no389 == null) {
					break;
				}
				var v389;
				switch(no389) {
				case 32:
					v389 = false;
					break;
				case 42:
					v389 = true;
					break;
				case 48:
					v389 = false;
					break;
				case 49:
					v389 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i390)));
				}
				switch(i390 - (l389 - 8)) {
				case 0:
					if(v389) {
						bs389 |= 128;
					} else {
						bs389 &= -129;
					}
					break;
				case 1:
					if(v389) {
						bs389 |= 64;
					} else {
						bs389 &= -65;
					}
					break;
				case 2:
					if(v389) {
						bs389 |= 32;
					} else {
						bs389 &= -33;
					}
					break;
				case 3:
					if(v389) {
						bs389 |= 16;
					} else {
						bs389 &= -17;
					}
					break;
				case 4:
					if(v389) {
						bs389 |= 8;
					} else {
						bs389 &= -9;
					}
					break;
				case 5:
					if(v389) {
						bs389 |= 4;
					} else {
						bs389 &= -5;
					}
					break;
				case 6:
					if(v389) {
						bs389 |= 2;
					} else {
						bs389 &= -3;
					}
					break;
				case 7:
					if(v389) {
						bs389 |= 1;
					} else {
						bs389 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs389;
			var this391 = 0;
			var bs390 = this391;
			var l390 = "* * *".length;
			var _g1391 = 0;
			var _g491 = l390;
			while(_g1391 < _g491) {
				var i391 = _g1391++;
				var no390 = "* * *".charCodeAt(i391);
				if(no390 == null) {
					break;
				}
				var v390;
				switch(no390) {
				case 32:
					v390 = false;
					break;
				case 42:
					v390 = true;
					break;
				case 48:
					v390 = false;
					break;
				case 49:
					v390 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i391)));
				}
				switch(i391 - (l390 - 8)) {
				case 0:
					if(v390) {
						bs390 |= 128;
					} else {
						bs390 &= -129;
					}
					break;
				case 1:
					if(v390) {
						bs390 |= 64;
					} else {
						bs390 &= -65;
					}
					break;
				case 2:
					if(v390) {
						bs390 |= 32;
					} else {
						bs390 &= -33;
					}
					break;
				case 3:
					if(v390) {
						bs390 |= 16;
					} else {
						bs390 &= -17;
					}
					break;
				case 4:
					if(v390) {
						bs390 |= 8;
					} else {
						bs390 &= -9;
					}
					break;
				case 5:
					if(v390) {
						bs390 |= 4;
					} else {
						bs390 &= -5;
					}
					break;
				case 6:
					if(v390) {
						bs390 |= 2;
					} else {
						bs390 &= -3;
					}
					break;
				case 7:
					if(v390) {
						bs390 |= 1;
					} else {
						bs390 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs390;
			var this392 = 0;
			var bs391 = this392;
			var l391 = " * * ".length;
			var _g1392 = 0;
			var _g492 = l391;
			while(_g1392 < _g492) {
				var i392 = _g1392++;
				var no391 = " * * ".charCodeAt(i392);
				if(no391 == null) {
					break;
				}
				var v391;
				switch(no391) {
				case 32:
					v391 = false;
					break;
				case 42:
					v391 = true;
					break;
				case 48:
					v391 = false;
					break;
				case 49:
					v391 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i392)));
				}
				switch(i392 - (l391 - 8)) {
				case 0:
					if(v391) {
						bs391 |= 128;
					} else {
						bs391 &= -129;
					}
					break;
				case 1:
					if(v391) {
						bs391 |= 64;
					} else {
						bs391 &= -65;
					}
					break;
				case 2:
					if(v391) {
						bs391 |= 32;
					} else {
						bs391 &= -33;
					}
					break;
				case 3:
					if(v391) {
						bs391 |= 16;
					} else {
						bs391 &= -17;
					}
					break;
				case 4:
					if(v391) {
						bs391 |= 8;
					} else {
						bs391 &= -9;
					}
					break;
				case 5:
					if(v391) {
						bs391 |= 4;
					} else {
						bs391 &= -5;
					}
					break;
				case 6:
					if(v391) {
						bs391 |= 2;
					} else {
						bs391 &= -3;
					}
					break;
				case 7:
					if(v391) {
						bs391 |= 1;
					} else {
						bs391 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs391;
			break;
		case 88:
			var this393 = 0;
			var bs392 = this393;
			var l392 = "*   *".length;
			var _g1393 = 0;
			var _g493 = l392;
			while(_g1393 < _g493) {
				var i393 = _g1393++;
				var no392 = "*   *".charCodeAt(i393);
				if(no392 == null) {
					break;
				}
				var v392;
				switch(no392) {
				case 32:
					v392 = false;
					break;
				case 42:
					v392 = true;
					break;
				case 48:
					v392 = false;
					break;
				case 49:
					v392 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i393)));
				}
				switch(i393 - (l392 - 8)) {
				case 0:
					if(v392) {
						bs392 |= 128;
					} else {
						bs392 &= -129;
					}
					break;
				case 1:
					if(v392) {
						bs392 |= 64;
					} else {
						bs392 &= -65;
					}
					break;
				case 2:
					if(v392) {
						bs392 |= 32;
					} else {
						bs392 &= -33;
					}
					break;
				case 3:
					if(v392) {
						bs392 |= 16;
					} else {
						bs392 &= -17;
					}
					break;
				case 4:
					if(v392) {
						bs392 |= 8;
					} else {
						bs392 &= -9;
					}
					break;
				case 5:
					if(v392) {
						bs392 |= 4;
					} else {
						bs392 &= -5;
					}
					break;
				case 6:
					if(v392) {
						bs392 |= 2;
					} else {
						bs392 &= -3;
					}
					break;
				case 7:
					if(v392) {
						bs392 |= 1;
					} else {
						bs392 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs392;
			var this394 = 0;
			var bs393 = this394;
			var l393 = "*   *".length;
			var _g1394 = 0;
			var _g494 = l393;
			while(_g1394 < _g494) {
				var i394 = _g1394++;
				var no393 = "*   *".charCodeAt(i394);
				if(no393 == null) {
					break;
				}
				var v393;
				switch(no393) {
				case 32:
					v393 = false;
					break;
				case 42:
					v393 = true;
					break;
				case 48:
					v393 = false;
					break;
				case 49:
					v393 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i394)));
				}
				switch(i394 - (l393 - 8)) {
				case 0:
					if(v393) {
						bs393 |= 128;
					} else {
						bs393 &= -129;
					}
					break;
				case 1:
					if(v393) {
						bs393 |= 64;
					} else {
						bs393 &= -65;
					}
					break;
				case 2:
					if(v393) {
						bs393 |= 32;
					} else {
						bs393 &= -33;
					}
					break;
				case 3:
					if(v393) {
						bs393 |= 16;
					} else {
						bs393 &= -17;
					}
					break;
				case 4:
					if(v393) {
						bs393 |= 8;
					} else {
						bs393 &= -9;
					}
					break;
				case 5:
					if(v393) {
						bs393 |= 4;
					} else {
						bs393 &= -5;
					}
					break;
				case 6:
					if(v393) {
						bs393 |= 2;
					} else {
						bs393 &= -3;
					}
					break;
				case 7:
					if(v393) {
						bs393 |= 1;
					} else {
						bs393 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs393;
			var this395 = 0;
			var bs394 = this395;
			var l394 = " * * ".length;
			var _g1395 = 0;
			var _g495 = l394;
			while(_g1395 < _g495) {
				var i395 = _g1395++;
				var no394 = " * * ".charCodeAt(i395);
				if(no394 == null) {
					break;
				}
				var v394;
				switch(no394) {
				case 32:
					v394 = false;
					break;
				case 42:
					v394 = true;
					break;
				case 48:
					v394 = false;
					break;
				case 49:
					v394 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i395)));
				}
				switch(i395 - (l394 - 8)) {
				case 0:
					if(v394) {
						bs394 |= 128;
					} else {
						bs394 &= -129;
					}
					break;
				case 1:
					if(v394) {
						bs394 |= 64;
					} else {
						bs394 &= -65;
					}
					break;
				case 2:
					if(v394) {
						bs394 |= 32;
					} else {
						bs394 &= -33;
					}
					break;
				case 3:
					if(v394) {
						bs394 |= 16;
					} else {
						bs394 &= -17;
					}
					break;
				case 4:
					if(v394) {
						bs394 |= 8;
					} else {
						bs394 &= -9;
					}
					break;
				case 5:
					if(v394) {
						bs394 |= 4;
					} else {
						bs394 &= -5;
					}
					break;
				case 6:
					if(v394) {
						bs394 |= 2;
					} else {
						bs394 &= -3;
					}
					break;
				case 7:
					if(v394) {
						bs394 |= 1;
					} else {
						bs394 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs394;
			var this396 = 0;
			var bs395 = this396;
			var l395 = "  *  ".length;
			var _g1396 = 0;
			var _g496 = l395;
			while(_g1396 < _g496) {
				var i396 = _g1396++;
				var no395 = "  *  ".charCodeAt(i396);
				if(no395 == null) {
					break;
				}
				var v395;
				switch(no395) {
				case 32:
					v395 = false;
					break;
				case 42:
					v395 = true;
					break;
				case 48:
					v395 = false;
					break;
				case 49:
					v395 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i396)));
				}
				switch(i396 - (l395 - 8)) {
				case 0:
					if(v395) {
						bs395 |= 128;
					} else {
						bs395 &= -129;
					}
					break;
				case 1:
					if(v395) {
						bs395 |= 64;
					} else {
						bs395 &= -65;
					}
					break;
				case 2:
					if(v395) {
						bs395 |= 32;
					} else {
						bs395 &= -33;
					}
					break;
				case 3:
					if(v395) {
						bs395 |= 16;
					} else {
						bs395 &= -17;
					}
					break;
				case 4:
					if(v395) {
						bs395 |= 8;
					} else {
						bs395 &= -9;
					}
					break;
				case 5:
					if(v395) {
						bs395 |= 4;
					} else {
						bs395 &= -5;
					}
					break;
				case 6:
					if(v395) {
						bs395 |= 2;
					} else {
						bs395 &= -3;
					}
					break;
				case 7:
					if(v395) {
						bs395 |= 1;
					} else {
						bs395 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs395;
			var this397 = 0;
			var bs396 = this397;
			var l396 = " * * ".length;
			var _g1397 = 0;
			var _g497 = l396;
			while(_g1397 < _g497) {
				var i397 = _g1397++;
				var no396 = " * * ".charCodeAt(i397);
				if(no396 == null) {
					break;
				}
				var v396;
				switch(no396) {
				case 32:
					v396 = false;
					break;
				case 42:
					v396 = true;
					break;
				case 48:
					v396 = false;
					break;
				case 49:
					v396 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i397)));
				}
				switch(i397 - (l396 - 8)) {
				case 0:
					if(v396) {
						bs396 |= 128;
					} else {
						bs396 &= -129;
					}
					break;
				case 1:
					if(v396) {
						bs396 |= 64;
					} else {
						bs396 &= -65;
					}
					break;
				case 2:
					if(v396) {
						bs396 |= 32;
					} else {
						bs396 &= -33;
					}
					break;
				case 3:
					if(v396) {
						bs396 |= 16;
					} else {
						bs396 &= -17;
					}
					break;
				case 4:
					if(v396) {
						bs396 |= 8;
					} else {
						bs396 &= -9;
					}
					break;
				case 5:
					if(v396) {
						bs396 |= 4;
					} else {
						bs396 &= -5;
					}
					break;
				case 6:
					if(v396) {
						bs396 |= 2;
					} else {
						bs396 &= -3;
					}
					break;
				case 7:
					if(v396) {
						bs396 |= 1;
					} else {
						bs396 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs396;
			var this398 = 0;
			var bs397 = this398;
			var l397 = "*   *".length;
			var _g1398 = 0;
			var _g498 = l397;
			while(_g1398 < _g498) {
				var i398 = _g1398++;
				var no397 = "*   *".charCodeAt(i398);
				if(no397 == null) {
					break;
				}
				var v397;
				switch(no397) {
				case 32:
					v397 = false;
					break;
				case 42:
					v397 = true;
					break;
				case 48:
					v397 = false;
					break;
				case 49:
					v397 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i398)));
				}
				switch(i398 - (l397 - 8)) {
				case 0:
					if(v397) {
						bs397 |= 128;
					} else {
						bs397 &= -129;
					}
					break;
				case 1:
					if(v397) {
						bs397 |= 64;
					} else {
						bs397 &= -65;
					}
					break;
				case 2:
					if(v397) {
						bs397 |= 32;
					} else {
						bs397 &= -33;
					}
					break;
				case 3:
					if(v397) {
						bs397 |= 16;
					} else {
						bs397 &= -17;
					}
					break;
				case 4:
					if(v397) {
						bs397 |= 8;
					} else {
						bs397 &= -9;
					}
					break;
				case 5:
					if(v397) {
						bs397 |= 4;
					} else {
						bs397 &= -5;
					}
					break;
				case 6:
					if(v397) {
						bs397 |= 2;
					} else {
						bs397 &= -3;
					}
					break;
				case 7:
					if(v397) {
						bs397 |= 1;
					} else {
						bs397 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs397;
			var this399 = 0;
			var bs398 = this399;
			var l398 = "*   *".length;
			var _g1399 = 0;
			var _g499 = l398;
			while(_g1399 < _g499) {
				var i399 = _g1399++;
				var no398 = "*   *".charCodeAt(i399);
				if(no398 == null) {
					break;
				}
				var v398;
				switch(no398) {
				case 32:
					v398 = false;
					break;
				case 42:
					v398 = true;
					break;
				case 48:
					v398 = false;
					break;
				case 49:
					v398 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i399)));
				}
				switch(i399 - (l398 - 8)) {
				case 0:
					if(v398) {
						bs398 |= 128;
					} else {
						bs398 &= -129;
					}
					break;
				case 1:
					if(v398) {
						bs398 |= 64;
					} else {
						bs398 &= -65;
					}
					break;
				case 2:
					if(v398) {
						bs398 |= 32;
					} else {
						bs398 &= -33;
					}
					break;
				case 3:
					if(v398) {
						bs398 |= 16;
					} else {
						bs398 &= -17;
					}
					break;
				case 4:
					if(v398) {
						bs398 |= 8;
					} else {
						bs398 &= -9;
					}
					break;
				case 5:
					if(v398) {
						bs398 |= 4;
					} else {
						bs398 &= -5;
					}
					break;
				case 6:
					if(v398) {
						bs398 |= 2;
					} else {
						bs398 &= -3;
					}
					break;
				case 7:
					if(v398) {
						bs398 |= 1;
					} else {
						bs398 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs398;
			break;
		case 89:
			var this400 = 0;
			var bs399 = this400;
			var l399 = "*   *".length;
			var _g1400 = 0;
			var _g500 = l399;
			while(_g1400 < _g500) {
				var i400 = _g1400++;
				var no399 = "*   *".charCodeAt(i400);
				if(no399 == null) {
					break;
				}
				var v399;
				switch(no399) {
				case 32:
					v399 = false;
					break;
				case 42:
					v399 = true;
					break;
				case 48:
					v399 = false;
					break;
				case 49:
					v399 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i400)));
				}
				switch(i400 - (l399 - 8)) {
				case 0:
					if(v399) {
						bs399 |= 128;
					} else {
						bs399 &= -129;
					}
					break;
				case 1:
					if(v399) {
						bs399 |= 64;
					} else {
						bs399 &= -65;
					}
					break;
				case 2:
					if(v399) {
						bs399 |= 32;
					} else {
						bs399 &= -33;
					}
					break;
				case 3:
					if(v399) {
						bs399 |= 16;
					} else {
						bs399 &= -17;
					}
					break;
				case 4:
					if(v399) {
						bs399 |= 8;
					} else {
						bs399 &= -9;
					}
					break;
				case 5:
					if(v399) {
						bs399 |= 4;
					} else {
						bs399 &= -5;
					}
					break;
				case 6:
					if(v399) {
						bs399 |= 2;
					} else {
						bs399 &= -3;
					}
					break;
				case 7:
					if(v399) {
						bs399 |= 1;
					} else {
						bs399 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs399;
			var this401 = 0;
			var bs400 = this401;
			var l400 = "*   *".length;
			var _g1401 = 0;
			var _g501 = l400;
			while(_g1401 < _g501) {
				var i401 = _g1401++;
				var no400 = "*   *".charCodeAt(i401);
				if(no400 == null) {
					break;
				}
				var v400;
				switch(no400) {
				case 32:
					v400 = false;
					break;
				case 42:
					v400 = true;
					break;
				case 48:
					v400 = false;
					break;
				case 49:
					v400 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i401)));
				}
				switch(i401 - (l400 - 8)) {
				case 0:
					if(v400) {
						bs400 |= 128;
					} else {
						bs400 &= -129;
					}
					break;
				case 1:
					if(v400) {
						bs400 |= 64;
					} else {
						bs400 &= -65;
					}
					break;
				case 2:
					if(v400) {
						bs400 |= 32;
					} else {
						bs400 &= -33;
					}
					break;
				case 3:
					if(v400) {
						bs400 |= 16;
					} else {
						bs400 &= -17;
					}
					break;
				case 4:
					if(v400) {
						bs400 |= 8;
					} else {
						bs400 &= -9;
					}
					break;
				case 5:
					if(v400) {
						bs400 |= 4;
					} else {
						bs400 &= -5;
					}
					break;
				case 6:
					if(v400) {
						bs400 |= 2;
					} else {
						bs400 &= -3;
					}
					break;
				case 7:
					if(v400) {
						bs400 |= 1;
					} else {
						bs400 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs400;
			var this402 = 0;
			var bs401 = this402;
			var l401 = "*   *".length;
			var _g1402 = 0;
			var _g502 = l401;
			while(_g1402 < _g502) {
				var i402 = _g1402++;
				var no401 = "*   *".charCodeAt(i402);
				if(no401 == null) {
					break;
				}
				var v401;
				switch(no401) {
				case 32:
					v401 = false;
					break;
				case 42:
					v401 = true;
					break;
				case 48:
					v401 = false;
					break;
				case 49:
					v401 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i402)));
				}
				switch(i402 - (l401 - 8)) {
				case 0:
					if(v401) {
						bs401 |= 128;
					} else {
						bs401 &= -129;
					}
					break;
				case 1:
					if(v401) {
						bs401 |= 64;
					} else {
						bs401 &= -65;
					}
					break;
				case 2:
					if(v401) {
						bs401 |= 32;
					} else {
						bs401 &= -33;
					}
					break;
				case 3:
					if(v401) {
						bs401 |= 16;
					} else {
						bs401 &= -17;
					}
					break;
				case 4:
					if(v401) {
						bs401 |= 8;
					} else {
						bs401 &= -9;
					}
					break;
				case 5:
					if(v401) {
						bs401 |= 4;
					} else {
						bs401 &= -5;
					}
					break;
				case 6:
					if(v401) {
						bs401 |= 2;
					} else {
						bs401 &= -3;
					}
					break;
				case 7:
					if(v401) {
						bs401 |= 1;
					} else {
						bs401 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs401;
			var this403 = 0;
			var bs402 = this403;
			var l402 = " * * ".length;
			var _g1403 = 0;
			var _g503 = l402;
			while(_g1403 < _g503) {
				var i403 = _g1403++;
				var no402 = " * * ".charCodeAt(i403);
				if(no402 == null) {
					break;
				}
				var v402;
				switch(no402) {
				case 32:
					v402 = false;
					break;
				case 42:
					v402 = true;
					break;
				case 48:
					v402 = false;
					break;
				case 49:
					v402 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i403)));
				}
				switch(i403 - (l402 - 8)) {
				case 0:
					if(v402) {
						bs402 |= 128;
					} else {
						bs402 &= -129;
					}
					break;
				case 1:
					if(v402) {
						bs402 |= 64;
					} else {
						bs402 &= -65;
					}
					break;
				case 2:
					if(v402) {
						bs402 |= 32;
					} else {
						bs402 &= -33;
					}
					break;
				case 3:
					if(v402) {
						bs402 |= 16;
					} else {
						bs402 &= -17;
					}
					break;
				case 4:
					if(v402) {
						bs402 |= 8;
					} else {
						bs402 &= -9;
					}
					break;
				case 5:
					if(v402) {
						bs402 |= 4;
					} else {
						bs402 &= -5;
					}
					break;
				case 6:
					if(v402) {
						bs402 |= 2;
					} else {
						bs402 &= -3;
					}
					break;
				case 7:
					if(v402) {
						bs402 |= 1;
					} else {
						bs402 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs402;
			var this404 = 0;
			var bs403 = this404;
			var l403 = "  *  ".length;
			var _g1404 = 0;
			var _g504 = l403;
			while(_g1404 < _g504) {
				var i404 = _g1404++;
				var no403 = "  *  ".charCodeAt(i404);
				if(no403 == null) {
					break;
				}
				var v403;
				switch(no403) {
				case 32:
					v403 = false;
					break;
				case 42:
					v403 = true;
					break;
				case 48:
					v403 = false;
					break;
				case 49:
					v403 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i404)));
				}
				switch(i404 - (l403 - 8)) {
				case 0:
					if(v403) {
						bs403 |= 128;
					} else {
						bs403 &= -129;
					}
					break;
				case 1:
					if(v403) {
						bs403 |= 64;
					} else {
						bs403 &= -65;
					}
					break;
				case 2:
					if(v403) {
						bs403 |= 32;
					} else {
						bs403 &= -33;
					}
					break;
				case 3:
					if(v403) {
						bs403 |= 16;
					} else {
						bs403 &= -17;
					}
					break;
				case 4:
					if(v403) {
						bs403 |= 8;
					} else {
						bs403 &= -9;
					}
					break;
				case 5:
					if(v403) {
						bs403 |= 4;
					} else {
						bs403 &= -5;
					}
					break;
				case 6:
					if(v403) {
						bs403 |= 2;
					} else {
						bs403 &= -3;
					}
					break;
				case 7:
					if(v403) {
						bs403 |= 1;
					} else {
						bs403 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs403;
			var this405 = 0;
			var bs404 = this405;
			var l404 = "  *  ".length;
			var _g1405 = 0;
			var _g505 = l404;
			while(_g1405 < _g505) {
				var i405 = _g1405++;
				var no404 = "  *  ".charCodeAt(i405);
				if(no404 == null) {
					break;
				}
				var v404;
				switch(no404) {
				case 32:
					v404 = false;
					break;
				case 42:
					v404 = true;
					break;
				case 48:
					v404 = false;
					break;
				case 49:
					v404 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i405)));
				}
				switch(i405 - (l404 - 8)) {
				case 0:
					if(v404) {
						bs404 |= 128;
					} else {
						bs404 &= -129;
					}
					break;
				case 1:
					if(v404) {
						bs404 |= 64;
					} else {
						bs404 &= -65;
					}
					break;
				case 2:
					if(v404) {
						bs404 |= 32;
					} else {
						bs404 &= -33;
					}
					break;
				case 3:
					if(v404) {
						bs404 |= 16;
					} else {
						bs404 &= -17;
					}
					break;
				case 4:
					if(v404) {
						bs404 |= 8;
					} else {
						bs404 &= -9;
					}
					break;
				case 5:
					if(v404) {
						bs404 |= 4;
					} else {
						bs404 &= -5;
					}
					break;
				case 6:
					if(v404) {
						bs404 |= 2;
					} else {
						bs404 &= -3;
					}
					break;
				case 7:
					if(v404) {
						bs404 |= 1;
					} else {
						bs404 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs404;
			var this406 = 0;
			var bs405 = this406;
			var l405 = "  *  ".length;
			var _g1406 = 0;
			var _g506 = l405;
			while(_g1406 < _g506) {
				var i406 = _g1406++;
				var no405 = "  *  ".charCodeAt(i406);
				if(no405 == null) {
					break;
				}
				var v405;
				switch(no405) {
				case 32:
					v405 = false;
					break;
				case 42:
					v405 = true;
					break;
				case 48:
					v405 = false;
					break;
				case 49:
					v405 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i406)));
				}
				switch(i406 - (l405 - 8)) {
				case 0:
					if(v405) {
						bs405 |= 128;
					} else {
						bs405 &= -129;
					}
					break;
				case 1:
					if(v405) {
						bs405 |= 64;
					} else {
						bs405 &= -65;
					}
					break;
				case 2:
					if(v405) {
						bs405 |= 32;
					} else {
						bs405 &= -33;
					}
					break;
				case 3:
					if(v405) {
						bs405 |= 16;
					} else {
						bs405 &= -17;
					}
					break;
				case 4:
					if(v405) {
						bs405 |= 8;
					} else {
						bs405 &= -9;
					}
					break;
				case 5:
					if(v405) {
						bs405 |= 4;
					} else {
						bs405 &= -5;
					}
					break;
				case 6:
					if(v405) {
						bs405 |= 2;
					} else {
						bs405 &= -3;
					}
					break;
				case 7:
					if(v405) {
						bs405 |= 1;
					} else {
						bs405 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs405;
			break;
		case 90:
			var this407 = 0;
			var bs406 = this407;
			var l406 = "*****".length;
			var _g1407 = 0;
			var _g507 = l406;
			while(_g1407 < _g507) {
				var i407 = _g1407++;
				var no406 = "*****".charCodeAt(i407);
				if(no406 == null) {
					break;
				}
				var v406;
				switch(no406) {
				case 32:
					v406 = false;
					break;
				case 42:
					v406 = true;
					break;
				case 48:
					v406 = false;
					break;
				case 49:
					v406 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i407)));
				}
				switch(i407 - (l406 - 8)) {
				case 0:
					if(v406) {
						bs406 |= 128;
					} else {
						bs406 &= -129;
					}
					break;
				case 1:
					if(v406) {
						bs406 |= 64;
					} else {
						bs406 &= -65;
					}
					break;
				case 2:
					if(v406) {
						bs406 |= 32;
					} else {
						bs406 &= -33;
					}
					break;
				case 3:
					if(v406) {
						bs406 |= 16;
					} else {
						bs406 &= -17;
					}
					break;
				case 4:
					if(v406) {
						bs406 |= 8;
					} else {
						bs406 &= -9;
					}
					break;
				case 5:
					if(v406) {
						bs406 |= 4;
					} else {
						bs406 &= -5;
					}
					break;
				case 6:
					if(v406) {
						bs406 |= 2;
					} else {
						bs406 &= -3;
					}
					break;
				case 7:
					if(v406) {
						bs406 |= 1;
					} else {
						bs406 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs406;
			var this408 = 0;
			var bs407 = this408;
			var l407 = "    *".length;
			var _g1408 = 0;
			var _g508 = l407;
			while(_g1408 < _g508) {
				var i408 = _g1408++;
				var no407 = "    *".charCodeAt(i408);
				if(no407 == null) {
					break;
				}
				var v407;
				switch(no407) {
				case 32:
					v407 = false;
					break;
				case 42:
					v407 = true;
					break;
				case 48:
					v407 = false;
					break;
				case 49:
					v407 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i408)));
				}
				switch(i408 - (l407 - 8)) {
				case 0:
					if(v407) {
						bs407 |= 128;
					} else {
						bs407 &= -129;
					}
					break;
				case 1:
					if(v407) {
						bs407 |= 64;
					} else {
						bs407 &= -65;
					}
					break;
				case 2:
					if(v407) {
						bs407 |= 32;
					} else {
						bs407 &= -33;
					}
					break;
				case 3:
					if(v407) {
						bs407 |= 16;
					} else {
						bs407 &= -17;
					}
					break;
				case 4:
					if(v407) {
						bs407 |= 8;
					} else {
						bs407 &= -9;
					}
					break;
				case 5:
					if(v407) {
						bs407 |= 4;
					} else {
						bs407 &= -5;
					}
					break;
				case 6:
					if(v407) {
						bs407 |= 2;
					} else {
						bs407 &= -3;
					}
					break;
				case 7:
					if(v407) {
						bs407 |= 1;
					} else {
						bs407 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs407;
			var this409 = 0;
			var bs408 = this409;
			var l408 = "   * ".length;
			var _g1409 = 0;
			var _g509 = l408;
			while(_g1409 < _g509) {
				var i409 = _g1409++;
				var no408 = "   * ".charCodeAt(i409);
				if(no408 == null) {
					break;
				}
				var v408;
				switch(no408) {
				case 32:
					v408 = false;
					break;
				case 42:
					v408 = true;
					break;
				case 48:
					v408 = false;
					break;
				case 49:
					v408 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i409)));
				}
				switch(i409 - (l408 - 8)) {
				case 0:
					if(v408) {
						bs408 |= 128;
					} else {
						bs408 &= -129;
					}
					break;
				case 1:
					if(v408) {
						bs408 |= 64;
					} else {
						bs408 &= -65;
					}
					break;
				case 2:
					if(v408) {
						bs408 |= 32;
					} else {
						bs408 &= -33;
					}
					break;
				case 3:
					if(v408) {
						bs408 |= 16;
					} else {
						bs408 &= -17;
					}
					break;
				case 4:
					if(v408) {
						bs408 |= 8;
					} else {
						bs408 &= -9;
					}
					break;
				case 5:
					if(v408) {
						bs408 |= 4;
					} else {
						bs408 &= -5;
					}
					break;
				case 6:
					if(v408) {
						bs408 |= 2;
					} else {
						bs408 &= -3;
					}
					break;
				case 7:
					if(v408) {
						bs408 |= 1;
					} else {
						bs408 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs408;
			var this410 = 0;
			var bs409 = this410;
			var l409 = "  *  ".length;
			var _g1410 = 0;
			var _g510 = l409;
			while(_g1410 < _g510) {
				var i410 = _g1410++;
				var no409 = "  *  ".charCodeAt(i410);
				if(no409 == null) {
					break;
				}
				var v409;
				switch(no409) {
				case 32:
					v409 = false;
					break;
				case 42:
					v409 = true;
					break;
				case 48:
					v409 = false;
					break;
				case 49:
					v409 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i410)));
				}
				switch(i410 - (l409 - 8)) {
				case 0:
					if(v409) {
						bs409 |= 128;
					} else {
						bs409 &= -129;
					}
					break;
				case 1:
					if(v409) {
						bs409 |= 64;
					} else {
						bs409 &= -65;
					}
					break;
				case 2:
					if(v409) {
						bs409 |= 32;
					} else {
						bs409 &= -33;
					}
					break;
				case 3:
					if(v409) {
						bs409 |= 16;
					} else {
						bs409 &= -17;
					}
					break;
				case 4:
					if(v409) {
						bs409 |= 8;
					} else {
						bs409 &= -9;
					}
					break;
				case 5:
					if(v409) {
						bs409 |= 4;
					} else {
						bs409 &= -5;
					}
					break;
				case 6:
					if(v409) {
						bs409 |= 2;
					} else {
						bs409 &= -3;
					}
					break;
				case 7:
					if(v409) {
						bs409 |= 1;
					} else {
						bs409 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs409;
			var this411 = 0;
			var bs410 = this411;
			var l410 = " *   ".length;
			var _g1411 = 0;
			var _g511 = l410;
			while(_g1411 < _g511) {
				var i411 = _g1411++;
				var no410 = " *   ".charCodeAt(i411);
				if(no410 == null) {
					break;
				}
				var v410;
				switch(no410) {
				case 32:
					v410 = false;
					break;
				case 42:
					v410 = true;
					break;
				case 48:
					v410 = false;
					break;
				case 49:
					v410 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i411)));
				}
				switch(i411 - (l410 - 8)) {
				case 0:
					if(v410) {
						bs410 |= 128;
					} else {
						bs410 &= -129;
					}
					break;
				case 1:
					if(v410) {
						bs410 |= 64;
					} else {
						bs410 &= -65;
					}
					break;
				case 2:
					if(v410) {
						bs410 |= 32;
					} else {
						bs410 &= -33;
					}
					break;
				case 3:
					if(v410) {
						bs410 |= 16;
					} else {
						bs410 &= -17;
					}
					break;
				case 4:
					if(v410) {
						bs410 |= 8;
					} else {
						bs410 &= -9;
					}
					break;
				case 5:
					if(v410) {
						bs410 |= 4;
					} else {
						bs410 &= -5;
					}
					break;
				case 6:
					if(v410) {
						bs410 |= 2;
					} else {
						bs410 &= -3;
					}
					break;
				case 7:
					if(v410) {
						bs410 |= 1;
					} else {
						bs410 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs410;
			var this412 = 0;
			var bs411 = this412;
			var l411 = "*    ".length;
			var _g1412 = 0;
			var _g512 = l411;
			while(_g1412 < _g512) {
				var i412 = _g1412++;
				var no411 = "*    ".charCodeAt(i412);
				if(no411 == null) {
					break;
				}
				var v411;
				switch(no411) {
				case 32:
					v411 = false;
					break;
				case 42:
					v411 = true;
					break;
				case 48:
					v411 = false;
					break;
				case 49:
					v411 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i412)));
				}
				switch(i412 - (l411 - 8)) {
				case 0:
					if(v411) {
						bs411 |= 128;
					} else {
						bs411 &= -129;
					}
					break;
				case 1:
					if(v411) {
						bs411 |= 64;
					} else {
						bs411 &= -65;
					}
					break;
				case 2:
					if(v411) {
						bs411 |= 32;
					} else {
						bs411 &= -33;
					}
					break;
				case 3:
					if(v411) {
						bs411 |= 16;
					} else {
						bs411 &= -17;
					}
					break;
				case 4:
					if(v411) {
						bs411 |= 8;
					} else {
						bs411 &= -9;
					}
					break;
				case 5:
					if(v411) {
						bs411 |= 4;
					} else {
						bs411 &= -5;
					}
					break;
				case 6:
					if(v411) {
						bs411 |= 2;
					} else {
						bs411 &= -3;
					}
					break;
				case 7:
					if(v411) {
						bs411 |= 1;
					} else {
						bs411 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs411;
			var this413 = 0;
			var bs412 = this413;
			var l412 = "*****".length;
			var _g1413 = 0;
			var _g513 = l412;
			while(_g1413 < _g513) {
				var i413 = _g1413++;
				var no412 = "*****".charCodeAt(i413);
				if(no412 == null) {
					break;
				}
				var v412;
				switch(no412) {
				case 32:
					v412 = false;
					break;
				case 42:
					v412 = true;
					break;
				case 48:
					v412 = false;
					break;
				case 49:
					v412 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i413)));
				}
				switch(i413 - (l412 - 8)) {
				case 0:
					if(v412) {
						bs412 |= 128;
					} else {
						bs412 &= -129;
					}
					break;
				case 1:
					if(v412) {
						bs412 |= 64;
					} else {
						bs412 &= -65;
					}
					break;
				case 2:
					if(v412) {
						bs412 |= 32;
					} else {
						bs412 &= -33;
					}
					break;
				case 3:
					if(v412) {
						bs412 |= 16;
					} else {
						bs412 &= -17;
					}
					break;
				case 4:
					if(v412) {
						bs412 |= 8;
					} else {
						bs412 &= -9;
					}
					break;
				case 5:
					if(v412) {
						bs412 |= 4;
					} else {
						bs412 &= -5;
					}
					break;
				case 6:
					if(v412) {
						bs412 |= 2;
					} else {
						bs412 &= -3;
					}
					break;
				case 7:
					if(v412) {
						bs412 |= 1;
					} else {
						bs412 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs412;
			break;
		case 91:
			var this414 = 0;
			var bs413 = this414;
			var l413 = " *** ".length;
			var _g1414 = 0;
			var _g514 = l413;
			while(_g1414 < _g514) {
				var i414 = _g1414++;
				var no413 = " *** ".charCodeAt(i414);
				if(no413 == null) {
					break;
				}
				var v413;
				switch(no413) {
				case 32:
					v413 = false;
					break;
				case 42:
					v413 = true;
					break;
				case 48:
					v413 = false;
					break;
				case 49:
					v413 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i414)));
				}
				switch(i414 - (l413 - 8)) {
				case 0:
					if(v413) {
						bs413 |= 128;
					} else {
						bs413 &= -129;
					}
					break;
				case 1:
					if(v413) {
						bs413 |= 64;
					} else {
						bs413 &= -65;
					}
					break;
				case 2:
					if(v413) {
						bs413 |= 32;
					} else {
						bs413 &= -33;
					}
					break;
				case 3:
					if(v413) {
						bs413 |= 16;
					} else {
						bs413 &= -17;
					}
					break;
				case 4:
					if(v413) {
						bs413 |= 8;
					} else {
						bs413 &= -9;
					}
					break;
				case 5:
					if(v413) {
						bs413 |= 4;
					} else {
						bs413 &= -5;
					}
					break;
				case 6:
					if(v413) {
						bs413 |= 2;
					} else {
						bs413 &= -3;
					}
					break;
				case 7:
					if(v413) {
						bs413 |= 1;
					} else {
						bs413 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs413;
			var this415 = 0;
			var bs414 = this415;
			var l414 = " *   ".length;
			var _g1415 = 0;
			var _g515 = l414;
			while(_g1415 < _g515) {
				var i415 = _g1415++;
				var no414 = " *   ".charCodeAt(i415);
				if(no414 == null) {
					break;
				}
				var v414;
				switch(no414) {
				case 32:
					v414 = false;
					break;
				case 42:
					v414 = true;
					break;
				case 48:
					v414 = false;
					break;
				case 49:
					v414 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i415)));
				}
				switch(i415 - (l414 - 8)) {
				case 0:
					if(v414) {
						bs414 |= 128;
					} else {
						bs414 &= -129;
					}
					break;
				case 1:
					if(v414) {
						bs414 |= 64;
					} else {
						bs414 &= -65;
					}
					break;
				case 2:
					if(v414) {
						bs414 |= 32;
					} else {
						bs414 &= -33;
					}
					break;
				case 3:
					if(v414) {
						bs414 |= 16;
					} else {
						bs414 &= -17;
					}
					break;
				case 4:
					if(v414) {
						bs414 |= 8;
					} else {
						bs414 &= -9;
					}
					break;
				case 5:
					if(v414) {
						bs414 |= 4;
					} else {
						bs414 &= -5;
					}
					break;
				case 6:
					if(v414) {
						bs414 |= 2;
					} else {
						bs414 &= -3;
					}
					break;
				case 7:
					if(v414) {
						bs414 |= 1;
					} else {
						bs414 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs414;
			var this416 = 0;
			var bs415 = this416;
			var l415 = " *   ".length;
			var _g1416 = 0;
			var _g516 = l415;
			while(_g1416 < _g516) {
				var i416 = _g1416++;
				var no415 = " *   ".charCodeAt(i416);
				if(no415 == null) {
					break;
				}
				var v415;
				switch(no415) {
				case 32:
					v415 = false;
					break;
				case 42:
					v415 = true;
					break;
				case 48:
					v415 = false;
					break;
				case 49:
					v415 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i416)));
				}
				switch(i416 - (l415 - 8)) {
				case 0:
					if(v415) {
						bs415 |= 128;
					} else {
						bs415 &= -129;
					}
					break;
				case 1:
					if(v415) {
						bs415 |= 64;
					} else {
						bs415 &= -65;
					}
					break;
				case 2:
					if(v415) {
						bs415 |= 32;
					} else {
						bs415 &= -33;
					}
					break;
				case 3:
					if(v415) {
						bs415 |= 16;
					} else {
						bs415 &= -17;
					}
					break;
				case 4:
					if(v415) {
						bs415 |= 8;
					} else {
						bs415 &= -9;
					}
					break;
				case 5:
					if(v415) {
						bs415 |= 4;
					} else {
						bs415 &= -5;
					}
					break;
				case 6:
					if(v415) {
						bs415 |= 2;
					} else {
						bs415 &= -3;
					}
					break;
				case 7:
					if(v415) {
						bs415 |= 1;
					} else {
						bs415 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs415;
			var this417 = 0;
			var bs416 = this417;
			var l416 = " *   ".length;
			var _g1417 = 0;
			var _g517 = l416;
			while(_g1417 < _g517) {
				var i417 = _g1417++;
				var no416 = " *   ".charCodeAt(i417);
				if(no416 == null) {
					break;
				}
				var v416;
				switch(no416) {
				case 32:
					v416 = false;
					break;
				case 42:
					v416 = true;
					break;
				case 48:
					v416 = false;
					break;
				case 49:
					v416 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i417)));
				}
				switch(i417 - (l416 - 8)) {
				case 0:
					if(v416) {
						bs416 |= 128;
					} else {
						bs416 &= -129;
					}
					break;
				case 1:
					if(v416) {
						bs416 |= 64;
					} else {
						bs416 &= -65;
					}
					break;
				case 2:
					if(v416) {
						bs416 |= 32;
					} else {
						bs416 &= -33;
					}
					break;
				case 3:
					if(v416) {
						bs416 |= 16;
					} else {
						bs416 &= -17;
					}
					break;
				case 4:
					if(v416) {
						bs416 |= 8;
					} else {
						bs416 &= -9;
					}
					break;
				case 5:
					if(v416) {
						bs416 |= 4;
					} else {
						bs416 &= -5;
					}
					break;
				case 6:
					if(v416) {
						bs416 |= 2;
					} else {
						bs416 &= -3;
					}
					break;
				case 7:
					if(v416) {
						bs416 |= 1;
					} else {
						bs416 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs416;
			var this418 = 0;
			var bs417 = this418;
			var l417 = " *   ".length;
			var _g1418 = 0;
			var _g518 = l417;
			while(_g1418 < _g518) {
				var i418 = _g1418++;
				var no417 = " *   ".charCodeAt(i418);
				if(no417 == null) {
					break;
				}
				var v417;
				switch(no417) {
				case 32:
					v417 = false;
					break;
				case 42:
					v417 = true;
					break;
				case 48:
					v417 = false;
					break;
				case 49:
					v417 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i418)));
				}
				switch(i418 - (l417 - 8)) {
				case 0:
					if(v417) {
						bs417 |= 128;
					} else {
						bs417 &= -129;
					}
					break;
				case 1:
					if(v417) {
						bs417 |= 64;
					} else {
						bs417 &= -65;
					}
					break;
				case 2:
					if(v417) {
						bs417 |= 32;
					} else {
						bs417 &= -33;
					}
					break;
				case 3:
					if(v417) {
						bs417 |= 16;
					} else {
						bs417 &= -17;
					}
					break;
				case 4:
					if(v417) {
						bs417 |= 8;
					} else {
						bs417 &= -9;
					}
					break;
				case 5:
					if(v417) {
						bs417 |= 4;
					} else {
						bs417 &= -5;
					}
					break;
				case 6:
					if(v417) {
						bs417 |= 2;
					} else {
						bs417 &= -3;
					}
					break;
				case 7:
					if(v417) {
						bs417 |= 1;
					} else {
						bs417 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs417;
			var this419 = 0;
			var bs418 = this419;
			var l418 = " *   ".length;
			var _g1419 = 0;
			var _g519 = l418;
			while(_g1419 < _g519) {
				var i419 = _g1419++;
				var no418 = " *   ".charCodeAt(i419);
				if(no418 == null) {
					break;
				}
				var v418;
				switch(no418) {
				case 32:
					v418 = false;
					break;
				case 42:
					v418 = true;
					break;
				case 48:
					v418 = false;
					break;
				case 49:
					v418 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i419)));
				}
				switch(i419 - (l418 - 8)) {
				case 0:
					if(v418) {
						bs418 |= 128;
					} else {
						bs418 &= -129;
					}
					break;
				case 1:
					if(v418) {
						bs418 |= 64;
					} else {
						bs418 &= -65;
					}
					break;
				case 2:
					if(v418) {
						bs418 |= 32;
					} else {
						bs418 &= -33;
					}
					break;
				case 3:
					if(v418) {
						bs418 |= 16;
					} else {
						bs418 &= -17;
					}
					break;
				case 4:
					if(v418) {
						bs418 |= 8;
					} else {
						bs418 &= -9;
					}
					break;
				case 5:
					if(v418) {
						bs418 |= 4;
					} else {
						bs418 &= -5;
					}
					break;
				case 6:
					if(v418) {
						bs418 |= 2;
					} else {
						bs418 &= -3;
					}
					break;
				case 7:
					if(v418) {
						bs418 |= 1;
					} else {
						bs418 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs418;
			var this420 = 0;
			var bs419 = this420;
			var l419 = " *** ".length;
			var _g1420 = 0;
			var _g520 = l419;
			while(_g1420 < _g520) {
				var i420 = _g1420++;
				var no419 = " *** ".charCodeAt(i420);
				if(no419 == null) {
					break;
				}
				var v419;
				switch(no419) {
				case 32:
					v419 = false;
					break;
				case 42:
					v419 = true;
					break;
				case 48:
					v419 = false;
					break;
				case 49:
					v419 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i420)));
				}
				switch(i420 - (l419 - 8)) {
				case 0:
					if(v419) {
						bs419 |= 128;
					} else {
						bs419 &= -129;
					}
					break;
				case 1:
					if(v419) {
						bs419 |= 64;
					} else {
						bs419 &= -65;
					}
					break;
				case 2:
					if(v419) {
						bs419 |= 32;
					} else {
						bs419 &= -33;
					}
					break;
				case 3:
					if(v419) {
						bs419 |= 16;
					} else {
						bs419 &= -17;
					}
					break;
				case 4:
					if(v419) {
						bs419 |= 8;
					} else {
						bs419 &= -9;
					}
					break;
				case 5:
					if(v419) {
						bs419 |= 4;
					} else {
						bs419 &= -5;
					}
					break;
				case 6:
					if(v419) {
						bs419 |= 2;
					} else {
						bs419 &= -3;
					}
					break;
				case 7:
					if(v419) {
						bs419 |= 1;
					} else {
						bs419 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs419;
			break;
		case 92:
			var this421 = 0;
			var bs420 = this421;
			var l420 = "*    ".length;
			var _g1421 = 0;
			var _g521 = l420;
			while(_g1421 < _g521) {
				var i421 = _g1421++;
				var no420 = "*    ".charCodeAt(i421);
				if(no420 == null) {
					break;
				}
				var v420;
				switch(no420) {
				case 32:
					v420 = false;
					break;
				case 42:
					v420 = true;
					break;
				case 48:
					v420 = false;
					break;
				case 49:
					v420 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i421)));
				}
				switch(i421 - (l420 - 8)) {
				case 0:
					if(v420) {
						bs420 |= 128;
					} else {
						bs420 &= -129;
					}
					break;
				case 1:
					if(v420) {
						bs420 |= 64;
					} else {
						bs420 &= -65;
					}
					break;
				case 2:
					if(v420) {
						bs420 |= 32;
					} else {
						bs420 &= -33;
					}
					break;
				case 3:
					if(v420) {
						bs420 |= 16;
					} else {
						bs420 &= -17;
					}
					break;
				case 4:
					if(v420) {
						bs420 |= 8;
					} else {
						bs420 &= -9;
					}
					break;
				case 5:
					if(v420) {
						bs420 |= 4;
					} else {
						bs420 &= -5;
					}
					break;
				case 6:
					if(v420) {
						bs420 |= 2;
					} else {
						bs420 &= -3;
					}
					break;
				case 7:
					if(v420) {
						bs420 |= 1;
					} else {
						bs420 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs420;
			var this422 = 0;
			var bs421 = this422;
			var l421 = " *   ".length;
			var _g1422 = 0;
			var _g522 = l421;
			while(_g1422 < _g522) {
				var i422 = _g1422++;
				var no421 = " *   ".charCodeAt(i422);
				if(no421 == null) {
					break;
				}
				var v421;
				switch(no421) {
				case 32:
					v421 = false;
					break;
				case 42:
					v421 = true;
					break;
				case 48:
					v421 = false;
					break;
				case 49:
					v421 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i422)));
				}
				switch(i422 - (l421 - 8)) {
				case 0:
					if(v421) {
						bs421 |= 128;
					} else {
						bs421 &= -129;
					}
					break;
				case 1:
					if(v421) {
						bs421 |= 64;
					} else {
						bs421 &= -65;
					}
					break;
				case 2:
					if(v421) {
						bs421 |= 32;
					} else {
						bs421 &= -33;
					}
					break;
				case 3:
					if(v421) {
						bs421 |= 16;
					} else {
						bs421 &= -17;
					}
					break;
				case 4:
					if(v421) {
						bs421 |= 8;
					} else {
						bs421 &= -9;
					}
					break;
				case 5:
					if(v421) {
						bs421 |= 4;
					} else {
						bs421 &= -5;
					}
					break;
				case 6:
					if(v421) {
						bs421 |= 2;
					} else {
						bs421 &= -3;
					}
					break;
				case 7:
					if(v421) {
						bs421 |= 1;
					} else {
						bs421 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs421;
			var this423 = 0;
			var bs422 = this423;
			var l422 = "  *  ".length;
			var _g1423 = 0;
			var _g523 = l422;
			while(_g1423 < _g523) {
				var i423 = _g1423++;
				var no422 = "  *  ".charCodeAt(i423);
				if(no422 == null) {
					break;
				}
				var v422;
				switch(no422) {
				case 32:
					v422 = false;
					break;
				case 42:
					v422 = true;
					break;
				case 48:
					v422 = false;
					break;
				case 49:
					v422 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i423)));
				}
				switch(i423 - (l422 - 8)) {
				case 0:
					if(v422) {
						bs422 |= 128;
					} else {
						bs422 &= -129;
					}
					break;
				case 1:
					if(v422) {
						bs422 |= 64;
					} else {
						bs422 &= -65;
					}
					break;
				case 2:
					if(v422) {
						bs422 |= 32;
					} else {
						bs422 &= -33;
					}
					break;
				case 3:
					if(v422) {
						bs422 |= 16;
					} else {
						bs422 &= -17;
					}
					break;
				case 4:
					if(v422) {
						bs422 |= 8;
					} else {
						bs422 &= -9;
					}
					break;
				case 5:
					if(v422) {
						bs422 |= 4;
					} else {
						bs422 &= -5;
					}
					break;
				case 6:
					if(v422) {
						bs422 |= 2;
					} else {
						bs422 &= -3;
					}
					break;
				case 7:
					if(v422) {
						bs422 |= 1;
					} else {
						bs422 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs422;
			var this424 = 0;
			var bs423 = this424;
			var l423 = "  *  ".length;
			var _g1424 = 0;
			var _g524 = l423;
			while(_g1424 < _g524) {
				var i424 = _g1424++;
				var no423 = "  *  ".charCodeAt(i424);
				if(no423 == null) {
					break;
				}
				var v423;
				switch(no423) {
				case 32:
					v423 = false;
					break;
				case 42:
					v423 = true;
					break;
				case 48:
					v423 = false;
					break;
				case 49:
					v423 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i424)));
				}
				switch(i424 - (l423 - 8)) {
				case 0:
					if(v423) {
						bs423 |= 128;
					} else {
						bs423 &= -129;
					}
					break;
				case 1:
					if(v423) {
						bs423 |= 64;
					} else {
						bs423 &= -65;
					}
					break;
				case 2:
					if(v423) {
						bs423 |= 32;
					} else {
						bs423 &= -33;
					}
					break;
				case 3:
					if(v423) {
						bs423 |= 16;
					} else {
						bs423 &= -17;
					}
					break;
				case 4:
					if(v423) {
						bs423 |= 8;
					} else {
						bs423 &= -9;
					}
					break;
				case 5:
					if(v423) {
						bs423 |= 4;
					} else {
						bs423 &= -5;
					}
					break;
				case 6:
					if(v423) {
						bs423 |= 2;
					} else {
						bs423 &= -3;
					}
					break;
				case 7:
					if(v423) {
						bs423 |= 1;
					} else {
						bs423 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs423;
			var this425 = 0;
			var bs424 = this425;
			var l424 = "   * ".length;
			var _g1425 = 0;
			var _g525 = l424;
			while(_g1425 < _g525) {
				var i425 = _g1425++;
				var no424 = "   * ".charCodeAt(i425);
				if(no424 == null) {
					break;
				}
				var v424;
				switch(no424) {
				case 32:
					v424 = false;
					break;
				case 42:
					v424 = true;
					break;
				case 48:
					v424 = false;
					break;
				case 49:
					v424 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i425)));
				}
				switch(i425 - (l424 - 8)) {
				case 0:
					if(v424) {
						bs424 |= 128;
					} else {
						bs424 &= -129;
					}
					break;
				case 1:
					if(v424) {
						bs424 |= 64;
					} else {
						bs424 &= -65;
					}
					break;
				case 2:
					if(v424) {
						bs424 |= 32;
					} else {
						bs424 &= -33;
					}
					break;
				case 3:
					if(v424) {
						bs424 |= 16;
					} else {
						bs424 &= -17;
					}
					break;
				case 4:
					if(v424) {
						bs424 |= 8;
					} else {
						bs424 &= -9;
					}
					break;
				case 5:
					if(v424) {
						bs424 |= 4;
					} else {
						bs424 &= -5;
					}
					break;
				case 6:
					if(v424) {
						bs424 |= 2;
					} else {
						bs424 &= -3;
					}
					break;
				case 7:
					if(v424) {
						bs424 |= 1;
					} else {
						bs424 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs424;
			var this426 = 0;
			var bs425 = this426;
			var l425 = "   * ".length;
			var _g1426 = 0;
			var _g526 = l425;
			while(_g1426 < _g526) {
				var i426 = _g1426++;
				var no425 = "   * ".charCodeAt(i426);
				if(no425 == null) {
					break;
				}
				var v425;
				switch(no425) {
				case 32:
					v425 = false;
					break;
				case 42:
					v425 = true;
					break;
				case 48:
					v425 = false;
					break;
				case 49:
					v425 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i426)));
				}
				switch(i426 - (l425 - 8)) {
				case 0:
					if(v425) {
						bs425 |= 128;
					} else {
						bs425 &= -129;
					}
					break;
				case 1:
					if(v425) {
						bs425 |= 64;
					} else {
						bs425 &= -65;
					}
					break;
				case 2:
					if(v425) {
						bs425 |= 32;
					} else {
						bs425 &= -33;
					}
					break;
				case 3:
					if(v425) {
						bs425 |= 16;
					} else {
						bs425 &= -17;
					}
					break;
				case 4:
					if(v425) {
						bs425 |= 8;
					} else {
						bs425 &= -9;
					}
					break;
				case 5:
					if(v425) {
						bs425 |= 4;
					} else {
						bs425 &= -5;
					}
					break;
				case 6:
					if(v425) {
						bs425 |= 2;
					} else {
						bs425 &= -3;
					}
					break;
				case 7:
					if(v425) {
						bs425 |= 1;
					} else {
						bs425 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs425;
			var this427 = 0;
			var bs426 = this427;
			var l426 = "    *".length;
			var _g1427 = 0;
			var _g527 = l426;
			while(_g1427 < _g527) {
				var i427 = _g1427++;
				var no426 = "    *".charCodeAt(i427);
				if(no426 == null) {
					break;
				}
				var v426;
				switch(no426) {
				case 32:
					v426 = false;
					break;
				case 42:
					v426 = true;
					break;
				case 48:
					v426 = false;
					break;
				case 49:
					v426 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i427)));
				}
				switch(i427 - (l426 - 8)) {
				case 0:
					if(v426) {
						bs426 |= 128;
					} else {
						bs426 &= -129;
					}
					break;
				case 1:
					if(v426) {
						bs426 |= 64;
					} else {
						bs426 &= -65;
					}
					break;
				case 2:
					if(v426) {
						bs426 |= 32;
					} else {
						bs426 &= -33;
					}
					break;
				case 3:
					if(v426) {
						bs426 |= 16;
					} else {
						bs426 &= -17;
					}
					break;
				case 4:
					if(v426) {
						bs426 |= 8;
					} else {
						bs426 &= -9;
					}
					break;
				case 5:
					if(v426) {
						bs426 |= 4;
					} else {
						bs426 &= -5;
					}
					break;
				case 6:
					if(v426) {
						bs426 |= 2;
					} else {
						bs426 &= -3;
					}
					break;
				case 7:
					if(v426) {
						bs426 |= 1;
					} else {
						bs426 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs426;
			break;
		case 93:
			var this428 = 0;
			var bs427 = this428;
			var l427 = " *** ".length;
			var _g1428 = 0;
			var _g528 = l427;
			while(_g1428 < _g528) {
				var i428 = _g1428++;
				var no427 = " *** ".charCodeAt(i428);
				if(no427 == null) {
					break;
				}
				var v427;
				switch(no427) {
				case 32:
					v427 = false;
					break;
				case 42:
					v427 = true;
					break;
				case 48:
					v427 = false;
					break;
				case 49:
					v427 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i428)));
				}
				switch(i428 - (l427 - 8)) {
				case 0:
					if(v427) {
						bs427 |= 128;
					} else {
						bs427 &= -129;
					}
					break;
				case 1:
					if(v427) {
						bs427 |= 64;
					} else {
						bs427 &= -65;
					}
					break;
				case 2:
					if(v427) {
						bs427 |= 32;
					} else {
						bs427 &= -33;
					}
					break;
				case 3:
					if(v427) {
						bs427 |= 16;
					} else {
						bs427 &= -17;
					}
					break;
				case 4:
					if(v427) {
						bs427 |= 8;
					} else {
						bs427 &= -9;
					}
					break;
				case 5:
					if(v427) {
						bs427 |= 4;
					} else {
						bs427 &= -5;
					}
					break;
				case 6:
					if(v427) {
						bs427 |= 2;
					} else {
						bs427 &= -3;
					}
					break;
				case 7:
					if(v427) {
						bs427 |= 1;
					} else {
						bs427 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs427;
			var this429 = 0;
			var bs428 = this429;
			var l428 = "   * ".length;
			var _g1429 = 0;
			var _g529 = l428;
			while(_g1429 < _g529) {
				var i429 = _g1429++;
				var no428 = "   * ".charCodeAt(i429);
				if(no428 == null) {
					break;
				}
				var v428;
				switch(no428) {
				case 32:
					v428 = false;
					break;
				case 42:
					v428 = true;
					break;
				case 48:
					v428 = false;
					break;
				case 49:
					v428 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i429)));
				}
				switch(i429 - (l428 - 8)) {
				case 0:
					if(v428) {
						bs428 |= 128;
					} else {
						bs428 &= -129;
					}
					break;
				case 1:
					if(v428) {
						bs428 |= 64;
					} else {
						bs428 &= -65;
					}
					break;
				case 2:
					if(v428) {
						bs428 |= 32;
					} else {
						bs428 &= -33;
					}
					break;
				case 3:
					if(v428) {
						bs428 |= 16;
					} else {
						bs428 &= -17;
					}
					break;
				case 4:
					if(v428) {
						bs428 |= 8;
					} else {
						bs428 &= -9;
					}
					break;
				case 5:
					if(v428) {
						bs428 |= 4;
					} else {
						bs428 &= -5;
					}
					break;
				case 6:
					if(v428) {
						bs428 |= 2;
					} else {
						bs428 &= -3;
					}
					break;
				case 7:
					if(v428) {
						bs428 |= 1;
					} else {
						bs428 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs428;
			var this430 = 0;
			var bs429 = this430;
			var l429 = "   * ".length;
			var _g1430 = 0;
			var _g530 = l429;
			while(_g1430 < _g530) {
				var i430 = _g1430++;
				var no429 = "   * ".charCodeAt(i430);
				if(no429 == null) {
					break;
				}
				var v429;
				switch(no429) {
				case 32:
					v429 = false;
					break;
				case 42:
					v429 = true;
					break;
				case 48:
					v429 = false;
					break;
				case 49:
					v429 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i430)));
				}
				switch(i430 - (l429 - 8)) {
				case 0:
					if(v429) {
						bs429 |= 128;
					} else {
						bs429 &= -129;
					}
					break;
				case 1:
					if(v429) {
						bs429 |= 64;
					} else {
						bs429 &= -65;
					}
					break;
				case 2:
					if(v429) {
						bs429 |= 32;
					} else {
						bs429 &= -33;
					}
					break;
				case 3:
					if(v429) {
						bs429 |= 16;
					} else {
						bs429 &= -17;
					}
					break;
				case 4:
					if(v429) {
						bs429 |= 8;
					} else {
						bs429 &= -9;
					}
					break;
				case 5:
					if(v429) {
						bs429 |= 4;
					} else {
						bs429 &= -5;
					}
					break;
				case 6:
					if(v429) {
						bs429 |= 2;
					} else {
						bs429 &= -3;
					}
					break;
				case 7:
					if(v429) {
						bs429 |= 1;
					} else {
						bs429 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs429;
			var this431 = 0;
			var bs430 = this431;
			var l430 = "   * ".length;
			var _g1431 = 0;
			var _g531 = l430;
			while(_g1431 < _g531) {
				var i431 = _g1431++;
				var no430 = "   * ".charCodeAt(i431);
				if(no430 == null) {
					break;
				}
				var v430;
				switch(no430) {
				case 32:
					v430 = false;
					break;
				case 42:
					v430 = true;
					break;
				case 48:
					v430 = false;
					break;
				case 49:
					v430 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i431)));
				}
				switch(i431 - (l430 - 8)) {
				case 0:
					if(v430) {
						bs430 |= 128;
					} else {
						bs430 &= -129;
					}
					break;
				case 1:
					if(v430) {
						bs430 |= 64;
					} else {
						bs430 &= -65;
					}
					break;
				case 2:
					if(v430) {
						bs430 |= 32;
					} else {
						bs430 &= -33;
					}
					break;
				case 3:
					if(v430) {
						bs430 |= 16;
					} else {
						bs430 &= -17;
					}
					break;
				case 4:
					if(v430) {
						bs430 |= 8;
					} else {
						bs430 &= -9;
					}
					break;
				case 5:
					if(v430) {
						bs430 |= 4;
					} else {
						bs430 &= -5;
					}
					break;
				case 6:
					if(v430) {
						bs430 |= 2;
					} else {
						bs430 &= -3;
					}
					break;
				case 7:
					if(v430) {
						bs430 |= 1;
					} else {
						bs430 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs430;
			var this432 = 0;
			var bs431 = this432;
			var l431 = "   * ".length;
			var _g1432 = 0;
			var _g532 = l431;
			while(_g1432 < _g532) {
				var i432 = _g1432++;
				var no431 = "   * ".charCodeAt(i432);
				if(no431 == null) {
					break;
				}
				var v431;
				switch(no431) {
				case 32:
					v431 = false;
					break;
				case 42:
					v431 = true;
					break;
				case 48:
					v431 = false;
					break;
				case 49:
					v431 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i432)));
				}
				switch(i432 - (l431 - 8)) {
				case 0:
					if(v431) {
						bs431 |= 128;
					} else {
						bs431 &= -129;
					}
					break;
				case 1:
					if(v431) {
						bs431 |= 64;
					} else {
						bs431 &= -65;
					}
					break;
				case 2:
					if(v431) {
						bs431 |= 32;
					} else {
						bs431 &= -33;
					}
					break;
				case 3:
					if(v431) {
						bs431 |= 16;
					} else {
						bs431 &= -17;
					}
					break;
				case 4:
					if(v431) {
						bs431 |= 8;
					} else {
						bs431 &= -9;
					}
					break;
				case 5:
					if(v431) {
						bs431 |= 4;
					} else {
						bs431 &= -5;
					}
					break;
				case 6:
					if(v431) {
						bs431 |= 2;
					} else {
						bs431 &= -3;
					}
					break;
				case 7:
					if(v431) {
						bs431 |= 1;
					} else {
						bs431 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs431;
			var this433 = 0;
			var bs432 = this433;
			var l432 = "   * ".length;
			var _g1433 = 0;
			var _g533 = l432;
			while(_g1433 < _g533) {
				var i433 = _g1433++;
				var no432 = "   * ".charCodeAt(i433);
				if(no432 == null) {
					break;
				}
				var v432;
				switch(no432) {
				case 32:
					v432 = false;
					break;
				case 42:
					v432 = true;
					break;
				case 48:
					v432 = false;
					break;
				case 49:
					v432 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i433)));
				}
				switch(i433 - (l432 - 8)) {
				case 0:
					if(v432) {
						bs432 |= 128;
					} else {
						bs432 &= -129;
					}
					break;
				case 1:
					if(v432) {
						bs432 |= 64;
					} else {
						bs432 &= -65;
					}
					break;
				case 2:
					if(v432) {
						bs432 |= 32;
					} else {
						bs432 &= -33;
					}
					break;
				case 3:
					if(v432) {
						bs432 |= 16;
					} else {
						bs432 &= -17;
					}
					break;
				case 4:
					if(v432) {
						bs432 |= 8;
					} else {
						bs432 &= -9;
					}
					break;
				case 5:
					if(v432) {
						bs432 |= 4;
					} else {
						bs432 &= -5;
					}
					break;
				case 6:
					if(v432) {
						bs432 |= 2;
					} else {
						bs432 &= -3;
					}
					break;
				case 7:
					if(v432) {
						bs432 |= 1;
					} else {
						bs432 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs432;
			var this434 = 0;
			var bs433 = this434;
			var l433 = " *** ".length;
			var _g1434 = 0;
			var _g534 = l433;
			while(_g1434 < _g534) {
				var i434 = _g1434++;
				var no433 = " *** ".charCodeAt(i434);
				if(no433 == null) {
					break;
				}
				var v433;
				switch(no433) {
				case 32:
					v433 = false;
					break;
				case 42:
					v433 = true;
					break;
				case 48:
					v433 = false;
					break;
				case 49:
					v433 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i434)));
				}
				switch(i434 - (l433 - 8)) {
				case 0:
					if(v433) {
						bs433 |= 128;
					} else {
						bs433 &= -129;
					}
					break;
				case 1:
					if(v433) {
						bs433 |= 64;
					} else {
						bs433 &= -65;
					}
					break;
				case 2:
					if(v433) {
						bs433 |= 32;
					} else {
						bs433 &= -33;
					}
					break;
				case 3:
					if(v433) {
						bs433 |= 16;
					} else {
						bs433 &= -17;
					}
					break;
				case 4:
					if(v433) {
						bs433 |= 8;
					} else {
						bs433 &= -9;
					}
					break;
				case 5:
					if(v433) {
						bs433 |= 4;
					} else {
						bs433 &= -5;
					}
					break;
				case 6:
					if(v433) {
						bs433 |= 2;
					} else {
						bs433 &= -3;
					}
					break;
				case 7:
					if(v433) {
						bs433 |= 1;
					} else {
						bs433 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs433;
			break;
		case 94:
			var this435 = 0;
			var bs434 = this435;
			var l434 = "  *  ".length;
			var _g1435 = 0;
			var _g535 = l434;
			while(_g1435 < _g535) {
				var i435 = _g1435++;
				var no434 = "  *  ".charCodeAt(i435);
				if(no434 == null) {
					break;
				}
				var v434;
				switch(no434) {
				case 32:
					v434 = false;
					break;
				case 42:
					v434 = true;
					break;
				case 48:
					v434 = false;
					break;
				case 49:
					v434 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i435)));
				}
				switch(i435 - (l434 - 8)) {
				case 0:
					if(v434) {
						bs434 |= 128;
					} else {
						bs434 &= -129;
					}
					break;
				case 1:
					if(v434) {
						bs434 |= 64;
					} else {
						bs434 &= -65;
					}
					break;
				case 2:
					if(v434) {
						bs434 |= 32;
					} else {
						bs434 &= -33;
					}
					break;
				case 3:
					if(v434) {
						bs434 |= 16;
					} else {
						bs434 &= -17;
					}
					break;
				case 4:
					if(v434) {
						bs434 |= 8;
					} else {
						bs434 &= -9;
					}
					break;
				case 5:
					if(v434) {
						bs434 |= 4;
					} else {
						bs434 &= -5;
					}
					break;
				case 6:
					if(v434) {
						bs434 |= 2;
					} else {
						bs434 &= -3;
					}
					break;
				case 7:
					if(v434) {
						bs434 |= 1;
					} else {
						bs434 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs434;
			var this436 = 0;
			var bs435 = this436;
			var l435 = " * * ".length;
			var _g1436 = 0;
			var _g536 = l435;
			while(_g1436 < _g536) {
				var i436 = _g1436++;
				var no435 = " * * ".charCodeAt(i436);
				if(no435 == null) {
					break;
				}
				var v435;
				switch(no435) {
				case 32:
					v435 = false;
					break;
				case 42:
					v435 = true;
					break;
				case 48:
					v435 = false;
					break;
				case 49:
					v435 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i436)));
				}
				switch(i436 - (l435 - 8)) {
				case 0:
					if(v435) {
						bs435 |= 128;
					} else {
						bs435 &= -129;
					}
					break;
				case 1:
					if(v435) {
						bs435 |= 64;
					} else {
						bs435 &= -65;
					}
					break;
				case 2:
					if(v435) {
						bs435 |= 32;
					} else {
						bs435 &= -33;
					}
					break;
				case 3:
					if(v435) {
						bs435 |= 16;
					} else {
						bs435 &= -17;
					}
					break;
				case 4:
					if(v435) {
						bs435 |= 8;
					} else {
						bs435 &= -9;
					}
					break;
				case 5:
					if(v435) {
						bs435 |= 4;
					} else {
						bs435 &= -5;
					}
					break;
				case 6:
					if(v435) {
						bs435 |= 2;
					} else {
						bs435 &= -3;
					}
					break;
				case 7:
					if(v435) {
						bs435 |= 1;
					} else {
						bs435 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs435;
			var this437 = 0;
			var bs436 = this437;
			var l436 = "*   *".length;
			var _g1437 = 0;
			var _g537 = l436;
			while(_g1437 < _g537) {
				var i437 = _g1437++;
				var no436 = "*   *".charCodeAt(i437);
				if(no436 == null) {
					break;
				}
				var v436;
				switch(no436) {
				case 32:
					v436 = false;
					break;
				case 42:
					v436 = true;
					break;
				case 48:
					v436 = false;
					break;
				case 49:
					v436 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i437)));
				}
				switch(i437 - (l436 - 8)) {
				case 0:
					if(v436) {
						bs436 |= 128;
					} else {
						bs436 &= -129;
					}
					break;
				case 1:
					if(v436) {
						bs436 |= 64;
					} else {
						bs436 &= -65;
					}
					break;
				case 2:
					if(v436) {
						bs436 |= 32;
					} else {
						bs436 &= -33;
					}
					break;
				case 3:
					if(v436) {
						bs436 |= 16;
					} else {
						bs436 &= -17;
					}
					break;
				case 4:
					if(v436) {
						bs436 |= 8;
					} else {
						bs436 &= -9;
					}
					break;
				case 5:
					if(v436) {
						bs436 |= 4;
					} else {
						bs436 &= -5;
					}
					break;
				case 6:
					if(v436) {
						bs436 |= 2;
					} else {
						bs436 &= -3;
					}
					break;
				case 7:
					if(v436) {
						bs436 |= 1;
					} else {
						bs436 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs436;
			var this438 = 0;
			var bs437 = this438;
			var l437 = "     ".length;
			var _g1438 = 0;
			var _g538 = l437;
			while(_g1438 < _g538) {
				var i438 = _g1438++;
				var no437 = "     ".charCodeAt(i438);
				if(no437 == null) {
					break;
				}
				var v437;
				switch(no437) {
				case 32:
					v437 = false;
					break;
				case 42:
					v437 = true;
					break;
				case 48:
					v437 = false;
					break;
				case 49:
					v437 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i438)));
				}
				switch(i438 - (l437 - 8)) {
				case 0:
					if(v437) {
						bs437 |= 128;
					} else {
						bs437 &= -129;
					}
					break;
				case 1:
					if(v437) {
						bs437 |= 64;
					} else {
						bs437 &= -65;
					}
					break;
				case 2:
					if(v437) {
						bs437 |= 32;
					} else {
						bs437 &= -33;
					}
					break;
				case 3:
					if(v437) {
						bs437 |= 16;
					} else {
						bs437 &= -17;
					}
					break;
				case 4:
					if(v437) {
						bs437 |= 8;
					} else {
						bs437 &= -9;
					}
					break;
				case 5:
					if(v437) {
						bs437 |= 4;
					} else {
						bs437 &= -5;
					}
					break;
				case 6:
					if(v437) {
						bs437 |= 2;
					} else {
						bs437 &= -3;
					}
					break;
				case 7:
					if(v437) {
						bs437 |= 1;
					} else {
						bs437 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs437;
			var this439 = 0;
			var bs438 = this439;
			var l438 = "     ".length;
			var _g1439 = 0;
			var _g539 = l438;
			while(_g1439 < _g539) {
				var i439 = _g1439++;
				var no438 = "     ".charCodeAt(i439);
				if(no438 == null) {
					break;
				}
				var v438;
				switch(no438) {
				case 32:
					v438 = false;
					break;
				case 42:
					v438 = true;
					break;
				case 48:
					v438 = false;
					break;
				case 49:
					v438 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i439)));
				}
				switch(i439 - (l438 - 8)) {
				case 0:
					if(v438) {
						bs438 |= 128;
					} else {
						bs438 &= -129;
					}
					break;
				case 1:
					if(v438) {
						bs438 |= 64;
					} else {
						bs438 &= -65;
					}
					break;
				case 2:
					if(v438) {
						bs438 |= 32;
					} else {
						bs438 &= -33;
					}
					break;
				case 3:
					if(v438) {
						bs438 |= 16;
					} else {
						bs438 &= -17;
					}
					break;
				case 4:
					if(v438) {
						bs438 |= 8;
					} else {
						bs438 &= -9;
					}
					break;
				case 5:
					if(v438) {
						bs438 |= 4;
					} else {
						bs438 &= -5;
					}
					break;
				case 6:
					if(v438) {
						bs438 |= 2;
					} else {
						bs438 &= -3;
					}
					break;
				case 7:
					if(v438) {
						bs438 |= 1;
					} else {
						bs438 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs438;
			var this440 = 0;
			var bs439 = this440;
			var l439 = "     ".length;
			var _g1440 = 0;
			var _g540 = l439;
			while(_g1440 < _g540) {
				var i440 = _g1440++;
				var no439 = "     ".charCodeAt(i440);
				if(no439 == null) {
					break;
				}
				var v439;
				switch(no439) {
				case 32:
					v439 = false;
					break;
				case 42:
					v439 = true;
					break;
				case 48:
					v439 = false;
					break;
				case 49:
					v439 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i440)));
				}
				switch(i440 - (l439 - 8)) {
				case 0:
					if(v439) {
						bs439 |= 128;
					} else {
						bs439 &= -129;
					}
					break;
				case 1:
					if(v439) {
						bs439 |= 64;
					} else {
						bs439 &= -65;
					}
					break;
				case 2:
					if(v439) {
						bs439 |= 32;
					} else {
						bs439 &= -33;
					}
					break;
				case 3:
					if(v439) {
						bs439 |= 16;
					} else {
						bs439 &= -17;
					}
					break;
				case 4:
					if(v439) {
						bs439 |= 8;
					} else {
						bs439 &= -9;
					}
					break;
				case 5:
					if(v439) {
						bs439 |= 4;
					} else {
						bs439 &= -5;
					}
					break;
				case 6:
					if(v439) {
						bs439 |= 2;
					} else {
						bs439 &= -3;
					}
					break;
				case 7:
					if(v439) {
						bs439 |= 1;
					} else {
						bs439 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs439;
			var this441 = 0;
			var bs440 = this441;
			var l440 = "     ".length;
			var _g1441 = 0;
			var _g541 = l440;
			while(_g1441 < _g541) {
				var i441 = _g1441++;
				var no440 = "     ".charCodeAt(i441);
				if(no440 == null) {
					break;
				}
				var v440;
				switch(no440) {
				case 32:
					v440 = false;
					break;
				case 42:
					v440 = true;
					break;
				case 48:
					v440 = false;
					break;
				case 49:
					v440 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i441)));
				}
				switch(i441 - (l440 - 8)) {
				case 0:
					if(v440) {
						bs440 |= 128;
					} else {
						bs440 &= -129;
					}
					break;
				case 1:
					if(v440) {
						bs440 |= 64;
					} else {
						bs440 &= -65;
					}
					break;
				case 2:
					if(v440) {
						bs440 |= 32;
					} else {
						bs440 &= -33;
					}
					break;
				case 3:
					if(v440) {
						bs440 |= 16;
					} else {
						bs440 &= -17;
					}
					break;
				case 4:
					if(v440) {
						bs440 |= 8;
					} else {
						bs440 &= -9;
					}
					break;
				case 5:
					if(v440) {
						bs440 |= 4;
					} else {
						bs440 &= -5;
					}
					break;
				case 6:
					if(v440) {
						bs440 |= 2;
					} else {
						bs440 &= -3;
					}
					break;
				case 7:
					if(v440) {
						bs440 |= 1;
					} else {
						bs440 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs440;
			break;
		case 95:
			var this442 = 0;
			var bs441 = this442;
			var l441 = "     ".length;
			var _g1442 = 0;
			var _g542 = l441;
			while(_g1442 < _g542) {
				var i442 = _g1442++;
				var no441 = "     ".charCodeAt(i442);
				if(no441 == null) {
					break;
				}
				var v441;
				switch(no441) {
				case 32:
					v441 = false;
					break;
				case 42:
					v441 = true;
					break;
				case 48:
					v441 = false;
					break;
				case 49:
					v441 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i442)));
				}
				switch(i442 - (l441 - 8)) {
				case 0:
					if(v441) {
						bs441 |= 128;
					} else {
						bs441 &= -129;
					}
					break;
				case 1:
					if(v441) {
						bs441 |= 64;
					} else {
						bs441 &= -65;
					}
					break;
				case 2:
					if(v441) {
						bs441 |= 32;
					} else {
						bs441 &= -33;
					}
					break;
				case 3:
					if(v441) {
						bs441 |= 16;
					} else {
						bs441 &= -17;
					}
					break;
				case 4:
					if(v441) {
						bs441 |= 8;
					} else {
						bs441 &= -9;
					}
					break;
				case 5:
					if(v441) {
						bs441 |= 4;
					} else {
						bs441 &= -5;
					}
					break;
				case 6:
					if(v441) {
						bs441 |= 2;
					} else {
						bs441 &= -3;
					}
					break;
				case 7:
					if(v441) {
						bs441 |= 1;
					} else {
						bs441 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs441;
			var this443 = 0;
			var bs442 = this443;
			var l442 = "     ".length;
			var _g1443 = 0;
			var _g543 = l442;
			while(_g1443 < _g543) {
				var i443 = _g1443++;
				var no442 = "     ".charCodeAt(i443);
				if(no442 == null) {
					break;
				}
				var v442;
				switch(no442) {
				case 32:
					v442 = false;
					break;
				case 42:
					v442 = true;
					break;
				case 48:
					v442 = false;
					break;
				case 49:
					v442 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i443)));
				}
				switch(i443 - (l442 - 8)) {
				case 0:
					if(v442) {
						bs442 |= 128;
					} else {
						bs442 &= -129;
					}
					break;
				case 1:
					if(v442) {
						bs442 |= 64;
					} else {
						bs442 &= -65;
					}
					break;
				case 2:
					if(v442) {
						bs442 |= 32;
					} else {
						bs442 &= -33;
					}
					break;
				case 3:
					if(v442) {
						bs442 |= 16;
					} else {
						bs442 &= -17;
					}
					break;
				case 4:
					if(v442) {
						bs442 |= 8;
					} else {
						bs442 &= -9;
					}
					break;
				case 5:
					if(v442) {
						bs442 |= 4;
					} else {
						bs442 &= -5;
					}
					break;
				case 6:
					if(v442) {
						bs442 |= 2;
					} else {
						bs442 &= -3;
					}
					break;
				case 7:
					if(v442) {
						bs442 |= 1;
					} else {
						bs442 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs442;
			var this444 = 0;
			var bs443 = this444;
			var l443 = "     ".length;
			var _g1444 = 0;
			var _g544 = l443;
			while(_g1444 < _g544) {
				var i444 = _g1444++;
				var no443 = "     ".charCodeAt(i444);
				if(no443 == null) {
					break;
				}
				var v443;
				switch(no443) {
				case 32:
					v443 = false;
					break;
				case 42:
					v443 = true;
					break;
				case 48:
					v443 = false;
					break;
				case 49:
					v443 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i444)));
				}
				switch(i444 - (l443 - 8)) {
				case 0:
					if(v443) {
						bs443 |= 128;
					} else {
						bs443 &= -129;
					}
					break;
				case 1:
					if(v443) {
						bs443 |= 64;
					} else {
						bs443 &= -65;
					}
					break;
				case 2:
					if(v443) {
						bs443 |= 32;
					} else {
						bs443 &= -33;
					}
					break;
				case 3:
					if(v443) {
						bs443 |= 16;
					} else {
						bs443 &= -17;
					}
					break;
				case 4:
					if(v443) {
						bs443 |= 8;
					} else {
						bs443 &= -9;
					}
					break;
				case 5:
					if(v443) {
						bs443 |= 4;
					} else {
						bs443 &= -5;
					}
					break;
				case 6:
					if(v443) {
						bs443 |= 2;
					} else {
						bs443 &= -3;
					}
					break;
				case 7:
					if(v443) {
						bs443 |= 1;
					} else {
						bs443 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs443;
			var this445 = 0;
			var bs444 = this445;
			var l444 = "     ".length;
			var _g1445 = 0;
			var _g545 = l444;
			while(_g1445 < _g545) {
				var i445 = _g1445++;
				var no444 = "     ".charCodeAt(i445);
				if(no444 == null) {
					break;
				}
				var v444;
				switch(no444) {
				case 32:
					v444 = false;
					break;
				case 42:
					v444 = true;
					break;
				case 48:
					v444 = false;
					break;
				case 49:
					v444 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i445)));
				}
				switch(i445 - (l444 - 8)) {
				case 0:
					if(v444) {
						bs444 |= 128;
					} else {
						bs444 &= -129;
					}
					break;
				case 1:
					if(v444) {
						bs444 |= 64;
					} else {
						bs444 &= -65;
					}
					break;
				case 2:
					if(v444) {
						bs444 |= 32;
					} else {
						bs444 &= -33;
					}
					break;
				case 3:
					if(v444) {
						bs444 |= 16;
					} else {
						bs444 &= -17;
					}
					break;
				case 4:
					if(v444) {
						bs444 |= 8;
					} else {
						bs444 &= -9;
					}
					break;
				case 5:
					if(v444) {
						bs444 |= 4;
					} else {
						bs444 &= -5;
					}
					break;
				case 6:
					if(v444) {
						bs444 |= 2;
					} else {
						bs444 &= -3;
					}
					break;
				case 7:
					if(v444) {
						bs444 |= 1;
					} else {
						bs444 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs444;
			var this446 = 0;
			var bs445 = this446;
			var l445 = "     ".length;
			var _g1446 = 0;
			var _g546 = l445;
			while(_g1446 < _g546) {
				var i446 = _g1446++;
				var no445 = "     ".charCodeAt(i446);
				if(no445 == null) {
					break;
				}
				var v445;
				switch(no445) {
				case 32:
					v445 = false;
					break;
				case 42:
					v445 = true;
					break;
				case 48:
					v445 = false;
					break;
				case 49:
					v445 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i446)));
				}
				switch(i446 - (l445 - 8)) {
				case 0:
					if(v445) {
						bs445 |= 128;
					} else {
						bs445 &= -129;
					}
					break;
				case 1:
					if(v445) {
						bs445 |= 64;
					} else {
						bs445 &= -65;
					}
					break;
				case 2:
					if(v445) {
						bs445 |= 32;
					} else {
						bs445 &= -33;
					}
					break;
				case 3:
					if(v445) {
						bs445 |= 16;
					} else {
						bs445 &= -17;
					}
					break;
				case 4:
					if(v445) {
						bs445 |= 8;
					} else {
						bs445 &= -9;
					}
					break;
				case 5:
					if(v445) {
						bs445 |= 4;
					} else {
						bs445 &= -5;
					}
					break;
				case 6:
					if(v445) {
						bs445 |= 2;
					} else {
						bs445 &= -3;
					}
					break;
				case 7:
					if(v445) {
						bs445 |= 1;
					} else {
						bs445 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs445;
			var this447 = 0;
			var bs446 = this447;
			var l446 = "     ".length;
			var _g1447 = 0;
			var _g547 = l446;
			while(_g1447 < _g547) {
				var i447 = _g1447++;
				var no446 = "     ".charCodeAt(i447);
				if(no446 == null) {
					break;
				}
				var v446;
				switch(no446) {
				case 32:
					v446 = false;
					break;
				case 42:
					v446 = true;
					break;
				case 48:
					v446 = false;
					break;
				case 49:
					v446 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i447)));
				}
				switch(i447 - (l446 - 8)) {
				case 0:
					if(v446) {
						bs446 |= 128;
					} else {
						bs446 &= -129;
					}
					break;
				case 1:
					if(v446) {
						bs446 |= 64;
					} else {
						bs446 &= -65;
					}
					break;
				case 2:
					if(v446) {
						bs446 |= 32;
					} else {
						bs446 &= -33;
					}
					break;
				case 3:
					if(v446) {
						bs446 |= 16;
					} else {
						bs446 &= -17;
					}
					break;
				case 4:
					if(v446) {
						bs446 |= 8;
					} else {
						bs446 &= -9;
					}
					break;
				case 5:
					if(v446) {
						bs446 |= 4;
					} else {
						bs446 &= -5;
					}
					break;
				case 6:
					if(v446) {
						bs446 |= 2;
					} else {
						bs446 &= -3;
					}
					break;
				case 7:
					if(v446) {
						bs446 |= 1;
					} else {
						bs446 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs446;
			var this448 = 0;
			var bs447 = this448;
			var l447 = "*****".length;
			var _g1448 = 0;
			var _g548 = l447;
			while(_g1448 < _g548) {
				var i448 = _g1448++;
				var no447 = "*****".charCodeAt(i448);
				if(no447 == null) {
					break;
				}
				var v447;
				switch(no447) {
				case 32:
					v447 = false;
					break;
				case 42:
					v447 = true;
					break;
				case 48:
					v447 = false;
					break;
				case 49:
					v447 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i448)));
				}
				switch(i448 - (l447 - 8)) {
				case 0:
					if(v447) {
						bs447 |= 128;
					} else {
						bs447 &= -129;
					}
					break;
				case 1:
					if(v447) {
						bs447 |= 64;
					} else {
						bs447 &= -65;
					}
					break;
				case 2:
					if(v447) {
						bs447 |= 32;
					} else {
						bs447 &= -33;
					}
					break;
				case 3:
					if(v447) {
						bs447 |= 16;
					} else {
						bs447 &= -17;
					}
					break;
				case 4:
					if(v447) {
						bs447 |= 8;
					} else {
						bs447 &= -9;
					}
					break;
				case 5:
					if(v447) {
						bs447 |= 4;
					} else {
						bs447 &= -5;
					}
					break;
				case 6:
					if(v447) {
						bs447 |= 2;
					} else {
						bs447 &= -3;
					}
					break;
				case 7:
					if(v447) {
						bs447 |= 1;
					} else {
						bs447 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs447;
			break;
		case 96:
			var this449 = 0;
			var bs448 = this449;
			var l448 = "*    ".length;
			var _g1449 = 0;
			var _g549 = l448;
			while(_g1449 < _g549) {
				var i449 = _g1449++;
				var no448 = "*    ".charCodeAt(i449);
				if(no448 == null) {
					break;
				}
				var v448;
				switch(no448) {
				case 32:
					v448 = false;
					break;
				case 42:
					v448 = true;
					break;
				case 48:
					v448 = false;
					break;
				case 49:
					v448 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i449)));
				}
				switch(i449 - (l448 - 8)) {
				case 0:
					if(v448) {
						bs448 |= 128;
					} else {
						bs448 &= -129;
					}
					break;
				case 1:
					if(v448) {
						bs448 |= 64;
					} else {
						bs448 &= -65;
					}
					break;
				case 2:
					if(v448) {
						bs448 |= 32;
					} else {
						bs448 &= -33;
					}
					break;
				case 3:
					if(v448) {
						bs448 |= 16;
					} else {
						bs448 &= -17;
					}
					break;
				case 4:
					if(v448) {
						bs448 |= 8;
					} else {
						bs448 &= -9;
					}
					break;
				case 5:
					if(v448) {
						bs448 |= 4;
					} else {
						bs448 &= -5;
					}
					break;
				case 6:
					if(v448) {
						bs448 |= 2;
					} else {
						bs448 &= -3;
					}
					break;
				case 7:
					if(v448) {
						bs448 |= 1;
					} else {
						bs448 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs448;
			var this450 = 0;
			var bs449 = this450;
			var l449 = " *   ".length;
			var _g1450 = 0;
			var _g550 = l449;
			while(_g1450 < _g550) {
				var i450 = _g1450++;
				var no449 = " *   ".charCodeAt(i450);
				if(no449 == null) {
					break;
				}
				var v449;
				switch(no449) {
				case 32:
					v449 = false;
					break;
				case 42:
					v449 = true;
					break;
				case 48:
					v449 = false;
					break;
				case 49:
					v449 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i450)));
				}
				switch(i450 - (l449 - 8)) {
				case 0:
					if(v449) {
						bs449 |= 128;
					} else {
						bs449 &= -129;
					}
					break;
				case 1:
					if(v449) {
						bs449 |= 64;
					} else {
						bs449 &= -65;
					}
					break;
				case 2:
					if(v449) {
						bs449 |= 32;
					} else {
						bs449 &= -33;
					}
					break;
				case 3:
					if(v449) {
						bs449 |= 16;
					} else {
						bs449 &= -17;
					}
					break;
				case 4:
					if(v449) {
						bs449 |= 8;
					} else {
						bs449 &= -9;
					}
					break;
				case 5:
					if(v449) {
						bs449 |= 4;
					} else {
						bs449 &= -5;
					}
					break;
				case 6:
					if(v449) {
						bs449 |= 2;
					} else {
						bs449 &= -3;
					}
					break;
				case 7:
					if(v449) {
						bs449 |= 1;
					} else {
						bs449 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs449;
			var this451 = 0;
			var bs450 = this451;
			var l450 = "     ".length;
			var _g1451 = 0;
			var _g551 = l450;
			while(_g1451 < _g551) {
				var i451 = _g1451++;
				var no450 = "     ".charCodeAt(i451);
				if(no450 == null) {
					break;
				}
				var v450;
				switch(no450) {
				case 32:
					v450 = false;
					break;
				case 42:
					v450 = true;
					break;
				case 48:
					v450 = false;
					break;
				case 49:
					v450 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i451)));
				}
				switch(i451 - (l450 - 8)) {
				case 0:
					if(v450) {
						bs450 |= 128;
					} else {
						bs450 &= -129;
					}
					break;
				case 1:
					if(v450) {
						bs450 |= 64;
					} else {
						bs450 &= -65;
					}
					break;
				case 2:
					if(v450) {
						bs450 |= 32;
					} else {
						bs450 &= -33;
					}
					break;
				case 3:
					if(v450) {
						bs450 |= 16;
					} else {
						bs450 &= -17;
					}
					break;
				case 4:
					if(v450) {
						bs450 |= 8;
					} else {
						bs450 &= -9;
					}
					break;
				case 5:
					if(v450) {
						bs450 |= 4;
					} else {
						bs450 &= -5;
					}
					break;
				case 6:
					if(v450) {
						bs450 |= 2;
					} else {
						bs450 &= -3;
					}
					break;
				case 7:
					if(v450) {
						bs450 |= 1;
					} else {
						bs450 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs450;
			var this452 = 0;
			var bs451 = this452;
			var l451 = "     ".length;
			var _g1452 = 0;
			var _g552 = l451;
			while(_g1452 < _g552) {
				var i452 = _g1452++;
				var no451 = "     ".charCodeAt(i452);
				if(no451 == null) {
					break;
				}
				var v451;
				switch(no451) {
				case 32:
					v451 = false;
					break;
				case 42:
					v451 = true;
					break;
				case 48:
					v451 = false;
					break;
				case 49:
					v451 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i452)));
				}
				switch(i452 - (l451 - 8)) {
				case 0:
					if(v451) {
						bs451 |= 128;
					} else {
						bs451 &= -129;
					}
					break;
				case 1:
					if(v451) {
						bs451 |= 64;
					} else {
						bs451 &= -65;
					}
					break;
				case 2:
					if(v451) {
						bs451 |= 32;
					} else {
						bs451 &= -33;
					}
					break;
				case 3:
					if(v451) {
						bs451 |= 16;
					} else {
						bs451 &= -17;
					}
					break;
				case 4:
					if(v451) {
						bs451 |= 8;
					} else {
						bs451 &= -9;
					}
					break;
				case 5:
					if(v451) {
						bs451 |= 4;
					} else {
						bs451 &= -5;
					}
					break;
				case 6:
					if(v451) {
						bs451 |= 2;
					} else {
						bs451 &= -3;
					}
					break;
				case 7:
					if(v451) {
						bs451 |= 1;
					} else {
						bs451 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs451;
			var this453 = 0;
			var bs452 = this453;
			var l452 = "     ".length;
			var _g1453 = 0;
			var _g553 = l452;
			while(_g1453 < _g553) {
				var i453 = _g1453++;
				var no452 = "     ".charCodeAt(i453);
				if(no452 == null) {
					break;
				}
				var v452;
				switch(no452) {
				case 32:
					v452 = false;
					break;
				case 42:
					v452 = true;
					break;
				case 48:
					v452 = false;
					break;
				case 49:
					v452 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i453)));
				}
				switch(i453 - (l452 - 8)) {
				case 0:
					if(v452) {
						bs452 |= 128;
					} else {
						bs452 &= -129;
					}
					break;
				case 1:
					if(v452) {
						bs452 |= 64;
					} else {
						bs452 &= -65;
					}
					break;
				case 2:
					if(v452) {
						bs452 |= 32;
					} else {
						bs452 &= -33;
					}
					break;
				case 3:
					if(v452) {
						bs452 |= 16;
					} else {
						bs452 &= -17;
					}
					break;
				case 4:
					if(v452) {
						bs452 |= 8;
					} else {
						bs452 &= -9;
					}
					break;
				case 5:
					if(v452) {
						bs452 |= 4;
					} else {
						bs452 &= -5;
					}
					break;
				case 6:
					if(v452) {
						bs452 |= 2;
					} else {
						bs452 &= -3;
					}
					break;
				case 7:
					if(v452) {
						bs452 |= 1;
					} else {
						bs452 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs452;
			var this454 = 0;
			var bs453 = this454;
			var l453 = "     ".length;
			var _g1454 = 0;
			var _g554 = l453;
			while(_g1454 < _g554) {
				var i454 = _g1454++;
				var no453 = "     ".charCodeAt(i454);
				if(no453 == null) {
					break;
				}
				var v453;
				switch(no453) {
				case 32:
					v453 = false;
					break;
				case 42:
					v453 = true;
					break;
				case 48:
					v453 = false;
					break;
				case 49:
					v453 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i454)));
				}
				switch(i454 - (l453 - 8)) {
				case 0:
					if(v453) {
						bs453 |= 128;
					} else {
						bs453 &= -129;
					}
					break;
				case 1:
					if(v453) {
						bs453 |= 64;
					} else {
						bs453 &= -65;
					}
					break;
				case 2:
					if(v453) {
						bs453 |= 32;
					} else {
						bs453 &= -33;
					}
					break;
				case 3:
					if(v453) {
						bs453 |= 16;
					} else {
						bs453 &= -17;
					}
					break;
				case 4:
					if(v453) {
						bs453 |= 8;
					} else {
						bs453 &= -9;
					}
					break;
				case 5:
					if(v453) {
						bs453 |= 4;
					} else {
						bs453 &= -5;
					}
					break;
				case 6:
					if(v453) {
						bs453 |= 2;
					} else {
						bs453 &= -3;
					}
					break;
				case 7:
					if(v453) {
						bs453 |= 1;
					} else {
						bs453 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs453;
			var this455 = 0;
			var bs454 = this455;
			var l454 = "     ".length;
			var _g1455 = 0;
			var _g555 = l454;
			while(_g1455 < _g555) {
				var i455 = _g1455++;
				var no454 = "     ".charCodeAt(i455);
				if(no454 == null) {
					break;
				}
				var v454;
				switch(no454) {
				case 32:
					v454 = false;
					break;
				case 42:
					v454 = true;
					break;
				case 48:
					v454 = false;
					break;
				case 49:
					v454 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i455)));
				}
				switch(i455 - (l454 - 8)) {
				case 0:
					if(v454) {
						bs454 |= 128;
					} else {
						bs454 &= -129;
					}
					break;
				case 1:
					if(v454) {
						bs454 |= 64;
					} else {
						bs454 &= -65;
					}
					break;
				case 2:
					if(v454) {
						bs454 |= 32;
					} else {
						bs454 &= -33;
					}
					break;
				case 3:
					if(v454) {
						bs454 |= 16;
					} else {
						bs454 &= -17;
					}
					break;
				case 4:
					if(v454) {
						bs454 |= 8;
					} else {
						bs454 &= -9;
					}
					break;
				case 5:
					if(v454) {
						bs454 |= 4;
					} else {
						bs454 &= -5;
					}
					break;
				case 6:
					if(v454) {
						bs454 |= 2;
					} else {
						bs454 &= -3;
					}
					break;
				case 7:
					if(v454) {
						bs454 |= 1;
					} else {
						bs454 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs454;
			break;
		case 97:
			var this456 = 0;
			var bs455 = this456;
			var l455 = "     ".length;
			var _g1456 = 0;
			var _g556 = l455;
			while(_g1456 < _g556) {
				var i456 = _g1456++;
				var no455 = "     ".charCodeAt(i456);
				if(no455 == null) {
					break;
				}
				var v455;
				switch(no455) {
				case 32:
					v455 = false;
					break;
				case 42:
					v455 = true;
					break;
				case 48:
					v455 = false;
					break;
				case 49:
					v455 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i456)));
				}
				switch(i456 - (l455 - 8)) {
				case 0:
					if(v455) {
						bs455 |= 128;
					} else {
						bs455 &= -129;
					}
					break;
				case 1:
					if(v455) {
						bs455 |= 64;
					} else {
						bs455 &= -65;
					}
					break;
				case 2:
					if(v455) {
						bs455 |= 32;
					} else {
						bs455 &= -33;
					}
					break;
				case 3:
					if(v455) {
						bs455 |= 16;
					} else {
						bs455 &= -17;
					}
					break;
				case 4:
					if(v455) {
						bs455 |= 8;
					} else {
						bs455 &= -9;
					}
					break;
				case 5:
					if(v455) {
						bs455 |= 4;
					} else {
						bs455 &= -5;
					}
					break;
				case 6:
					if(v455) {
						bs455 |= 2;
					} else {
						bs455 &= -3;
					}
					break;
				case 7:
					if(v455) {
						bs455 |= 1;
					} else {
						bs455 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs455;
			var this457 = 0;
			var bs456 = this457;
			var l456 = "     ".length;
			var _g1457 = 0;
			var _g557 = l456;
			while(_g1457 < _g557) {
				var i457 = _g1457++;
				var no456 = "     ".charCodeAt(i457);
				if(no456 == null) {
					break;
				}
				var v456;
				switch(no456) {
				case 32:
					v456 = false;
					break;
				case 42:
					v456 = true;
					break;
				case 48:
					v456 = false;
					break;
				case 49:
					v456 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i457)));
				}
				switch(i457 - (l456 - 8)) {
				case 0:
					if(v456) {
						bs456 |= 128;
					} else {
						bs456 &= -129;
					}
					break;
				case 1:
					if(v456) {
						bs456 |= 64;
					} else {
						bs456 &= -65;
					}
					break;
				case 2:
					if(v456) {
						bs456 |= 32;
					} else {
						bs456 &= -33;
					}
					break;
				case 3:
					if(v456) {
						bs456 |= 16;
					} else {
						bs456 &= -17;
					}
					break;
				case 4:
					if(v456) {
						bs456 |= 8;
					} else {
						bs456 &= -9;
					}
					break;
				case 5:
					if(v456) {
						bs456 |= 4;
					} else {
						bs456 &= -5;
					}
					break;
				case 6:
					if(v456) {
						bs456 |= 2;
					} else {
						bs456 &= -3;
					}
					break;
				case 7:
					if(v456) {
						bs456 |= 1;
					} else {
						bs456 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs456;
			var this458 = 0;
			var bs457 = this458;
			var l457 = " *** ".length;
			var _g1458 = 0;
			var _g558 = l457;
			while(_g1458 < _g558) {
				var i458 = _g1458++;
				var no457 = " *** ".charCodeAt(i458);
				if(no457 == null) {
					break;
				}
				var v457;
				switch(no457) {
				case 32:
					v457 = false;
					break;
				case 42:
					v457 = true;
					break;
				case 48:
					v457 = false;
					break;
				case 49:
					v457 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i458)));
				}
				switch(i458 - (l457 - 8)) {
				case 0:
					if(v457) {
						bs457 |= 128;
					} else {
						bs457 &= -129;
					}
					break;
				case 1:
					if(v457) {
						bs457 |= 64;
					} else {
						bs457 &= -65;
					}
					break;
				case 2:
					if(v457) {
						bs457 |= 32;
					} else {
						bs457 &= -33;
					}
					break;
				case 3:
					if(v457) {
						bs457 |= 16;
					} else {
						bs457 &= -17;
					}
					break;
				case 4:
					if(v457) {
						bs457 |= 8;
					} else {
						bs457 &= -9;
					}
					break;
				case 5:
					if(v457) {
						bs457 |= 4;
					} else {
						bs457 &= -5;
					}
					break;
				case 6:
					if(v457) {
						bs457 |= 2;
					} else {
						bs457 &= -3;
					}
					break;
				case 7:
					if(v457) {
						bs457 |= 1;
					} else {
						bs457 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs457;
			var this459 = 0;
			var bs458 = this459;
			var l458 = "    *".length;
			var _g1459 = 0;
			var _g559 = l458;
			while(_g1459 < _g559) {
				var i459 = _g1459++;
				var no458 = "    *".charCodeAt(i459);
				if(no458 == null) {
					break;
				}
				var v458;
				switch(no458) {
				case 32:
					v458 = false;
					break;
				case 42:
					v458 = true;
					break;
				case 48:
					v458 = false;
					break;
				case 49:
					v458 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i459)));
				}
				switch(i459 - (l458 - 8)) {
				case 0:
					if(v458) {
						bs458 |= 128;
					} else {
						bs458 &= -129;
					}
					break;
				case 1:
					if(v458) {
						bs458 |= 64;
					} else {
						bs458 &= -65;
					}
					break;
				case 2:
					if(v458) {
						bs458 |= 32;
					} else {
						bs458 &= -33;
					}
					break;
				case 3:
					if(v458) {
						bs458 |= 16;
					} else {
						bs458 &= -17;
					}
					break;
				case 4:
					if(v458) {
						bs458 |= 8;
					} else {
						bs458 &= -9;
					}
					break;
				case 5:
					if(v458) {
						bs458 |= 4;
					} else {
						bs458 &= -5;
					}
					break;
				case 6:
					if(v458) {
						bs458 |= 2;
					} else {
						bs458 &= -3;
					}
					break;
				case 7:
					if(v458) {
						bs458 |= 1;
					} else {
						bs458 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs458;
			var this460 = 0;
			var bs459 = this460;
			var l459 = " ****".length;
			var _g1460 = 0;
			var _g560 = l459;
			while(_g1460 < _g560) {
				var i460 = _g1460++;
				var no459 = " ****".charCodeAt(i460);
				if(no459 == null) {
					break;
				}
				var v459;
				switch(no459) {
				case 32:
					v459 = false;
					break;
				case 42:
					v459 = true;
					break;
				case 48:
					v459 = false;
					break;
				case 49:
					v459 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i460)));
				}
				switch(i460 - (l459 - 8)) {
				case 0:
					if(v459) {
						bs459 |= 128;
					} else {
						bs459 &= -129;
					}
					break;
				case 1:
					if(v459) {
						bs459 |= 64;
					} else {
						bs459 &= -65;
					}
					break;
				case 2:
					if(v459) {
						bs459 |= 32;
					} else {
						bs459 &= -33;
					}
					break;
				case 3:
					if(v459) {
						bs459 |= 16;
					} else {
						bs459 &= -17;
					}
					break;
				case 4:
					if(v459) {
						bs459 |= 8;
					} else {
						bs459 &= -9;
					}
					break;
				case 5:
					if(v459) {
						bs459 |= 4;
					} else {
						bs459 &= -5;
					}
					break;
				case 6:
					if(v459) {
						bs459 |= 2;
					} else {
						bs459 &= -3;
					}
					break;
				case 7:
					if(v459) {
						bs459 |= 1;
					} else {
						bs459 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs459;
			var this461 = 0;
			var bs460 = this461;
			var l460 = "*   *".length;
			var _g1461 = 0;
			var _g561 = l460;
			while(_g1461 < _g561) {
				var i461 = _g1461++;
				var no460 = "*   *".charCodeAt(i461);
				if(no460 == null) {
					break;
				}
				var v460;
				switch(no460) {
				case 32:
					v460 = false;
					break;
				case 42:
					v460 = true;
					break;
				case 48:
					v460 = false;
					break;
				case 49:
					v460 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i461)));
				}
				switch(i461 - (l460 - 8)) {
				case 0:
					if(v460) {
						bs460 |= 128;
					} else {
						bs460 &= -129;
					}
					break;
				case 1:
					if(v460) {
						bs460 |= 64;
					} else {
						bs460 &= -65;
					}
					break;
				case 2:
					if(v460) {
						bs460 |= 32;
					} else {
						bs460 &= -33;
					}
					break;
				case 3:
					if(v460) {
						bs460 |= 16;
					} else {
						bs460 &= -17;
					}
					break;
				case 4:
					if(v460) {
						bs460 |= 8;
					} else {
						bs460 &= -9;
					}
					break;
				case 5:
					if(v460) {
						bs460 |= 4;
					} else {
						bs460 &= -5;
					}
					break;
				case 6:
					if(v460) {
						bs460 |= 2;
					} else {
						bs460 &= -3;
					}
					break;
				case 7:
					if(v460) {
						bs460 |= 1;
					} else {
						bs460 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs460;
			var this462 = 0;
			var bs461 = this462;
			var l461 = " ****".length;
			var _g1462 = 0;
			var _g562 = l461;
			while(_g1462 < _g562) {
				var i462 = _g1462++;
				var no461 = " ****".charCodeAt(i462);
				if(no461 == null) {
					break;
				}
				var v461;
				switch(no461) {
				case 32:
					v461 = false;
					break;
				case 42:
					v461 = true;
					break;
				case 48:
					v461 = false;
					break;
				case 49:
					v461 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i462)));
				}
				switch(i462 - (l461 - 8)) {
				case 0:
					if(v461) {
						bs461 |= 128;
					} else {
						bs461 &= -129;
					}
					break;
				case 1:
					if(v461) {
						bs461 |= 64;
					} else {
						bs461 &= -65;
					}
					break;
				case 2:
					if(v461) {
						bs461 |= 32;
					} else {
						bs461 &= -33;
					}
					break;
				case 3:
					if(v461) {
						bs461 |= 16;
					} else {
						bs461 &= -17;
					}
					break;
				case 4:
					if(v461) {
						bs461 |= 8;
					} else {
						bs461 &= -9;
					}
					break;
				case 5:
					if(v461) {
						bs461 |= 4;
					} else {
						bs461 &= -5;
					}
					break;
				case 6:
					if(v461) {
						bs461 |= 2;
					} else {
						bs461 &= -3;
					}
					break;
				case 7:
					if(v461) {
						bs461 |= 1;
					} else {
						bs461 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs461;
			break;
		case 98:
			var this463 = 0;
			var bs462 = this463;
			var l462 = "*    ".length;
			var _g1463 = 0;
			var _g563 = l462;
			while(_g1463 < _g563) {
				var i463 = _g1463++;
				var no462 = "*    ".charCodeAt(i463);
				if(no462 == null) {
					break;
				}
				var v462;
				switch(no462) {
				case 32:
					v462 = false;
					break;
				case 42:
					v462 = true;
					break;
				case 48:
					v462 = false;
					break;
				case 49:
					v462 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i463)));
				}
				switch(i463 - (l462 - 8)) {
				case 0:
					if(v462) {
						bs462 |= 128;
					} else {
						bs462 &= -129;
					}
					break;
				case 1:
					if(v462) {
						bs462 |= 64;
					} else {
						bs462 &= -65;
					}
					break;
				case 2:
					if(v462) {
						bs462 |= 32;
					} else {
						bs462 &= -33;
					}
					break;
				case 3:
					if(v462) {
						bs462 |= 16;
					} else {
						bs462 &= -17;
					}
					break;
				case 4:
					if(v462) {
						bs462 |= 8;
					} else {
						bs462 &= -9;
					}
					break;
				case 5:
					if(v462) {
						bs462 |= 4;
					} else {
						bs462 &= -5;
					}
					break;
				case 6:
					if(v462) {
						bs462 |= 2;
					} else {
						bs462 &= -3;
					}
					break;
				case 7:
					if(v462) {
						bs462 |= 1;
					} else {
						bs462 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs462;
			var this464 = 0;
			var bs463 = this464;
			var l463 = "*    ".length;
			var _g1464 = 0;
			var _g564 = l463;
			while(_g1464 < _g564) {
				var i464 = _g1464++;
				var no463 = "*    ".charCodeAt(i464);
				if(no463 == null) {
					break;
				}
				var v463;
				switch(no463) {
				case 32:
					v463 = false;
					break;
				case 42:
					v463 = true;
					break;
				case 48:
					v463 = false;
					break;
				case 49:
					v463 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i464)));
				}
				switch(i464 - (l463 - 8)) {
				case 0:
					if(v463) {
						bs463 |= 128;
					} else {
						bs463 &= -129;
					}
					break;
				case 1:
					if(v463) {
						bs463 |= 64;
					} else {
						bs463 &= -65;
					}
					break;
				case 2:
					if(v463) {
						bs463 |= 32;
					} else {
						bs463 &= -33;
					}
					break;
				case 3:
					if(v463) {
						bs463 |= 16;
					} else {
						bs463 &= -17;
					}
					break;
				case 4:
					if(v463) {
						bs463 |= 8;
					} else {
						bs463 &= -9;
					}
					break;
				case 5:
					if(v463) {
						bs463 |= 4;
					} else {
						bs463 &= -5;
					}
					break;
				case 6:
					if(v463) {
						bs463 |= 2;
					} else {
						bs463 &= -3;
					}
					break;
				case 7:
					if(v463) {
						bs463 |= 1;
					} else {
						bs463 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs463;
			var this465 = 0;
			var bs464 = this465;
			var l464 = "* ** ".length;
			var _g1465 = 0;
			var _g565 = l464;
			while(_g1465 < _g565) {
				var i465 = _g1465++;
				var no464 = "* ** ".charCodeAt(i465);
				if(no464 == null) {
					break;
				}
				var v464;
				switch(no464) {
				case 32:
					v464 = false;
					break;
				case 42:
					v464 = true;
					break;
				case 48:
					v464 = false;
					break;
				case 49:
					v464 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* ** ".charCodeAt(i465)));
				}
				switch(i465 - (l464 - 8)) {
				case 0:
					if(v464) {
						bs464 |= 128;
					} else {
						bs464 &= -129;
					}
					break;
				case 1:
					if(v464) {
						bs464 |= 64;
					} else {
						bs464 &= -65;
					}
					break;
				case 2:
					if(v464) {
						bs464 |= 32;
					} else {
						bs464 &= -33;
					}
					break;
				case 3:
					if(v464) {
						bs464 |= 16;
					} else {
						bs464 &= -17;
					}
					break;
				case 4:
					if(v464) {
						bs464 |= 8;
					} else {
						bs464 &= -9;
					}
					break;
				case 5:
					if(v464) {
						bs464 |= 4;
					} else {
						bs464 &= -5;
					}
					break;
				case 6:
					if(v464) {
						bs464 |= 2;
					} else {
						bs464 &= -3;
					}
					break;
				case 7:
					if(v464) {
						bs464 |= 1;
					} else {
						bs464 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs464;
			var this466 = 0;
			var bs465 = this466;
			var l465 = "**  *".length;
			var _g1466 = 0;
			var _g566 = l465;
			while(_g1466 < _g566) {
				var i466 = _g1466++;
				var no465 = "**  *".charCodeAt(i466);
				if(no465 == null) {
					break;
				}
				var v465;
				switch(no465) {
				case 32:
					v465 = false;
					break;
				case 42:
					v465 = true;
					break;
				case 48:
					v465 = false;
					break;
				case 49:
					v465 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i466)));
				}
				switch(i466 - (l465 - 8)) {
				case 0:
					if(v465) {
						bs465 |= 128;
					} else {
						bs465 &= -129;
					}
					break;
				case 1:
					if(v465) {
						bs465 |= 64;
					} else {
						bs465 &= -65;
					}
					break;
				case 2:
					if(v465) {
						bs465 |= 32;
					} else {
						bs465 &= -33;
					}
					break;
				case 3:
					if(v465) {
						bs465 |= 16;
					} else {
						bs465 &= -17;
					}
					break;
				case 4:
					if(v465) {
						bs465 |= 8;
					} else {
						bs465 &= -9;
					}
					break;
				case 5:
					if(v465) {
						bs465 |= 4;
					} else {
						bs465 &= -5;
					}
					break;
				case 6:
					if(v465) {
						bs465 |= 2;
					} else {
						bs465 &= -3;
					}
					break;
				case 7:
					if(v465) {
						bs465 |= 1;
					} else {
						bs465 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs465;
			var this467 = 0;
			var bs466 = this467;
			var l466 = "*   *".length;
			var _g1467 = 0;
			var _g567 = l466;
			while(_g1467 < _g567) {
				var i467 = _g1467++;
				var no466 = "*   *".charCodeAt(i467);
				if(no466 == null) {
					break;
				}
				var v466;
				switch(no466) {
				case 32:
					v466 = false;
					break;
				case 42:
					v466 = true;
					break;
				case 48:
					v466 = false;
					break;
				case 49:
					v466 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i467)));
				}
				switch(i467 - (l466 - 8)) {
				case 0:
					if(v466) {
						bs466 |= 128;
					} else {
						bs466 &= -129;
					}
					break;
				case 1:
					if(v466) {
						bs466 |= 64;
					} else {
						bs466 &= -65;
					}
					break;
				case 2:
					if(v466) {
						bs466 |= 32;
					} else {
						bs466 &= -33;
					}
					break;
				case 3:
					if(v466) {
						bs466 |= 16;
					} else {
						bs466 &= -17;
					}
					break;
				case 4:
					if(v466) {
						bs466 |= 8;
					} else {
						bs466 &= -9;
					}
					break;
				case 5:
					if(v466) {
						bs466 |= 4;
					} else {
						bs466 &= -5;
					}
					break;
				case 6:
					if(v466) {
						bs466 |= 2;
					} else {
						bs466 &= -3;
					}
					break;
				case 7:
					if(v466) {
						bs466 |= 1;
					} else {
						bs466 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs466;
			var this468 = 0;
			var bs467 = this468;
			var l467 = "*   *".length;
			var _g1468 = 0;
			var _g568 = l467;
			while(_g1468 < _g568) {
				var i468 = _g1468++;
				var no467 = "*   *".charCodeAt(i468);
				if(no467 == null) {
					break;
				}
				var v467;
				switch(no467) {
				case 32:
					v467 = false;
					break;
				case 42:
					v467 = true;
					break;
				case 48:
					v467 = false;
					break;
				case 49:
					v467 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i468)));
				}
				switch(i468 - (l467 - 8)) {
				case 0:
					if(v467) {
						bs467 |= 128;
					} else {
						bs467 &= -129;
					}
					break;
				case 1:
					if(v467) {
						bs467 |= 64;
					} else {
						bs467 &= -65;
					}
					break;
				case 2:
					if(v467) {
						bs467 |= 32;
					} else {
						bs467 &= -33;
					}
					break;
				case 3:
					if(v467) {
						bs467 |= 16;
					} else {
						bs467 &= -17;
					}
					break;
				case 4:
					if(v467) {
						bs467 |= 8;
					} else {
						bs467 &= -9;
					}
					break;
				case 5:
					if(v467) {
						bs467 |= 4;
					} else {
						bs467 &= -5;
					}
					break;
				case 6:
					if(v467) {
						bs467 |= 2;
					} else {
						bs467 &= -3;
					}
					break;
				case 7:
					if(v467) {
						bs467 |= 1;
					} else {
						bs467 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs467;
			var this469 = 0;
			var bs468 = this469;
			var l468 = "**** ".length;
			var _g1469 = 0;
			var _g569 = l468;
			while(_g1469 < _g569) {
				var i469 = _g1469++;
				var no468 = "**** ".charCodeAt(i469);
				if(no468 == null) {
					break;
				}
				var v468;
				switch(no468) {
				case 32:
					v468 = false;
					break;
				case 42:
					v468 = true;
					break;
				case 48:
					v468 = false;
					break;
				case 49:
					v468 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i469)));
				}
				switch(i469 - (l468 - 8)) {
				case 0:
					if(v468) {
						bs468 |= 128;
					} else {
						bs468 &= -129;
					}
					break;
				case 1:
					if(v468) {
						bs468 |= 64;
					} else {
						bs468 &= -65;
					}
					break;
				case 2:
					if(v468) {
						bs468 |= 32;
					} else {
						bs468 &= -33;
					}
					break;
				case 3:
					if(v468) {
						bs468 |= 16;
					} else {
						bs468 &= -17;
					}
					break;
				case 4:
					if(v468) {
						bs468 |= 8;
					} else {
						bs468 &= -9;
					}
					break;
				case 5:
					if(v468) {
						bs468 |= 4;
					} else {
						bs468 &= -5;
					}
					break;
				case 6:
					if(v468) {
						bs468 |= 2;
					} else {
						bs468 &= -3;
					}
					break;
				case 7:
					if(v468) {
						bs468 |= 1;
					} else {
						bs468 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs468;
			break;
		case 99:
			var this470 = 0;
			var bs469 = this470;
			var l469 = "     ".length;
			var _g1470 = 0;
			var _g570 = l469;
			while(_g1470 < _g570) {
				var i470 = _g1470++;
				var no469 = "     ".charCodeAt(i470);
				if(no469 == null) {
					break;
				}
				var v469;
				switch(no469) {
				case 32:
					v469 = false;
					break;
				case 42:
					v469 = true;
					break;
				case 48:
					v469 = false;
					break;
				case 49:
					v469 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i470)));
				}
				switch(i470 - (l469 - 8)) {
				case 0:
					if(v469) {
						bs469 |= 128;
					} else {
						bs469 &= -129;
					}
					break;
				case 1:
					if(v469) {
						bs469 |= 64;
					} else {
						bs469 &= -65;
					}
					break;
				case 2:
					if(v469) {
						bs469 |= 32;
					} else {
						bs469 &= -33;
					}
					break;
				case 3:
					if(v469) {
						bs469 |= 16;
					} else {
						bs469 &= -17;
					}
					break;
				case 4:
					if(v469) {
						bs469 |= 8;
					} else {
						bs469 &= -9;
					}
					break;
				case 5:
					if(v469) {
						bs469 |= 4;
					} else {
						bs469 &= -5;
					}
					break;
				case 6:
					if(v469) {
						bs469 |= 2;
					} else {
						bs469 &= -3;
					}
					break;
				case 7:
					if(v469) {
						bs469 |= 1;
					} else {
						bs469 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs469;
			var this471 = 0;
			var bs470 = this471;
			var l470 = "     ".length;
			var _g1471 = 0;
			var _g571 = l470;
			while(_g1471 < _g571) {
				var i471 = _g1471++;
				var no470 = "     ".charCodeAt(i471);
				if(no470 == null) {
					break;
				}
				var v470;
				switch(no470) {
				case 32:
					v470 = false;
					break;
				case 42:
					v470 = true;
					break;
				case 48:
					v470 = false;
					break;
				case 49:
					v470 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i471)));
				}
				switch(i471 - (l470 - 8)) {
				case 0:
					if(v470) {
						bs470 |= 128;
					} else {
						bs470 &= -129;
					}
					break;
				case 1:
					if(v470) {
						bs470 |= 64;
					} else {
						bs470 &= -65;
					}
					break;
				case 2:
					if(v470) {
						bs470 |= 32;
					} else {
						bs470 &= -33;
					}
					break;
				case 3:
					if(v470) {
						bs470 |= 16;
					} else {
						bs470 &= -17;
					}
					break;
				case 4:
					if(v470) {
						bs470 |= 8;
					} else {
						bs470 &= -9;
					}
					break;
				case 5:
					if(v470) {
						bs470 |= 4;
					} else {
						bs470 &= -5;
					}
					break;
				case 6:
					if(v470) {
						bs470 |= 2;
					} else {
						bs470 &= -3;
					}
					break;
				case 7:
					if(v470) {
						bs470 |= 1;
					} else {
						bs470 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs470;
			var this472 = 0;
			var bs471 = this472;
			var l471 = " *** ".length;
			var _g1472 = 0;
			var _g572 = l471;
			while(_g1472 < _g572) {
				var i472 = _g1472++;
				var no471 = " *** ".charCodeAt(i472);
				if(no471 == null) {
					break;
				}
				var v471;
				switch(no471) {
				case 32:
					v471 = false;
					break;
				case 42:
					v471 = true;
					break;
				case 48:
					v471 = false;
					break;
				case 49:
					v471 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i472)));
				}
				switch(i472 - (l471 - 8)) {
				case 0:
					if(v471) {
						bs471 |= 128;
					} else {
						bs471 &= -129;
					}
					break;
				case 1:
					if(v471) {
						bs471 |= 64;
					} else {
						bs471 &= -65;
					}
					break;
				case 2:
					if(v471) {
						bs471 |= 32;
					} else {
						bs471 &= -33;
					}
					break;
				case 3:
					if(v471) {
						bs471 |= 16;
					} else {
						bs471 &= -17;
					}
					break;
				case 4:
					if(v471) {
						bs471 |= 8;
					} else {
						bs471 &= -9;
					}
					break;
				case 5:
					if(v471) {
						bs471 |= 4;
					} else {
						bs471 &= -5;
					}
					break;
				case 6:
					if(v471) {
						bs471 |= 2;
					} else {
						bs471 &= -3;
					}
					break;
				case 7:
					if(v471) {
						bs471 |= 1;
					} else {
						bs471 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs471;
			var this473 = 0;
			var bs472 = this473;
			var l472 = "*    ".length;
			var _g1473 = 0;
			var _g573 = l472;
			while(_g1473 < _g573) {
				var i473 = _g1473++;
				var no472 = "*    ".charCodeAt(i473);
				if(no472 == null) {
					break;
				}
				var v472;
				switch(no472) {
				case 32:
					v472 = false;
					break;
				case 42:
					v472 = true;
					break;
				case 48:
					v472 = false;
					break;
				case 49:
					v472 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i473)));
				}
				switch(i473 - (l472 - 8)) {
				case 0:
					if(v472) {
						bs472 |= 128;
					} else {
						bs472 &= -129;
					}
					break;
				case 1:
					if(v472) {
						bs472 |= 64;
					} else {
						bs472 &= -65;
					}
					break;
				case 2:
					if(v472) {
						bs472 |= 32;
					} else {
						bs472 &= -33;
					}
					break;
				case 3:
					if(v472) {
						bs472 |= 16;
					} else {
						bs472 &= -17;
					}
					break;
				case 4:
					if(v472) {
						bs472 |= 8;
					} else {
						bs472 &= -9;
					}
					break;
				case 5:
					if(v472) {
						bs472 |= 4;
					} else {
						bs472 &= -5;
					}
					break;
				case 6:
					if(v472) {
						bs472 |= 2;
					} else {
						bs472 &= -3;
					}
					break;
				case 7:
					if(v472) {
						bs472 |= 1;
					} else {
						bs472 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs472;
			var this474 = 0;
			var bs473 = this474;
			var l473 = "*    ".length;
			var _g1474 = 0;
			var _g574 = l473;
			while(_g1474 < _g574) {
				var i474 = _g1474++;
				var no473 = "*    ".charCodeAt(i474);
				if(no473 == null) {
					break;
				}
				var v473;
				switch(no473) {
				case 32:
					v473 = false;
					break;
				case 42:
					v473 = true;
					break;
				case 48:
					v473 = false;
					break;
				case 49:
					v473 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i474)));
				}
				switch(i474 - (l473 - 8)) {
				case 0:
					if(v473) {
						bs473 |= 128;
					} else {
						bs473 &= -129;
					}
					break;
				case 1:
					if(v473) {
						bs473 |= 64;
					} else {
						bs473 &= -65;
					}
					break;
				case 2:
					if(v473) {
						bs473 |= 32;
					} else {
						bs473 &= -33;
					}
					break;
				case 3:
					if(v473) {
						bs473 |= 16;
					} else {
						bs473 &= -17;
					}
					break;
				case 4:
					if(v473) {
						bs473 |= 8;
					} else {
						bs473 &= -9;
					}
					break;
				case 5:
					if(v473) {
						bs473 |= 4;
					} else {
						bs473 &= -5;
					}
					break;
				case 6:
					if(v473) {
						bs473 |= 2;
					} else {
						bs473 &= -3;
					}
					break;
				case 7:
					if(v473) {
						bs473 |= 1;
					} else {
						bs473 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs473;
			var this475 = 0;
			var bs474 = this475;
			var l474 = "*   *".length;
			var _g1475 = 0;
			var _g575 = l474;
			while(_g1475 < _g575) {
				var i475 = _g1475++;
				var no474 = "*   *".charCodeAt(i475);
				if(no474 == null) {
					break;
				}
				var v474;
				switch(no474) {
				case 32:
					v474 = false;
					break;
				case 42:
					v474 = true;
					break;
				case 48:
					v474 = false;
					break;
				case 49:
					v474 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i475)));
				}
				switch(i475 - (l474 - 8)) {
				case 0:
					if(v474) {
						bs474 |= 128;
					} else {
						bs474 &= -129;
					}
					break;
				case 1:
					if(v474) {
						bs474 |= 64;
					} else {
						bs474 &= -65;
					}
					break;
				case 2:
					if(v474) {
						bs474 |= 32;
					} else {
						bs474 &= -33;
					}
					break;
				case 3:
					if(v474) {
						bs474 |= 16;
					} else {
						bs474 &= -17;
					}
					break;
				case 4:
					if(v474) {
						bs474 |= 8;
					} else {
						bs474 &= -9;
					}
					break;
				case 5:
					if(v474) {
						bs474 |= 4;
					} else {
						bs474 &= -5;
					}
					break;
				case 6:
					if(v474) {
						bs474 |= 2;
					} else {
						bs474 &= -3;
					}
					break;
				case 7:
					if(v474) {
						bs474 |= 1;
					} else {
						bs474 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs474;
			var this476 = 0;
			var bs475 = this476;
			var l475 = " *** ".length;
			var _g1476 = 0;
			var _g576 = l475;
			while(_g1476 < _g576) {
				var i476 = _g1476++;
				var no475 = " *** ".charCodeAt(i476);
				if(no475 == null) {
					break;
				}
				var v475;
				switch(no475) {
				case 32:
					v475 = false;
					break;
				case 42:
					v475 = true;
					break;
				case 48:
					v475 = false;
					break;
				case 49:
					v475 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i476)));
				}
				switch(i476 - (l475 - 8)) {
				case 0:
					if(v475) {
						bs475 |= 128;
					} else {
						bs475 &= -129;
					}
					break;
				case 1:
					if(v475) {
						bs475 |= 64;
					} else {
						bs475 &= -65;
					}
					break;
				case 2:
					if(v475) {
						bs475 |= 32;
					} else {
						bs475 &= -33;
					}
					break;
				case 3:
					if(v475) {
						bs475 |= 16;
					} else {
						bs475 &= -17;
					}
					break;
				case 4:
					if(v475) {
						bs475 |= 8;
					} else {
						bs475 &= -9;
					}
					break;
				case 5:
					if(v475) {
						bs475 |= 4;
					} else {
						bs475 &= -5;
					}
					break;
				case 6:
					if(v475) {
						bs475 |= 2;
					} else {
						bs475 &= -3;
					}
					break;
				case 7:
					if(v475) {
						bs475 |= 1;
					} else {
						bs475 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs475;
			break;
		case 100:
			var this477 = 0;
			var bs476 = this477;
			var l476 = "    *".length;
			var _g1477 = 0;
			var _g577 = l476;
			while(_g1477 < _g577) {
				var i477 = _g1477++;
				var no476 = "    *".charCodeAt(i477);
				if(no476 == null) {
					break;
				}
				var v476;
				switch(no476) {
				case 32:
					v476 = false;
					break;
				case 42:
					v476 = true;
					break;
				case 48:
					v476 = false;
					break;
				case 49:
					v476 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i477)));
				}
				switch(i477 - (l476 - 8)) {
				case 0:
					if(v476) {
						bs476 |= 128;
					} else {
						bs476 &= -129;
					}
					break;
				case 1:
					if(v476) {
						bs476 |= 64;
					} else {
						bs476 &= -65;
					}
					break;
				case 2:
					if(v476) {
						bs476 |= 32;
					} else {
						bs476 &= -33;
					}
					break;
				case 3:
					if(v476) {
						bs476 |= 16;
					} else {
						bs476 &= -17;
					}
					break;
				case 4:
					if(v476) {
						bs476 |= 8;
					} else {
						bs476 &= -9;
					}
					break;
				case 5:
					if(v476) {
						bs476 |= 4;
					} else {
						bs476 &= -5;
					}
					break;
				case 6:
					if(v476) {
						bs476 |= 2;
					} else {
						bs476 &= -3;
					}
					break;
				case 7:
					if(v476) {
						bs476 |= 1;
					} else {
						bs476 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs476;
			var this478 = 0;
			var bs477 = this478;
			var l477 = "    *".length;
			var _g1478 = 0;
			var _g578 = l477;
			while(_g1478 < _g578) {
				var i478 = _g1478++;
				var no477 = "    *".charCodeAt(i478);
				if(no477 == null) {
					break;
				}
				var v477;
				switch(no477) {
				case 32:
					v477 = false;
					break;
				case 42:
					v477 = true;
					break;
				case 48:
					v477 = false;
					break;
				case 49:
					v477 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i478)));
				}
				switch(i478 - (l477 - 8)) {
				case 0:
					if(v477) {
						bs477 |= 128;
					} else {
						bs477 &= -129;
					}
					break;
				case 1:
					if(v477) {
						bs477 |= 64;
					} else {
						bs477 &= -65;
					}
					break;
				case 2:
					if(v477) {
						bs477 |= 32;
					} else {
						bs477 &= -33;
					}
					break;
				case 3:
					if(v477) {
						bs477 |= 16;
					} else {
						bs477 &= -17;
					}
					break;
				case 4:
					if(v477) {
						bs477 |= 8;
					} else {
						bs477 &= -9;
					}
					break;
				case 5:
					if(v477) {
						bs477 |= 4;
					} else {
						bs477 &= -5;
					}
					break;
				case 6:
					if(v477) {
						bs477 |= 2;
					} else {
						bs477 &= -3;
					}
					break;
				case 7:
					if(v477) {
						bs477 |= 1;
					} else {
						bs477 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs477;
			var this479 = 0;
			var bs478 = this479;
			var l478 = " ** *".length;
			var _g1479 = 0;
			var _g579 = l478;
			while(_g1479 < _g579) {
				var i479 = _g1479++;
				var no478 = " ** *".charCodeAt(i479);
				if(no478 == null) {
					break;
				}
				var v478;
				switch(no478) {
				case 32:
					v478 = false;
					break;
				case 42:
					v478 = true;
					break;
				case 48:
					v478 = false;
					break;
				case 49:
					v478 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i479)));
				}
				switch(i479 - (l478 - 8)) {
				case 0:
					if(v478) {
						bs478 |= 128;
					} else {
						bs478 &= -129;
					}
					break;
				case 1:
					if(v478) {
						bs478 |= 64;
					} else {
						bs478 &= -65;
					}
					break;
				case 2:
					if(v478) {
						bs478 |= 32;
					} else {
						bs478 &= -33;
					}
					break;
				case 3:
					if(v478) {
						bs478 |= 16;
					} else {
						bs478 &= -17;
					}
					break;
				case 4:
					if(v478) {
						bs478 |= 8;
					} else {
						bs478 &= -9;
					}
					break;
				case 5:
					if(v478) {
						bs478 |= 4;
					} else {
						bs478 &= -5;
					}
					break;
				case 6:
					if(v478) {
						bs478 |= 2;
					} else {
						bs478 &= -3;
					}
					break;
				case 7:
					if(v478) {
						bs478 |= 1;
					} else {
						bs478 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs478;
			var this480 = 0;
			var bs479 = this480;
			var l479 = "*  **".length;
			var _g1480 = 0;
			var _g580 = l479;
			while(_g1480 < _g580) {
				var i480 = _g1480++;
				var no479 = "*  **".charCodeAt(i480);
				if(no479 == null) {
					break;
				}
				var v479;
				switch(no479) {
				case 32:
					v479 = false;
					break;
				case 42:
					v479 = true;
					break;
				case 48:
					v479 = false;
					break;
				case 49:
					v479 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  **".charCodeAt(i480)));
				}
				switch(i480 - (l479 - 8)) {
				case 0:
					if(v479) {
						bs479 |= 128;
					} else {
						bs479 &= -129;
					}
					break;
				case 1:
					if(v479) {
						bs479 |= 64;
					} else {
						bs479 &= -65;
					}
					break;
				case 2:
					if(v479) {
						bs479 |= 32;
					} else {
						bs479 &= -33;
					}
					break;
				case 3:
					if(v479) {
						bs479 |= 16;
					} else {
						bs479 &= -17;
					}
					break;
				case 4:
					if(v479) {
						bs479 |= 8;
					} else {
						bs479 &= -9;
					}
					break;
				case 5:
					if(v479) {
						bs479 |= 4;
					} else {
						bs479 &= -5;
					}
					break;
				case 6:
					if(v479) {
						bs479 |= 2;
					} else {
						bs479 &= -3;
					}
					break;
				case 7:
					if(v479) {
						bs479 |= 1;
					} else {
						bs479 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs479;
			var this481 = 0;
			var bs480 = this481;
			var l480 = "*   *".length;
			var _g1481 = 0;
			var _g581 = l480;
			while(_g1481 < _g581) {
				var i481 = _g1481++;
				var no480 = "*   *".charCodeAt(i481);
				if(no480 == null) {
					break;
				}
				var v480;
				switch(no480) {
				case 32:
					v480 = false;
					break;
				case 42:
					v480 = true;
					break;
				case 48:
					v480 = false;
					break;
				case 49:
					v480 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i481)));
				}
				switch(i481 - (l480 - 8)) {
				case 0:
					if(v480) {
						bs480 |= 128;
					} else {
						bs480 &= -129;
					}
					break;
				case 1:
					if(v480) {
						bs480 |= 64;
					} else {
						bs480 &= -65;
					}
					break;
				case 2:
					if(v480) {
						bs480 |= 32;
					} else {
						bs480 &= -33;
					}
					break;
				case 3:
					if(v480) {
						bs480 |= 16;
					} else {
						bs480 &= -17;
					}
					break;
				case 4:
					if(v480) {
						bs480 |= 8;
					} else {
						bs480 &= -9;
					}
					break;
				case 5:
					if(v480) {
						bs480 |= 4;
					} else {
						bs480 &= -5;
					}
					break;
				case 6:
					if(v480) {
						bs480 |= 2;
					} else {
						bs480 &= -3;
					}
					break;
				case 7:
					if(v480) {
						bs480 |= 1;
					} else {
						bs480 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs480;
			var this482 = 0;
			var bs481 = this482;
			var l481 = "*   *".length;
			var _g1482 = 0;
			var _g582 = l481;
			while(_g1482 < _g582) {
				var i482 = _g1482++;
				var no481 = "*   *".charCodeAt(i482);
				if(no481 == null) {
					break;
				}
				var v481;
				switch(no481) {
				case 32:
					v481 = false;
					break;
				case 42:
					v481 = true;
					break;
				case 48:
					v481 = false;
					break;
				case 49:
					v481 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i482)));
				}
				switch(i482 - (l481 - 8)) {
				case 0:
					if(v481) {
						bs481 |= 128;
					} else {
						bs481 &= -129;
					}
					break;
				case 1:
					if(v481) {
						bs481 |= 64;
					} else {
						bs481 &= -65;
					}
					break;
				case 2:
					if(v481) {
						bs481 |= 32;
					} else {
						bs481 &= -33;
					}
					break;
				case 3:
					if(v481) {
						bs481 |= 16;
					} else {
						bs481 &= -17;
					}
					break;
				case 4:
					if(v481) {
						bs481 |= 8;
					} else {
						bs481 &= -9;
					}
					break;
				case 5:
					if(v481) {
						bs481 |= 4;
					} else {
						bs481 &= -5;
					}
					break;
				case 6:
					if(v481) {
						bs481 |= 2;
					} else {
						bs481 &= -3;
					}
					break;
				case 7:
					if(v481) {
						bs481 |= 1;
					} else {
						bs481 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs481;
			var this483 = 0;
			var bs482 = this483;
			var l482 = " ****".length;
			var _g1483 = 0;
			var _g583 = l482;
			while(_g1483 < _g583) {
				var i483 = _g1483++;
				var no482 = " ****".charCodeAt(i483);
				if(no482 == null) {
					break;
				}
				var v482;
				switch(no482) {
				case 32:
					v482 = false;
					break;
				case 42:
					v482 = true;
					break;
				case 48:
					v482 = false;
					break;
				case 49:
					v482 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i483)));
				}
				switch(i483 - (l482 - 8)) {
				case 0:
					if(v482) {
						bs482 |= 128;
					} else {
						bs482 &= -129;
					}
					break;
				case 1:
					if(v482) {
						bs482 |= 64;
					} else {
						bs482 &= -65;
					}
					break;
				case 2:
					if(v482) {
						bs482 |= 32;
					} else {
						bs482 &= -33;
					}
					break;
				case 3:
					if(v482) {
						bs482 |= 16;
					} else {
						bs482 &= -17;
					}
					break;
				case 4:
					if(v482) {
						bs482 |= 8;
					} else {
						bs482 &= -9;
					}
					break;
				case 5:
					if(v482) {
						bs482 |= 4;
					} else {
						bs482 &= -5;
					}
					break;
				case 6:
					if(v482) {
						bs482 |= 2;
					} else {
						bs482 &= -3;
					}
					break;
				case 7:
					if(v482) {
						bs482 |= 1;
					} else {
						bs482 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs482;
			break;
		case 101:
			var this484 = 0;
			var bs483 = this484;
			var l483 = "     ".length;
			var _g1484 = 0;
			var _g584 = l483;
			while(_g1484 < _g584) {
				var i484 = _g1484++;
				var no483 = "     ".charCodeAt(i484);
				if(no483 == null) {
					break;
				}
				var v483;
				switch(no483) {
				case 32:
					v483 = false;
					break;
				case 42:
					v483 = true;
					break;
				case 48:
					v483 = false;
					break;
				case 49:
					v483 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i484)));
				}
				switch(i484 - (l483 - 8)) {
				case 0:
					if(v483) {
						bs483 |= 128;
					} else {
						bs483 &= -129;
					}
					break;
				case 1:
					if(v483) {
						bs483 |= 64;
					} else {
						bs483 &= -65;
					}
					break;
				case 2:
					if(v483) {
						bs483 |= 32;
					} else {
						bs483 &= -33;
					}
					break;
				case 3:
					if(v483) {
						bs483 |= 16;
					} else {
						bs483 &= -17;
					}
					break;
				case 4:
					if(v483) {
						bs483 |= 8;
					} else {
						bs483 &= -9;
					}
					break;
				case 5:
					if(v483) {
						bs483 |= 4;
					} else {
						bs483 &= -5;
					}
					break;
				case 6:
					if(v483) {
						bs483 |= 2;
					} else {
						bs483 &= -3;
					}
					break;
				case 7:
					if(v483) {
						bs483 |= 1;
					} else {
						bs483 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs483;
			var this485 = 0;
			var bs484 = this485;
			var l484 = "     ".length;
			var _g1485 = 0;
			var _g585 = l484;
			while(_g1485 < _g585) {
				var i485 = _g1485++;
				var no484 = "     ".charCodeAt(i485);
				if(no484 == null) {
					break;
				}
				var v484;
				switch(no484) {
				case 32:
					v484 = false;
					break;
				case 42:
					v484 = true;
					break;
				case 48:
					v484 = false;
					break;
				case 49:
					v484 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i485)));
				}
				switch(i485 - (l484 - 8)) {
				case 0:
					if(v484) {
						bs484 |= 128;
					} else {
						bs484 &= -129;
					}
					break;
				case 1:
					if(v484) {
						bs484 |= 64;
					} else {
						bs484 &= -65;
					}
					break;
				case 2:
					if(v484) {
						bs484 |= 32;
					} else {
						bs484 &= -33;
					}
					break;
				case 3:
					if(v484) {
						bs484 |= 16;
					} else {
						bs484 &= -17;
					}
					break;
				case 4:
					if(v484) {
						bs484 |= 8;
					} else {
						bs484 &= -9;
					}
					break;
				case 5:
					if(v484) {
						bs484 |= 4;
					} else {
						bs484 &= -5;
					}
					break;
				case 6:
					if(v484) {
						bs484 |= 2;
					} else {
						bs484 &= -3;
					}
					break;
				case 7:
					if(v484) {
						bs484 |= 1;
					} else {
						bs484 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs484;
			var this486 = 0;
			var bs485 = this486;
			var l485 = " *** ".length;
			var _g1486 = 0;
			var _g586 = l485;
			while(_g1486 < _g586) {
				var i486 = _g1486++;
				var no485 = " *** ".charCodeAt(i486);
				if(no485 == null) {
					break;
				}
				var v485;
				switch(no485) {
				case 32:
					v485 = false;
					break;
				case 42:
					v485 = true;
					break;
				case 48:
					v485 = false;
					break;
				case 49:
					v485 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i486)));
				}
				switch(i486 - (l485 - 8)) {
				case 0:
					if(v485) {
						bs485 |= 128;
					} else {
						bs485 &= -129;
					}
					break;
				case 1:
					if(v485) {
						bs485 |= 64;
					} else {
						bs485 &= -65;
					}
					break;
				case 2:
					if(v485) {
						bs485 |= 32;
					} else {
						bs485 &= -33;
					}
					break;
				case 3:
					if(v485) {
						bs485 |= 16;
					} else {
						bs485 &= -17;
					}
					break;
				case 4:
					if(v485) {
						bs485 |= 8;
					} else {
						bs485 &= -9;
					}
					break;
				case 5:
					if(v485) {
						bs485 |= 4;
					} else {
						bs485 &= -5;
					}
					break;
				case 6:
					if(v485) {
						bs485 |= 2;
					} else {
						bs485 &= -3;
					}
					break;
				case 7:
					if(v485) {
						bs485 |= 1;
					} else {
						bs485 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs485;
			var this487 = 0;
			var bs486 = this487;
			var l486 = "*   *".length;
			var _g1487 = 0;
			var _g587 = l486;
			while(_g1487 < _g587) {
				var i487 = _g1487++;
				var no486 = "*   *".charCodeAt(i487);
				if(no486 == null) {
					break;
				}
				var v486;
				switch(no486) {
				case 32:
					v486 = false;
					break;
				case 42:
					v486 = true;
					break;
				case 48:
					v486 = false;
					break;
				case 49:
					v486 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i487)));
				}
				switch(i487 - (l486 - 8)) {
				case 0:
					if(v486) {
						bs486 |= 128;
					} else {
						bs486 &= -129;
					}
					break;
				case 1:
					if(v486) {
						bs486 |= 64;
					} else {
						bs486 &= -65;
					}
					break;
				case 2:
					if(v486) {
						bs486 |= 32;
					} else {
						bs486 &= -33;
					}
					break;
				case 3:
					if(v486) {
						bs486 |= 16;
					} else {
						bs486 &= -17;
					}
					break;
				case 4:
					if(v486) {
						bs486 |= 8;
					} else {
						bs486 &= -9;
					}
					break;
				case 5:
					if(v486) {
						bs486 |= 4;
					} else {
						bs486 &= -5;
					}
					break;
				case 6:
					if(v486) {
						bs486 |= 2;
					} else {
						bs486 &= -3;
					}
					break;
				case 7:
					if(v486) {
						bs486 |= 1;
					} else {
						bs486 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs486;
			var this488 = 0;
			var bs487 = this488;
			var l487 = "*****".length;
			var _g1488 = 0;
			var _g588 = l487;
			while(_g1488 < _g588) {
				var i488 = _g1488++;
				var no487 = "*****".charCodeAt(i488);
				if(no487 == null) {
					break;
				}
				var v487;
				switch(no487) {
				case 32:
					v487 = false;
					break;
				case 42:
					v487 = true;
					break;
				case 48:
					v487 = false;
					break;
				case 49:
					v487 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i488)));
				}
				switch(i488 - (l487 - 8)) {
				case 0:
					if(v487) {
						bs487 |= 128;
					} else {
						bs487 &= -129;
					}
					break;
				case 1:
					if(v487) {
						bs487 |= 64;
					} else {
						bs487 &= -65;
					}
					break;
				case 2:
					if(v487) {
						bs487 |= 32;
					} else {
						bs487 &= -33;
					}
					break;
				case 3:
					if(v487) {
						bs487 |= 16;
					} else {
						bs487 &= -17;
					}
					break;
				case 4:
					if(v487) {
						bs487 |= 8;
					} else {
						bs487 &= -9;
					}
					break;
				case 5:
					if(v487) {
						bs487 |= 4;
					} else {
						bs487 &= -5;
					}
					break;
				case 6:
					if(v487) {
						bs487 |= 2;
					} else {
						bs487 &= -3;
					}
					break;
				case 7:
					if(v487) {
						bs487 |= 1;
					} else {
						bs487 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs487;
			var this489 = 0;
			var bs488 = this489;
			var l488 = "*    ".length;
			var _g1489 = 0;
			var _g589 = l488;
			while(_g1489 < _g589) {
				var i489 = _g1489++;
				var no488 = "*    ".charCodeAt(i489);
				if(no488 == null) {
					break;
				}
				var v488;
				switch(no488) {
				case 32:
					v488 = false;
					break;
				case 42:
					v488 = true;
					break;
				case 48:
					v488 = false;
					break;
				case 49:
					v488 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i489)));
				}
				switch(i489 - (l488 - 8)) {
				case 0:
					if(v488) {
						bs488 |= 128;
					} else {
						bs488 &= -129;
					}
					break;
				case 1:
					if(v488) {
						bs488 |= 64;
					} else {
						bs488 &= -65;
					}
					break;
				case 2:
					if(v488) {
						bs488 |= 32;
					} else {
						bs488 &= -33;
					}
					break;
				case 3:
					if(v488) {
						bs488 |= 16;
					} else {
						bs488 &= -17;
					}
					break;
				case 4:
					if(v488) {
						bs488 |= 8;
					} else {
						bs488 &= -9;
					}
					break;
				case 5:
					if(v488) {
						bs488 |= 4;
					} else {
						bs488 &= -5;
					}
					break;
				case 6:
					if(v488) {
						bs488 |= 2;
					} else {
						bs488 &= -3;
					}
					break;
				case 7:
					if(v488) {
						bs488 |= 1;
					} else {
						bs488 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs488;
			var this490 = 0;
			var bs489 = this490;
			var l489 = " *** ".length;
			var _g1490 = 0;
			var _g590 = l489;
			while(_g1490 < _g590) {
				var i490 = _g1490++;
				var no489 = " *** ".charCodeAt(i490);
				if(no489 == null) {
					break;
				}
				var v489;
				switch(no489) {
				case 32:
					v489 = false;
					break;
				case 42:
					v489 = true;
					break;
				case 48:
					v489 = false;
					break;
				case 49:
					v489 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i490)));
				}
				switch(i490 - (l489 - 8)) {
				case 0:
					if(v489) {
						bs489 |= 128;
					} else {
						bs489 &= -129;
					}
					break;
				case 1:
					if(v489) {
						bs489 |= 64;
					} else {
						bs489 &= -65;
					}
					break;
				case 2:
					if(v489) {
						bs489 |= 32;
					} else {
						bs489 &= -33;
					}
					break;
				case 3:
					if(v489) {
						bs489 |= 16;
					} else {
						bs489 &= -17;
					}
					break;
				case 4:
					if(v489) {
						bs489 |= 8;
					} else {
						bs489 &= -9;
					}
					break;
				case 5:
					if(v489) {
						bs489 |= 4;
					} else {
						bs489 &= -5;
					}
					break;
				case 6:
					if(v489) {
						bs489 |= 2;
					} else {
						bs489 &= -3;
					}
					break;
				case 7:
					if(v489) {
						bs489 |= 1;
					} else {
						bs489 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs489;
			break;
		case 102:
			var this491 = 0;
			var bs490 = this491;
			var l490 = "  ** ".length;
			var _g1491 = 0;
			var _g591 = l490;
			while(_g1491 < _g591) {
				var i491 = _g1491++;
				var no490 = "  ** ".charCodeAt(i491);
				if(no490 == null) {
					break;
				}
				var v490;
				switch(no490) {
				case 32:
					v490 = false;
					break;
				case 42:
					v490 = true;
					break;
				case 48:
					v490 = false;
					break;
				case 49:
					v490 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i491)));
				}
				switch(i491 - (l490 - 8)) {
				case 0:
					if(v490) {
						bs490 |= 128;
					} else {
						bs490 &= -129;
					}
					break;
				case 1:
					if(v490) {
						bs490 |= 64;
					} else {
						bs490 &= -65;
					}
					break;
				case 2:
					if(v490) {
						bs490 |= 32;
					} else {
						bs490 &= -33;
					}
					break;
				case 3:
					if(v490) {
						bs490 |= 16;
					} else {
						bs490 &= -17;
					}
					break;
				case 4:
					if(v490) {
						bs490 |= 8;
					} else {
						bs490 &= -9;
					}
					break;
				case 5:
					if(v490) {
						bs490 |= 4;
					} else {
						bs490 &= -5;
					}
					break;
				case 6:
					if(v490) {
						bs490 |= 2;
					} else {
						bs490 &= -3;
					}
					break;
				case 7:
					if(v490) {
						bs490 |= 1;
					} else {
						bs490 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs490;
			var this492 = 0;
			var bs491 = this492;
			var l491 = " *  *".length;
			var _g1492 = 0;
			var _g592 = l491;
			while(_g1492 < _g592) {
				var i492 = _g1492++;
				var no491 = " *  *".charCodeAt(i492);
				if(no491 == null) {
					break;
				}
				var v491;
				switch(no491) {
				case 32:
					v491 = false;
					break;
				case 42:
					v491 = true;
					break;
				case 48:
					v491 = false;
					break;
				case 49:
					v491 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *  *".charCodeAt(i492)));
				}
				switch(i492 - (l491 - 8)) {
				case 0:
					if(v491) {
						bs491 |= 128;
					} else {
						bs491 &= -129;
					}
					break;
				case 1:
					if(v491) {
						bs491 |= 64;
					} else {
						bs491 &= -65;
					}
					break;
				case 2:
					if(v491) {
						bs491 |= 32;
					} else {
						bs491 &= -33;
					}
					break;
				case 3:
					if(v491) {
						bs491 |= 16;
					} else {
						bs491 &= -17;
					}
					break;
				case 4:
					if(v491) {
						bs491 |= 8;
					} else {
						bs491 &= -9;
					}
					break;
				case 5:
					if(v491) {
						bs491 |= 4;
					} else {
						bs491 &= -5;
					}
					break;
				case 6:
					if(v491) {
						bs491 |= 2;
					} else {
						bs491 &= -3;
					}
					break;
				case 7:
					if(v491) {
						bs491 |= 1;
					} else {
						bs491 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs491;
			var this493 = 0;
			var bs492 = this493;
			var l492 = " *   ".length;
			var _g1493 = 0;
			var _g593 = l492;
			while(_g1493 < _g593) {
				var i493 = _g1493++;
				var no492 = " *   ".charCodeAt(i493);
				if(no492 == null) {
					break;
				}
				var v492;
				switch(no492) {
				case 32:
					v492 = false;
					break;
				case 42:
					v492 = true;
					break;
				case 48:
					v492 = false;
					break;
				case 49:
					v492 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i493)));
				}
				switch(i493 - (l492 - 8)) {
				case 0:
					if(v492) {
						bs492 |= 128;
					} else {
						bs492 &= -129;
					}
					break;
				case 1:
					if(v492) {
						bs492 |= 64;
					} else {
						bs492 &= -65;
					}
					break;
				case 2:
					if(v492) {
						bs492 |= 32;
					} else {
						bs492 &= -33;
					}
					break;
				case 3:
					if(v492) {
						bs492 |= 16;
					} else {
						bs492 &= -17;
					}
					break;
				case 4:
					if(v492) {
						bs492 |= 8;
					} else {
						bs492 &= -9;
					}
					break;
				case 5:
					if(v492) {
						bs492 |= 4;
					} else {
						bs492 &= -5;
					}
					break;
				case 6:
					if(v492) {
						bs492 |= 2;
					} else {
						bs492 &= -3;
					}
					break;
				case 7:
					if(v492) {
						bs492 |= 1;
					} else {
						bs492 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs492;
			var this494 = 0;
			var bs493 = this494;
			var l493 = "***  ".length;
			var _g1494 = 0;
			var _g594 = l493;
			while(_g1494 < _g594) {
				var i494 = _g1494++;
				var no493 = "***  ".charCodeAt(i494);
				if(no493 == null) {
					break;
				}
				var v493;
				switch(no493) {
				case 32:
					v493 = false;
					break;
				case 42:
					v493 = true;
					break;
				case 48:
					v493 = false;
					break;
				case 49:
					v493 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("***  ".charCodeAt(i494)));
				}
				switch(i494 - (l493 - 8)) {
				case 0:
					if(v493) {
						bs493 |= 128;
					} else {
						bs493 &= -129;
					}
					break;
				case 1:
					if(v493) {
						bs493 |= 64;
					} else {
						bs493 &= -65;
					}
					break;
				case 2:
					if(v493) {
						bs493 |= 32;
					} else {
						bs493 &= -33;
					}
					break;
				case 3:
					if(v493) {
						bs493 |= 16;
					} else {
						bs493 &= -17;
					}
					break;
				case 4:
					if(v493) {
						bs493 |= 8;
					} else {
						bs493 &= -9;
					}
					break;
				case 5:
					if(v493) {
						bs493 |= 4;
					} else {
						bs493 &= -5;
					}
					break;
				case 6:
					if(v493) {
						bs493 |= 2;
					} else {
						bs493 &= -3;
					}
					break;
				case 7:
					if(v493) {
						bs493 |= 1;
					} else {
						bs493 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs493;
			var this495 = 0;
			var bs494 = this495;
			var l494 = " *   ".length;
			var _g1495 = 0;
			var _g595 = l494;
			while(_g1495 < _g595) {
				var i495 = _g1495++;
				var no494 = " *   ".charCodeAt(i495);
				if(no494 == null) {
					break;
				}
				var v494;
				switch(no494) {
				case 32:
					v494 = false;
					break;
				case 42:
					v494 = true;
					break;
				case 48:
					v494 = false;
					break;
				case 49:
					v494 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i495)));
				}
				switch(i495 - (l494 - 8)) {
				case 0:
					if(v494) {
						bs494 |= 128;
					} else {
						bs494 &= -129;
					}
					break;
				case 1:
					if(v494) {
						bs494 |= 64;
					} else {
						bs494 &= -65;
					}
					break;
				case 2:
					if(v494) {
						bs494 |= 32;
					} else {
						bs494 &= -33;
					}
					break;
				case 3:
					if(v494) {
						bs494 |= 16;
					} else {
						bs494 &= -17;
					}
					break;
				case 4:
					if(v494) {
						bs494 |= 8;
					} else {
						bs494 &= -9;
					}
					break;
				case 5:
					if(v494) {
						bs494 |= 4;
					} else {
						bs494 &= -5;
					}
					break;
				case 6:
					if(v494) {
						bs494 |= 2;
					} else {
						bs494 &= -3;
					}
					break;
				case 7:
					if(v494) {
						bs494 |= 1;
					} else {
						bs494 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs494;
			var this496 = 0;
			var bs495 = this496;
			var l495 = " *   ".length;
			var _g1496 = 0;
			var _g596 = l495;
			while(_g1496 < _g596) {
				var i496 = _g1496++;
				var no495 = " *   ".charCodeAt(i496);
				if(no495 == null) {
					break;
				}
				var v495;
				switch(no495) {
				case 32:
					v495 = false;
					break;
				case 42:
					v495 = true;
					break;
				case 48:
					v495 = false;
					break;
				case 49:
					v495 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i496)));
				}
				switch(i496 - (l495 - 8)) {
				case 0:
					if(v495) {
						bs495 |= 128;
					} else {
						bs495 &= -129;
					}
					break;
				case 1:
					if(v495) {
						bs495 |= 64;
					} else {
						bs495 &= -65;
					}
					break;
				case 2:
					if(v495) {
						bs495 |= 32;
					} else {
						bs495 &= -33;
					}
					break;
				case 3:
					if(v495) {
						bs495 |= 16;
					} else {
						bs495 &= -17;
					}
					break;
				case 4:
					if(v495) {
						bs495 |= 8;
					} else {
						bs495 &= -9;
					}
					break;
				case 5:
					if(v495) {
						bs495 |= 4;
					} else {
						bs495 &= -5;
					}
					break;
				case 6:
					if(v495) {
						bs495 |= 2;
					} else {
						bs495 &= -3;
					}
					break;
				case 7:
					if(v495) {
						bs495 |= 1;
					} else {
						bs495 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs495;
			var this497 = 0;
			var bs496 = this497;
			var l496 = " *   ".length;
			var _g1497 = 0;
			var _g597 = l496;
			while(_g1497 < _g597) {
				var i497 = _g1497++;
				var no496 = " *   ".charCodeAt(i497);
				if(no496 == null) {
					break;
				}
				var v496;
				switch(no496) {
				case 32:
					v496 = false;
					break;
				case 42:
					v496 = true;
					break;
				case 48:
					v496 = false;
					break;
				case 49:
					v496 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i497)));
				}
				switch(i497 - (l496 - 8)) {
				case 0:
					if(v496) {
						bs496 |= 128;
					} else {
						bs496 &= -129;
					}
					break;
				case 1:
					if(v496) {
						bs496 |= 64;
					} else {
						bs496 &= -65;
					}
					break;
				case 2:
					if(v496) {
						bs496 |= 32;
					} else {
						bs496 &= -33;
					}
					break;
				case 3:
					if(v496) {
						bs496 |= 16;
					} else {
						bs496 &= -17;
					}
					break;
				case 4:
					if(v496) {
						bs496 |= 8;
					} else {
						bs496 &= -9;
					}
					break;
				case 5:
					if(v496) {
						bs496 |= 4;
					} else {
						bs496 &= -5;
					}
					break;
				case 6:
					if(v496) {
						bs496 |= 2;
					} else {
						bs496 &= -3;
					}
					break;
				case 7:
					if(v496) {
						bs496 |= 1;
					} else {
						bs496 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs496;
			break;
		case 103:
			var this498 = 0;
			var bs497 = this498;
			var l497 = "     ".length;
			var _g1498 = 0;
			var _g598 = l497;
			while(_g1498 < _g598) {
				var i498 = _g1498++;
				var no497 = "     ".charCodeAt(i498);
				if(no497 == null) {
					break;
				}
				var v497;
				switch(no497) {
				case 32:
					v497 = false;
					break;
				case 42:
					v497 = true;
					break;
				case 48:
					v497 = false;
					break;
				case 49:
					v497 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i498)));
				}
				switch(i498 - (l497 - 8)) {
				case 0:
					if(v497) {
						bs497 |= 128;
					} else {
						bs497 &= -129;
					}
					break;
				case 1:
					if(v497) {
						bs497 |= 64;
					} else {
						bs497 &= -65;
					}
					break;
				case 2:
					if(v497) {
						bs497 |= 32;
					} else {
						bs497 &= -33;
					}
					break;
				case 3:
					if(v497) {
						bs497 |= 16;
					} else {
						bs497 &= -17;
					}
					break;
				case 4:
					if(v497) {
						bs497 |= 8;
					} else {
						bs497 &= -9;
					}
					break;
				case 5:
					if(v497) {
						bs497 |= 4;
					} else {
						bs497 &= -5;
					}
					break;
				case 6:
					if(v497) {
						bs497 |= 2;
					} else {
						bs497 &= -3;
					}
					break;
				case 7:
					if(v497) {
						bs497 |= 1;
					} else {
						bs497 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs497;
			var this499 = 0;
			var bs498 = this499;
			var l498 = " ****".length;
			var _g1499 = 0;
			var _g599 = l498;
			while(_g1499 < _g599) {
				var i499 = _g1499++;
				var no498 = " ****".charCodeAt(i499);
				if(no498 == null) {
					break;
				}
				var v498;
				switch(no498) {
				case 32:
					v498 = false;
					break;
				case 42:
					v498 = true;
					break;
				case 48:
					v498 = false;
					break;
				case 49:
					v498 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i499)));
				}
				switch(i499 - (l498 - 8)) {
				case 0:
					if(v498) {
						bs498 |= 128;
					} else {
						bs498 &= -129;
					}
					break;
				case 1:
					if(v498) {
						bs498 |= 64;
					} else {
						bs498 &= -65;
					}
					break;
				case 2:
					if(v498) {
						bs498 |= 32;
					} else {
						bs498 &= -33;
					}
					break;
				case 3:
					if(v498) {
						bs498 |= 16;
					} else {
						bs498 &= -17;
					}
					break;
				case 4:
					if(v498) {
						bs498 |= 8;
					} else {
						bs498 &= -9;
					}
					break;
				case 5:
					if(v498) {
						bs498 |= 4;
					} else {
						bs498 &= -5;
					}
					break;
				case 6:
					if(v498) {
						bs498 |= 2;
					} else {
						bs498 &= -3;
					}
					break;
				case 7:
					if(v498) {
						bs498 |= 1;
					} else {
						bs498 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs498;
			var this500 = 0;
			var bs499 = this500;
			var l499 = "*   *".length;
			var _g1500 = 0;
			var _g600 = l499;
			while(_g1500 < _g600) {
				var i500 = _g1500++;
				var no499 = "*   *".charCodeAt(i500);
				if(no499 == null) {
					break;
				}
				var v499;
				switch(no499) {
				case 32:
					v499 = false;
					break;
				case 42:
					v499 = true;
					break;
				case 48:
					v499 = false;
					break;
				case 49:
					v499 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i500)));
				}
				switch(i500 - (l499 - 8)) {
				case 0:
					if(v499) {
						bs499 |= 128;
					} else {
						bs499 &= -129;
					}
					break;
				case 1:
					if(v499) {
						bs499 |= 64;
					} else {
						bs499 &= -65;
					}
					break;
				case 2:
					if(v499) {
						bs499 |= 32;
					} else {
						bs499 &= -33;
					}
					break;
				case 3:
					if(v499) {
						bs499 |= 16;
					} else {
						bs499 &= -17;
					}
					break;
				case 4:
					if(v499) {
						bs499 |= 8;
					} else {
						bs499 &= -9;
					}
					break;
				case 5:
					if(v499) {
						bs499 |= 4;
					} else {
						bs499 &= -5;
					}
					break;
				case 6:
					if(v499) {
						bs499 |= 2;
					} else {
						bs499 &= -3;
					}
					break;
				case 7:
					if(v499) {
						bs499 |= 1;
					} else {
						bs499 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs499;
			var this501 = 0;
			var bs500 = this501;
			var l500 = "*   *".length;
			var _g1501 = 0;
			var _g601 = l500;
			while(_g1501 < _g601) {
				var i501 = _g1501++;
				var no500 = "*   *".charCodeAt(i501);
				if(no500 == null) {
					break;
				}
				var v500;
				switch(no500) {
				case 32:
					v500 = false;
					break;
				case 42:
					v500 = true;
					break;
				case 48:
					v500 = false;
					break;
				case 49:
					v500 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i501)));
				}
				switch(i501 - (l500 - 8)) {
				case 0:
					if(v500) {
						bs500 |= 128;
					} else {
						bs500 &= -129;
					}
					break;
				case 1:
					if(v500) {
						bs500 |= 64;
					} else {
						bs500 &= -65;
					}
					break;
				case 2:
					if(v500) {
						bs500 |= 32;
					} else {
						bs500 &= -33;
					}
					break;
				case 3:
					if(v500) {
						bs500 |= 16;
					} else {
						bs500 &= -17;
					}
					break;
				case 4:
					if(v500) {
						bs500 |= 8;
					} else {
						bs500 &= -9;
					}
					break;
				case 5:
					if(v500) {
						bs500 |= 4;
					} else {
						bs500 &= -5;
					}
					break;
				case 6:
					if(v500) {
						bs500 |= 2;
					} else {
						bs500 &= -3;
					}
					break;
				case 7:
					if(v500) {
						bs500 |= 1;
					} else {
						bs500 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs500;
			var this502 = 0;
			var bs501 = this502;
			var l501 = " ****".length;
			var _g1502 = 0;
			var _g602 = l501;
			while(_g1502 < _g602) {
				var i502 = _g1502++;
				var no501 = " ****".charCodeAt(i502);
				if(no501 == null) {
					break;
				}
				var v501;
				switch(no501) {
				case 32:
					v501 = false;
					break;
				case 42:
					v501 = true;
					break;
				case 48:
					v501 = false;
					break;
				case 49:
					v501 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i502)));
				}
				switch(i502 - (l501 - 8)) {
				case 0:
					if(v501) {
						bs501 |= 128;
					} else {
						bs501 &= -129;
					}
					break;
				case 1:
					if(v501) {
						bs501 |= 64;
					} else {
						bs501 &= -65;
					}
					break;
				case 2:
					if(v501) {
						bs501 |= 32;
					} else {
						bs501 &= -33;
					}
					break;
				case 3:
					if(v501) {
						bs501 |= 16;
					} else {
						bs501 &= -17;
					}
					break;
				case 4:
					if(v501) {
						bs501 |= 8;
					} else {
						bs501 &= -9;
					}
					break;
				case 5:
					if(v501) {
						bs501 |= 4;
					} else {
						bs501 &= -5;
					}
					break;
				case 6:
					if(v501) {
						bs501 |= 2;
					} else {
						bs501 &= -3;
					}
					break;
				case 7:
					if(v501) {
						bs501 |= 1;
					} else {
						bs501 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs501;
			var this503 = 0;
			var bs502 = this503;
			var l502 = "    *".length;
			var _g1503 = 0;
			var _g603 = l502;
			while(_g1503 < _g603) {
				var i503 = _g1503++;
				var no502 = "    *".charCodeAt(i503);
				if(no502 == null) {
					break;
				}
				var v502;
				switch(no502) {
				case 32:
					v502 = false;
					break;
				case 42:
					v502 = true;
					break;
				case 48:
					v502 = false;
					break;
				case 49:
					v502 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i503)));
				}
				switch(i503 - (l502 - 8)) {
				case 0:
					if(v502) {
						bs502 |= 128;
					} else {
						bs502 &= -129;
					}
					break;
				case 1:
					if(v502) {
						bs502 |= 64;
					} else {
						bs502 &= -65;
					}
					break;
				case 2:
					if(v502) {
						bs502 |= 32;
					} else {
						bs502 &= -33;
					}
					break;
				case 3:
					if(v502) {
						bs502 |= 16;
					} else {
						bs502 &= -17;
					}
					break;
				case 4:
					if(v502) {
						bs502 |= 8;
					} else {
						bs502 &= -9;
					}
					break;
				case 5:
					if(v502) {
						bs502 |= 4;
					} else {
						bs502 &= -5;
					}
					break;
				case 6:
					if(v502) {
						bs502 |= 2;
					} else {
						bs502 &= -3;
					}
					break;
				case 7:
					if(v502) {
						bs502 |= 1;
					} else {
						bs502 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs502;
			var this504 = 0;
			var bs503 = this504;
			var l503 = " *** ".length;
			var _g1504 = 0;
			var _g604 = l503;
			while(_g1504 < _g604) {
				var i504 = _g1504++;
				var no503 = " *** ".charCodeAt(i504);
				if(no503 == null) {
					break;
				}
				var v503;
				switch(no503) {
				case 32:
					v503 = false;
					break;
				case 42:
					v503 = true;
					break;
				case 48:
					v503 = false;
					break;
				case 49:
					v503 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i504)));
				}
				switch(i504 - (l503 - 8)) {
				case 0:
					if(v503) {
						bs503 |= 128;
					} else {
						bs503 &= -129;
					}
					break;
				case 1:
					if(v503) {
						bs503 |= 64;
					} else {
						bs503 &= -65;
					}
					break;
				case 2:
					if(v503) {
						bs503 |= 32;
					} else {
						bs503 &= -33;
					}
					break;
				case 3:
					if(v503) {
						bs503 |= 16;
					} else {
						bs503 &= -17;
					}
					break;
				case 4:
					if(v503) {
						bs503 |= 8;
					} else {
						bs503 &= -9;
					}
					break;
				case 5:
					if(v503) {
						bs503 |= 4;
					} else {
						bs503 &= -5;
					}
					break;
				case 6:
					if(v503) {
						bs503 |= 2;
					} else {
						bs503 &= -3;
					}
					break;
				case 7:
					if(v503) {
						bs503 |= 1;
					} else {
						bs503 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs503;
			break;
		case 104:
			var this505 = 0;
			var bs504 = this505;
			var l504 = "*    ".length;
			var _g1505 = 0;
			var _g605 = l504;
			while(_g1505 < _g605) {
				var i505 = _g1505++;
				var no504 = "*    ".charCodeAt(i505);
				if(no504 == null) {
					break;
				}
				var v504;
				switch(no504) {
				case 32:
					v504 = false;
					break;
				case 42:
					v504 = true;
					break;
				case 48:
					v504 = false;
					break;
				case 49:
					v504 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i505)));
				}
				switch(i505 - (l504 - 8)) {
				case 0:
					if(v504) {
						bs504 |= 128;
					} else {
						bs504 &= -129;
					}
					break;
				case 1:
					if(v504) {
						bs504 |= 64;
					} else {
						bs504 &= -65;
					}
					break;
				case 2:
					if(v504) {
						bs504 |= 32;
					} else {
						bs504 &= -33;
					}
					break;
				case 3:
					if(v504) {
						bs504 |= 16;
					} else {
						bs504 &= -17;
					}
					break;
				case 4:
					if(v504) {
						bs504 |= 8;
					} else {
						bs504 &= -9;
					}
					break;
				case 5:
					if(v504) {
						bs504 |= 4;
					} else {
						bs504 &= -5;
					}
					break;
				case 6:
					if(v504) {
						bs504 |= 2;
					} else {
						bs504 &= -3;
					}
					break;
				case 7:
					if(v504) {
						bs504 |= 1;
					} else {
						bs504 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs504;
			var this506 = 0;
			var bs505 = this506;
			var l505 = "*    ".length;
			var _g1506 = 0;
			var _g606 = l505;
			while(_g1506 < _g606) {
				var i506 = _g1506++;
				var no505 = "*    ".charCodeAt(i506);
				if(no505 == null) {
					break;
				}
				var v505;
				switch(no505) {
				case 32:
					v505 = false;
					break;
				case 42:
					v505 = true;
					break;
				case 48:
					v505 = false;
					break;
				case 49:
					v505 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i506)));
				}
				switch(i506 - (l505 - 8)) {
				case 0:
					if(v505) {
						bs505 |= 128;
					} else {
						bs505 &= -129;
					}
					break;
				case 1:
					if(v505) {
						bs505 |= 64;
					} else {
						bs505 &= -65;
					}
					break;
				case 2:
					if(v505) {
						bs505 |= 32;
					} else {
						bs505 &= -33;
					}
					break;
				case 3:
					if(v505) {
						bs505 |= 16;
					} else {
						bs505 &= -17;
					}
					break;
				case 4:
					if(v505) {
						bs505 |= 8;
					} else {
						bs505 &= -9;
					}
					break;
				case 5:
					if(v505) {
						bs505 |= 4;
					} else {
						bs505 &= -5;
					}
					break;
				case 6:
					if(v505) {
						bs505 |= 2;
					} else {
						bs505 &= -3;
					}
					break;
				case 7:
					if(v505) {
						bs505 |= 1;
					} else {
						bs505 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs505;
			var this507 = 0;
			var bs506 = this507;
			var l506 = "* ** ".length;
			var _g1507 = 0;
			var _g607 = l506;
			while(_g1507 < _g607) {
				var i507 = _g1507++;
				var no506 = "* ** ".charCodeAt(i507);
				if(no506 == null) {
					break;
				}
				var v506;
				switch(no506) {
				case 32:
					v506 = false;
					break;
				case 42:
					v506 = true;
					break;
				case 48:
					v506 = false;
					break;
				case 49:
					v506 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* ** ".charCodeAt(i507)));
				}
				switch(i507 - (l506 - 8)) {
				case 0:
					if(v506) {
						bs506 |= 128;
					} else {
						bs506 &= -129;
					}
					break;
				case 1:
					if(v506) {
						bs506 |= 64;
					} else {
						bs506 &= -65;
					}
					break;
				case 2:
					if(v506) {
						bs506 |= 32;
					} else {
						bs506 &= -33;
					}
					break;
				case 3:
					if(v506) {
						bs506 |= 16;
					} else {
						bs506 &= -17;
					}
					break;
				case 4:
					if(v506) {
						bs506 |= 8;
					} else {
						bs506 &= -9;
					}
					break;
				case 5:
					if(v506) {
						bs506 |= 4;
					} else {
						bs506 &= -5;
					}
					break;
				case 6:
					if(v506) {
						bs506 |= 2;
					} else {
						bs506 &= -3;
					}
					break;
				case 7:
					if(v506) {
						bs506 |= 1;
					} else {
						bs506 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs506;
			var this508 = 0;
			var bs507 = this508;
			var l507 = "**  *".length;
			var _g1508 = 0;
			var _g608 = l507;
			while(_g1508 < _g608) {
				var i508 = _g1508++;
				var no507 = "**  *".charCodeAt(i508);
				if(no507 == null) {
					break;
				}
				var v507;
				switch(no507) {
				case 32:
					v507 = false;
					break;
				case 42:
					v507 = true;
					break;
				case 48:
					v507 = false;
					break;
				case 49:
					v507 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i508)));
				}
				switch(i508 - (l507 - 8)) {
				case 0:
					if(v507) {
						bs507 |= 128;
					} else {
						bs507 &= -129;
					}
					break;
				case 1:
					if(v507) {
						bs507 |= 64;
					} else {
						bs507 &= -65;
					}
					break;
				case 2:
					if(v507) {
						bs507 |= 32;
					} else {
						bs507 &= -33;
					}
					break;
				case 3:
					if(v507) {
						bs507 |= 16;
					} else {
						bs507 &= -17;
					}
					break;
				case 4:
					if(v507) {
						bs507 |= 8;
					} else {
						bs507 &= -9;
					}
					break;
				case 5:
					if(v507) {
						bs507 |= 4;
					} else {
						bs507 &= -5;
					}
					break;
				case 6:
					if(v507) {
						bs507 |= 2;
					} else {
						bs507 &= -3;
					}
					break;
				case 7:
					if(v507) {
						bs507 |= 1;
					} else {
						bs507 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs507;
			var this509 = 0;
			var bs508 = this509;
			var l508 = "*   *".length;
			var _g1509 = 0;
			var _g609 = l508;
			while(_g1509 < _g609) {
				var i509 = _g1509++;
				var no508 = "*   *".charCodeAt(i509);
				if(no508 == null) {
					break;
				}
				var v508;
				switch(no508) {
				case 32:
					v508 = false;
					break;
				case 42:
					v508 = true;
					break;
				case 48:
					v508 = false;
					break;
				case 49:
					v508 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i509)));
				}
				switch(i509 - (l508 - 8)) {
				case 0:
					if(v508) {
						bs508 |= 128;
					} else {
						bs508 &= -129;
					}
					break;
				case 1:
					if(v508) {
						bs508 |= 64;
					} else {
						bs508 &= -65;
					}
					break;
				case 2:
					if(v508) {
						bs508 |= 32;
					} else {
						bs508 &= -33;
					}
					break;
				case 3:
					if(v508) {
						bs508 |= 16;
					} else {
						bs508 &= -17;
					}
					break;
				case 4:
					if(v508) {
						bs508 |= 8;
					} else {
						bs508 &= -9;
					}
					break;
				case 5:
					if(v508) {
						bs508 |= 4;
					} else {
						bs508 &= -5;
					}
					break;
				case 6:
					if(v508) {
						bs508 |= 2;
					} else {
						bs508 &= -3;
					}
					break;
				case 7:
					if(v508) {
						bs508 |= 1;
					} else {
						bs508 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs508;
			var this510 = 0;
			var bs509 = this510;
			var l509 = "*   *".length;
			var _g1510 = 0;
			var _g610 = l509;
			while(_g1510 < _g610) {
				var i510 = _g1510++;
				var no509 = "*   *".charCodeAt(i510);
				if(no509 == null) {
					break;
				}
				var v509;
				switch(no509) {
				case 32:
					v509 = false;
					break;
				case 42:
					v509 = true;
					break;
				case 48:
					v509 = false;
					break;
				case 49:
					v509 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i510)));
				}
				switch(i510 - (l509 - 8)) {
				case 0:
					if(v509) {
						bs509 |= 128;
					} else {
						bs509 &= -129;
					}
					break;
				case 1:
					if(v509) {
						bs509 |= 64;
					} else {
						bs509 &= -65;
					}
					break;
				case 2:
					if(v509) {
						bs509 |= 32;
					} else {
						bs509 &= -33;
					}
					break;
				case 3:
					if(v509) {
						bs509 |= 16;
					} else {
						bs509 &= -17;
					}
					break;
				case 4:
					if(v509) {
						bs509 |= 8;
					} else {
						bs509 &= -9;
					}
					break;
				case 5:
					if(v509) {
						bs509 |= 4;
					} else {
						bs509 &= -5;
					}
					break;
				case 6:
					if(v509) {
						bs509 |= 2;
					} else {
						bs509 &= -3;
					}
					break;
				case 7:
					if(v509) {
						bs509 |= 1;
					} else {
						bs509 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs509;
			var this511 = 0;
			var bs510 = this511;
			var l510 = "*   *".length;
			var _g1511 = 0;
			var _g611 = l510;
			while(_g1511 < _g611) {
				var i511 = _g1511++;
				var no510 = "*   *".charCodeAt(i511);
				if(no510 == null) {
					break;
				}
				var v510;
				switch(no510) {
				case 32:
					v510 = false;
					break;
				case 42:
					v510 = true;
					break;
				case 48:
					v510 = false;
					break;
				case 49:
					v510 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i511)));
				}
				switch(i511 - (l510 - 8)) {
				case 0:
					if(v510) {
						bs510 |= 128;
					} else {
						bs510 &= -129;
					}
					break;
				case 1:
					if(v510) {
						bs510 |= 64;
					} else {
						bs510 &= -65;
					}
					break;
				case 2:
					if(v510) {
						bs510 |= 32;
					} else {
						bs510 &= -33;
					}
					break;
				case 3:
					if(v510) {
						bs510 |= 16;
					} else {
						bs510 &= -17;
					}
					break;
				case 4:
					if(v510) {
						bs510 |= 8;
					} else {
						bs510 &= -9;
					}
					break;
				case 5:
					if(v510) {
						bs510 |= 4;
					} else {
						bs510 &= -5;
					}
					break;
				case 6:
					if(v510) {
						bs510 |= 2;
					} else {
						bs510 &= -3;
					}
					break;
				case 7:
					if(v510) {
						bs510 |= 1;
					} else {
						bs510 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs510;
			break;
		case 105:
			var this512 = 0;
			var bs511 = this512;
			var l511 = "  *  ".length;
			var _g1512 = 0;
			var _g612 = l511;
			while(_g1512 < _g612) {
				var i512 = _g1512++;
				var no511 = "  *  ".charCodeAt(i512);
				if(no511 == null) {
					break;
				}
				var v511;
				switch(no511) {
				case 32:
					v511 = false;
					break;
				case 42:
					v511 = true;
					break;
				case 48:
					v511 = false;
					break;
				case 49:
					v511 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i512)));
				}
				switch(i512 - (l511 - 8)) {
				case 0:
					if(v511) {
						bs511 |= 128;
					} else {
						bs511 &= -129;
					}
					break;
				case 1:
					if(v511) {
						bs511 |= 64;
					} else {
						bs511 &= -65;
					}
					break;
				case 2:
					if(v511) {
						bs511 |= 32;
					} else {
						bs511 &= -33;
					}
					break;
				case 3:
					if(v511) {
						bs511 |= 16;
					} else {
						bs511 &= -17;
					}
					break;
				case 4:
					if(v511) {
						bs511 |= 8;
					} else {
						bs511 &= -9;
					}
					break;
				case 5:
					if(v511) {
						bs511 |= 4;
					} else {
						bs511 &= -5;
					}
					break;
				case 6:
					if(v511) {
						bs511 |= 2;
					} else {
						bs511 &= -3;
					}
					break;
				case 7:
					if(v511) {
						bs511 |= 1;
					} else {
						bs511 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs511;
			var this513 = 0;
			var bs512 = this513;
			var l512 = "     ".length;
			var _g1513 = 0;
			var _g613 = l512;
			while(_g1513 < _g613) {
				var i513 = _g1513++;
				var no512 = "     ".charCodeAt(i513);
				if(no512 == null) {
					break;
				}
				var v512;
				switch(no512) {
				case 32:
					v512 = false;
					break;
				case 42:
					v512 = true;
					break;
				case 48:
					v512 = false;
					break;
				case 49:
					v512 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i513)));
				}
				switch(i513 - (l512 - 8)) {
				case 0:
					if(v512) {
						bs512 |= 128;
					} else {
						bs512 &= -129;
					}
					break;
				case 1:
					if(v512) {
						bs512 |= 64;
					} else {
						bs512 &= -65;
					}
					break;
				case 2:
					if(v512) {
						bs512 |= 32;
					} else {
						bs512 &= -33;
					}
					break;
				case 3:
					if(v512) {
						bs512 |= 16;
					} else {
						bs512 &= -17;
					}
					break;
				case 4:
					if(v512) {
						bs512 |= 8;
					} else {
						bs512 &= -9;
					}
					break;
				case 5:
					if(v512) {
						bs512 |= 4;
					} else {
						bs512 &= -5;
					}
					break;
				case 6:
					if(v512) {
						bs512 |= 2;
					} else {
						bs512 &= -3;
					}
					break;
				case 7:
					if(v512) {
						bs512 |= 1;
					} else {
						bs512 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs512;
			var this514 = 0;
			var bs513 = this514;
			var l513 = " **  ".length;
			var _g1514 = 0;
			var _g614 = l513;
			while(_g1514 < _g614) {
				var i514 = _g1514++;
				var no513 = " **  ".charCodeAt(i514);
				if(no513 == null) {
					break;
				}
				var v513;
				switch(no513) {
				case 32:
					v513 = false;
					break;
				case 42:
					v513 = true;
					break;
				case 48:
					v513 = false;
					break;
				case 49:
					v513 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i514)));
				}
				switch(i514 - (l513 - 8)) {
				case 0:
					if(v513) {
						bs513 |= 128;
					} else {
						bs513 &= -129;
					}
					break;
				case 1:
					if(v513) {
						bs513 |= 64;
					} else {
						bs513 &= -65;
					}
					break;
				case 2:
					if(v513) {
						bs513 |= 32;
					} else {
						bs513 &= -33;
					}
					break;
				case 3:
					if(v513) {
						bs513 |= 16;
					} else {
						bs513 &= -17;
					}
					break;
				case 4:
					if(v513) {
						bs513 |= 8;
					} else {
						bs513 &= -9;
					}
					break;
				case 5:
					if(v513) {
						bs513 |= 4;
					} else {
						bs513 &= -5;
					}
					break;
				case 6:
					if(v513) {
						bs513 |= 2;
					} else {
						bs513 &= -3;
					}
					break;
				case 7:
					if(v513) {
						bs513 |= 1;
					} else {
						bs513 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs513;
			var this515 = 0;
			var bs514 = this515;
			var l514 = "  *  ".length;
			var _g1515 = 0;
			var _g615 = l514;
			while(_g1515 < _g615) {
				var i515 = _g1515++;
				var no514 = "  *  ".charCodeAt(i515);
				if(no514 == null) {
					break;
				}
				var v514;
				switch(no514) {
				case 32:
					v514 = false;
					break;
				case 42:
					v514 = true;
					break;
				case 48:
					v514 = false;
					break;
				case 49:
					v514 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i515)));
				}
				switch(i515 - (l514 - 8)) {
				case 0:
					if(v514) {
						bs514 |= 128;
					} else {
						bs514 &= -129;
					}
					break;
				case 1:
					if(v514) {
						bs514 |= 64;
					} else {
						bs514 &= -65;
					}
					break;
				case 2:
					if(v514) {
						bs514 |= 32;
					} else {
						bs514 &= -33;
					}
					break;
				case 3:
					if(v514) {
						bs514 |= 16;
					} else {
						bs514 &= -17;
					}
					break;
				case 4:
					if(v514) {
						bs514 |= 8;
					} else {
						bs514 &= -9;
					}
					break;
				case 5:
					if(v514) {
						bs514 |= 4;
					} else {
						bs514 &= -5;
					}
					break;
				case 6:
					if(v514) {
						bs514 |= 2;
					} else {
						bs514 &= -3;
					}
					break;
				case 7:
					if(v514) {
						bs514 |= 1;
					} else {
						bs514 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs514;
			var this516 = 0;
			var bs515 = this516;
			var l515 = "  *  ".length;
			var _g1516 = 0;
			var _g616 = l515;
			while(_g1516 < _g616) {
				var i516 = _g1516++;
				var no515 = "  *  ".charCodeAt(i516);
				if(no515 == null) {
					break;
				}
				var v515;
				switch(no515) {
				case 32:
					v515 = false;
					break;
				case 42:
					v515 = true;
					break;
				case 48:
					v515 = false;
					break;
				case 49:
					v515 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i516)));
				}
				switch(i516 - (l515 - 8)) {
				case 0:
					if(v515) {
						bs515 |= 128;
					} else {
						bs515 &= -129;
					}
					break;
				case 1:
					if(v515) {
						bs515 |= 64;
					} else {
						bs515 &= -65;
					}
					break;
				case 2:
					if(v515) {
						bs515 |= 32;
					} else {
						bs515 &= -33;
					}
					break;
				case 3:
					if(v515) {
						bs515 |= 16;
					} else {
						bs515 &= -17;
					}
					break;
				case 4:
					if(v515) {
						bs515 |= 8;
					} else {
						bs515 &= -9;
					}
					break;
				case 5:
					if(v515) {
						bs515 |= 4;
					} else {
						bs515 &= -5;
					}
					break;
				case 6:
					if(v515) {
						bs515 |= 2;
					} else {
						bs515 &= -3;
					}
					break;
				case 7:
					if(v515) {
						bs515 |= 1;
					} else {
						bs515 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs515;
			var this517 = 0;
			var bs516 = this517;
			var l516 = "  *  ".length;
			var _g1517 = 0;
			var _g617 = l516;
			while(_g1517 < _g617) {
				var i517 = _g1517++;
				var no516 = "  *  ".charCodeAt(i517);
				if(no516 == null) {
					break;
				}
				var v516;
				switch(no516) {
				case 32:
					v516 = false;
					break;
				case 42:
					v516 = true;
					break;
				case 48:
					v516 = false;
					break;
				case 49:
					v516 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i517)));
				}
				switch(i517 - (l516 - 8)) {
				case 0:
					if(v516) {
						bs516 |= 128;
					} else {
						bs516 &= -129;
					}
					break;
				case 1:
					if(v516) {
						bs516 |= 64;
					} else {
						bs516 &= -65;
					}
					break;
				case 2:
					if(v516) {
						bs516 |= 32;
					} else {
						bs516 &= -33;
					}
					break;
				case 3:
					if(v516) {
						bs516 |= 16;
					} else {
						bs516 &= -17;
					}
					break;
				case 4:
					if(v516) {
						bs516 |= 8;
					} else {
						bs516 &= -9;
					}
					break;
				case 5:
					if(v516) {
						bs516 |= 4;
					} else {
						bs516 &= -5;
					}
					break;
				case 6:
					if(v516) {
						bs516 |= 2;
					} else {
						bs516 &= -3;
					}
					break;
				case 7:
					if(v516) {
						bs516 |= 1;
					} else {
						bs516 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs516;
			var this518 = 0;
			var bs517 = this518;
			var l517 = " *** ".length;
			var _g1518 = 0;
			var _g618 = l517;
			while(_g1518 < _g618) {
				var i518 = _g1518++;
				var no517 = " *** ".charCodeAt(i518);
				if(no517 == null) {
					break;
				}
				var v517;
				switch(no517) {
				case 32:
					v517 = false;
					break;
				case 42:
					v517 = true;
					break;
				case 48:
					v517 = false;
					break;
				case 49:
					v517 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i518)));
				}
				switch(i518 - (l517 - 8)) {
				case 0:
					if(v517) {
						bs517 |= 128;
					} else {
						bs517 &= -129;
					}
					break;
				case 1:
					if(v517) {
						bs517 |= 64;
					} else {
						bs517 &= -65;
					}
					break;
				case 2:
					if(v517) {
						bs517 |= 32;
					} else {
						bs517 &= -33;
					}
					break;
				case 3:
					if(v517) {
						bs517 |= 16;
					} else {
						bs517 &= -17;
					}
					break;
				case 4:
					if(v517) {
						bs517 |= 8;
					} else {
						bs517 &= -9;
					}
					break;
				case 5:
					if(v517) {
						bs517 |= 4;
					} else {
						bs517 &= -5;
					}
					break;
				case 6:
					if(v517) {
						bs517 |= 2;
					} else {
						bs517 &= -3;
					}
					break;
				case 7:
					if(v517) {
						bs517 |= 1;
					} else {
						bs517 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs517;
			break;
		case 106:
			var this519 = 0;
			var bs518 = this519;
			var l518 = "   * ".length;
			var _g1519 = 0;
			var _g619 = l518;
			while(_g1519 < _g619) {
				var i519 = _g1519++;
				var no518 = "   * ".charCodeAt(i519);
				if(no518 == null) {
					break;
				}
				var v518;
				switch(no518) {
				case 32:
					v518 = false;
					break;
				case 42:
					v518 = true;
					break;
				case 48:
					v518 = false;
					break;
				case 49:
					v518 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i519)));
				}
				switch(i519 - (l518 - 8)) {
				case 0:
					if(v518) {
						bs518 |= 128;
					} else {
						bs518 &= -129;
					}
					break;
				case 1:
					if(v518) {
						bs518 |= 64;
					} else {
						bs518 &= -65;
					}
					break;
				case 2:
					if(v518) {
						bs518 |= 32;
					} else {
						bs518 &= -33;
					}
					break;
				case 3:
					if(v518) {
						bs518 |= 16;
					} else {
						bs518 &= -17;
					}
					break;
				case 4:
					if(v518) {
						bs518 |= 8;
					} else {
						bs518 &= -9;
					}
					break;
				case 5:
					if(v518) {
						bs518 |= 4;
					} else {
						bs518 &= -5;
					}
					break;
				case 6:
					if(v518) {
						bs518 |= 2;
					} else {
						bs518 &= -3;
					}
					break;
				case 7:
					if(v518) {
						bs518 |= 1;
					} else {
						bs518 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs518;
			var this520 = 0;
			var bs519 = this520;
			var l519 = "     ".length;
			var _g1520 = 0;
			var _g620 = l519;
			while(_g1520 < _g620) {
				var i520 = _g1520++;
				var no519 = "     ".charCodeAt(i520);
				if(no519 == null) {
					break;
				}
				var v519;
				switch(no519) {
				case 32:
					v519 = false;
					break;
				case 42:
					v519 = true;
					break;
				case 48:
					v519 = false;
					break;
				case 49:
					v519 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i520)));
				}
				switch(i520 - (l519 - 8)) {
				case 0:
					if(v519) {
						bs519 |= 128;
					} else {
						bs519 &= -129;
					}
					break;
				case 1:
					if(v519) {
						bs519 |= 64;
					} else {
						bs519 &= -65;
					}
					break;
				case 2:
					if(v519) {
						bs519 |= 32;
					} else {
						bs519 &= -33;
					}
					break;
				case 3:
					if(v519) {
						bs519 |= 16;
					} else {
						bs519 &= -17;
					}
					break;
				case 4:
					if(v519) {
						bs519 |= 8;
					} else {
						bs519 &= -9;
					}
					break;
				case 5:
					if(v519) {
						bs519 |= 4;
					} else {
						bs519 &= -5;
					}
					break;
				case 6:
					if(v519) {
						bs519 |= 2;
					} else {
						bs519 &= -3;
					}
					break;
				case 7:
					if(v519) {
						bs519 |= 1;
					} else {
						bs519 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs519;
			var this521 = 0;
			var bs520 = this521;
			var l520 = "  ** ".length;
			var _g1521 = 0;
			var _g621 = l520;
			while(_g1521 < _g621) {
				var i521 = _g1521++;
				var no520 = "  ** ".charCodeAt(i521);
				if(no520 == null) {
					break;
				}
				var v520;
				switch(no520) {
				case 32:
					v520 = false;
					break;
				case 42:
					v520 = true;
					break;
				case 48:
					v520 = false;
					break;
				case 49:
					v520 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i521)));
				}
				switch(i521 - (l520 - 8)) {
				case 0:
					if(v520) {
						bs520 |= 128;
					} else {
						bs520 &= -129;
					}
					break;
				case 1:
					if(v520) {
						bs520 |= 64;
					} else {
						bs520 &= -65;
					}
					break;
				case 2:
					if(v520) {
						bs520 |= 32;
					} else {
						bs520 &= -33;
					}
					break;
				case 3:
					if(v520) {
						bs520 |= 16;
					} else {
						bs520 &= -17;
					}
					break;
				case 4:
					if(v520) {
						bs520 |= 8;
					} else {
						bs520 &= -9;
					}
					break;
				case 5:
					if(v520) {
						bs520 |= 4;
					} else {
						bs520 &= -5;
					}
					break;
				case 6:
					if(v520) {
						bs520 |= 2;
					} else {
						bs520 &= -3;
					}
					break;
				case 7:
					if(v520) {
						bs520 |= 1;
					} else {
						bs520 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs520;
			var this522 = 0;
			var bs521 = this522;
			var l521 = "   * ".length;
			var _g1522 = 0;
			var _g622 = l521;
			while(_g1522 < _g622) {
				var i522 = _g1522++;
				var no521 = "   * ".charCodeAt(i522);
				if(no521 == null) {
					break;
				}
				var v521;
				switch(no521) {
				case 32:
					v521 = false;
					break;
				case 42:
					v521 = true;
					break;
				case 48:
					v521 = false;
					break;
				case 49:
					v521 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i522)));
				}
				switch(i522 - (l521 - 8)) {
				case 0:
					if(v521) {
						bs521 |= 128;
					} else {
						bs521 &= -129;
					}
					break;
				case 1:
					if(v521) {
						bs521 |= 64;
					} else {
						bs521 &= -65;
					}
					break;
				case 2:
					if(v521) {
						bs521 |= 32;
					} else {
						bs521 &= -33;
					}
					break;
				case 3:
					if(v521) {
						bs521 |= 16;
					} else {
						bs521 &= -17;
					}
					break;
				case 4:
					if(v521) {
						bs521 |= 8;
					} else {
						bs521 &= -9;
					}
					break;
				case 5:
					if(v521) {
						bs521 |= 4;
					} else {
						bs521 &= -5;
					}
					break;
				case 6:
					if(v521) {
						bs521 |= 2;
					} else {
						bs521 &= -3;
					}
					break;
				case 7:
					if(v521) {
						bs521 |= 1;
					} else {
						bs521 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs521;
			var this523 = 0;
			var bs522 = this523;
			var l522 = "   * ".length;
			var _g1523 = 0;
			var _g623 = l522;
			while(_g1523 < _g623) {
				var i523 = _g1523++;
				var no522 = "   * ".charCodeAt(i523);
				if(no522 == null) {
					break;
				}
				var v522;
				switch(no522) {
				case 32:
					v522 = false;
					break;
				case 42:
					v522 = true;
					break;
				case 48:
					v522 = false;
					break;
				case 49:
					v522 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i523)));
				}
				switch(i523 - (l522 - 8)) {
				case 0:
					if(v522) {
						bs522 |= 128;
					} else {
						bs522 &= -129;
					}
					break;
				case 1:
					if(v522) {
						bs522 |= 64;
					} else {
						bs522 &= -65;
					}
					break;
				case 2:
					if(v522) {
						bs522 |= 32;
					} else {
						bs522 &= -33;
					}
					break;
				case 3:
					if(v522) {
						bs522 |= 16;
					} else {
						bs522 &= -17;
					}
					break;
				case 4:
					if(v522) {
						bs522 |= 8;
					} else {
						bs522 &= -9;
					}
					break;
				case 5:
					if(v522) {
						bs522 |= 4;
					} else {
						bs522 &= -5;
					}
					break;
				case 6:
					if(v522) {
						bs522 |= 2;
					} else {
						bs522 &= -3;
					}
					break;
				case 7:
					if(v522) {
						bs522 |= 1;
					} else {
						bs522 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs522;
			var this524 = 0;
			var bs523 = this524;
			var l523 = "*  * ".length;
			var _g1524 = 0;
			var _g624 = l523;
			while(_g1524 < _g624) {
				var i524 = _g1524++;
				var no523 = "*  * ".charCodeAt(i524);
				if(no523 == null) {
					break;
				}
				var v523;
				switch(no523) {
				case 32:
					v523 = false;
					break;
				case 42:
					v523 = true;
					break;
				case 48:
					v523 = false;
					break;
				case 49:
					v523 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i524)));
				}
				switch(i524 - (l523 - 8)) {
				case 0:
					if(v523) {
						bs523 |= 128;
					} else {
						bs523 &= -129;
					}
					break;
				case 1:
					if(v523) {
						bs523 |= 64;
					} else {
						bs523 &= -65;
					}
					break;
				case 2:
					if(v523) {
						bs523 |= 32;
					} else {
						bs523 &= -33;
					}
					break;
				case 3:
					if(v523) {
						bs523 |= 16;
					} else {
						bs523 &= -17;
					}
					break;
				case 4:
					if(v523) {
						bs523 |= 8;
					} else {
						bs523 &= -9;
					}
					break;
				case 5:
					if(v523) {
						bs523 |= 4;
					} else {
						bs523 &= -5;
					}
					break;
				case 6:
					if(v523) {
						bs523 |= 2;
					} else {
						bs523 &= -3;
					}
					break;
				case 7:
					if(v523) {
						bs523 |= 1;
					} else {
						bs523 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs523;
			var this525 = 0;
			var bs524 = this525;
			var l524 = " **  ".length;
			var _g1525 = 0;
			var _g625 = l524;
			while(_g1525 < _g625) {
				var i525 = _g1525++;
				var no524 = " **  ".charCodeAt(i525);
				if(no524 == null) {
					break;
				}
				var v524;
				switch(no524) {
				case 32:
					v524 = false;
					break;
				case 42:
					v524 = true;
					break;
				case 48:
					v524 = false;
					break;
				case 49:
					v524 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i525)));
				}
				switch(i525 - (l524 - 8)) {
				case 0:
					if(v524) {
						bs524 |= 128;
					} else {
						bs524 &= -129;
					}
					break;
				case 1:
					if(v524) {
						bs524 |= 64;
					} else {
						bs524 &= -65;
					}
					break;
				case 2:
					if(v524) {
						bs524 |= 32;
					} else {
						bs524 &= -33;
					}
					break;
				case 3:
					if(v524) {
						bs524 |= 16;
					} else {
						bs524 &= -17;
					}
					break;
				case 4:
					if(v524) {
						bs524 |= 8;
					} else {
						bs524 &= -9;
					}
					break;
				case 5:
					if(v524) {
						bs524 |= 4;
					} else {
						bs524 &= -5;
					}
					break;
				case 6:
					if(v524) {
						bs524 |= 2;
					} else {
						bs524 &= -3;
					}
					break;
				case 7:
					if(v524) {
						bs524 |= 1;
					} else {
						bs524 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs524;
			break;
		case 107:
			var this526 = 0;
			var bs525 = this526;
			var l525 = "*    ".length;
			var _g1526 = 0;
			var _g626 = l525;
			while(_g1526 < _g626) {
				var i526 = _g1526++;
				var no525 = "*    ".charCodeAt(i526);
				if(no525 == null) {
					break;
				}
				var v525;
				switch(no525) {
				case 32:
					v525 = false;
					break;
				case 42:
					v525 = true;
					break;
				case 48:
					v525 = false;
					break;
				case 49:
					v525 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i526)));
				}
				switch(i526 - (l525 - 8)) {
				case 0:
					if(v525) {
						bs525 |= 128;
					} else {
						bs525 &= -129;
					}
					break;
				case 1:
					if(v525) {
						bs525 |= 64;
					} else {
						bs525 &= -65;
					}
					break;
				case 2:
					if(v525) {
						bs525 |= 32;
					} else {
						bs525 &= -33;
					}
					break;
				case 3:
					if(v525) {
						bs525 |= 16;
					} else {
						bs525 &= -17;
					}
					break;
				case 4:
					if(v525) {
						bs525 |= 8;
					} else {
						bs525 &= -9;
					}
					break;
				case 5:
					if(v525) {
						bs525 |= 4;
					} else {
						bs525 &= -5;
					}
					break;
				case 6:
					if(v525) {
						bs525 |= 2;
					} else {
						bs525 &= -3;
					}
					break;
				case 7:
					if(v525) {
						bs525 |= 1;
					} else {
						bs525 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs525;
			var this527 = 0;
			var bs526 = this527;
			var l526 = "*    ".length;
			var _g1527 = 0;
			var _g627 = l526;
			while(_g1527 < _g627) {
				var i527 = _g1527++;
				var no526 = "*    ".charCodeAt(i527);
				if(no526 == null) {
					break;
				}
				var v526;
				switch(no526) {
				case 32:
					v526 = false;
					break;
				case 42:
					v526 = true;
					break;
				case 48:
					v526 = false;
					break;
				case 49:
					v526 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i527)));
				}
				switch(i527 - (l526 - 8)) {
				case 0:
					if(v526) {
						bs526 |= 128;
					} else {
						bs526 &= -129;
					}
					break;
				case 1:
					if(v526) {
						bs526 |= 64;
					} else {
						bs526 &= -65;
					}
					break;
				case 2:
					if(v526) {
						bs526 |= 32;
					} else {
						bs526 &= -33;
					}
					break;
				case 3:
					if(v526) {
						bs526 |= 16;
					} else {
						bs526 &= -17;
					}
					break;
				case 4:
					if(v526) {
						bs526 |= 8;
					} else {
						bs526 &= -9;
					}
					break;
				case 5:
					if(v526) {
						bs526 |= 4;
					} else {
						bs526 &= -5;
					}
					break;
				case 6:
					if(v526) {
						bs526 |= 2;
					} else {
						bs526 &= -3;
					}
					break;
				case 7:
					if(v526) {
						bs526 |= 1;
					} else {
						bs526 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs526;
			var this528 = 0;
			var bs527 = this528;
			var l527 = "*  * ".length;
			var _g1528 = 0;
			var _g628 = l527;
			while(_g1528 < _g628) {
				var i528 = _g1528++;
				var no527 = "*  * ".charCodeAt(i528);
				if(no527 == null) {
					break;
				}
				var v527;
				switch(no527) {
				case 32:
					v527 = false;
					break;
				case 42:
					v527 = true;
					break;
				case 48:
					v527 = false;
					break;
				case 49:
					v527 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i528)));
				}
				switch(i528 - (l527 - 8)) {
				case 0:
					if(v527) {
						bs527 |= 128;
					} else {
						bs527 &= -129;
					}
					break;
				case 1:
					if(v527) {
						bs527 |= 64;
					} else {
						bs527 &= -65;
					}
					break;
				case 2:
					if(v527) {
						bs527 |= 32;
					} else {
						bs527 &= -33;
					}
					break;
				case 3:
					if(v527) {
						bs527 |= 16;
					} else {
						bs527 &= -17;
					}
					break;
				case 4:
					if(v527) {
						bs527 |= 8;
					} else {
						bs527 &= -9;
					}
					break;
				case 5:
					if(v527) {
						bs527 |= 4;
					} else {
						bs527 &= -5;
					}
					break;
				case 6:
					if(v527) {
						bs527 |= 2;
					} else {
						bs527 &= -3;
					}
					break;
				case 7:
					if(v527) {
						bs527 |= 1;
					} else {
						bs527 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs527;
			var this529 = 0;
			var bs528 = this529;
			var l528 = "* *  ".length;
			var _g1529 = 0;
			var _g629 = l528;
			while(_g1529 < _g629) {
				var i529 = _g1529++;
				var no528 = "* *  ".charCodeAt(i529);
				if(no528 == null) {
					break;
				}
				var v528;
				switch(no528) {
				case 32:
					v528 = false;
					break;
				case 42:
					v528 = true;
					break;
				case 48:
					v528 = false;
					break;
				case 49:
					v528 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i529)));
				}
				switch(i529 - (l528 - 8)) {
				case 0:
					if(v528) {
						bs528 |= 128;
					} else {
						bs528 &= -129;
					}
					break;
				case 1:
					if(v528) {
						bs528 |= 64;
					} else {
						bs528 &= -65;
					}
					break;
				case 2:
					if(v528) {
						bs528 |= 32;
					} else {
						bs528 &= -33;
					}
					break;
				case 3:
					if(v528) {
						bs528 |= 16;
					} else {
						bs528 &= -17;
					}
					break;
				case 4:
					if(v528) {
						bs528 |= 8;
					} else {
						bs528 &= -9;
					}
					break;
				case 5:
					if(v528) {
						bs528 |= 4;
					} else {
						bs528 &= -5;
					}
					break;
				case 6:
					if(v528) {
						bs528 |= 2;
					} else {
						bs528 &= -3;
					}
					break;
				case 7:
					if(v528) {
						bs528 |= 1;
					} else {
						bs528 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs528;
			var this530 = 0;
			var bs529 = this530;
			var l529 = "**   ".length;
			var _g1530 = 0;
			var _g630 = l529;
			while(_g1530 < _g630) {
				var i530 = _g1530++;
				var no529 = "**   ".charCodeAt(i530);
				if(no529 == null) {
					break;
				}
				var v529;
				switch(no529) {
				case 32:
					v529 = false;
					break;
				case 42:
					v529 = true;
					break;
				case 48:
					v529 = false;
					break;
				case 49:
					v529 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**   ".charCodeAt(i530)));
				}
				switch(i530 - (l529 - 8)) {
				case 0:
					if(v529) {
						bs529 |= 128;
					} else {
						bs529 &= -129;
					}
					break;
				case 1:
					if(v529) {
						bs529 |= 64;
					} else {
						bs529 &= -65;
					}
					break;
				case 2:
					if(v529) {
						bs529 |= 32;
					} else {
						bs529 &= -33;
					}
					break;
				case 3:
					if(v529) {
						bs529 |= 16;
					} else {
						bs529 &= -17;
					}
					break;
				case 4:
					if(v529) {
						bs529 |= 8;
					} else {
						bs529 &= -9;
					}
					break;
				case 5:
					if(v529) {
						bs529 |= 4;
					} else {
						bs529 &= -5;
					}
					break;
				case 6:
					if(v529) {
						bs529 |= 2;
					} else {
						bs529 &= -3;
					}
					break;
				case 7:
					if(v529) {
						bs529 |= 1;
					} else {
						bs529 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs529;
			var this531 = 0;
			var bs530 = this531;
			var l530 = "* *  ".length;
			var _g1531 = 0;
			var _g631 = l530;
			while(_g1531 < _g631) {
				var i531 = _g1531++;
				var no530 = "* *  ".charCodeAt(i531);
				if(no530 == null) {
					break;
				}
				var v530;
				switch(no530) {
				case 32:
					v530 = false;
					break;
				case 42:
					v530 = true;
					break;
				case 48:
					v530 = false;
					break;
				case 49:
					v530 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i531)));
				}
				switch(i531 - (l530 - 8)) {
				case 0:
					if(v530) {
						bs530 |= 128;
					} else {
						bs530 &= -129;
					}
					break;
				case 1:
					if(v530) {
						bs530 |= 64;
					} else {
						bs530 &= -65;
					}
					break;
				case 2:
					if(v530) {
						bs530 |= 32;
					} else {
						bs530 &= -33;
					}
					break;
				case 3:
					if(v530) {
						bs530 |= 16;
					} else {
						bs530 &= -17;
					}
					break;
				case 4:
					if(v530) {
						bs530 |= 8;
					} else {
						bs530 &= -9;
					}
					break;
				case 5:
					if(v530) {
						bs530 |= 4;
					} else {
						bs530 &= -5;
					}
					break;
				case 6:
					if(v530) {
						bs530 |= 2;
					} else {
						bs530 &= -3;
					}
					break;
				case 7:
					if(v530) {
						bs530 |= 1;
					} else {
						bs530 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs530;
			var this532 = 0;
			var bs531 = this532;
			var l531 = "*   *".length;
			var _g1532 = 0;
			var _g632 = l531;
			while(_g1532 < _g632) {
				var i532 = _g1532++;
				var no531 = "*   *".charCodeAt(i532);
				if(no531 == null) {
					break;
				}
				var v531;
				switch(no531) {
				case 32:
					v531 = false;
					break;
				case 42:
					v531 = true;
					break;
				case 48:
					v531 = false;
					break;
				case 49:
					v531 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i532)));
				}
				switch(i532 - (l531 - 8)) {
				case 0:
					if(v531) {
						bs531 |= 128;
					} else {
						bs531 &= -129;
					}
					break;
				case 1:
					if(v531) {
						bs531 |= 64;
					} else {
						bs531 &= -65;
					}
					break;
				case 2:
					if(v531) {
						bs531 |= 32;
					} else {
						bs531 &= -33;
					}
					break;
				case 3:
					if(v531) {
						bs531 |= 16;
					} else {
						bs531 &= -17;
					}
					break;
				case 4:
					if(v531) {
						bs531 |= 8;
					} else {
						bs531 &= -9;
					}
					break;
				case 5:
					if(v531) {
						bs531 |= 4;
					} else {
						bs531 &= -5;
					}
					break;
				case 6:
					if(v531) {
						bs531 |= 2;
					} else {
						bs531 &= -3;
					}
					break;
				case 7:
					if(v531) {
						bs531 |= 1;
					} else {
						bs531 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs531;
			break;
		case 108:
			var this533 = 0;
			var bs532 = this533;
			var l532 = " **  ".length;
			var _g1533 = 0;
			var _g633 = l532;
			while(_g1533 < _g633) {
				var i533 = _g1533++;
				var no532 = " **  ".charCodeAt(i533);
				if(no532 == null) {
					break;
				}
				var v532;
				switch(no532) {
				case 32:
					v532 = false;
					break;
				case 42:
					v532 = true;
					break;
				case 48:
					v532 = false;
					break;
				case 49:
					v532 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i533)));
				}
				switch(i533 - (l532 - 8)) {
				case 0:
					if(v532) {
						bs532 |= 128;
					} else {
						bs532 &= -129;
					}
					break;
				case 1:
					if(v532) {
						bs532 |= 64;
					} else {
						bs532 &= -65;
					}
					break;
				case 2:
					if(v532) {
						bs532 |= 32;
					} else {
						bs532 &= -33;
					}
					break;
				case 3:
					if(v532) {
						bs532 |= 16;
					} else {
						bs532 &= -17;
					}
					break;
				case 4:
					if(v532) {
						bs532 |= 8;
					} else {
						bs532 &= -9;
					}
					break;
				case 5:
					if(v532) {
						bs532 |= 4;
					} else {
						bs532 &= -5;
					}
					break;
				case 6:
					if(v532) {
						bs532 |= 2;
					} else {
						bs532 &= -3;
					}
					break;
				case 7:
					if(v532) {
						bs532 |= 1;
					} else {
						bs532 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs532;
			var this534 = 0;
			var bs533 = this534;
			var l533 = "  *  ".length;
			var _g1534 = 0;
			var _g634 = l533;
			while(_g1534 < _g634) {
				var i534 = _g1534++;
				var no533 = "  *  ".charCodeAt(i534);
				if(no533 == null) {
					break;
				}
				var v533;
				switch(no533) {
				case 32:
					v533 = false;
					break;
				case 42:
					v533 = true;
					break;
				case 48:
					v533 = false;
					break;
				case 49:
					v533 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i534)));
				}
				switch(i534 - (l533 - 8)) {
				case 0:
					if(v533) {
						bs533 |= 128;
					} else {
						bs533 &= -129;
					}
					break;
				case 1:
					if(v533) {
						bs533 |= 64;
					} else {
						bs533 &= -65;
					}
					break;
				case 2:
					if(v533) {
						bs533 |= 32;
					} else {
						bs533 &= -33;
					}
					break;
				case 3:
					if(v533) {
						bs533 |= 16;
					} else {
						bs533 &= -17;
					}
					break;
				case 4:
					if(v533) {
						bs533 |= 8;
					} else {
						bs533 &= -9;
					}
					break;
				case 5:
					if(v533) {
						bs533 |= 4;
					} else {
						bs533 &= -5;
					}
					break;
				case 6:
					if(v533) {
						bs533 |= 2;
					} else {
						bs533 &= -3;
					}
					break;
				case 7:
					if(v533) {
						bs533 |= 1;
					} else {
						bs533 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs533;
			var this535 = 0;
			var bs534 = this535;
			var l534 = "  *  ".length;
			var _g1535 = 0;
			var _g635 = l534;
			while(_g1535 < _g635) {
				var i535 = _g1535++;
				var no534 = "  *  ".charCodeAt(i535);
				if(no534 == null) {
					break;
				}
				var v534;
				switch(no534) {
				case 32:
					v534 = false;
					break;
				case 42:
					v534 = true;
					break;
				case 48:
					v534 = false;
					break;
				case 49:
					v534 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i535)));
				}
				switch(i535 - (l534 - 8)) {
				case 0:
					if(v534) {
						bs534 |= 128;
					} else {
						bs534 &= -129;
					}
					break;
				case 1:
					if(v534) {
						bs534 |= 64;
					} else {
						bs534 &= -65;
					}
					break;
				case 2:
					if(v534) {
						bs534 |= 32;
					} else {
						bs534 &= -33;
					}
					break;
				case 3:
					if(v534) {
						bs534 |= 16;
					} else {
						bs534 &= -17;
					}
					break;
				case 4:
					if(v534) {
						bs534 |= 8;
					} else {
						bs534 &= -9;
					}
					break;
				case 5:
					if(v534) {
						bs534 |= 4;
					} else {
						bs534 &= -5;
					}
					break;
				case 6:
					if(v534) {
						bs534 |= 2;
					} else {
						bs534 &= -3;
					}
					break;
				case 7:
					if(v534) {
						bs534 |= 1;
					} else {
						bs534 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs534;
			var this536 = 0;
			var bs535 = this536;
			var l535 = "  *  ".length;
			var _g1536 = 0;
			var _g636 = l535;
			while(_g1536 < _g636) {
				var i536 = _g1536++;
				var no535 = "  *  ".charCodeAt(i536);
				if(no535 == null) {
					break;
				}
				var v535;
				switch(no535) {
				case 32:
					v535 = false;
					break;
				case 42:
					v535 = true;
					break;
				case 48:
					v535 = false;
					break;
				case 49:
					v535 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i536)));
				}
				switch(i536 - (l535 - 8)) {
				case 0:
					if(v535) {
						bs535 |= 128;
					} else {
						bs535 &= -129;
					}
					break;
				case 1:
					if(v535) {
						bs535 |= 64;
					} else {
						bs535 &= -65;
					}
					break;
				case 2:
					if(v535) {
						bs535 |= 32;
					} else {
						bs535 &= -33;
					}
					break;
				case 3:
					if(v535) {
						bs535 |= 16;
					} else {
						bs535 &= -17;
					}
					break;
				case 4:
					if(v535) {
						bs535 |= 8;
					} else {
						bs535 &= -9;
					}
					break;
				case 5:
					if(v535) {
						bs535 |= 4;
					} else {
						bs535 &= -5;
					}
					break;
				case 6:
					if(v535) {
						bs535 |= 2;
					} else {
						bs535 &= -3;
					}
					break;
				case 7:
					if(v535) {
						bs535 |= 1;
					} else {
						bs535 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs535;
			var this537 = 0;
			var bs536 = this537;
			var l536 = "  *  ".length;
			var _g1537 = 0;
			var _g637 = l536;
			while(_g1537 < _g637) {
				var i537 = _g1537++;
				var no536 = "  *  ".charCodeAt(i537);
				if(no536 == null) {
					break;
				}
				var v536;
				switch(no536) {
				case 32:
					v536 = false;
					break;
				case 42:
					v536 = true;
					break;
				case 48:
					v536 = false;
					break;
				case 49:
					v536 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i537)));
				}
				switch(i537 - (l536 - 8)) {
				case 0:
					if(v536) {
						bs536 |= 128;
					} else {
						bs536 &= -129;
					}
					break;
				case 1:
					if(v536) {
						bs536 |= 64;
					} else {
						bs536 &= -65;
					}
					break;
				case 2:
					if(v536) {
						bs536 |= 32;
					} else {
						bs536 &= -33;
					}
					break;
				case 3:
					if(v536) {
						bs536 |= 16;
					} else {
						bs536 &= -17;
					}
					break;
				case 4:
					if(v536) {
						bs536 |= 8;
					} else {
						bs536 &= -9;
					}
					break;
				case 5:
					if(v536) {
						bs536 |= 4;
					} else {
						bs536 &= -5;
					}
					break;
				case 6:
					if(v536) {
						bs536 |= 2;
					} else {
						bs536 &= -3;
					}
					break;
				case 7:
					if(v536) {
						bs536 |= 1;
					} else {
						bs536 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs536;
			var this538 = 0;
			var bs537 = this538;
			var l537 = "  *  ".length;
			var _g1538 = 0;
			var _g638 = l537;
			while(_g1538 < _g638) {
				var i538 = _g1538++;
				var no537 = "  *  ".charCodeAt(i538);
				if(no537 == null) {
					break;
				}
				var v537;
				switch(no537) {
				case 32:
					v537 = false;
					break;
				case 42:
					v537 = true;
					break;
				case 48:
					v537 = false;
					break;
				case 49:
					v537 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i538)));
				}
				switch(i538 - (l537 - 8)) {
				case 0:
					if(v537) {
						bs537 |= 128;
					} else {
						bs537 &= -129;
					}
					break;
				case 1:
					if(v537) {
						bs537 |= 64;
					} else {
						bs537 &= -65;
					}
					break;
				case 2:
					if(v537) {
						bs537 |= 32;
					} else {
						bs537 &= -33;
					}
					break;
				case 3:
					if(v537) {
						bs537 |= 16;
					} else {
						bs537 &= -17;
					}
					break;
				case 4:
					if(v537) {
						bs537 |= 8;
					} else {
						bs537 &= -9;
					}
					break;
				case 5:
					if(v537) {
						bs537 |= 4;
					} else {
						bs537 &= -5;
					}
					break;
				case 6:
					if(v537) {
						bs537 |= 2;
					} else {
						bs537 &= -3;
					}
					break;
				case 7:
					if(v537) {
						bs537 |= 1;
					} else {
						bs537 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs537;
			var this539 = 0;
			var bs538 = this539;
			var l538 = " ***".length;
			var _g1539 = 0;
			var _g639 = l538;
			while(_g1539 < _g639) {
				var i539 = _g1539++;
				var no538 = " ***".charCodeAt(i539);
				if(no538 == null) {
					break;
				}
				var v538;
				switch(no538) {
				case 32:
					v538 = false;
					break;
				case 42:
					v538 = true;
					break;
				case 48:
					v538 = false;
					break;
				case 49:
					v538 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ***".charCodeAt(i539)));
				}
				switch(i539 - (l538 - 8)) {
				case 0:
					if(v538) {
						bs538 |= 128;
					} else {
						bs538 &= -129;
					}
					break;
				case 1:
					if(v538) {
						bs538 |= 64;
					} else {
						bs538 &= -65;
					}
					break;
				case 2:
					if(v538) {
						bs538 |= 32;
					} else {
						bs538 &= -33;
					}
					break;
				case 3:
					if(v538) {
						bs538 |= 16;
					} else {
						bs538 &= -17;
					}
					break;
				case 4:
					if(v538) {
						bs538 |= 8;
					} else {
						bs538 &= -9;
					}
					break;
				case 5:
					if(v538) {
						bs538 |= 4;
					} else {
						bs538 &= -5;
					}
					break;
				case 6:
					if(v538) {
						bs538 |= 2;
					} else {
						bs538 &= -3;
					}
					break;
				case 7:
					if(v538) {
						bs538 |= 1;
					} else {
						bs538 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs538;
			break;
		case 109:
			var this540 = 0;
			var bs539 = this540;
			var l539 = "     ".length;
			var _g1540 = 0;
			var _g640 = l539;
			while(_g1540 < _g640) {
				var i540 = _g1540++;
				var no539 = "     ".charCodeAt(i540);
				if(no539 == null) {
					break;
				}
				var v539;
				switch(no539) {
				case 32:
					v539 = false;
					break;
				case 42:
					v539 = true;
					break;
				case 48:
					v539 = false;
					break;
				case 49:
					v539 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i540)));
				}
				switch(i540 - (l539 - 8)) {
				case 0:
					if(v539) {
						bs539 |= 128;
					} else {
						bs539 &= -129;
					}
					break;
				case 1:
					if(v539) {
						bs539 |= 64;
					} else {
						bs539 &= -65;
					}
					break;
				case 2:
					if(v539) {
						bs539 |= 32;
					} else {
						bs539 &= -33;
					}
					break;
				case 3:
					if(v539) {
						bs539 |= 16;
					} else {
						bs539 &= -17;
					}
					break;
				case 4:
					if(v539) {
						bs539 |= 8;
					} else {
						bs539 &= -9;
					}
					break;
				case 5:
					if(v539) {
						bs539 |= 4;
					} else {
						bs539 &= -5;
					}
					break;
				case 6:
					if(v539) {
						bs539 |= 2;
					} else {
						bs539 &= -3;
					}
					break;
				case 7:
					if(v539) {
						bs539 |= 1;
					} else {
						bs539 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs539;
			var this541 = 0;
			var bs540 = this541;
			var l540 = "     ".length;
			var _g1541 = 0;
			var _g641 = l540;
			while(_g1541 < _g641) {
				var i541 = _g1541++;
				var no540 = "     ".charCodeAt(i541);
				if(no540 == null) {
					break;
				}
				var v540;
				switch(no540) {
				case 32:
					v540 = false;
					break;
				case 42:
					v540 = true;
					break;
				case 48:
					v540 = false;
					break;
				case 49:
					v540 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i541)));
				}
				switch(i541 - (l540 - 8)) {
				case 0:
					if(v540) {
						bs540 |= 128;
					} else {
						bs540 &= -129;
					}
					break;
				case 1:
					if(v540) {
						bs540 |= 64;
					} else {
						bs540 &= -65;
					}
					break;
				case 2:
					if(v540) {
						bs540 |= 32;
					} else {
						bs540 &= -33;
					}
					break;
				case 3:
					if(v540) {
						bs540 |= 16;
					} else {
						bs540 &= -17;
					}
					break;
				case 4:
					if(v540) {
						bs540 |= 8;
					} else {
						bs540 &= -9;
					}
					break;
				case 5:
					if(v540) {
						bs540 |= 4;
					} else {
						bs540 &= -5;
					}
					break;
				case 6:
					if(v540) {
						bs540 |= 2;
					} else {
						bs540 &= -3;
					}
					break;
				case 7:
					if(v540) {
						bs540 |= 1;
					} else {
						bs540 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs540;
			var this542 = 0;
			var bs541 = this542;
			var l541 = "** * ".length;
			var _g1542 = 0;
			var _g642 = l541;
			while(_g1542 < _g642) {
				var i542 = _g1542++;
				var no541 = "** * ".charCodeAt(i542);
				if(no541 == null) {
					break;
				}
				var v541;
				switch(no541) {
				case 32:
					v541 = false;
					break;
				case 42:
					v541 = true;
					break;
				case 48:
					v541 = false;
					break;
				case 49:
					v541 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("** * ".charCodeAt(i542)));
				}
				switch(i542 - (l541 - 8)) {
				case 0:
					if(v541) {
						bs541 |= 128;
					} else {
						bs541 &= -129;
					}
					break;
				case 1:
					if(v541) {
						bs541 |= 64;
					} else {
						bs541 &= -65;
					}
					break;
				case 2:
					if(v541) {
						bs541 |= 32;
					} else {
						bs541 &= -33;
					}
					break;
				case 3:
					if(v541) {
						bs541 |= 16;
					} else {
						bs541 &= -17;
					}
					break;
				case 4:
					if(v541) {
						bs541 |= 8;
					} else {
						bs541 &= -9;
					}
					break;
				case 5:
					if(v541) {
						bs541 |= 4;
					} else {
						bs541 &= -5;
					}
					break;
				case 6:
					if(v541) {
						bs541 |= 2;
					} else {
						bs541 &= -3;
					}
					break;
				case 7:
					if(v541) {
						bs541 |= 1;
					} else {
						bs541 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs541;
			var this543 = 0;
			var bs542 = this543;
			var l542 = "* * *".length;
			var _g1543 = 0;
			var _g643 = l542;
			while(_g1543 < _g643) {
				var i543 = _g1543++;
				var no542 = "* * *".charCodeAt(i543);
				if(no542 == null) {
					break;
				}
				var v542;
				switch(no542) {
				case 32:
					v542 = false;
					break;
				case 42:
					v542 = true;
					break;
				case 48:
					v542 = false;
					break;
				case 49:
					v542 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i543)));
				}
				switch(i543 - (l542 - 8)) {
				case 0:
					if(v542) {
						bs542 |= 128;
					} else {
						bs542 &= -129;
					}
					break;
				case 1:
					if(v542) {
						bs542 |= 64;
					} else {
						bs542 &= -65;
					}
					break;
				case 2:
					if(v542) {
						bs542 |= 32;
					} else {
						bs542 &= -33;
					}
					break;
				case 3:
					if(v542) {
						bs542 |= 16;
					} else {
						bs542 &= -17;
					}
					break;
				case 4:
					if(v542) {
						bs542 |= 8;
					} else {
						bs542 &= -9;
					}
					break;
				case 5:
					if(v542) {
						bs542 |= 4;
					} else {
						bs542 &= -5;
					}
					break;
				case 6:
					if(v542) {
						bs542 |= 2;
					} else {
						bs542 &= -3;
					}
					break;
				case 7:
					if(v542) {
						bs542 |= 1;
					} else {
						bs542 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs542;
			var this544 = 0;
			var bs543 = this544;
			var l543 = "* * *".length;
			var _g1544 = 0;
			var _g644 = l543;
			while(_g1544 < _g644) {
				var i544 = _g1544++;
				var no543 = "* * *".charCodeAt(i544);
				if(no543 == null) {
					break;
				}
				var v543;
				switch(no543) {
				case 32:
					v543 = false;
					break;
				case 42:
					v543 = true;
					break;
				case 48:
					v543 = false;
					break;
				case 49:
					v543 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i544)));
				}
				switch(i544 - (l543 - 8)) {
				case 0:
					if(v543) {
						bs543 |= 128;
					} else {
						bs543 &= -129;
					}
					break;
				case 1:
					if(v543) {
						bs543 |= 64;
					} else {
						bs543 &= -65;
					}
					break;
				case 2:
					if(v543) {
						bs543 |= 32;
					} else {
						bs543 &= -33;
					}
					break;
				case 3:
					if(v543) {
						bs543 |= 16;
					} else {
						bs543 &= -17;
					}
					break;
				case 4:
					if(v543) {
						bs543 |= 8;
					} else {
						bs543 &= -9;
					}
					break;
				case 5:
					if(v543) {
						bs543 |= 4;
					} else {
						bs543 &= -5;
					}
					break;
				case 6:
					if(v543) {
						bs543 |= 2;
					} else {
						bs543 &= -3;
					}
					break;
				case 7:
					if(v543) {
						bs543 |= 1;
					} else {
						bs543 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs543;
			var this545 = 0;
			var bs544 = this545;
			var l544 = "*   *".length;
			var _g1545 = 0;
			var _g645 = l544;
			while(_g1545 < _g645) {
				var i545 = _g1545++;
				var no544 = "*   *".charCodeAt(i545);
				if(no544 == null) {
					break;
				}
				var v544;
				switch(no544) {
				case 32:
					v544 = false;
					break;
				case 42:
					v544 = true;
					break;
				case 48:
					v544 = false;
					break;
				case 49:
					v544 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i545)));
				}
				switch(i545 - (l544 - 8)) {
				case 0:
					if(v544) {
						bs544 |= 128;
					} else {
						bs544 &= -129;
					}
					break;
				case 1:
					if(v544) {
						bs544 |= 64;
					} else {
						bs544 &= -65;
					}
					break;
				case 2:
					if(v544) {
						bs544 |= 32;
					} else {
						bs544 &= -33;
					}
					break;
				case 3:
					if(v544) {
						bs544 |= 16;
					} else {
						bs544 &= -17;
					}
					break;
				case 4:
					if(v544) {
						bs544 |= 8;
					} else {
						bs544 &= -9;
					}
					break;
				case 5:
					if(v544) {
						bs544 |= 4;
					} else {
						bs544 &= -5;
					}
					break;
				case 6:
					if(v544) {
						bs544 |= 2;
					} else {
						bs544 &= -3;
					}
					break;
				case 7:
					if(v544) {
						bs544 |= 1;
					} else {
						bs544 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs544;
			var this546 = 0;
			var bs545 = this546;
			var l545 = "*   *".length;
			var _g1546 = 0;
			var _g646 = l545;
			while(_g1546 < _g646) {
				var i546 = _g1546++;
				var no545 = "*   *".charCodeAt(i546);
				if(no545 == null) {
					break;
				}
				var v545;
				switch(no545) {
				case 32:
					v545 = false;
					break;
				case 42:
					v545 = true;
					break;
				case 48:
					v545 = false;
					break;
				case 49:
					v545 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i546)));
				}
				switch(i546 - (l545 - 8)) {
				case 0:
					if(v545) {
						bs545 |= 128;
					} else {
						bs545 &= -129;
					}
					break;
				case 1:
					if(v545) {
						bs545 |= 64;
					} else {
						bs545 &= -65;
					}
					break;
				case 2:
					if(v545) {
						bs545 |= 32;
					} else {
						bs545 &= -33;
					}
					break;
				case 3:
					if(v545) {
						bs545 |= 16;
					} else {
						bs545 &= -17;
					}
					break;
				case 4:
					if(v545) {
						bs545 |= 8;
					} else {
						bs545 &= -9;
					}
					break;
				case 5:
					if(v545) {
						bs545 |= 4;
					} else {
						bs545 &= -5;
					}
					break;
				case 6:
					if(v545) {
						bs545 |= 2;
					} else {
						bs545 &= -3;
					}
					break;
				case 7:
					if(v545) {
						bs545 |= 1;
					} else {
						bs545 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs545;
			break;
		case 110:
			var this547 = 0;
			var bs546 = this547;
			var l546 = "     ".length;
			var _g1547 = 0;
			var _g647 = l546;
			while(_g1547 < _g647) {
				var i547 = _g1547++;
				var no546 = "     ".charCodeAt(i547);
				if(no546 == null) {
					break;
				}
				var v546;
				switch(no546) {
				case 32:
					v546 = false;
					break;
				case 42:
					v546 = true;
					break;
				case 48:
					v546 = false;
					break;
				case 49:
					v546 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i547)));
				}
				switch(i547 - (l546 - 8)) {
				case 0:
					if(v546) {
						bs546 |= 128;
					} else {
						bs546 &= -129;
					}
					break;
				case 1:
					if(v546) {
						bs546 |= 64;
					} else {
						bs546 &= -65;
					}
					break;
				case 2:
					if(v546) {
						bs546 |= 32;
					} else {
						bs546 &= -33;
					}
					break;
				case 3:
					if(v546) {
						bs546 |= 16;
					} else {
						bs546 &= -17;
					}
					break;
				case 4:
					if(v546) {
						bs546 |= 8;
					} else {
						bs546 &= -9;
					}
					break;
				case 5:
					if(v546) {
						bs546 |= 4;
					} else {
						bs546 &= -5;
					}
					break;
				case 6:
					if(v546) {
						bs546 |= 2;
					} else {
						bs546 &= -3;
					}
					break;
				case 7:
					if(v546) {
						bs546 |= 1;
					} else {
						bs546 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs546;
			var this548 = 0;
			var bs547 = this548;
			var l547 = "     ".length;
			var _g1548 = 0;
			var _g648 = l547;
			while(_g1548 < _g648) {
				var i548 = _g1548++;
				var no547 = "     ".charCodeAt(i548);
				if(no547 == null) {
					break;
				}
				var v547;
				switch(no547) {
				case 32:
					v547 = false;
					break;
				case 42:
					v547 = true;
					break;
				case 48:
					v547 = false;
					break;
				case 49:
					v547 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i548)));
				}
				switch(i548 - (l547 - 8)) {
				case 0:
					if(v547) {
						bs547 |= 128;
					} else {
						bs547 &= -129;
					}
					break;
				case 1:
					if(v547) {
						bs547 |= 64;
					} else {
						bs547 &= -65;
					}
					break;
				case 2:
					if(v547) {
						bs547 |= 32;
					} else {
						bs547 &= -33;
					}
					break;
				case 3:
					if(v547) {
						bs547 |= 16;
					} else {
						bs547 &= -17;
					}
					break;
				case 4:
					if(v547) {
						bs547 |= 8;
					} else {
						bs547 &= -9;
					}
					break;
				case 5:
					if(v547) {
						bs547 |= 4;
					} else {
						bs547 &= -5;
					}
					break;
				case 6:
					if(v547) {
						bs547 |= 2;
					} else {
						bs547 &= -3;
					}
					break;
				case 7:
					if(v547) {
						bs547 |= 1;
					} else {
						bs547 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs547;
			var this549 = 0;
			var bs548 = this549;
			var l548 = "* ** ".length;
			var _g1549 = 0;
			var _g649 = l548;
			while(_g1549 < _g649) {
				var i549 = _g1549++;
				var no548 = "* ** ".charCodeAt(i549);
				if(no548 == null) {
					break;
				}
				var v548;
				switch(no548) {
				case 32:
					v548 = false;
					break;
				case 42:
					v548 = true;
					break;
				case 48:
					v548 = false;
					break;
				case 49:
					v548 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* ** ".charCodeAt(i549)));
				}
				switch(i549 - (l548 - 8)) {
				case 0:
					if(v548) {
						bs548 |= 128;
					} else {
						bs548 &= -129;
					}
					break;
				case 1:
					if(v548) {
						bs548 |= 64;
					} else {
						bs548 &= -65;
					}
					break;
				case 2:
					if(v548) {
						bs548 |= 32;
					} else {
						bs548 &= -33;
					}
					break;
				case 3:
					if(v548) {
						bs548 |= 16;
					} else {
						bs548 &= -17;
					}
					break;
				case 4:
					if(v548) {
						bs548 |= 8;
					} else {
						bs548 &= -9;
					}
					break;
				case 5:
					if(v548) {
						bs548 |= 4;
					} else {
						bs548 &= -5;
					}
					break;
				case 6:
					if(v548) {
						bs548 |= 2;
					} else {
						bs548 &= -3;
					}
					break;
				case 7:
					if(v548) {
						bs548 |= 1;
					} else {
						bs548 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs548;
			var this550 = 0;
			var bs549 = this550;
			var l549 = "**  *".length;
			var _g1550 = 0;
			var _g650 = l549;
			while(_g1550 < _g650) {
				var i550 = _g1550++;
				var no549 = "**  *".charCodeAt(i550);
				if(no549 == null) {
					break;
				}
				var v549;
				switch(no549) {
				case 32:
					v549 = false;
					break;
				case 42:
					v549 = true;
					break;
				case 48:
					v549 = false;
					break;
				case 49:
					v549 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i550)));
				}
				switch(i550 - (l549 - 8)) {
				case 0:
					if(v549) {
						bs549 |= 128;
					} else {
						bs549 &= -129;
					}
					break;
				case 1:
					if(v549) {
						bs549 |= 64;
					} else {
						bs549 &= -65;
					}
					break;
				case 2:
					if(v549) {
						bs549 |= 32;
					} else {
						bs549 &= -33;
					}
					break;
				case 3:
					if(v549) {
						bs549 |= 16;
					} else {
						bs549 &= -17;
					}
					break;
				case 4:
					if(v549) {
						bs549 |= 8;
					} else {
						bs549 &= -9;
					}
					break;
				case 5:
					if(v549) {
						bs549 |= 4;
					} else {
						bs549 &= -5;
					}
					break;
				case 6:
					if(v549) {
						bs549 |= 2;
					} else {
						bs549 &= -3;
					}
					break;
				case 7:
					if(v549) {
						bs549 |= 1;
					} else {
						bs549 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs549;
			var this551 = 0;
			var bs550 = this551;
			var l550 = "*   *".length;
			var _g1551 = 0;
			var _g651 = l550;
			while(_g1551 < _g651) {
				var i551 = _g1551++;
				var no550 = "*   *".charCodeAt(i551);
				if(no550 == null) {
					break;
				}
				var v550;
				switch(no550) {
				case 32:
					v550 = false;
					break;
				case 42:
					v550 = true;
					break;
				case 48:
					v550 = false;
					break;
				case 49:
					v550 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i551)));
				}
				switch(i551 - (l550 - 8)) {
				case 0:
					if(v550) {
						bs550 |= 128;
					} else {
						bs550 &= -129;
					}
					break;
				case 1:
					if(v550) {
						bs550 |= 64;
					} else {
						bs550 &= -65;
					}
					break;
				case 2:
					if(v550) {
						bs550 |= 32;
					} else {
						bs550 &= -33;
					}
					break;
				case 3:
					if(v550) {
						bs550 |= 16;
					} else {
						bs550 &= -17;
					}
					break;
				case 4:
					if(v550) {
						bs550 |= 8;
					} else {
						bs550 &= -9;
					}
					break;
				case 5:
					if(v550) {
						bs550 |= 4;
					} else {
						bs550 &= -5;
					}
					break;
				case 6:
					if(v550) {
						bs550 |= 2;
					} else {
						bs550 &= -3;
					}
					break;
				case 7:
					if(v550) {
						bs550 |= 1;
					} else {
						bs550 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs550;
			var this552 = 0;
			var bs551 = this552;
			var l551 = "*   *".length;
			var _g1552 = 0;
			var _g652 = l551;
			while(_g1552 < _g652) {
				var i552 = _g1552++;
				var no551 = "*   *".charCodeAt(i552);
				if(no551 == null) {
					break;
				}
				var v551;
				switch(no551) {
				case 32:
					v551 = false;
					break;
				case 42:
					v551 = true;
					break;
				case 48:
					v551 = false;
					break;
				case 49:
					v551 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i552)));
				}
				switch(i552 - (l551 - 8)) {
				case 0:
					if(v551) {
						bs551 |= 128;
					} else {
						bs551 &= -129;
					}
					break;
				case 1:
					if(v551) {
						bs551 |= 64;
					} else {
						bs551 &= -65;
					}
					break;
				case 2:
					if(v551) {
						bs551 |= 32;
					} else {
						bs551 &= -33;
					}
					break;
				case 3:
					if(v551) {
						bs551 |= 16;
					} else {
						bs551 &= -17;
					}
					break;
				case 4:
					if(v551) {
						bs551 |= 8;
					} else {
						bs551 &= -9;
					}
					break;
				case 5:
					if(v551) {
						bs551 |= 4;
					} else {
						bs551 &= -5;
					}
					break;
				case 6:
					if(v551) {
						bs551 |= 2;
					} else {
						bs551 &= -3;
					}
					break;
				case 7:
					if(v551) {
						bs551 |= 1;
					} else {
						bs551 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs551;
			var this553 = 0;
			var bs552 = this553;
			var l552 = "*   *".length;
			var _g1553 = 0;
			var _g653 = l552;
			while(_g1553 < _g653) {
				var i553 = _g1553++;
				var no552 = "*   *".charCodeAt(i553);
				if(no552 == null) {
					break;
				}
				var v552;
				switch(no552) {
				case 32:
					v552 = false;
					break;
				case 42:
					v552 = true;
					break;
				case 48:
					v552 = false;
					break;
				case 49:
					v552 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i553)));
				}
				switch(i553 - (l552 - 8)) {
				case 0:
					if(v552) {
						bs552 |= 128;
					} else {
						bs552 &= -129;
					}
					break;
				case 1:
					if(v552) {
						bs552 |= 64;
					} else {
						bs552 &= -65;
					}
					break;
				case 2:
					if(v552) {
						bs552 |= 32;
					} else {
						bs552 &= -33;
					}
					break;
				case 3:
					if(v552) {
						bs552 |= 16;
					} else {
						bs552 &= -17;
					}
					break;
				case 4:
					if(v552) {
						bs552 |= 8;
					} else {
						bs552 &= -9;
					}
					break;
				case 5:
					if(v552) {
						bs552 |= 4;
					} else {
						bs552 &= -5;
					}
					break;
				case 6:
					if(v552) {
						bs552 |= 2;
					} else {
						bs552 &= -3;
					}
					break;
				case 7:
					if(v552) {
						bs552 |= 1;
					} else {
						bs552 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs552;
			break;
		case 111:
			var this554 = 0;
			var bs553 = this554;
			var l553 = "     ".length;
			var _g1554 = 0;
			var _g654 = l553;
			while(_g1554 < _g654) {
				var i554 = _g1554++;
				var no553 = "     ".charCodeAt(i554);
				if(no553 == null) {
					break;
				}
				var v553;
				switch(no553) {
				case 32:
					v553 = false;
					break;
				case 42:
					v553 = true;
					break;
				case 48:
					v553 = false;
					break;
				case 49:
					v553 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i554)));
				}
				switch(i554 - (l553 - 8)) {
				case 0:
					if(v553) {
						bs553 |= 128;
					} else {
						bs553 &= -129;
					}
					break;
				case 1:
					if(v553) {
						bs553 |= 64;
					} else {
						bs553 &= -65;
					}
					break;
				case 2:
					if(v553) {
						bs553 |= 32;
					} else {
						bs553 &= -33;
					}
					break;
				case 3:
					if(v553) {
						bs553 |= 16;
					} else {
						bs553 &= -17;
					}
					break;
				case 4:
					if(v553) {
						bs553 |= 8;
					} else {
						bs553 &= -9;
					}
					break;
				case 5:
					if(v553) {
						bs553 |= 4;
					} else {
						bs553 &= -5;
					}
					break;
				case 6:
					if(v553) {
						bs553 |= 2;
					} else {
						bs553 &= -3;
					}
					break;
				case 7:
					if(v553) {
						bs553 |= 1;
					} else {
						bs553 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs553;
			var this555 = 0;
			var bs554 = this555;
			var l554 = "     ".length;
			var _g1555 = 0;
			var _g655 = l554;
			while(_g1555 < _g655) {
				var i555 = _g1555++;
				var no554 = "     ".charCodeAt(i555);
				if(no554 == null) {
					break;
				}
				var v554;
				switch(no554) {
				case 32:
					v554 = false;
					break;
				case 42:
					v554 = true;
					break;
				case 48:
					v554 = false;
					break;
				case 49:
					v554 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i555)));
				}
				switch(i555 - (l554 - 8)) {
				case 0:
					if(v554) {
						bs554 |= 128;
					} else {
						bs554 &= -129;
					}
					break;
				case 1:
					if(v554) {
						bs554 |= 64;
					} else {
						bs554 &= -65;
					}
					break;
				case 2:
					if(v554) {
						bs554 |= 32;
					} else {
						bs554 &= -33;
					}
					break;
				case 3:
					if(v554) {
						bs554 |= 16;
					} else {
						bs554 &= -17;
					}
					break;
				case 4:
					if(v554) {
						bs554 |= 8;
					} else {
						bs554 &= -9;
					}
					break;
				case 5:
					if(v554) {
						bs554 |= 4;
					} else {
						bs554 &= -5;
					}
					break;
				case 6:
					if(v554) {
						bs554 |= 2;
					} else {
						bs554 &= -3;
					}
					break;
				case 7:
					if(v554) {
						bs554 |= 1;
					} else {
						bs554 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs554;
			var this556 = 0;
			var bs555 = this556;
			var l555 = " *** ".length;
			var _g1556 = 0;
			var _g656 = l555;
			while(_g1556 < _g656) {
				var i556 = _g1556++;
				var no555 = " *** ".charCodeAt(i556);
				if(no555 == null) {
					break;
				}
				var v555;
				switch(no555) {
				case 32:
					v555 = false;
					break;
				case 42:
					v555 = true;
					break;
				case 48:
					v555 = false;
					break;
				case 49:
					v555 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i556)));
				}
				switch(i556 - (l555 - 8)) {
				case 0:
					if(v555) {
						bs555 |= 128;
					} else {
						bs555 &= -129;
					}
					break;
				case 1:
					if(v555) {
						bs555 |= 64;
					} else {
						bs555 &= -65;
					}
					break;
				case 2:
					if(v555) {
						bs555 |= 32;
					} else {
						bs555 &= -33;
					}
					break;
				case 3:
					if(v555) {
						bs555 |= 16;
					} else {
						bs555 &= -17;
					}
					break;
				case 4:
					if(v555) {
						bs555 |= 8;
					} else {
						bs555 &= -9;
					}
					break;
				case 5:
					if(v555) {
						bs555 |= 4;
					} else {
						bs555 &= -5;
					}
					break;
				case 6:
					if(v555) {
						bs555 |= 2;
					} else {
						bs555 &= -3;
					}
					break;
				case 7:
					if(v555) {
						bs555 |= 1;
					} else {
						bs555 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs555;
			var this557 = 0;
			var bs556 = this557;
			var l556 = "*   *".length;
			var _g1557 = 0;
			var _g657 = l556;
			while(_g1557 < _g657) {
				var i557 = _g1557++;
				var no556 = "*   *".charCodeAt(i557);
				if(no556 == null) {
					break;
				}
				var v556;
				switch(no556) {
				case 32:
					v556 = false;
					break;
				case 42:
					v556 = true;
					break;
				case 48:
					v556 = false;
					break;
				case 49:
					v556 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i557)));
				}
				switch(i557 - (l556 - 8)) {
				case 0:
					if(v556) {
						bs556 |= 128;
					} else {
						bs556 &= -129;
					}
					break;
				case 1:
					if(v556) {
						bs556 |= 64;
					} else {
						bs556 &= -65;
					}
					break;
				case 2:
					if(v556) {
						bs556 |= 32;
					} else {
						bs556 &= -33;
					}
					break;
				case 3:
					if(v556) {
						bs556 |= 16;
					} else {
						bs556 &= -17;
					}
					break;
				case 4:
					if(v556) {
						bs556 |= 8;
					} else {
						bs556 &= -9;
					}
					break;
				case 5:
					if(v556) {
						bs556 |= 4;
					} else {
						bs556 &= -5;
					}
					break;
				case 6:
					if(v556) {
						bs556 |= 2;
					} else {
						bs556 &= -3;
					}
					break;
				case 7:
					if(v556) {
						bs556 |= 1;
					} else {
						bs556 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs556;
			var this558 = 0;
			var bs557 = this558;
			var l557 = "*   *".length;
			var _g1558 = 0;
			var _g658 = l557;
			while(_g1558 < _g658) {
				var i558 = _g1558++;
				var no557 = "*   *".charCodeAt(i558);
				if(no557 == null) {
					break;
				}
				var v557;
				switch(no557) {
				case 32:
					v557 = false;
					break;
				case 42:
					v557 = true;
					break;
				case 48:
					v557 = false;
					break;
				case 49:
					v557 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i558)));
				}
				switch(i558 - (l557 - 8)) {
				case 0:
					if(v557) {
						bs557 |= 128;
					} else {
						bs557 &= -129;
					}
					break;
				case 1:
					if(v557) {
						bs557 |= 64;
					} else {
						bs557 &= -65;
					}
					break;
				case 2:
					if(v557) {
						bs557 |= 32;
					} else {
						bs557 &= -33;
					}
					break;
				case 3:
					if(v557) {
						bs557 |= 16;
					} else {
						bs557 &= -17;
					}
					break;
				case 4:
					if(v557) {
						bs557 |= 8;
					} else {
						bs557 &= -9;
					}
					break;
				case 5:
					if(v557) {
						bs557 |= 4;
					} else {
						bs557 &= -5;
					}
					break;
				case 6:
					if(v557) {
						bs557 |= 2;
					} else {
						bs557 &= -3;
					}
					break;
				case 7:
					if(v557) {
						bs557 |= 1;
					} else {
						bs557 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs557;
			var this559 = 0;
			var bs558 = this559;
			var l558 = "*   *".length;
			var _g1559 = 0;
			var _g659 = l558;
			while(_g1559 < _g659) {
				var i559 = _g1559++;
				var no558 = "*   *".charCodeAt(i559);
				if(no558 == null) {
					break;
				}
				var v558;
				switch(no558) {
				case 32:
					v558 = false;
					break;
				case 42:
					v558 = true;
					break;
				case 48:
					v558 = false;
					break;
				case 49:
					v558 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i559)));
				}
				switch(i559 - (l558 - 8)) {
				case 0:
					if(v558) {
						bs558 |= 128;
					} else {
						bs558 &= -129;
					}
					break;
				case 1:
					if(v558) {
						bs558 |= 64;
					} else {
						bs558 &= -65;
					}
					break;
				case 2:
					if(v558) {
						bs558 |= 32;
					} else {
						bs558 &= -33;
					}
					break;
				case 3:
					if(v558) {
						bs558 |= 16;
					} else {
						bs558 &= -17;
					}
					break;
				case 4:
					if(v558) {
						bs558 |= 8;
					} else {
						bs558 &= -9;
					}
					break;
				case 5:
					if(v558) {
						bs558 |= 4;
					} else {
						bs558 &= -5;
					}
					break;
				case 6:
					if(v558) {
						bs558 |= 2;
					} else {
						bs558 &= -3;
					}
					break;
				case 7:
					if(v558) {
						bs558 |= 1;
					} else {
						bs558 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs558;
			var this560 = 0;
			var bs559 = this560;
			var l559 = " *** ".length;
			var _g1560 = 0;
			var _g660 = l559;
			while(_g1560 < _g660) {
				var i560 = _g1560++;
				var no559 = " *** ".charCodeAt(i560);
				if(no559 == null) {
					break;
				}
				var v559;
				switch(no559) {
				case 32:
					v559 = false;
					break;
				case 42:
					v559 = true;
					break;
				case 48:
					v559 = false;
					break;
				case 49:
					v559 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i560)));
				}
				switch(i560 - (l559 - 8)) {
				case 0:
					if(v559) {
						bs559 |= 128;
					} else {
						bs559 &= -129;
					}
					break;
				case 1:
					if(v559) {
						bs559 |= 64;
					} else {
						bs559 &= -65;
					}
					break;
				case 2:
					if(v559) {
						bs559 |= 32;
					} else {
						bs559 &= -33;
					}
					break;
				case 3:
					if(v559) {
						bs559 |= 16;
					} else {
						bs559 &= -17;
					}
					break;
				case 4:
					if(v559) {
						bs559 |= 8;
					} else {
						bs559 &= -9;
					}
					break;
				case 5:
					if(v559) {
						bs559 |= 4;
					} else {
						bs559 &= -5;
					}
					break;
				case 6:
					if(v559) {
						bs559 |= 2;
					} else {
						bs559 &= -3;
					}
					break;
				case 7:
					if(v559) {
						bs559 |= 1;
					} else {
						bs559 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs559;
			break;
		case 112:
			var this561 = 0;
			var bs560 = this561;
			var l560 = "     ".length;
			var _g1561 = 0;
			var _g661 = l560;
			while(_g1561 < _g661) {
				var i561 = _g1561++;
				var no560 = "     ".charCodeAt(i561);
				if(no560 == null) {
					break;
				}
				var v560;
				switch(no560) {
				case 32:
					v560 = false;
					break;
				case 42:
					v560 = true;
					break;
				case 48:
					v560 = false;
					break;
				case 49:
					v560 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i561)));
				}
				switch(i561 - (l560 - 8)) {
				case 0:
					if(v560) {
						bs560 |= 128;
					} else {
						bs560 &= -129;
					}
					break;
				case 1:
					if(v560) {
						bs560 |= 64;
					} else {
						bs560 &= -65;
					}
					break;
				case 2:
					if(v560) {
						bs560 |= 32;
					} else {
						bs560 &= -33;
					}
					break;
				case 3:
					if(v560) {
						bs560 |= 16;
					} else {
						bs560 &= -17;
					}
					break;
				case 4:
					if(v560) {
						bs560 |= 8;
					} else {
						bs560 &= -9;
					}
					break;
				case 5:
					if(v560) {
						bs560 |= 4;
					} else {
						bs560 &= -5;
					}
					break;
				case 6:
					if(v560) {
						bs560 |= 2;
					} else {
						bs560 &= -3;
					}
					break;
				case 7:
					if(v560) {
						bs560 |= 1;
					} else {
						bs560 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs560;
			var this562 = 0;
			var bs561 = this562;
			var l561 = "     ".length;
			var _g1562 = 0;
			var _g662 = l561;
			while(_g1562 < _g662) {
				var i562 = _g1562++;
				var no561 = "     ".charCodeAt(i562);
				if(no561 == null) {
					break;
				}
				var v561;
				switch(no561) {
				case 32:
					v561 = false;
					break;
				case 42:
					v561 = true;
					break;
				case 48:
					v561 = false;
					break;
				case 49:
					v561 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i562)));
				}
				switch(i562 - (l561 - 8)) {
				case 0:
					if(v561) {
						bs561 |= 128;
					} else {
						bs561 &= -129;
					}
					break;
				case 1:
					if(v561) {
						bs561 |= 64;
					} else {
						bs561 &= -65;
					}
					break;
				case 2:
					if(v561) {
						bs561 |= 32;
					} else {
						bs561 &= -33;
					}
					break;
				case 3:
					if(v561) {
						bs561 |= 16;
					} else {
						bs561 &= -17;
					}
					break;
				case 4:
					if(v561) {
						bs561 |= 8;
					} else {
						bs561 &= -9;
					}
					break;
				case 5:
					if(v561) {
						bs561 |= 4;
					} else {
						bs561 &= -5;
					}
					break;
				case 6:
					if(v561) {
						bs561 |= 2;
					} else {
						bs561 &= -3;
					}
					break;
				case 7:
					if(v561) {
						bs561 |= 1;
					} else {
						bs561 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs561;
			var this563 = 0;
			var bs562 = this563;
			var l562 = "**** ".length;
			var _g1563 = 0;
			var _g663 = l562;
			while(_g1563 < _g663) {
				var i563 = _g1563++;
				var no562 = "**** ".charCodeAt(i563);
				if(no562 == null) {
					break;
				}
				var v562;
				switch(no562) {
				case 32:
					v562 = false;
					break;
				case 42:
					v562 = true;
					break;
				case 48:
					v562 = false;
					break;
				case 49:
					v562 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i563)));
				}
				switch(i563 - (l562 - 8)) {
				case 0:
					if(v562) {
						bs562 |= 128;
					} else {
						bs562 &= -129;
					}
					break;
				case 1:
					if(v562) {
						bs562 |= 64;
					} else {
						bs562 &= -65;
					}
					break;
				case 2:
					if(v562) {
						bs562 |= 32;
					} else {
						bs562 &= -33;
					}
					break;
				case 3:
					if(v562) {
						bs562 |= 16;
					} else {
						bs562 &= -17;
					}
					break;
				case 4:
					if(v562) {
						bs562 |= 8;
					} else {
						bs562 &= -9;
					}
					break;
				case 5:
					if(v562) {
						bs562 |= 4;
					} else {
						bs562 &= -5;
					}
					break;
				case 6:
					if(v562) {
						bs562 |= 2;
					} else {
						bs562 &= -3;
					}
					break;
				case 7:
					if(v562) {
						bs562 |= 1;
					} else {
						bs562 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs562;
			var this564 = 0;
			var bs563 = this564;
			var l563 = "*   *".length;
			var _g1564 = 0;
			var _g664 = l563;
			while(_g1564 < _g664) {
				var i564 = _g1564++;
				var no563 = "*   *".charCodeAt(i564);
				if(no563 == null) {
					break;
				}
				var v563;
				switch(no563) {
				case 32:
					v563 = false;
					break;
				case 42:
					v563 = true;
					break;
				case 48:
					v563 = false;
					break;
				case 49:
					v563 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i564)));
				}
				switch(i564 - (l563 - 8)) {
				case 0:
					if(v563) {
						bs563 |= 128;
					} else {
						bs563 &= -129;
					}
					break;
				case 1:
					if(v563) {
						bs563 |= 64;
					} else {
						bs563 &= -65;
					}
					break;
				case 2:
					if(v563) {
						bs563 |= 32;
					} else {
						bs563 &= -33;
					}
					break;
				case 3:
					if(v563) {
						bs563 |= 16;
					} else {
						bs563 &= -17;
					}
					break;
				case 4:
					if(v563) {
						bs563 |= 8;
					} else {
						bs563 &= -9;
					}
					break;
				case 5:
					if(v563) {
						bs563 |= 4;
					} else {
						bs563 &= -5;
					}
					break;
				case 6:
					if(v563) {
						bs563 |= 2;
					} else {
						bs563 &= -3;
					}
					break;
				case 7:
					if(v563) {
						bs563 |= 1;
					} else {
						bs563 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs563;
			var this565 = 0;
			var bs564 = this565;
			var l564 = "**** ".length;
			var _g1565 = 0;
			var _g665 = l564;
			while(_g1565 < _g665) {
				var i565 = _g1565++;
				var no564 = "**** ".charCodeAt(i565);
				if(no564 == null) {
					break;
				}
				var v564;
				switch(no564) {
				case 32:
					v564 = false;
					break;
				case 42:
					v564 = true;
					break;
				case 48:
					v564 = false;
					break;
				case 49:
					v564 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i565)));
				}
				switch(i565 - (l564 - 8)) {
				case 0:
					if(v564) {
						bs564 |= 128;
					} else {
						bs564 &= -129;
					}
					break;
				case 1:
					if(v564) {
						bs564 |= 64;
					} else {
						bs564 &= -65;
					}
					break;
				case 2:
					if(v564) {
						bs564 |= 32;
					} else {
						bs564 &= -33;
					}
					break;
				case 3:
					if(v564) {
						bs564 |= 16;
					} else {
						bs564 &= -17;
					}
					break;
				case 4:
					if(v564) {
						bs564 |= 8;
					} else {
						bs564 &= -9;
					}
					break;
				case 5:
					if(v564) {
						bs564 |= 4;
					} else {
						bs564 &= -5;
					}
					break;
				case 6:
					if(v564) {
						bs564 |= 2;
					} else {
						bs564 &= -3;
					}
					break;
				case 7:
					if(v564) {
						bs564 |= 1;
					} else {
						bs564 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs564;
			var this566 = 0;
			var bs565 = this566;
			var l565 = "*    ".length;
			var _g1566 = 0;
			var _g666 = l565;
			while(_g1566 < _g666) {
				var i566 = _g1566++;
				var no565 = "*    ".charCodeAt(i566);
				if(no565 == null) {
					break;
				}
				var v565;
				switch(no565) {
				case 32:
					v565 = false;
					break;
				case 42:
					v565 = true;
					break;
				case 48:
					v565 = false;
					break;
				case 49:
					v565 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i566)));
				}
				switch(i566 - (l565 - 8)) {
				case 0:
					if(v565) {
						bs565 |= 128;
					} else {
						bs565 &= -129;
					}
					break;
				case 1:
					if(v565) {
						bs565 |= 64;
					} else {
						bs565 &= -65;
					}
					break;
				case 2:
					if(v565) {
						bs565 |= 32;
					} else {
						bs565 &= -33;
					}
					break;
				case 3:
					if(v565) {
						bs565 |= 16;
					} else {
						bs565 &= -17;
					}
					break;
				case 4:
					if(v565) {
						bs565 |= 8;
					} else {
						bs565 &= -9;
					}
					break;
				case 5:
					if(v565) {
						bs565 |= 4;
					} else {
						bs565 &= -5;
					}
					break;
				case 6:
					if(v565) {
						bs565 |= 2;
					} else {
						bs565 &= -3;
					}
					break;
				case 7:
					if(v565) {
						bs565 |= 1;
					} else {
						bs565 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs565;
			var this567 = 0;
			var bs566 = this567;
			var l566 = "*    ".length;
			var _g1567 = 0;
			var _g667 = l566;
			while(_g1567 < _g667) {
				var i567 = _g1567++;
				var no566 = "*    ".charCodeAt(i567);
				if(no566 == null) {
					break;
				}
				var v566;
				switch(no566) {
				case 32:
					v566 = false;
					break;
				case 42:
					v566 = true;
					break;
				case 48:
					v566 = false;
					break;
				case 49:
					v566 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i567)));
				}
				switch(i567 - (l566 - 8)) {
				case 0:
					if(v566) {
						bs566 |= 128;
					} else {
						bs566 &= -129;
					}
					break;
				case 1:
					if(v566) {
						bs566 |= 64;
					} else {
						bs566 &= -65;
					}
					break;
				case 2:
					if(v566) {
						bs566 |= 32;
					} else {
						bs566 &= -33;
					}
					break;
				case 3:
					if(v566) {
						bs566 |= 16;
					} else {
						bs566 &= -17;
					}
					break;
				case 4:
					if(v566) {
						bs566 |= 8;
					} else {
						bs566 &= -9;
					}
					break;
				case 5:
					if(v566) {
						bs566 |= 4;
					} else {
						bs566 &= -5;
					}
					break;
				case 6:
					if(v566) {
						bs566 |= 2;
					} else {
						bs566 &= -3;
					}
					break;
				case 7:
					if(v566) {
						bs566 |= 1;
					} else {
						bs566 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs566;
			break;
		case 113:
			var this568 = 0;
			var bs567 = this568;
			var l567 = "     ".length;
			var _g1568 = 0;
			var _g668 = l567;
			while(_g1568 < _g668) {
				var i568 = _g1568++;
				var no567 = "     ".charCodeAt(i568);
				if(no567 == null) {
					break;
				}
				var v567;
				switch(no567) {
				case 32:
					v567 = false;
					break;
				case 42:
					v567 = true;
					break;
				case 48:
					v567 = false;
					break;
				case 49:
					v567 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i568)));
				}
				switch(i568 - (l567 - 8)) {
				case 0:
					if(v567) {
						bs567 |= 128;
					} else {
						bs567 &= -129;
					}
					break;
				case 1:
					if(v567) {
						bs567 |= 64;
					} else {
						bs567 &= -65;
					}
					break;
				case 2:
					if(v567) {
						bs567 |= 32;
					} else {
						bs567 &= -33;
					}
					break;
				case 3:
					if(v567) {
						bs567 |= 16;
					} else {
						bs567 &= -17;
					}
					break;
				case 4:
					if(v567) {
						bs567 |= 8;
					} else {
						bs567 &= -9;
					}
					break;
				case 5:
					if(v567) {
						bs567 |= 4;
					} else {
						bs567 &= -5;
					}
					break;
				case 6:
					if(v567) {
						bs567 |= 2;
					} else {
						bs567 &= -3;
					}
					break;
				case 7:
					if(v567) {
						bs567 |= 1;
					} else {
						bs567 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs567;
			var this569 = 0;
			var bs568 = this569;
			var l568 = "     ".length;
			var _g1569 = 0;
			var _g669 = l568;
			while(_g1569 < _g669) {
				var i569 = _g1569++;
				var no568 = "     ".charCodeAt(i569);
				if(no568 == null) {
					break;
				}
				var v568;
				switch(no568) {
				case 32:
					v568 = false;
					break;
				case 42:
					v568 = true;
					break;
				case 48:
					v568 = false;
					break;
				case 49:
					v568 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i569)));
				}
				switch(i569 - (l568 - 8)) {
				case 0:
					if(v568) {
						bs568 |= 128;
					} else {
						bs568 &= -129;
					}
					break;
				case 1:
					if(v568) {
						bs568 |= 64;
					} else {
						bs568 &= -65;
					}
					break;
				case 2:
					if(v568) {
						bs568 |= 32;
					} else {
						bs568 &= -33;
					}
					break;
				case 3:
					if(v568) {
						bs568 |= 16;
					} else {
						bs568 &= -17;
					}
					break;
				case 4:
					if(v568) {
						bs568 |= 8;
					} else {
						bs568 &= -9;
					}
					break;
				case 5:
					if(v568) {
						bs568 |= 4;
					} else {
						bs568 &= -5;
					}
					break;
				case 6:
					if(v568) {
						bs568 |= 2;
					} else {
						bs568 &= -3;
					}
					break;
				case 7:
					if(v568) {
						bs568 |= 1;
					} else {
						bs568 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs568;
			var this570 = 0;
			var bs569 = this570;
			var l569 = " ** *".length;
			var _g1570 = 0;
			var _g670 = l569;
			while(_g1570 < _g670) {
				var i570 = _g1570++;
				var no569 = " ** *".charCodeAt(i570);
				if(no569 == null) {
					break;
				}
				var v569;
				switch(no569) {
				case 32:
					v569 = false;
					break;
				case 42:
					v569 = true;
					break;
				case 48:
					v569 = false;
					break;
				case 49:
					v569 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i570)));
				}
				switch(i570 - (l569 - 8)) {
				case 0:
					if(v569) {
						bs569 |= 128;
					} else {
						bs569 &= -129;
					}
					break;
				case 1:
					if(v569) {
						bs569 |= 64;
					} else {
						bs569 &= -65;
					}
					break;
				case 2:
					if(v569) {
						bs569 |= 32;
					} else {
						bs569 &= -33;
					}
					break;
				case 3:
					if(v569) {
						bs569 |= 16;
					} else {
						bs569 &= -17;
					}
					break;
				case 4:
					if(v569) {
						bs569 |= 8;
					} else {
						bs569 &= -9;
					}
					break;
				case 5:
					if(v569) {
						bs569 |= 4;
					} else {
						bs569 &= -5;
					}
					break;
				case 6:
					if(v569) {
						bs569 |= 2;
					} else {
						bs569 &= -3;
					}
					break;
				case 7:
					if(v569) {
						bs569 |= 1;
					} else {
						bs569 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs569;
			var this571 = 0;
			var bs570 = this571;
			var l570 = "*  **".length;
			var _g1571 = 0;
			var _g671 = l570;
			while(_g1571 < _g671) {
				var i571 = _g1571++;
				var no570 = "*  **".charCodeAt(i571);
				if(no570 == null) {
					break;
				}
				var v570;
				switch(no570) {
				case 32:
					v570 = false;
					break;
				case 42:
					v570 = true;
					break;
				case 48:
					v570 = false;
					break;
				case 49:
					v570 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  **".charCodeAt(i571)));
				}
				switch(i571 - (l570 - 8)) {
				case 0:
					if(v570) {
						bs570 |= 128;
					} else {
						bs570 &= -129;
					}
					break;
				case 1:
					if(v570) {
						bs570 |= 64;
					} else {
						bs570 &= -65;
					}
					break;
				case 2:
					if(v570) {
						bs570 |= 32;
					} else {
						bs570 &= -33;
					}
					break;
				case 3:
					if(v570) {
						bs570 |= 16;
					} else {
						bs570 &= -17;
					}
					break;
				case 4:
					if(v570) {
						bs570 |= 8;
					} else {
						bs570 &= -9;
					}
					break;
				case 5:
					if(v570) {
						bs570 |= 4;
					} else {
						bs570 &= -5;
					}
					break;
				case 6:
					if(v570) {
						bs570 |= 2;
					} else {
						bs570 &= -3;
					}
					break;
				case 7:
					if(v570) {
						bs570 |= 1;
					} else {
						bs570 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs570;
			var this572 = 0;
			var bs571 = this572;
			var l571 = " ****".length;
			var _g1572 = 0;
			var _g672 = l571;
			while(_g1572 < _g672) {
				var i572 = _g1572++;
				var no571 = " ****".charCodeAt(i572);
				if(no571 == null) {
					break;
				}
				var v571;
				switch(no571) {
				case 32:
					v571 = false;
					break;
				case 42:
					v571 = true;
					break;
				case 48:
					v571 = false;
					break;
				case 49:
					v571 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i572)));
				}
				switch(i572 - (l571 - 8)) {
				case 0:
					if(v571) {
						bs571 |= 128;
					} else {
						bs571 &= -129;
					}
					break;
				case 1:
					if(v571) {
						bs571 |= 64;
					} else {
						bs571 &= -65;
					}
					break;
				case 2:
					if(v571) {
						bs571 |= 32;
					} else {
						bs571 &= -33;
					}
					break;
				case 3:
					if(v571) {
						bs571 |= 16;
					} else {
						bs571 &= -17;
					}
					break;
				case 4:
					if(v571) {
						bs571 |= 8;
					} else {
						bs571 &= -9;
					}
					break;
				case 5:
					if(v571) {
						bs571 |= 4;
					} else {
						bs571 &= -5;
					}
					break;
				case 6:
					if(v571) {
						bs571 |= 2;
					} else {
						bs571 &= -3;
					}
					break;
				case 7:
					if(v571) {
						bs571 |= 1;
					} else {
						bs571 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs571;
			var this573 = 0;
			var bs572 = this573;
			var l572 = "    *".length;
			var _g1573 = 0;
			var _g673 = l572;
			while(_g1573 < _g673) {
				var i573 = _g1573++;
				var no572 = "    *".charCodeAt(i573);
				if(no572 == null) {
					break;
				}
				var v572;
				switch(no572) {
				case 32:
					v572 = false;
					break;
				case 42:
					v572 = true;
					break;
				case 48:
					v572 = false;
					break;
				case 49:
					v572 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i573)));
				}
				switch(i573 - (l572 - 8)) {
				case 0:
					if(v572) {
						bs572 |= 128;
					} else {
						bs572 &= -129;
					}
					break;
				case 1:
					if(v572) {
						bs572 |= 64;
					} else {
						bs572 &= -65;
					}
					break;
				case 2:
					if(v572) {
						bs572 |= 32;
					} else {
						bs572 &= -33;
					}
					break;
				case 3:
					if(v572) {
						bs572 |= 16;
					} else {
						bs572 &= -17;
					}
					break;
				case 4:
					if(v572) {
						bs572 |= 8;
					} else {
						bs572 &= -9;
					}
					break;
				case 5:
					if(v572) {
						bs572 |= 4;
					} else {
						bs572 &= -5;
					}
					break;
				case 6:
					if(v572) {
						bs572 |= 2;
					} else {
						bs572 &= -3;
					}
					break;
				case 7:
					if(v572) {
						bs572 |= 1;
					} else {
						bs572 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs572;
			var this574 = 0;
			var bs573 = this574;
			var l573 = "    *".length;
			var _g1574 = 0;
			var _g674 = l573;
			while(_g1574 < _g674) {
				var i574 = _g1574++;
				var no573 = "    *".charCodeAt(i574);
				if(no573 == null) {
					break;
				}
				var v573;
				switch(no573) {
				case 32:
					v573 = false;
					break;
				case 42:
					v573 = true;
					break;
				case 48:
					v573 = false;
					break;
				case 49:
					v573 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i574)));
				}
				switch(i574 - (l573 - 8)) {
				case 0:
					if(v573) {
						bs573 |= 128;
					} else {
						bs573 &= -129;
					}
					break;
				case 1:
					if(v573) {
						bs573 |= 64;
					} else {
						bs573 &= -65;
					}
					break;
				case 2:
					if(v573) {
						bs573 |= 32;
					} else {
						bs573 &= -33;
					}
					break;
				case 3:
					if(v573) {
						bs573 |= 16;
					} else {
						bs573 &= -17;
					}
					break;
				case 4:
					if(v573) {
						bs573 |= 8;
					} else {
						bs573 &= -9;
					}
					break;
				case 5:
					if(v573) {
						bs573 |= 4;
					} else {
						bs573 &= -5;
					}
					break;
				case 6:
					if(v573) {
						bs573 |= 2;
					} else {
						bs573 &= -3;
					}
					break;
				case 7:
					if(v573) {
						bs573 |= 1;
					} else {
						bs573 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs573;
			break;
		case 114:
			var this575 = 0;
			var bs574 = this575;
			var l574 = "     ".length;
			var _g1575 = 0;
			var _g675 = l574;
			while(_g1575 < _g675) {
				var i575 = _g1575++;
				var no574 = "     ".charCodeAt(i575);
				if(no574 == null) {
					break;
				}
				var v574;
				switch(no574) {
				case 32:
					v574 = false;
					break;
				case 42:
					v574 = true;
					break;
				case 48:
					v574 = false;
					break;
				case 49:
					v574 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i575)));
				}
				switch(i575 - (l574 - 8)) {
				case 0:
					if(v574) {
						bs574 |= 128;
					} else {
						bs574 &= -129;
					}
					break;
				case 1:
					if(v574) {
						bs574 |= 64;
					} else {
						bs574 &= -65;
					}
					break;
				case 2:
					if(v574) {
						bs574 |= 32;
					} else {
						bs574 &= -33;
					}
					break;
				case 3:
					if(v574) {
						bs574 |= 16;
					} else {
						bs574 &= -17;
					}
					break;
				case 4:
					if(v574) {
						bs574 |= 8;
					} else {
						bs574 &= -9;
					}
					break;
				case 5:
					if(v574) {
						bs574 |= 4;
					} else {
						bs574 &= -5;
					}
					break;
				case 6:
					if(v574) {
						bs574 |= 2;
					} else {
						bs574 &= -3;
					}
					break;
				case 7:
					if(v574) {
						bs574 |= 1;
					} else {
						bs574 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs574;
			var this576 = 0;
			var bs575 = this576;
			var l575 = "     ".length;
			var _g1576 = 0;
			var _g676 = l575;
			while(_g1576 < _g676) {
				var i576 = _g1576++;
				var no575 = "     ".charCodeAt(i576);
				if(no575 == null) {
					break;
				}
				var v575;
				switch(no575) {
				case 32:
					v575 = false;
					break;
				case 42:
					v575 = true;
					break;
				case 48:
					v575 = false;
					break;
				case 49:
					v575 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i576)));
				}
				switch(i576 - (l575 - 8)) {
				case 0:
					if(v575) {
						bs575 |= 128;
					} else {
						bs575 &= -129;
					}
					break;
				case 1:
					if(v575) {
						bs575 |= 64;
					} else {
						bs575 &= -65;
					}
					break;
				case 2:
					if(v575) {
						bs575 |= 32;
					} else {
						bs575 &= -33;
					}
					break;
				case 3:
					if(v575) {
						bs575 |= 16;
					} else {
						bs575 &= -17;
					}
					break;
				case 4:
					if(v575) {
						bs575 |= 8;
					} else {
						bs575 &= -9;
					}
					break;
				case 5:
					if(v575) {
						bs575 |= 4;
					} else {
						bs575 &= -5;
					}
					break;
				case 6:
					if(v575) {
						bs575 |= 2;
					} else {
						bs575 &= -3;
					}
					break;
				case 7:
					if(v575) {
						bs575 |= 1;
					} else {
						bs575 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs575;
			var this577 = 0;
			var bs576 = this577;
			var l576 = "* ** ".length;
			var _g1577 = 0;
			var _g677 = l576;
			while(_g1577 < _g677) {
				var i577 = _g1577++;
				var no576 = "* ** ".charCodeAt(i577);
				if(no576 == null) {
					break;
				}
				var v576;
				switch(no576) {
				case 32:
					v576 = false;
					break;
				case 42:
					v576 = true;
					break;
				case 48:
					v576 = false;
					break;
				case 49:
					v576 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* ** ".charCodeAt(i577)));
				}
				switch(i577 - (l576 - 8)) {
				case 0:
					if(v576) {
						bs576 |= 128;
					} else {
						bs576 &= -129;
					}
					break;
				case 1:
					if(v576) {
						bs576 |= 64;
					} else {
						bs576 &= -65;
					}
					break;
				case 2:
					if(v576) {
						bs576 |= 32;
					} else {
						bs576 &= -33;
					}
					break;
				case 3:
					if(v576) {
						bs576 |= 16;
					} else {
						bs576 &= -17;
					}
					break;
				case 4:
					if(v576) {
						bs576 |= 8;
					} else {
						bs576 &= -9;
					}
					break;
				case 5:
					if(v576) {
						bs576 |= 4;
					} else {
						bs576 &= -5;
					}
					break;
				case 6:
					if(v576) {
						bs576 |= 2;
					} else {
						bs576 &= -3;
					}
					break;
				case 7:
					if(v576) {
						bs576 |= 1;
					} else {
						bs576 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs576;
			var this578 = 0;
			var bs577 = this578;
			var l577 = "**  *".length;
			var _g1578 = 0;
			var _g678 = l577;
			while(_g1578 < _g678) {
				var i578 = _g1578++;
				var no577 = "**  *".charCodeAt(i578);
				if(no577 == null) {
					break;
				}
				var v577;
				switch(no577) {
				case 32:
					v577 = false;
					break;
				case 42:
					v577 = true;
					break;
				case 48:
					v577 = false;
					break;
				case 49:
					v577 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i578)));
				}
				switch(i578 - (l577 - 8)) {
				case 0:
					if(v577) {
						bs577 |= 128;
					} else {
						bs577 &= -129;
					}
					break;
				case 1:
					if(v577) {
						bs577 |= 64;
					} else {
						bs577 &= -65;
					}
					break;
				case 2:
					if(v577) {
						bs577 |= 32;
					} else {
						bs577 &= -33;
					}
					break;
				case 3:
					if(v577) {
						bs577 |= 16;
					} else {
						bs577 &= -17;
					}
					break;
				case 4:
					if(v577) {
						bs577 |= 8;
					} else {
						bs577 &= -9;
					}
					break;
				case 5:
					if(v577) {
						bs577 |= 4;
					} else {
						bs577 &= -5;
					}
					break;
				case 6:
					if(v577) {
						bs577 |= 2;
					} else {
						bs577 &= -3;
					}
					break;
				case 7:
					if(v577) {
						bs577 |= 1;
					} else {
						bs577 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs577;
			var this579 = 0;
			var bs578 = this579;
			var l578 = "*    ".length;
			var _g1579 = 0;
			var _g679 = l578;
			while(_g1579 < _g679) {
				var i579 = _g1579++;
				var no578 = "*    ".charCodeAt(i579);
				if(no578 == null) {
					break;
				}
				var v578;
				switch(no578) {
				case 32:
					v578 = false;
					break;
				case 42:
					v578 = true;
					break;
				case 48:
					v578 = false;
					break;
				case 49:
					v578 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i579)));
				}
				switch(i579 - (l578 - 8)) {
				case 0:
					if(v578) {
						bs578 |= 128;
					} else {
						bs578 &= -129;
					}
					break;
				case 1:
					if(v578) {
						bs578 |= 64;
					} else {
						bs578 &= -65;
					}
					break;
				case 2:
					if(v578) {
						bs578 |= 32;
					} else {
						bs578 &= -33;
					}
					break;
				case 3:
					if(v578) {
						bs578 |= 16;
					} else {
						bs578 &= -17;
					}
					break;
				case 4:
					if(v578) {
						bs578 |= 8;
					} else {
						bs578 &= -9;
					}
					break;
				case 5:
					if(v578) {
						bs578 |= 4;
					} else {
						bs578 &= -5;
					}
					break;
				case 6:
					if(v578) {
						bs578 |= 2;
					} else {
						bs578 &= -3;
					}
					break;
				case 7:
					if(v578) {
						bs578 |= 1;
					} else {
						bs578 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs578;
			var this580 = 0;
			var bs579 = this580;
			var l579 = "*    ".length;
			var _g1580 = 0;
			var _g680 = l579;
			while(_g1580 < _g680) {
				var i580 = _g1580++;
				var no579 = "*    ".charCodeAt(i580);
				if(no579 == null) {
					break;
				}
				var v579;
				switch(no579) {
				case 32:
					v579 = false;
					break;
				case 42:
					v579 = true;
					break;
				case 48:
					v579 = false;
					break;
				case 49:
					v579 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i580)));
				}
				switch(i580 - (l579 - 8)) {
				case 0:
					if(v579) {
						bs579 |= 128;
					} else {
						bs579 &= -129;
					}
					break;
				case 1:
					if(v579) {
						bs579 |= 64;
					} else {
						bs579 &= -65;
					}
					break;
				case 2:
					if(v579) {
						bs579 |= 32;
					} else {
						bs579 &= -33;
					}
					break;
				case 3:
					if(v579) {
						bs579 |= 16;
					} else {
						bs579 &= -17;
					}
					break;
				case 4:
					if(v579) {
						bs579 |= 8;
					} else {
						bs579 &= -9;
					}
					break;
				case 5:
					if(v579) {
						bs579 |= 4;
					} else {
						bs579 &= -5;
					}
					break;
				case 6:
					if(v579) {
						bs579 |= 2;
					} else {
						bs579 &= -3;
					}
					break;
				case 7:
					if(v579) {
						bs579 |= 1;
					} else {
						bs579 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs579;
			var this581 = 0;
			var bs580 = this581;
			var l580 = "*    ".length;
			var _g1581 = 0;
			var _g681 = l580;
			while(_g1581 < _g681) {
				var i581 = _g1581++;
				var no580 = "*    ".charCodeAt(i581);
				if(no580 == null) {
					break;
				}
				var v580;
				switch(no580) {
				case 32:
					v580 = false;
					break;
				case 42:
					v580 = true;
					break;
				case 48:
					v580 = false;
					break;
				case 49:
					v580 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i581)));
				}
				switch(i581 - (l580 - 8)) {
				case 0:
					if(v580) {
						bs580 |= 128;
					} else {
						bs580 &= -129;
					}
					break;
				case 1:
					if(v580) {
						bs580 |= 64;
					} else {
						bs580 &= -65;
					}
					break;
				case 2:
					if(v580) {
						bs580 |= 32;
					} else {
						bs580 &= -33;
					}
					break;
				case 3:
					if(v580) {
						bs580 |= 16;
					} else {
						bs580 &= -17;
					}
					break;
				case 4:
					if(v580) {
						bs580 |= 8;
					} else {
						bs580 &= -9;
					}
					break;
				case 5:
					if(v580) {
						bs580 |= 4;
					} else {
						bs580 &= -5;
					}
					break;
				case 6:
					if(v580) {
						bs580 |= 2;
					} else {
						bs580 &= -3;
					}
					break;
				case 7:
					if(v580) {
						bs580 |= 1;
					} else {
						bs580 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs580;
			break;
		case 115:
			var this582 = 0;
			var bs581 = this582;
			var l581 = "     ".length;
			var _g1582 = 0;
			var _g682 = l581;
			while(_g1582 < _g682) {
				var i582 = _g1582++;
				var no581 = "     ".charCodeAt(i582);
				if(no581 == null) {
					break;
				}
				var v581;
				switch(no581) {
				case 32:
					v581 = false;
					break;
				case 42:
					v581 = true;
					break;
				case 48:
					v581 = false;
					break;
				case 49:
					v581 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i582)));
				}
				switch(i582 - (l581 - 8)) {
				case 0:
					if(v581) {
						bs581 |= 128;
					} else {
						bs581 &= -129;
					}
					break;
				case 1:
					if(v581) {
						bs581 |= 64;
					} else {
						bs581 &= -65;
					}
					break;
				case 2:
					if(v581) {
						bs581 |= 32;
					} else {
						bs581 &= -33;
					}
					break;
				case 3:
					if(v581) {
						bs581 |= 16;
					} else {
						bs581 &= -17;
					}
					break;
				case 4:
					if(v581) {
						bs581 |= 8;
					} else {
						bs581 &= -9;
					}
					break;
				case 5:
					if(v581) {
						bs581 |= 4;
					} else {
						bs581 &= -5;
					}
					break;
				case 6:
					if(v581) {
						bs581 |= 2;
					} else {
						bs581 &= -3;
					}
					break;
				case 7:
					if(v581) {
						bs581 |= 1;
					} else {
						bs581 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs581;
			var this583 = 0;
			var bs582 = this583;
			var l582 = "     ".length;
			var _g1583 = 0;
			var _g683 = l582;
			while(_g1583 < _g683) {
				var i583 = _g1583++;
				var no582 = "     ".charCodeAt(i583);
				if(no582 == null) {
					break;
				}
				var v582;
				switch(no582) {
				case 32:
					v582 = false;
					break;
				case 42:
					v582 = true;
					break;
				case 48:
					v582 = false;
					break;
				case 49:
					v582 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i583)));
				}
				switch(i583 - (l582 - 8)) {
				case 0:
					if(v582) {
						bs582 |= 128;
					} else {
						bs582 &= -129;
					}
					break;
				case 1:
					if(v582) {
						bs582 |= 64;
					} else {
						bs582 &= -65;
					}
					break;
				case 2:
					if(v582) {
						bs582 |= 32;
					} else {
						bs582 &= -33;
					}
					break;
				case 3:
					if(v582) {
						bs582 |= 16;
					} else {
						bs582 &= -17;
					}
					break;
				case 4:
					if(v582) {
						bs582 |= 8;
					} else {
						bs582 &= -9;
					}
					break;
				case 5:
					if(v582) {
						bs582 |= 4;
					} else {
						bs582 &= -5;
					}
					break;
				case 6:
					if(v582) {
						bs582 |= 2;
					} else {
						bs582 &= -3;
					}
					break;
				case 7:
					if(v582) {
						bs582 |= 1;
					} else {
						bs582 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs582;
			var this584 = 0;
			var bs583 = this584;
			var l583 = " *** ".length;
			var _g1584 = 0;
			var _g684 = l583;
			while(_g1584 < _g684) {
				var i584 = _g1584++;
				var no583 = " *** ".charCodeAt(i584);
				if(no583 == null) {
					break;
				}
				var v583;
				switch(no583) {
				case 32:
					v583 = false;
					break;
				case 42:
					v583 = true;
					break;
				case 48:
					v583 = false;
					break;
				case 49:
					v583 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i584)));
				}
				switch(i584 - (l583 - 8)) {
				case 0:
					if(v583) {
						bs583 |= 128;
					} else {
						bs583 &= -129;
					}
					break;
				case 1:
					if(v583) {
						bs583 |= 64;
					} else {
						bs583 &= -65;
					}
					break;
				case 2:
					if(v583) {
						bs583 |= 32;
					} else {
						bs583 &= -33;
					}
					break;
				case 3:
					if(v583) {
						bs583 |= 16;
					} else {
						bs583 &= -17;
					}
					break;
				case 4:
					if(v583) {
						bs583 |= 8;
					} else {
						bs583 &= -9;
					}
					break;
				case 5:
					if(v583) {
						bs583 |= 4;
					} else {
						bs583 &= -5;
					}
					break;
				case 6:
					if(v583) {
						bs583 |= 2;
					} else {
						bs583 &= -3;
					}
					break;
				case 7:
					if(v583) {
						bs583 |= 1;
					} else {
						bs583 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs583;
			var this585 = 0;
			var bs584 = this585;
			var l584 = "*    ".length;
			var _g1585 = 0;
			var _g685 = l584;
			while(_g1585 < _g685) {
				var i585 = _g1585++;
				var no584 = "*    ".charCodeAt(i585);
				if(no584 == null) {
					break;
				}
				var v584;
				switch(no584) {
				case 32:
					v584 = false;
					break;
				case 42:
					v584 = true;
					break;
				case 48:
					v584 = false;
					break;
				case 49:
					v584 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i585)));
				}
				switch(i585 - (l584 - 8)) {
				case 0:
					if(v584) {
						bs584 |= 128;
					} else {
						bs584 &= -129;
					}
					break;
				case 1:
					if(v584) {
						bs584 |= 64;
					} else {
						bs584 &= -65;
					}
					break;
				case 2:
					if(v584) {
						bs584 |= 32;
					} else {
						bs584 &= -33;
					}
					break;
				case 3:
					if(v584) {
						bs584 |= 16;
					} else {
						bs584 &= -17;
					}
					break;
				case 4:
					if(v584) {
						bs584 |= 8;
					} else {
						bs584 &= -9;
					}
					break;
				case 5:
					if(v584) {
						bs584 |= 4;
					} else {
						bs584 &= -5;
					}
					break;
				case 6:
					if(v584) {
						bs584 |= 2;
					} else {
						bs584 &= -3;
					}
					break;
				case 7:
					if(v584) {
						bs584 |= 1;
					} else {
						bs584 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs584;
			var this586 = 0;
			var bs585 = this586;
			var l585 = " *** ".length;
			var _g1586 = 0;
			var _g686 = l585;
			while(_g1586 < _g686) {
				var i586 = _g1586++;
				var no585 = " *** ".charCodeAt(i586);
				if(no585 == null) {
					break;
				}
				var v585;
				switch(no585) {
				case 32:
					v585 = false;
					break;
				case 42:
					v585 = true;
					break;
				case 48:
					v585 = false;
					break;
				case 49:
					v585 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i586)));
				}
				switch(i586 - (l585 - 8)) {
				case 0:
					if(v585) {
						bs585 |= 128;
					} else {
						bs585 &= -129;
					}
					break;
				case 1:
					if(v585) {
						bs585 |= 64;
					} else {
						bs585 &= -65;
					}
					break;
				case 2:
					if(v585) {
						bs585 |= 32;
					} else {
						bs585 &= -33;
					}
					break;
				case 3:
					if(v585) {
						bs585 |= 16;
					} else {
						bs585 &= -17;
					}
					break;
				case 4:
					if(v585) {
						bs585 |= 8;
					} else {
						bs585 &= -9;
					}
					break;
				case 5:
					if(v585) {
						bs585 |= 4;
					} else {
						bs585 &= -5;
					}
					break;
				case 6:
					if(v585) {
						bs585 |= 2;
					} else {
						bs585 &= -3;
					}
					break;
				case 7:
					if(v585) {
						bs585 |= 1;
					} else {
						bs585 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs585;
			var this587 = 0;
			var bs586 = this587;
			var l586 = "    *".length;
			var _g1587 = 0;
			var _g687 = l586;
			while(_g1587 < _g687) {
				var i587 = _g1587++;
				var no586 = "    *".charCodeAt(i587);
				if(no586 == null) {
					break;
				}
				var v586;
				switch(no586) {
				case 32:
					v586 = false;
					break;
				case 42:
					v586 = true;
					break;
				case 48:
					v586 = false;
					break;
				case 49:
					v586 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i587)));
				}
				switch(i587 - (l586 - 8)) {
				case 0:
					if(v586) {
						bs586 |= 128;
					} else {
						bs586 &= -129;
					}
					break;
				case 1:
					if(v586) {
						bs586 |= 64;
					} else {
						bs586 &= -65;
					}
					break;
				case 2:
					if(v586) {
						bs586 |= 32;
					} else {
						bs586 &= -33;
					}
					break;
				case 3:
					if(v586) {
						bs586 |= 16;
					} else {
						bs586 &= -17;
					}
					break;
				case 4:
					if(v586) {
						bs586 |= 8;
					} else {
						bs586 &= -9;
					}
					break;
				case 5:
					if(v586) {
						bs586 |= 4;
					} else {
						bs586 &= -5;
					}
					break;
				case 6:
					if(v586) {
						bs586 |= 2;
					} else {
						bs586 &= -3;
					}
					break;
				case 7:
					if(v586) {
						bs586 |= 1;
					} else {
						bs586 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs586;
			var this588 = 0;
			var bs587 = this588;
			var l587 = "**** ".length;
			var _g1588 = 0;
			var _g688 = l587;
			while(_g1588 < _g688) {
				var i588 = _g1588++;
				var no587 = "**** ".charCodeAt(i588);
				if(no587 == null) {
					break;
				}
				var v587;
				switch(no587) {
				case 32:
					v587 = false;
					break;
				case 42:
					v587 = true;
					break;
				case 48:
					v587 = false;
					break;
				case 49:
					v587 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i588)));
				}
				switch(i588 - (l587 - 8)) {
				case 0:
					if(v587) {
						bs587 |= 128;
					} else {
						bs587 &= -129;
					}
					break;
				case 1:
					if(v587) {
						bs587 |= 64;
					} else {
						bs587 &= -65;
					}
					break;
				case 2:
					if(v587) {
						bs587 |= 32;
					} else {
						bs587 &= -33;
					}
					break;
				case 3:
					if(v587) {
						bs587 |= 16;
					} else {
						bs587 &= -17;
					}
					break;
				case 4:
					if(v587) {
						bs587 |= 8;
					} else {
						bs587 &= -9;
					}
					break;
				case 5:
					if(v587) {
						bs587 |= 4;
					} else {
						bs587 &= -5;
					}
					break;
				case 6:
					if(v587) {
						bs587 |= 2;
					} else {
						bs587 &= -3;
					}
					break;
				case 7:
					if(v587) {
						bs587 |= 1;
					} else {
						bs587 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs587;
			break;
		case 116:
			var this589 = 0;
			var bs588 = this589;
			var l588 = "     ".length;
			var _g1589 = 0;
			var _g689 = l588;
			while(_g1589 < _g689) {
				var i589 = _g1589++;
				var no588 = "     ".charCodeAt(i589);
				if(no588 == null) {
					break;
				}
				var v588;
				switch(no588) {
				case 32:
					v588 = false;
					break;
				case 42:
					v588 = true;
					break;
				case 48:
					v588 = false;
					break;
				case 49:
					v588 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i589)));
				}
				switch(i589 - (l588 - 8)) {
				case 0:
					if(v588) {
						bs588 |= 128;
					} else {
						bs588 &= -129;
					}
					break;
				case 1:
					if(v588) {
						bs588 |= 64;
					} else {
						bs588 &= -65;
					}
					break;
				case 2:
					if(v588) {
						bs588 |= 32;
					} else {
						bs588 &= -33;
					}
					break;
				case 3:
					if(v588) {
						bs588 |= 16;
					} else {
						bs588 &= -17;
					}
					break;
				case 4:
					if(v588) {
						bs588 |= 8;
					} else {
						bs588 &= -9;
					}
					break;
				case 5:
					if(v588) {
						bs588 |= 4;
					} else {
						bs588 &= -5;
					}
					break;
				case 6:
					if(v588) {
						bs588 |= 2;
					} else {
						bs588 &= -3;
					}
					break;
				case 7:
					if(v588) {
						bs588 |= 1;
					} else {
						bs588 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs588;
			var this590 = 0;
			var bs589 = this590;
			var l589 = " *   ".length;
			var _g1590 = 0;
			var _g690 = l589;
			while(_g1590 < _g690) {
				var i590 = _g1590++;
				var no589 = " *   ".charCodeAt(i590);
				if(no589 == null) {
					break;
				}
				var v589;
				switch(no589) {
				case 32:
					v589 = false;
					break;
				case 42:
					v589 = true;
					break;
				case 48:
					v589 = false;
					break;
				case 49:
					v589 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i590)));
				}
				switch(i590 - (l589 - 8)) {
				case 0:
					if(v589) {
						bs589 |= 128;
					} else {
						bs589 &= -129;
					}
					break;
				case 1:
					if(v589) {
						bs589 |= 64;
					} else {
						bs589 &= -65;
					}
					break;
				case 2:
					if(v589) {
						bs589 |= 32;
					} else {
						bs589 &= -33;
					}
					break;
				case 3:
					if(v589) {
						bs589 |= 16;
					} else {
						bs589 &= -17;
					}
					break;
				case 4:
					if(v589) {
						bs589 |= 8;
					} else {
						bs589 &= -9;
					}
					break;
				case 5:
					if(v589) {
						bs589 |= 4;
					} else {
						bs589 &= -5;
					}
					break;
				case 6:
					if(v589) {
						bs589 |= 2;
					} else {
						bs589 &= -3;
					}
					break;
				case 7:
					if(v589) {
						bs589 |= 1;
					} else {
						bs589 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs589;
			var this591 = 0;
			var bs590 = this591;
			var l590 = "***  ".length;
			var _g1591 = 0;
			var _g691 = l590;
			while(_g1591 < _g691) {
				var i591 = _g1591++;
				var no590 = "***  ".charCodeAt(i591);
				if(no590 == null) {
					break;
				}
				var v590;
				switch(no590) {
				case 32:
					v590 = false;
					break;
				case 42:
					v590 = true;
					break;
				case 48:
					v590 = false;
					break;
				case 49:
					v590 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("***  ".charCodeAt(i591)));
				}
				switch(i591 - (l590 - 8)) {
				case 0:
					if(v590) {
						bs590 |= 128;
					} else {
						bs590 &= -129;
					}
					break;
				case 1:
					if(v590) {
						bs590 |= 64;
					} else {
						bs590 &= -65;
					}
					break;
				case 2:
					if(v590) {
						bs590 |= 32;
					} else {
						bs590 &= -33;
					}
					break;
				case 3:
					if(v590) {
						bs590 |= 16;
					} else {
						bs590 &= -17;
					}
					break;
				case 4:
					if(v590) {
						bs590 |= 8;
					} else {
						bs590 &= -9;
					}
					break;
				case 5:
					if(v590) {
						bs590 |= 4;
					} else {
						bs590 &= -5;
					}
					break;
				case 6:
					if(v590) {
						bs590 |= 2;
					} else {
						bs590 &= -3;
					}
					break;
				case 7:
					if(v590) {
						bs590 |= 1;
					} else {
						bs590 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs590;
			var this592 = 0;
			var bs591 = this592;
			var l591 = " *   ".length;
			var _g1592 = 0;
			var _g692 = l591;
			while(_g1592 < _g692) {
				var i592 = _g1592++;
				var no591 = " *   ".charCodeAt(i592);
				if(no591 == null) {
					break;
				}
				var v591;
				switch(no591) {
				case 32:
					v591 = false;
					break;
				case 42:
					v591 = true;
					break;
				case 48:
					v591 = false;
					break;
				case 49:
					v591 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i592)));
				}
				switch(i592 - (l591 - 8)) {
				case 0:
					if(v591) {
						bs591 |= 128;
					} else {
						bs591 &= -129;
					}
					break;
				case 1:
					if(v591) {
						bs591 |= 64;
					} else {
						bs591 &= -65;
					}
					break;
				case 2:
					if(v591) {
						bs591 |= 32;
					} else {
						bs591 &= -33;
					}
					break;
				case 3:
					if(v591) {
						bs591 |= 16;
					} else {
						bs591 &= -17;
					}
					break;
				case 4:
					if(v591) {
						bs591 |= 8;
					} else {
						bs591 &= -9;
					}
					break;
				case 5:
					if(v591) {
						bs591 |= 4;
					} else {
						bs591 &= -5;
					}
					break;
				case 6:
					if(v591) {
						bs591 |= 2;
					} else {
						bs591 &= -3;
					}
					break;
				case 7:
					if(v591) {
						bs591 |= 1;
					} else {
						bs591 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs591;
			var this593 = 0;
			var bs592 = this593;
			var l592 = " *   ".length;
			var _g1593 = 0;
			var _g693 = l592;
			while(_g1593 < _g693) {
				var i593 = _g1593++;
				var no592 = " *   ".charCodeAt(i593);
				if(no592 == null) {
					break;
				}
				var v592;
				switch(no592) {
				case 32:
					v592 = false;
					break;
				case 42:
					v592 = true;
					break;
				case 48:
					v592 = false;
					break;
				case 49:
					v592 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i593)));
				}
				switch(i593 - (l592 - 8)) {
				case 0:
					if(v592) {
						bs592 |= 128;
					} else {
						bs592 &= -129;
					}
					break;
				case 1:
					if(v592) {
						bs592 |= 64;
					} else {
						bs592 &= -65;
					}
					break;
				case 2:
					if(v592) {
						bs592 |= 32;
					} else {
						bs592 &= -33;
					}
					break;
				case 3:
					if(v592) {
						bs592 |= 16;
					} else {
						bs592 &= -17;
					}
					break;
				case 4:
					if(v592) {
						bs592 |= 8;
					} else {
						bs592 &= -9;
					}
					break;
				case 5:
					if(v592) {
						bs592 |= 4;
					} else {
						bs592 &= -5;
					}
					break;
				case 6:
					if(v592) {
						bs592 |= 2;
					} else {
						bs592 &= -3;
					}
					break;
				case 7:
					if(v592) {
						bs592 |= 1;
					} else {
						bs592 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs592;
			var this594 = 0;
			var bs593 = this594;
			var l593 = " *  *".length;
			var _g1594 = 0;
			var _g694 = l593;
			while(_g1594 < _g694) {
				var i594 = _g1594++;
				var no593 = " *  *".charCodeAt(i594);
				if(no593 == null) {
					break;
				}
				var v593;
				switch(no593) {
				case 32:
					v593 = false;
					break;
				case 42:
					v593 = true;
					break;
				case 48:
					v593 = false;
					break;
				case 49:
					v593 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *  *".charCodeAt(i594)));
				}
				switch(i594 - (l593 - 8)) {
				case 0:
					if(v593) {
						bs593 |= 128;
					} else {
						bs593 &= -129;
					}
					break;
				case 1:
					if(v593) {
						bs593 |= 64;
					} else {
						bs593 &= -65;
					}
					break;
				case 2:
					if(v593) {
						bs593 |= 32;
					} else {
						bs593 &= -33;
					}
					break;
				case 3:
					if(v593) {
						bs593 |= 16;
					} else {
						bs593 &= -17;
					}
					break;
				case 4:
					if(v593) {
						bs593 |= 8;
					} else {
						bs593 &= -9;
					}
					break;
				case 5:
					if(v593) {
						bs593 |= 4;
					} else {
						bs593 &= -5;
					}
					break;
				case 6:
					if(v593) {
						bs593 |= 2;
					} else {
						bs593 &= -3;
					}
					break;
				case 7:
					if(v593) {
						bs593 |= 1;
					} else {
						bs593 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs593;
			var this595 = 0;
			var bs594 = this595;
			var l594 = "  ** ".length;
			var _g1595 = 0;
			var _g695 = l594;
			while(_g1595 < _g695) {
				var i595 = _g1595++;
				var no594 = "  ** ".charCodeAt(i595);
				if(no594 == null) {
					break;
				}
				var v594;
				switch(no594) {
				case 32:
					v594 = false;
					break;
				case 42:
					v594 = true;
					break;
				case 48:
					v594 = false;
					break;
				case 49:
					v594 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i595)));
				}
				switch(i595 - (l594 - 8)) {
				case 0:
					if(v594) {
						bs594 |= 128;
					} else {
						bs594 &= -129;
					}
					break;
				case 1:
					if(v594) {
						bs594 |= 64;
					} else {
						bs594 &= -65;
					}
					break;
				case 2:
					if(v594) {
						bs594 |= 32;
					} else {
						bs594 &= -33;
					}
					break;
				case 3:
					if(v594) {
						bs594 |= 16;
					} else {
						bs594 &= -17;
					}
					break;
				case 4:
					if(v594) {
						bs594 |= 8;
					} else {
						bs594 &= -9;
					}
					break;
				case 5:
					if(v594) {
						bs594 |= 4;
					} else {
						bs594 &= -5;
					}
					break;
				case 6:
					if(v594) {
						bs594 |= 2;
					} else {
						bs594 &= -3;
					}
					break;
				case 7:
					if(v594) {
						bs594 |= 1;
					} else {
						bs594 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs594;
			break;
		case 117:
			var this596 = 0;
			var bs595 = this596;
			var l595 = "     ".length;
			var _g1596 = 0;
			var _g696 = l595;
			while(_g1596 < _g696) {
				var i596 = _g1596++;
				var no595 = "     ".charCodeAt(i596);
				if(no595 == null) {
					break;
				}
				var v595;
				switch(no595) {
				case 32:
					v595 = false;
					break;
				case 42:
					v595 = true;
					break;
				case 48:
					v595 = false;
					break;
				case 49:
					v595 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i596)));
				}
				switch(i596 - (l595 - 8)) {
				case 0:
					if(v595) {
						bs595 |= 128;
					} else {
						bs595 &= -129;
					}
					break;
				case 1:
					if(v595) {
						bs595 |= 64;
					} else {
						bs595 &= -65;
					}
					break;
				case 2:
					if(v595) {
						bs595 |= 32;
					} else {
						bs595 &= -33;
					}
					break;
				case 3:
					if(v595) {
						bs595 |= 16;
					} else {
						bs595 &= -17;
					}
					break;
				case 4:
					if(v595) {
						bs595 |= 8;
					} else {
						bs595 &= -9;
					}
					break;
				case 5:
					if(v595) {
						bs595 |= 4;
					} else {
						bs595 &= -5;
					}
					break;
				case 6:
					if(v595) {
						bs595 |= 2;
					} else {
						bs595 &= -3;
					}
					break;
				case 7:
					if(v595) {
						bs595 |= 1;
					} else {
						bs595 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs595;
			var this597 = 0;
			var bs596 = this597;
			var l596 = "     ".length;
			var _g1597 = 0;
			var _g697 = l596;
			while(_g1597 < _g697) {
				var i597 = _g1597++;
				var no596 = "     ".charCodeAt(i597);
				if(no596 == null) {
					break;
				}
				var v596;
				switch(no596) {
				case 32:
					v596 = false;
					break;
				case 42:
					v596 = true;
					break;
				case 48:
					v596 = false;
					break;
				case 49:
					v596 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i597)));
				}
				switch(i597 - (l596 - 8)) {
				case 0:
					if(v596) {
						bs596 |= 128;
					} else {
						bs596 &= -129;
					}
					break;
				case 1:
					if(v596) {
						bs596 |= 64;
					} else {
						bs596 &= -65;
					}
					break;
				case 2:
					if(v596) {
						bs596 |= 32;
					} else {
						bs596 &= -33;
					}
					break;
				case 3:
					if(v596) {
						bs596 |= 16;
					} else {
						bs596 &= -17;
					}
					break;
				case 4:
					if(v596) {
						bs596 |= 8;
					} else {
						bs596 &= -9;
					}
					break;
				case 5:
					if(v596) {
						bs596 |= 4;
					} else {
						bs596 &= -5;
					}
					break;
				case 6:
					if(v596) {
						bs596 |= 2;
					} else {
						bs596 &= -3;
					}
					break;
				case 7:
					if(v596) {
						bs596 |= 1;
					} else {
						bs596 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs596;
			var this598 = 0;
			var bs597 = this598;
			var l597 = "*   *".length;
			var _g1598 = 0;
			var _g698 = l597;
			while(_g1598 < _g698) {
				var i598 = _g1598++;
				var no597 = "*   *".charCodeAt(i598);
				if(no597 == null) {
					break;
				}
				var v597;
				switch(no597) {
				case 32:
					v597 = false;
					break;
				case 42:
					v597 = true;
					break;
				case 48:
					v597 = false;
					break;
				case 49:
					v597 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i598)));
				}
				switch(i598 - (l597 - 8)) {
				case 0:
					if(v597) {
						bs597 |= 128;
					} else {
						bs597 &= -129;
					}
					break;
				case 1:
					if(v597) {
						bs597 |= 64;
					} else {
						bs597 &= -65;
					}
					break;
				case 2:
					if(v597) {
						bs597 |= 32;
					} else {
						bs597 &= -33;
					}
					break;
				case 3:
					if(v597) {
						bs597 |= 16;
					} else {
						bs597 &= -17;
					}
					break;
				case 4:
					if(v597) {
						bs597 |= 8;
					} else {
						bs597 &= -9;
					}
					break;
				case 5:
					if(v597) {
						bs597 |= 4;
					} else {
						bs597 &= -5;
					}
					break;
				case 6:
					if(v597) {
						bs597 |= 2;
					} else {
						bs597 &= -3;
					}
					break;
				case 7:
					if(v597) {
						bs597 |= 1;
					} else {
						bs597 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs597;
			var this599 = 0;
			var bs598 = this599;
			var l598 = "*   *".length;
			var _g1599 = 0;
			var _g699 = l598;
			while(_g1599 < _g699) {
				var i599 = _g1599++;
				var no598 = "*   *".charCodeAt(i599);
				if(no598 == null) {
					break;
				}
				var v598;
				switch(no598) {
				case 32:
					v598 = false;
					break;
				case 42:
					v598 = true;
					break;
				case 48:
					v598 = false;
					break;
				case 49:
					v598 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i599)));
				}
				switch(i599 - (l598 - 8)) {
				case 0:
					if(v598) {
						bs598 |= 128;
					} else {
						bs598 &= -129;
					}
					break;
				case 1:
					if(v598) {
						bs598 |= 64;
					} else {
						bs598 &= -65;
					}
					break;
				case 2:
					if(v598) {
						bs598 |= 32;
					} else {
						bs598 &= -33;
					}
					break;
				case 3:
					if(v598) {
						bs598 |= 16;
					} else {
						bs598 &= -17;
					}
					break;
				case 4:
					if(v598) {
						bs598 |= 8;
					} else {
						bs598 &= -9;
					}
					break;
				case 5:
					if(v598) {
						bs598 |= 4;
					} else {
						bs598 &= -5;
					}
					break;
				case 6:
					if(v598) {
						bs598 |= 2;
					} else {
						bs598 &= -3;
					}
					break;
				case 7:
					if(v598) {
						bs598 |= 1;
					} else {
						bs598 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs598;
			var this600 = 0;
			var bs599 = this600;
			var l599 = "*   *".length;
			var _g1600 = 0;
			var _g700 = l599;
			while(_g1600 < _g700) {
				var i600 = _g1600++;
				var no599 = "*   *".charCodeAt(i600);
				if(no599 == null) {
					break;
				}
				var v599;
				switch(no599) {
				case 32:
					v599 = false;
					break;
				case 42:
					v599 = true;
					break;
				case 48:
					v599 = false;
					break;
				case 49:
					v599 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i600)));
				}
				switch(i600 - (l599 - 8)) {
				case 0:
					if(v599) {
						bs599 |= 128;
					} else {
						bs599 &= -129;
					}
					break;
				case 1:
					if(v599) {
						bs599 |= 64;
					} else {
						bs599 &= -65;
					}
					break;
				case 2:
					if(v599) {
						bs599 |= 32;
					} else {
						bs599 &= -33;
					}
					break;
				case 3:
					if(v599) {
						bs599 |= 16;
					} else {
						bs599 &= -17;
					}
					break;
				case 4:
					if(v599) {
						bs599 |= 8;
					} else {
						bs599 &= -9;
					}
					break;
				case 5:
					if(v599) {
						bs599 |= 4;
					} else {
						bs599 &= -5;
					}
					break;
				case 6:
					if(v599) {
						bs599 |= 2;
					} else {
						bs599 &= -3;
					}
					break;
				case 7:
					if(v599) {
						bs599 |= 1;
					} else {
						bs599 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs599;
			var this601 = 0;
			var bs600 = this601;
			var l600 = "*  **".length;
			var _g1601 = 0;
			var _g701 = l600;
			while(_g1601 < _g701) {
				var i601 = _g1601++;
				var no600 = "*  **".charCodeAt(i601);
				if(no600 == null) {
					break;
				}
				var v600;
				switch(no600) {
				case 32:
					v600 = false;
					break;
				case 42:
					v600 = true;
					break;
				case 48:
					v600 = false;
					break;
				case 49:
					v600 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  **".charCodeAt(i601)));
				}
				switch(i601 - (l600 - 8)) {
				case 0:
					if(v600) {
						bs600 |= 128;
					} else {
						bs600 &= -129;
					}
					break;
				case 1:
					if(v600) {
						bs600 |= 64;
					} else {
						bs600 &= -65;
					}
					break;
				case 2:
					if(v600) {
						bs600 |= 32;
					} else {
						bs600 &= -33;
					}
					break;
				case 3:
					if(v600) {
						bs600 |= 16;
					} else {
						bs600 &= -17;
					}
					break;
				case 4:
					if(v600) {
						bs600 |= 8;
					} else {
						bs600 &= -9;
					}
					break;
				case 5:
					if(v600) {
						bs600 |= 4;
					} else {
						bs600 &= -5;
					}
					break;
				case 6:
					if(v600) {
						bs600 |= 2;
					} else {
						bs600 &= -3;
					}
					break;
				case 7:
					if(v600) {
						bs600 |= 1;
					} else {
						bs600 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs600;
			var this602 = 0;
			var bs601 = this602;
			var l601 = " ** *".length;
			var _g1602 = 0;
			var _g702 = l601;
			while(_g1602 < _g702) {
				var i602 = _g1602++;
				var no601 = " ** *".charCodeAt(i602);
				if(no601 == null) {
					break;
				}
				var v601;
				switch(no601) {
				case 32:
					v601 = false;
					break;
				case 42:
					v601 = true;
					break;
				case 48:
					v601 = false;
					break;
				case 49:
					v601 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i602)));
				}
				switch(i602 - (l601 - 8)) {
				case 0:
					if(v601) {
						bs601 |= 128;
					} else {
						bs601 &= -129;
					}
					break;
				case 1:
					if(v601) {
						bs601 |= 64;
					} else {
						bs601 &= -65;
					}
					break;
				case 2:
					if(v601) {
						bs601 |= 32;
					} else {
						bs601 &= -33;
					}
					break;
				case 3:
					if(v601) {
						bs601 |= 16;
					} else {
						bs601 &= -17;
					}
					break;
				case 4:
					if(v601) {
						bs601 |= 8;
					} else {
						bs601 &= -9;
					}
					break;
				case 5:
					if(v601) {
						bs601 |= 4;
					} else {
						bs601 &= -5;
					}
					break;
				case 6:
					if(v601) {
						bs601 |= 2;
					} else {
						bs601 &= -3;
					}
					break;
				case 7:
					if(v601) {
						bs601 |= 1;
					} else {
						bs601 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs601;
			break;
		case 118:
			var this603 = 0;
			var bs602 = this603;
			var l602 = "     ".length;
			var _g1603 = 0;
			var _g703 = l602;
			while(_g1603 < _g703) {
				var i603 = _g1603++;
				var no602 = "     ".charCodeAt(i603);
				if(no602 == null) {
					break;
				}
				var v602;
				switch(no602) {
				case 32:
					v602 = false;
					break;
				case 42:
					v602 = true;
					break;
				case 48:
					v602 = false;
					break;
				case 49:
					v602 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i603)));
				}
				switch(i603 - (l602 - 8)) {
				case 0:
					if(v602) {
						bs602 |= 128;
					} else {
						bs602 &= -129;
					}
					break;
				case 1:
					if(v602) {
						bs602 |= 64;
					} else {
						bs602 &= -65;
					}
					break;
				case 2:
					if(v602) {
						bs602 |= 32;
					} else {
						bs602 &= -33;
					}
					break;
				case 3:
					if(v602) {
						bs602 |= 16;
					} else {
						bs602 &= -17;
					}
					break;
				case 4:
					if(v602) {
						bs602 |= 8;
					} else {
						bs602 &= -9;
					}
					break;
				case 5:
					if(v602) {
						bs602 |= 4;
					} else {
						bs602 &= -5;
					}
					break;
				case 6:
					if(v602) {
						bs602 |= 2;
					} else {
						bs602 &= -3;
					}
					break;
				case 7:
					if(v602) {
						bs602 |= 1;
					} else {
						bs602 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs602;
			var this604 = 0;
			var bs603 = this604;
			var l603 = "     ".length;
			var _g1604 = 0;
			var _g704 = l603;
			while(_g1604 < _g704) {
				var i604 = _g1604++;
				var no603 = "     ".charCodeAt(i604);
				if(no603 == null) {
					break;
				}
				var v603;
				switch(no603) {
				case 32:
					v603 = false;
					break;
				case 42:
					v603 = true;
					break;
				case 48:
					v603 = false;
					break;
				case 49:
					v603 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i604)));
				}
				switch(i604 - (l603 - 8)) {
				case 0:
					if(v603) {
						bs603 |= 128;
					} else {
						bs603 &= -129;
					}
					break;
				case 1:
					if(v603) {
						bs603 |= 64;
					} else {
						bs603 &= -65;
					}
					break;
				case 2:
					if(v603) {
						bs603 |= 32;
					} else {
						bs603 &= -33;
					}
					break;
				case 3:
					if(v603) {
						bs603 |= 16;
					} else {
						bs603 &= -17;
					}
					break;
				case 4:
					if(v603) {
						bs603 |= 8;
					} else {
						bs603 &= -9;
					}
					break;
				case 5:
					if(v603) {
						bs603 |= 4;
					} else {
						bs603 &= -5;
					}
					break;
				case 6:
					if(v603) {
						bs603 |= 2;
					} else {
						bs603 &= -3;
					}
					break;
				case 7:
					if(v603) {
						bs603 |= 1;
					} else {
						bs603 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs603;
			var this605 = 0;
			var bs604 = this605;
			var l604 = "*   *".length;
			var _g1605 = 0;
			var _g705 = l604;
			while(_g1605 < _g705) {
				var i605 = _g1605++;
				var no604 = "*   *".charCodeAt(i605);
				if(no604 == null) {
					break;
				}
				var v604;
				switch(no604) {
				case 32:
					v604 = false;
					break;
				case 42:
					v604 = true;
					break;
				case 48:
					v604 = false;
					break;
				case 49:
					v604 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i605)));
				}
				switch(i605 - (l604 - 8)) {
				case 0:
					if(v604) {
						bs604 |= 128;
					} else {
						bs604 &= -129;
					}
					break;
				case 1:
					if(v604) {
						bs604 |= 64;
					} else {
						bs604 &= -65;
					}
					break;
				case 2:
					if(v604) {
						bs604 |= 32;
					} else {
						bs604 &= -33;
					}
					break;
				case 3:
					if(v604) {
						bs604 |= 16;
					} else {
						bs604 &= -17;
					}
					break;
				case 4:
					if(v604) {
						bs604 |= 8;
					} else {
						bs604 &= -9;
					}
					break;
				case 5:
					if(v604) {
						bs604 |= 4;
					} else {
						bs604 &= -5;
					}
					break;
				case 6:
					if(v604) {
						bs604 |= 2;
					} else {
						bs604 &= -3;
					}
					break;
				case 7:
					if(v604) {
						bs604 |= 1;
					} else {
						bs604 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs604;
			var this606 = 0;
			var bs605 = this606;
			var l605 = "*   *".length;
			var _g1606 = 0;
			var _g706 = l605;
			while(_g1606 < _g706) {
				var i606 = _g1606++;
				var no605 = "*   *".charCodeAt(i606);
				if(no605 == null) {
					break;
				}
				var v605;
				switch(no605) {
				case 32:
					v605 = false;
					break;
				case 42:
					v605 = true;
					break;
				case 48:
					v605 = false;
					break;
				case 49:
					v605 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i606)));
				}
				switch(i606 - (l605 - 8)) {
				case 0:
					if(v605) {
						bs605 |= 128;
					} else {
						bs605 &= -129;
					}
					break;
				case 1:
					if(v605) {
						bs605 |= 64;
					} else {
						bs605 &= -65;
					}
					break;
				case 2:
					if(v605) {
						bs605 |= 32;
					} else {
						bs605 &= -33;
					}
					break;
				case 3:
					if(v605) {
						bs605 |= 16;
					} else {
						bs605 &= -17;
					}
					break;
				case 4:
					if(v605) {
						bs605 |= 8;
					} else {
						bs605 &= -9;
					}
					break;
				case 5:
					if(v605) {
						bs605 |= 4;
					} else {
						bs605 &= -5;
					}
					break;
				case 6:
					if(v605) {
						bs605 |= 2;
					} else {
						bs605 &= -3;
					}
					break;
				case 7:
					if(v605) {
						bs605 |= 1;
					} else {
						bs605 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs605;
			var this607 = 0;
			var bs606 = this607;
			var l606 = "*   *".length;
			var _g1607 = 0;
			var _g707 = l606;
			while(_g1607 < _g707) {
				var i607 = _g1607++;
				var no606 = "*   *".charCodeAt(i607);
				if(no606 == null) {
					break;
				}
				var v606;
				switch(no606) {
				case 32:
					v606 = false;
					break;
				case 42:
					v606 = true;
					break;
				case 48:
					v606 = false;
					break;
				case 49:
					v606 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i607)));
				}
				switch(i607 - (l606 - 8)) {
				case 0:
					if(v606) {
						bs606 |= 128;
					} else {
						bs606 &= -129;
					}
					break;
				case 1:
					if(v606) {
						bs606 |= 64;
					} else {
						bs606 &= -65;
					}
					break;
				case 2:
					if(v606) {
						bs606 |= 32;
					} else {
						bs606 &= -33;
					}
					break;
				case 3:
					if(v606) {
						bs606 |= 16;
					} else {
						bs606 &= -17;
					}
					break;
				case 4:
					if(v606) {
						bs606 |= 8;
					} else {
						bs606 &= -9;
					}
					break;
				case 5:
					if(v606) {
						bs606 |= 4;
					} else {
						bs606 &= -5;
					}
					break;
				case 6:
					if(v606) {
						bs606 |= 2;
					} else {
						bs606 &= -3;
					}
					break;
				case 7:
					if(v606) {
						bs606 |= 1;
					} else {
						bs606 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs606;
			var this608 = 0;
			var bs607 = this608;
			var l607 = " * * ".length;
			var _g1608 = 0;
			var _g708 = l607;
			while(_g1608 < _g708) {
				var i608 = _g1608++;
				var no607 = " * * ".charCodeAt(i608);
				if(no607 == null) {
					break;
				}
				var v607;
				switch(no607) {
				case 32:
					v607 = false;
					break;
				case 42:
					v607 = true;
					break;
				case 48:
					v607 = false;
					break;
				case 49:
					v607 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i608)));
				}
				switch(i608 - (l607 - 8)) {
				case 0:
					if(v607) {
						bs607 |= 128;
					} else {
						bs607 &= -129;
					}
					break;
				case 1:
					if(v607) {
						bs607 |= 64;
					} else {
						bs607 &= -65;
					}
					break;
				case 2:
					if(v607) {
						bs607 |= 32;
					} else {
						bs607 &= -33;
					}
					break;
				case 3:
					if(v607) {
						bs607 |= 16;
					} else {
						bs607 &= -17;
					}
					break;
				case 4:
					if(v607) {
						bs607 |= 8;
					} else {
						bs607 &= -9;
					}
					break;
				case 5:
					if(v607) {
						bs607 |= 4;
					} else {
						bs607 &= -5;
					}
					break;
				case 6:
					if(v607) {
						bs607 |= 2;
					} else {
						bs607 &= -3;
					}
					break;
				case 7:
					if(v607) {
						bs607 |= 1;
					} else {
						bs607 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs607;
			var this609 = 0;
			var bs608 = this609;
			var l608 = "  *  ".length;
			var _g1609 = 0;
			var _g709 = l608;
			while(_g1609 < _g709) {
				var i609 = _g1609++;
				var no608 = "  *  ".charCodeAt(i609);
				if(no608 == null) {
					break;
				}
				var v608;
				switch(no608) {
				case 32:
					v608 = false;
					break;
				case 42:
					v608 = true;
					break;
				case 48:
					v608 = false;
					break;
				case 49:
					v608 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i609)));
				}
				switch(i609 - (l608 - 8)) {
				case 0:
					if(v608) {
						bs608 |= 128;
					} else {
						bs608 &= -129;
					}
					break;
				case 1:
					if(v608) {
						bs608 |= 64;
					} else {
						bs608 &= -65;
					}
					break;
				case 2:
					if(v608) {
						bs608 |= 32;
					} else {
						bs608 &= -33;
					}
					break;
				case 3:
					if(v608) {
						bs608 |= 16;
					} else {
						bs608 &= -17;
					}
					break;
				case 4:
					if(v608) {
						bs608 |= 8;
					} else {
						bs608 &= -9;
					}
					break;
				case 5:
					if(v608) {
						bs608 |= 4;
					} else {
						bs608 &= -5;
					}
					break;
				case 6:
					if(v608) {
						bs608 |= 2;
					} else {
						bs608 &= -3;
					}
					break;
				case 7:
					if(v608) {
						bs608 |= 1;
					} else {
						bs608 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs608;
			break;
		case 119:
			var this610 = 0;
			var bs609 = this610;
			var l609 = "     ".length;
			var _g1610 = 0;
			var _g710 = l609;
			while(_g1610 < _g710) {
				var i610 = _g1610++;
				var no609 = "     ".charCodeAt(i610);
				if(no609 == null) {
					break;
				}
				var v609;
				switch(no609) {
				case 32:
					v609 = false;
					break;
				case 42:
					v609 = true;
					break;
				case 48:
					v609 = false;
					break;
				case 49:
					v609 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i610)));
				}
				switch(i610 - (l609 - 8)) {
				case 0:
					if(v609) {
						bs609 |= 128;
					} else {
						bs609 &= -129;
					}
					break;
				case 1:
					if(v609) {
						bs609 |= 64;
					} else {
						bs609 &= -65;
					}
					break;
				case 2:
					if(v609) {
						bs609 |= 32;
					} else {
						bs609 &= -33;
					}
					break;
				case 3:
					if(v609) {
						bs609 |= 16;
					} else {
						bs609 &= -17;
					}
					break;
				case 4:
					if(v609) {
						bs609 |= 8;
					} else {
						bs609 &= -9;
					}
					break;
				case 5:
					if(v609) {
						bs609 |= 4;
					} else {
						bs609 &= -5;
					}
					break;
				case 6:
					if(v609) {
						bs609 |= 2;
					} else {
						bs609 &= -3;
					}
					break;
				case 7:
					if(v609) {
						bs609 |= 1;
					} else {
						bs609 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs609;
			var this611 = 0;
			var bs610 = this611;
			var l610 = "     ".length;
			var _g1611 = 0;
			var _g711 = l610;
			while(_g1611 < _g711) {
				var i611 = _g1611++;
				var no610 = "     ".charCodeAt(i611);
				if(no610 == null) {
					break;
				}
				var v610;
				switch(no610) {
				case 32:
					v610 = false;
					break;
				case 42:
					v610 = true;
					break;
				case 48:
					v610 = false;
					break;
				case 49:
					v610 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i611)));
				}
				switch(i611 - (l610 - 8)) {
				case 0:
					if(v610) {
						bs610 |= 128;
					} else {
						bs610 &= -129;
					}
					break;
				case 1:
					if(v610) {
						bs610 |= 64;
					} else {
						bs610 &= -65;
					}
					break;
				case 2:
					if(v610) {
						bs610 |= 32;
					} else {
						bs610 &= -33;
					}
					break;
				case 3:
					if(v610) {
						bs610 |= 16;
					} else {
						bs610 &= -17;
					}
					break;
				case 4:
					if(v610) {
						bs610 |= 8;
					} else {
						bs610 &= -9;
					}
					break;
				case 5:
					if(v610) {
						bs610 |= 4;
					} else {
						bs610 &= -5;
					}
					break;
				case 6:
					if(v610) {
						bs610 |= 2;
					} else {
						bs610 &= -3;
					}
					break;
				case 7:
					if(v610) {
						bs610 |= 1;
					} else {
						bs610 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs610;
			var this612 = 0;
			var bs611 = this612;
			var l611 = "*   *".length;
			var _g1612 = 0;
			var _g712 = l611;
			while(_g1612 < _g712) {
				var i612 = _g1612++;
				var no611 = "*   *".charCodeAt(i612);
				if(no611 == null) {
					break;
				}
				var v611;
				switch(no611) {
				case 32:
					v611 = false;
					break;
				case 42:
					v611 = true;
					break;
				case 48:
					v611 = false;
					break;
				case 49:
					v611 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i612)));
				}
				switch(i612 - (l611 - 8)) {
				case 0:
					if(v611) {
						bs611 |= 128;
					} else {
						bs611 &= -129;
					}
					break;
				case 1:
					if(v611) {
						bs611 |= 64;
					} else {
						bs611 &= -65;
					}
					break;
				case 2:
					if(v611) {
						bs611 |= 32;
					} else {
						bs611 &= -33;
					}
					break;
				case 3:
					if(v611) {
						bs611 |= 16;
					} else {
						bs611 &= -17;
					}
					break;
				case 4:
					if(v611) {
						bs611 |= 8;
					} else {
						bs611 &= -9;
					}
					break;
				case 5:
					if(v611) {
						bs611 |= 4;
					} else {
						bs611 &= -5;
					}
					break;
				case 6:
					if(v611) {
						bs611 |= 2;
					} else {
						bs611 &= -3;
					}
					break;
				case 7:
					if(v611) {
						bs611 |= 1;
					} else {
						bs611 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs611;
			var this613 = 0;
			var bs612 = this613;
			var l612 = "*   *".length;
			var _g1613 = 0;
			var _g713 = l612;
			while(_g1613 < _g713) {
				var i613 = _g1613++;
				var no612 = "*   *".charCodeAt(i613);
				if(no612 == null) {
					break;
				}
				var v612;
				switch(no612) {
				case 32:
					v612 = false;
					break;
				case 42:
					v612 = true;
					break;
				case 48:
					v612 = false;
					break;
				case 49:
					v612 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i613)));
				}
				switch(i613 - (l612 - 8)) {
				case 0:
					if(v612) {
						bs612 |= 128;
					} else {
						bs612 &= -129;
					}
					break;
				case 1:
					if(v612) {
						bs612 |= 64;
					} else {
						bs612 &= -65;
					}
					break;
				case 2:
					if(v612) {
						bs612 |= 32;
					} else {
						bs612 &= -33;
					}
					break;
				case 3:
					if(v612) {
						bs612 |= 16;
					} else {
						bs612 &= -17;
					}
					break;
				case 4:
					if(v612) {
						bs612 |= 8;
					} else {
						bs612 &= -9;
					}
					break;
				case 5:
					if(v612) {
						bs612 |= 4;
					} else {
						bs612 &= -5;
					}
					break;
				case 6:
					if(v612) {
						bs612 |= 2;
					} else {
						bs612 &= -3;
					}
					break;
				case 7:
					if(v612) {
						bs612 |= 1;
					} else {
						bs612 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs612;
			var this614 = 0;
			var bs613 = this614;
			var l613 = "* * *".length;
			var _g1614 = 0;
			var _g714 = l613;
			while(_g1614 < _g714) {
				var i614 = _g1614++;
				var no613 = "* * *".charCodeAt(i614);
				if(no613 == null) {
					break;
				}
				var v613;
				switch(no613) {
				case 32:
					v613 = false;
					break;
				case 42:
					v613 = true;
					break;
				case 48:
					v613 = false;
					break;
				case 49:
					v613 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i614)));
				}
				switch(i614 - (l613 - 8)) {
				case 0:
					if(v613) {
						bs613 |= 128;
					} else {
						bs613 &= -129;
					}
					break;
				case 1:
					if(v613) {
						bs613 |= 64;
					} else {
						bs613 &= -65;
					}
					break;
				case 2:
					if(v613) {
						bs613 |= 32;
					} else {
						bs613 &= -33;
					}
					break;
				case 3:
					if(v613) {
						bs613 |= 16;
					} else {
						bs613 &= -17;
					}
					break;
				case 4:
					if(v613) {
						bs613 |= 8;
					} else {
						bs613 &= -9;
					}
					break;
				case 5:
					if(v613) {
						bs613 |= 4;
					} else {
						bs613 &= -5;
					}
					break;
				case 6:
					if(v613) {
						bs613 |= 2;
					} else {
						bs613 &= -3;
					}
					break;
				case 7:
					if(v613) {
						bs613 |= 1;
					} else {
						bs613 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs613;
			var this615 = 0;
			var bs614 = this615;
			var l614 = "* * *".length;
			var _g1615 = 0;
			var _g715 = l614;
			while(_g1615 < _g715) {
				var i615 = _g1615++;
				var no614 = "* * *".charCodeAt(i615);
				if(no614 == null) {
					break;
				}
				var v614;
				switch(no614) {
				case 32:
					v614 = false;
					break;
				case 42:
					v614 = true;
					break;
				case 48:
					v614 = false;
					break;
				case 49:
					v614 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i615)));
				}
				switch(i615 - (l614 - 8)) {
				case 0:
					if(v614) {
						bs614 |= 128;
					} else {
						bs614 &= -129;
					}
					break;
				case 1:
					if(v614) {
						bs614 |= 64;
					} else {
						bs614 &= -65;
					}
					break;
				case 2:
					if(v614) {
						bs614 |= 32;
					} else {
						bs614 &= -33;
					}
					break;
				case 3:
					if(v614) {
						bs614 |= 16;
					} else {
						bs614 &= -17;
					}
					break;
				case 4:
					if(v614) {
						bs614 |= 8;
					} else {
						bs614 &= -9;
					}
					break;
				case 5:
					if(v614) {
						bs614 |= 4;
					} else {
						bs614 &= -5;
					}
					break;
				case 6:
					if(v614) {
						bs614 |= 2;
					} else {
						bs614 &= -3;
					}
					break;
				case 7:
					if(v614) {
						bs614 |= 1;
					} else {
						bs614 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs614;
			var this616 = 0;
			var bs615 = this616;
			var l615 = " * * ".length;
			var _g1616 = 0;
			var _g716 = l615;
			while(_g1616 < _g716) {
				var i616 = _g1616++;
				var no615 = " * * ".charCodeAt(i616);
				if(no615 == null) {
					break;
				}
				var v615;
				switch(no615) {
				case 32:
					v615 = false;
					break;
				case 42:
					v615 = true;
					break;
				case 48:
					v615 = false;
					break;
				case 49:
					v615 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i616)));
				}
				switch(i616 - (l615 - 8)) {
				case 0:
					if(v615) {
						bs615 |= 128;
					} else {
						bs615 &= -129;
					}
					break;
				case 1:
					if(v615) {
						bs615 |= 64;
					} else {
						bs615 &= -65;
					}
					break;
				case 2:
					if(v615) {
						bs615 |= 32;
					} else {
						bs615 &= -33;
					}
					break;
				case 3:
					if(v615) {
						bs615 |= 16;
					} else {
						bs615 &= -17;
					}
					break;
				case 4:
					if(v615) {
						bs615 |= 8;
					} else {
						bs615 &= -9;
					}
					break;
				case 5:
					if(v615) {
						bs615 |= 4;
					} else {
						bs615 &= -5;
					}
					break;
				case 6:
					if(v615) {
						bs615 |= 2;
					} else {
						bs615 &= -3;
					}
					break;
				case 7:
					if(v615) {
						bs615 |= 1;
					} else {
						bs615 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs615;
			break;
		case 120:
			var this617 = 0;
			var bs616 = this617;
			var l616 = "     ".length;
			var _g1617 = 0;
			var _g717 = l616;
			while(_g1617 < _g717) {
				var i617 = _g1617++;
				var no616 = "     ".charCodeAt(i617);
				if(no616 == null) {
					break;
				}
				var v616;
				switch(no616) {
				case 32:
					v616 = false;
					break;
				case 42:
					v616 = true;
					break;
				case 48:
					v616 = false;
					break;
				case 49:
					v616 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i617)));
				}
				switch(i617 - (l616 - 8)) {
				case 0:
					if(v616) {
						bs616 |= 128;
					} else {
						bs616 &= -129;
					}
					break;
				case 1:
					if(v616) {
						bs616 |= 64;
					} else {
						bs616 &= -65;
					}
					break;
				case 2:
					if(v616) {
						bs616 |= 32;
					} else {
						bs616 &= -33;
					}
					break;
				case 3:
					if(v616) {
						bs616 |= 16;
					} else {
						bs616 &= -17;
					}
					break;
				case 4:
					if(v616) {
						bs616 |= 8;
					} else {
						bs616 &= -9;
					}
					break;
				case 5:
					if(v616) {
						bs616 |= 4;
					} else {
						bs616 &= -5;
					}
					break;
				case 6:
					if(v616) {
						bs616 |= 2;
					} else {
						bs616 &= -3;
					}
					break;
				case 7:
					if(v616) {
						bs616 |= 1;
					} else {
						bs616 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs616;
			var this618 = 0;
			var bs617 = this618;
			var l617 = "     ".length;
			var _g1618 = 0;
			var _g718 = l617;
			while(_g1618 < _g718) {
				var i618 = _g1618++;
				var no617 = "     ".charCodeAt(i618);
				if(no617 == null) {
					break;
				}
				var v617;
				switch(no617) {
				case 32:
					v617 = false;
					break;
				case 42:
					v617 = true;
					break;
				case 48:
					v617 = false;
					break;
				case 49:
					v617 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i618)));
				}
				switch(i618 - (l617 - 8)) {
				case 0:
					if(v617) {
						bs617 |= 128;
					} else {
						bs617 &= -129;
					}
					break;
				case 1:
					if(v617) {
						bs617 |= 64;
					} else {
						bs617 &= -65;
					}
					break;
				case 2:
					if(v617) {
						bs617 |= 32;
					} else {
						bs617 &= -33;
					}
					break;
				case 3:
					if(v617) {
						bs617 |= 16;
					} else {
						bs617 &= -17;
					}
					break;
				case 4:
					if(v617) {
						bs617 |= 8;
					} else {
						bs617 &= -9;
					}
					break;
				case 5:
					if(v617) {
						bs617 |= 4;
					} else {
						bs617 &= -5;
					}
					break;
				case 6:
					if(v617) {
						bs617 |= 2;
					} else {
						bs617 &= -3;
					}
					break;
				case 7:
					if(v617) {
						bs617 |= 1;
					} else {
						bs617 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs617;
			var this619 = 0;
			var bs618 = this619;
			var l618 = "*   *".length;
			var _g1619 = 0;
			var _g719 = l618;
			while(_g1619 < _g719) {
				var i619 = _g1619++;
				var no618 = "*   *".charCodeAt(i619);
				if(no618 == null) {
					break;
				}
				var v618;
				switch(no618) {
				case 32:
					v618 = false;
					break;
				case 42:
					v618 = true;
					break;
				case 48:
					v618 = false;
					break;
				case 49:
					v618 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i619)));
				}
				switch(i619 - (l618 - 8)) {
				case 0:
					if(v618) {
						bs618 |= 128;
					} else {
						bs618 &= -129;
					}
					break;
				case 1:
					if(v618) {
						bs618 |= 64;
					} else {
						bs618 &= -65;
					}
					break;
				case 2:
					if(v618) {
						bs618 |= 32;
					} else {
						bs618 &= -33;
					}
					break;
				case 3:
					if(v618) {
						bs618 |= 16;
					} else {
						bs618 &= -17;
					}
					break;
				case 4:
					if(v618) {
						bs618 |= 8;
					} else {
						bs618 &= -9;
					}
					break;
				case 5:
					if(v618) {
						bs618 |= 4;
					} else {
						bs618 &= -5;
					}
					break;
				case 6:
					if(v618) {
						bs618 |= 2;
					} else {
						bs618 &= -3;
					}
					break;
				case 7:
					if(v618) {
						bs618 |= 1;
					} else {
						bs618 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs618;
			var this620 = 0;
			var bs619 = this620;
			var l619 = " * * ".length;
			var _g1620 = 0;
			var _g720 = l619;
			while(_g1620 < _g720) {
				var i620 = _g1620++;
				var no619 = " * * ".charCodeAt(i620);
				if(no619 == null) {
					break;
				}
				var v619;
				switch(no619) {
				case 32:
					v619 = false;
					break;
				case 42:
					v619 = true;
					break;
				case 48:
					v619 = false;
					break;
				case 49:
					v619 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i620)));
				}
				switch(i620 - (l619 - 8)) {
				case 0:
					if(v619) {
						bs619 |= 128;
					} else {
						bs619 &= -129;
					}
					break;
				case 1:
					if(v619) {
						bs619 |= 64;
					} else {
						bs619 &= -65;
					}
					break;
				case 2:
					if(v619) {
						bs619 |= 32;
					} else {
						bs619 &= -33;
					}
					break;
				case 3:
					if(v619) {
						bs619 |= 16;
					} else {
						bs619 &= -17;
					}
					break;
				case 4:
					if(v619) {
						bs619 |= 8;
					} else {
						bs619 &= -9;
					}
					break;
				case 5:
					if(v619) {
						bs619 |= 4;
					} else {
						bs619 &= -5;
					}
					break;
				case 6:
					if(v619) {
						bs619 |= 2;
					} else {
						bs619 &= -3;
					}
					break;
				case 7:
					if(v619) {
						bs619 |= 1;
					} else {
						bs619 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs619;
			var this621 = 0;
			var bs620 = this621;
			var l620 = "  *  ".length;
			var _g1621 = 0;
			var _g721 = l620;
			while(_g1621 < _g721) {
				var i621 = _g1621++;
				var no620 = "  *  ".charCodeAt(i621);
				if(no620 == null) {
					break;
				}
				var v620;
				switch(no620) {
				case 32:
					v620 = false;
					break;
				case 42:
					v620 = true;
					break;
				case 48:
					v620 = false;
					break;
				case 49:
					v620 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i621)));
				}
				switch(i621 - (l620 - 8)) {
				case 0:
					if(v620) {
						bs620 |= 128;
					} else {
						bs620 &= -129;
					}
					break;
				case 1:
					if(v620) {
						bs620 |= 64;
					} else {
						bs620 &= -65;
					}
					break;
				case 2:
					if(v620) {
						bs620 |= 32;
					} else {
						bs620 &= -33;
					}
					break;
				case 3:
					if(v620) {
						bs620 |= 16;
					} else {
						bs620 &= -17;
					}
					break;
				case 4:
					if(v620) {
						bs620 |= 8;
					} else {
						bs620 &= -9;
					}
					break;
				case 5:
					if(v620) {
						bs620 |= 4;
					} else {
						bs620 &= -5;
					}
					break;
				case 6:
					if(v620) {
						bs620 |= 2;
					} else {
						bs620 &= -3;
					}
					break;
				case 7:
					if(v620) {
						bs620 |= 1;
					} else {
						bs620 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs620;
			var this622 = 0;
			var bs621 = this622;
			var l621 = " * * ".length;
			var _g1622 = 0;
			var _g722 = l621;
			while(_g1622 < _g722) {
				var i622 = _g1622++;
				var no621 = " * * ".charCodeAt(i622);
				if(no621 == null) {
					break;
				}
				var v621;
				switch(no621) {
				case 32:
					v621 = false;
					break;
				case 42:
					v621 = true;
					break;
				case 48:
					v621 = false;
					break;
				case 49:
					v621 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i622)));
				}
				switch(i622 - (l621 - 8)) {
				case 0:
					if(v621) {
						bs621 |= 128;
					} else {
						bs621 &= -129;
					}
					break;
				case 1:
					if(v621) {
						bs621 |= 64;
					} else {
						bs621 &= -65;
					}
					break;
				case 2:
					if(v621) {
						bs621 |= 32;
					} else {
						bs621 &= -33;
					}
					break;
				case 3:
					if(v621) {
						bs621 |= 16;
					} else {
						bs621 &= -17;
					}
					break;
				case 4:
					if(v621) {
						bs621 |= 8;
					} else {
						bs621 &= -9;
					}
					break;
				case 5:
					if(v621) {
						bs621 |= 4;
					} else {
						bs621 &= -5;
					}
					break;
				case 6:
					if(v621) {
						bs621 |= 2;
					} else {
						bs621 &= -3;
					}
					break;
				case 7:
					if(v621) {
						bs621 |= 1;
					} else {
						bs621 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs621;
			var this623 = 0;
			var bs622 = this623;
			var l622 = "*   *".length;
			var _g1623 = 0;
			var _g723 = l622;
			while(_g1623 < _g723) {
				var i623 = _g1623++;
				var no622 = "*   *".charCodeAt(i623);
				if(no622 == null) {
					break;
				}
				var v622;
				switch(no622) {
				case 32:
					v622 = false;
					break;
				case 42:
					v622 = true;
					break;
				case 48:
					v622 = false;
					break;
				case 49:
					v622 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i623)));
				}
				switch(i623 - (l622 - 8)) {
				case 0:
					if(v622) {
						bs622 |= 128;
					} else {
						bs622 &= -129;
					}
					break;
				case 1:
					if(v622) {
						bs622 |= 64;
					} else {
						bs622 &= -65;
					}
					break;
				case 2:
					if(v622) {
						bs622 |= 32;
					} else {
						bs622 &= -33;
					}
					break;
				case 3:
					if(v622) {
						bs622 |= 16;
					} else {
						bs622 &= -17;
					}
					break;
				case 4:
					if(v622) {
						bs622 |= 8;
					} else {
						bs622 &= -9;
					}
					break;
				case 5:
					if(v622) {
						bs622 |= 4;
					} else {
						bs622 &= -5;
					}
					break;
				case 6:
					if(v622) {
						bs622 |= 2;
					} else {
						bs622 &= -3;
					}
					break;
				case 7:
					if(v622) {
						bs622 |= 1;
					} else {
						bs622 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs622;
			break;
		case 121:
			var this624 = 0;
			var bs623 = this624;
			var l623 = "     ".length;
			var _g1624 = 0;
			var _g724 = l623;
			while(_g1624 < _g724) {
				var i624 = _g1624++;
				var no623 = "     ".charCodeAt(i624);
				if(no623 == null) {
					break;
				}
				var v623;
				switch(no623) {
				case 32:
					v623 = false;
					break;
				case 42:
					v623 = true;
					break;
				case 48:
					v623 = false;
					break;
				case 49:
					v623 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i624)));
				}
				switch(i624 - (l623 - 8)) {
				case 0:
					if(v623) {
						bs623 |= 128;
					} else {
						bs623 &= -129;
					}
					break;
				case 1:
					if(v623) {
						bs623 |= 64;
					} else {
						bs623 &= -65;
					}
					break;
				case 2:
					if(v623) {
						bs623 |= 32;
					} else {
						bs623 &= -33;
					}
					break;
				case 3:
					if(v623) {
						bs623 |= 16;
					} else {
						bs623 &= -17;
					}
					break;
				case 4:
					if(v623) {
						bs623 |= 8;
					} else {
						bs623 &= -9;
					}
					break;
				case 5:
					if(v623) {
						bs623 |= 4;
					} else {
						bs623 &= -5;
					}
					break;
				case 6:
					if(v623) {
						bs623 |= 2;
					} else {
						bs623 &= -3;
					}
					break;
				case 7:
					if(v623) {
						bs623 |= 1;
					} else {
						bs623 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs623;
			var this625 = 0;
			var bs624 = this625;
			var l624 = "     ".length;
			var _g1625 = 0;
			var _g725 = l624;
			while(_g1625 < _g725) {
				var i625 = _g1625++;
				var no624 = "     ".charCodeAt(i625);
				if(no624 == null) {
					break;
				}
				var v624;
				switch(no624) {
				case 32:
					v624 = false;
					break;
				case 42:
					v624 = true;
					break;
				case 48:
					v624 = false;
					break;
				case 49:
					v624 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i625)));
				}
				switch(i625 - (l624 - 8)) {
				case 0:
					if(v624) {
						bs624 |= 128;
					} else {
						bs624 &= -129;
					}
					break;
				case 1:
					if(v624) {
						bs624 |= 64;
					} else {
						bs624 &= -65;
					}
					break;
				case 2:
					if(v624) {
						bs624 |= 32;
					} else {
						bs624 &= -33;
					}
					break;
				case 3:
					if(v624) {
						bs624 |= 16;
					} else {
						bs624 &= -17;
					}
					break;
				case 4:
					if(v624) {
						bs624 |= 8;
					} else {
						bs624 &= -9;
					}
					break;
				case 5:
					if(v624) {
						bs624 |= 4;
					} else {
						bs624 &= -5;
					}
					break;
				case 6:
					if(v624) {
						bs624 |= 2;
					} else {
						bs624 &= -3;
					}
					break;
				case 7:
					if(v624) {
						bs624 |= 1;
					} else {
						bs624 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs624;
			var this626 = 0;
			var bs625 = this626;
			var l625 = "*   *".length;
			var _g1626 = 0;
			var _g726 = l625;
			while(_g1626 < _g726) {
				var i626 = _g1626++;
				var no625 = "*   *".charCodeAt(i626);
				if(no625 == null) {
					break;
				}
				var v625;
				switch(no625) {
				case 32:
					v625 = false;
					break;
				case 42:
					v625 = true;
					break;
				case 48:
					v625 = false;
					break;
				case 49:
					v625 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i626)));
				}
				switch(i626 - (l625 - 8)) {
				case 0:
					if(v625) {
						bs625 |= 128;
					} else {
						bs625 &= -129;
					}
					break;
				case 1:
					if(v625) {
						bs625 |= 64;
					} else {
						bs625 &= -65;
					}
					break;
				case 2:
					if(v625) {
						bs625 |= 32;
					} else {
						bs625 &= -33;
					}
					break;
				case 3:
					if(v625) {
						bs625 |= 16;
					} else {
						bs625 &= -17;
					}
					break;
				case 4:
					if(v625) {
						bs625 |= 8;
					} else {
						bs625 &= -9;
					}
					break;
				case 5:
					if(v625) {
						bs625 |= 4;
					} else {
						bs625 &= -5;
					}
					break;
				case 6:
					if(v625) {
						bs625 |= 2;
					} else {
						bs625 &= -3;
					}
					break;
				case 7:
					if(v625) {
						bs625 |= 1;
					} else {
						bs625 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs625;
			var this627 = 0;
			var bs626 = this627;
			var l626 = "*   *".length;
			var _g1627 = 0;
			var _g727 = l626;
			while(_g1627 < _g727) {
				var i627 = _g1627++;
				var no626 = "*   *".charCodeAt(i627);
				if(no626 == null) {
					break;
				}
				var v626;
				switch(no626) {
				case 32:
					v626 = false;
					break;
				case 42:
					v626 = true;
					break;
				case 48:
					v626 = false;
					break;
				case 49:
					v626 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i627)));
				}
				switch(i627 - (l626 - 8)) {
				case 0:
					if(v626) {
						bs626 |= 128;
					} else {
						bs626 &= -129;
					}
					break;
				case 1:
					if(v626) {
						bs626 |= 64;
					} else {
						bs626 &= -65;
					}
					break;
				case 2:
					if(v626) {
						bs626 |= 32;
					} else {
						bs626 &= -33;
					}
					break;
				case 3:
					if(v626) {
						bs626 |= 16;
					} else {
						bs626 &= -17;
					}
					break;
				case 4:
					if(v626) {
						bs626 |= 8;
					} else {
						bs626 &= -9;
					}
					break;
				case 5:
					if(v626) {
						bs626 |= 4;
					} else {
						bs626 &= -5;
					}
					break;
				case 6:
					if(v626) {
						bs626 |= 2;
					} else {
						bs626 &= -3;
					}
					break;
				case 7:
					if(v626) {
						bs626 |= 1;
					} else {
						bs626 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs626;
			var this628 = 0;
			var bs627 = this628;
			var l627 = " ****".length;
			var _g1628 = 0;
			var _g728 = l627;
			while(_g1628 < _g728) {
				var i628 = _g1628++;
				var no627 = " ****".charCodeAt(i628);
				if(no627 == null) {
					break;
				}
				var v627;
				switch(no627) {
				case 32:
					v627 = false;
					break;
				case 42:
					v627 = true;
					break;
				case 48:
					v627 = false;
					break;
				case 49:
					v627 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i628)));
				}
				switch(i628 - (l627 - 8)) {
				case 0:
					if(v627) {
						bs627 |= 128;
					} else {
						bs627 &= -129;
					}
					break;
				case 1:
					if(v627) {
						bs627 |= 64;
					} else {
						bs627 &= -65;
					}
					break;
				case 2:
					if(v627) {
						bs627 |= 32;
					} else {
						bs627 &= -33;
					}
					break;
				case 3:
					if(v627) {
						bs627 |= 16;
					} else {
						bs627 &= -17;
					}
					break;
				case 4:
					if(v627) {
						bs627 |= 8;
					} else {
						bs627 &= -9;
					}
					break;
				case 5:
					if(v627) {
						bs627 |= 4;
					} else {
						bs627 &= -5;
					}
					break;
				case 6:
					if(v627) {
						bs627 |= 2;
					} else {
						bs627 &= -3;
					}
					break;
				case 7:
					if(v627) {
						bs627 |= 1;
					} else {
						bs627 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs627;
			var this629 = 0;
			var bs628 = this629;
			var l628 = "    *".length;
			var _g1629 = 0;
			var _g729 = l628;
			while(_g1629 < _g729) {
				var i629 = _g1629++;
				var no628 = "    *".charCodeAt(i629);
				if(no628 == null) {
					break;
				}
				var v628;
				switch(no628) {
				case 32:
					v628 = false;
					break;
				case 42:
					v628 = true;
					break;
				case 48:
					v628 = false;
					break;
				case 49:
					v628 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i629)));
				}
				switch(i629 - (l628 - 8)) {
				case 0:
					if(v628) {
						bs628 |= 128;
					} else {
						bs628 &= -129;
					}
					break;
				case 1:
					if(v628) {
						bs628 |= 64;
					} else {
						bs628 &= -65;
					}
					break;
				case 2:
					if(v628) {
						bs628 |= 32;
					} else {
						bs628 &= -33;
					}
					break;
				case 3:
					if(v628) {
						bs628 |= 16;
					} else {
						bs628 &= -17;
					}
					break;
				case 4:
					if(v628) {
						bs628 |= 8;
					} else {
						bs628 &= -9;
					}
					break;
				case 5:
					if(v628) {
						bs628 |= 4;
					} else {
						bs628 &= -5;
					}
					break;
				case 6:
					if(v628) {
						bs628 |= 2;
					} else {
						bs628 &= -3;
					}
					break;
				case 7:
					if(v628) {
						bs628 |= 1;
					} else {
						bs628 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs628;
			var this630 = 0;
			var bs629 = this630;
			var l629 = " *** ".length;
			var _g1630 = 0;
			var _g730 = l629;
			while(_g1630 < _g730) {
				var i630 = _g1630++;
				var no629 = " *** ".charCodeAt(i630);
				if(no629 == null) {
					break;
				}
				var v629;
				switch(no629) {
				case 32:
					v629 = false;
					break;
				case 42:
					v629 = true;
					break;
				case 48:
					v629 = false;
					break;
				case 49:
					v629 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i630)));
				}
				switch(i630 - (l629 - 8)) {
				case 0:
					if(v629) {
						bs629 |= 128;
					} else {
						bs629 &= -129;
					}
					break;
				case 1:
					if(v629) {
						bs629 |= 64;
					} else {
						bs629 &= -65;
					}
					break;
				case 2:
					if(v629) {
						bs629 |= 32;
					} else {
						bs629 &= -33;
					}
					break;
				case 3:
					if(v629) {
						bs629 |= 16;
					} else {
						bs629 &= -17;
					}
					break;
				case 4:
					if(v629) {
						bs629 |= 8;
					} else {
						bs629 &= -9;
					}
					break;
				case 5:
					if(v629) {
						bs629 |= 4;
					} else {
						bs629 &= -5;
					}
					break;
				case 6:
					if(v629) {
						bs629 |= 2;
					} else {
						bs629 &= -3;
					}
					break;
				case 7:
					if(v629) {
						bs629 |= 1;
					} else {
						bs629 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs629;
			break;
		case 122:
			var this631 = 0;
			var bs630 = this631;
			var l630 = "     ".length;
			var _g1631 = 0;
			var _g731 = l630;
			while(_g1631 < _g731) {
				var i631 = _g1631++;
				var no630 = "     ".charCodeAt(i631);
				if(no630 == null) {
					break;
				}
				var v630;
				switch(no630) {
				case 32:
					v630 = false;
					break;
				case 42:
					v630 = true;
					break;
				case 48:
					v630 = false;
					break;
				case 49:
					v630 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i631)));
				}
				switch(i631 - (l630 - 8)) {
				case 0:
					if(v630) {
						bs630 |= 128;
					} else {
						bs630 &= -129;
					}
					break;
				case 1:
					if(v630) {
						bs630 |= 64;
					} else {
						bs630 &= -65;
					}
					break;
				case 2:
					if(v630) {
						bs630 |= 32;
					} else {
						bs630 &= -33;
					}
					break;
				case 3:
					if(v630) {
						bs630 |= 16;
					} else {
						bs630 &= -17;
					}
					break;
				case 4:
					if(v630) {
						bs630 |= 8;
					} else {
						bs630 &= -9;
					}
					break;
				case 5:
					if(v630) {
						bs630 |= 4;
					} else {
						bs630 &= -5;
					}
					break;
				case 6:
					if(v630) {
						bs630 |= 2;
					} else {
						bs630 &= -3;
					}
					break;
				case 7:
					if(v630) {
						bs630 |= 1;
					} else {
						bs630 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs630;
			var this632 = 0;
			var bs631 = this632;
			var l631 = "     ".length;
			var _g1632 = 0;
			var _g732 = l631;
			while(_g1632 < _g732) {
				var i632 = _g1632++;
				var no631 = "     ".charCodeAt(i632);
				if(no631 == null) {
					break;
				}
				var v631;
				switch(no631) {
				case 32:
					v631 = false;
					break;
				case 42:
					v631 = true;
					break;
				case 48:
					v631 = false;
					break;
				case 49:
					v631 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i632)));
				}
				switch(i632 - (l631 - 8)) {
				case 0:
					if(v631) {
						bs631 |= 128;
					} else {
						bs631 &= -129;
					}
					break;
				case 1:
					if(v631) {
						bs631 |= 64;
					} else {
						bs631 &= -65;
					}
					break;
				case 2:
					if(v631) {
						bs631 |= 32;
					} else {
						bs631 &= -33;
					}
					break;
				case 3:
					if(v631) {
						bs631 |= 16;
					} else {
						bs631 &= -17;
					}
					break;
				case 4:
					if(v631) {
						bs631 |= 8;
					} else {
						bs631 &= -9;
					}
					break;
				case 5:
					if(v631) {
						bs631 |= 4;
					} else {
						bs631 &= -5;
					}
					break;
				case 6:
					if(v631) {
						bs631 |= 2;
					} else {
						bs631 &= -3;
					}
					break;
				case 7:
					if(v631) {
						bs631 |= 1;
					} else {
						bs631 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs631;
			var this633 = 0;
			var bs632 = this633;
			var l632 = "*****".length;
			var _g1633 = 0;
			var _g733 = l632;
			while(_g1633 < _g733) {
				var i633 = _g1633++;
				var no632 = "*****".charCodeAt(i633);
				if(no632 == null) {
					break;
				}
				var v632;
				switch(no632) {
				case 32:
					v632 = false;
					break;
				case 42:
					v632 = true;
					break;
				case 48:
					v632 = false;
					break;
				case 49:
					v632 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i633)));
				}
				switch(i633 - (l632 - 8)) {
				case 0:
					if(v632) {
						bs632 |= 128;
					} else {
						bs632 &= -129;
					}
					break;
				case 1:
					if(v632) {
						bs632 |= 64;
					} else {
						bs632 &= -65;
					}
					break;
				case 2:
					if(v632) {
						bs632 |= 32;
					} else {
						bs632 &= -33;
					}
					break;
				case 3:
					if(v632) {
						bs632 |= 16;
					} else {
						bs632 &= -17;
					}
					break;
				case 4:
					if(v632) {
						bs632 |= 8;
					} else {
						bs632 &= -9;
					}
					break;
				case 5:
					if(v632) {
						bs632 |= 4;
					} else {
						bs632 &= -5;
					}
					break;
				case 6:
					if(v632) {
						bs632 |= 2;
					} else {
						bs632 &= -3;
					}
					break;
				case 7:
					if(v632) {
						bs632 |= 1;
					} else {
						bs632 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs632;
			var this634 = 0;
			var bs633 = this634;
			var l633 = "   * ".length;
			var _g1634 = 0;
			var _g734 = l633;
			while(_g1634 < _g734) {
				var i634 = _g1634++;
				var no633 = "   * ".charCodeAt(i634);
				if(no633 == null) {
					break;
				}
				var v633;
				switch(no633) {
				case 32:
					v633 = false;
					break;
				case 42:
					v633 = true;
					break;
				case 48:
					v633 = false;
					break;
				case 49:
					v633 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i634)));
				}
				switch(i634 - (l633 - 8)) {
				case 0:
					if(v633) {
						bs633 |= 128;
					} else {
						bs633 &= -129;
					}
					break;
				case 1:
					if(v633) {
						bs633 |= 64;
					} else {
						bs633 &= -65;
					}
					break;
				case 2:
					if(v633) {
						bs633 |= 32;
					} else {
						bs633 &= -33;
					}
					break;
				case 3:
					if(v633) {
						bs633 |= 16;
					} else {
						bs633 &= -17;
					}
					break;
				case 4:
					if(v633) {
						bs633 |= 8;
					} else {
						bs633 &= -9;
					}
					break;
				case 5:
					if(v633) {
						bs633 |= 4;
					} else {
						bs633 &= -5;
					}
					break;
				case 6:
					if(v633) {
						bs633 |= 2;
					} else {
						bs633 &= -3;
					}
					break;
				case 7:
					if(v633) {
						bs633 |= 1;
					} else {
						bs633 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs633;
			var this635 = 0;
			var bs634 = this635;
			var l634 = "  *  ".length;
			var _g1635 = 0;
			var _g735 = l634;
			while(_g1635 < _g735) {
				var i635 = _g1635++;
				var no634 = "  *  ".charCodeAt(i635);
				if(no634 == null) {
					break;
				}
				var v634;
				switch(no634) {
				case 32:
					v634 = false;
					break;
				case 42:
					v634 = true;
					break;
				case 48:
					v634 = false;
					break;
				case 49:
					v634 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i635)));
				}
				switch(i635 - (l634 - 8)) {
				case 0:
					if(v634) {
						bs634 |= 128;
					} else {
						bs634 &= -129;
					}
					break;
				case 1:
					if(v634) {
						bs634 |= 64;
					} else {
						bs634 &= -65;
					}
					break;
				case 2:
					if(v634) {
						bs634 |= 32;
					} else {
						bs634 &= -33;
					}
					break;
				case 3:
					if(v634) {
						bs634 |= 16;
					} else {
						bs634 &= -17;
					}
					break;
				case 4:
					if(v634) {
						bs634 |= 8;
					} else {
						bs634 &= -9;
					}
					break;
				case 5:
					if(v634) {
						bs634 |= 4;
					} else {
						bs634 &= -5;
					}
					break;
				case 6:
					if(v634) {
						bs634 |= 2;
					} else {
						bs634 &= -3;
					}
					break;
				case 7:
					if(v634) {
						bs634 |= 1;
					} else {
						bs634 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs634;
			var this636 = 0;
			var bs635 = this636;
			var l635 = " *   ".length;
			var _g1636 = 0;
			var _g736 = l635;
			while(_g1636 < _g736) {
				var i636 = _g1636++;
				var no635 = " *   ".charCodeAt(i636);
				if(no635 == null) {
					break;
				}
				var v635;
				switch(no635) {
				case 32:
					v635 = false;
					break;
				case 42:
					v635 = true;
					break;
				case 48:
					v635 = false;
					break;
				case 49:
					v635 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i636)));
				}
				switch(i636 - (l635 - 8)) {
				case 0:
					if(v635) {
						bs635 |= 128;
					} else {
						bs635 &= -129;
					}
					break;
				case 1:
					if(v635) {
						bs635 |= 64;
					} else {
						bs635 &= -65;
					}
					break;
				case 2:
					if(v635) {
						bs635 |= 32;
					} else {
						bs635 &= -33;
					}
					break;
				case 3:
					if(v635) {
						bs635 |= 16;
					} else {
						bs635 &= -17;
					}
					break;
				case 4:
					if(v635) {
						bs635 |= 8;
					} else {
						bs635 &= -9;
					}
					break;
				case 5:
					if(v635) {
						bs635 |= 4;
					} else {
						bs635 &= -5;
					}
					break;
				case 6:
					if(v635) {
						bs635 |= 2;
					} else {
						bs635 &= -3;
					}
					break;
				case 7:
					if(v635) {
						bs635 |= 1;
					} else {
						bs635 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs635;
			var this637 = 0;
			var bs636 = this637;
			var l636 = "*****".length;
			var _g1637 = 0;
			var _g737 = l636;
			while(_g1637 < _g737) {
				var i637 = _g1637++;
				var no636 = "*****".charCodeAt(i637);
				if(no636 == null) {
					break;
				}
				var v636;
				switch(no636) {
				case 32:
					v636 = false;
					break;
				case 42:
					v636 = true;
					break;
				case 48:
					v636 = false;
					break;
				case 49:
					v636 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i637)));
				}
				switch(i637 - (l636 - 8)) {
				case 0:
					if(v636) {
						bs636 |= 128;
					} else {
						bs636 &= -129;
					}
					break;
				case 1:
					if(v636) {
						bs636 |= 64;
					} else {
						bs636 &= -65;
					}
					break;
				case 2:
					if(v636) {
						bs636 |= 32;
					} else {
						bs636 &= -33;
					}
					break;
				case 3:
					if(v636) {
						bs636 |= 16;
					} else {
						bs636 &= -17;
					}
					break;
				case 4:
					if(v636) {
						bs636 |= 8;
					} else {
						bs636 &= -9;
					}
					break;
				case 5:
					if(v636) {
						bs636 |= 4;
					} else {
						bs636 &= -5;
					}
					break;
				case 6:
					if(v636) {
						bs636 |= 2;
					} else {
						bs636 &= -3;
					}
					break;
				case 7:
					if(v636) {
						bs636 |= 1;
					} else {
						bs636 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs636;
			break;
		case 123:
			var this638 = 0;
			var bs637 = this638;
			var l637 = "   * ".length;
			var _g1638 = 0;
			var _g738 = l637;
			while(_g1638 < _g738) {
				var i638 = _g1638++;
				var no637 = "   * ".charCodeAt(i638);
				if(no637 == null) {
					break;
				}
				var v637;
				switch(no637) {
				case 32:
					v637 = false;
					break;
				case 42:
					v637 = true;
					break;
				case 48:
					v637 = false;
					break;
				case 49:
					v637 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i638)));
				}
				switch(i638 - (l637 - 8)) {
				case 0:
					if(v637) {
						bs637 |= 128;
					} else {
						bs637 &= -129;
					}
					break;
				case 1:
					if(v637) {
						bs637 |= 64;
					} else {
						bs637 &= -65;
					}
					break;
				case 2:
					if(v637) {
						bs637 |= 32;
					} else {
						bs637 &= -33;
					}
					break;
				case 3:
					if(v637) {
						bs637 |= 16;
					} else {
						bs637 &= -17;
					}
					break;
				case 4:
					if(v637) {
						bs637 |= 8;
					} else {
						bs637 &= -9;
					}
					break;
				case 5:
					if(v637) {
						bs637 |= 4;
					} else {
						bs637 &= -5;
					}
					break;
				case 6:
					if(v637) {
						bs637 |= 2;
					} else {
						bs637 &= -3;
					}
					break;
				case 7:
					if(v637) {
						bs637 |= 1;
					} else {
						bs637 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs637;
			var this639 = 0;
			var bs638 = this639;
			var l638 = "  *  ".length;
			var _g1639 = 0;
			var _g739 = l638;
			while(_g1639 < _g739) {
				var i639 = _g1639++;
				var no638 = "  *  ".charCodeAt(i639);
				if(no638 == null) {
					break;
				}
				var v638;
				switch(no638) {
				case 32:
					v638 = false;
					break;
				case 42:
					v638 = true;
					break;
				case 48:
					v638 = false;
					break;
				case 49:
					v638 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i639)));
				}
				switch(i639 - (l638 - 8)) {
				case 0:
					if(v638) {
						bs638 |= 128;
					} else {
						bs638 &= -129;
					}
					break;
				case 1:
					if(v638) {
						bs638 |= 64;
					} else {
						bs638 &= -65;
					}
					break;
				case 2:
					if(v638) {
						bs638 |= 32;
					} else {
						bs638 &= -33;
					}
					break;
				case 3:
					if(v638) {
						bs638 |= 16;
					} else {
						bs638 &= -17;
					}
					break;
				case 4:
					if(v638) {
						bs638 |= 8;
					} else {
						bs638 &= -9;
					}
					break;
				case 5:
					if(v638) {
						bs638 |= 4;
					} else {
						bs638 &= -5;
					}
					break;
				case 6:
					if(v638) {
						bs638 |= 2;
					} else {
						bs638 &= -3;
					}
					break;
				case 7:
					if(v638) {
						bs638 |= 1;
					} else {
						bs638 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs638;
			var this640 = 0;
			var bs639 = this640;
			var l639 = "  *  ".length;
			var _g1640 = 0;
			var _g740 = l639;
			while(_g1640 < _g740) {
				var i640 = _g1640++;
				var no639 = "  *  ".charCodeAt(i640);
				if(no639 == null) {
					break;
				}
				var v639;
				switch(no639) {
				case 32:
					v639 = false;
					break;
				case 42:
					v639 = true;
					break;
				case 48:
					v639 = false;
					break;
				case 49:
					v639 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i640)));
				}
				switch(i640 - (l639 - 8)) {
				case 0:
					if(v639) {
						bs639 |= 128;
					} else {
						bs639 &= -129;
					}
					break;
				case 1:
					if(v639) {
						bs639 |= 64;
					} else {
						bs639 &= -65;
					}
					break;
				case 2:
					if(v639) {
						bs639 |= 32;
					} else {
						bs639 &= -33;
					}
					break;
				case 3:
					if(v639) {
						bs639 |= 16;
					} else {
						bs639 &= -17;
					}
					break;
				case 4:
					if(v639) {
						bs639 |= 8;
					} else {
						bs639 &= -9;
					}
					break;
				case 5:
					if(v639) {
						bs639 |= 4;
					} else {
						bs639 &= -5;
					}
					break;
				case 6:
					if(v639) {
						bs639 |= 2;
					} else {
						bs639 &= -3;
					}
					break;
				case 7:
					if(v639) {
						bs639 |= 1;
					} else {
						bs639 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs639;
			var this641 = 0;
			var bs640 = this641;
			var l640 = " *   ".length;
			var _g1641 = 0;
			var _g741 = l640;
			while(_g1641 < _g741) {
				var i641 = _g1641++;
				var no640 = " *   ".charCodeAt(i641);
				if(no640 == null) {
					break;
				}
				var v640;
				switch(no640) {
				case 32:
					v640 = false;
					break;
				case 42:
					v640 = true;
					break;
				case 48:
					v640 = false;
					break;
				case 49:
					v640 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i641)));
				}
				switch(i641 - (l640 - 8)) {
				case 0:
					if(v640) {
						bs640 |= 128;
					} else {
						bs640 &= -129;
					}
					break;
				case 1:
					if(v640) {
						bs640 |= 64;
					} else {
						bs640 &= -65;
					}
					break;
				case 2:
					if(v640) {
						bs640 |= 32;
					} else {
						bs640 &= -33;
					}
					break;
				case 3:
					if(v640) {
						bs640 |= 16;
					} else {
						bs640 &= -17;
					}
					break;
				case 4:
					if(v640) {
						bs640 |= 8;
					} else {
						bs640 &= -9;
					}
					break;
				case 5:
					if(v640) {
						bs640 |= 4;
					} else {
						bs640 &= -5;
					}
					break;
				case 6:
					if(v640) {
						bs640 |= 2;
					} else {
						bs640 &= -3;
					}
					break;
				case 7:
					if(v640) {
						bs640 |= 1;
					} else {
						bs640 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs640;
			var this642 = 0;
			var bs641 = this642;
			var l641 = "  *  ".length;
			var _g1642 = 0;
			var _g742 = l641;
			while(_g1642 < _g742) {
				var i642 = _g1642++;
				var no641 = "  *  ".charCodeAt(i642);
				if(no641 == null) {
					break;
				}
				var v641;
				switch(no641) {
				case 32:
					v641 = false;
					break;
				case 42:
					v641 = true;
					break;
				case 48:
					v641 = false;
					break;
				case 49:
					v641 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i642)));
				}
				switch(i642 - (l641 - 8)) {
				case 0:
					if(v641) {
						bs641 |= 128;
					} else {
						bs641 &= -129;
					}
					break;
				case 1:
					if(v641) {
						bs641 |= 64;
					} else {
						bs641 &= -65;
					}
					break;
				case 2:
					if(v641) {
						bs641 |= 32;
					} else {
						bs641 &= -33;
					}
					break;
				case 3:
					if(v641) {
						bs641 |= 16;
					} else {
						bs641 &= -17;
					}
					break;
				case 4:
					if(v641) {
						bs641 |= 8;
					} else {
						bs641 &= -9;
					}
					break;
				case 5:
					if(v641) {
						bs641 |= 4;
					} else {
						bs641 &= -5;
					}
					break;
				case 6:
					if(v641) {
						bs641 |= 2;
					} else {
						bs641 &= -3;
					}
					break;
				case 7:
					if(v641) {
						bs641 |= 1;
					} else {
						bs641 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs641;
			var this643 = 0;
			var bs642 = this643;
			var l642 = "  *  ".length;
			var _g1643 = 0;
			var _g743 = l642;
			while(_g1643 < _g743) {
				var i643 = _g1643++;
				var no642 = "  *  ".charCodeAt(i643);
				if(no642 == null) {
					break;
				}
				var v642;
				switch(no642) {
				case 32:
					v642 = false;
					break;
				case 42:
					v642 = true;
					break;
				case 48:
					v642 = false;
					break;
				case 49:
					v642 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i643)));
				}
				switch(i643 - (l642 - 8)) {
				case 0:
					if(v642) {
						bs642 |= 128;
					} else {
						bs642 &= -129;
					}
					break;
				case 1:
					if(v642) {
						bs642 |= 64;
					} else {
						bs642 &= -65;
					}
					break;
				case 2:
					if(v642) {
						bs642 |= 32;
					} else {
						bs642 &= -33;
					}
					break;
				case 3:
					if(v642) {
						bs642 |= 16;
					} else {
						bs642 &= -17;
					}
					break;
				case 4:
					if(v642) {
						bs642 |= 8;
					} else {
						bs642 &= -9;
					}
					break;
				case 5:
					if(v642) {
						bs642 |= 4;
					} else {
						bs642 &= -5;
					}
					break;
				case 6:
					if(v642) {
						bs642 |= 2;
					} else {
						bs642 &= -3;
					}
					break;
				case 7:
					if(v642) {
						bs642 |= 1;
					} else {
						bs642 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs642;
			var this644 = 0;
			var bs643 = this644;
			var l643 = "   * ".length;
			var _g1644 = 0;
			var _g744 = l643;
			while(_g1644 < _g744) {
				var i644 = _g1644++;
				var no643 = "   * ".charCodeAt(i644);
				if(no643 == null) {
					break;
				}
				var v643;
				switch(no643) {
				case 32:
					v643 = false;
					break;
				case 42:
					v643 = true;
					break;
				case 48:
					v643 = false;
					break;
				case 49:
					v643 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i644)));
				}
				switch(i644 - (l643 - 8)) {
				case 0:
					if(v643) {
						bs643 |= 128;
					} else {
						bs643 &= -129;
					}
					break;
				case 1:
					if(v643) {
						bs643 |= 64;
					} else {
						bs643 &= -65;
					}
					break;
				case 2:
					if(v643) {
						bs643 |= 32;
					} else {
						bs643 &= -33;
					}
					break;
				case 3:
					if(v643) {
						bs643 |= 16;
					} else {
						bs643 &= -17;
					}
					break;
				case 4:
					if(v643) {
						bs643 |= 8;
					} else {
						bs643 &= -9;
					}
					break;
				case 5:
					if(v643) {
						bs643 |= 4;
					} else {
						bs643 &= -5;
					}
					break;
				case 6:
					if(v643) {
						bs643 |= 2;
					} else {
						bs643 &= -3;
					}
					break;
				case 7:
					if(v643) {
						bs643 |= 1;
					} else {
						bs643 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs643;
			break;
		case 124:
			var this645 = 0;
			var bs644 = this645;
			var l644 = "  *  ".length;
			var _g1645 = 0;
			var _g745 = l644;
			while(_g1645 < _g745) {
				var i645 = _g1645++;
				var no644 = "  *  ".charCodeAt(i645);
				if(no644 == null) {
					break;
				}
				var v644;
				switch(no644) {
				case 32:
					v644 = false;
					break;
				case 42:
					v644 = true;
					break;
				case 48:
					v644 = false;
					break;
				case 49:
					v644 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i645)));
				}
				switch(i645 - (l644 - 8)) {
				case 0:
					if(v644) {
						bs644 |= 128;
					} else {
						bs644 &= -129;
					}
					break;
				case 1:
					if(v644) {
						bs644 |= 64;
					} else {
						bs644 &= -65;
					}
					break;
				case 2:
					if(v644) {
						bs644 |= 32;
					} else {
						bs644 &= -33;
					}
					break;
				case 3:
					if(v644) {
						bs644 |= 16;
					} else {
						bs644 &= -17;
					}
					break;
				case 4:
					if(v644) {
						bs644 |= 8;
					} else {
						bs644 &= -9;
					}
					break;
				case 5:
					if(v644) {
						bs644 |= 4;
					} else {
						bs644 &= -5;
					}
					break;
				case 6:
					if(v644) {
						bs644 |= 2;
					} else {
						bs644 &= -3;
					}
					break;
				case 7:
					if(v644) {
						bs644 |= 1;
					} else {
						bs644 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs644;
			var this646 = 0;
			var bs645 = this646;
			var l645 = "  *  ".length;
			var _g1646 = 0;
			var _g746 = l645;
			while(_g1646 < _g746) {
				var i646 = _g1646++;
				var no645 = "  *  ".charCodeAt(i646);
				if(no645 == null) {
					break;
				}
				var v645;
				switch(no645) {
				case 32:
					v645 = false;
					break;
				case 42:
					v645 = true;
					break;
				case 48:
					v645 = false;
					break;
				case 49:
					v645 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i646)));
				}
				switch(i646 - (l645 - 8)) {
				case 0:
					if(v645) {
						bs645 |= 128;
					} else {
						bs645 &= -129;
					}
					break;
				case 1:
					if(v645) {
						bs645 |= 64;
					} else {
						bs645 &= -65;
					}
					break;
				case 2:
					if(v645) {
						bs645 |= 32;
					} else {
						bs645 &= -33;
					}
					break;
				case 3:
					if(v645) {
						bs645 |= 16;
					} else {
						bs645 &= -17;
					}
					break;
				case 4:
					if(v645) {
						bs645 |= 8;
					} else {
						bs645 &= -9;
					}
					break;
				case 5:
					if(v645) {
						bs645 |= 4;
					} else {
						bs645 &= -5;
					}
					break;
				case 6:
					if(v645) {
						bs645 |= 2;
					} else {
						bs645 &= -3;
					}
					break;
				case 7:
					if(v645) {
						bs645 |= 1;
					} else {
						bs645 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs645;
			var this647 = 0;
			var bs646 = this647;
			var l646 = "  *  ".length;
			var _g1647 = 0;
			var _g747 = l646;
			while(_g1647 < _g747) {
				var i647 = _g1647++;
				var no646 = "  *  ".charCodeAt(i647);
				if(no646 == null) {
					break;
				}
				var v646;
				switch(no646) {
				case 32:
					v646 = false;
					break;
				case 42:
					v646 = true;
					break;
				case 48:
					v646 = false;
					break;
				case 49:
					v646 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i647)));
				}
				switch(i647 - (l646 - 8)) {
				case 0:
					if(v646) {
						bs646 |= 128;
					} else {
						bs646 &= -129;
					}
					break;
				case 1:
					if(v646) {
						bs646 |= 64;
					} else {
						bs646 &= -65;
					}
					break;
				case 2:
					if(v646) {
						bs646 |= 32;
					} else {
						bs646 &= -33;
					}
					break;
				case 3:
					if(v646) {
						bs646 |= 16;
					} else {
						bs646 &= -17;
					}
					break;
				case 4:
					if(v646) {
						bs646 |= 8;
					} else {
						bs646 &= -9;
					}
					break;
				case 5:
					if(v646) {
						bs646 |= 4;
					} else {
						bs646 &= -5;
					}
					break;
				case 6:
					if(v646) {
						bs646 |= 2;
					} else {
						bs646 &= -3;
					}
					break;
				case 7:
					if(v646) {
						bs646 |= 1;
					} else {
						bs646 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs646;
			var this648 = 0;
			var bs647 = this648;
			var l647 = "  *  ".length;
			var _g1648 = 0;
			var _g748 = l647;
			while(_g1648 < _g748) {
				var i648 = _g1648++;
				var no647 = "  *  ".charCodeAt(i648);
				if(no647 == null) {
					break;
				}
				var v647;
				switch(no647) {
				case 32:
					v647 = false;
					break;
				case 42:
					v647 = true;
					break;
				case 48:
					v647 = false;
					break;
				case 49:
					v647 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i648)));
				}
				switch(i648 - (l647 - 8)) {
				case 0:
					if(v647) {
						bs647 |= 128;
					} else {
						bs647 &= -129;
					}
					break;
				case 1:
					if(v647) {
						bs647 |= 64;
					} else {
						bs647 &= -65;
					}
					break;
				case 2:
					if(v647) {
						bs647 |= 32;
					} else {
						bs647 &= -33;
					}
					break;
				case 3:
					if(v647) {
						bs647 |= 16;
					} else {
						bs647 &= -17;
					}
					break;
				case 4:
					if(v647) {
						bs647 |= 8;
					} else {
						bs647 &= -9;
					}
					break;
				case 5:
					if(v647) {
						bs647 |= 4;
					} else {
						bs647 &= -5;
					}
					break;
				case 6:
					if(v647) {
						bs647 |= 2;
					} else {
						bs647 &= -3;
					}
					break;
				case 7:
					if(v647) {
						bs647 |= 1;
					} else {
						bs647 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs647;
			var this649 = 0;
			var bs648 = this649;
			var l648 = "  *  ".length;
			var _g1649 = 0;
			var _g749 = l648;
			while(_g1649 < _g749) {
				var i649 = _g1649++;
				var no648 = "  *  ".charCodeAt(i649);
				if(no648 == null) {
					break;
				}
				var v648;
				switch(no648) {
				case 32:
					v648 = false;
					break;
				case 42:
					v648 = true;
					break;
				case 48:
					v648 = false;
					break;
				case 49:
					v648 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i649)));
				}
				switch(i649 - (l648 - 8)) {
				case 0:
					if(v648) {
						bs648 |= 128;
					} else {
						bs648 &= -129;
					}
					break;
				case 1:
					if(v648) {
						bs648 |= 64;
					} else {
						bs648 &= -65;
					}
					break;
				case 2:
					if(v648) {
						bs648 |= 32;
					} else {
						bs648 &= -33;
					}
					break;
				case 3:
					if(v648) {
						bs648 |= 16;
					} else {
						bs648 &= -17;
					}
					break;
				case 4:
					if(v648) {
						bs648 |= 8;
					} else {
						bs648 &= -9;
					}
					break;
				case 5:
					if(v648) {
						bs648 |= 4;
					} else {
						bs648 &= -5;
					}
					break;
				case 6:
					if(v648) {
						bs648 |= 2;
					} else {
						bs648 &= -3;
					}
					break;
				case 7:
					if(v648) {
						bs648 |= 1;
					} else {
						bs648 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs648;
			var this650 = 0;
			var bs649 = this650;
			var l649 = "  *  ".length;
			var _g1650 = 0;
			var _g750 = l649;
			while(_g1650 < _g750) {
				var i650 = _g1650++;
				var no649 = "  *  ".charCodeAt(i650);
				if(no649 == null) {
					break;
				}
				var v649;
				switch(no649) {
				case 32:
					v649 = false;
					break;
				case 42:
					v649 = true;
					break;
				case 48:
					v649 = false;
					break;
				case 49:
					v649 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i650)));
				}
				switch(i650 - (l649 - 8)) {
				case 0:
					if(v649) {
						bs649 |= 128;
					} else {
						bs649 &= -129;
					}
					break;
				case 1:
					if(v649) {
						bs649 |= 64;
					} else {
						bs649 &= -65;
					}
					break;
				case 2:
					if(v649) {
						bs649 |= 32;
					} else {
						bs649 &= -33;
					}
					break;
				case 3:
					if(v649) {
						bs649 |= 16;
					} else {
						bs649 &= -17;
					}
					break;
				case 4:
					if(v649) {
						bs649 |= 8;
					} else {
						bs649 &= -9;
					}
					break;
				case 5:
					if(v649) {
						bs649 |= 4;
					} else {
						bs649 &= -5;
					}
					break;
				case 6:
					if(v649) {
						bs649 |= 2;
					} else {
						bs649 &= -3;
					}
					break;
				case 7:
					if(v649) {
						bs649 |= 1;
					} else {
						bs649 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs649;
			var this651 = 0;
			var bs650 = this651;
			var l650 = "  *  ".length;
			var _g1651 = 0;
			var _g751 = l650;
			while(_g1651 < _g751) {
				var i651 = _g1651++;
				var no650 = "  *  ".charCodeAt(i651);
				if(no650 == null) {
					break;
				}
				var v650;
				switch(no650) {
				case 32:
					v650 = false;
					break;
				case 42:
					v650 = true;
					break;
				case 48:
					v650 = false;
					break;
				case 49:
					v650 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i651)));
				}
				switch(i651 - (l650 - 8)) {
				case 0:
					if(v650) {
						bs650 |= 128;
					} else {
						bs650 &= -129;
					}
					break;
				case 1:
					if(v650) {
						bs650 |= 64;
					} else {
						bs650 &= -65;
					}
					break;
				case 2:
					if(v650) {
						bs650 |= 32;
					} else {
						bs650 &= -33;
					}
					break;
				case 3:
					if(v650) {
						bs650 |= 16;
					} else {
						bs650 &= -17;
					}
					break;
				case 4:
					if(v650) {
						bs650 |= 8;
					} else {
						bs650 &= -9;
					}
					break;
				case 5:
					if(v650) {
						bs650 |= 4;
					} else {
						bs650 &= -5;
					}
					break;
				case 6:
					if(v650) {
						bs650 |= 2;
					} else {
						bs650 &= -3;
					}
					break;
				case 7:
					if(v650) {
						bs650 |= 1;
					} else {
						bs650 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs650;
			break;
		case 125:
			var this652 = 0;
			var bs651 = this652;
			var l651 = "   * ".length;
			var _g1652 = 0;
			var _g752 = l651;
			while(_g1652 < _g752) {
				var i652 = _g1652++;
				var no651 = "   * ".charCodeAt(i652);
				if(no651 == null) {
					break;
				}
				var v651;
				switch(no651) {
				case 32:
					v651 = false;
					break;
				case 42:
					v651 = true;
					break;
				case 48:
					v651 = false;
					break;
				case 49:
					v651 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i652)));
				}
				switch(i652 - (l651 - 8)) {
				case 0:
					if(v651) {
						bs651 |= 128;
					} else {
						bs651 &= -129;
					}
					break;
				case 1:
					if(v651) {
						bs651 |= 64;
					} else {
						bs651 &= -65;
					}
					break;
				case 2:
					if(v651) {
						bs651 |= 32;
					} else {
						bs651 &= -33;
					}
					break;
				case 3:
					if(v651) {
						bs651 |= 16;
					} else {
						bs651 &= -17;
					}
					break;
				case 4:
					if(v651) {
						bs651 |= 8;
					} else {
						bs651 &= -9;
					}
					break;
				case 5:
					if(v651) {
						bs651 |= 4;
					} else {
						bs651 &= -5;
					}
					break;
				case 6:
					if(v651) {
						bs651 |= 2;
					} else {
						bs651 &= -3;
					}
					break;
				case 7:
					if(v651) {
						bs651 |= 1;
					} else {
						bs651 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs651;
			var this653 = 0;
			var bs652 = this653;
			var l652 = "  *  ".length;
			var _g1653 = 0;
			var _g753 = l652;
			while(_g1653 < _g753) {
				var i653 = _g1653++;
				var no652 = "  *  ".charCodeAt(i653);
				if(no652 == null) {
					break;
				}
				var v652;
				switch(no652) {
				case 32:
					v652 = false;
					break;
				case 42:
					v652 = true;
					break;
				case 48:
					v652 = false;
					break;
				case 49:
					v652 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i653)));
				}
				switch(i653 - (l652 - 8)) {
				case 0:
					if(v652) {
						bs652 |= 128;
					} else {
						bs652 &= -129;
					}
					break;
				case 1:
					if(v652) {
						bs652 |= 64;
					} else {
						bs652 &= -65;
					}
					break;
				case 2:
					if(v652) {
						bs652 |= 32;
					} else {
						bs652 &= -33;
					}
					break;
				case 3:
					if(v652) {
						bs652 |= 16;
					} else {
						bs652 &= -17;
					}
					break;
				case 4:
					if(v652) {
						bs652 |= 8;
					} else {
						bs652 &= -9;
					}
					break;
				case 5:
					if(v652) {
						bs652 |= 4;
					} else {
						bs652 &= -5;
					}
					break;
				case 6:
					if(v652) {
						bs652 |= 2;
					} else {
						bs652 &= -3;
					}
					break;
				case 7:
					if(v652) {
						bs652 |= 1;
					} else {
						bs652 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs652;
			var this654 = 0;
			var bs653 = this654;
			var l653 = "  *  ".length;
			var _g1654 = 0;
			var _g754 = l653;
			while(_g1654 < _g754) {
				var i654 = _g1654++;
				var no653 = "  *  ".charCodeAt(i654);
				if(no653 == null) {
					break;
				}
				var v653;
				switch(no653) {
				case 32:
					v653 = false;
					break;
				case 42:
					v653 = true;
					break;
				case 48:
					v653 = false;
					break;
				case 49:
					v653 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i654)));
				}
				switch(i654 - (l653 - 8)) {
				case 0:
					if(v653) {
						bs653 |= 128;
					} else {
						bs653 &= -129;
					}
					break;
				case 1:
					if(v653) {
						bs653 |= 64;
					} else {
						bs653 &= -65;
					}
					break;
				case 2:
					if(v653) {
						bs653 |= 32;
					} else {
						bs653 &= -33;
					}
					break;
				case 3:
					if(v653) {
						bs653 |= 16;
					} else {
						bs653 &= -17;
					}
					break;
				case 4:
					if(v653) {
						bs653 |= 8;
					} else {
						bs653 &= -9;
					}
					break;
				case 5:
					if(v653) {
						bs653 |= 4;
					} else {
						bs653 &= -5;
					}
					break;
				case 6:
					if(v653) {
						bs653 |= 2;
					} else {
						bs653 &= -3;
					}
					break;
				case 7:
					if(v653) {
						bs653 |= 1;
					} else {
						bs653 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs653;
			var this655 = 0;
			var bs654 = this655;
			var l654 = " *   ".length;
			var _g1655 = 0;
			var _g755 = l654;
			while(_g1655 < _g755) {
				var i655 = _g1655++;
				var no654 = " *   ".charCodeAt(i655);
				if(no654 == null) {
					break;
				}
				var v654;
				switch(no654) {
				case 32:
					v654 = false;
					break;
				case 42:
					v654 = true;
					break;
				case 48:
					v654 = false;
					break;
				case 49:
					v654 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i655)));
				}
				switch(i655 - (l654 - 8)) {
				case 0:
					if(v654) {
						bs654 |= 128;
					} else {
						bs654 &= -129;
					}
					break;
				case 1:
					if(v654) {
						bs654 |= 64;
					} else {
						bs654 &= -65;
					}
					break;
				case 2:
					if(v654) {
						bs654 |= 32;
					} else {
						bs654 &= -33;
					}
					break;
				case 3:
					if(v654) {
						bs654 |= 16;
					} else {
						bs654 &= -17;
					}
					break;
				case 4:
					if(v654) {
						bs654 |= 8;
					} else {
						bs654 &= -9;
					}
					break;
				case 5:
					if(v654) {
						bs654 |= 4;
					} else {
						bs654 &= -5;
					}
					break;
				case 6:
					if(v654) {
						bs654 |= 2;
					} else {
						bs654 &= -3;
					}
					break;
				case 7:
					if(v654) {
						bs654 |= 1;
					} else {
						bs654 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs654;
			var this656 = 0;
			var bs655 = this656;
			var l655 = "  *  ".length;
			var _g1656 = 0;
			var _g756 = l655;
			while(_g1656 < _g756) {
				var i656 = _g1656++;
				var no655 = "  *  ".charCodeAt(i656);
				if(no655 == null) {
					break;
				}
				var v655;
				switch(no655) {
				case 32:
					v655 = false;
					break;
				case 42:
					v655 = true;
					break;
				case 48:
					v655 = false;
					break;
				case 49:
					v655 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i656)));
				}
				switch(i656 - (l655 - 8)) {
				case 0:
					if(v655) {
						bs655 |= 128;
					} else {
						bs655 &= -129;
					}
					break;
				case 1:
					if(v655) {
						bs655 |= 64;
					} else {
						bs655 &= -65;
					}
					break;
				case 2:
					if(v655) {
						bs655 |= 32;
					} else {
						bs655 &= -33;
					}
					break;
				case 3:
					if(v655) {
						bs655 |= 16;
					} else {
						bs655 &= -17;
					}
					break;
				case 4:
					if(v655) {
						bs655 |= 8;
					} else {
						bs655 &= -9;
					}
					break;
				case 5:
					if(v655) {
						bs655 |= 4;
					} else {
						bs655 &= -5;
					}
					break;
				case 6:
					if(v655) {
						bs655 |= 2;
					} else {
						bs655 &= -3;
					}
					break;
				case 7:
					if(v655) {
						bs655 |= 1;
					} else {
						bs655 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs655;
			var this657 = 0;
			var bs656 = this657;
			var l656 = "  *  ".length;
			var _g1657 = 0;
			var _g757 = l656;
			while(_g1657 < _g757) {
				var i657 = _g1657++;
				var no656 = "  *  ".charCodeAt(i657);
				if(no656 == null) {
					break;
				}
				var v656;
				switch(no656) {
				case 32:
					v656 = false;
					break;
				case 42:
					v656 = true;
					break;
				case 48:
					v656 = false;
					break;
				case 49:
					v656 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i657)));
				}
				switch(i657 - (l656 - 8)) {
				case 0:
					if(v656) {
						bs656 |= 128;
					} else {
						bs656 &= -129;
					}
					break;
				case 1:
					if(v656) {
						bs656 |= 64;
					} else {
						bs656 &= -65;
					}
					break;
				case 2:
					if(v656) {
						bs656 |= 32;
					} else {
						bs656 &= -33;
					}
					break;
				case 3:
					if(v656) {
						bs656 |= 16;
					} else {
						bs656 &= -17;
					}
					break;
				case 4:
					if(v656) {
						bs656 |= 8;
					} else {
						bs656 &= -9;
					}
					break;
				case 5:
					if(v656) {
						bs656 |= 4;
					} else {
						bs656 &= -5;
					}
					break;
				case 6:
					if(v656) {
						bs656 |= 2;
					} else {
						bs656 &= -3;
					}
					break;
				case 7:
					if(v656) {
						bs656 |= 1;
					} else {
						bs656 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs656;
			var this658 = 0;
			var bs657 = this658;
			var l657 = "   * ".length;
			var _g1658 = 0;
			var _g758 = l657;
			while(_g1658 < _g758) {
				var i658 = _g1658++;
				var no657 = "   * ".charCodeAt(i658);
				if(no657 == null) {
					break;
				}
				var v657;
				switch(no657) {
				case 32:
					v657 = false;
					break;
				case 42:
					v657 = true;
					break;
				case 48:
					v657 = false;
					break;
				case 49:
					v657 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i658)));
				}
				switch(i658 - (l657 - 8)) {
				case 0:
					if(v657) {
						bs657 |= 128;
					} else {
						bs657 &= -129;
					}
					break;
				case 1:
					if(v657) {
						bs657 |= 64;
					} else {
						bs657 &= -65;
					}
					break;
				case 2:
					if(v657) {
						bs657 |= 32;
					} else {
						bs657 &= -33;
					}
					break;
				case 3:
					if(v657) {
						bs657 |= 16;
					} else {
						bs657 &= -17;
					}
					break;
				case 4:
					if(v657) {
						bs657 |= 8;
					} else {
						bs657 &= -9;
					}
					break;
				case 5:
					if(v657) {
						bs657 |= 4;
					} else {
						bs657 &= -5;
					}
					break;
				case 6:
					if(v657) {
						bs657 |= 2;
					} else {
						bs657 &= -3;
					}
					break;
				case 7:
					if(v657) {
						bs657 |= 1;
					} else {
						bs657 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs657;
			break;
		case 126:
			var this659 = 0;
			var bs658 = this659;
			var l658 = " ** *".length;
			var _g1659 = 0;
			var _g759 = l658;
			while(_g1659 < _g759) {
				var i659 = _g1659++;
				var no658 = " ** *".charCodeAt(i659);
				if(no658 == null) {
					break;
				}
				var v658;
				switch(no658) {
				case 32:
					v658 = false;
					break;
				case 42:
					v658 = true;
					break;
				case 48:
					v658 = false;
					break;
				case 49:
					v658 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i659)));
				}
				switch(i659 - (l658 - 8)) {
				case 0:
					if(v658) {
						bs658 |= 128;
					} else {
						bs658 &= -129;
					}
					break;
				case 1:
					if(v658) {
						bs658 |= 64;
					} else {
						bs658 &= -65;
					}
					break;
				case 2:
					if(v658) {
						bs658 |= 32;
					} else {
						bs658 &= -33;
					}
					break;
				case 3:
					if(v658) {
						bs658 |= 16;
					} else {
						bs658 &= -17;
					}
					break;
				case 4:
					if(v658) {
						bs658 |= 8;
					} else {
						bs658 &= -9;
					}
					break;
				case 5:
					if(v658) {
						bs658 |= 4;
					} else {
						bs658 &= -5;
					}
					break;
				case 6:
					if(v658) {
						bs658 |= 2;
					} else {
						bs658 &= -3;
					}
					break;
				case 7:
					if(v658) {
						bs658 |= 1;
					} else {
						bs658 &= -2;
					}
					break;
				default:
				}
			}
			arr1[0] = bs658;
			var this660 = 0;
			var bs659 = this660;
			var l659 = "*  * ".length;
			var _g1660 = 0;
			var _g760 = l659;
			while(_g1660 < _g760) {
				var i660 = _g1660++;
				var no659 = "*  * ".charCodeAt(i660);
				if(no659 == null) {
					break;
				}
				var v659;
				switch(no659) {
				case 32:
					v659 = false;
					break;
				case 42:
					v659 = true;
					break;
				case 48:
					v659 = false;
					break;
				case 49:
					v659 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i660)));
				}
				switch(i660 - (l659 - 8)) {
				case 0:
					if(v659) {
						bs659 |= 128;
					} else {
						bs659 &= -129;
					}
					break;
				case 1:
					if(v659) {
						bs659 |= 64;
					} else {
						bs659 &= -65;
					}
					break;
				case 2:
					if(v659) {
						bs659 |= 32;
					} else {
						bs659 &= -33;
					}
					break;
				case 3:
					if(v659) {
						bs659 |= 16;
					} else {
						bs659 &= -17;
					}
					break;
				case 4:
					if(v659) {
						bs659 |= 8;
					} else {
						bs659 &= -9;
					}
					break;
				case 5:
					if(v659) {
						bs659 |= 4;
					} else {
						bs659 &= -5;
					}
					break;
				case 6:
					if(v659) {
						bs659 |= 2;
					} else {
						bs659 &= -3;
					}
					break;
				case 7:
					if(v659) {
						bs659 |= 1;
					} else {
						bs659 &= -2;
					}
					break;
				default:
				}
			}
			arr1[1] = bs659;
			var this661 = 0;
			var bs660 = this661;
			var l660 = "     ".length;
			var _g1661 = 0;
			var _g761 = l660;
			while(_g1661 < _g761) {
				var i661 = _g1661++;
				var no660 = "     ".charCodeAt(i661);
				if(no660 == null) {
					break;
				}
				var v660;
				switch(no660) {
				case 32:
					v660 = false;
					break;
				case 42:
					v660 = true;
					break;
				case 48:
					v660 = false;
					break;
				case 49:
					v660 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i661)));
				}
				switch(i661 - (l660 - 8)) {
				case 0:
					if(v660) {
						bs660 |= 128;
					} else {
						bs660 &= -129;
					}
					break;
				case 1:
					if(v660) {
						bs660 |= 64;
					} else {
						bs660 &= -65;
					}
					break;
				case 2:
					if(v660) {
						bs660 |= 32;
					} else {
						bs660 &= -33;
					}
					break;
				case 3:
					if(v660) {
						bs660 |= 16;
					} else {
						bs660 &= -17;
					}
					break;
				case 4:
					if(v660) {
						bs660 |= 8;
					} else {
						bs660 &= -9;
					}
					break;
				case 5:
					if(v660) {
						bs660 |= 4;
					} else {
						bs660 &= -5;
					}
					break;
				case 6:
					if(v660) {
						bs660 |= 2;
					} else {
						bs660 &= -3;
					}
					break;
				case 7:
					if(v660) {
						bs660 |= 1;
					} else {
						bs660 &= -2;
					}
					break;
				default:
				}
			}
			arr1[2] = bs660;
			var this662 = 0;
			var bs661 = this662;
			var l661 = "     ".length;
			var _g1662 = 0;
			var _g762 = l661;
			while(_g1662 < _g762) {
				var i662 = _g1662++;
				var no661 = "     ".charCodeAt(i662);
				if(no661 == null) {
					break;
				}
				var v661;
				switch(no661) {
				case 32:
					v661 = false;
					break;
				case 42:
					v661 = true;
					break;
				case 48:
					v661 = false;
					break;
				case 49:
					v661 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i662)));
				}
				switch(i662 - (l661 - 8)) {
				case 0:
					if(v661) {
						bs661 |= 128;
					} else {
						bs661 &= -129;
					}
					break;
				case 1:
					if(v661) {
						bs661 |= 64;
					} else {
						bs661 &= -65;
					}
					break;
				case 2:
					if(v661) {
						bs661 |= 32;
					} else {
						bs661 &= -33;
					}
					break;
				case 3:
					if(v661) {
						bs661 |= 16;
					} else {
						bs661 &= -17;
					}
					break;
				case 4:
					if(v661) {
						bs661 |= 8;
					} else {
						bs661 &= -9;
					}
					break;
				case 5:
					if(v661) {
						bs661 |= 4;
					} else {
						bs661 &= -5;
					}
					break;
				case 6:
					if(v661) {
						bs661 |= 2;
					} else {
						bs661 &= -3;
					}
					break;
				case 7:
					if(v661) {
						bs661 |= 1;
					} else {
						bs661 &= -2;
					}
					break;
				default:
				}
			}
			arr1[3] = bs661;
			var this663 = 0;
			var bs662 = this663;
			var l662 = "     ".length;
			var _g1663 = 0;
			var _g763 = l662;
			while(_g1663 < _g763) {
				var i663 = _g1663++;
				var no662 = "     ".charCodeAt(i663);
				if(no662 == null) {
					break;
				}
				var v662;
				switch(no662) {
				case 32:
					v662 = false;
					break;
				case 42:
					v662 = true;
					break;
				case 48:
					v662 = false;
					break;
				case 49:
					v662 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i663)));
				}
				switch(i663 - (l662 - 8)) {
				case 0:
					if(v662) {
						bs662 |= 128;
					} else {
						bs662 &= -129;
					}
					break;
				case 1:
					if(v662) {
						bs662 |= 64;
					} else {
						bs662 &= -65;
					}
					break;
				case 2:
					if(v662) {
						bs662 |= 32;
					} else {
						bs662 &= -33;
					}
					break;
				case 3:
					if(v662) {
						bs662 |= 16;
					} else {
						bs662 &= -17;
					}
					break;
				case 4:
					if(v662) {
						bs662 |= 8;
					} else {
						bs662 &= -9;
					}
					break;
				case 5:
					if(v662) {
						bs662 |= 4;
					} else {
						bs662 &= -5;
					}
					break;
				case 6:
					if(v662) {
						bs662 |= 2;
					} else {
						bs662 &= -3;
					}
					break;
				case 7:
					if(v662) {
						bs662 |= 1;
					} else {
						bs662 &= -2;
					}
					break;
				default:
				}
			}
			arr1[4] = bs662;
			var this664 = 0;
			var bs663 = this664;
			var l663 = "     ".length;
			var _g1664 = 0;
			var _g764 = l663;
			while(_g1664 < _g764) {
				var i664 = _g1664++;
				var no663 = "     ".charCodeAt(i664);
				if(no663 == null) {
					break;
				}
				var v663;
				switch(no663) {
				case 32:
					v663 = false;
					break;
				case 42:
					v663 = true;
					break;
				case 48:
					v663 = false;
					break;
				case 49:
					v663 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i664)));
				}
				switch(i664 - (l663 - 8)) {
				case 0:
					if(v663) {
						bs663 |= 128;
					} else {
						bs663 &= -129;
					}
					break;
				case 1:
					if(v663) {
						bs663 |= 64;
					} else {
						bs663 &= -65;
					}
					break;
				case 2:
					if(v663) {
						bs663 |= 32;
					} else {
						bs663 &= -33;
					}
					break;
				case 3:
					if(v663) {
						bs663 |= 16;
					} else {
						bs663 &= -17;
					}
					break;
				case 4:
					if(v663) {
						bs663 |= 8;
					} else {
						bs663 &= -9;
					}
					break;
				case 5:
					if(v663) {
						bs663 |= 4;
					} else {
						bs663 &= -5;
					}
					break;
				case 6:
					if(v663) {
						bs663 |= 2;
					} else {
						bs663 &= -3;
					}
					break;
				case 7:
					if(v663) {
						bs663 |= 1;
					} else {
						bs663 &= -2;
					}
					break;
				default:
				}
			}
			arr1[5] = bs663;
			var this665 = 0;
			var bs664 = this665;
			var l664 = "     ".length;
			var _g1665 = 0;
			var _g765 = l664;
			while(_g1665 < _g765) {
				var i665 = _g1665++;
				var no664 = "     ".charCodeAt(i665);
				if(no664 == null) {
					break;
				}
				var v664;
				switch(no664) {
				case 32:
					v664 = false;
					break;
				case 42:
					v664 = true;
					break;
				case 48:
					v664 = false;
					break;
				case 49:
					v664 = true;
					break;
				default:
					throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i665)));
				}
				switch(i665 - (l664 - 8)) {
				case 0:
					if(v664) {
						bs664 |= 128;
					} else {
						bs664 &= -129;
					}
					break;
				case 1:
					if(v664) {
						bs664 |= 64;
					} else {
						bs664 &= -65;
					}
					break;
				case 2:
					if(v664) {
						bs664 |= 32;
					} else {
						bs664 &= -33;
					}
					break;
				case 3:
					if(v664) {
						bs664 |= 16;
					} else {
						bs664 &= -17;
					}
					break;
				case 4:
					if(v664) {
						bs664 |= 8;
					} else {
						bs664 &= -9;
					}
					break;
				case 5:
					if(v664) {
						bs664 |= 4;
					} else {
						bs664 &= -5;
					}
					break;
				case 6:
					if(v664) {
						bs664 |= 2;
					} else {
						bs664 &= -3;
					}
					break;
				case 7:
					if(v664) {
						bs664 |= 1;
					} else {
						bs664 &= -2;
					}
					break;
				default:
				}
			}
			arr1[6] = bs664;
			break;
		}
		arr[i] = trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$._new(arr1);
	}
	return arr;
};
trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$.five7_dotMatrix = function(charCode) {
	var arr = [];
	switch(charCode) {
	case 32:
		var this1 = 0;
		var bs = this1;
		var l = "00000".length;
		var _g1 = 0;
		var _g = l;
		while(_g1 < _g) {
			var i = _g1++;
			var no = "00000".charCodeAt(i);
			if(no == null) {
				break;
			}
			var v;
			switch(no) {
			case 32:
				v = false;
				break;
			case 42:
				v = true;
				break;
			case 48:
				v = false;
				break;
			case 49:
				v = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i)));
			}
			switch(i - (l - 8)) {
			case 0:
				if(v) {
					bs |= 128;
				} else {
					bs &= -129;
				}
				break;
			case 1:
				if(v) {
					bs |= 64;
				} else {
					bs &= -65;
				}
				break;
			case 2:
				if(v) {
					bs |= 32;
				} else {
					bs &= -33;
				}
				break;
			case 3:
				if(v) {
					bs |= 16;
				} else {
					bs &= -17;
				}
				break;
			case 4:
				if(v) {
					bs |= 8;
				} else {
					bs &= -9;
				}
				break;
			case 5:
				if(v) {
					bs |= 4;
				} else {
					bs &= -5;
				}
				break;
			case 6:
				if(v) {
					bs |= 2;
				} else {
					bs &= -3;
				}
				break;
			case 7:
				if(v) {
					bs |= 1;
				} else {
					bs &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs;
		var this2 = 0;
		var bs1 = this2;
		var l1 = "00000".length;
		var _g11 = 0;
		var _g2 = l1;
		while(_g11 < _g2) {
			var i1 = _g11++;
			var no1 = "00000".charCodeAt(i1);
			if(no1 == null) {
				break;
			}
			var v1;
			switch(no1) {
			case 32:
				v1 = false;
				break;
			case 42:
				v1 = true;
				break;
			case 48:
				v1 = false;
				break;
			case 49:
				v1 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i1)));
			}
			switch(i1 - (l1 - 8)) {
			case 0:
				if(v1) {
					bs1 |= 128;
				} else {
					bs1 &= -129;
				}
				break;
			case 1:
				if(v1) {
					bs1 |= 64;
				} else {
					bs1 &= -65;
				}
				break;
			case 2:
				if(v1) {
					bs1 |= 32;
				} else {
					bs1 &= -33;
				}
				break;
			case 3:
				if(v1) {
					bs1 |= 16;
				} else {
					bs1 &= -17;
				}
				break;
			case 4:
				if(v1) {
					bs1 |= 8;
				} else {
					bs1 &= -9;
				}
				break;
			case 5:
				if(v1) {
					bs1 |= 4;
				} else {
					bs1 &= -5;
				}
				break;
			case 6:
				if(v1) {
					bs1 |= 2;
				} else {
					bs1 &= -3;
				}
				break;
			case 7:
				if(v1) {
					bs1 |= 1;
				} else {
					bs1 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs1;
		var this3 = 0;
		var bs2 = this3;
		var l2 = "00000".length;
		var _g12 = 0;
		var _g3 = l2;
		while(_g12 < _g3) {
			var i2 = _g12++;
			var no2 = "00000".charCodeAt(i2);
			if(no2 == null) {
				break;
			}
			var v2;
			switch(no2) {
			case 32:
				v2 = false;
				break;
			case 42:
				v2 = true;
				break;
			case 48:
				v2 = false;
				break;
			case 49:
				v2 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i2)));
			}
			switch(i2 - (l2 - 8)) {
			case 0:
				if(v2) {
					bs2 |= 128;
				} else {
					bs2 &= -129;
				}
				break;
			case 1:
				if(v2) {
					bs2 |= 64;
				} else {
					bs2 &= -65;
				}
				break;
			case 2:
				if(v2) {
					bs2 |= 32;
				} else {
					bs2 &= -33;
				}
				break;
			case 3:
				if(v2) {
					bs2 |= 16;
				} else {
					bs2 &= -17;
				}
				break;
			case 4:
				if(v2) {
					bs2 |= 8;
				} else {
					bs2 &= -9;
				}
				break;
			case 5:
				if(v2) {
					bs2 |= 4;
				} else {
					bs2 &= -5;
				}
				break;
			case 6:
				if(v2) {
					bs2 |= 2;
				} else {
					bs2 &= -3;
				}
				break;
			case 7:
				if(v2) {
					bs2 |= 1;
				} else {
					bs2 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs2;
		var this4 = 0;
		var bs3 = this4;
		var l3 = "00000".length;
		var _g13 = 0;
		var _g4 = l3;
		while(_g13 < _g4) {
			var i3 = _g13++;
			var no3 = "00000".charCodeAt(i3);
			if(no3 == null) {
				break;
			}
			var v3;
			switch(no3) {
			case 32:
				v3 = false;
				break;
			case 42:
				v3 = true;
				break;
			case 48:
				v3 = false;
				break;
			case 49:
				v3 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i3)));
			}
			switch(i3 - (l3 - 8)) {
			case 0:
				if(v3) {
					bs3 |= 128;
				} else {
					bs3 &= -129;
				}
				break;
			case 1:
				if(v3) {
					bs3 |= 64;
				} else {
					bs3 &= -65;
				}
				break;
			case 2:
				if(v3) {
					bs3 |= 32;
				} else {
					bs3 &= -33;
				}
				break;
			case 3:
				if(v3) {
					bs3 |= 16;
				} else {
					bs3 &= -17;
				}
				break;
			case 4:
				if(v3) {
					bs3 |= 8;
				} else {
					bs3 &= -9;
				}
				break;
			case 5:
				if(v3) {
					bs3 |= 4;
				} else {
					bs3 &= -5;
				}
				break;
			case 6:
				if(v3) {
					bs3 |= 2;
				} else {
					bs3 &= -3;
				}
				break;
			case 7:
				if(v3) {
					bs3 |= 1;
				} else {
					bs3 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs3;
		var this5 = 0;
		var bs4 = this5;
		var l4 = "00000".length;
		var _g14 = 0;
		var _g5 = l4;
		while(_g14 < _g5) {
			var i4 = _g14++;
			var no4 = "00000".charCodeAt(i4);
			if(no4 == null) {
				break;
			}
			var v4;
			switch(no4) {
			case 32:
				v4 = false;
				break;
			case 42:
				v4 = true;
				break;
			case 48:
				v4 = false;
				break;
			case 49:
				v4 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i4)));
			}
			switch(i4 - (l4 - 8)) {
			case 0:
				if(v4) {
					bs4 |= 128;
				} else {
					bs4 &= -129;
				}
				break;
			case 1:
				if(v4) {
					bs4 |= 64;
				} else {
					bs4 &= -65;
				}
				break;
			case 2:
				if(v4) {
					bs4 |= 32;
				} else {
					bs4 &= -33;
				}
				break;
			case 3:
				if(v4) {
					bs4 |= 16;
				} else {
					bs4 &= -17;
				}
				break;
			case 4:
				if(v4) {
					bs4 |= 8;
				} else {
					bs4 &= -9;
				}
				break;
			case 5:
				if(v4) {
					bs4 |= 4;
				} else {
					bs4 &= -5;
				}
				break;
			case 6:
				if(v4) {
					bs4 |= 2;
				} else {
					bs4 &= -3;
				}
				break;
			case 7:
				if(v4) {
					bs4 |= 1;
				} else {
					bs4 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs4;
		var this6 = 0;
		var bs5 = this6;
		var l5 = "00000".length;
		var _g15 = 0;
		var _g6 = l5;
		while(_g15 < _g6) {
			var i5 = _g15++;
			var no5 = "00000".charCodeAt(i5);
			if(no5 == null) {
				break;
			}
			var v5;
			switch(no5) {
			case 32:
				v5 = false;
				break;
			case 42:
				v5 = true;
				break;
			case 48:
				v5 = false;
				break;
			case 49:
				v5 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i5)));
			}
			switch(i5 - (l5 - 8)) {
			case 0:
				if(v5) {
					bs5 |= 128;
				} else {
					bs5 &= -129;
				}
				break;
			case 1:
				if(v5) {
					bs5 |= 64;
				} else {
					bs5 &= -65;
				}
				break;
			case 2:
				if(v5) {
					bs5 |= 32;
				} else {
					bs5 &= -33;
				}
				break;
			case 3:
				if(v5) {
					bs5 |= 16;
				} else {
					bs5 &= -17;
				}
				break;
			case 4:
				if(v5) {
					bs5 |= 8;
				} else {
					bs5 &= -9;
				}
				break;
			case 5:
				if(v5) {
					bs5 |= 4;
				} else {
					bs5 &= -5;
				}
				break;
			case 6:
				if(v5) {
					bs5 |= 2;
				} else {
					bs5 &= -3;
				}
				break;
			case 7:
				if(v5) {
					bs5 |= 1;
				} else {
					bs5 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs5;
		var this7 = 0;
		var bs6 = this7;
		var l6 = "00000".length;
		var _g16 = 0;
		var _g7 = l6;
		while(_g16 < _g7) {
			var i6 = _g16++;
			var no6 = "00000".charCodeAt(i6);
			if(no6 == null) {
				break;
			}
			var v6;
			switch(no6) {
			case 32:
				v6 = false;
				break;
			case 42:
				v6 = true;
				break;
			case 48:
				v6 = false;
				break;
			case 49:
				v6 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("00000".charCodeAt(i6)));
			}
			switch(i6 - (l6 - 8)) {
			case 0:
				if(v6) {
					bs6 |= 128;
				} else {
					bs6 &= -129;
				}
				break;
			case 1:
				if(v6) {
					bs6 |= 64;
				} else {
					bs6 &= -65;
				}
				break;
			case 2:
				if(v6) {
					bs6 |= 32;
				} else {
					bs6 &= -33;
				}
				break;
			case 3:
				if(v6) {
					bs6 |= 16;
				} else {
					bs6 &= -17;
				}
				break;
			case 4:
				if(v6) {
					bs6 |= 8;
				} else {
					bs6 &= -9;
				}
				break;
			case 5:
				if(v6) {
					bs6 |= 4;
				} else {
					bs6 &= -5;
				}
				break;
			case 6:
				if(v6) {
					bs6 |= 2;
				} else {
					bs6 &= -3;
				}
				break;
			case 7:
				if(v6) {
					bs6 |= 1;
				} else {
					bs6 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs6;
		break;
	case 33:
		var this8 = 0;
		var bs7 = this8;
		var l7 = "  *  ".length;
		var _g17 = 0;
		var _g8 = l7;
		while(_g17 < _g8) {
			var i7 = _g17++;
			var no7 = "  *  ".charCodeAt(i7);
			if(no7 == null) {
				break;
			}
			var v7;
			switch(no7) {
			case 32:
				v7 = false;
				break;
			case 42:
				v7 = true;
				break;
			case 48:
				v7 = false;
				break;
			case 49:
				v7 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i7)));
			}
			switch(i7 - (l7 - 8)) {
			case 0:
				if(v7) {
					bs7 |= 128;
				} else {
					bs7 &= -129;
				}
				break;
			case 1:
				if(v7) {
					bs7 |= 64;
				} else {
					bs7 &= -65;
				}
				break;
			case 2:
				if(v7) {
					bs7 |= 32;
				} else {
					bs7 &= -33;
				}
				break;
			case 3:
				if(v7) {
					bs7 |= 16;
				} else {
					bs7 &= -17;
				}
				break;
			case 4:
				if(v7) {
					bs7 |= 8;
				} else {
					bs7 &= -9;
				}
				break;
			case 5:
				if(v7) {
					bs7 |= 4;
				} else {
					bs7 &= -5;
				}
				break;
			case 6:
				if(v7) {
					bs7 |= 2;
				} else {
					bs7 &= -3;
				}
				break;
			case 7:
				if(v7) {
					bs7 |= 1;
				} else {
					bs7 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs7;
		var this9 = 0;
		var bs8 = this9;
		var l8 = "  *  ".length;
		var _g18 = 0;
		var _g9 = l8;
		while(_g18 < _g9) {
			var i8 = _g18++;
			var no8 = "  *  ".charCodeAt(i8);
			if(no8 == null) {
				break;
			}
			var v8;
			switch(no8) {
			case 32:
				v8 = false;
				break;
			case 42:
				v8 = true;
				break;
			case 48:
				v8 = false;
				break;
			case 49:
				v8 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i8)));
			}
			switch(i8 - (l8 - 8)) {
			case 0:
				if(v8) {
					bs8 |= 128;
				} else {
					bs8 &= -129;
				}
				break;
			case 1:
				if(v8) {
					bs8 |= 64;
				} else {
					bs8 &= -65;
				}
				break;
			case 2:
				if(v8) {
					bs8 |= 32;
				} else {
					bs8 &= -33;
				}
				break;
			case 3:
				if(v8) {
					bs8 |= 16;
				} else {
					bs8 &= -17;
				}
				break;
			case 4:
				if(v8) {
					bs8 |= 8;
				} else {
					bs8 &= -9;
				}
				break;
			case 5:
				if(v8) {
					bs8 |= 4;
				} else {
					bs8 &= -5;
				}
				break;
			case 6:
				if(v8) {
					bs8 |= 2;
				} else {
					bs8 &= -3;
				}
				break;
			case 7:
				if(v8) {
					bs8 |= 1;
				} else {
					bs8 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs8;
		var this10 = 0;
		var bs9 = this10;
		var l9 = "  *  ".length;
		var _g19 = 0;
		var _g10 = l9;
		while(_g19 < _g10) {
			var i9 = _g19++;
			var no9 = "  *  ".charCodeAt(i9);
			if(no9 == null) {
				break;
			}
			var v9;
			switch(no9) {
			case 32:
				v9 = false;
				break;
			case 42:
				v9 = true;
				break;
			case 48:
				v9 = false;
				break;
			case 49:
				v9 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i9)));
			}
			switch(i9 - (l9 - 8)) {
			case 0:
				if(v9) {
					bs9 |= 128;
				} else {
					bs9 &= -129;
				}
				break;
			case 1:
				if(v9) {
					bs9 |= 64;
				} else {
					bs9 &= -65;
				}
				break;
			case 2:
				if(v9) {
					bs9 |= 32;
				} else {
					bs9 &= -33;
				}
				break;
			case 3:
				if(v9) {
					bs9 |= 16;
				} else {
					bs9 &= -17;
				}
				break;
			case 4:
				if(v9) {
					bs9 |= 8;
				} else {
					bs9 &= -9;
				}
				break;
			case 5:
				if(v9) {
					bs9 |= 4;
				} else {
					bs9 &= -5;
				}
				break;
			case 6:
				if(v9) {
					bs9 |= 2;
				} else {
					bs9 &= -3;
				}
				break;
			case 7:
				if(v9) {
					bs9 |= 1;
				} else {
					bs9 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs9;
		var this11 = 0;
		var bs10 = this11;
		var l10 = "  *  ".length;
		var _g110 = 0;
		var _g20 = l10;
		while(_g110 < _g20) {
			var i10 = _g110++;
			var no10 = "  *  ".charCodeAt(i10);
			if(no10 == null) {
				break;
			}
			var v10;
			switch(no10) {
			case 32:
				v10 = false;
				break;
			case 42:
				v10 = true;
				break;
			case 48:
				v10 = false;
				break;
			case 49:
				v10 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i10)));
			}
			switch(i10 - (l10 - 8)) {
			case 0:
				if(v10) {
					bs10 |= 128;
				} else {
					bs10 &= -129;
				}
				break;
			case 1:
				if(v10) {
					bs10 |= 64;
				} else {
					bs10 &= -65;
				}
				break;
			case 2:
				if(v10) {
					bs10 |= 32;
				} else {
					bs10 &= -33;
				}
				break;
			case 3:
				if(v10) {
					bs10 |= 16;
				} else {
					bs10 &= -17;
				}
				break;
			case 4:
				if(v10) {
					bs10 |= 8;
				} else {
					bs10 &= -9;
				}
				break;
			case 5:
				if(v10) {
					bs10 |= 4;
				} else {
					bs10 &= -5;
				}
				break;
			case 6:
				if(v10) {
					bs10 |= 2;
				} else {
					bs10 &= -3;
				}
				break;
			case 7:
				if(v10) {
					bs10 |= 1;
				} else {
					bs10 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs10;
		var this12 = 0;
		var bs11 = this12;
		var l11 = "     ".length;
		var _g111 = 0;
		var _g21 = l11;
		while(_g111 < _g21) {
			var i11 = _g111++;
			var no11 = "     ".charCodeAt(i11);
			if(no11 == null) {
				break;
			}
			var v11;
			switch(no11) {
			case 32:
				v11 = false;
				break;
			case 42:
				v11 = true;
				break;
			case 48:
				v11 = false;
				break;
			case 49:
				v11 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i11)));
			}
			switch(i11 - (l11 - 8)) {
			case 0:
				if(v11) {
					bs11 |= 128;
				} else {
					bs11 &= -129;
				}
				break;
			case 1:
				if(v11) {
					bs11 |= 64;
				} else {
					bs11 &= -65;
				}
				break;
			case 2:
				if(v11) {
					bs11 |= 32;
				} else {
					bs11 &= -33;
				}
				break;
			case 3:
				if(v11) {
					bs11 |= 16;
				} else {
					bs11 &= -17;
				}
				break;
			case 4:
				if(v11) {
					bs11 |= 8;
				} else {
					bs11 &= -9;
				}
				break;
			case 5:
				if(v11) {
					bs11 |= 4;
				} else {
					bs11 &= -5;
				}
				break;
			case 6:
				if(v11) {
					bs11 |= 2;
				} else {
					bs11 &= -3;
				}
				break;
			case 7:
				if(v11) {
					bs11 |= 1;
				} else {
					bs11 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs11;
		var this13 = 0;
		var bs12 = this13;
		var l12 = "  *  ".length;
		var _g112 = 0;
		var _g22 = l12;
		while(_g112 < _g22) {
			var i12 = _g112++;
			var no12 = "  *  ".charCodeAt(i12);
			if(no12 == null) {
				break;
			}
			var v12;
			switch(no12) {
			case 32:
				v12 = false;
				break;
			case 42:
				v12 = true;
				break;
			case 48:
				v12 = false;
				break;
			case 49:
				v12 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i12)));
			}
			switch(i12 - (l12 - 8)) {
			case 0:
				if(v12) {
					bs12 |= 128;
				} else {
					bs12 &= -129;
				}
				break;
			case 1:
				if(v12) {
					bs12 |= 64;
				} else {
					bs12 &= -65;
				}
				break;
			case 2:
				if(v12) {
					bs12 |= 32;
				} else {
					bs12 &= -33;
				}
				break;
			case 3:
				if(v12) {
					bs12 |= 16;
				} else {
					bs12 &= -17;
				}
				break;
			case 4:
				if(v12) {
					bs12 |= 8;
				} else {
					bs12 &= -9;
				}
				break;
			case 5:
				if(v12) {
					bs12 |= 4;
				} else {
					bs12 &= -5;
				}
				break;
			case 6:
				if(v12) {
					bs12 |= 2;
				} else {
					bs12 &= -3;
				}
				break;
			case 7:
				if(v12) {
					bs12 |= 1;
				} else {
					bs12 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs12;
		var this14 = 0;
		var bs13 = this14;
		var l13 = "     ".length;
		var _g113 = 0;
		var _g23 = l13;
		while(_g113 < _g23) {
			var i13 = _g113++;
			var no13 = "     ".charCodeAt(i13);
			if(no13 == null) {
				break;
			}
			var v13;
			switch(no13) {
			case 32:
				v13 = false;
				break;
			case 42:
				v13 = true;
				break;
			case 48:
				v13 = false;
				break;
			case 49:
				v13 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i13)));
			}
			switch(i13 - (l13 - 8)) {
			case 0:
				if(v13) {
					bs13 |= 128;
				} else {
					bs13 &= -129;
				}
				break;
			case 1:
				if(v13) {
					bs13 |= 64;
				} else {
					bs13 &= -65;
				}
				break;
			case 2:
				if(v13) {
					bs13 |= 32;
				} else {
					bs13 &= -33;
				}
				break;
			case 3:
				if(v13) {
					bs13 |= 16;
				} else {
					bs13 &= -17;
				}
				break;
			case 4:
				if(v13) {
					bs13 |= 8;
				} else {
					bs13 &= -9;
				}
				break;
			case 5:
				if(v13) {
					bs13 |= 4;
				} else {
					bs13 &= -5;
				}
				break;
			case 6:
				if(v13) {
					bs13 |= 2;
				} else {
					bs13 &= -3;
				}
				break;
			case 7:
				if(v13) {
					bs13 |= 1;
				} else {
					bs13 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs13;
		break;
	case 34:
		var this15 = 0;
		var bs14 = this15;
		var l14 = "     ".length;
		var _g114 = 0;
		var _g24 = l14;
		while(_g114 < _g24) {
			var i14 = _g114++;
			var no14 = "     ".charCodeAt(i14);
			if(no14 == null) {
				break;
			}
			var v14;
			switch(no14) {
			case 32:
				v14 = false;
				break;
			case 42:
				v14 = true;
				break;
			case 48:
				v14 = false;
				break;
			case 49:
				v14 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i14)));
			}
			switch(i14 - (l14 - 8)) {
			case 0:
				if(v14) {
					bs14 |= 128;
				} else {
					bs14 &= -129;
				}
				break;
			case 1:
				if(v14) {
					bs14 |= 64;
				} else {
					bs14 &= -65;
				}
				break;
			case 2:
				if(v14) {
					bs14 |= 32;
				} else {
					bs14 &= -33;
				}
				break;
			case 3:
				if(v14) {
					bs14 |= 16;
				} else {
					bs14 &= -17;
				}
				break;
			case 4:
				if(v14) {
					bs14 |= 8;
				} else {
					bs14 &= -9;
				}
				break;
			case 5:
				if(v14) {
					bs14 |= 4;
				} else {
					bs14 &= -5;
				}
				break;
			case 6:
				if(v14) {
					bs14 |= 2;
				} else {
					bs14 &= -3;
				}
				break;
			case 7:
				if(v14) {
					bs14 |= 1;
				} else {
					bs14 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs14;
		var this16 = 0;
		var bs15 = this16;
		var l15 = " * * ".length;
		var _g115 = 0;
		var _g25 = l15;
		while(_g115 < _g25) {
			var i15 = _g115++;
			var no15 = " * * ".charCodeAt(i15);
			if(no15 == null) {
				break;
			}
			var v15;
			switch(no15) {
			case 32:
				v15 = false;
				break;
			case 42:
				v15 = true;
				break;
			case 48:
				v15 = false;
				break;
			case 49:
				v15 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i15)));
			}
			switch(i15 - (l15 - 8)) {
			case 0:
				if(v15) {
					bs15 |= 128;
				} else {
					bs15 &= -129;
				}
				break;
			case 1:
				if(v15) {
					bs15 |= 64;
				} else {
					bs15 &= -65;
				}
				break;
			case 2:
				if(v15) {
					bs15 |= 32;
				} else {
					bs15 &= -33;
				}
				break;
			case 3:
				if(v15) {
					bs15 |= 16;
				} else {
					bs15 &= -17;
				}
				break;
			case 4:
				if(v15) {
					bs15 |= 8;
				} else {
					bs15 &= -9;
				}
				break;
			case 5:
				if(v15) {
					bs15 |= 4;
				} else {
					bs15 &= -5;
				}
				break;
			case 6:
				if(v15) {
					bs15 |= 2;
				} else {
					bs15 &= -3;
				}
				break;
			case 7:
				if(v15) {
					bs15 |= 1;
				} else {
					bs15 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs15;
		var this17 = 0;
		var bs16 = this17;
		var l16 = " * * ".length;
		var _g116 = 0;
		var _g26 = l16;
		while(_g116 < _g26) {
			var i16 = _g116++;
			var no16 = " * * ".charCodeAt(i16);
			if(no16 == null) {
				break;
			}
			var v16;
			switch(no16) {
			case 32:
				v16 = false;
				break;
			case 42:
				v16 = true;
				break;
			case 48:
				v16 = false;
				break;
			case 49:
				v16 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i16)));
			}
			switch(i16 - (l16 - 8)) {
			case 0:
				if(v16) {
					bs16 |= 128;
				} else {
					bs16 &= -129;
				}
				break;
			case 1:
				if(v16) {
					bs16 |= 64;
				} else {
					bs16 &= -65;
				}
				break;
			case 2:
				if(v16) {
					bs16 |= 32;
				} else {
					bs16 &= -33;
				}
				break;
			case 3:
				if(v16) {
					bs16 |= 16;
				} else {
					bs16 &= -17;
				}
				break;
			case 4:
				if(v16) {
					bs16 |= 8;
				} else {
					bs16 &= -9;
				}
				break;
			case 5:
				if(v16) {
					bs16 |= 4;
				} else {
					bs16 &= -5;
				}
				break;
			case 6:
				if(v16) {
					bs16 |= 2;
				} else {
					bs16 &= -3;
				}
				break;
			case 7:
				if(v16) {
					bs16 |= 1;
				} else {
					bs16 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs16;
		var this18 = 0;
		var bs17 = this18;
		var l17 = " * * ".length;
		var _g117 = 0;
		var _g27 = l17;
		while(_g117 < _g27) {
			var i17 = _g117++;
			var no17 = " * * ".charCodeAt(i17);
			if(no17 == null) {
				break;
			}
			var v17;
			switch(no17) {
			case 32:
				v17 = false;
				break;
			case 42:
				v17 = true;
				break;
			case 48:
				v17 = false;
				break;
			case 49:
				v17 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i17)));
			}
			switch(i17 - (l17 - 8)) {
			case 0:
				if(v17) {
					bs17 |= 128;
				} else {
					bs17 &= -129;
				}
				break;
			case 1:
				if(v17) {
					bs17 |= 64;
				} else {
					bs17 &= -65;
				}
				break;
			case 2:
				if(v17) {
					bs17 |= 32;
				} else {
					bs17 &= -33;
				}
				break;
			case 3:
				if(v17) {
					bs17 |= 16;
				} else {
					bs17 &= -17;
				}
				break;
			case 4:
				if(v17) {
					bs17 |= 8;
				} else {
					bs17 &= -9;
				}
				break;
			case 5:
				if(v17) {
					bs17 |= 4;
				} else {
					bs17 &= -5;
				}
				break;
			case 6:
				if(v17) {
					bs17 |= 2;
				} else {
					bs17 &= -3;
				}
				break;
			case 7:
				if(v17) {
					bs17 |= 1;
				} else {
					bs17 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs17;
		var this19 = 0;
		var bs18 = this19;
		var l18 = "     ".length;
		var _g118 = 0;
		var _g28 = l18;
		while(_g118 < _g28) {
			var i18 = _g118++;
			var no18 = "     ".charCodeAt(i18);
			if(no18 == null) {
				break;
			}
			var v18;
			switch(no18) {
			case 32:
				v18 = false;
				break;
			case 42:
				v18 = true;
				break;
			case 48:
				v18 = false;
				break;
			case 49:
				v18 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i18)));
			}
			switch(i18 - (l18 - 8)) {
			case 0:
				if(v18) {
					bs18 |= 128;
				} else {
					bs18 &= -129;
				}
				break;
			case 1:
				if(v18) {
					bs18 |= 64;
				} else {
					bs18 &= -65;
				}
				break;
			case 2:
				if(v18) {
					bs18 |= 32;
				} else {
					bs18 &= -33;
				}
				break;
			case 3:
				if(v18) {
					bs18 |= 16;
				} else {
					bs18 &= -17;
				}
				break;
			case 4:
				if(v18) {
					bs18 |= 8;
				} else {
					bs18 &= -9;
				}
				break;
			case 5:
				if(v18) {
					bs18 |= 4;
				} else {
					bs18 &= -5;
				}
				break;
			case 6:
				if(v18) {
					bs18 |= 2;
				} else {
					bs18 &= -3;
				}
				break;
			case 7:
				if(v18) {
					bs18 |= 1;
				} else {
					bs18 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs18;
		var this20 = 0;
		var bs19 = this20;
		var l19 = "     ".length;
		var _g119 = 0;
		var _g29 = l19;
		while(_g119 < _g29) {
			var i19 = _g119++;
			var no19 = "     ".charCodeAt(i19);
			if(no19 == null) {
				break;
			}
			var v19;
			switch(no19) {
			case 32:
				v19 = false;
				break;
			case 42:
				v19 = true;
				break;
			case 48:
				v19 = false;
				break;
			case 49:
				v19 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i19)));
			}
			switch(i19 - (l19 - 8)) {
			case 0:
				if(v19) {
					bs19 |= 128;
				} else {
					bs19 &= -129;
				}
				break;
			case 1:
				if(v19) {
					bs19 |= 64;
				} else {
					bs19 &= -65;
				}
				break;
			case 2:
				if(v19) {
					bs19 |= 32;
				} else {
					bs19 &= -33;
				}
				break;
			case 3:
				if(v19) {
					bs19 |= 16;
				} else {
					bs19 &= -17;
				}
				break;
			case 4:
				if(v19) {
					bs19 |= 8;
				} else {
					bs19 &= -9;
				}
				break;
			case 5:
				if(v19) {
					bs19 |= 4;
				} else {
					bs19 &= -5;
				}
				break;
			case 6:
				if(v19) {
					bs19 |= 2;
				} else {
					bs19 &= -3;
				}
				break;
			case 7:
				if(v19) {
					bs19 |= 1;
				} else {
					bs19 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs19;
		var this21 = 0;
		var bs20 = this21;
		var l20 = "     ".length;
		var _g120 = 0;
		var _g30 = l20;
		while(_g120 < _g30) {
			var i20 = _g120++;
			var no20 = "     ".charCodeAt(i20);
			if(no20 == null) {
				break;
			}
			var v20;
			switch(no20) {
			case 32:
				v20 = false;
				break;
			case 42:
				v20 = true;
				break;
			case 48:
				v20 = false;
				break;
			case 49:
				v20 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i20)));
			}
			switch(i20 - (l20 - 8)) {
			case 0:
				if(v20) {
					bs20 |= 128;
				} else {
					bs20 &= -129;
				}
				break;
			case 1:
				if(v20) {
					bs20 |= 64;
				} else {
					bs20 &= -65;
				}
				break;
			case 2:
				if(v20) {
					bs20 |= 32;
				} else {
					bs20 &= -33;
				}
				break;
			case 3:
				if(v20) {
					bs20 |= 16;
				} else {
					bs20 &= -17;
				}
				break;
			case 4:
				if(v20) {
					bs20 |= 8;
				} else {
					bs20 &= -9;
				}
				break;
			case 5:
				if(v20) {
					bs20 |= 4;
				} else {
					bs20 &= -5;
				}
				break;
			case 6:
				if(v20) {
					bs20 |= 2;
				} else {
					bs20 &= -3;
				}
				break;
			case 7:
				if(v20) {
					bs20 |= 1;
				} else {
					bs20 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs20;
		break;
	case 35:
		var this22 = 0;
		var bs21 = this22;
		var l21 = " * * ".length;
		var _g121 = 0;
		var _g31 = l21;
		while(_g121 < _g31) {
			var i21 = _g121++;
			var no21 = " * * ".charCodeAt(i21);
			if(no21 == null) {
				break;
			}
			var v21;
			switch(no21) {
			case 32:
				v21 = false;
				break;
			case 42:
				v21 = true;
				break;
			case 48:
				v21 = false;
				break;
			case 49:
				v21 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i21)));
			}
			switch(i21 - (l21 - 8)) {
			case 0:
				if(v21) {
					bs21 |= 128;
				} else {
					bs21 &= -129;
				}
				break;
			case 1:
				if(v21) {
					bs21 |= 64;
				} else {
					bs21 &= -65;
				}
				break;
			case 2:
				if(v21) {
					bs21 |= 32;
				} else {
					bs21 &= -33;
				}
				break;
			case 3:
				if(v21) {
					bs21 |= 16;
				} else {
					bs21 &= -17;
				}
				break;
			case 4:
				if(v21) {
					bs21 |= 8;
				} else {
					bs21 &= -9;
				}
				break;
			case 5:
				if(v21) {
					bs21 |= 4;
				} else {
					bs21 &= -5;
				}
				break;
			case 6:
				if(v21) {
					bs21 |= 2;
				} else {
					bs21 &= -3;
				}
				break;
			case 7:
				if(v21) {
					bs21 |= 1;
				} else {
					bs21 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs21;
		var this23 = 0;
		var bs22 = this23;
		var l22 = " * * ".length;
		var _g122 = 0;
		var _g32 = l22;
		while(_g122 < _g32) {
			var i22 = _g122++;
			var no22 = " * * ".charCodeAt(i22);
			if(no22 == null) {
				break;
			}
			var v22;
			switch(no22) {
			case 32:
				v22 = false;
				break;
			case 42:
				v22 = true;
				break;
			case 48:
				v22 = false;
				break;
			case 49:
				v22 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i22)));
			}
			switch(i22 - (l22 - 8)) {
			case 0:
				if(v22) {
					bs22 |= 128;
				} else {
					bs22 &= -129;
				}
				break;
			case 1:
				if(v22) {
					bs22 |= 64;
				} else {
					bs22 &= -65;
				}
				break;
			case 2:
				if(v22) {
					bs22 |= 32;
				} else {
					bs22 &= -33;
				}
				break;
			case 3:
				if(v22) {
					bs22 |= 16;
				} else {
					bs22 &= -17;
				}
				break;
			case 4:
				if(v22) {
					bs22 |= 8;
				} else {
					bs22 &= -9;
				}
				break;
			case 5:
				if(v22) {
					bs22 |= 4;
				} else {
					bs22 &= -5;
				}
				break;
			case 6:
				if(v22) {
					bs22 |= 2;
				} else {
					bs22 &= -3;
				}
				break;
			case 7:
				if(v22) {
					bs22 |= 1;
				} else {
					bs22 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs22;
		var this24 = 0;
		var bs23 = this24;
		var l23 = "*****".length;
		var _g123 = 0;
		var _g33 = l23;
		while(_g123 < _g33) {
			var i23 = _g123++;
			var no23 = "*****".charCodeAt(i23);
			if(no23 == null) {
				break;
			}
			var v23;
			switch(no23) {
			case 32:
				v23 = false;
				break;
			case 42:
				v23 = true;
				break;
			case 48:
				v23 = false;
				break;
			case 49:
				v23 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i23)));
			}
			switch(i23 - (l23 - 8)) {
			case 0:
				if(v23) {
					bs23 |= 128;
				} else {
					bs23 &= -129;
				}
				break;
			case 1:
				if(v23) {
					bs23 |= 64;
				} else {
					bs23 &= -65;
				}
				break;
			case 2:
				if(v23) {
					bs23 |= 32;
				} else {
					bs23 &= -33;
				}
				break;
			case 3:
				if(v23) {
					bs23 |= 16;
				} else {
					bs23 &= -17;
				}
				break;
			case 4:
				if(v23) {
					bs23 |= 8;
				} else {
					bs23 &= -9;
				}
				break;
			case 5:
				if(v23) {
					bs23 |= 4;
				} else {
					bs23 &= -5;
				}
				break;
			case 6:
				if(v23) {
					bs23 |= 2;
				} else {
					bs23 &= -3;
				}
				break;
			case 7:
				if(v23) {
					bs23 |= 1;
				} else {
					bs23 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs23;
		var this25 = 0;
		var bs24 = this25;
		var l24 = " * * ".length;
		var _g124 = 0;
		var _g34 = l24;
		while(_g124 < _g34) {
			var i24 = _g124++;
			var no24 = " * * ".charCodeAt(i24);
			if(no24 == null) {
				break;
			}
			var v24;
			switch(no24) {
			case 32:
				v24 = false;
				break;
			case 42:
				v24 = true;
				break;
			case 48:
				v24 = false;
				break;
			case 49:
				v24 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i24)));
			}
			switch(i24 - (l24 - 8)) {
			case 0:
				if(v24) {
					bs24 |= 128;
				} else {
					bs24 &= -129;
				}
				break;
			case 1:
				if(v24) {
					bs24 |= 64;
				} else {
					bs24 &= -65;
				}
				break;
			case 2:
				if(v24) {
					bs24 |= 32;
				} else {
					bs24 &= -33;
				}
				break;
			case 3:
				if(v24) {
					bs24 |= 16;
				} else {
					bs24 &= -17;
				}
				break;
			case 4:
				if(v24) {
					bs24 |= 8;
				} else {
					bs24 &= -9;
				}
				break;
			case 5:
				if(v24) {
					bs24 |= 4;
				} else {
					bs24 &= -5;
				}
				break;
			case 6:
				if(v24) {
					bs24 |= 2;
				} else {
					bs24 &= -3;
				}
				break;
			case 7:
				if(v24) {
					bs24 |= 1;
				} else {
					bs24 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs24;
		var this26 = 0;
		var bs25 = this26;
		var l25 = "*****".length;
		var _g125 = 0;
		var _g35 = l25;
		while(_g125 < _g35) {
			var i25 = _g125++;
			var no25 = "*****".charCodeAt(i25);
			if(no25 == null) {
				break;
			}
			var v25;
			switch(no25) {
			case 32:
				v25 = false;
				break;
			case 42:
				v25 = true;
				break;
			case 48:
				v25 = false;
				break;
			case 49:
				v25 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i25)));
			}
			switch(i25 - (l25 - 8)) {
			case 0:
				if(v25) {
					bs25 |= 128;
				} else {
					bs25 &= -129;
				}
				break;
			case 1:
				if(v25) {
					bs25 |= 64;
				} else {
					bs25 &= -65;
				}
				break;
			case 2:
				if(v25) {
					bs25 |= 32;
				} else {
					bs25 &= -33;
				}
				break;
			case 3:
				if(v25) {
					bs25 |= 16;
				} else {
					bs25 &= -17;
				}
				break;
			case 4:
				if(v25) {
					bs25 |= 8;
				} else {
					bs25 &= -9;
				}
				break;
			case 5:
				if(v25) {
					bs25 |= 4;
				} else {
					bs25 &= -5;
				}
				break;
			case 6:
				if(v25) {
					bs25 |= 2;
				} else {
					bs25 &= -3;
				}
				break;
			case 7:
				if(v25) {
					bs25 |= 1;
				} else {
					bs25 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs25;
		var this27 = 0;
		var bs26 = this27;
		var l26 = " * * ".length;
		var _g126 = 0;
		var _g36 = l26;
		while(_g126 < _g36) {
			var i26 = _g126++;
			var no26 = " * * ".charCodeAt(i26);
			if(no26 == null) {
				break;
			}
			var v26;
			switch(no26) {
			case 32:
				v26 = false;
				break;
			case 42:
				v26 = true;
				break;
			case 48:
				v26 = false;
				break;
			case 49:
				v26 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i26)));
			}
			switch(i26 - (l26 - 8)) {
			case 0:
				if(v26) {
					bs26 |= 128;
				} else {
					bs26 &= -129;
				}
				break;
			case 1:
				if(v26) {
					bs26 |= 64;
				} else {
					bs26 &= -65;
				}
				break;
			case 2:
				if(v26) {
					bs26 |= 32;
				} else {
					bs26 &= -33;
				}
				break;
			case 3:
				if(v26) {
					bs26 |= 16;
				} else {
					bs26 &= -17;
				}
				break;
			case 4:
				if(v26) {
					bs26 |= 8;
				} else {
					bs26 &= -9;
				}
				break;
			case 5:
				if(v26) {
					bs26 |= 4;
				} else {
					bs26 &= -5;
				}
				break;
			case 6:
				if(v26) {
					bs26 |= 2;
				} else {
					bs26 &= -3;
				}
				break;
			case 7:
				if(v26) {
					bs26 |= 1;
				} else {
					bs26 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs26;
		var this28 = 0;
		var bs27 = this28;
		var l27 = " * * ".length;
		var _g127 = 0;
		var _g37 = l27;
		while(_g127 < _g37) {
			var i27 = _g127++;
			var no27 = " * * ".charCodeAt(i27);
			if(no27 == null) {
				break;
			}
			var v27;
			switch(no27) {
			case 32:
				v27 = false;
				break;
			case 42:
				v27 = true;
				break;
			case 48:
				v27 = false;
				break;
			case 49:
				v27 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i27)));
			}
			switch(i27 - (l27 - 8)) {
			case 0:
				if(v27) {
					bs27 |= 128;
				} else {
					bs27 &= -129;
				}
				break;
			case 1:
				if(v27) {
					bs27 |= 64;
				} else {
					bs27 &= -65;
				}
				break;
			case 2:
				if(v27) {
					bs27 |= 32;
				} else {
					bs27 &= -33;
				}
				break;
			case 3:
				if(v27) {
					bs27 |= 16;
				} else {
					bs27 &= -17;
				}
				break;
			case 4:
				if(v27) {
					bs27 |= 8;
				} else {
					bs27 &= -9;
				}
				break;
			case 5:
				if(v27) {
					bs27 |= 4;
				} else {
					bs27 &= -5;
				}
				break;
			case 6:
				if(v27) {
					bs27 |= 2;
				} else {
					bs27 &= -3;
				}
				break;
			case 7:
				if(v27) {
					bs27 |= 1;
				} else {
					bs27 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs27;
		break;
	case 36:
		var this29 = 0;
		var bs28 = this29;
		var l28 = "  *  ".length;
		var _g128 = 0;
		var _g38 = l28;
		while(_g128 < _g38) {
			var i28 = _g128++;
			var no28 = "  *  ".charCodeAt(i28);
			if(no28 == null) {
				break;
			}
			var v28;
			switch(no28) {
			case 32:
				v28 = false;
				break;
			case 42:
				v28 = true;
				break;
			case 48:
				v28 = false;
				break;
			case 49:
				v28 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i28)));
			}
			switch(i28 - (l28 - 8)) {
			case 0:
				if(v28) {
					bs28 |= 128;
				} else {
					bs28 &= -129;
				}
				break;
			case 1:
				if(v28) {
					bs28 |= 64;
				} else {
					bs28 &= -65;
				}
				break;
			case 2:
				if(v28) {
					bs28 |= 32;
				} else {
					bs28 &= -33;
				}
				break;
			case 3:
				if(v28) {
					bs28 |= 16;
				} else {
					bs28 &= -17;
				}
				break;
			case 4:
				if(v28) {
					bs28 |= 8;
				} else {
					bs28 &= -9;
				}
				break;
			case 5:
				if(v28) {
					bs28 |= 4;
				} else {
					bs28 &= -5;
				}
				break;
			case 6:
				if(v28) {
					bs28 |= 2;
				} else {
					bs28 &= -3;
				}
				break;
			case 7:
				if(v28) {
					bs28 |= 1;
				} else {
					bs28 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs28;
		var this30 = 0;
		var bs29 = this30;
		var l29 = " ****".length;
		var _g129 = 0;
		var _g39 = l29;
		while(_g129 < _g39) {
			var i29 = _g129++;
			var no29 = " ****".charCodeAt(i29);
			if(no29 == null) {
				break;
			}
			var v29;
			switch(no29) {
			case 32:
				v29 = false;
				break;
			case 42:
				v29 = true;
				break;
			case 48:
				v29 = false;
				break;
			case 49:
				v29 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i29)));
			}
			switch(i29 - (l29 - 8)) {
			case 0:
				if(v29) {
					bs29 |= 128;
				} else {
					bs29 &= -129;
				}
				break;
			case 1:
				if(v29) {
					bs29 |= 64;
				} else {
					bs29 &= -65;
				}
				break;
			case 2:
				if(v29) {
					bs29 |= 32;
				} else {
					bs29 &= -33;
				}
				break;
			case 3:
				if(v29) {
					bs29 |= 16;
				} else {
					bs29 &= -17;
				}
				break;
			case 4:
				if(v29) {
					bs29 |= 8;
				} else {
					bs29 &= -9;
				}
				break;
			case 5:
				if(v29) {
					bs29 |= 4;
				} else {
					bs29 &= -5;
				}
				break;
			case 6:
				if(v29) {
					bs29 |= 2;
				} else {
					bs29 &= -3;
				}
				break;
			case 7:
				if(v29) {
					bs29 |= 1;
				} else {
					bs29 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs29;
		var this31 = 0;
		var bs30 = this31;
		var l30 = "* *  ".length;
		var _g130 = 0;
		var _g40 = l30;
		while(_g130 < _g40) {
			var i30 = _g130++;
			var no30 = "* *  ".charCodeAt(i30);
			if(no30 == null) {
				break;
			}
			var v30;
			switch(no30) {
			case 32:
				v30 = false;
				break;
			case 42:
				v30 = true;
				break;
			case 48:
				v30 = false;
				break;
			case 49:
				v30 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i30)));
			}
			switch(i30 - (l30 - 8)) {
			case 0:
				if(v30) {
					bs30 |= 128;
				} else {
					bs30 &= -129;
				}
				break;
			case 1:
				if(v30) {
					bs30 |= 64;
				} else {
					bs30 &= -65;
				}
				break;
			case 2:
				if(v30) {
					bs30 |= 32;
				} else {
					bs30 &= -33;
				}
				break;
			case 3:
				if(v30) {
					bs30 |= 16;
				} else {
					bs30 &= -17;
				}
				break;
			case 4:
				if(v30) {
					bs30 |= 8;
				} else {
					bs30 &= -9;
				}
				break;
			case 5:
				if(v30) {
					bs30 |= 4;
				} else {
					bs30 &= -5;
				}
				break;
			case 6:
				if(v30) {
					bs30 |= 2;
				} else {
					bs30 &= -3;
				}
				break;
			case 7:
				if(v30) {
					bs30 |= 1;
				} else {
					bs30 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs30;
		var this32 = 0;
		var bs31 = this32;
		var l31 = " *** ".length;
		var _g131 = 0;
		var _g41 = l31;
		while(_g131 < _g41) {
			var i31 = _g131++;
			var no31 = " *** ".charCodeAt(i31);
			if(no31 == null) {
				break;
			}
			var v31;
			switch(no31) {
			case 32:
				v31 = false;
				break;
			case 42:
				v31 = true;
				break;
			case 48:
				v31 = false;
				break;
			case 49:
				v31 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i31)));
			}
			switch(i31 - (l31 - 8)) {
			case 0:
				if(v31) {
					bs31 |= 128;
				} else {
					bs31 &= -129;
				}
				break;
			case 1:
				if(v31) {
					bs31 |= 64;
				} else {
					bs31 &= -65;
				}
				break;
			case 2:
				if(v31) {
					bs31 |= 32;
				} else {
					bs31 &= -33;
				}
				break;
			case 3:
				if(v31) {
					bs31 |= 16;
				} else {
					bs31 &= -17;
				}
				break;
			case 4:
				if(v31) {
					bs31 |= 8;
				} else {
					bs31 &= -9;
				}
				break;
			case 5:
				if(v31) {
					bs31 |= 4;
				} else {
					bs31 &= -5;
				}
				break;
			case 6:
				if(v31) {
					bs31 |= 2;
				} else {
					bs31 &= -3;
				}
				break;
			case 7:
				if(v31) {
					bs31 |= 1;
				} else {
					bs31 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs31;
		var this33 = 0;
		var bs32 = this33;
		var l32 = "  * *".length;
		var _g132 = 0;
		var _g42 = l32;
		while(_g132 < _g42) {
			var i32 = _g132++;
			var no32 = "  * *".charCodeAt(i32);
			if(no32 == null) {
				break;
			}
			var v32;
			switch(no32) {
			case 32:
				v32 = false;
				break;
			case 42:
				v32 = true;
				break;
			case 48:
				v32 = false;
				break;
			case 49:
				v32 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  * *".charCodeAt(i32)));
			}
			switch(i32 - (l32 - 8)) {
			case 0:
				if(v32) {
					bs32 |= 128;
				} else {
					bs32 &= -129;
				}
				break;
			case 1:
				if(v32) {
					bs32 |= 64;
				} else {
					bs32 &= -65;
				}
				break;
			case 2:
				if(v32) {
					bs32 |= 32;
				} else {
					bs32 &= -33;
				}
				break;
			case 3:
				if(v32) {
					bs32 |= 16;
				} else {
					bs32 &= -17;
				}
				break;
			case 4:
				if(v32) {
					bs32 |= 8;
				} else {
					bs32 &= -9;
				}
				break;
			case 5:
				if(v32) {
					bs32 |= 4;
				} else {
					bs32 &= -5;
				}
				break;
			case 6:
				if(v32) {
					bs32 |= 2;
				} else {
					bs32 &= -3;
				}
				break;
			case 7:
				if(v32) {
					bs32 |= 1;
				} else {
					bs32 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs32;
		var this34 = 0;
		var bs33 = this34;
		var l33 = "**** ".length;
		var _g133 = 0;
		var _g43 = l33;
		while(_g133 < _g43) {
			var i33 = _g133++;
			var no33 = "**** ".charCodeAt(i33);
			if(no33 == null) {
				break;
			}
			var v33;
			switch(no33) {
			case 32:
				v33 = false;
				break;
			case 42:
				v33 = true;
				break;
			case 48:
				v33 = false;
				break;
			case 49:
				v33 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i33)));
			}
			switch(i33 - (l33 - 8)) {
			case 0:
				if(v33) {
					bs33 |= 128;
				} else {
					bs33 &= -129;
				}
				break;
			case 1:
				if(v33) {
					bs33 |= 64;
				} else {
					bs33 &= -65;
				}
				break;
			case 2:
				if(v33) {
					bs33 |= 32;
				} else {
					bs33 &= -33;
				}
				break;
			case 3:
				if(v33) {
					bs33 |= 16;
				} else {
					bs33 &= -17;
				}
				break;
			case 4:
				if(v33) {
					bs33 |= 8;
				} else {
					bs33 &= -9;
				}
				break;
			case 5:
				if(v33) {
					bs33 |= 4;
				} else {
					bs33 &= -5;
				}
				break;
			case 6:
				if(v33) {
					bs33 |= 2;
				} else {
					bs33 &= -3;
				}
				break;
			case 7:
				if(v33) {
					bs33 |= 1;
				} else {
					bs33 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs33;
		var this35 = 0;
		var bs34 = this35;
		var l34 = "  *  ".length;
		var _g134 = 0;
		var _g44 = l34;
		while(_g134 < _g44) {
			var i34 = _g134++;
			var no34 = "  *  ".charCodeAt(i34);
			if(no34 == null) {
				break;
			}
			var v34;
			switch(no34) {
			case 32:
				v34 = false;
				break;
			case 42:
				v34 = true;
				break;
			case 48:
				v34 = false;
				break;
			case 49:
				v34 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i34)));
			}
			switch(i34 - (l34 - 8)) {
			case 0:
				if(v34) {
					bs34 |= 128;
				} else {
					bs34 &= -129;
				}
				break;
			case 1:
				if(v34) {
					bs34 |= 64;
				} else {
					bs34 &= -65;
				}
				break;
			case 2:
				if(v34) {
					bs34 |= 32;
				} else {
					bs34 &= -33;
				}
				break;
			case 3:
				if(v34) {
					bs34 |= 16;
				} else {
					bs34 &= -17;
				}
				break;
			case 4:
				if(v34) {
					bs34 |= 8;
				} else {
					bs34 &= -9;
				}
				break;
			case 5:
				if(v34) {
					bs34 |= 4;
				} else {
					bs34 &= -5;
				}
				break;
			case 6:
				if(v34) {
					bs34 |= 2;
				} else {
					bs34 &= -3;
				}
				break;
			case 7:
				if(v34) {
					bs34 |= 1;
				} else {
					bs34 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs34;
		break;
	case 37:
		var this36 = 0;
		var bs35 = this36;
		var l35 = "**   ".length;
		var _g135 = 0;
		var _g45 = l35;
		while(_g135 < _g45) {
			var i35 = _g135++;
			var no35 = "**   ".charCodeAt(i35);
			if(no35 == null) {
				break;
			}
			var v35;
			switch(no35) {
			case 32:
				v35 = false;
				break;
			case 42:
				v35 = true;
				break;
			case 48:
				v35 = false;
				break;
			case 49:
				v35 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**   ".charCodeAt(i35)));
			}
			switch(i35 - (l35 - 8)) {
			case 0:
				if(v35) {
					bs35 |= 128;
				} else {
					bs35 &= -129;
				}
				break;
			case 1:
				if(v35) {
					bs35 |= 64;
				} else {
					bs35 &= -65;
				}
				break;
			case 2:
				if(v35) {
					bs35 |= 32;
				} else {
					bs35 &= -33;
				}
				break;
			case 3:
				if(v35) {
					bs35 |= 16;
				} else {
					bs35 &= -17;
				}
				break;
			case 4:
				if(v35) {
					bs35 |= 8;
				} else {
					bs35 &= -9;
				}
				break;
			case 5:
				if(v35) {
					bs35 |= 4;
				} else {
					bs35 &= -5;
				}
				break;
			case 6:
				if(v35) {
					bs35 |= 2;
				} else {
					bs35 &= -3;
				}
				break;
			case 7:
				if(v35) {
					bs35 |= 1;
				} else {
					bs35 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs35;
		var this37 = 0;
		var bs36 = this37;
		var l36 = "**  *".length;
		var _g136 = 0;
		var _g46 = l36;
		while(_g136 < _g46) {
			var i36 = _g136++;
			var no36 = "**  *".charCodeAt(i36);
			if(no36 == null) {
				break;
			}
			var v36;
			switch(no36) {
			case 32:
				v36 = false;
				break;
			case 42:
				v36 = true;
				break;
			case 48:
				v36 = false;
				break;
			case 49:
				v36 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i36)));
			}
			switch(i36 - (l36 - 8)) {
			case 0:
				if(v36) {
					bs36 |= 128;
				} else {
					bs36 &= -129;
				}
				break;
			case 1:
				if(v36) {
					bs36 |= 64;
				} else {
					bs36 &= -65;
				}
				break;
			case 2:
				if(v36) {
					bs36 |= 32;
				} else {
					bs36 &= -33;
				}
				break;
			case 3:
				if(v36) {
					bs36 |= 16;
				} else {
					bs36 &= -17;
				}
				break;
			case 4:
				if(v36) {
					bs36 |= 8;
				} else {
					bs36 &= -9;
				}
				break;
			case 5:
				if(v36) {
					bs36 |= 4;
				} else {
					bs36 &= -5;
				}
				break;
			case 6:
				if(v36) {
					bs36 |= 2;
				} else {
					bs36 &= -3;
				}
				break;
			case 7:
				if(v36) {
					bs36 |= 1;
				} else {
					bs36 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs36;
		var this38 = 0;
		var bs37 = this38;
		var l37 = "   * ".length;
		var _g137 = 0;
		var _g47 = l37;
		while(_g137 < _g47) {
			var i37 = _g137++;
			var no37 = "   * ".charCodeAt(i37);
			if(no37 == null) {
				break;
			}
			var v37;
			switch(no37) {
			case 32:
				v37 = false;
				break;
			case 42:
				v37 = true;
				break;
			case 48:
				v37 = false;
				break;
			case 49:
				v37 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i37)));
			}
			switch(i37 - (l37 - 8)) {
			case 0:
				if(v37) {
					bs37 |= 128;
				} else {
					bs37 &= -129;
				}
				break;
			case 1:
				if(v37) {
					bs37 |= 64;
				} else {
					bs37 &= -65;
				}
				break;
			case 2:
				if(v37) {
					bs37 |= 32;
				} else {
					bs37 &= -33;
				}
				break;
			case 3:
				if(v37) {
					bs37 |= 16;
				} else {
					bs37 &= -17;
				}
				break;
			case 4:
				if(v37) {
					bs37 |= 8;
				} else {
					bs37 &= -9;
				}
				break;
			case 5:
				if(v37) {
					bs37 |= 4;
				} else {
					bs37 &= -5;
				}
				break;
			case 6:
				if(v37) {
					bs37 |= 2;
				} else {
					bs37 &= -3;
				}
				break;
			case 7:
				if(v37) {
					bs37 |= 1;
				} else {
					bs37 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs37;
		var this39 = 0;
		var bs38 = this39;
		var l38 = "  *  ".length;
		var _g138 = 0;
		var _g48 = l38;
		while(_g138 < _g48) {
			var i38 = _g138++;
			var no38 = "  *  ".charCodeAt(i38);
			if(no38 == null) {
				break;
			}
			var v38;
			switch(no38) {
			case 32:
				v38 = false;
				break;
			case 42:
				v38 = true;
				break;
			case 48:
				v38 = false;
				break;
			case 49:
				v38 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i38)));
			}
			switch(i38 - (l38 - 8)) {
			case 0:
				if(v38) {
					bs38 |= 128;
				} else {
					bs38 &= -129;
				}
				break;
			case 1:
				if(v38) {
					bs38 |= 64;
				} else {
					bs38 &= -65;
				}
				break;
			case 2:
				if(v38) {
					bs38 |= 32;
				} else {
					bs38 &= -33;
				}
				break;
			case 3:
				if(v38) {
					bs38 |= 16;
				} else {
					bs38 &= -17;
				}
				break;
			case 4:
				if(v38) {
					bs38 |= 8;
				} else {
					bs38 &= -9;
				}
				break;
			case 5:
				if(v38) {
					bs38 |= 4;
				} else {
					bs38 &= -5;
				}
				break;
			case 6:
				if(v38) {
					bs38 |= 2;
				} else {
					bs38 &= -3;
				}
				break;
			case 7:
				if(v38) {
					bs38 |= 1;
				} else {
					bs38 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs38;
		var this40 = 0;
		var bs39 = this40;
		var l39 = " *   ".length;
		var _g139 = 0;
		var _g49 = l39;
		while(_g139 < _g49) {
			var i39 = _g139++;
			var no39 = " *   ".charCodeAt(i39);
			if(no39 == null) {
				break;
			}
			var v39;
			switch(no39) {
			case 32:
				v39 = false;
				break;
			case 42:
				v39 = true;
				break;
			case 48:
				v39 = false;
				break;
			case 49:
				v39 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i39)));
			}
			switch(i39 - (l39 - 8)) {
			case 0:
				if(v39) {
					bs39 |= 128;
				} else {
					bs39 &= -129;
				}
				break;
			case 1:
				if(v39) {
					bs39 |= 64;
				} else {
					bs39 &= -65;
				}
				break;
			case 2:
				if(v39) {
					bs39 |= 32;
				} else {
					bs39 &= -33;
				}
				break;
			case 3:
				if(v39) {
					bs39 |= 16;
				} else {
					bs39 &= -17;
				}
				break;
			case 4:
				if(v39) {
					bs39 |= 8;
				} else {
					bs39 &= -9;
				}
				break;
			case 5:
				if(v39) {
					bs39 |= 4;
				} else {
					bs39 &= -5;
				}
				break;
			case 6:
				if(v39) {
					bs39 |= 2;
				} else {
					bs39 &= -3;
				}
				break;
			case 7:
				if(v39) {
					bs39 |= 1;
				} else {
					bs39 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs39;
		var this41 = 0;
		var bs40 = this41;
		var l40 = "*  **".length;
		var _g140 = 0;
		var _g50 = l40;
		while(_g140 < _g50) {
			var i40 = _g140++;
			var no40 = "*  **".charCodeAt(i40);
			if(no40 == null) {
				break;
			}
			var v40;
			switch(no40) {
			case 32:
				v40 = false;
				break;
			case 42:
				v40 = true;
				break;
			case 48:
				v40 = false;
				break;
			case 49:
				v40 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  **".charCodeAt(i40)));
			}
			switch(i40 - (l40 - 8)) {
			case 0:
				if(v40) {
					bs40 |= 128;
				} else {
					bs40 &= -129;
				}
				break;
			case 1:
				if(v40) {
					bs40 |= 64;
				} else {
					bs40 &= -65;
				}
				break;
			case 2:
				if(v40) {
					bs40 |= 32;
				} else {
					bs40 &= -33;
				}
				break;
			case 3:
				if(v40) {
					bs40 |= 16;
				} else {
					bs40 &= -17;
				}
				break;
			case 4:
				if(v40) {
					bs40 |= 8;
				} else {
					bs40 &= -9;
				}
				break;
			case 5:
				if(v40) {
					bs40 |= 4;
				} else {
					bs40 &= -5;
				}
				break;
			case 6:
				if(v40) {
					bs40 |= 2;
				} else {
					bs40 &= -3;
				}
				break;
			case 7:
				if(v40) {
					bs40 |= 1;
				} else {
					bs40 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs40;
		var this42 = 0;
		var bs41 = this42;
		var l41 = "   **".length;
		var _g141 = 0;
		var _g51 = l41;
		while(_g141 < _g51) {
			var i41 = _g141++;
			var no41 = "   **".charCodeAt(i41);
			if(no41 == null) {
				break;
			}
			var v41;
			switch(no41) {
			case 32:
				v41 = false;
				break;
			case 42:
				v41 = true;
				break;
			case 48:
				v41 = false;
				break;
			case 49:
				v41 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   **".charCodeAt(i41)));
			}
			switch(i41 - (l41 - 8)) {
			case 0:
				if(v41) {
					bs41 |= 128;
				} else {
					bs41 &= -129;
				}
				break;
			case 1:
				if(v41) {
					bs41 |= 64;
				} else {
					bs41 &= -65;
				}
				break;
			case 2:
				if(v41) {
					bs41 |= 32;
				} else {
					bs41 &= -33;
				}
				break;
			case 3:
				if(v41) {
					bs41 |= 16;
				} else {
					bs41 &= -17;
				}
				break;
			case 4:
				if(v41) {
					bs41 |= 8;
				} else {
					bs41 &= -9;
				}
				break;
			case 5:
				if(v41) {
					bs41 |= 4;
				} else {
					bs41 &= -5;
				}
				break;
			case 6:
				if(v41) {
					bs41 |= 2;
				} else {
					bs41 &= -3;
				}
				break;
			case 7:
				if(v41) {
					bs41 |= 1;
				} else {
					bs41 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs41;
		break;
	case 38:
		var this43 = 0;
		var bs42 = this43;
		var l42 = " **  ".length;
		var _g142 = 0;
		var _g52 = l42;
		while(_g142 < _g52) {
			var i42 = _g142++;
			var no42 = " **  ".charCodeAt(i42);
			if(no42 == null) {
				break;
			}
			var v42;
			switch(no42) {
			case 32:
				v42 = false;
				break;
			case 42:
				v42 = true;
				break;
			case 48:
				v42 = false;
				break;
			case 49:
				v42 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i42)));
			}
			switch(i42 - (l42 - 8)) {
			case 0:
				if(v42) {
					bs42 |= 128;
				} else {
					bs42 &= -129;
				}
				break;
			case 1:
				if(v42) {
					bs42 |= 64;
				} else {
					bs42 &= -65;
				}
				break;
			case 2:
				if(v42) {
					bs42 |= 32;
				} else {
					bs42 &= -33;
				}
				break;
			case 3:
				if(v42) {
					bs42 |= 16;
				} else {
					bs42 &= -17;
				}
				break;
			case 4:
				if(v42) {
					bs42 |= 8;
				} else {
					bs42 &= -9;
				}
				break;
			case 5:
				if(v42) {
					bs42 |= 4;
				} else {
					bs42 &= -5;
				}
				break;
			case 6:
				if(v42) {
					bs42 |= 2;
				} else {
					bs42 &= -3;
				}
				break;
			case 7:
				if(v42) {
					bs42 |= 1;
				} else {
					bs42 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs42;
		var this44 = 0;
		var bs43 = this44;
		var l43 = "*  * ".length;
		var _g143 = 0;
		var _g53 = l43;
		while(_g143 < _g53) {
			var i43 = _g143++;
			var no43 = "*  * ".charCodeAt(i43);
			if(no43 == null) {
				break;
			}
			var v43;
			switch(no43) {
			case 32:
				v43 = false;
				break;
			case 42:
				v43 = true;
				break;
			case 48:
				v43 = false;
				break;
			case 49:
				v43 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i43)));
			}
			switch(i43 - (l43 - 8)) {
			case 0:
				if(v43) {
					bs43 |= 128;
				} else {
					bs43 &= -129;
				}
				break;
			case 1:
				if(v43) {
					bs43 |= 64;
				} else {
					bs43 &= -65;
				}
				break;
			case 2:
				if(v43) {
					bs43 |= 32;
				} else {
					bs43 &= -33;
				}
				break;
			case 3:
				if(v43) {
					bs43 |= 16;
				} else {
					bs43 &= -17;
				}
				break;
			case 4:
				if(v43) {
					bs43 |= 8;
				} else {
					bs43 &= -9;
				}
				break;
			case 5:
				if(v43) {
					bs43 |= 4;
				} else {
					bs43 &= -5;
				}
				break;
			case 6:
				if(v43) {
					bs43 |= 2;
				} else {
					bs43 &= -3;
				}
				break;
			case 7:
				if(v43) {
					bs43 |= 1;
				} else {
					bs43 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs43;
		var this45 = 0;
		var bs44 = this45;
		var l44 = "* *  ".length;
		var _g144 = 0;
		var _g54 = l44;
		while(_g144 < _g54) {
			var i44 = _g144++;
			var no44 = "* *  ".charCodeAt(i44);
			if(no44 == null) {
				break;
			}
			var v44;
			switch(no44) {
			case 32:
				v44 = false;
				break;
			case 42:
				v44 = true;
				break;
			case 48:
				v44 = false;
				break;
			case 49:
				v44 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i44)));
			}
			switch(i44 - (l44 - 8)) {
			case 0:
				if(v44) {
					bs44 |= 128;
				} else {
					bs44 &= -129;
				}
				break;
			case 1:
				if(v44) {
					bs44 |= 64;
				} else {
					bs44 &= -65;
				}
				break;
			case 2:
				if(v44) {
					bs44 |= 32;
				} else {
					bs44 &= -33;
				}
				break;
			case 3:
				if(v44) {
					bs44 |= 16;
				} else {
					bs44 &= -17;
				}
				break;
			case 4:
				if(v44) {
					bs44 |= 8;
				} else {
					bs44 &= -9;
				}
				break;
			case 5:
				if(v44) {
					bs44 |= 4;
				} else {
					bs44 &= -5;
				}
				break;
			case 6:
				if(v44) {
					bs44 |= 2;
				} else {
					bs44 &= -3;
				}
				break;
			case 7:
				if(v44) {
					bs44 |= 1;
				} else {
					bs44 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs44;
		var this46 = 0;
		var bs45 = this46;
		var l45 = " *   ".length;
		var _g145 = 0;
		var _g55 = l45;
		while(_g145 < _g55) {
			var i45 = _g145++;
			var no45 = " *   ".charCodeAt(i45);
			if(no45 == null) {
				break;
			}
			var v45;
			switch(no45) {
			case 32:
				v45 = false;
				break;
			case 42:
				v45 = true;
				break;
			case 48:
				v45 = false;
				break;
			case 49:
				v45 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i45)));
			}
			switch(i45 - (l45 - 8)) {
			case 0:
				if(v45) {
					bs45 |= 128;
				} else {
					bs45 &= -129;
				}
				break;
			case 1:
				if(v45) {
					bs45 |= 64;
				} else {
					bs45 &= -65;
				}
				break;
			case 2:
				if(v45) {
					bs45 |= 32;
				} else {
					bs45 &= -33;
				}
				break;
			case 3:
				if(v45) {
					bs45 |= 16;
				} else {
					bs45 &= -17;
				}
				break;
			case 4:
				if(v45) {
					bs45 |= 8;
				} else {
					bs45 &= -9;
				}
				break;
			case 5:
				if(v45) {
					bs45 |= 4;
				} else {
					bs45 &= -5;
				}
				break;
			case 6:
				if(v45) {
					bs45 |= 2;
				} else {
					bs45 &= -3;
				}
				break;
			case 7:
				if(v45) {
					bs45 |= 1;
				} else {
					bs45 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs45;
		var this47 = 0;
		var bs46 = this47;
		var l46 = "* * *".length;
		var _g146 = 0;
		var _g56 = l46;
		while(_g146 < _g56) {
			var i46 = _g146++;
			var no46 = "* * *".charCodeAt(i46);
			if(no46 == null) {
				break;
			}
			var v46;
			switch(no46) {
			case 32:
				v46 = false;
				break;
			case 42:
				v46 = true;
				break;
			case 48:
				v46 = false;
				break;
			case 49:
				v46 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i46)));
			}
			switch(i46 - (l46 - 8)) {
			case 0:
				if(v46) {
					bs46 |= 128;
				} else {
					bs46 &= -129;
				}
				break;
			case 1:
				if(v46) {
					bs46 |= 64;
				} else {
					bs46 &= -65;
				}
				break;
			case 2:
				if(v46) {
					bs46 |= 32;
				} else {
					bs46 &= -33;
				}
				break;
			case 3:
				if(v46) {
					bs46 |= 16;
				} else {
					bs46 &= -17;
				}
				break;
			case 4:
				if(v46) {
					bs46 |= 8;
				} else {
					bs46 &= -9;
				}
				break;
			case 5:
				if(v46) {
					bs46 |= 4;
				} else {
					bs46 &= -5;
				}
				break;
			case 6:
				if(v46) {
					bs46 |= 2;
				} else {
					bs46 &= -3;
				}
				break;
			case 7:
				if(v46) {
					bs46 |= 1;
				} else {
					bs46 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs46;
		var this48 = 0;
		var bs47 = this48;
		var l47 = "*  * ".length;
		var _g147 = 0;
		var _g57 = l47;
		while(_g147 < _g57) {
			var i47 = _g147++;
			var no47 = "*  * ".charCodeAt(i47);
			if(no47 == null) {
				break;
			}
			var v47;
			switch(no47) {
			case 32:
				v47 = false;
				break;
			case 42:
				v47 = true;
				break;
			case 48:
				v47 = false;
				break;
			case 49:
				v47 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i47)));
			}
			switch(i47 - (l47 - 8)) {
			case 0:
				if(v47) {
					bs47 |= 128;
				} else {
					bs47 &= -129;
				}
				break;
			case 1:
				if(v47) {
					bs47 |= 64;
				} else {
					bs47 &= -65;
				}
				break;
			case 2:
				if(v47) {
					bs47 |= 32;
				} else {
					bs47 &= -33;
				}
				break;
			case 3:
				if(v47) {
					bs47 |= 16;
				} else {
					bs47 &= -17;
				}
				break;
			case 4:
				if(v47) {
					bs47 |= 8;
				} else {
					bs47 &= -9;
				}
				break;
			case 5:
				if(v47) {
					bs47 |= 4;
				} else {
					bs47 &= -5;
				}
				break;
			case 6:
				if(v47) {
					bs47 |= 2;
				} else {
					bs47 &= -3;
				}
				break;
			case 7:
				if(v47) {
					bs47 |= 1;
				} else {
					bs47 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs47;
		var this49 = 0;
		var bs48 = this49;
		var l48 = " ** *".length;
		var _g148 = 0;
		var _g58 = l48;
		while(_g148 < _g58) {
			var i48 = _g148++;
			var no48 = " ** *".charCodeAt(i48);
			if(no48 == null) {
				break;
			}
			var v48;
			switch(no48) {
			case 32:
				v48 = false;
				break;
			case 42:
				v48 = true;
				break;
			case 48:
				v48 = false;
				break;
			case 49:
				v48 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i48)));
			}
			switch(i48 - (l48 - 8)) {
			case 0:
				if(v48) {
					bs48 |= 128;
				} else {
					bs48 &= -129;
				}
				break;
			case 1:
				if(v48) {
					bs48 |= 64;
				} else {
					bs48 &= -65;
				}
				break;
			case 2:
				if(v48) {
					bs48 |= 32;
				} else {
					bs48 &= -33;
				}
				break;
			case 3:
				if(v48) {
					bs48 |= 16;
				} else {
					bs48 &= -17;
				}
				break;
			case 4:
				if(v48) {
					bs48 |= 8;
				} else {
					bs48 &= -9;
				}
				break;
			case 5:
				if(v48) {
					bs48 |= 4;
				} else {
					bs48 &= -5;
				}
				break;
			case 6:
				if(v48) {
					bs48 |= 2;
				} else {
					bs48 &= -3;
				}
				break;
			case 7:
				if(v48) {
					bs48 |= 1;
				} else {
					bs48 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs48;
		break;
	case 39:
		var this50 = 0;
		var bs49 = this50;
		var l49 = "  ** ".length;
		var _g149 = 0;
		var _g59 = l49;
		while(_g149 < _g59) {
			var i49 = _g149++;
			var no49 = "  ** ".charCodeAt(i49);
			if(no49 == null) {
				break;
			}
			var v49;
			switch(no49) {
			case 32:
				v49 = false;
				break;
			case 42:
				v49 = true;
				break;
			case 48:
				v49 = false;
				break;
			case 49:
				v49 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i49)));
			}
			switch(i49 - (l49 - 8)) {
			case 0:
				if(v49) {
					bs49 |= 128;
				} else {
					bs49 &= -129;
				}
				break;
			case 1:
				if(v49) {
					bs49 |= 64;
				} else {
					bs49 &= -65;
				}
				break;
			case 2:
				if(v49) {
					bs49 |= 32;
				} else {
					bs49 &= -33;
				}
				break;
			case 3:
				if(v49) {
					bs49 |= 16;
				} else {
					bs49 &= -17;
				}
				break;
			case 4:
				if(v49) {
					bs49 |= 8;
				} else {
					bs49 &= -9;
				}
				break;
			case 5:
				if(v49) {
					bs49 |= 4;
				} else {
					bs49 &= -5;
				}
				break;
			case 6:
				if(v49) {
					bs49 |= 2;
				} else {
					bs49 &= -3;
				}
				break;
			case 7:
				if(v49) {
					bs49 |= 1;
				} else {
					bs49 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs49;
		var this51 = 0;
		var bs50 = this51;
		var l50 = "   * ".length;
		var _g150 = 0;
		var _g60 = l50;
		while(_g150 < _g60) {
			var i50 = _g150++;
			var no50 = "   * ".charCodeAt(i50);
			if(no50 == null) {
				break;
			}
			var v50;
			switch(no50) {
			case 32:
				v50 = false;
				break;
			case 42:
				v50 = true;
				break;
			case 48:
				v50 = false;
				break;
			case 49:
				v50 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i50)));
			}
			switch(i50 - (l50 - 8)) {
			case 0:
				if(v50) {
					bs50 |= 128;
				} else {
					bs50 &= -129;
				}
				break;
			case 1:
				if(v50) {
					bs50 |= 64;
				} else {
					bs50 &= -65;
				}
				break;
			case 2:
				if(v50) {
					bs50 |= 32;
				} else {
					bs50 &= -33;
				}
				break;
			case 3:
				if(v50) {
					bs50 |= 16;
				} else {
					bs50 &= -17;
				}
				break;
			case 4:
				if(v50) {
					bs50 |= 8;
				} else {
					bs50 &= -9;
				}
				break;
			case 5:
				if(v50) {
					bs50 |= 4;
				} else {
					bs50 &= -5;
				}
				break;
			case 6:
				if(v50) {
					bs50 |= 2;
				} else {
					bs50 &= -3;
				}
				break;
			case 7:
				if(v50) {
					bs50 |= 1;
				} else {
					bs50 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs50;
		var this52 = 0;
		var bs51 = this52;
		var l51 = "  *  ".length;
		var _g151 = 0;
		var _g61 = l51;
		while(_g151 < _g61) {
			var i51 = _g151++;
			var no51 = "  *  ".charCodeAt(i51);
			if(no51 == null) {
				break;
			}
			var v51;
			switch(no51) {
			case 32:
				v51 = false;
				break;
			case 42:
				v51 = true;
				break;
			case 48:
				v51 = false;
				break;
			case 49:
				v51 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i51)));
			}
			switch(i51 - (l51 - 8)) {
			case 0:
				if(v51) {
					bs51 |= 128;
				} else {
					bs51 &= -129;
				}
				break;
			case 1:
				if(v51) {
					bs51 |= 64;
				} else {
					bs51 &= -65;
				}
				break;
			case 2:
				if(v51) {
					bs51 |= 32;
				} else {
					bs51 &= -33;
				}
				break;
			case 3:
				if(v51) {
					bs51 |= 16;
				} else {
					bs51 &= -17;
				}
				break;
			case 4:
				if(v51) {
					bs51 |= 8;
				} else {
					bs51 &= -9;
				}
				break;
			case 5:
				if(v51) {
					bs51 |= 4;
				} else {
					bs51 &= -5;
				}
				break;
			case 6:
				if(v51) {
					bs51 |= 2;
				} else {
					bs51 &= -3;
				}
				break;
			case 7:
				if(v51) {
					bs51 |= 1;
				} else {
					bs51 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs51;
		var this53 = 0;
		var bs52 = this53;
		var l52 = "     ".length;
		var _g152 = 0;
		var _g62 = l52;
		while(_g152 < _g62) {
			var i52 = _g152++;
			var no52 = "     ".charCodeAt(i52);
			if(no52 == null) {
				break;
			}
			var v52;
			switch(no52) {
			case 32:
				v52 = false;
				break;
			case 42:
				v52 = true;
				break;
			case 48:
				v52 = false;
				break;
			case 49:
				v52 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i52)));
			}
			switch(i52 - (l52 - 8)) {
			case 0:
				if(v52) {
					bs52 |= 128;
				} else {
					bs52 &= -129;
				}
				break;
			case 1:
				if(v52) {
					bs52 |= 64;
				} else {
					bs52 &= -65;
				}
				break;
			case 2:
				if(v52) {
					bs52 |= 32;
				} else {
					bs52 &= -33;
				}
				break;
			case 3:
				if(v52) {
					bs52 |= 16;
				} else {
					bs52 &= -17;
				}
				break;
			case 4:
				if(v52) {
					bs52 |= 8;
				} else {
					bs52 &= -9;
				}
				break;
			case 5:
				if(v52) {
					bs52 |= 4;
				} else {
					bs52 &= -5;
				}
				break;
			case 6:
				if(v52) {
					bs52 |= 2;
				} else {
					bs52 &= -3;
				}
				break;
			case 7:
				if(v52) {
					bs52 |= 1;
				} else {
					bs52 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs52;
		var this54 = 0;
		var bs53 = this54;
		var l53 = "     ".length;
		var _g153 = 0;
		var _g63 = l53;
		while(_g153 < _g63) {
			var i53 = _g153++;
			var no53 = "     ".charCodeAt(i53);
			if(no53 == null) {
				break;
			}
			var v53;
			switch(no53) {
			case 32:
				v53 = false;
				break;
			case 42:
				v53 = true;
				break;
			case 48:
				v53 = false;
				break;
			case 49:
				v53 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i53)));
			}
			switch(i53 - (l53 - 8)) {
			case 0:
				if(v53) {
					bs53 |= 128;
				} else {
					bs53 &= -129;
				}
				break;
			case 1:
				if(v53) {
					bs53 |= 64;
				} else {
					bs53 &= -65;
				}
				break;
			case 2:
				if(v53) {
					bs53 |= 32;
				} else {
					bs53 &= -33;
				}
				break;
			case 3:
				if(v53) {
					bs53 |= 16;
				} else {
					bs53 &= -17;
				}
				break;
			case 4:
				if(v53) {
					bs53 |= 8;
				} else {
					bs53 &= -9;
				}
				break;
			case 5:
				if(v53) {
					bs53 |= 4;
				} else {
					bs53 &= -5;
				}
				break;
			case 6:
				if(v53) {
					bs53 |= 2;
				} else {
					bs53 &= -3;
				}
				break;
			case 7:
				if(v53) {
					bs53 |= 1;
				} else {
					bs53 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs53;
		var this55 = 0;
		var bs54 = this55;
		var l54 = "     ".length;
		var _g154 = 0;
		var _g64 = l54;
		while(_g154 < _g64) {
			var i54 = _g154++;
			var no54 = "     ".charCodeAt(i54);
			if(no54 == null) {
				break;
			}
			var v54;
			switch(no54) {
			case 32:
				v54 = false;
				break;
			case 42:
				v54 = true;
				break;
			case 48:
				v54 = false;
				break;
			case 49:
				v54 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i54)));
			}
			switch(i54 - (l54 - 8)) {
			case 0:
				if(v54) {
					bs54 |= 128;
				} else {
					bs54 &= -129;
				}
				break;
			case 1:
				if(v54) {
					bs54 |= 64;
				} else {
					bs54 &= -65;
				}
				break;
			case 2:
				if(v54) {
					bs54 |= 32;
				} else {
					bs54 &= -33;
				}
				break;
			case 3:
				if(v54) {
					bs54 |= 16;
				} else {
					bs54 &= -17;
				}
				break;
			case 4:
				if(v54) {
					bs54 |= 8;
				} else {
					bs54 &= -9;
				}
				break;
			case 5:
				if(v54) {
					bs54 |= 4;
				} else {
					bs54 &= -5;
				}
				break;
			case 6:
				if(v54) {
					bs54 |= 2;
				} else {
					bs54 &= -3;
				}
				break;
			case 7:
				if(v54) {
					bs54 |= 1;
				} else {
					bs54 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs54;
		var this56 = 0;
		var bs55 = this56;
		var l55 = "     ".length;
		var _g155 = 0;
		var _g65 = l55;
		while(_g155 < _g65) {
			var i55 = _g155++;
			var no55 = "     ".charCodeAt(i55);
			if(no55 == null) {
				break;
			}
			var v55;
			switch(no55) {
			case 32:
				v55 = false;
				break;
			case 42:
				v55 = true;
				break;
			case 48:
				v55 = false;
				break;
			case 49:
				v55 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i55)));
			}
			switch(i55 - (l55 - 8)) {
			case 0:
				if(v55) {
					bs55 |= 128;
				} else {
					bs55 &= -129;
				}
				break;
			case 1:
				if(v55) {
					bs55 |= 64;
				} else {
					bs55 &= -65;
				}
				break;
			case 2:
				if(v55) {
					bs55 |= 32;
				} else {
					bs55 &= -33;
				}
				break;
			case 3:
				if(v55) {
					bs55 |= 16;
				} else {
					bs55 &= -17;
				}
				break;
			case 4:
				if(v55) {
					bs55 |= 8;
				} else {
					bs55 &= -9;
				}
				break;
			case 5:
				if(v55) {
					bs55 |= 4;
				} else {
					bs55 &= -5;
				}
				break;
			case 6:
				if(v55) {
					bs55 |= 2;
				} else {
					bs55 &= -3;
				}
				break;
			case 7:
				if(v55) {
					bs55 |= 1;
				} else {
					bs55 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs55;
		break;
	case 40:
		var this57 = 0;
		var bs56 = this57;
		var l56 = "  *  ".length;
		var _g156 = 0;
		var _g66 = l56;
		while(_g156 < _g66) {
			var i56 = _g156++;
			var no56 = "  *  ".charCodeAt(i56);
			if(no56 == null) {
				break;
			}
			var v56;
			switch(no56) {
			case 32:
				v56 = false;
				break;
			case 42:
				v56 = true;
				break;
			case 48:
				v56 = false;
				break;
			case 49:
				v56 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i56)));
			}
			switch(i56 - (l56 - 8)) {
			case 0:
				if(v56) {
					bs56 |= 128;
				} else {
					bs56 &= -129;
				}
				break;
			case 1:
				if(v56) {
					bs56 |= 64;
				} else {
					bs56 &= -65;
				}
				break;
			case 2:
				if(v56) {
					bs56 |= 32;
				} else {
					bs56 &= -33;
				}
				break;
			case 3:
				if(v56) {
					bs56 |= 16;
				} else {
					bs56 &= -17;
				}
				break;
			case 4:
				if(v56) {
					bs56 |= 8;
				} else {
					bs56 &= -9;
				}
				break;
			case 5:
				if(v56) {
					bs56 |= 4;
				} else {
					bs56 &= -5;
				}
				break;
			case 6:
				if(v56) {
					bs56 |= 2;
				} else {
					bs56 &= -3;
				}
				break;
			case 7:
				if(v56) {
					bs56 |= 1;
				} else {
					bs56 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs56;
		var this58 = 0;
		var bs57 = this58;
		var l57 = " *   ".length;
		var _g157 = 0;
		var _g67 = l57;
		while(_g157 < _g67) {
			var i57 = _g157++;
			var no57 = " *   ".charCodeAt(i57);
			if(no57 == null) {
				break;
			}
			var v57;
			switch(no57) {
			case 32:
				v57 = false;
				break;
			case 42:
				v57 = true;
				break;
			case 48:
				v57 = false;
				break;
			case 49:
				v57 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i57)));
			}
			switch(i57 - (l57 - 8)) {
			case 0:
				if(v57) {
					bs57 |= 128;
				} else {
					bs57 &= -129;
				}
				break;
			case 1:
				if(v57) {
					bs57 |= 64;
				} else {
					bs57 &= -65;
				}
				break;
			case 2:
				if(v57) {
					bs57 |= 32;
				} else {
					bs57 &= -33;
				}
				break;
			case 3:
				if(v57) {
					bs57 |= 16;
				} else {
					bs57 &= -17;
				}
				break;
			case 4:
				if(v57) {
					bs57 |= 8;
				} else {
					bs57 &= -9;
				}
				break;
			case 5:
				if(v57) {
					bs57 |= 4;
				} else {
					bs57 &= -5;
				}
				break;
			case 6:
				if(v57) {
					bs57 |= 2;
				} else {
					bs57 &= -3;
				}
				break;
			case 7:
				if(v57) {
					bs57 |= 1;
				} else {
					bs57 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs57;
		var this59 = 0;
		var bs58 = this59;
		var l58 = "*    ".length;
		var _g158 = 0;
		var _g68 = l58;
		while(_g158 < _g68) {
			var i58 = _g158++;
			var no58 = "*    ".charCodeAt(i58);
			if(no58 == null) {
				break;
			}
			var v58;
			switch(no58) {
			case 32:
				v58 = false;
				break;
			case 42:
				v58 = true;
				break;
			case 48:
				v58 = false;
				break;
			case 49:
				v58 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i58)));
			}
			switch(i58 - (l58 - 8)) {
			case 0:
				if(v58) {
					bs58 |= 128;
				} else {
					bs58 &= -129;
				}
				break;
			case 1:
				if(v58) {
					bs58 |= 64;
				} else {
					bs58 &= -65;
				}
				break;
			case 2:
				if(v58) {
					bs58 |= 32;
				} else {
					bs58 &= -33;
				}
				break;
			case 3:
				if(v58) {
					bs58 |= 16;
				} else {
					bs58 &= -17;
				}
				break;
			case 4:
				if(v58) {
					bs58 |= 8;
				} else {
					bs58 &= -9;
				}
				break;
			case 5:
				if(v58) {
					bs58 |= 4;
				} else {
					bs58 &= -5;
				}
				break;
			case 6:
				if(v58) {
					bs58 |= 2;
				} else {
					bs58 &= -3;
				}
				break;
			case 7:
				if(v58) {
					bs58 |= 1;
				} else {
					bs58 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs58;
		var this60 = 0;
		var bs59 = this60;
		var l59 = "*    ".length;
		var _g159 = 0;
		var _g69 = l59;
		while(_g159 < _g69) {
			var i59 = _g159++;
			var no59 = "*    ".charCodeAt(i59);
			if(no59 == null) {
				break;
			}
			var v59;
			switch(no59) {
			case 32:
				v59 = false;
				break;
			case 42:
				v59 = true;
				break;
			case 48:
				v59 = false;
				break;
			case 49:
				v59 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i59)));
			}
			switch(i59 - (l59 - 8)) {
			case 0:
				if(v59) {
					bs59 |= 128;
				} else {
					bs59 &= -129;
				}
				break;
			case 1:
				if(v59) {
					bs59 |= 64;
				} else {
					bs59 &= -65;
				}
				break;
			case 2:
				if(v59) {
					bs59 |= 32;
				} else {
					bs59 &= -33;
				}
				break;
			case 3:
				if(v59) {
					bs59 |= 16;
				} else {
					bs59 &= -17;
				}
				break;
			case 4:
				if(v59) {
					bs59 |= 8;
				} else {
					bs59 &= -9;
				}
				break;
			case 5:
				if(v59) {
					bs59 |= 4;
				} else {
					bs59 &= -5;
				}
				break;
			case 6:
				if(v59) {
					bs59 |= 2;
				} else {
					bs59 &= -3;
				}
				break;
			case 7:
				if(v59) {
					bs59 |= 1;
				} else {
					bs59 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs59;
		var this61 = 0;
		var bs60 = this61;
		var l60 = "*    ".length;
		var _g160 = 0;
		var _g70 = l60;
		while(_g160 < _g70) {
			var i60 = _g160++;
			var no60 = "*    ".charCodeAt(i60);
			if(no60 == null) {
				break;
			}
			var v60;
			switch(no60) {
			case 32:
				v60 = false;
				break;
			case 42:
				v60 = true;
				break;
			case 48:
				v60 = false;
				break;
			case 49:
				v60 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i60)));
			}
			switch(i60 - (l60 - 8)) {
			case 0:
				if(v60) {
					bs60 |= 128;
				} else {
					bs60 &= -129;
				}
				break;
			case 1:
				if(v60) {
					bs60 |= 64;
				} else {
					bs60 &= -65;
				}
				break;
			case 2:
				if(v60) {
					bs60 |= 32;
				} else {
					bs60 &= -33;
				}
				break;
			case 3:
				if(v60) {
					bs60 |= 16;
				} else {
					bs60 &= -17;
				}
				break;
			case 4:
				if(v60) {
					bs60 |= 8;
				} else {
					bs60 &= -9;
				}
				break;
			case 5:
				if(v60) {
					bs60 |= 4;
				} else {
					bs60 &= -5;
				}
				break;
			case 6:
				if(v60) {
					bs60 |= 2;
				} else {
					bs60 &= -3;
				}
				break;
			case 7:
				if(v60) {
					bs60 |= 1;
				} else {
					bs60 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs60;
		var this62 = 0;
		var bs61 = this62;
		var l61 = " *   ".length;
		var _g161 = 0;
		var _g71 = l61;
		while(_g161 < _g71) {
			var i61 = _g161++;
			var no61 = " *   ".charCodeAt(i61);
			if(no61 == null) {
				break;
			}
			var v61;
			switch(no61) {
			case 32:
				v61 = false;
				break;
			case 42:
				v61 = true;
				break;
			case 48:
				v61 = false;
				break;
			case 49:
				v61 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i61)));
			}
			switch(i61 - (l61 - 8)) {
			case 0:
				if(v61) {
					bs61 |= 128;
				} else {
					bs61 &= -129;
				}
				break;
			case 1:
				if(v61) {
					bs61 |= 64;
				} else {
					bs61 &= -65;
				}
				break;
			case 2:
				if(v61) {
					bs61 |= 32;
				} else {
					bs61 &= -33;
				}
				break;
			case 3:
				if(v61) {
					bs61 |= 16;
				} else {
					bs61 &= -17;
				}
				break;
			case 4:
				if(v61) {
					bs61 |= 8;
				} else {
					bs61 &= -9;
				}
				break;
			case 5:
				if(v61) {
					bs61 |= 4;
				} else {
					bs61 &= -5;
				}
				break;
			case 6:
				if(v61) {
					bs61 |= 2;
				} else {
					bs61 &= -3;
				}
				break;
			case 7:
				if(v61) {
					bs61 |= 1;
				} else {
					bs61 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs61;
		var this63 = 0;
		var bs62 = this63;
		var l62 = "  *  ".length;
		var _g162 = 0;
		var _g72 = l62;
		while(_g162 < _g72) {
			var i62 = _g162++;
			var no62 = "  *  ".charCodeAt(i62);
			if(no62 == null) {
				break;
			}
			var v62;
			switch(no62) {
			case 32:
				v62 = false;
				break;
			case 42:
				v62 = true;
				break;
			case 48:
				v62 = false;
				break;
			case 49:
				v62 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i62)));
			}
			switch(i62 - (l62 - 8)) {
			case 0:
				if(v62) {
					bs62 |= 128;
				} else {
					bs62 &= -129;
				}
				break;
			case 1:
				if(v62) {
					bs62 |= 64;
				} else {
					bs62 &= -65;
				}
				break;
			case 2:
				if(v62) {
					bs62 |= 32;
				} else {
					bs62 &= -33;
				}
				break;
			case 3:
				if(v62) {
					bs62 |= 16;
				} else {
					bs62 &= -17;
				}
				break;
			case 4:
				if(v62) {
					bs62 |= 8;
				} else {
					bs62 &= -9;
				}
				break;
			case 5:
				if(v62) {
					bs62 |= 4;
				} else {
					bs62 &= -5;
				}
				break;
			case 6:
				if(v62) {
					bs62 |= 2;
				} else {
					bs62 &= -3;
				}
				break;
			case 7:
				if(v62) {
					bs62 |= 1;
				} else {
					bs62 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs62;
		break;
	case 41:
		var this64 = 0;
		var bs63 = this64;
		var l63 = "  *  ".length;
		var _g163 = 0;
		var _g73 = l63;
		while(_g163 < _g73) {
			var i63 = _g163++;
			var no63 = "  *  ".charCodeAt(i63);
			if(no63 == null) {
				break;
			}
			var v63;
			switch(no63) {
			case 32:
				v63 = false;
				break;
			case 42:
				v63 = true;
				break;
			case 48:
				v63 = false;
				break;
			case 49:
				v63 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i63)));
			}
			switch(i63 - (l63 - 8)) {
			case 0:
				if(v63) {
					bs63 |= 128;
				} else {
					bs63 &= -129;
				}
				break;
			case 1:
				if(v63) {
					bs63 |= 64;
				} else {
					bs63 &= -65;
				}
				break;
			case 2:
				if(v63) {
					bs63 |= 32;
				} else {
					bs63 &= -33;
				}
				break;
			case 3:
				if(v63) {
					bs63 |= 16;
				} else {
					bs63 &= -17;
				}
				break;
			case 4:
				if(v63) {
					bs63 |= 8;
				} else {
					bs63 &= -9;
				}
				break;
			case 5:
				if(v63) {
					bs63 |= 4;
				} else {
					bs63 &= -5;
				}
				break;
			case 6:
				if(v63) {
					bs63 |= 2;
				} else {
					bs63 &= -3;
				}
				break;
			case 7:
				if(v63) {
					bs63 |= 1;
				} else {
					bs63 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs63;
		var this65 = 0;
		var bs64 = this65;
		var l64 = "   * ".length;
		var _g164 = 0;
		var _g74 = l64;
		while(_g164 < _g74) {
			var i64 = _g164++;
			var no64 = "   * ".charCodeAt(i64);
			if(no64 == null) {
				break;
			}
			var v64;
			switch(no64) {
			case 32:
				v64 = false;
				break;
			case 42:
				v64 = true;
				break;
			case 48:
				v64 = false;
				break;
			case 49:
				v64 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i64)));
			}
			switch(i64 - (l64 - 8)) {
			case 0:
				if(v64) {
					bs64 |= 128;
				} else {
					bs64 &= -129;
				}
				break;
			case 1:
				if(v64) {
					bs64 |= 64;
				} else {
					bs64 &= -65;
				}
				break;
			case 2:
				if(v64) {
					bs64 |= 32;
				} else {
					bs64 &= -33;
				}
				break;
			case 3:
				if(v64) {
					bs64 |= 16;
				} else {
					bs64 &= -17;
				}
				break;
			case 4:
				if(v64) {
					bs64 |= 8;
				} else {
					bs64 &= -9;
				}
				break;
			case 5:
				if(v64) {
					bs64 |= 4;
				} else {
					bs64 &= -5;
				}
				break;
			case 6:
				if(v64) {
					bs64 |= 2;
				} else {
					bs64 &= -3;
				}
				break;
			case 7:
				if(v64) {
					bs64 |= 1;
				} else {
					bs64 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs64;
		var this66 = 0;
		var bs65 = this66;
		var l65 = "    *".length;
		var _g165 = 0;
		var _g75 = l65;
		while(_g165 < _g75) {
			var i65 = _g165++;
			var no65 = "    *".charCodeAt(i65);
			if(no65 == null) {
				break;
			}
			var v65;
			switch(no65) {
			case 32:
				v65 = false;
				break;
			case 42:
				v65 = true;
				break;
			case 48:
				v65 = false;
				break;
			case 49:
				v65 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i65)));
			}
			switch(i65 - (l65 - 8)) {
			case 0:
				if(v65) {
					bs65 |= 128;
				} else {
					bs65 &= -129;
				}
				break;
			case 1:
				if(v65) {
					bs65 |= 64;
				} else {
					bs65 &= -65;
				}
				break;
			case 2:
				if(v65) {
					bs65 |= 32;
				} else {
					bs65 &= -33;
				}
				break;
			case 3:
				if(v65) {
					bs65 |= 16;
				} else {
					bs65 &= -17;
				}
				break;
			case 4:
				if(v65) {
					bs65 |= 8;
				} else {
					bs65 &= -9;
				}
				break;
			case 5:
				if(v65) {
					bs65 |= 4;
				} else {
					bs65 &= -5;
				}
				break;
			case 6:
				if(v65) {
					bs65 |= 2;
				} else {
					bs65 &= -3;
				}
				break;
			case 7:
				if(v65) {
					bs65 |= 1;
				} else {
					bs65 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs65;
		var this67 = 0;
		var bs66 = this67;
		var l66 = "    *".length;
		var _g166 = 0;
		var _g76 = l66;
		while(_g166 < _g76) {
			var i66 = _g166++;
			var no66 = "    *".charCodeAt(i66);
			if(no66 == null) {
				break;
			}
			var v66;
			switch(no66) {
			case 32:
				v66 = false;
				break;
			case 42:
				v66 = true;
				break;
			case 48:
				v66 = false;
				break;
			case 49:
				v66 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i66)));
			}
			switch(i66 - (l66 - 8)) {
			case 0:
				if(v66) {
					bs66 |= 128;
				} else {
					bs66 &= -129;
				}
				break;
			case 1:
				if(v66) {
					bs66 |= 64;
				} else {
					bs66 &= -65;
				}
				break;
			case 2:
				if(v66) {
					bs66 |= 32;
				} else {
					bs66 &= -33;
				}
				break;
			case 3:
				if(v66) {
					bs66 |= 16;
				} else {
					bs66 &= -17;
				}
				break;
			case 4:
				if(v66) {
					bs66 |= 8;
				} else {
					bs66 &= -9;
				}
				break;
			case 5:
				if(v66) {
					bs66 |= 4;
				} else {
					bs66 &= -5;
				}
				break;
			case 6:
				if(v66) {
					bs66 |= 2;
				} else {
					bs66 &= -3;
				}
				break;
			case 7:
				if(v66) {
					bs66 |= 1;
				} else {
					bs66 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs66;
		var this68 = 0;
		var bs67 = this68;
		var l67 = "    *".length;
		var _g167 = 0;
		var _g77 = l67;
		while(_g167 < _g77) {
			var i67 = _g167++;
			var no67 = "    *".charCodeAt(i67);
			if(no67 == null) {
				break;
			}
			var v67;
			switch(no67) {
			case 32:
				v67 = false;
				break;
			case 42:
				v67 = true;
				break;
			case 48:
				v67 = false;
				break;
			case 49:
				v67 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i67)));
			}
			switch(i67 - (l67 - 8)) {
			case 0:
				if(v67) {
					bs67 |= 128;
				} else {
					bs67 &= -129;
				}
				break;
			case 1:
				if(v67) {
					bs67 |= 64;
				} else {
					bs67 &= -65;
				}
				break;
			case 2:
				if(v67) {
					bs67 |= 32;
				} else {
					bs67 &= -33;
				}
				break;
			case 3:
				if(v67) {
					bs67 |= 16;
				} else {
					bs67 &= -17;
				}
				break;
			case 4:
				if(v67) {
					bs67 |= 8;
				} else {
					bs67 &= -9;
				}
				break;
			case 5:
				if(v67) {
					bs67 |= 4;
				} else {
					bs67 &= -5;
				}
				break;
			case 6:
				if(v67) {
					bs67 |= 2;
				} else {
					bs67 &= -3;
				}
				break;
			case 7:
				if(v67) {
					bs67 |= 1;
				} else {
					bs67 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs67;
		var this69 = 0;
		var bs68 = this69;
		var l68 = "   * ".length;
		var _g168 = 0;
		var _g78 = l68;
		while(_g168 < _g78) {
			var i68 = _g168++;
			var no68 = "   * ".charCodeAt(i68);
			if(no68 == null) {
				break;
			}
			var v68;
			switch(no68) {
			case 32:
				v68 = false;
				break;
			case 42:
				v68 = true;
				break;
			case 48:
				v68 = false;
				break;
			case 49:
				v68 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i68)));
			}
			switch(i68 - (l68 - 8)) {
			case 0:
				if(v68) {
					bs68 |= 128;
				} else {
					bs68 &= -129;
				}
				break;
			case 1:
				if(v68) {
					bs68 |= 64;
				} else {
					bs68 &= -65;
				}
				break;
			case 2:
				if(v68) {
					bs68 |= 32;
				} else {
					bs68 &= -33;
				}
				break;
			case 3:
				if(v68) {
					bs68 |= 16;
				} else {
					bs68 &= -17;
				}
				break;
			case 4:
				if(v68) {
					bs68 |= 8;
				} else {
					bs68 &= -9;
				}
				break;
			case 5:
				if(v68) {
					bs68 |= 4;
				} else {
					bs68 &= -5;
				}
				break;
			case 6:
				if(v68) {
					bs68 |= 2;
				} else {
					bs68 &= -3;
				}
				break;
			case 7:
				if(v68) {
					bs68 |= 1;
				} else {
					bs68 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs68;
		var this70 = 0;
		var bs69 = this70;
		var l69 = "  *  ".length;
		var _g169 = 0;
		var _g79 = l69;
		while(_g169 < _g79) {
			var i69 = _g169++;
			var no69 = "  *  ".charCodeAt(i69);
			if(no69 == null) {
				break;
			}
			var v69;
			switch(no69) {
			case 32:
				v69 = false;
				break;
			case 42:
				v69 = true;
				break;
			case 48:
				v69 = false;
				break;
			case 49:
				v69 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i69)));
			}
			switch(i69 - (l69 - 8)) {
			case 0:
				if(v69) {
					bs69 |= 128;
				} else {
					bs69 &= -129;
				}
				break;
			case 1:
				if(v69) {
					bs69 |= 64;
				} else {
					bs69 &= -65;
				}
				break;
			case 2:
				if(v69) {
					bs69 |= 32;
				} else {
					bs69 &= -33;
				}
				break;
			case 3:
				if(v69) {
					bs69 |= 16;
				} else {
					bs69 &= -17;
				}
				break;
			case 4:
				if(v69) {
					bs69 |= 8;
				} else {
					bs69 &= -9;
				}
				break;
			case 5:
				if(v69) {
					bs69 |= 4;
				} else {
					bs69 &= -5;
				}
				break;
			case 6:
				if(v69) {
					bs69 |= 2;
				} else {
					bs69 &= -3;
				}
				break;
			case 7:
				if(v69) {
					bs69 |= 1;
				} else {
					bs69 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs69;
		break;
	case 42:
		var this71 = 0;
		var bs70 = this71;
		var l70 = "  *  ".length;
		var _g170 = 0;
		var _g80 = l70;
		while(_g170 < _g80) {
			var i70 = _g170++;
			var no70 = "  *  ".charCodeAt(i70);
			if(no70 == null) {
				break;
			}
			var v70;
			switch(no70) {
			case 32:
				v70 = false;
				break;
			case 42:
				v70 = true;
				break;
			case 48:
				v70 = false;
				break;
			case 49:
				v70 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i70)));
			}
			switch(i70 - (l70 - 8)) {
			case 0:
				if(v70) {
					bs70 |= 128;
				} else {
					bs70 &= -129;
				}
				break;
			case 1:
				if(v70) {
					bs70 |= 64;
				} else {
					bs70 &= -65;
				}
				break;
			case 2:
				if(v70) {
					bs70 |= 32;
				} else {
					bs70 &= -33;
				}
				break;
			case 3:
				if(v70) {
					bs70 |= 16;
				} else {
					bs70 &= -17;
				}
				break;
			case 4:
				if(v70) {
					bs70 |= 8;
				} else {
					bs70 &= -9;
				}
				break;
			case 5:
				if(v70) {
					bs70 |= 4;
				} else {
					bs70 &= -5;
				}
				break;
			case 6:
				if(v70) {
					bs70 |= 2;
				} else {
					bs70 &= -3;
				}
				break;
			case 7:
				if(v70) {
					bs70 |= 1;
				} else {
					bs70 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs70;
		var this72 = 0;
		var bs71 = this72;
		var l71 = "  *  ".length;
		var _g171 = 0;
		var _g81 = l71;
		while(_g171 < _g81) {
			var i71 = _g171++;
			var no71 = "  *  ".charCodeAt(i71);
			if(no71 == null) {
				break;
			}
			var v71;
			switch(no71) {
			case 32:
				v71 = false;
				break;
			case 42:
				v71 = true;
				break;
			case 48:
				v71 = false;
				break;
			case 49:
				v71 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i71)));
			}
			switch(i71 - (l71 - 8)) {
			case 0:
				if(v71) {
					bs71 |= 128;
				} else {
					bs71 &= -129;
				}
				break;
			case 1:
				if(v71) {
					bs71 |= 64;
				} else {
					bs71 &= -65;
				}
				break;
			case 2:
				if(v71) {
					bs71 |= 32;
				} else {
					bs71 &= -33;
				}
				break;
			case 3:
				if(v71) {
					bs71 |= 16;
				} else {
					bs71 &= -17;
				}
				break;
			case 4:
				if(v71) {
					bs71 |= 8;
				} else {
					bs71 &= -9;
				}
				break;
			case 5:
				if(v71) {
					bs71 |= 4;
				} else {
					bs71 &= -5;
				}
				break;
			case 6:
				if(v71) {
					bs71 |= 2;
				} else {
					bs71 &= -3;
				}
				break;
			case 7:
				if(v71) {
					bs71 |= 1;
				} else {
					bs71 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs71;
		var this73 = 0;
		var bs72 = this73;
		var l72 = "* * *".length;
		var _g172 = 0;
		var _g82 = l72;
		while(_g172 < _g82) {
			var i72 = _g172++;
			var no72 = "* * *".charCodeAt(i72);
			if(no72 == null) {
				break;
			}
			var v72;
			switch(no72) {
			case 32:
				v72 = false;
				break;
			case 42:
				v72 = true;
				break;
			case 48:
				v72 = false;
				break;
			case 49:
				v72 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i72)));
			}
			switch(i72 - (l72 - 8)) {
			case 0:
				if(v72) {
					bs72 |= 128;
				} else {
					bs72 &= -129;
				}
				break;
			case 1:
				if(v72) {
					bs72 |= 64;
				} else {
					bs72 &= -65;
				}
				break;
			case 2:
				if(v72) {
					bs72 |= 32;
				} else {
					bs72 &= -33;
				}
				break;
			case 3:
				if(v72) {
					bs72 |= 16;
				} else {
					bs72 &= -17;
				}
				break;
			case 4:
				if(v72) {
					bs72 |= 8;
				} else {
					bs72 &= -9;
				}
				break;
			case 5:
				if(v72) {
					bs72 |= 4;
				} else {
					bs72 &= -5;
				}
				break;
			case 6:
				if(v72) {
					bs72 |= 2;
				} else {
					bs72 &= -3;
				}
				break;
			case 7:
				if(v72) {
					bs72 |= 1;
				} else {
					bs72 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs72;
		var this74 = 0;
		var bs73 = this74;
		var l73 = " *** ".length;
		var _g173 = 0;
		var _g83 = l73;
		while(_g173 < _g83) {
			var i73 = _g173++;
			var no73 = " *** ".charCodeAt(i73);
			if(no73 == null) {
				break;
			}
			var v73;
			switch(no73) {
			case 32:
				v73 = false;
				break;
			case 42:
				v73 = true;
				break;
			case 48:
				v73 = false;
				break;
			case 49:
				v73 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i73)));
			}
			switch(i73 - (l73 - 8)) {
			case 0:
				if(v73) {
					bs73 |= 128;
				} else {
					bs73 &= -129;
				}
				break;
			case 1:
				if(v73) {
					bs73 |= 64;
				} else {
					bs73 &= -65;
				}
				break;
			case 2:
				if(v73) {
					bs73 |= 32;
				} else {
					bs73 &= -33;
				}
				break;
			case 3:
				if(v73) {
					bs73 |= 16;
				} else {
					bs73 &= -17;
				}
				break;
			case 4:
				if(v73) {
					bs73 |= 8;
				} else {
					bs73 &= -9;
				}
				break;
			case 5:
				if(v73) {
					bs73 |= 4;
				} else {
					bs73 &= -5;
				}
				break;
			case 6:
				if(v73) {
					bs73 |= 2;
				} else {
					bs73 &= -3;
				}
				break;
			case 7:
				if(v73) {
					bs73 |= 1;
				} else {
					bs73 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs73;
		var this75 = 0;
		var bs74 = this75;
		var l74 = "* * *".length;
		var _g174 = 0;
		var _g84 = l74;
		while(_g174 < _g84) {
			var i74 = _g174++;
			var no74 = "* * *".charCodeAt(i74);
			if(no74 == null) {
				break;
			}
			var v74;
			switch(no74) {
			case 32:
				v74 = false;
				break;
			case 42:
				v74 = true;
				break;
			case 48:
				v74 = false;
				break;
			case 49:
				v74 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i74)));
			}
			switch(i74 - (l74 - 8)) {
			case 0:
				if(v74) {
					bs74 |= 128;
				} else {
					bs74 &= -129;
				}
				break;
			case 1:
				if(v74) {
					bs74 |= 64;
				} else {
					bs74 &= -65;
				}
				break;
			case 2:
				if(v74) {
					bs74 |= 32;
				} else {
					bs74 &= -33;
				}
				break;
			case 3:
				if(v74) {
					bs74 |= 16;
				} else {
					bs74 &= -17;
				}
				break;
			case 4:
				if(v74) {
					bs74 |= 8;
				} else {
					bs74 &= -9;
				}
				break;
			case 5:
				if(v74) {
					bs74 |= 4;
				} else {
					bs74 &= -5;
				}
				break;
			case 6:
				if(v74) {
					bs74 |= 2;
				} else {
					bs74 &= -3;
				}
				break;
			case 7:
				if(v74) {
					bs74 |= 1;
				} else {
					bs74 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs74;
		var this76 = 0;
		var bs75 = this76;
		var l75 = "  *  ".length;
		var _g175 = 0;
		var _g85 = l75;
		while(_g175 < _g85) {
			var i75 = _g175++;
			var no75 = "  *  ".charCodeAt(i75);
			if(no75 == null) {
				break;
			}
			var v75;
			switch(no75) {
			case 32:
				v75 = false;
				break;
			case 42:
				v75 = true;
				break;
			case 48:
				v75 = false;
				break;
			case 49:
				v75 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i75)));
			}
			switch(i75 - (l75 - 8)) {
			case 0:
				if(v75) {
					bs75 |= 128;
				} else {
					bs75 &= -129;
				}
				break;
			case 1:
				if(v75) {
					bs75 |= 64;
				} else {
					bs75 &= -65;
				}
				break;
			case 2:
				if(v75) {
					bs75 |= 32;
				} else {
					bs75 &= -33;
				}
				break;
			case 3:
				if(v75) {
					bs75 |= 16;
				} else {
					bs75 &= -17;
				}
				break;
			case 4:
				if(v75) {
					bs75 |= 8;
				} else {
					bs75 &= -9;
				}
				break;
			case 5:
				if(v75) {
					bs75 |= 4;
				} else {
					bs75 &= -5;
				}
				break;
			case 6:
				if(v75) {
					bs75 |= 2;
				} else {
					bs75 &= -3;
				}
				break;
			case 7:
				if(v75) {
					bs75 |= 1;
				} else {
					bs75 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs75;
		var this77 = 0;
		var bs76 = this77;
		var l76 = "     ".length;
		var _g176 = 0;
		var _g86 = l76;
		while(_g176 < _g86) {
			var i76 = _g176++;
			var no76 = "     ".charCodeAt(i76);
			if(no76 == null) {
				break;
			}
			var v76;
			switch(no76) {
			case 32:
				v76 = false;
				break;
			case 42:
				v76 = true;
				break;
			case 48:
				v76 = false;
				break;
			case 49:
				v76 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i76)));
			}
			switch(i76 - (l76 - 8)) {
			case 0:
				if(v76) {
					bs76 |= 128;
				} else {
					bs76 &= -129;
				}
				break;
			case 1:
				if(v76) {
					bs76 |= 64;
				} else {
					bs76 &= -65;
				}
				break;
			case 2:
				if(v76) {
					bs76 |= 32;
				} else {
					bs76 &= -33;
				}
				break;
			case 3:
				if(v76) {
					bs76 |= 16;
				} else {
					bs76 &= -17;
				}
				break;
			case 4:
				if(v76) {
					bs76 |= 8;
				} else {
					bs76 &= -9;
				}
				break;
			case 5:
				if(v76) {
					bs76 |= 4;
				} else {
					bs76 &= -5;
				}
				break;
			case 6:
				if(v76) {
					bs76 |= 2;
				} else {
					bs76 &= -3;
				}
				break;
			case 7:
				if(v76) {
					bs76 |= 1;
				} else {
					bs76 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs76;
		break;
	case 43:
		var this78 = 0;
		var bs77 = this78;
		var l77 = "     ".length;
		var _g177 = 0;
		var _g87 = l77;
		while(_g177 < _g87) {
			var i77 = _g177++;
			var no77 = "     ".charCodeAt(i77);
			if(no77 == null) {
				break;
			}
			var v77;
			switch(no77) {
			case 32:
				v77 = false;
				break;
			case 42:
				v77 = true;
				break;
			case 48:
				v77 = false;
				break;
			case 49:
				v77 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i77)));
			}
			switch(i77 - (l77 - 8)) {
			case 0:
				if(v77) {
					bs77 |= 128;
				} else {
					bs77 &= -129;
				}
				break;
			case 1:
				if(v77) {
					bs77 |= 64;
				} else {
					bs77 &= -65;
				}
				break;
			case 2:
				if(v77) {
					bs77 |= 32;
				} else {
					bs77 &= -33;
				}
				break;
			case 3:
				if(v77) {
					bs77 |= 16;
				} else {
					bs77 &= -17;
				}
				break;
			case 4:
				if(v77) {
					bs77 |= 8;
				} else {
					bs77 &= -9;
				}
				break;
			case 5:
				if(v77) {
					bs77 |= 4;
				} else {
					bs77 &= -5;
				}
				break;
			case 6:
				if(v77) {
					bs77 |= 2;
				} else {
					bs77 &= -3;
				}
				break;
			case 7:
				if(v77) {
					bs77 |= 1;
				} else {
					bs77 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs77;
		var this79 = 0;
		var bs78 = this79;
		var l78 = "  *  ".length;
		var _g178 = 0;
		var _g88 = l78;
		while(_g178 < _g88) {
			var i78 = _g178++;
			var no78 = "  *  ".charCodeAt(i78);
			if(no78 == null) {
				break;
			}
			var v78;
			switch(no78) {
			case 32:
				v78 = false;
				break;
			case 42:
				v78 = true;
				break;
			case 48:
				v78 = false;
				break;
			case 49:
				v78 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i78)));
			}
			switch(i78 - (l78 - 8)) {
			case 0:
				if(v78) {
					bs78 |= 128;
				} else {
					bs78 &= -129;
				}
				break;
			case 1:
				if(v78) {
					bs78 |= 64;
				} else {
					bs78 &= -65;
				}
				break;
			case 2:
				if(v78) {
					bs78 |= 32;
				} else {
					bs78 &= -33;
				}
				break;
			case 3:
				if(v78) {
					bs78 |= 16;
				} else {
					bs78 &= -17;
				}
				break;
			case 4:
				if(v78) {
					bs78 |= 8;
				} else {
					bs78 &= -9;
				}
				break;
			case 5:
				if(v78) {
					bs78 |= 4;
				} else {
					bs78 &= -5;
				}
				break;
			case 6:
				if(v78) {
					bs78 |= 2;
				} else {
					bs78 &= -3;
				}
				break;
			case 7:
				if(v78) {
					bs78 |= 1;
				} else {
					bs78 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs78;
		var this80 = 0;
		var bs79 = this80;
		var l79 = "  *  ".length;
		var _g179 = 0;
		var _g89 = l79;
		while(_g179 < _g89) {
			var i79 = _g179++;
			var no79 = "  *  ".charCodeAt(i79);
			if(no79 == null) {
				break;
			}
			var v79;
			switch(no79) {
			case 32:
				v79 = false;
				break;
			case 42:
				v79 = true;
				break;
			case 48:
				v79 = false;
				break;
			case 49:
				v79 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i79)));
			}
			switch(i79 - (l79 - 8)) {
			case 0:
				if(v79) {
					bs79 |= 128;
				} else {
					bs79 &= -129;
				}
				break;
			case 1:
				if(v79) {
					bs79 |= 64;
				} else {
					bs79 &= -65;
				}
				break;
			case 2:
				if(v79) {
					bs79 |= 32;
				} else {
					bs79 &= -33;
				}
				break;
			case 3:
				if(v79) {
					bs79 |= 16;
				} else {
					bs79 &= -17;
				}
				break;
			case 4:
				if(v79) {
					bs79 |= 8;
				} else {
					bs79 &= -9;
				}
				break;
			case 5:
				if(v79) {
					bs79 |= 4;
				} else {
					bs79 &= -5;
				}
				break;
			case 6:
				if(v79) {
					bs79 |= 2;
				} else {
					bs79 &= -3;
				}
				break;
			case 7:
				if(v79) {
					bs79 |= 1;
				} else {
					bs79 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs79;
		var this81 = 0;
		var bs80 = this81;
		var l80 = "*****".length;
		var _g180 = 0;
		var _g90 = l80;
		while(_g180 < _g90) {
			var i80 = _g180++;
			var no80 = "*****".charCodeAt(i80);
			if(no80 == null) {
				break;
			}
			var v80;
			switch(no80) {
			case 32:
				v80 = false;
				break;
			case 42:
				v80 = true;
				break;
			case 48:
				v80 = false;
				break;
			case 49:
				v80 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i80)));
			}
			switch(i80 - (l80 - 8)) {
			case 0:
				if(v80) {
					bs80 |= 128;
				} else {
					bs80 &= -129;
				}
				break;
			case 1:
				if(v80) {
					bs80 |= 64;
				} else {
					bs80 &= -65;
				}
				break;
			case 2:
				if(v80) {
					bs80 |= 32;
				} else {
					bs80 &= -33;
				}
				break;
			case 3:
				if(v80) {
					bs80 |= 16;
				} else {
					bs80 &= -17;
				}
				break;
			case 4:
				if(v80) {
					bs80 |= 8;
				} else {
					bs80 &= -9;
				}
				break;
			case 5:
				if(v80) {
					bs80 |= 4;
				} else {
					bs80 &= -5;
				}
				break;
			case 6:
				if(v80) {
					bs80 |= 2;
				} else {
					bs80 &= -3;
				}
				break;
			case 7:
				if(v80) {
					bs80 |= 1;
				} else {
					bs80 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs80;
		var this82 = 0;
		var bs81 = this82;
		var l81 = "  *  ".length;
		var _g181 = 0;
		var _g91 = l81;
		while(_g181 < _g91) {
			var i81 = _g181++;
			var no81 = "  *  ".charCodeAt(i81);
			if(no81 == null) {
				break;
			}
			var v81;
			switch(no81) {
			case 32:
				v81 = false;
				break;
			case 42:
				v81 = true;
				break;
			case 48:
				v81 = false;
				break;
			case 49:
				v81 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i81)));
			}
			switch(i81 - (l81 - 8)) {
			case 0:
				if(v81) {
					bs81 |= 128;
				} else {
					bs81 &= -129;
				}
				break;
			case 1:
				if(v81) {
					bs81 |= 64;
				} else {
					bs81 &= -65;
				}
				break;
			case 2:
				if(v81) {
					bs81 |= 32;
				} else {
					bs81 &= -33;
				}
				break;
			case 3:
				if(v81) {
					bs81 |= 16;
				} else {
					bs81 &= -17;
				}
				break;
			case 4:
				if(v81) {
					bs81 |= 8;
				} else {
					bs81 &= -9;
				}
				break;
			case 5:
				if(v81) {
					bs81 |= 4;
				} else {
					bs81 &= -5;
				}
				break;
			case 6:
				if(v81) {
					bs81 |= 2;
				} else {
					bs81 &= -3;
				}
				break;
			case 7:
				if(v81) {
					bs81 |= 1;
				} else {
					bs81 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs81;
		var this83 = 0;
		var bs82 = this83;
		var l82 = "  *  ".length;
		var _g182 = 0;
		var _g92 = l82;
		while(_g182 < _g92) {
			var i82 = _g182++;
			var no82 = "  *  ".charCodeAt(i82);
			if(no82 == null) {
				break;
			}
			var v82;
			switch(no82) {
			case 32:
				v82 = false;
				break;
			case 42:
				v82 = true;
				break;
			case 48:
				v82 = false;
				break;
			case 49:
				v82 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i82)));
			}
			switch(i82 - (l82 - 8)) {
			case 0:
				if(v82) {
					bs82 |= 128;
				} else {
					bs82 &= -129;
				}
				break;
			case 1:
				if(v82) {
					bs82 |= 64;
				} else {
					bs82 &= -65;
				}
				break;
			case 2:
				if(v82) {
					bs82 |= 32;
				} else {
					bs82 &= -33;
				}
				break;
			case 3:
				if(v82) {
					bs82 |= 16;
				} else {
					bs82 &= -17;
				}
				break;
			case 4:
				if(v82) {
					bs82 |= 8;
				} else {
					bs82 &= -9;
				}
				break;
			case 5:
				if(v82) {
					bs82 |= 4;
				} else {
					bs82 &= -5;
				}
				break;
			case 6:
				if(v82) {
					bs82 |= 2;
				} else {
					bs82 &= -3;
				}
				break;
			case 7:
				if(v82) {
					bs82 |= 1;
				} else {
					bs82 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs82;
		var this84 = 0;
		var bs83 = this84;
		var l83 = "     ".length;
		var _g183 = 0;
		var _g93 = l83;
		while(_g183 < _g93) {
			var i83 = _g183++;
			var no83 = "     ".charCodeAt(i83);
			if(no83 == null) {
				break;
			}
			var v83;
			switch(no83) {
			case 32:
				v83 = false;
				break;
			case 42:
				v83 = true;
				break;
			case 48:
				v83 = false;
				break;
			case 49:
				v83 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i83)));
			}
			switch(i83 - (l83 - 8)) {
			case 0:
				if(v83) {
					bs83 |= 128;
				} else {
					bs83 &= -129;
				}
				break;
			case 1:
				if(v83) {
					bs83 |= 64;
				} else {
					bs83 &= -65;
				}
				break;
			case 2:
				if(v83) {
					bs83 |= 32;
				} else {
					bs83 &= -33;
				}
				break;
			case 3:
				if(v83) {
					bs83 |= 16;
				} else {
					bs83 &= -17;
				}
				break;
			case 4:
				if(v83) {
					bs83 |= 8;
				} else {
					bs83 &= -9;
				}
				break;
			case 5:
				if(v83) {
					bs83 |= 4;
				} else {
					bs83 &= -5;
				}
				break;
			case 6:
				if(v83) {
					bs83 |= 2;
				} else {
					bs83 &= -3;
				}
				break;
			case 7:
				if(v83) {
					bs83 |= 1;
				} else {
					bs83 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs83;
		break;
	case 44:
		var this85 = 0;
		var bs84 = this85;
		var l84 = "     ".length;
		var _g184 = 0;
		var _g94 = l84;
		while(_g184 < _g94) {
			var i84 = _g184++;
			var no84 = "     ".charCodeAt(i84);
			if(no84 == null) {
				break;
			}
			var v84;
			switch(no84) {
			case 32:
				v84 = false;
				break;
			case 42:
				v84 = true;
				break;
			case 48:
				v84 = false;
				break;
			case 49:
				v84 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i84)));
			}
			switch(i84 - (l84 - 8)) {
			case 0:
				if(v84) {
					bs84 |= 128;
				} else {
					bs84 &= -129;
				}
				break;
			case 1:
				if(v84) {
					bs84 |= 64;
				} else {
					bs84 &= -65;
				}
				break;
			case 2:
				if(v84) {
					bs84 |= 32;
				} else {
					bs84 &= -33;
				}
				break;
			case 3:
				if(v84) {
					bs84 |= 16;
				} else {
					bs84 &= -17;
				}
				break;
			case 4:
				if(v84) {
					bs84 |= 8;
				} else {
					bs84 &= -9;
				}
				break;
			case 5:
				if(v84) {
					bs84 |= 4;
				} else {
					bs84 &= -5;
				}
				break;
			case 6:
				if(v84) {
					bs84 |= 2;
				} else {
					bs84 &= -3;
				}
				break;
			case 7:
				if(v84) {
					bs84 |= 1;
				} else {
					bs84 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs84;
		var this86 = 0;
		var bs85 = this86;
		var l85 = "     ".length;
		var _g185 = 0;
		var _g95 = l85;
		while(_g185 < _g95) {
			var i85 = _g185++;
			var no85 = "     ".charCodeAt(i85);
			if(no85 == null) {
				break;
			}
			var v85;
			switch(no85) {
			case 32:
				v85 = false;
				break;
			case 42:
				v85 = true;
				break;
			case 48:
				v85 = false;
				break;
			case 49:
				v85 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i85)));
			}
			switch(i85 - (l85 - 8)) {
			case 0:
				if(v85) {
					bs85 |= 128;
				} else {
					bs85 &= -129;
				}
				break;
			case 1:
				if(v85) {
					bs85 |= 64;
				} else {
					bs85 &= -65;
				}
				break;
			case 2:
				if(v85) {
					bs85 |= 32;
				} else {
					bs85 &= -33;
				}
				break;
			case 3:
				if(v85) {
					bs85 |= 16;
				} else {
					bs85 &= -17;
				}
				break;
			case 4:
				if(v85) {
					bs85 |= 8;
				} else {
					bs85 &= -9;
				}
				break;
			case 5:
				if(v85) {
					bs85 |= 4;
				} else {
					bs85 &= -5;
				}
				break;
			case 6:
				if(v85) {
					bs85 |= 2;
				} else {
					bs85 &= -3;
				}
				break;
			case 7:
				if(v85) {
					bs85 |= 1;
				} else {
					bs85 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs85;
		var this87 = 0;
		var bs86 = this87;
		var l86 = "     ".length;
		var _g186 = 0;
		var _g96 = l86;
		while(_g186 < _g96) {
			var i86 = _g186++;
			var no86 = "     ".charCodeAt(i86);
			if(no86 == null) {
				break;
			}
			var v86;
			switch(no86) {
			case 32:
				v86 = false;
				break;
			case 42:
				v86 = true;
				break;
			case 48:
				v86 = false;
				break;
			case 49:
				v86 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i86)));
			}
			switch(i86 - (l86 - 8)) {
			case 0:
				if(v86) {
					bs86 |= 128;
				} else {
					bs86 &= -129;
				}
				break;
			case 1:
				if(v86) {
					bs86 |= 64;
				} else {
					bs86 &= -65;
				}
				break;
			case 2:
				if(v86) {
					bs86 |= 32;
				} else {
					bs86 &= -33;
				}
				break;
			case 3:
				if(v86) {
					bs86 |= 16;
				} else {
					bs86 &= -17;
				}
				break;
			case 4:
				if(v86) {
					bs86 |= 8;
				} else {
					bs86 &= -9;
				}
				break;
			case 5:
				if(v86) {
					bs86 |= 4;
				} else {
					bs86 &= -5;
				}
				break;
			case 6:
				if(v86) {
					bs86 |= 2;
				} else {
					bs86 &= -3;
				}
				break;
			case 7:
				if(v86) {
					bs86 |= 1;
				} else {
					bs86 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs86;
		var this88 = 0;
		var bs87 = this88;
		var l87 = "     ".length;
		var _g187 = 0;
		var _g97 = l87;
		while(_g187 < _g97) {
			var i87 = _g187++;
			var no87 = "     ".charCodeAt(i87);
			if(no87 == null) {
				break;
			}
			var v87;
			switch(no87) {
			case 32:
				v87 = false;
				break;
			case 42:
				v87 = true;
				break;
			case 48:
				v87 = false;
				break;
			case 49:
				v87 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i87)));
			}
			switch(i87 - (l87 - 8)) {
			case 0:
				if(v87) {
					bs87 |= 128;
				} else {
					bs87 &= -129;
				}
				break;
			case 1:
				if(v87) {
					bs87 |= 64;
				} else {
					bs87 &= -65;
				}
				break;
			case 2:
				if(v87) {
					bs87 |= 32;
				} else {
					bs87 &= -33;
				}
				break;
			case 3:
				if(v87) {
					bs87 |= 16;
				} else {
					bs87 &= -17;
				}
				break;
			case 4:
				if(v87) {
					bs87 |= 8;
				} else {
					bs87 &= -9;
				}
				break;
			case 5:
				if(v87) {
					bs87 |= 4;
				} else {
					bs87 &= -5;
				}
				break;
			case 6:
				if(v87) {
					bs87 |= 2;
				} else {
					bs87 &= -3;
				}
				break;
			case 7:
				if(v87) {
					bs87 |= 1;
				} else {
					bs87 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs87;
		var this89 = 0;
		var bs88 = this89;
		var l88 = " **  ".length;
		var _g188 = 0;
		var _g98 = l88;
		while(_g188 < _g98) {
			var i88 = _g188++;
			var no88 = " **  ".charCodeAt(i88);
			if(no88 == null) {
				break;
			}
			var v88;
			switch(no88) {
			case 32:
				v88 = false;
				break;
			case 42:
				v88 = true;
				break;
			case 48:
				v88 = false;
				break;
			case 49:
				v88 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i88)));
			}
			switch(i88 - (l88 - 8)) {
			case 0:
				if(v88) {
					bs88 |= 128;
				} else {
					bs88 &= -129;
				}
				break;
			case 1:
				if(v88) {
					bs88 |= 64;
				} else {
					bs88 &= -65;
				}
				break;
			case 2:
				if(v88) {
					bs88 |= 32;
				} else {
					bs88 &= -33;
				}
				break;
			case 3:
				if(v88) {
					bs88 |= 16;
				} else {
					bs88 &= -17;
				}
				break;
			case 4:
				if(v88) {
					bs88 |= 8;
				} else {
					bs88 &= -9;
				}
				break;
			case 5:
				if(v88) {
					bs88 |= 4;
				} else {
					bs88 &= -5;
				}
				break;
			case 6:
				if(v88) {
					bs88 |= 2;
				} else {
					bs88 &= -3;
				}
				break;
			case 7:
				if(v88) {
					bs88 |= 1;
				} else {
					bs88 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs88;
		var this90 = 0;
		var bs89 = this90;
		var l89 = "  *  ".length;
		var _g189 = 0;
		var _g99 = l89;
		while(_g189 < _g99) {
			var i89 = _g189++;
			var no89 = "  *  ".charCodeAt(i89);
			if(no89 == null) {
				break;
			}
			var v89;
			switch(no89) {
			case 32:
				v89 = false;
				break;
			case 42:
				v89 = true;
				break;
			case 48:
				v89 = false;
				break;
			case 49:
				v89 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i89)));
			}
			switch(i89 - (l89 - 8)) {
			case 0:
				if(v89) {
					bs89 |= 128;
				} else {
					bs89 &= -129;
				}
				break;
			case 1:
				if(v89) {
					bs89 |= 64;
				} else {
					bs89 &= -65;
				}
				break;
			case 2:
				if(v89) {
					bs89 |= 32;
				} else {
					bs89 &= -33;
				}
				break;
			case 3:
				if(v89) {
					bs89 |= 16;
				} else {
					bs89 &= -17;
				}
				break;
			case 4:
				if(v89) {
					bs89 |= 8;
				} else {
					bs89 &= -9;
				}
				break;
			case 5:
				if(v89) {
					bs89 |= 4;
				} else {
					bs89 &= -5;
				}
				break;
			case 6:
				if(v89) {
					bs89 |= 2;
				} else {
					bs89 &= -3;
				}
				break;
			case 7:
				if(v89) {
					bs89 |= 1;
				} else {
					bs89 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs89;
		var this91 = 0;
		var bs90 = this91;
		var l90 = " *   ".length;
		var _g190 = 0;
		var _g100 = l90;
		while(_g190 < _g100) {
			var i90 = _g190++;
			var no90 = " *   ".charCodeAt(i90);
			if(no90 == null) {
				break;
			}
			var v90;
			switch(no90) {
			case 32:
				v90 = false;
				break;
			case 42:
				v90 = true;
				break;
			case 48:
				v90 = false;
				break;
			case 49:
				v90 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i90)));
			}
			switch(i90 - (l90 - 8)) {
			case 0:
				if(v90) {
					bs90 |= 128;
				} else {
					bs90 &= -129;
				}
				break;
			case 1:
				if(v90) {
					bs90 |= 64;
				} else {
					bs90 &= -65;
				}
				break;
			case 2:
				if(v90) {
					bs90 |= 32;
				} else {
					bs90 &= -33;
				}
				break;
			case 3:
				if(v90) {
					bs90 |= 16;
				} else {
					bs90 &= -17;
				}
				break;
			case 4:
				if(v90) {
					bs90 |= 8;
				} else {
					bs90 &= -9;
				}
				break;
			case 5:
				if(v90) {
					bs90 |= 4;
				} else {
					bs90 &= -5;
				}
				break;
			case 6:
				if(v90) {
					bs90 |= 2;
				} else {
					bs90 &= -3;
				}
				break;
			case 7:
				if(v90) {
					bs90 |= 1;
				} else {
					bs90 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs90;
		break;
	case 45:
		var this92 = 0;
		var bs91 = this92;
		var l91 = "     ".length;
		var _g191 = 0;
		var _g101 = l91;
		while(_g191 < _g101) {
			var i91 = _g191++;
			var no91 = "     ".charCodeAt(i91);
			if(no91 == null) {
				break;
			}
			var v91;
			switch(no91) {
			case 32:
				v91 = false;
				break;
			case 42:
				v91 = true;
				break;
			case 48:
				v91 = false;
				break;
			case 49:
				v91 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i91)));
			}
			switch(i91 - (l91 - 8)) {
			case 0:
				if(v91) {
					bs91 |= 128;
				} else {
					bs91 &= -129;
				}
				break;
			case 1:
				if(v91) {
					bs91 |= 64;
				} else {
					bs91 &= -65;
				}
				break;
			case 2:
				if(v91) {
					bs91 |= 32;
				} else {
					bs91 &= -33;
				}
				break;
			case 3:
				if(v91) {
					bs91 |= 16;
				} else {
					bs91 &= -17;
				}
				break;
			case 4:
				if(v91) {
					bs91 |= 8;
				} else {
					bs91 &= -9;
				}
				break;
			case 5:
				if(v91) {
					bs91 |= 4;
				} else {
					bs91 &= -5;
				}
				break;
			case 6:
				if(v91) {
					bs91 |= 2;
				} else {
					bs91 &= -3;
				}
				break;
			case 7:
				if(v91) {
					bs91 |= 1;
				} else {
					bs91 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs91;
		var this93 = 0;
		var bs92 = this93;
		var l92 = "     ".length;
		var _g192 = 0;
		var _g102 = l92;
		while(_g192 < _g102) {
			var i92 = _g192++;
			var no92 = "     ".charCodeAt(i92);
			if(no92 == null) {
				break;
			}
			var v92;
			switch(no92) {
			case 32:
				v92 = false;
				break;
			case 42:
				v92 = true;
				break;
			case 48:
				v92 = false;
				break;
			case 49:
				v92 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i92)));
			}
			switch(i92 - (l92 - 8)) {
			case 0:
				if(v92) {
					bs92 |= 128;
				} else {
					bs92 &= -129;
				}
				break;
			case 1:
				if(v92) {
					bs92 |= 64;
				} else {
					bs92 &= -65;
				}
				break;
			case 2:
				if(v92) {
					bs92 |= 32;
				} else {
					bs92 &= -33;
				}
				break;
			case 3:
				if(v92) {
					bs92 |= 16;
				} else {
					bs92 &= -17;
				}
				break;
			case 4:
				if(v92) {
					bs92 |= 8;
				} else {
					bs92 &= -9;
				}
				break;
			case 5:
				if(v92) {
					bs92 |= 4;
				} else {
					bs92 &= -5;
				}
				break;
			case 6:
				if(v92) {
					bs92 |= 2;
				} else {
					bs92 &= -3;
				}
				break;
			case 7:
				if(v92) {
					bs92 |= 1;
				} else {
					bs92 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs92;
		var this94 = 0;
		var bs93 = this94;
		var l93 = "     ".length;
		var _g193 = 0;
		var _g103 = l93;
		while(_g193 < _g103) {
			var i93 = _g193++;
			var no93 = "     ".charCodeAt(i93);
			if(no93 == null) {
				break;
			}
			var v93;
			switch(no93) {
			case 32:
				v93 = false;
				break;
			case 42:
				v93 = true;
				break;
			case 48:
				v93 = false;
				break;
			case 49:
				v93 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i93)));
			}
			switch(i93 - (l93 - 8)) {
			case 0:
				if(v93) {
					bs93 |= 128;
				} else {
					bs93 &= -129;
				}
				break;
			case 1:
				if(v93) {
					bs93 |= 64;
				} else {
					bs93 &= -65;
				}
				break;
			case 2:
				if(v93) {
					bs93 |= 32;
				} else {
					bs93 &= -33;
				}
				break;
			case 3:
				if(v93) {
					bs93 |= 16;
				} else {
					bs93 &= -17;
				}
				break;
			case 4:
				if(v93) {
					bs93 |= 8;
				} else {
					bs93 &= -9;
				}
				break;
			case 5:
				if(v93) {
					bs93 |= 4;
				} else {
					bs93 &= -5;
				}
				break;
			case 6:
				if(v93) {
					bs93 |= 2;
				} else {
					bs93 &= -3;
				}
				break;
			case 7:
				if(v93) {
					bs93 |= 1;
				} else {
					bs93 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs93;
		var this95 = 0;
		var bs94 = this95;
		var l94 = "*****".length;
		var _g194 = 0;
		var _g104 = l94;
		while(_g194 < _g104) {
			var i94 = _g194++;
			var no94 = "*****".charCodeAt(i94);
			if(no94 == null) {
				break;
			}
			var v94;
			switch(no94) {
			case 32:
				v94 = false;
				break;
			case 42:
				v94 = true;
				break;
			case 48:
				v94 = false;
				break;
			case 49:
				v94 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i94)));
			}
			switch(i94 - (l94 - 8)) {
			case 0:
				if(v94) {
					bs94 |= 128;
				} else {
					bs94 &= -129;
				}
				break;
			case 1:
				if(v94) {
					bs94 |= 64;
				} else {
					bs94 &= -65;
				}
				break;
			case 2:
				if(v94) {
					bs94 |= 32;
				} else {
					bs94 &= -33;
				}
				break;
			case 3:
				if(v94) {
					bs94 |= 16;
				} else {
					bs94 &= -17;
				}
				break;
			case 4:
				if(v94) {
					bs94 |= 8;
				} else {
					bs94 &= -9;
				}
				break;
			case 5:
				if(v94) {
					bs94 |= 4;
				} else {
					bs94 &= -5;
				}
				break;
			case 6:
				if(v94) {
					bs94 |= 2;
				} else {
					bs94 &= -3;
				}
				break;
			case 7:
				if(v94) {
					bs94 |= 1;
				} else {
					bs94 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs94;
		var this96 = 0;
		var bs95 = this96;
		var l95 = "     ".length;
		var _g195 = 0;
		var _g105 = l95;
		while(_g195 < _g105) {
			var i95 = _g195++;
			var no95 = "     ".charCodeAt(i95);
			if(no95 == null) {
				break;
			}
			var v95;
			switch(no95) {
			case 32:
				v95 = false;
				break;
			case 42:
				v95 = true;
				break;
			case 48:
				v95 = false;
				break;
			case 49:
				v95 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i95)));
			}
			switch(i95 - (l95 - 8)) {
			case 0:
				if(v95) {
					bs95 |= 128;
				} else {
					bs95 &= -129;
				}
				break;
			case 1:
				if(v95) {
					bs95 |= 64;
				} else {
					bs95 &= -65;
				}
				break;
			case 2:
				if(v95) {
					bs95 |= 32;
				} else {
					bs95 &= -33;
				}
				break;
			case 3:
				if(v95) {
					bs95 |= 16;
				} else {
					bs95 &= -17;
				}
				break;
			case 4:
				if(v95) {
					bs95 |= 8;
				} else {
					bs95 &= -9;
				}
				break;
			case 5:
				if(v95) {
					bs95 |= 4;
				} else {
					bs95 &= -5;
				}
				break;
			case 6:
				if(v95) {
					bs95 |= 2;
				} else {
					bs95 &= -3;
				}
				break;
			case 7:
				if(v95) {
					bs95 |= 1;
				} else {
					bs95 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs95;
		var this97 = 0;
		var bs96 = this97;
		var l96 = "     ".length;
		var _g196 = 0;
		var _g106 = l96;
		while(_g196 < _g106) {
			var i96 = _g196++;
			var no96 = "     ".charCodeAt(i96);
			if(no96 == null) {
				break;
			}
			var v96;
			switch(no96) {
			case 32:
				v96 = false;
				break;
			case 42:
				v96 = true;
				break;
			case 48:
				v96 = false;
				break;
			case 49:
				v96 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i96)));
			}
			switch(i96 - (l96 - 8)) {
			case 0:
				if(v96) {
					bs96 |= 128;
				} else {
					bs96 &= -129;
				}
				break;
			case 1:
				if(v96) {
					bs96 |= 64;
				} else {
					bs96 &= -65;
				}
				break;
			case 2:
				if(v96) {
					bs96 |= 32;
				} else {
					bs96 &= -33;
				}
				break;
			case 3:
				if(v96) {
					bs96 |= 16;
				} else {
					bs96 &= -17;
				}
				break;
			case 4:
				if(v96) {
					bs96 |= 8;
				} else {
					bs96 &= -9;
				}
				break;
			case 5:
				if(v96) {
					bs96 |= 4;
				} else {
					bs96 &= -5;
				}
				break;
			case 6:
				if(v96) {
					bs96 |= 2;
				} else {
					bs96 &= -3;
				}
				break;
			case 7:
				if(v96) {
					bs96 |= 1;
				} else {
					bs96 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs96;
		var this98 = 0;
		var bs97 = this98;
		var l97 = "     ".length;
		var _g197 = 0;
		var _g107 = l97;
		while(_g197 < _g107) {
			var i97 = _g197++;
			var no97 = "     ".charCodeAt(i97);
			if(no97 == null) {
				break;
			}
			var v97;
			switch(no97) {
			case 32:
				v97 = false;
				break;
			case 42:
				v97 = true;
				break;
			case 48:
				v97 = false;
				break;
			case 49:
				v97 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i97)));
			}
			switch(i97 - (l97 - 8)) {
			case 0:
				if(v97) {
					bs97 |= 128;
				} else {
					bs97 &= -129;
				}
				break;
			case 1:
				if(v97) {
					bs97 |= 64;
				} else {
					bs97 &= -65;
				}
				break;
			case 2:
				if(v97) {
					bs97 |= 32;
				} else {
					bs97 &= -33;
				}
				break;
			case 3:
				if(v97) {
					bs97 |= 16;
				} else {
					bs97 &= -17;
				}
				break;
			case 4:
				if(v97) {
					bs97 |= 8;
				} else {
					bs97 &= -9;
				}
				break;
			case 5:
				if(v97) {
					bs97 |= 4;
				} else {
					bs97 &= -5;
				}
				break;
			case 6:
				if(v97) {
					bs97 |= 2;
				} else {
					bs97 &= -3;
				}
				break;
			case 7:
				if(v97) {
					bs97 |= 1;
				} else {
					bs97 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs97;
		break;
	case 46:
		var this99 = 0;
		var bs98 = this99;
		var l98 = "     ".length;
		var _g198 = 0;
		var _g108 = l98;
		while(_g198 < _g108) {
			var i98 = _g198++;
			var no98 = "     ".charCodeAt(i98);
			if(no98 == null) {
				break;
			}
			var v98;
			switch(no98) {
			case 32:
				v98 = false;
				break;
			case 42:
				v98 = true;
				break;
			case 48:
				v98 = false;
				break;
			case 49:
				v98 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i98)));
			}
			switch(i98 - (l98 - 8)) {
			case 0:
				if(v98) {
					bs98 |= 128;
				} else {
					bs98 &= -129;
				}
				break;
			case 1:
				if(v98) {
					bs98 |= 64;
				} else {
					bs98 &= -65;
				}
				break;
			case 2:
				if(v98) {
					bs98 |= 32;
				} else {
					bs98 &= -33;
				}
				break;
			case 3:
				if(v98) {
					bs98 |= 16;
				} else {
					bs98 &= -17;
				}
				break;
			case 4:
				if(v98) {
					bs98 |= 8;
				} else {
					bs98 &= -9;
				}
				break;
			case 5:
				if(v98) {
					bs98 |= 4;
				} else {
					bs98 &= -5;
				}
				break;
			case 6:
				if(v98) {
					bs98 |= 2;
				} else {
					bs98 &= -3;
				}
				break;
			case 7:
				if(v98) {
					bs98 |= 1;
				} else {
					bs98 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs98;
		var this100 = 0;
		var bs99 = this100;
		var l99 = "     ".length;
		var _g199 = 0;
		var _g109 = l99;
		while(_g199 < _g109) {
			var i99 = _g199++;
			var no99 = "     ".charCodeAt(i99);
			if(no99 == null) {
				break;
			}
			var v99;
			switch(no99) {
			case 32:
				v99 = false;
				break;
			case 42:
				v99 = true;
				break;
			case 48:
				v99 = false;
				break;
			case 49:
				v99 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i99)));
			}
			switch(i99 - (l99 - 8)) {
			case 0:
				if(v99) {
					bs99 |= 128;
				} else {
					bs99 &= -129;
				}
				break;
			case 1:
				if(v99) {
					bs99 |= 64;
				} else {
					bs99 &= -65;
				}
				break;
			case 2:
				if(v99) {
					bs99 |= 32;
				} else {
					bs99 &= -33;
				}
				break;
			case 3:
				if(v99) {
					bs99 |= 16;
				} else {
					bs99 &= -17;
				}
				break;
			case 4:
				if(v99) {
					bs99 |= 8;
				} else {
					bs99 &= -9;
				}
				break;
			case 5:
				if(v99) {
					bs99 |= 4;
				} else {
					bs99 &= -5;
				}
				break;
			case 6:
				if(v99) {
					bs99 |= 2;
				} else {
					bs99 &= -3;
				}
				break;
			case 7:
				if(v99) {
					bs99 |= 1;
				} else {
					bs99 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs99;
		var this101 = 0;
		var bs100 = this101;
		var l100 = "     ".length;
		var _g1100 = 0;
		var _g200 = l100;
		while(_g1100 < _g200) {
			var i100 = _g1100++;
			var no100 = "     ".charCodeAt(i100);
			if(no100 == null) {
				break;
			}
			var v100;
			switch(no100) {
			case 32:
				v100 = false;
				break;
			case 42:
				v100 = true;
				break;
			case 48:
				v100 = false;
				break;
			case 49:
				v100 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i100)));
			}
			switch(i100 - (l100 - 8)) {
			case 0:
				if(v100) {
					bs100 |= 128;
				} else {
					bs100 &= -129;
				}
				break;
			case 1:
				if(v100) {
					bs100 |= 64;
				} else {
					bs100 &= -65;
				}
				break;
			case 2:
				if(v100) {
					bs100 |= 32;
				} else {
					bs100 &= -33;
				}
				break;
			case 3:
				if(v100) {
					bs100 |= 16;
				} else {
					bs100 &= -17;
				}
				break;
			case 4:
				if(v100) {
					bs100 |= 8;
				} else {
					bs100 &= -9;
				}
				break;
			case 5:
				if(v100) {
					bs100 |= 4;
				} else {
					bs100 &= -5;
				}
				break;
			case 6:
				if(v100) {
					bs100 |= 2;
				} else {
					bs100 &= -3;
				}
				break;
			case 7:
				if(v100) {
					bs100 |= 1;
				} else {
					bs100 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs100;
		var this102 = 0;
		var bs101 = this102;
		var l101 = "     ".length;
		var _g1101 = 0;
		var _g201 = l101;
		while(_g1101 < _g201) {
			var i101 = _g1101++;
			var no101 = "     ".charCodeAt(i101);
			if(no101 == null) {
				break;
			}
			var v101;
			switch(no101) {
			case 32:
				v101 = false;
				break;
			case 42:
				v101 = true;
				break;
			case 48:
				v101 = false;
				break;
			case 49:
				v101 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i101)));
			}
			switch(i101 - (l101 - 8)) {
			case 0:
				if(v101) {
					bs101 |= 128;
				} else {
					bs101 &= -129;
				}
				break;
			case 1:
				if(v101) {
					bs101 |= 64;
				} else {
					bs101 &= -65;
				}
				break;
			case 2:
				if(v101) {
					bs101 |= 32;
				} else {
					bs101 &= -33;
				}
				break;
			case 3:
				if(v101) {
					bs101 |= 16;
				} else {
					bs101 &= -17;
				}
				break;
			case 4:
				if(v101) {
					bs101 |= 8;
				} else {
					bs101 &= -9;
				}
				break;
			case 5:
				if(v101) {
					bs101 |= 4;
				} else {
					bs101 &= -5;
				}
				break;
			case 6:
				if(v101) {
					bs101 |= 2;
				} else {
					bs101 &= -3;
				}
				break;
			case 7:
				if(v101) {
					bs101 |= 1;
				} else {
					bs101 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs101;
		var this103 = 0;
		var bs102 = this103;
		var l102 = "     ".length;
		var _g1102 = 0;
		var _g202 = l102;
		while(_g1102 < _g202) {
			var i102 = _g1102++;
			var no102 = "     ".charCodeAt(i102);
			if(no102 == null) {
				break;
			}
			var v102;
			switch(no102) {
			case 32:
				v102 = false;
				break;
			case 42:
				v102 = true;
				break;
			case 48:
				v102 = false;
				break;
			case 49:
				v102 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i102)));
			}
			switch(i102 - (l102 - 8)) {
			case 0:
				if(v102) {
					bs102 |= 128;
				} else {
					bs102 &= -129;
				}
				break;
			case 1:
				if(v102) {
					bs102 |= 64;
				} else {
					bs102 &= -65;
				}
				break;
			case 2:
				if(v102) {
					bs102 |= 32;
				} else {
					bs102 &= -33;
				}
				break;
			case 3:
				if(v102) {
					bs102 |= 16;
				} else {
					bs102 &= -17;
				}
				break;
			case 4:
				if(v102) {
					bs102 |= 8;
				} else {
					bs102 &= -9;
				}
				break;
			case 5:
				if(v102) {
					bs102 |= 4;
				} else {
					bs102 &= -5;
				}
				break;
			case 6:
				if(v102) {
					bs102 |= 2;
				} else {
					bs102 &= -3;
				}
				break;
			case 7:
				if(v102) {
					bs102 |= 1;
				} else {
					bs102 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs102;
		var this104 = 0;
		var bs103 = this104;
		var l103 = "  ** ".length;
		var _g1103 = 0;
		var _g203 = l103;
		while(_g1103 < _g203) {
			var i103 = _g1103++;
			var no103 = "  ** ".charCodeAt(i103);
			if(no103 == null) {
				break;
			}
			var v103;
			switch(no103) {
			case 32:
				v103 = false;
				break;
			case 42:
				v103 = true;
				break;
			case 48:
				v103 = false;
				break;
			case 49:
				v103 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i103)));
			}
			switch(i103 - (l103 - 8)) {
			case 0:
				if(v103) {
					bs103 |= 128;
				} else {
					bs103 &= -129;
				}
				break;
			case 1:
				if(v103) {
					bs103 |= 64;
				} else {
					bs103 &= -65;
				}
				break;
			case 2:
				if(v103) {
					bs103 |= 32;
				} else {
					bs103 &= -33;
				}
				break;
			case 3:
				if(v103) {
					bs103 |= 16;
				} else {
					bs103 &= -17;
				}
				break;
			case 4:
				if(v103) {
					bs103 |= 8;
				} else {
					bs103 &= -9;
				}
				break;
			case 5:
				if(v103) {
					bs103 |= 4;
				} else {
					bs103 &= -5;
				}
				break;
			case 6:
				if(v103) {
					bs103 |= 2;
				} else {
					bs103 &= -3;
				}
				break;
			case 7:
				if(v103) {
					bs103 |= 1;
				} else {
					bs103 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs103;
		var this105 = 0;
		var bs104 = this105;
		var l104 = "  ** ".length;
		var _g1104 = 0;
		var _g204 = l104;
		while(_g1104 < _g204) {
			var i104 = _g1104++;
			var no104 = "  ** ".charCodeAt(i104);
			if(no104 == null) {
				break;
			}
			var v104;
			switch(no104) {
			case 32:
				v104 = false;
				break;
			case 42:
				v104 = true;
				break;
			case 48:
				v104 = false;
				break;
			case 49:
				v104 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i104)));
			}
			switch(i104 - (l104 - 8)) {
			case 0:
				if(v104) {
					bs104 |= 128;
				} else {
					bs104 &= -129;
				}
				break;
			case 1:
				if(v104) {
					bs104 |= 64;
				} else {
					bs104 &= -65;
				}
				break;
			case 2:
				if(v104) {
					bs104 |= 32;
				} else {
					bs104 &= -33;
				}
				break;
			case 3:
				if(v104) {
					bs104 |= 16;
				} else {
					bs104 &= -17;
				}
				break;
			case 4:
				if(v104) {
					bs104 |= 8;
				} else {
					bs104 &= -9;
				}
				break;
			case 5:
				if(v104) {
					bs104 |= 4;
				} else {
					bs104 &= -5;
				}
				break;
			case 6:
				if(v104) {
					bs104 |= 2;
				} else {
					bs104 &= -3;
				}
				break;
			case 7:
				if(v104) {
					bs104 |= 1;
				} else {
					bs104 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs104;
		break;
	case 47:
		var this106 = 0;
		var bs105 = this106;
		var l105 = "    *".length;
		var _g1105 = 0;
		var _g205 = l105;
		while(_g1105 < _g205) {
			var i105 = _g1105++;
			var no105 = "    *".charCodeAt(i105);
			if(no105 == null) {
				break;
			}
			var v105;
			switch(no105) {
			case 32:
				v105 = false;
				break;
			case 42:
				v105 = true;
				break;
			case 48:
				v105 = false;
				break;
			case 49:
				v105 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i105)));
			}
			switch(i105 - (l105 - 8)) {
			case 0:
				if(v105) {
					bs105 |= 128;
				} else {
					bs105 &= -129;
				}
				break;
			case 1:
				if(v105) {
					bs105 |= 64;
				} else {
					bs105 &= -65;
				}
				break;
			case 2:
				if(v105) {
					bs105 |= 32;
				} else {
					bs105 &= -33;
				}
				break;
			case 3:
				if(v105) {
					bs105 |= 16;
				} else {
					bs105 &= -17;
				}
				break;
			case 4:
				if(v105) {
					bs105 |= 8;
				} else {
					bs105 &= -9;
				}
				break;
			case 5:
				if(v105) {
					bs105 |= 4;
				} else {
					bs105 &= -5;
				}
				break;
			case 6:
				if(v105) {
					bs105 |= 2;
				} else {
					bs105 &= -3;
				}
				break;
			case 7:
				if(v105) {
					bs105 |= 1;
				} else {
					bs105 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs105;
		var this107 = 0;
		var bs106 = this107;
		var l106 = "   * ".length;
		var _g1106 = 0;
		var _g206 = l106;
		while(_g1106 < _g206) {
			var i106 = _g1106++;
			var no106 = "   * ".charCodeAt(i106);
			if(no106 == null) {
				break;
			}
			var v106;
			switch(no106) {
			case 32:
				v106 = false;
				break;
			case 42:
				v106 = true;
				break;
			case 48:
				v106 = false;
				break;
			case 49:
				v106 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i106)));
			}
			switch(i106 - (l106 - 8)) {
			case 0:
				if(v106) {
					bs106 |= 128;
				} else {
					bs106 &= -129;
				}
				break;
			case 1:
				if(v106) {
					bs106 |= 64;
				} else {
					bs106 &= -65;
				}
				break;
			case 2:
				if(v106) {
					bs106 |= 32;
				} else {
					bs106 &= -33;
				}
				break;
			case 3:
				if(v106) {
					bs106 |= 16;
				} else {
					bs106 &= -17;
				}
				break;
			case 4:
				if(v106) {
					bs106 |= 8;
				} else {
					bs106 &= -9;
				}
				break;
			case 5:
				if(v106) {
					bs106 |= 4;
				} else {
					bs106 &= -5;
				}
				break;
			case 6:
				if(v106) {
					bs106 |= 2;
				} else {
					bs106 &= -3;
				}
				break;
			case 7:
				if(v106) {
					bs106 |= 1;
				} else {
					bs106 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs106;
		var this108 = 0;
		var bs107 = this108;
		var l107 = "   * ".length;
		var _g1107 = 0;
		var _g207 = l107;
		while(_g1107 < _g207) {
			var i107 = _g1107++;
			var no107 = "   * ".charCodeAt(i107);
			if(no107 == null) {
				break;
			}
			var v107;
			switch(no107) {
			case 32:
				v107 = false;
				break;
			case 42:
				v107 = true;
				break;
			case 48:
				v107 = false;
				break;
			case 49:
				v107 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i107)));
			}
			switch(i107 - (l107 - 8)) {
			case 0:
				if(v107) {
					bs107 |= 128;
				} else {
					bs107 &= -129;
				}
				break;
			case 1:
				if(v107) {
					bs107 |= 64;
				} else {
					bs107 &= -65;
				}
				break;
			case 2:
				if(v107) {
					bs107 |= 32;
				} else {
					bs107 &= -33;
				}
				break;
			case 3:
				if(v107) {
					bs107 |= 16;
				} else {
					bs107 &= -17;
				}
				break;
			case 4:
				if(v107) {
					bs107 |= 8;
				} else {
					bs107 &= -9;
				}
				break;
			case 5:
				if(v107) {
					bs107 |= 4;
				} else {
					bs107 &= -5;
				}
				break;
			case 6:
				if(v107) {
					bs107 |= 2;
				} else {
					bs107 &= -3;
				}
				break;
			case 7:
				if(v107) {
					bs107 |= 1;
				} else {
					bs107 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs107;
		var this109 = 0;
		var bs108 = this109;
		var l108 = "  *  ".length;
		var _g1108 = 0;
		var _g208 = l108;
		while(_g1108 < _g208) {
			var i108 = _g1108++;
			var no108 = "  *  ".charCodeAt(i108);
			if(no108 == null) {
				break;
			}
			var v108;
			switch(no108) {
			case 32:
				v108 = false;
				break;
			case 42:
				v108 = true;
				break;
			case 48:
				v108 = false;
				break;
			case 49:
				v108 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i108)));
			}
			switch(i108 - (l108 - 8)) {
			case 0:
				if(v108) {
					bs108 |= 128;
				} else {
					bs108 &= -129;
				}
				break;
			case 1:
				if(v108) {
					bs108 |= 64;
				} else {
					bs108 &= -65;
				}
				break;
			case 2:
				if(v108) {
					bs108 |= 32;
				} else {
					bs108 &= -33;
				}
				break;
			case 3:
				if(v108) {
					bs108 |= 16;
				} else {
					bs108 &= -17;
				}
				break;
			case 4:
				if(v108) {
					bs108 |= 8;
				} else {
					bs108 &= -9;
				}
				break;
			case 5:
				if(v108) {
					bs108 |= 4;
				} else {
					bs108 &= -5;
				}
				break;
			case 6:
				if(v108) {
					bs108 |= 2;
				} else {
					bs108 &= -3;
				}
				break;
			case 7:
				if(v108) {
					bs108 |= 1;
				} else {
					bs108 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs108;
		var this110 = 0;
		var bs109 = this110;
		var l109 = "  *  ".length;
		var _g1109 = 0;
		var _g209 = l109;
		while(_g1109 < _g209) {
			var i109 = _g1109++;
			var no109 = "  *  ".charCodeAt(i109);
			if(no109 == null) {
				break;
			}
			var v109;
			switch(no109) {
			case 32:
				v109 = false;
				break;
			case 42:
				v109 = true;
				break;
			case 48:
				v109 = false;
				break;
			case 49:
				v109 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i109)));
			}
			switch(i109 - (l109 - 8)) {
			case 0:
				if(v109) {
					bs109 |= 128;
				} else {
					bs109 &= -129;
				}
				break;
			case 1:
				if(v109) {
					bs109 |= 64;
				} else {
					bs109 &= -65;
				}
				break;
			case 2:
				if(v109) {
					bs109 |= 32;
				} else {
					bs109 &= -33;
				}
				break;
			case 3:
				if(v109) {
					bs109 |= 16;
				} else {
					bs109 &= -17;
				}
				break;
			case 4:
				if(v109) {
					bs109 |= 8;
				} else {
					bs109 &= -9;
				}
				break;
			case 5:
				if(v109) {
					bs109 |= 4;
				} else {
					bs109 &= -5;
				}
				break;
			case 6:
				if(v109) {
					bs109 |= 2;
				} else {
					bs109 &= -3;
				}
				break;
			case 7:
				if(v109) {
					bs109 |= 1;
				} else {
					bs109 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs109;
		var this111 = 0;
		var bs110 = this111;
		var l110 = " *   ".length;
		var _g1110 = 0;
		var _g210 = l110;
		while(_g1110 < _g210) {
			var i110 = _g1110++;
			var no110 = " *   ".charCodeAt(i110);
			if(no110 == null) {
				break;
			}
			var v110;
			switch(no110) {
			case 32:
				v110 = false;
				break;
			case 42:
				v110 = true;
				break;
			case 48:
				v110 = false;
				break;
			case 49:
				v110 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i110)));
			}
			switch(i110 - (l110 - 8)) {
			case 0:
				if(v110) {
					bs110 |= 128;
				} else {
					bs110 &= -129;
				}
				break;
			case 1:
				if(v110) {
					bs110 |= 64;
				} else {
					bs110 &= -65;
				}
				break;
			case 2:
				if(v110) {
					bs110 |= 32;
				} else {
					bs110 &= -33;
				}
				break;
			case 3:
				if(v110) {
					bs110 |= 16;
				} else {
					bs110 &= -17;
				}
				break;
			case 4:
				if(v110) {
					bs110 |= 8;
				} else {
					bs110 &= -9;
				}
				break;
			case 5:
				if(v110) {
					bs110 |= 4;
				} else {
					bs110 &= -5;
				}
				break;
			case 6:
				if(v110) {
					bs110 |= 2;
				} else {
					bs110 &= -3;
				}
				break;
			case 7:
				if(v110) {
					bs110 |= 1;
				} else {
					bs110 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs110;
		var this112 = 0;
		var bs111 = this112;
		var l111 = "*    ".length;
		var _g1111 = 0;
		var _g211 = l111;
		while(_g1111 < _g211) {
			var i111 = _g1111++;
			var no111 = "*    ".charCodeAt(i111);
			if(no111 == null) {
				break;
			}
			var v111;
			switch(no111) {
			case 32:
				v111 = false;
				break;
			case 42:
				v111 = true;
				break;
			case 48:
				v111 = false;
				break;
			case 49:
				v111 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i111)));
			}
			switch(i111 - (l111 - 8)) {
			case 0:
				if(v111) {
					bs111 |= 128;
				} else {
					bs111 &= -129;
				}
				break;
			case 1:
				if(v111) {
					bs111 |= 64;
				} else {
					bs111 &= -65;
				}
				break;
			case 2:
				if(v111) {
					bs111 |= 32;
				} else {
					bs111 &= -33;
				}
				break;
			case 3:
				if(v111) {
					bs111 |= 16;
				} else {
					bs111 &= -17;
				}
				break;
			case 4:
				if(v111) {
					bs111 |= 8;
				} else {
					bs111 &= -9;
				}
				break;
			case 5:
				if(v111) {
					bs111 |= 4;
				} else {
					bs111 &= -5;
				}
				break;
			case 6:
				if(v111) {
					bs111 |= 2;
				} else {
					bs111 &= -3;
				}
				break;
			case 7:
				if(v111) {
					bs111 |= 1;
				} else {
					bs111 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs111;
		break;
	case 48:
		var this113 = 0;
		var bs112 = this113;
		var l112 = " *** ".length;
		var _g1112 = 0;
		var _g212 = l112;
		while(_g1112 < _g212) {
			var i112 = _g1112++;
			var no112 = " *** ".charCodeAt(i112);
			if(no112 == null) {
				break;
			}
			var v112;
			switch(no112) {
			case 32:
				v112 = false;
				break;
			case 42:
				v112 = true;
				break;
			case 48:
				v112 = false;
				break;
			case 49:
				v112 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i112)));
			}
			switch(i112 - (l112 - 8)) {
			case 0:
				if(v112) {
					bs112 |= 128;
				} else {
					bs112 &= -129;
				}
				break;
			case 1:
				if(v112) {
					bs112 |= 64;
				} else {
					bs112 &= -65;
				}
				break;
			case 2:
				if(v112) {
					bs112 |= 32;
				} else {
					bs112 &= -33;
				}
				break;
			case 3:
				if(v112) {
					bs112 |= 16;
				} else {
					bs112 &= -17;
				}
				break;
			case 4:
				if(v112) {
					bs112 |= 8;
				} else {
					bs112 &= -9;
				}
				break;
			case 5:
				if(v112) {
					bs112 |= 4;
				} else {
					bs112 &= -5;
				}
				break;
			case 6:
				if(v112) {
					bs112 |= 2;
				} else {
					bs112 &= -3;
				}
				break;
			case 7:
				if(v112) {
					bs112 |= 1;
				} else {
					bs112 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs112;
		var this114 = 0;
		var bs113 = this114;
		var l113 = "*   *".length;
		var _g1113 = 0;
		var _g213 = l113;
		while(_g1113 < _g213) {
			var i113 = _g1113++;
			var no113 = "*   *".charCodeAt(i113);
			if(no113 == null) {
				break;
			}
			var v113;
			switch(no113) {
			case 32:
				v113 = false;
				break;
			case 42:
				v113 = true;
				break;
			case 48:
				v113 = false;
				break;
			case 49:
				v113 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i113)));
			}
			switch(i113 - (l113 - 8)) {
			case 0:
				if(v113) {
					bs113 |= 128;
				} else {
					bs113 &= -129;
				}
				break;
			case 1:
				if(v113) {
					bs113 |= 64;
				} else {
					bs113 &= -65;
				}
				break;
			case 2:
				if(v113) {
					bs113 |= 32;
				} else {
					bs113 &= -33;
				}
				break;
			case 3:
				if(v113) {
					bs113 |= 16;
				} else {
					bs113 &= -17;
				}
				break;
			case 4:
				if(v113) {
					bs113 |= 8;
				} else {
					bs113 &= -9;
				}
				break;
			case 5:
				if(v113) {
					bs113 |= 4;
				} else {
					bs113 &= -5;
				}
				break;
			case 6:
				if(v113) {
					bs113 |= 2;
				} else {
					bs113 &= -3;
				}
				break;
			case 7:
				if(v113) {
					bs113 |= 1;
				} else {
					bs113 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs113;
		var this115 = 0;
		var bs114 = this115;
		var l114 = "*  **".length;
		var _g1114 = 0;
		var _g214 = l114;
		while(_g1114 < _g214) {
			var i114 = _g1114++;
			var no114 = "*  **".charCodeAt(i114);
			if(no114 == null) {
				break;
			}
			var v114;
			switch(no114) {
			case 32:
				v114 = false;
				break;
			case 42:
				v114 = true;
				break;
			case 48:
				v114 = false;
				break;
			case 49:
				v114 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  **".charCodeAt(i114)));
			}
			switch(i114 - (l114 - 8)) {
			case 0:
				if(v114) {
					bs114 |= 128;
				} else {
					bs114 &= -129;
				}
				break;
			case 1:
				if(v114) {
					bs114 |= 64;
				} else {
					bs114 &= -65;
				}
				break;
			case 2:
				if(v114) {
					bs114 |= 32;
				} else {
					bs114 &= -33;
				}
				break;
			case 3:
				if(v114) {
					bs114 |= 16;
				} else {
					bs114 &= -17;
				}
				break;
			case 4:
				if(v114) {
					bs114 |= 8;
				} else {
					bs114 &= -9;
				}
				break;
			case 5:
				if(v114) {
					bs114 |= 4;
				} else {
					bs114 &= -5;
				}
				break;
			case 6:
				if(v114) {
					bs114 |= 2;
				} else {
					bs114 &= -3;
				}
				break;
			case 7:
				if(v114) {
					bs114 |= 1;
				} else {
					bs114 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs114;
		var this116 = 0;
		var bs115 = this116;
		var l115 = "* * *".length;
		var _g1115 = 0;
		var _g215 = l115;
		while(_g1115 < _g215) {
			var i115 = _g1115++;
			var no115 = "* * *".charCodeAt(i115);
			if(no115 == null) {
				break;
			}
			var v115;
			switch(no115) {
			case 32:
				v115 = false;
				break;
			case 42:
				v115 = true;
				break;
			case 48:
				v115 = false;
				break;
			case 49:
				v115 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i115)));
			}
			switch(i115 - (l115 - 8)) {
			case 0:
				if(v115) {
					bs115 |= 128;
				} else {
					bs115 &= -129;
				}
				break;
			case 1:
				if(v115) {
					bs115 |= 64;
				} else {
					bs115 &= -65;
				}
				break;
			case 2:
				if(v115) {
					bs115 |= 32;
				} else {
					bs115 &= -33;
				}
				break;
			case 3:
				if(v115) {
					bs115 |= 16;
				} else {
					bs115 &= -17;
				}
				break;
			case 4:
				if(v115) {
					bs115 |= 8;
				} else {
					bs115 &= -9;
				}
				break;
			case 5:
				if(v115) {
					bs115 |= 4;
				} else {
					bs115 &= -5;
				}
				break;
			case 6:
				if(v115) {
					bs115 |= 2;
				} else {
					bs115 &= -3;
				}
				break;
			case 7:
				if(v115) {
					bs115 |= 1;
				} else {
					bs115 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs115;
		var this117 = 0;
		var bs116 = this117;
		var l116 = "**  *".length;
		var _g1116 = 0;
		var _g216 = l116;
		while(_g1116 < _g216) {
			var i116 = _g1116++;
			var no116 = "**  *".charCodeAt(i116);
			if(no116 == null) {
				break;
			}
			var v116;
			switch(no116) {
			case 32:
				v116 = false;
				break;
			case 42:
				v116 = true;
				break;
			case 48:
				v116 = false;
				break;
			case 49:
				v116 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i116)));
			}
			switch(i116 - (l116 - 8)) {
			case 0:
				if(v116) {
					bs116 |= 128;
				} else {
					bs116 &= -129;
				}
				break;
			case 1:
				if(v116) {
					bs116 |= 64;
				} else {
					bs116 &= -65;
				}
				break;
			case 2:
				if(v116) {
					bs116 |= 32;
				} else {
					bs116 &= -33;
				}
				break;
			case 3:
				if(v116) {
					bs116 |= 16;
				} else {
					bs116 &= -17;
				}
				break;
			case 4:
				if(v116) {
					bs116 |= 8;
				} else {
					bs116 &= -9;
				}
				break;
			case 5:
				if(v116) {
					bs116 |= 4;
				} else {
					bs116 &= -5;
				}
				break;
			case 6:
				if(v116) {
					bs116 |= 2;
				} else {
					bs116 &= -3;
				}
				break;
			case 7:
				if(v116) {
					bs116 |= 1;
				} else {
					bs116 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs116;
		var this118 = 0;
		var bs117 = this118;
		var l117 = "*   *".length;
		var _g1117 = 0;
		var _g217 = l117;
		while(_g1117 < _g217) {
			var i117 = _g1117++;
			var no117 = "*   *".charCodeAt(i117);
			if(no117 == null) {
				break;
			}
			var v117;
			switch(no117) {
			case 32:
				v117 = false;
				break;
			case 42:
				v117 = true;
				break;
			case 48:
				v117 = false;
				break;
			case 49:
				v117 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i117)));
			}
			switch(i117 - (l117 - 8)) {
			case 0:
				if(v117) {
					bs117 |= 128;
				} else {
					bs117 &= -129;
				}
				break;
			case 1:
				if(v117) {
					bs117 |= 64;
				} else {
					bs117 &= -65;
				}
				break;
			case 2:
				if(v117) {
					bs117 |= 32;
				} else {
					bs117 &= -33;
				}
				break;
			case 3:
				if(v117) {
					bs117 |= 16;
				} else {
					bs117 &= -17;
				}
				break;
			case 4:
				if(v117) {
					bs117 |= 8;
				} else {
					bs117 &= -9;
				}
				break;
			case 5:
				if(v117) {
					bs117 |= 4;
				} else {
					bs117 &= -5;
				}
				break;
			case 6:
				if(v117) {
					bs117 |= 2;
				} else {
					bs117 &= -3;
				}
				break;
			case 7:
				if(v117) {
					bs117 |= 1;
				} else {
					bs117 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs117;
		var this119 = 0;
		var bs118 = this119;
		var l118 = " *** ".length;
		var _g1118 = 0;
		var _g218 = l118;
		while(_g1118 < _g218) {
			var i118 = _g1118++;
			var no118 = " *** ".charCodeAt(i118);
			if(no118 == null) {
				break;
			}
			var v118;
			switch(no118) {
			case 32:
				v118 = false;
				break;
			case 42:
				v118 = true;
				break;
			case 48:
				v118 = false;
				break;
			case 49:
				v118 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i118)));
			}
			switch(i118 - (l118 - 8)) {
			case 0:
				if(v118) {
					bs118 |= 128;
				} else {
					bs118 &= -129;
				}
				break;
			case 1:
				if(v118) {
					bs118 |= 64;
				} else {
					bs118 &= -65;
				}
				break;
			case 2:
				if(v118) {
					bs118 |= 32;
				} else {
					bs118 &= -33;
				}
				break;
			case 3:
				if(v118) {
					bs118 |= 16;
				} else {
					bs118 &= -17;
				}
				break;
			case 4:
				if(v118) {
					bs118 |= 8;
				} else {
					bs118 &= -9;
				}
				break;
			case 5:
				if(v118) {
					bs118 |= 4;
				} else {
					bs118 &= -5;
				}
				break;
			case 6:
				if(v118) {
					bs118 |= 2;
				} else {
					bs118 &= -3;
				}
				break;
			case 7:
				if(v118) {
					bs118 |= 1;
				} else {
					bs118 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs118;
		break;
	case 49:
		var this120 = 0;
		var bs119 = this120;
		var l119 = "  *  ".length;
		var _g1119 = 0;
		var _g219 = l119;
		while(_g1119 < _g219) {
			var i119 = _g1119++;
			var no119 = "  *  ".charCodeAt(i119);
			if(no119 == null) {
				break;
			}
			var v119;
			switch(no119) {
			case 32:
				v119 = false;
				break;
			case 42:
				v119 = true;
				break;
			case 48:
				v119 = false;
				break;
			case 49:
				v119 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i119)));
			}
			switch(i119 - (l119 - 8)) {
			case 0:
				if(v119) {
					bs119 |= 128;
				} else {
					bs119 &= -129;
				}
				break;
			case 1:
				if(v119) {
					bs119 |= 64;
				} else {
					bs119 &= -65;
				}
				break;
			case 2:
				if(v119) {
					bs119 |= 32;
				} else {
					bs119 &= -33;
				}
				break;
			case 3:
				if(v119) {
					bs119 |= 16;
				} else {
					bs119 &= -17;
				}
				break;
			case 4:
				if(v119) {
					bs119 |= 8;
				} else {
					bs119 &= -9;
				}
				break;
			case 5:
				if(v119) {
					bs119 |= 4;
				} else {
					bs119 &= -5;
				}
				break;
			case 6:
				if(v119) {
					bs119 |= 2;
				} else {
					bs119 &= -3;
				}
				break;
			case 7:
				if(v119) {
					bs119 |= 1;
				} else {
					bs119 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs119;
		var this121 = 0;
		var bs120 = this121;
		var l120 = " **  ".length;
		var _g1120 = 0;
		var _g220 = l120;
		while(_g1120 < _g220) {
			var i120 = _g1120++;
			var no120 = " **  ".charCodeAt(i120);
			if(no120 == null) {
				break;
			}
			var v120;
			switch(no120) {
			case 32:
				v120 = false;
				break;
			case 42:
				v120 = true;
				break;
			case 48:
				v120 = false;
				break;
			case 49:
				v120 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i120)));
			}
			switch(i120 - (l120 - 8)) {
			case 0:
				if(v120) {
					bs120 |= 128;
				} else {
					bs120 &= -129;
				}
				break;
			case 1:
				if(v120) {
					bs120 |= 64;
				} else {
					bs120 &= -65;
				}
				break;
			case 2:
				if(v120) {
					bs120 |= 32;
				} else {
					bs120 &= -33;
				}
				break;
			case 3:
				if(v120) {
					bs120 |= 16;
				} else {
					bs120 &= -17;
				}
				break;
			case 4:
				if(v120) {
					bs120 |= 8;
				} else {
					bs120 &= -9;
				}
				break;
			case 5:
				if(v120) {
					bs120 |= 4;
				} else {
					bs120 &= -5;
				}
				break;
			case 6:
				if(v120) {
					bs120 |= 2;
				} else {
					bs120 &= -3;
				}
				break;
			case 7:
				if(v120) {
					bs120 |= 1;
				} else {
					bs120 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs120;
		var this122 = 0;
		var bs121 = this122;
		var l121 = "  *  ".length;
		var _g1121 = 0;
		var _g221 = l121;
		while(_g1121 < _g221) {
			var i121 = _g1121++;
			var no121 = "  *  ".charCodeAt(i121);
			if(no121 == null) {
				break;
			}
			var v121;
			switch(no121) {
			case 32:
				v121 = false;
				break;
			case 42:
				v121 = true;
				break;
			case 48:
				v121 = false;
				break;
			case 49:
				v121 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i121)));
			}
			switch(i121 - (l121 - 8)) {
			case 0:
				if(v121) {
					bs121 |= 128;
				} else {
					bs121 &= -129;
				}
				break;
			case 1:
				if(v121) {
					bs121 |= 64;
				} else {
					bs121 &= -65;
				}
				break;
			case 2:
				if(v121) {
					bs121 |= 32;
				} else {
					bs121 &= -33;
				}
				break;
			case 3:
				if(v121) {
					bs121 |= 16;
				} else {
					bs121 &= -17;
				}
				break;
			case 4:
				if(v121) {
					bs121 |= 8;
				} else {
					bs121 &= -9;
				}
				break;
			case 5:
				if(v121) {
					bs121 |= 4;
				} else {
					bs121 &= -5;
				}
				break;
			case 6:
				if(v121) {
					bs121 |= 2;
				} else {
					bs121 &= -3;
				}
				break;
			case 7:
				if(v121) {
					bs121 |= 1;
				} else {
					bs121 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs121;
		var this123 = 0;
		var bs122 = this123;
		var l122 = "  *  ".length;
		var _g1122 = 0;
		var _g222 = l122;
		while(_g1122 < _g222) {
			var i122 = _g1122++;
			var no122 = "  *  ".charCodeAt(i122);
			if(no122 == null) {
				break;
			}
			var v122;
			switch(no122) {
			case 32:
				v122 = false;
				break;
			case 42:
				v122 = true;
				break;
			case 48:
				v122 = false;
				break;
			case 49:
				v122 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i122)));
			}
			switch(i122 - (l122 - 8)) {
			case 0:
				if(v122) {
					bs122 |= 128;
				} else {
					bs122 &= -129;
				}
				break;
			case 1:
				if(v122) {
					bs122 |= 64;
				} else {
					bs122 &= -65;
				}
				break;
			case 2:
				if(v122) {
					bs122 |= 32;
				} else {
					bs122 &= -33;
				}
				break;
			case 3:
				if(v122) {
					bs122 |= 16;
				} else {
					bs122 &= -17;
				}
				break;
			case 4:
				if(v122) {
					bs122 |= 8;
				} else {
					bs122 &= -9;
				}
				break;
			case 5:
				if(v122) {
					bs122 |= 4;
				} else {
					bs122 &= -5;
				}
				break;
			case 6:
				if(v122) {
					bs122 |= 2;
				} else {
					bs122 &= -3;
				}
				break;
			case 7:
				if(v122) {
					bs122 |= 1;
				} else {
					bs122 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs122;
		var this124 = 0;
		var bs123 = this124;
		var l123 = "  *  ".length;
		var _g1123 = 0;
		var _g223 = l123;
		while(_g1123 < _g223) {
			var i123 = _g1123++;
			var no123 = "  *  ".charCodeAt(i123);
			if(no123 == null) {
				break;
			}
			var v123;
			switch(no123) {
			case 32:
				v123 = false;
				break;
			case 42:
				v123 = true;
				break;
			case 48:
				v123 = false;
				break;
			case 49:
				v123 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i123)));
			}
			switch(i123 - (l123 - 8)) {
			case 0:
				if(v123) {
					bs123 |= 128;
				} else {
					bs123 &= -129;
				}
				break;
			case 1:
				if(v123) {
					bs123 |= 64;
				} else {
					bs123 &= -65;
				}
				break;
			case 2:
				if(v123) {
					bs123 |= 32;
				} else {
					bs123 &= -33;
				}
				break;
			case 3:
				if(v123) {
					bs123 |= 16;
				} else {
					bs123 &= -17;
				}
				break;
			case 4:
				if(v123) {
					bs123 |= 8;
				} else {
					bs123 &= -9;
				}
				break;
			case 5:
				if(v123) {
					bs123 |= 4;
				} else {
					bs123 &= -5;
				}
				break;
			case 6:
				if(v123) {
					bs123 |= 2;
				} else {
					bs123 &= -3;
				}
				break;
			case 7:
				if(v123) {
					bs123 |= 1;
				} else {
					bs123 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs123;
		var this125 = 0;
		var bs124 = this125;
		var l124 = "  *  ".length;
		var _g1124 = 0;
		var _g224 = l124;
		while(_g1124 < _g224) {
			var i124 = _g1124++;
			var no124 = "  *  ".charCodeAt(i124);
			if(no124 == null) {
				break;
			}
			var v124;
			switch(no124) {
			case 32:
				v124 = false;
				break;
			case 42:
				v124 = true;
				break;
			case 48:
				v124 = false;
				break;
			case 49:
				v124 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i124)));
			}
			switch(i124 - (l124 - 8)) {
			case 0:
				if(v124) {
					bs124 |= 128;
				} else {
					bs124 &= -129;
				}
				break;
			case 1:
				if(v124) {
					bs124 |= 64;
				} else {
					bs124 &= -65;
				}
				break;
			case 2:
				if(v124) {
					bs124 |= 32;
				} else {
					bs124 &= -33;
				}
				break;
			case 3:
				if(v124) {
					bs124 |= 16;
				} else {
					bs124 &= -17;
				}
				break;
			case 4:
				if(v124) {
					bs124 |= 8;
				} else {
					bs124 &= -9;
				}
				break;
			case 5:
				if(v124) {
					bs124 |= 4;
				} else {
					bs124 &= -5;
				}
				break;
			case 6:
				if(v124) {
					bs124 |= 2;
				} else {
					bs124 &= -3;
				}
				break;
			case 7:
				if(v124) {
					bs124 |= 1;
				} else {
					bs124 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs124;
		var this126 = 0;
		var bs125 = this126;
		var l125 = " *** ".length;
		var _g1125 = 0;
		var _g225 = l125;
		while(_g1125 < _g225) {
			var i125 = _g1125++;
			var no125 = " *** ".charCodeAt(i125);
			if(no125 == null) {
				break;
			}
			var v125;
			switch(no125) {
			case 32:
				v125 = false;
				break;
			case 42:
				v125 = true;
				break;
			case 48:
				v125 = false;
				break;
			case 49:
				v125 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i125)));
			}
			switch(i125 - (l125 - 8)) {
			case 0:
				if(v125) {
					bs125 |= 128;
				} else {
					bs125 &= -129;
				}
				break;
			case 1:
				if(v125) {
					bs125 |= 64;
				} else {
					bs125 &= -65;
				}
				break;
			case 2:
				if(v125) {
					bs125 |= 32;
				} else {
					bs125 &= -33;
				}
				break;
			case 3:
				if(v125) {
					bs125 |= 16;
				} else {
					bs125 &= -17;
				}
				break;
			case 4:
				if(v125) {
					bs125 |= 8;
				} else {
					bs125 &= -9;
				}
				break;
			case 5:
				if(v125) {
					bs125 |= 4;
				} else {
					bs125 &= -5;
				}
				break;
			case 6:
				if(v125) {
					bs125 |= 2;
				} else {
					bs125 &= -3;
				}
				break;
			case 7:
				if(v125) {
					bs125 |= 1;
				} else {
					bs125 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs125;
		break;
	case 50:
		var this127 = 0;
		var bs126 = this127;
		var l126 = " *** ".length;
		var _g1126 = 0;
		var _g226 = l126;
		while(_g1126 < _g226) {
			var i126 = _g1126++;
			var no126 = " *** ".charCodeAt(i126);
			if(no126 == null) {
				break;
			}
			var v126;
			switch(no126) {
			case 32:
				v126 = false;
				break;
			case 42:
				v126 = true;
				break;
			case 48:
				v126 = false;
				break;
			case 49:
				v126 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i126)));
			}
			switch(i126 - (l126 - 8)) {
			case 0:
				if(v126) {
					bs126 |= 128;
				} else {
					bs126 &= -129;
				}
				break;
			case 1:
				if(v126) {
					bs126 |= 64;
				} else {
					bs126 &= -65;
				}
				break;
			case 2:
				if(v126) {
					bs126 |= 32;
				} else {
					bs126 &= -33;
				}
				break;
			case 3:
				if(v126) {
					bs126 |= 16;
				} else {
					bs126 &= -17;
				}
				break;
			case 4:
				if(v126) {
					bs126 |= 8;
				} else {
					bs126 &= -9;
				}
				break;
			case 5:
				if(v126) {
					bs126 |= 4;
				} else {
					bs126 &= -5;
				}
				break;
			case 6:
				if(v126) {
					bs126 |= 2;
				} else {
					bs126 &= -3;
				}
				break;
			case 7:
				if(v126) {
					bs126 |= 1;
				} else {
					bs126 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs126;
		var this128 = 0;
		var bs127 = this128;
		var l127 = "*   *".length;
		var _g1127 = 0;
		var _g227 = l127;
		while(_g1127 < _g227) {
			var i127 = _g1127++;
			var no127 = "*   *".charCodeAt(i127);
			if(no127 == null) {
				break;
			}
			var v127;
			switch(no127) {
			case 32:
				v127 = false;
				break;
			case 42:
				v127 = true;
				break;
			case 48:
				v127 = false;
				break;
			case 49:
				v127 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i127)));
			}
			switch(i127 - (l127 - 8)) {
			case 0:
				if(v127) {
					bs127 |= 128;
				} else {
					bs127 &= -129;
				}
				break;
			case 1:
				if(v127) {
					bs127 |= 64;
				} else {
					bs127 &= -65;
				}
				break;
			case 2:
				if(v127) {
					bs127 |= 32;
				} else {
					bs127 &= -33;
				}
				break;
			case 3:
				if(v127) {
					bs127 |= 16;
				} else {
					bs127 &= -17;
				}
				break;
			case 4:
				if(v127) {
					bs127 |= 8;
				} else {
					bs127 &= -9;
				}
				break;
			case 5:
				if(v127) {
					bs127 |= 4;
				} else {
					bs127 &= -5;
				}
				break;
			case 6:
				if(v127) {
					bs127 |= 2;
				} else {
					bs127 &= -3;
				}
				break;
			case 7:
				if(v127) {
					bs127 |= 1;
				} else {
					bs127 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs127;
		var this129 = 0;
		var bs128 = this129;
		var l128 = "    *".length;
		var _g1128 = 0;
		var _g228 = l128;
		while(_g1128 < _g228) {
			var i128 = _g1128++;
			var no128 = "    *".charCodeAt(i128);
			if(no128 == null) {
				break;
			}
			var v128;
			switch(no128) {
			case 32:
				v128 = false;
				break;
			case 42:
				v128 = true;
				break;
			case 48:
				v128 = false;
				break;
			case 49:
				v128 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i128)));
			}
			switch(i128 - (l128 - 8)) {
			case 0:
				if(v128) {
					bs128 |= 128;
				} else {
					bs128 &= -129;
				}
				break;
			case 1:
				if(v128) {
					bs128 |= 64;
				} else {
					bs128 &= -65;
				}
				break;
			case 2:
				if(v128) {
					bs128 |= 32;
				} else {
					bs128 &= -33;
				}
				break;
			case 3:
				if(v128) {
					bs128 |= 16;
				} else {
					bs128 &= -17;
				}
				break;
			case 4:
				if(v128) {
					bs128 |= 8;
				} else {
					bs128 &= -9;
				}
				break;
			case 5:
				if(v128) {
					bs128 |= 4;
				} else {
					bs128 &= -5;
				}
				break;
			case 6:
				if(v128) {
					bs128 |= 2;
				} else {
					bs128 &= -3;
				}
				break;
			case 7:
				if(v128) {
					bs128 |= 1;
				} else {
					bs128 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs128;
		var this130 = 0;
		var bs129 = this130;
		var l129 = "  *  ".length;
		var _g1129 = 0;
		var _g229 = l129;
		while(_g1129 < _g229) {
			var i129 = _g1129++;
			var no129 = "  *  ".charCodeAt(i129);
			if(no129 == null) {
				break;
			}
			var v129;
			switch(no129) {
			case 32:
				v129 = false;
				break;
			case 42:
				v129 = true;
				break;
			case 48:
				v129 = false;
				break;
			case 49:
				v129 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i129)));
			}
			switch(i129 - (l129 - 8)) {
			case 0:
				if(v129) {
					bs129 |= 128;
				} else {
					bs129 &= -129;
				}
				break;
			case 1:
				if(v129) {
					bs129 |= 64;
				} else {
					bs129 &= -65;
				}
				break;
			case 2:
				if(v129) {
					bs129 |= 32;
				} else {
					bs129 &= -33;
				}
				break;
			case 3:
				if(v129) {
					bs129 |= 16;
				} else {
					bs129 &= -17;
				}
				break;
			case 4:
				if(v129) {
					bs129 |= 8;
				} else {
					bs129 &= -9;
				}
				break;
			case 5:
				if(v129) {
					bs129 |= 4;
				} else {
					bs129 &= -5;
				}
				break;
			case 6:
				if(v129) {
					bs129 |= 2;
				} else {
					bs129 &= -3;
				}
				break;
			case 7:
				if(v129) {
					bs129 |= 1;
				} else {
					bs129 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs129;
		var this131 = 0;
		var bs130 = this131;
		var l130 = " *   ".length;
		var _g1130 = 0;
		var _g230 = l130;
		while(_g1130 < _g230) {
			var i130 = _g1130++;
			var no130 = " *   ".charCodeAt(i130);
			if(no130 == null) {
				break;
			}
			var v130;
			switch(no130) {
			case 32:
				v130 = false;
				break;
			case 42:
				v130 = true;
				break;
			case 48:
				v130 = false;
				break;
			case 49:
				v130 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i130)));
			}
			switch(i130 - (l130 - 8)) {
			case 0:
				if(v130) {
					bs130 |= 128;
				} else {
					bs130 &= -129;
				}
				break;
			case 1:
				if(v130) {
					bs130 |= 64;
				} else {
					bs130 &= -65;
				}
				break;
			case 2:
				if(v130) {
					bs130 |= 32;
				} else {
					bs130 &= -33;
				}
				break;
			case 3:
				if(v130) {
					bs130 |= 16;
				} else {
					bs130 &= -17;
				}
				break;
			case 4:
				if(v130) {
					bs130 |= 8;
				} else {
					bs130 &= -9;
				}
				break;
			case 5:
				if(v130) {
					bs130 |= 4;
				} else {
					bs130 &= -5;
				}
				break;
			case 6:
				if(v130) {
					bs130 |= 2;
				} else {
					bs130 &= -3;
				}
				break;
			case 7:
				if(v130) {
					bs130 |= 1;
				} else {
					bs130 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs130;
		var this132 = 0;
		var bs131 = this132;
		var l131 = "*    ".length;
		var _g1131 = 0;
		var _g231 = l131;
		while(_g1131 < _g231) {
			var i131 = _g1131++;
			var no131 = "*    ".charCodeAt(i131);
			if(no131 == null) {
				break;
			}
			var v131;
			switch(no131) {
			case 32:
				v131 = false;
				break;
			case 42:
				v131 = true;
				break;
			case 48:
				v131 = false;
				break;
			case 49:
				v131 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i131)));
			}
			switch(i131 - (l131 - 8)) {
			case 0:
				if(v131) {
					bs131 |= 128;
				} else {
					bs131 &= -129;
				}
				break;
			case 1:
				if(v131) {
					bs131 |= 64;
				} else {
					bs131 &= -65;
				}
				break;
			case 2:
				if(v131) {
					bs131 |= 32;
				} else {
					bs131 &= -33;
				}
				break;
			case 3:
				if(v131) {
					bs131 |= 16;
				} else {
					bs131 &= -17;
				}
				break;
			case 4:
				if(v131) {
					bs131 |= 8;
				} else {
					bs131 &= -9;
				}
				break;
			case 5:
				if(v131) {
					bs131 |= 4;
				} else {
					bs131 &= -5;
				}
				break;
			case 6:
				if(v131) {
					bs131 |= 2;
				} else {
					bs131 &= -3;
				}
				break;
			case 7:
				if(v131) {
					bs131 |= 1;
				} else {
					bs131 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs131;
		var this133 = 0;
		var bs132 = this133;
		var l132 = "*****".length;
		var _g1132 = 0;
		var _g232 = l132;
		while(_g1132 < _g232) {
			var i132 = _g1132++;
			var no132 = "*****".charCodeAt(i132);
			if(no132 == null) {
				break;
			}
			var v132;
			switch(no132) {
			case 32:
				v132 = false;
				break;
			case 42:
				v132 = true;
				break;
			case 48:
				v132 = false;
				break;
			case 49:
				v132 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i132)));
			}
			switch(i132 - (l132 - 8)) {
			case 0:
				if(v132) {
					bs132 |= 128;
				} else {
					bs132 &= -129;
				}
				break;
			case 1:
				if(v132) {
					bs132 |= 64;
				} else {
					bs132 &= -65;
				}
				break;
			case 2:
				if(v132) {
					bs132 |= 32;
				} else {
					bs132 &= -33;
				}
				break;
			case 3:
				if(v132) {
					bs132 |= 16;
				} else {
					bs132 &= -17;
				}
				break;
			case 4:
				if(v132) {
					bs132 |= 8;
				} else {
					bs132 &= -9;
				}
				break;
			case 5:
				if(v132) {
					bs132 |= 4;
				} else {
					bs132 &= -5;
				}
				break;
			case 6:
				if(v132) {
					bs132 |= 2;
				} else {
					bs132 &= -3;
				}
				break;
			case 7:
				if(v132) {
					bs132 |= 1;
				} else {
					bs132 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs132;
		break;
	case 51:
		var this134 = 0;
		var bs133 = this134;
		var l133 = "*****".length;
		var _g1133 = 0;
		var _g233 = l133;
		while(_g1133 < _g233) {
			var i133 = _g1133++;
			var no133 = "*****".charCodeAt(i133);
			if(no133 == null) {
				break;
			}
			var v133;
			switch(no133) {
			case 32:
				v133 = false;
				break;
			case 42:
				v133 = true;
				break;
			case 48:
				v133 = false;
				break;
			case 49:
				v133 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i133)));
			}
			switch(i133 - (l133 - 8)) {
			case 0:
				if(v133) {
					bs133 |= 128;
				} else {
					bs133 &= -129;
				}
				break;
			case 1:
				if(v133) {
					bs133 |= 64;
				} else {
					bs133 &= -65;
				}
				break;
			case 2:
				if(v133) {
					bs133 |= 32;
				} else {
					bs133 &= -33;
				}
				break;
			case 3:
				if(v133) {
					bs133 |= 16;
				} else {
					bs133 &= -17;
				}
				break;
			case 4:
				if(v133) {
					bs133 |= 8;
				} else {
					bs133 &= -9;
				}
				break;
			case 5:
				if(v133) {
					bs133 |= 4;
				} else {
					bs133 &= -5;
				}
				break;
			case 6:
				if(v133) {
					bs133 |= 2;
				} else {
					bs133 &= -3;
				}
				break;
			case 7:
				if(v133) {
					bs133 |= 1;
				} else {
					bs133 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs133;
		var this135 = 0;
		var bs134 = this135;
		var l134 = "   * ".length;
		var _g1134 = 0;
		var _g234 = l134;
		while(_g1134 < _g234) {
			var i134 = _g1134++;
			var no134 = "   * ".charCodeAt(i134);
			if(no134 == null) {
				break;
			}
			var v134;
			switch(no134) {
			case 32:
				v134 = false;
				break;
			case 42:
				v134 = true;
				break;
			case 48:
				v134 = false;
				break;
			case 49:
				v134 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i134)));
			}
			switch(i134 - (l134 - 8)) {
			case 0:
				if(v134) {
					bs134 |= 128;
				} else {
					bs134 &= -129;
				}
				break;
			case 1:
				if(v134) {
					bs134 |= 64;
				} else {
					bs134 &= -65;
				}
				break;
			case 2:
				if(v134) {
					bs134 |= 32;
				} else {
					bs134 &= -33;
				}
				break;
			case 3:
				if(v134) {
					bs134 |= 16;
				} else {
					bs134 &= -17;
				}
				break;
			case 4:
				if(v134) {
					bs134 |= 8;
				} else {
					bs134 &= -9;
				}
				break;
			case 5:
				if(v134) {
					bs134 |= 4;
				} else {
					bs134 &= -5;
				}
				break;
			case 6:
				if(v134) {
					bs134 |= 2;
				} else {
					bs134 &= -3;
				}
				break;
			case 7:
				if(v134) {
					bs134 |= 1;
				} else {
					bs134 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs134;
		var this136 = 0;
		var bs135 = this136;
		var l135 = "  *  ".length;
		var _g1135 = 0;
		var _g235 = l135;
		while(_g1135 < _g235) {
			var i135 = _g1135++;
			var no135 = "  *  ".charCodeAt(i135);
			if(no135 == null) {
				break;
			}
			var v135;
			switch(no135) {
			case 32:
				v135 = false;
				break;
			case 42:
				v135 = true;
				break;
			case 48:
				v135 = false;
				break;
			case 49:
				v135 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i135)));
			}
			switch(i135 - (l135 - 8)) {
			case 0:
				if(v135) {
					bs135 |= 128;
				} else {
					bs135 &= -129;
				}
				break;
			case 1:
				if(v135) {
					bs135 |= 64;
				} else {
					bs135 &= -65;
				}
				break;
			case 2:
				if(v135) {
					bs135 |= 32;
				} else {
					bs135 &= -33;
				}
				break;
			case 3:
				if(v135) {
					bs135 |= 16;
				} else {
					bs135 &= -17;
				}
				break;
			case 4:
				if(v135) {
					bs135 |= 8;
				} else {
					bs135 &= -9;
				}
				break;
			case 5:
				if(v135) {
					bs135 |= 4;
				} else {
					bs135 &= -5;
				}
				break;
			case 6:
				if(v135) {
					bs135 |= 2;
				} else {
					bs135 &= -3;
				}
				break;
			case 7:
				if(v135) {
					bs135 |= 1;
				} else {
					bs135 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs135;
		var this137 = 0;
		var bs136 = this137;
		var l136 = "   * ".length;
		var _g1136 = 0;
		var _g236 = l136;
		while(_g1136 < _g236) {
			var i136 = _g1136++;
			var no136 = "   * ".charCodeAt(i136);
			if(no136 == null) {
				break;
			}
			var v136;
			switch(no136) {
			case 32:
				v136 = false;
				break;
			case 42:
				v136 = true;
				break;
			case 48:
				v136 = false;
				break;
			case 49:
				v136 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i136)));
			}
			switch(i136 - (l136 - 8)) {
			case 0:
				if(v136) {
					bs136 |= 128;
				} else {
					bs136 &= -129;
				}
				break;
			case 1:
				if(v136) {
					bs136 |= 64;
				} else {
					bs136 &= -65;
				}
				break;
			case 2:
				if(v136) {
					bs136 |= 32;
				} else {
					bs136 &= -33;
				}
				break;
			case 3:
				if(v136) {
					bs136 |= 16;
				} else {
					bs136 &= -17;
				}
				break;
			case 4:
				if(v136) {
					bs136 |= 8;
				} else {
					bs136 &= -9;
				}
				break;
			case 5:
				if(v136) {
					bs136 |= 4;
				} else {
					bs136 &= -5;
				}
				break;
			case 6:
				if(v136) {
					bs136 |= 2;
				} else {
					bs136 &= -3;
				}
				break;
			case 7:
				if(v136) {
					bs136 |= 1;
				} else {
					bs136 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs136;
		var this138 = 0;
		var bs137 = this138;
		var l137 = "    *".length;
		var _g1137 = 0;
		var _g237 = l137;
		while(_g1137 < _g237) {
			var i137 = _g1137++;
			var no137 = "    *".charCodeAt(i137);
			if(no137 == null) {
				break;
			}
			var v137;
			switch(no137) {
			case 32:
				v137 = false;
				break;
			case 42:
				v137 = true;
				break;
			case 48:
				v137 = false;
				break;
			case 49:
				v137 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i137)));
			}
			switch(i137 - (l137 - 8)) {
			case 0:
				if(v137) {
					bs137 |= 128;
				} else {
					bs137 &= -129;
				}
				break;
			case 1:
				if(v137) {
					bs137 |= 64;
				} else {
					bs137 &= -65;
				}
				break;
			case 2:
				if(v137) {
					bs137 |= 32;
				} else {
					bs137 &= -33;
				}
				break;
			case 3:
				if(v137) {
					bs137 |= 16;
				} else {
					bs137 &= -17;
				}
				break;
			case 4:
				if(v137) {
					bs137 |= 8;
				} else {
					bs137 &= -9;
				}
				break;
			case 5:
				if(v137) {
					bs137 |= 4;
				} else {
					bs137 &= -5;
				}
				break;
			case 6:
				if(v137) {
					bs137 |= 2;
				} else {
					bs137 &= -3;
				}
				break;
			case 7:
				if(v137) {
					bs137 |= 1;
				} else {
					bs137 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs137;
		var this139 = 0;
		var bs138 = this139;
		var l138 = "*   *".length;
		var _g1138 = 0;
		var _g238 = l138;
		while(_g1138 < _g238) {
			var i138 = _g1138++;
			var no138 = "*   *".charCodeAt(i138);
			if(no138 == null) {
				break;
			}
			var v138;
			switch(no138) {
			case 32:
				v138 = false;
				break;
			case 42:
				v138 = true;
				break;
			case 48:
				v138 = false;
				break;
			case 49:
				v138 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i138)));
			}
			switch(i138 - (l138 - 8)) {
			case 0:
				if(v138) {
					bs138 |= 128;
				} else {
					bs138 &= -129;
				}
				break;
			case 1:
				if(v138) {
					bs138 |= 64;
				} else {
					bs138 &= -65;
				}
				break;
			case 2:
				if(v138) {
					bs138 |= 32;
				} else {
					bs138 &= -33;
				}
				break;
			case 3:
				if(v138) {
					bs138 |= 16;
				} else {
					bs138 &= -17;
				}
				break;
			case 4:
				if(v138) {
					bs138 |= 8;
				} else {
					bs138 &= -9;
				}
				break;
			case 5:
				if(v138) {
					bs138 |= 4;
				} else {
					bs138 &= -5;
				}
				break;
			case 6:
				if(v138) {
					bs138 |= 2;
				} else {
					bs138 &= -3;
				}
				break;
			case 7:
				if(v138) {
					bs138 |= 1;
				} else {
					bs138 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs138;
		var this140 = 0;
		var bs139 = this140;
		var l139 = " *** ".length;
		var _g1139 = 0;
		var _g239 = l139;
		while(_g1139 < _g239) {
			var i139 = _g1139++;
			var no139 = " *** ".charCodeAt(i139);
			if(no139 == null) {
				break;
			}
			var v139;
			switch(no139) {
			case 32:
				v139 = false;
				break;
			case 42:
				v139 = true;
				break;
			case 48:
				v139 = false;
				break;
			case 49:
				v139 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i139)));
			}
			switch(i139 - (l139 - 8)) {
			case 0:
				if(v139) {
					bs139 |= 128;
				} else {
					bs139 &= -129;
				}
				break;
			case 1:
				if(v139) {
					bs139 |= 64;
				} else {
					bs139 &= -65;
				}
				break;
			case 2:
				if(v139) {
					bs139 |= 32;
				} else {
					bs139 &= -33;
				}
				break;
			case 3:
				if(v139) {
					bs139 |= 16;
				} else {
					bs139 &= -17;
				}
				break;
			case 4:
				if(v139) {
					bs139 |= 8;
				} else {
					bs139 &= -9;
				}
				break;
			case 5:
				if(v139) {
					bs139 |= 4;
				} else {
					bs139 &= -5;
				}
				break;
			case 6:
				if(v139) {
					bs139 |= 2;
				} else {
					bs139 &= -3;
				}
				break;
			case 7:
				if(v139) {
					bs139 |= 1;
				} else {
					bs139 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs139;
		break;
	case 52:
		var this141 = 0;
		var bs140 = this141;
		var l140 = "   * ".length;
		var _g1140 = 0;
		var _g240 = l140;
		while(_g1140 < _g240) {
			var i140 = _g1140++;
			var no140 = "   * ".charCodeAt(i140);
			if(no140 == null) {
				break;
			}
			var v140;
			switch(no140) {
			case 32:
				v140 = false;
				break;
			case 42:
				v140 = true;
				break;
			case 48:
				v140 = false;
				break;
			case 49:
				v140 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i140)));
			}
			switch(i140 - (l140 - 8)) {
			case 0:
				if(v140) {
					bs140 |= 128;
				} else {
					bs140 &= -129;
				}
				break;
			case 1:
				if(v140) {
					bs140 |= 64;
				} else {
					bs140 &= -65;
				}
				break;
			case 2:
				if(v140) {
					bs140 |= 32;
				} else {
					bs140 &= -33;
				}
				break;
			case 3:
				if(v140) {
					bs140 |= 16;
				} else {
					bs140 &= -17;
				}
				break;
			case 4:
				if(v140) {
					bs140 |= 8;
				} else {
					bs140 &= -9;
				}
				break;
			case 5:
				if(v140) {
					bs140 |= 4;
				} else {
					bs140 &= -5;
				}
				break;
			case 6:
				if(v140) {
					bs140 |= 2;
				} else {
					bs140 &= -3;
				}
				break;
			case 7:
				if(v140) {
					bs140 |= 1;
				} else {
					bs140 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs140;
		var this142 = 0;
		var bs141 = this142;
		var l141 = "  ** ".length;
		var _g1141 = 0;
		var _g241 = l141;
		while(_g1141 < _g241) {
			var i141 = _g1141++;
			var no141 = "  ** ".charCodeAt(i141);
			if(no141 == null) {
				break;
			}
			var v141;
			switch(no141) {
			case 32:
				v141 = false;
				break;
			case 42:
				v141 = true;
				break;
			case 48:
				v141 = false;
				break;
			case 49:
				v141 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i141)));
			}
			switch(i141 - (l141 - 8)) {
			case 0:
				if(v141) {
					bs141 |= 128;
				} else {
					bs141 &= -129;
				}
				break;
			case 1:
				if(v141) {
					bs141 |= 64;
				} else {
					bs141 &= -65;
				}
				break;
			case 2:
				if(v141) {
					bs141 |= 32;
				} else {
					bs141 &= -33;
				}
				break;
			case 3:
				if(v141) {
					bs141 |= 16;
				} else {
					bs141 &= -17;
				}
				break;
			case 4:
				if(v141) {
					bs141 |= 8;
				} else {
					bs141 &= -9;
				}
				break;
			case 5:
				if(v141) {
					bs141 |= 4;
				} else {
					bs141 &= -5;
				}
				break;
			case 6:
				if(v141) {
					bs141 |= 2;
				} else {
					bs141 &= -3;
				}
				break;
			case 7:
				if(v141) {
					bs141 |= 1;
				} else {
					bs141 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs141;
		var this143 = 0;
		var bs142 = this143;
		var l142 = " * * ".length;
		var _g1142 = 0;
		var _g242 = l142;
		while(_g1142 < _g242) {
			var i142 = _g1142++;
			var no142 = " * * ".charCodeAt(i142);
			if(no142 == null) {
				break;
			}
			var v142;
			switch(no142) {
			case 32:
				v142 = false;
				break;
			case 42:
				v142 = true;
				break;
			case 48:
				v142 = false;
				break;
			case 49:
				v142 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i142)));
			}
			switch(i142 - (l142 - 8)) {
			case 0:
				if(v142) {
					bs142 |= 128;
				} else {
					bs142 &= -129;
				}
				break;
			case 1:
				if(v142) {
					bs142 |= 64;
				} else {
					bs142 &= -65;
				}
				break;
			case 2:
				if(v142) {
					bs142 |= 32;
				} else {
					bs142 &= -33;
				}
				break;
			case 3:
				if(v142) {
					bs142 |= 16;
				} else {
					bs142 &= -17;
				}
				break;
			case 4:
				if(v142) {
					bs142 |= 8;
				} else {
					bs142 &= -9;
				}
				break;
			case 5:
				if(v142) {
					bs142 |= 4;
				} else {
					bs142 &= -5;
				}
				break;
			case 6:
				if(v142) {
					bs142 |= 2;
				} else {
					bs142 &= -3;
				}
				break;
			case 7:
				if(v142) {
					bs142 |= 1;
				} else {
					bs142 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs142;
		var this144 = 0;
		var bs143 = this144;
		var l143 = "*  * ".length;
		var _g1143 = 0;
		var _g243 = l143;
		while(_g1143 < _g243) {
			var i143 = _g1143++;
			var no143 = "*  * ".charCodeAt(i143);
			if(no143 == null) {
				break;
			}
			var v143;
			switch(no143) {
			case 32:
				v143 = false;
				break;
			case 42:
				v143 = true;
				break;
			case 48:
				v143 = false;
				break;
			case 49:
				v143 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i143)));
			}
			switch(i143 - (l143 - 8)) {
			case 0:
				if(v143) {
					bs143 |= 128;
				} else {
					bs143 &= -129;
				}
				break;
			case 1:
				if(v143) {
					bs143 |= 64;
				} else {
					bs143 &= -65;
				}
				break;
			case 2:
				if(v143) {
					bs143 |= 32;
				} else {
					bs143 &= -33;
				}
				break;
			case 3:
				if(v143) {
					bs143 |= 16;
				} else {
					bs143 &= -17;
				}
				break;
			case 4:
				if(v143) {
					bs143 |= 8;
				} else {
					bs143 &= -9;
				}
				break;
			case 5:
				if(v143) {
					bs143 |= 4;
				} else {
					bs143 &= -5;
				}
				break;
			case 6:
				if(v143) {
					bs143 |= 2;
				} else {
					bs143 &= -3;
				}
				break;
			case 7:
				if(v143) {
					bs143 |= 1;
				} else {
					bs143 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs143;
		var this145 = 0;
		var bs144 = this145;
		var l144 = "*****".length;
		var _g1144 = 0;
		var _g244 = l144;
		while(_g1144 < _g244) {
			var i144 = _g1144++;
			var no144 = "*****".charCodeAt(i144);
			if(no144 == null) {
				break;
			}
			var v144;
			switch(no144) {
			case 32:
				v144 = false;
				break;
			case 42:
				v144 = true;
				break;
			case 48:
				v144 = false;
				break;
			case 49:
				v144 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i144)));
			}
			switch(i144 - (l144 - 8)) {
			case 0:
				if(v144) {
					bs144 |= 128;
				} else {
					bs144 &= -129;
				}
				break;
			case 1:
				if(v144) {
					bs144 |= 64;
				} else {
					bs144 &= -65;
				}
				break;
			case 2:
				if(v144) {
					bs144 |= 32;
				} else {
					bs144 &= -33;
				}
				break;
			case 3:
				if(v144) {
					bs144 |= 16;
				} else {
					bs144 &= -17;
				}
				break;
			case 4:
				if(v144) {
					bs144 |= 8;
				} else {
					bs144 &= -9;
				}
				break;
			case 5:
				if(v144) {
					bs144 |= 4;
				} else {
					bs144 &= -5;
				}
				break;
			case 6:
				if(v144) {
					bs144 |= 2;
				} else {
					bs144 &= -3;
				}
				break;
			case 7:
				if(v144) {
					bs144 |= 1;
				} else {
					bs144 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs144;
		var this146 = 0;
		var bs145 = this146;
		var l145 = "   * ".length;
		var _g1145 = 0;
		var _g245 = l145;
		while(_g1145 < _g245) {
			var i145 = _g1145++;
			var no145 = "   * ".charCodeAt(i145);
			if(no145 == null) {
				break;
			}
			var v145;
			switch(no145) {
			case 32:
				v145 = false;
				break;
			case 42:
				v145 = true;
				break;
			case 48:
				v145 = false;
				break;
			case 49:
				v145 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i145)));
			}
			switch(i145 - (l145 - 8)) {
			case 0:
				if(v145) {
					bs145 |= 128;
				} else {
					bs145 &= -129;
				}
				break;
			case 1:
				if(v145) {
					bs145 |= 64;
				} else {
					bs145 &= -65;
				}
				break;
			case 2:
				if(v145) {
					bs145 |= 32;
				} else {
					bs145 &= -33;
				}
				break;
			case 3:
				if(v145) {
					bs145 |= 16;
				} else {
					bs145 &= -17;
				}
				break;
			case 4:
				if(v145) {
					bs145 |= 8;
				} else {
					bs145 &= -9;
				}
				break;
			case 5:
				if(v145) {
					bs145 |= 4;
				} else {
					bs145 &= -5;
				}
				break;
			case 6:
				if(v145) {
					bs145 |= 2;
				} else {
					bs145 &= -3;
				}
				break;
			case 7:
				if(v145) {
					bs145 |= 1;
				} else {
					bs145 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs145;
		var this147 = 0;
		var bs146 = this147;
		var l146 = "   * ".length;
		var _g1146 = 0;
		var _g246 = l146;
		while(_g1146 < _g246) {
			var i146 = _g1146++;
			var no146 = "   * ".charCodeAt(i146);
			if(no146 == null) {
				break;
			}
			var v146;
			switch(no146) {
			case 32:
				v146 = false;
				break;
			case 42:
				v146 = true;
				break;
			case 48:
				v146 = false;
				break;
			case 49:
				v146 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i146)));
			}
			switch(i146 - (l146 - 8)) {
			case 0:
				if(v146) {
					bs146 |= 128;
				} else {
					bs146 &= -129;
				}
				break;
			case 1:
				if(v146) {
					bs146 |= 64;
				} else {
					bs146 &= -65;
				}
				break;
			case 2:
				if(v146) {
					bs146 |= 32;
				} else {
					bs146 &= -33;
				}
				break;
			case 3:
				if(v146) {
					bs146 |= 16;
				} else {
					bs146 &= -17;
				}
				break;
			case 4:
				if(v146) {
					bs146 |= 8;
				} else {
					bs146 &= -9;
				}
				break;
			case 5:
				if(v146) {
					bs146 |= 4;
				} else {
					bs146 &= -5;
				}
				break;
			case 6:
				if(v146) {
					bs146 |= 2;
				} else {
					bs146 &= -3;
				}
				break;
			case 7:
				if(v146) {
					bs146 |= 1;
				} else {
					bs146 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs146;
		break;
	case 53:
		var this148 = 0;
		var bs147 = this148;
		var l147 = "*****".length;
		var _g1147 = 0;
		var _g247 = l147;
		while(_g1147 < _g247) {
			var i147 = _g1147++;
			var no147 = "*****".charCodeAt(i147);
			if(no147 == null) {
				break;
			}
			var v147;
			switch(no147) {
			case 32:
				v147 = false;
				break;
			case 42:
				v147 = true;
				break;
			case 48:
				v147 = false;
				break;
			case 49:
				v147 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i147)));
			}
			switch(i147 - (l147 - 8)) {
			case 0:
				if(v147) {
					bs147 |= 128;
				} else {
					bs147 &= -129;
				}
				break;
			case 1:
				if(v147) {
					bs147 |= 64;
				} else {
					bs147 &= -65;
				}
				break;
			case 2:
				if(v147) {
					bs147 |= 32;
				} else {
					bs147 &= -33;
				}
				break;
			case 3:
				if(v147) {
					bs147 |= 16;
				} else {
					bs147 &= -17;
				}
				break;
			case 4:
				if(v147) {
					bs147 |= 8;
				} else {
					bs147 &= -9;
				}
				break;
			case 5:
				if(v147) {
					bs147 |= 4;
				} else {
					bs147 &= -5;
				}
				break;
			case 6:
				if(v147) {
					bs147 |= 2;
				} else {
					bs147 &= -3;
				}
				break;
			case 7:
				if(v147) {
					bs147 |= 1;
				} else {
					bs147 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs147;
		var this149 = 0;
		var bs148 = this149;
		var l148 = "*    ".length;
		var _g1148 = 0;
		var _g248 = l148;
		while(_g1148 < _g248) {
			var i148 = _g1148++;
			var no148 = "*    ".charCodeAt(i148);
			if(no148 == null) {
				break;
			}
			var v148;
			switch(no148) {
			case 32:
				v148 = false;
				break;
			case 42:
				v148 = true;
				break;
			case 48:
				v148 = false;
				break;
			case 49:
				v148 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i148)));
			}
			switch(i148 - (l148 - 8)) {
			case 0:
				if(v148) {
					bs148 |= 128;
				} else {
					bs148 &= -129;
				}
				break;
			case 1:
				if(v148) {
					bs148 |= 64;
				} else {
					bs148 &= -65;
				}
				break;
			case 2:
				if(v148) {
					bs148 |= 32;
				} else {
					bs148 &= -33;
				}
				break;
			case 3:
				if(v148) {
					bs148 |= 16;
				} else {
					bs148 &= -17;
				}
				break;
			case 4:
				if(v148) {
					bs148 |= 8;
				} else {
					bs148 &= -9;
				}
				break;
			case 5:
				if(v148) {
					bs148 |= 4;
				} else {
					bs148 &= -5;
				}
				break;
			case 6:
				if(v148) {
					bs148 |= 2;
				} else {
					bs148 &= -3;
				}
				break;
			case 7:
				if(v148) {
					bs148 |= 1;
				} else {
					bs148 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs148;
		var this150 = 0;
		var bs149 = this150;
		var l149 = "**** ".length;
		var _g1149 = 0;
		var _g249 = l149;
		while(_g1149 < _g249) {
			var i149 = _g1149++;
			var no149 = "**** ".charCodeAt(i149);
			if(no149 == null) {
				break;
			}
			var v149;
			switch(no149) {
			case 32:
				v149 = false;
				break;
			case 42:
				v149 = true;
				break;
			case 48:
				v149 = false;
				break;
			case 49:
				v149 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i149)));
			}
			switch(i149 - (l149 - 8)) {
			case 0:
				if(v149) {
					bs149 |= 128;
				} else {
					bs149 &= -129;
				}
				break;
			case 1:
				if(v149) {
					bs149 |= 64;
				} else {
					bs149 &= -65;
				}
				break;
			case 2:
				if(v149) {
					bs149 |= 32;
				} else {
					bs149 &= -33;
				}
				break;
			case 3:
				if(v149) {
					bs149 |= 16;
				} else {
					bs149 &= -17;
				}
				break;
			case 4:
				if(v149) {
					bs149 |= 8;
				} else {
					bs149 &= -9;
				}
				break;
			case 5:
				if(v149) {
					bs149 |= 4;
				} else {
					bs149 &= -5;
				}
				break;
			case 6:
				if(v149) {
					bs149 |= 2;
				} else {
					bs149 &= -3;
				}
				break;
			case 7:
				if(v149) {
					bs149 |= 1;
				} else {
					bs149 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs149;
		var this151 = 0;
		var bs150 = this151;
		var l150 = "    *".length;
		var _g1150 = 0;
		var _g250 = l150;
		while(_g1150 < _g250) {
			var i150 = _g1150++;
			var no150 = "    *".charCodeAt(i150);
			if(no150 == null) {
				break;
			}
			var v150;
			switch(no150) {
			case 32:
				v150 = false;
				break;
			case 42:
				v150 = true;
				break;
			case 48:
				v150 = false;
				break;
			case 49:
				v150 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i150)));
			}
			switch(i150 - (l150 - 8)) {
			case 0:
				if(v150) {
					bs150 |= 128;
				} else {
					bs150 &= -129;
				}
				break;
			case 1:
				if(v150) {
					bs150 |= 64;
				} else {
					bs150 &= -65;
				}
				break;
			case 2:
				if(v150) {
					bs150 |= 32;
				} else {
					bs150 &= -33;
				}
				break;
			case 3:
				if(v150) {
					bs150 |= 16;
				} else {
					bs150 &= -17;
				}
				break;
			case 4:
				if(v150) {
					bs150 |= 8;
				} else {
					bs150 &= -9;
				}
				break;
			case 5:
				if(v150) {
					bs150 |= 4;
				} else {
					bs150 &= -5;
				}
				break;
			case 6:
				if(v150) {
					bs150 |= 2;
				} else {
					bs150 &= -3;
				}
				break;
			case 7:
				if(v150) {
					bs150 |= 1;
				} else {
					bs150 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs150;
		var this152 = 0;
		var bs151 = this152;
		var l151 = "    *".length;
		var _g1151 = 0;
		var _g251 = l151;
		while(_g1151 < _g251) {
			var i151 = _g1151++;
			var no151 = "    *".charCodeAt(i151);
			if(no151 == null) {
				break;
			}
			var v151;
			switch(no151) {
			case 32:
				v151 = false;
				break;
			case 42:
				v151 = true;
				break;
			case 48:
				v151 = false;
				break;
			case 49:
				v151 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i151)));
			}
			switch(i151 - (l151 - 8)) {
			case 0:
				if(v151) {
					bs151 |= 128;
				} else {
					bs151 &= -129;
				}
				break;
			case 1:
				if(v151) {
					bs151 |= 64;
				} else {
					bs151 &= -65;
				}
				break;
			case 2:
				if(v151) {
					bs151 |= 32;
				} else {
					bs151 &= -33;
				}
				break;
			case 3:
				if(v151) {
					bs151 |= 16;
				} else {
					bs151 &= -17;
				}
				break;
			case 4:
				if(v151) {
					bs151 |= 8;
				} else {
					bs151 &= -9;
				}
				break;
			case 5:
				if(v151) {
					bs151 |= 4;
				} else {
					bs151 &= -5;
				}
				break;
			case 6:
				if(v151) {
					bs151 |= 2;
				} else {
					bs151 &= -3;
				}
				break;
			case 7:
				if(v151) {
					bs151 |= 1;
				} else {
					bs151 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs151;
		var this153 = 0;
		var bs152 = this153;
		var l152 = "*   *".length;
		var _g1152 = 0;
		var _g252 = l152;
		while(_g1152 < _g252) {
			var i152 = _g1152++;
			var no152 = "*   *".charCodeAt(i152);
			if(no152 == null) {
				break;
			}
			var v152;
			switch(no152) {
			case 32:
				v152 = false;
				break;
			case 42:
				v152 = true;
				break;
			case 48:
				v152 = false;
				break;
			case 49:
				v152 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i152)));
			}
			switch(i152 - (l152 - 8)) {
			case 0:
				if(v152) {
					bs152 |= 128;
				} else {
					bs152 &= -129;
				}
				break;
			case 1:
				if(v152) {
					bs152 |= 64;
				} else {
					bs152 &= -65;
				}
				break;
			case 2:
				if(v152) {
					bs152 |= 32;
				} else {
					bs152 &= -33;
				}
				break;
			case 3:
				if(v152) {
					bs152 |= 16;
				} else {
					bs152 &= -17;
				}
				break;
			case 4:
				if(v152) {
					bs152 |= 8;
				} else {
					bs152 &= -9;
				}
				break;
			case 5:
				if(v152) {
					bs152 |= 4;
				} else {
					bs152 &= -5;
				}
				break;
			case 6:
				if(v152) {
					bs152 |= 2;
				} else {
					bs152 &= -3;
				}
				break;
			case 7:
				if(v152) {
					bs152 |= 1;
				} else {
					bs152 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs152;
		var this154 = 0;
		var bs153 = this154;
		var l153 = " *** ".length;
		var _g1153 = 0;
		var _g253 = l153;
		while(_g1153 < _g253) {
			var i153 = _g1153++;
			var no153 = " *** ".charCodeAt(i153);
			if(no153 == null) {
				break;
			}
			var v153;
			switch(no153) {
			case 32:
				v153 = false;
				break;
			case 42:
				v153 = true;
				break;
			case 48:
				v153 = false;
				break;
			case 49:
				v153 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i153)));
			}
			switch(i153 - (l153 - 8)) {
			case 0:
				if(v153) {
					bs153 |= 128;
				} else {
					bs153 &= -129;
				}
				break;
			case 1:
				if(v153) {
					bs153 |= 64;
				} else {
					bs153 &= -65;
				}
				break;
			case 2:
				if(v153) {
					bs153 |= 32;
				} else {
					bs153 &= -33;
				}
				break;
			case 3:
				if(v153) {
					bs153 |= 16;
				} else {
					bs153 &= -17;
				}
				break;
			case 4:
				if(v153) {
					bs153 |= 8;
				} else {
					bs153 &= -9;
				}
				break;
			case 5:
				if(v153) {
					bs153 |= 4;
				} else {
					bs153 &= -5;
				}
				break;
			case 6:
				if(v153) {
					bs153 |= 2;
				} else {
					bs153 &= -3;
				}
				break;
			case 7:
				if(v153) {
					bs153 |= 1;
				} else {
					bs153 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs153;
		break;
	case 54:
		var this155 = 0;
		var bs154 = this155;
		var l154 = "  ** ".length;
		var _g1154 = 0;
		var _g254 = l154;
		while(_g1154 < _g254) {
			var i154 = _g1154++;
			var no154 = "  ** ".charCodeAt(i154);
			if(no154 == null) {
				break;
			}
			var v154;
			switch(no154) {
			case 32:
				v154 = false;
				break;
			case 42:
				v154 = true;
				break;
			case 48:
				v154 = false;
				break;
			case 49:
				v154 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i154)));
			}
			switch(i154 - (l154 - 8)) {
			case 0:
				if(v154) {
					bs154 |= 128;
				} else {
					bs154 &= -129;
				}
				break;
			case 1:
				if(v154) {
					bs154 |= 64;
				} else {
					bs154 &= -65;
				}
				break;
			case 2:
				if(v154) {
					bs154 |= 32;
				} else {
					bs154 &= -33;
				}
				break;
			case 3:
				if(v154) {
					bs154 |= 16;
				} else {
					bs154 &= -17;
				}
				break;
			case 4:
				if(v154) {
					bs154 |= 8;
				} else {
					bs154 &= -9;
				}
				break;
			case 5:
				if(v154) {
					bs154 |= 4;
				} else {
					bs154 &= -5;
				}
				break;
			case 6:
				if(v154) {
					bs154 |= 2;
				} else {
					bs154 &= -3;
				}
				break;
			case 7:
				if(v154) {
					bs154 |= 1;
				} else {
					bs154 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs154;
		var this156 = 0;
		var bs155 = this156;
		var l155 = " *   ".length;
		var _g1155 = 0;
		var _g255 = l155;
		while(_g1155 < _g255) {
			var i155 = _g1155++;
			var no155 = " *   ".charCodeAt(i155);
			if(no155 == null) {
				break;
			}
			var v155;
			switch(no155) {
			case 32:
				v155 = false;
				break;
			case 42:
				v155 = true;
				break;
			case 48:
				v155 = false;
				break;
			case 49:
				v155 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i155)));
			}
			switch(i155 - (l155 - 8)) {
			case 0:
				if(v155) {
					bs155 |= 128;
				} else {
					bs155 &= -129;
				}
				break;
			case 1:
				if(v155) {
					bs155 |= 64;
				} else {
					bs155 &= -65;
				}
				break;
			case 2:
				if(v155) {
					bs155 |= 32;
				} else {
					bs155 &= -33;
				}
				break;
			case 3:
				if(v155) {
					bs155 |= 16;
				} else {
					bs155 &= -17;
				}
				break;
			case 4:
				if(v155) {
					bs155 |= 8;
				} else {
					bs155 &= -9;
				}
				break;
			case 5:
				if(v155) {
					bs155 |= 4;
				} else {
					bs155 &= -5;
				}
				break;
			case 6:
				if(v155) {
					bs155 |= 2;
				} else {
					bs155 &= -3;
				}
				break;
			case 7:
				if(v155) {
					bs155 |= 1;
				} else {
					bs155 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs155;
		var this157 = 0;
		var bs156 = this157;
		var l156 = "*    ".length;
		var _g1156 = 0;
		var _g256 = l156;
		while(_g1156 < _g256) {
			var i156 = _g1156++;
			var no156 = "*    ".charCodeAt(i156);
			if(no156 == null) {
				break;
			}
			var v156;
			switch(no156) {
			case 32:
				v156 = false;
				break;
			case 42:
				v156 = true;
				break;
			case 48:
				v156 = false;
				break;
			case 49:
				v156 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i156)));
			}
			switch(i156 - (l156 - 8)) {
			case 0:
				if(v156) {
					bs156 |= 128;
				} else {
					bs156 &= -129;
				}
				break;
			case 1:
				if(v156) {
					bs156 |= 64;
				} else {
					bs156 &= -65;
				}
				break;
			case 2:
				if(v156) {
					bs156 |= 32;
				} else {
					bs156 &= -33;
				}
				break;
			case 3:
				if(v156) {
					bs156 |= 16;
				} else {
					bs156 &= -17;
				}
				break;
			case 4:
				if(v156) {
					bs156 |= 8;
				} else {
					bs156 &= -9;
				}
				break;
			case 5:
				if(v156) {
					bs156 |= 4;
				} else {
					bs156 &= -5;
				}
				break;
			case 6:
				if(v156) {
					bs156 |= 2;
				} else {
					bs156 &= -3;
				}
				break;
			case 7:
				if(v156) {
					bs156 |= 1;
				} else {
					bs156 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs156;
		var this158 = 0;
		var bs157 = this158;
		var l157 = "**** ".length;
		var _g1157 = 0;
		var _g257 = l157;
		while(_g1157 < _g257) {
			var i157 = _g1157++;
			var no157 = "**** ".charCodeAt(i157);
			if(no157 == null) {
				break;
			}
			var v157;
			switch(no157) {
			case 32:
				v157 = false;
				break;
			case 42:
				v157 = true;
				break;
			case 48:
				v157 = false;
				break;
			case 49:
				v157 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i157)));
			}
			switch(i157 - (l157 - 8)) {
			case 0:
				if(v157) {
					bs157 |= 128;
				} else {
					bs157 &= -129;
				}
				break;
			case 1:
				if(v157) {
					bs157 |= 64;
				} else {
					bs157 &= -65;
				}
				break;
			case 2:
				if(v157) {
					bs157 |= 32;
				} else {
					bs157 &= -33;
				}
				break;
			case 3:
				if(v157) {
					bs157 |= 16;
				} else {
					bs157 &= -17;
				}
				break;
			case 4:
				if(v157) {
					bs157 |= 8;
				} else {
					bs157 &= -9;
				}
				break;
			case 5:
				if(v157) {
					bs157 |= 4;
				} else {
					bs157 &= -5;
				}
				break;
			case 6:
				if(v157) {
					bs157 |= 2;
				} else {
					bs157 &= -3;
				}
				break;
			case 7:
				if(v157) {
					bs157 |= 1;
				} else {
					bs157 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs157;
		var this159 = 0;
		var bs158 = this159;
		var l158 = "*   *".length;
		var _g1158 = 0;
		var _g258 = l158;
		while(_g1158 < _g258) {
			var i158 = _g1158++;
			var no158 = "*   *".charCodeAt(i158);
			if(no158 == null) {
				break;
			}
			var v158;
			switch(no158) {
			case 32:
				v158 = false;
				break;
			case 42:
				v158 = true;
				break;
			case 48:
				v158 = false;
				break;
			case 49:
				v158 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i158)));
			}
			switch(i158 - (l158 - 8)) {
			case 0:
				if(v158) {
					bs158 |= 128;
				} else {
					bs158 &= -129;
				}
				break;
			case 1:
				if(v158) {
					bs158 |= 64;
				} else {
					bs158 &= -65;
				}
				break;
			case 2:
				if(v158) {
					bs158 |= 32;
				} else {
					bs158 &= -33;
				}
				break;
			case 3:
				if(v158) {
					bs158 |= 16;
				} else {
					bs158 &= -17;
				}
				break;
			case 4:
				if(v158) {
					bs158 |= 8;
				} else {
					bs158 &= -9;
				}
				break;
			case 5:
				if(v158) {
					bs158 |= 4;
				} else {
					bs158 &= -5;
				}
				break;
			case 6:
				if(v158) {
					bs158 |= 2;
				} else {
					bs158 &= -3;
				}
				break;
			case 7:
				if(v158) {
					bs158 |= 1;
				} else {
					bs158 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs158;
		var this160 = 0;
		var bs159 = this160;
		var l159 = "*   *".length;
		var _g1159 = 0;
		var _g259 = l159;
		while(_g1159 < _g259) {
			var i159 = _g1159++;
			var no159 = "*   *".charCodeAt(i159);
			if(no159 == null) {
				break;
			}
			var v159;
			switch(no159) {
			case 32:
				v159 = false;
				break;
			case 42:
				v159 = true;
				break;
			case 48:
				v159 = false;
				break;
			case 49:
				v159 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i159)));
			}
			switch(i159 - (l159 - 8)) {
			case 0:
				if(v159) {
					bs159 |= 128;
				} else {
					bs159 &= -129;
				}
				break;
			case 1:
				if(v159) {
					bs159 |= 64;
				} else {
					bs159 &= -65;
				}
				break;
			case 2:
				if(v159) {
					bs159 |= 32;
				} else {
					bs159 &= -33;
				}
				break;
			case 3:
				if(v159) {
					bs159 |= 16;
				} else {
					bs159 &= -17;
				}
				break;
			case 4:
				if(v159) {
					bs159 |= 8;
				} else {
					bs159 &= -9;
				}
				break;
			case 5:
				if(v159) {
					bs159 |= 4;
				} else {
					bs159 &= -5;
				}
				break;
			case 6:
				if(v159) {
					bs159 |= 2;
				} else {
					bs159 &= -3;
				}
				break;
			case 7:
				if(v159) {
					bs159 |= 1;
				} else {
					bs159 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs159;
		var this161 = 0;
		var bs160 = this161;
		var l160 = " *** ".length;
		var _g1160 = 0;
		var _g260 = l160;
		while(_g1160 < _g260) {
			var i160 = _g1160++;
			var no160 = " *** ".charCodeAt(i160);
			if(no160 == null) {
				break;
			}
			var v160;
			switch(no160) {
			case 32:
				v160 = false;
				break;
			case 42:
				v160 = true;
				break;
			case 48:
				v160 = false;
				break;
			case 49:
				v160 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i160)));
			}
			switch(i160 - (l160 - 8)) {
			case 0:
				if(v160) {
					bs160 |= 128;
				} else {
					bs160 &= -129;
				}
				break;
			case 1:
				if(v160) {
					bs160 |= 64;
				} else {
					bs160 &= -65;
				}
				break;
			case 2:
				if(v160) {
					bs160 |= 32;
				} else {
					bs160 &= -33;
				}
				break;
			case 3:
				if(v160) {
					bs160 |= 16;
				} else {
					bs160 &= -17;
				}
				break;
			case 4:
				if(v160) {
					bs160 |= 8;
				} else {
					bs160 &= -9;
				}
				break;
			case 5:
				if(v160) {
					bs160 |= 4;
				} else {
					bs160 &= -5;
				}
				break;
			case 6:
				if(v160) {
					bs160 |= 2;
				} else {
					bs160 &= -3;
				}
				break;
			case 7:
				if(v160) {
					bs160 |= 1;
				} else {
					bs160 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs160;
		break;
	case 55:
		var this162 = 0;
		var bs161 = this162;
		var l161 = "*****".length;
		var _g1161 = 0;
		var _g261 = l161;
		while(_g1161 < _g261) {
			var i161 = _g1161++;
			var no161 = "*****".charCodeAt(i161);
			if(no161 == null) {
				break;
			}
			var v161;
			switch(no161) {
			case 32:
				v161 = false;
				break;
			case 42:
				v161 = true;
				break;
			case 48:
				v161 = false;
				break;
			case 49:
				v161 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i161)));
			}
			switch(i161 - (l161 - 8)) {
			case 0:
				if(v161) {
					bs161 |= 128;
				} else {
					bs161 &= -129;
				}
				break;
			case 1:
				if(v161) {
					bs161 |= 64;
				} else {
					bs161 &= -65;
				}
				break;
			case 2:
				if(v161) {
					bs161 |= 32;
				} else {
					bs161 &= -33;
				}
				break;
			case 3:
				if(v161) {
					bs161 |= 16;
				} else {
					bs161 &= -17;
				}
				break;
			case 4:
				if(v161) {
					bs161 |= 8;
				} else {
					bs161 &= -9;
				}
				break;
			case 5:
				if(v161) {
					bs161 |= 4;
				} else {
					bs161 &= -5;
				}
				break;
			case 6:
				if(v161) {
					bs161 |= 2;
				} else {
					bs161 &= -3;
				}
				break;
			case 7:
				if(v161) {
					bs161 |= 1;
				} else {
					bs161 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs161;
		var this163 = 0;
		var bs162 = this163;
		var l162 = "    *".length;
		var _g1162 = 0;
		var _g262 = l162;
		while(_g1162 < _g262) {
			var i162 = _g1162++;
			var no162 = "    *".charCodeAt(i162);
			if(no162 == null) {
				break;
			}
			var v162;
			switch(no162) {
			case 32:
				v162 = false;
				break;
			case 42:
				v162 = true;
				break;
			case 48:
				v162 = false;
				break;
			case 49:
				v162 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i162)));
			}
			switch(i162 - (l162 - 8)) {
			case 0:
				if(v162) {
					bs162 |= 128;
				} else {
					bs162 &= -129;
				}
				break;
			case 1:
				if(v162) {
					bs162 |= 64;
				} else {
					bs162 &= -65;
				}
				break;
			case 2:
				if(v162) {
					bs162 |= 32;
				} else {
					bs162 &= -33;
				}
				break;
			case 3:
				if(v162) {
					bs162 |= 16;
				} else {
					bs162 &= -17;
				}
				break;
			case 4:
				if(v162) {
					bs162 |= 8;
				} else {
					bs162 &= -9;
				}
				break;
			case 5:
				if(v162) {
					bs162 |= 4;
				} else {
					bs162 &= -5;
				}
				break;
			case 6:
				if(v162) {
					bs162 |= 2;
				} else {
					bs162 &= -3;
				}
				break;
			case 7:
				if(v162) {
					bs162 |= 1;
				} else {
					bs162 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs162;
		var this164 = 0;
		var bs163 = this164;
		var l163 = "   * ".length;
		var _g1163 = 0;
		var _g263 = l163;
		while(_g1163 < _g263) {
			var i163 = _g1163++;
			var no163 = "   * ".charCodeAt(i163);
			if(no163 == null) {
				break;
			}
			var v163;
			switch(no163) {
			case 32:
				v163 = false;
				break;
			case 42:
				v163 = true;
				break;
			case 48:
				v163 = false;
				break;
			case 49:
				v163 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i163)));
			}
			switch(i163 - (l163 - 8)) {
			case 0:
				if(v163) {
					bs163 |= 128;
				} else {
					bs163 &= -129;
				}
				break;
			case 1:
				if(v163) {
					bs163 |= 64;
				} else {
					bs163 &= -65;
				}
				break;
			case 2:
				if(v163) {
					bs163 |= 32;
				} else {
					bs163 &= -33;
				}
				break;
			case 3:
				if(v163) {
					bs163 |= 16;
				} else {
					bs163 &= -17;
				}
				break;
			case 4:
				if(v163) {
					bs163 |= 8;
				} else {
					bs163 &= -9;
				}
				break;
			case 5:
				if(v163) {
					bs163 |= 4;
				} else {
					bs163 &= -5;
				}
				break;
			case 6:
				if(v163) {
					bs163 |= 2;
				} else {
					bs163 &= -3;
				}
				break;
			case 7:
				if(v163) {
					bs163 |= 1;
				} else {
					bs163 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs163;
		var this165 = 0;
		var bs164 = this165;
		var l164 = "  *  ".length;
		var _g1164 = 0;
		var _g264 = l164;
		while(_g1164 < _g264) {
			var i164 = _g1164++;
			var no164 = "  *  ".charCodeAt(i164);
			if(no164 == null) {
				break;
			}
			var v164;
			switch(no164) {
			case 32:
				v164 = false;
				break;
			case 42:
				v164 = true;
				break;
			case 48:
				v164 = false;
				break;
			case 49:
				v164 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i164)));
			}
			switch(i164 - (l164 - 8)) {
			case 0:
				if(v164) {
					bs164 |= 128;
				} else {
					bs164 &= -129;
				}
				break;
			case 1:
				if(v164) {
					bs164 |= 64;
				} else {
					bs164 &= -65;
				}
				break;
			case 2:
				if(v164) {
					bs164 |= 32;
				} else {
					bs164 &= -33;
				}
				break;
			case 3:
				if(v164) {
					bs164 |= 16;
				} else {
					bs164 &= -17;
				}
				break;
			case 4:
				if(v164) {
					bs164 |= 8;
				} else {
					bs164 &= -9;
				}
				break;
			case 5:
				if(v164) {
					bs164 |= 4;
				} else {
					bs164 &= -5;
				}
				break;
			case 6:
				if(v164) {
					bs164 |= 2;
				} else {
					bs164 &= -3;
				}
				break;
			case 7:
				if(v164) {
					bs164 |= 1;
				} else {
					bs164 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs164;
		var this166 = 0;
		var bs165 = this166;
		var l165 = " *   ".length;
		var _g1165 = 0;
		var _g265 = l165;
		while(_g1165 < _g265) {
			var i165 = _g1165++;
			var no165 = " *   ".charCodeAt(i165);
			if(no165 == null) {
				break;
			}
			var v165;
			switch(no165) {
			case 32:
				v165 = false;
				break;
			case 42:
				v165 = true;
				break;
			case 48:
				v165 = false;
				break;
			case 49:
				v165 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i165)));
			}
			switch(i165 - (l165 - 8)) {
			case 0:
				if(v165) {
					bs165 |= 128;
				} else {
					bs165 &= -129;
				}
				break;
			case 1:
				if(v165) {
					bs165 |= 64;
				} else {
					bs165 &= -65;
				}
				break;
			case 2:
				if(v165) {
					bs165 |= 32;
				} else {
					bs165 &= -33;
				}
				break;
			case 3:
				if(v165) {
					bs165 |= 16;
				} else {
					bs165 &= -17;
				}
				break;
			case 4:
				if(v165) {
					bs165 |= 8;
				} else {
					bs165 &= -9;
				}
				break;
			case 5:
				if(v165) {
					bs165 |= 4;
				} else {
					bs165 &= -5;
				}
				break;
			case 6:
				if(v165) {
					bs165 |= 2;
				} else {
					bs165 &= -3;
				}
				break;
			case 7:
				if(v165) {
					bs165 |= 1;
				} else {
					bs165 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs165;
		var this167 = 0;
		var bs166 = this167;
		var l166 = " *   ".length;
		var _g1166 = 0;
		var _g266 = l166;
		while(_g1166 < _g266) {
			var i166 = _g1166++;
			var no166 = " *   ".charCodeAt(i166);
			if(no166 == null) {
				break;
			}
			var v166;
			switch(no166) {
			case 32:
				v166 = false;
				break;
			case 42:
				v166 = true;
				break;
			case 48:
				v166 = false;
				break;
			case 49:
				v166 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i166)));
			}
			switch(i166 - (l166 - 8)) {
			case 0:
				if(v166) {
					bs166 |= 128;
				} else {
					bs166 &= -129;
				}
				break;
			case 1:
				if(v166) {
					bs166 |= 64;
				} else {
					bs166 &= -65;
				}
				break;
			case 2:
				if(v166) {
					bs166 |= 32;
				} else {
					bs166 &= -33;
				}
				break;
			case 3:
				if(v166) {
					bs166 |= 16;
				} else {
					bs166 &= -17;
				}
				break;
			case 4:
				if(v166) {
					bs166 |= 8;
				} else {
					bs166 &= -9;
				}
				break;
			case 5:
				if(v166) {
					bs166 |= 4;
				} else {
					bs166 &= -5;
				}
				break;
			case 6:
				if(v166) {
					bs166 |= 2;
				} else {
					bs166 &= -3;
				}
				break;
			case 7:
				if(v166) {
					bs166 |= 1;
				} else {
					bs166 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs166;
		var this168 = 0;
		var bs167 = this168;
		var l167 = " *   ".length;
		var _g1167 = 0;
		var _g267 = l167;
		while(_g1167 < _g267) {
			var i167 = _g1167++;
			var no167 = " *   ".charCodeAt(i167);
			if(no167 == null) {
				break;
			}
			var v167;
			switch(no167) {
			case 32:
				v167 = false;
				break;
			case 42:
				v167 = true;
				break;
			case 48:
				v167 = false;
				break;
			case 49:
				v167 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i167)));
			}
			switch(i167 - (l167 - 8)) {
			case 0:
				if(v167) {
					bs167 |= 128;
				} else {
					bs167 &= -129;
				}
				break;
			case 1:
				if(v167) {
					bs167 |= 64;
				} else {
					bs167 &= -65;
				}
				break;
			case 2:
				if(v167) {
					bs167 |= 32;
				} else {
					bs167 &= -33;
				}
				break;
			case 3:
				if(v167) {
					bs167 |= 16;
				} else {
					bs167 &= -17;
				}
				break;
			case 4:
				if(v167) {
					bs167 |= 8;
				} else {
					bs167 &= -9;
				}
				break;
			case 5:
				if(v167) {
					bs167 |= 4;
				} else {
					bs167 &= -5;
				}
				break;
			case 6:
				if(v167) {
					bs167 |= 2;
				} else {
					bs167 &= -3;
				}
				break;
			case 7:
				if(v167) {
					bs167 |= 1;
				} else {
					bs167 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs167;
		break;
	case 56:
		var this169 = 0;
		var bs168 = this169;
		var l168 = " *** ".length;
		var _g1168 = 0;
		var _g268 = l168;
		while(_g1168 < _g268) {
			var i168 = _g1168++;
			var no168 = " *** ".charCodeAt(i168);
			if(no168 == null) {
				break;
			}
			var v168;
			switch(no168) {
			case 32:
				v168 = false;
				break;
			case 42:
				v168 = true;
				break;
			case 48:
				v168 = false;
				break;
			case 49:
				v168 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i168)));
			}
			switch(i168 - (l168 - 8)) {
			case 0:
				if(v168) {
					bs168 |= 128;
				} else {
					bs168 &= -129;
				}
				break;
			case 1:
				if(v168) {
					bs168 |= 64;
				} else {
					bs168 &= -65;
				}
				break;
			case 2:
				if(v168) {
					bs168 |= 32;
				} else {
					bs168 &= -33;
				}
				break;
			case 3:
				if(v168) {
					bs168 |= 16;
				} else {
					bs168 &= -17;
				}
				break;
			case 4:
				if(v168) {
					bs168 |= 8;
				} else {
					bs168 &= -9;
				}
				break;
			case 5:
				if(v168) {
					bs168 |= 4;
				} else {
					bs168 &= -5;
				}
				break;
			case 6:
				if(v168) {
					bs168 |= 2;
				} else {
					bs168 &= -3;
				}
				break;
			case 7:
				if(v168) {
					bs168 |= 1;
				} else {
					bs168 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs168;
		var this170 = 0;
		var bs169 = this170;
		var l169 = "*   *".length;
		var _g1169 = 0;
		var _g269 = l169;
		while(_g1169 < _g269) {
			var i169 = _g1169++;
			var no169 = "*   *".charCodeAt(i169);
			if(no169 == null) {
				break;
			}
			var v169;
			switch(no169) {
			case 32:
				v169 = false;
				break;
			case 42:
				v169 = true;
				break;
			case 48:
				v169 = false;
				break;
			case 49:
				v169 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i169)));
			}
			switch(i169 - (l169 - 8)) {
			case 0:
				if(v169) {
					bs169 |= 128;
				} else {
					bs169 &= -129;
				}
				break;
			case 1:
				if(v169) {
					bs169 |= 64;
				} else {
					bs169 &= -65;
				}
				break;
			case 2:
				if(v169) {
					bs169 |= 32;
				} else {
					bs169 &= -33;
				}
				break;
			case 3:
				if(v169) {
					bs169 |= 16;
				} else {
					bs169 &= -17;
				}
				break;
			case 4:
				if(v169) {
					bs169 |= 8;
				} else {
					bs169 &= -9;
				}
				break;
			case 5:
				if(v169) {
					bs169 |= 4;
				} else {
					bs169 &= -5;
				}
				break;
			case 6:
				if(v169) {
					bs169 |= 2;
				} else {
					bs169 &= -3;
				}
				break;
			case 7:
				if(v169) {
					bs169 |= 1;
				} else {
					bs169 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs169;
		var this171 = 0;
		var bs170 = this171;
		var l170 = "*   *".length;
		var _g1170 = 0;
		var _g270 = l170;
		while(_g1170 < _g270) {
			var i170 = _g1170++;
			var no170 = "*   *".charCodeAt(i170);
			if(no170 == null) {
				break;
			}
			var v170;
			switch(no170) {
			case 32:
				v170 = false;
				break;
			case 42:
				v170 = true;
				break;
			case 48:
				v170 = false;
				break;
			case 49:
				v170 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i170)));
			}
			switch(i170 - (l170 - 8)) {
			case 0:
				if(v170) {
					bs170 |= 128;
				} else {
					bs170 &= -129;
				}
				break;
			case 1:
				if(v170) {
					bs170 |= 64;
				} else {
					bs170 &= -65;
				}
				break;
			case 2:
				if(v170) {
					bs170 |= 32;
				} else {
					bs170 &= -33;
				}
				break;
			case 3:
				if(v170) {
					bs170 |= 16;
				} else {
					bs170 &= -17;
				}
				break;
			case 4:
				if(v170) {
					bs170 |= 8;
				} else {
					bs170 &= -9;
				}
				break;
			case 5:
				if(v170) {
					bs170 |= 4;
				} else {
					bs170 &= -5;
				}
				break;
			case 6:
				if(v170) {
					bs170 |= 2;
				} else {
					bs170 &= -3;
				}
				break;
			case 7:
				if(v170) {
					bs170 |= 1;
				} else {
					bs170 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs170;
		var this172 = 0;
		var bs171 = this172;
		var l171 = " *** ".length;
		var _g1171 = 0;
		var _g271 = l171;
		while(_g1171 < _g271) {
			var i171 = _g1171++;
			var no171 = " *** ".charCodeAt(i171);
			if(no171 == null) {
				break;
			}
			var v171;
			switch(no171) {
			case 32:
				v171 = false;
				break;
			case 42:
				v171 = true;
				break;
			case 48:
				v171 = false;
				break;
			case 49:
				v171 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i171)));
			}
			switch(i171 - (l171 - 8)) {
			case 0:
				if(v171) {
					bs171 |= 128;
				} else {
					bs171 &= -129;
				}
				break;
			case 1:
				if(v171) {
					bs171 |= 64;
				} else {
					bs171 &= -65;
				}
				break;
			case 2:
				if(v171) {
					bs171 |= 32;
				} else {
					bs171 &= -33;
				}
				break;
			case 3:
				if(v171) {
					bs171 |= 16;
				} else {
					bs171 &= -17;
				}
				break;
			case 4:
				if(v171) {
					bs171 |= 8;
				} else {
					bs171 &= -9;
				}
				break;
			case 5:
				if(v171) {
					bs171 |= 4;
				} else {
					bs171 &= -5;
				}
				break;
			case 6:
				if(v171) {
					bs171 |= 2;
				} else {
					bs171 &= -3;
				}
				break;
			case 7:
				if(v171) {
					bs171 |= 1;
				} else {
					bs171 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs171;
		var this173 = 0;
		var bs172 = this173;
		var l172 = "*   *".length;
		var _g1172 = 0;
		var _g272 = l172;
		while(_g1172 < _g272) {
			var i172 = _g1172++;
			var no172 = "*   *".charCodeAt(i172);
			if(no172 == null) {
				break;
			}
			var v172;
			switch(no172) {
			case 32:
				v172 = false;
				break;
			case 42:
				v172 = true;
				break;
			case 48:
				v172 = false;
				break;
			case 49:
				v172 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i172)));
			}
			switch(i172 - (l172 - 8)) {
			case 0:
				if(v172) {
					bs172 |= 128;
				} else {
					bs172 &= -129;
				}
				break;
			case 1:
				if(v172) {
					bs172 |= 64;
				} else {
					bs172 &= -65;
				}
				break;
			case 2:
				if(v172) {
					bs172 |= 32;
				} else {
					bs172 &= -33;
				}
				break;
			case 3:
				if(v172) {
					bs172 |= 16;
				} else {
					bs172 &= -17;
				}
				break;
			case 4:
				if(v172) {
					bs172 |= 8;
				} else {
					bs172 &= -9;
				}
				break;
			case 5:
				if(v172) {
					bs172 |= 4;
				} else {
					bs172 &= -5;
				}
				break;
			case 6:
				if(v172) {
					bs172 |= 2;
				} else {
					bs172 &= -3;
				}
				break;
			case 7:
				if(v172) {
					bs172 |= 1;
				} else {
					bs172 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs172;
		var this174 = 0;
		var bs173 = this174;
		var l173 = "*   *".length;
		var _g1173 = 0;
		var _g273 = l173;
		while(_g1173 < _g273) {
			var i173 = _g1173++;
			var no173 = "*   *".charCodeAt(i173);
			if(no173 == null) {
				break;
			}
			var v173;
			switch(no173) {
			case 32:
				v173 = false;
				break;
			case 42:
				v173 = true;
				break;
			case 48:
				v173 = false;
				break;
			case 49:
				v173 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i173)));
			}
			switch(i173 - (l173 - 8)) {
			case 0:
				if(v173) {
					bs173 |= 128;
				} else {
					bs173 &= -129;
				}
				break;
			case 1:
				if(v173) {
					bs173 |= 64;
				} else {
					bs173 &= -65;
				}
				break;
			case 2:
				if(v173) {
					bs173 |= 32;
				} else {
					bs173 &= -33;
				}
				break;
			case 3:
				if(v173) {
					bs173 |= 16;
				} else {
					bs173 &= -17;
				}
				break;
			case 4:
				if(v173) {
					bs173 |= 8;
				} else {
					bs173 &= -9;
				}
				break;
			case 5:
				if(v173) {
					bs173 |= 4;
				} else {
					bs173 &= -5;
				}
				break;
			case 6:
				if(v173) {
					bs173 |= 2;
				} else {
					bs173 &= -3;
				}
				break;
			case 7:
				if(v173) {
					bs173 |= 1;
				} else {
					bs173 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs173;
		var this175 = 0;
		var bs174 = this175;
		var l174 = " *** ".length;
		var _g1174 = 0;
		var _g274 = l174;
		while(_g1174 < _g274) {
			var i174 = _g1174++;
			var no174 = " *** ".charCodeAt(i174);
			if(no174 == null) {
				break;
			}
			var v174;
			switch(no174) {
			case 32:
				v174 = false;
				break;
			case 42:
				v174 = true;
				break;
			case 48:
				v174 = false;
				break;
			case 49:
				v174 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i174)));
			}
			switch(i174 - (l174 - 8)) {
			case 0:
				if(v174) {
					bs174 |= 128;
				} else {
					bs174 &= -129;
				}
				break;
			case 1:
				if(v174) {
					bs174 |= 64;
				} else {
					bs174 &= -65;
				}
				break;
			case 2:
				if(v174) {
					bs174 |= 32;
				} else {
					bs174 &= -33;
				}
				break;
			case 3:
				if(v174) {
					bs174 |= 16;
				} else {
					bs174 &= -17;
				}
				break;
			case 4:
				if(v174) {
					bs174 |= 8;
				} else {
					bs174 &= -9;
				}
				break;
			case 5:
				if(v174) {
					bs174 |= 4;
				} else {
					bs174 &= -5;
				}
				break;
			case 6:
				if(v174) {
					bs174 |= 2;
				} else {
					bs174 &= -3;
				}
				break;
			case 7:
				if(v174) {
					bs174 |= 1;
				} else {
					bs174 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs174;
		break;
	case 57:
		var this176 = 0;
		var bs175 = this176;
		var l175 = " *** ".length;
		var _g1175 = 0;
		var _g275 = l175;
		while(_g1175 < _g275) {
			var i175 = _g1175++;
			var no175 = " *** ".charCodeAt(i175);
			if(no175 == null) {
				break;
			}
			var v175;
			switch(no175) {
			case 32:
				v175 = false;
				break;
			case 42:
				v175 = true;
				break;
			case 48:
				v175 = false;
				break;
			case 49:
				v175 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i175)));
			}
			switch(i175 - (l175 - 8)) {
			case 0:
				if(v175) {
					bs175 |= 128;
				} else {
					bs175 &= -129;
				}
				break;
			case 1:
				if(v175) {
					bs175 |= 64;
				} else {
					bs175 &= -65;
				}
				break;
			case 2:
				if(v175) {
					bs175 |= 32;
				} else {
					bs175 &= -33;
				}
				break;
			case 3:
				if(v175) {
					bs175 |= 16;
				} else {
					bs175 &= -17;
				}
				break;
			case 4:
				if(v175) {
					bs175 |= 8;
				} else {
					bs175 &= -9;
				}
				break;
			case 5:
				if(v175) {
					bs175 |= 4;
				} else {
					bs175 &= -5;
				}
				break;
			case 6:
				if(v175) {
					bs175 |= 2;
				} else {
					bs175 &= -3;
				}
				break;
			case 7:
				if(v175) {
					bs175 |= 1;
				} else {
					bs175 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs175;
		var this177 = 0;
		var bs176 = this177;
		var l176 = "*   *".length;
		var _g1176 = 0;
		var _g276 = l176;
		while(_g1176 < _g276) {
			var i176 = _g1176++;
			var no176 = "*   *".charCodeAt(i176);
			if(no176 == null) {
				break;
			}
			var v176;
			switch(no176) {
			case 32:
				v176 = false;
				break;
			case 42:
				v176 = true;
				break;
			case 48:
				v176 = false;
				break;
			case 49:
				v176 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i176)));
			}
			switch(i176 - (l176 - 8)) {
			case 0:
				if(v176) {
					bs176 |= 128;
				} else {
					bs176 &= -129;
				}
				break;
			case 1:
				if(v176) {
					bs176 |= 64;
				} else {
					bs176 &= -65;
				}
				break;
			case 2:
				if(v176) {
					bs176 |= 32;
				} else {
					bs176 &= -33;
				}
				break;
			case 3:
				if(v176) {
					bs176 |= 16;
				} else {
					bs176 &= -17;
				}
				break;
			case 4:
				if(v176) {
					bs176 |= 8;
				} else {
					bs176 &= -9;
				}
				break;
			case 5:
				if(v176) {
					bs176 |= 4;
				} else {
					bs176 &= -5;
				}
				break;
			case 6:
				if(v176) {
					bs176 |= 2;
				} else {
					bs176 &= -3;
				}
				break;
			case 7:
				if(v176) {
					bs176 |= 1;
				} else {
					bs176 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs176;
		var this178 = 0;
		var bs177 = this178;
		var l177 = "*   *".length;
		var _g1177 = 0;
		var _g277 = l177;
		while(_g1177 < _g277) {
			var i177 = _g1177++;
			var no177 = "*   *".charCodeAt(i177);
			if(no177 == null) {
				break;
			}
			var v177;
			switch(no177) {
			case 32:
				v177 = false;
				break;
			case 42:
				v177 = true;
				break;
			case 48:
				v177 = false;
				break;
			case 49:
				v177 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i177)));
			}
			switch(i177 - (l177 - 8)) {
			case 0:
				if(v177) {
					bs177 |= 128;
				} else {
					bs177 &= -129;
				}
				break;
			case 1:
				if(v177) {
					bs177 |= 64;
				} else {
					bs177 &= -65;
				}
				break;
			case 2:
				if(v177) {
					bs177 |= 32;
				} else {
					bs177 &= -33;
				}
				break;
			case 3:
				if(v177) {
					bs177 |= 16;
				} else {
					bs177 &= -17;
				}
				break;
			case 4:
				if(v177) {
					bs177 |= 8;
				} else {
					bs177 &= -9;
				}
				break;
			case 5:
				if(v177) {
					bs177 |= 4;
				} else {
					bs177 &= -5;
				}
				break;
			case 6:
				if(v177) {
					bs177 |= 2;
				} else {
					bs177 &= -3;
				}
				break;
			case 7:
				if(v177) {
					bs177 |= 1;
				} else {
					bs177 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs177;
		var this179 = 0;
		var bs178 = this179;
		var l178 = " ****".length;
		var _g1178 = 0;
		var _g278 = l178;
		while(_g1178 < _g278) {
			var i178 = _g1178++;
			var no178 = " ****".charCodeAt(i178);
			if(no178 == null) {
				break;
			}
			var v178;
			switch(no178) {
			case 32:
				v178 = false;
				break;
			case 42:
				v178 = true;
				break;
			case 48:
				v178 = false;
				break;
			case 49:
				v178 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i178)));
			}
			switch(i178 - (l178 - 8)) {
			case 0:
				if(v178) {
					bs178 |= 128;
				} else {
					bs178 &= -129;
				}
				break;
			case 1:
				if(v178) {
					bs178 |= 64;
				} else {
					bs178 &= -65;
				}
				break;
			case 2:
				if(v178) {
					bs178 |= 32;
				} else {
					bs178 &= -33;
				}
				break;
			case 3:
				if(v178) {
					bs178 |= 16;
				} else {
					bs178 &= -17;
				}
				break;
			case 4:
				if(v178) {
					bs178 |= 8;
				} else {
					bs178 &= -9;
				}
				break;
			case 5:
				if(v178) {
					bs178 |= 4;
				} else {
					bs178 &= -5;
				}
				break;
			case 6:
				if(v178) {
					bs178 |= 2;
				} else {
					bs178 &= -3;
				}
				break;
			case 7:
				if(v178) {
					bs178 |= 1;
				} else {
					bs178 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs178;
		var this180 = 0;
		var bs179 = this180;
		var l179 = "    *".length;
		var _g1179 = 0;
		var _g279 = l179;
		while(_g1179 < _g279) {
			var i179 = _g1179++;
			var no179 = "    *".charCodeAt(i179);
			if(no179 == null) {
				break;
			}
			var v179;
			switch(no179) {
			case 32:
				v179 = false;
				break;
			case 42:
				v179 = true;
				break;
			case 48:
				v179 = false;
				break;
			case 49:
				v179 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i179)));
			}
			switch(i179 - (l179 - 8)) {
			case 0:
				if(v179) {
					bs179 |= 128;
				} else {
					bs179 &= -129;
				}
				break;
			case 1:
				if(v179) {
					bs179 |= 64;
				} else {
					bs179 &= -65;
				}
				break;
			case 2:
				if(v179) {
					bs179 |= 32;
				} else {
					bs179 &= -33;
				}
				break;
			case 3:
				if(v179) {
					bs179 |= 16;
				} else {
					bs179 &= -17;
				}
				break;
			case 4:
				if(v179) {
					bs179 |= 8;
				} else {
					bs179 &= -9;
				}
				break;
			case 5:
				if(v179) {
					bs179 |= 4;
				} else {
					bs179 &= -5;
				}
				break;
			case 6:
				if(v179) {
					bs179 |= 2;
				} else {
					bs179 &= -3;
				}
				break;
			case 7:
				if(v179) {
					bs179 |= 1;
				} else {
					bs179 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs179;
		var this181 = 0;
		var bs180 = this181;
		var l180 = "   * ".length;
		var _g1180 = 0;
		var _g280 = l180;
		while(_g1180 < _g280) {
			var i180 = _g1180++;
			var no180 = "   * ".charCodeAt(i180);
			if(no180 == null) {
				break;
			}
			var v180;
			switch(no180) {
			case 32:
				v180 = false;
				break;
			case 42:
				v180 = true;
				break;
			case 48:
				v180 = false;
				break;
			case 49:
				v180 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i180)));
			}
			switch(i180 - (l180 - 8)) {
			case 0:
				if(v180) {
					bs180 |= 128;
				} else {
					bs180 &= -129;
				}
				break;
			case 1:
				if(v180) {
					bs180 |= 64;
				} else {
					bs180 &= -65;
				}
				break;
			case 2:
				if(v180) {
					bs180 |= 32;
				} else {
					bs180 &= -33;
				}
				break;
			case 3:
				if(v180) {
					bs180 |= 16;
				} else {
					bs180 &= -17;
				}
				break;
			case 4:
				if(v180) {
					bs180 |= 8;
				} else {
					bs180 &= -9;
				}
				break;
			case 5:
				if(v180) {
					bs180 |= 4;
				} else {
					bs180 &= -5;
				}
				break;
			case 6:
				if(v180) {
					bs180 |= 2;
				} else {
					bs180 &= -3;
				}
				break;
			case 7:
				if(v180) {
					bs180 |= 1;
				} else {
					bs180 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs180;
		var this182 = 0;
		var bs181 = this182;
		var l181 = " **  ".length;
		var _g1181 = 0;
		var _g281 = l181;
		while(_g1181 < _g281) {
			var i181 = _g1181++;
			var no181 = " **  ".charCodeAt(i181);
			if(no181 == null) {
				break;
			}
			var v181;
			switch(no181) {
			case 32:
				v181 = false;
				break;
			case 42:
				v181 = true;
				break;
			case 48:
				v181 = false;
				break;
			case 49:
				v181 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i181)));
			}
			switch(i181 - (l181 - 8)) {
			case 0:
				if(v181) {
					bs181 |= 128;
				} else {
					bs181 &= -129;
				}
				break;
			case 1:
				if(v181) {
					bs181 |= 64;
				} else {
					bs181 &= -65;
				}
				break;
			case 2:
				if(v181) {
					bs181 |= 32;
				} else {
					bs181 &= -33;
				}
				break;
			case 3:
				if(v181) {
					bs181 |= 16;
				} else {
					bs181 &= -17;
				}
				break;
			case 4:
				if(v181) {
					bs181 |= 8;
				} else {
					bs181 &= -9;
				}
				break;
			case 5:
				if(v181) {
					bs181 |= 4;
				} else {
					bs181 &= -5;
				}
				break;
			case 6:
				if(v181) {
					bs181 |= 2;
				} else {
					bs181 &= -3;
				}
				break;
			case 7:
				if(v181) {
					bs181 |= 1;
				} else {
					bs181 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs181;
		break;
	case 58:
		var this183 = 0;
		var bs182 = this183;
		var l182 = "     ".length;
		var _g1182 = 0;
		var _g282 = l182;
		while(_g1182 < _g282) {
			var i182 = _g1182++;
			var no182 = "     ".charCodeAt(i182);
			if(no182 == null) {
				break;
			}
			var v182;
			switch(no182) {
			case 32:
				v182 = false;
				break;
			case 42:
				v182 = true;
				break;
			case 48:
				v182 = false;
				break;
			case 49:
				v182 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i182)));
			}
			switch(i182 - (l182 - 8)) {
			case 0:
				if(v182) {
					bs182 |= 128;
				} else {
					bs182 &= -129;
				}
				break;
			case 1:
				if(v182) {
					bs182 |= 64;
				} else {
					bs182 &= -65;
				}
				break;
			case 2:
				if(v182) {
					bs182 |= 32;
				} else {
					bs182 &= -33;
				}
				break;
			case 3:
				if(v182) {
					bs182 |= 16;
				} else {
					bs182 &= -17;
				}
				break;
			case 4:
				if(v182) {
					bs182 |= 8;
				} else {
					bs182 &= -9;
				}
				break;
			case 5:
				if(v182) {
					bs182 |= 4;
				} else {
					bs182 &= -5;
				}
				break;
			case 6:
				if(v182) {
					bs182 |= 2;
				} else {
					bs182 &= -3;
				}
				break;
			case 7:
				if(v182) {
					bs182 |= 1;
				} else {
					bs182 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs182;
		var this184 = 0;
		var bs183 = this184;
		var l183 = "  ** ".length;
		var _g1183 = 0;
		var _g283 = l183;
		while(_g1183 < _g283) {
			var i183 = _g1183++;
			var no183 = "  ** ".charCodeAt(i183);
			if(no183 == null) {
				break;
			}
			var v183;
			switch(no183) {
			case 32:
				v183 = false;
				break;
			case 42:
				v183 = true;
				break;
			case 48:
				v183 = false;
				break;
			case 49:
				v183 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i183)));
			}
			switch(i183 - (l183 - 8)) {
			case 0:
				if(v183) {
					bs183 |= 128;
				} else {
					bs183 &= -129;
				}
				break;
			case 1:
				if(v183) {
					bs183 |= 64;
				} else {
					bs183 &= -65;
				}
				break;
			case 2:
				if(v183) {
					bs183 |= 32;
				} else {
					bs183 &= -33;
				}
				break;
			case 3:
				if(v183) {
					bs183 |= 16;
				} else {
					bs183 &= -17;
				}
				break;
			case 4:
				if(v183) {
					bs183 |= 8;
				} else {
					bs183 &= -9;
				}
				break;
			case 5:
				if(v183) {
					bs183 |= 4;
				} else {
					bs183 &= -5;
				}
				break;
			case 6:
				if(v183) {
					bs183 |= 2;
				} else {
					bs183 &= -3;
				}
				break;
			case 7:
				if(v183) {
					bs183 |= 1;
				} else {
					bs183 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs183;
		var this185 = 0;
		var bs184 = this185;
		var l184 = "  ** ".length;
		var _g1184 = 0;
		var _g284 = l184;
		while(_g1184 < _g284) {
			var i184 = _g1184++;
			var no184 = "  ** ".charCodeAt(i184);
			if(no184 == null) {
				break;
			}
			var v184;
			switch(no184) {
			case 32:
				v184 = false;
				break;
			case 42:
				v184 = true;
				break;
			case 48:
				v184 = false;
				break;
			case 49:
				v184 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i184)));
			}
			switch(i184 - (l184 - 8)) {
			case 0:
				if(v184) {
					bs184 |= 128;
				} else {
					bs184 &= -129;
				}
				break;
			case 1:
				if(v184) {
					bs184 |= 64;
				} else {
					bs184 &= -65;
				}
				break;
			case 2:
				if(v184) {
					bs184 |= 32;
				} else {
					bs184 &= -33;
				}
				break;
			case 3:
				if(v184) {
					bs184 |= 16;
				} else {
					bs184 &= -17;
				}
				break;
			case 4:
				if(v184) {
					bs184 |= 8;
				} else {
					bs184 &= -9;
				}
				break;
			case 5:
				if(v184) {
					bs184 |= 4;
				} else {
					bs184 &= -5;
				}
				break;
			case 6:
				if(v184) {
					bs184 |= 2;
				} else {
					bs184 &= -3;
				}
				break;
			case 7:
				if(v184) {
					bs184 |= 1;
				} else {
					bs184 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs184;
		var this186 = 0;
		var bs185 = this186;
		var l185 = "     ".length;
		var _g1185 = 0;
		var _g285 = l185;
		while(_g1185 < _g285) {
			var i185 = _g1185++;
			var no185 = "     ".charCodeAt(i185);
			if(no185 == null) {
				break;
			}
			var v185;
			switch(no185) {
			case 32:
				v185 = false;
				break;
			case 42:
				v185 = true;
				break;
			case 48:
				v185 = false;
				break;
			case 49:
				v185 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i185)));
			}
			switch(i185 - (l185 - 8)) {
			case 0:
				if(v185) {
					bs185 |= 128;
				} else {
					bs185 &= -129;
				}
				break;
			case 1:
				if(v185) {
					bs185 |= 64;
				} else {
					bs185 &= -65;
				}
				break;
			case 2:
				if(v185) {
					bs185 |= 32;
				} else {
					bs185 &= -33;
				}
				break;
			case 3:
				if(v185) {
					bs185 |= 16;
				} else {
					bs185 &= -17;
				}
				break;
			case 4:
				if(v185) {
					bs185 |= 8;
				} else {
					bs185 &= -9;
				}
				break;
			case 5:
				if(v185) {
					bs185 |= 4;
				} else {
					bs185 &= -5;
				}
				break;
			case 6:
				if(v185) {
					bs185 |= 2;
				} else {
					bs185 &= -3;
				}
				break;
			case 7:
				if(v185) {
					bs185 |= 1;
				} else {
					bs185 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs185;
		var this187 = 0;
		var bs186 = this187;
		var l186 = "  ** ".length;
		var _g1186 = 0;
		var _g286 = l186;
		while(_g1186 < _g286) {
			var i186 = _g1186++;
			var no186 = "  ** ".charCodeAt(i186);
			if(no186 == null) {
				break;
			}
			var v186;
			switch(no186) {
			case 32:
				v186 = false;
				break;
			case 42:
				v186 = true;
				break;
			case 48:
				v186 = false;
				break;
			case 49:
				v186 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i186)));
			}
			switch(i186 - (l186 - 8)) {
			case 0:
				if(v186) {
					bs186 |= 128;
				} else {
					bs186 &= -129;
				}
				break;
			case 1:
				if(v186) {
					bs186 |= 64;
				} else {
					bs186 &= -65;
				}
				break;
			case 2:
				if(v186) {
					bs186 |= 32;
				} else {
					bs186 &= -33;
				}
				break;
			case 3:
				if(v186) {
					bs186 |= 16;
				} else {
					bs186 &= -17;
				}
				break;
			case 4:
				if(v186) {
					bs186 |= 8;
				} else {
					bs186 &= -9;
				}
				break;
			case 5:
				if(v186) {
					bs186 |= 4;
				} else {
					bs186 &= -5;
				}
				break;
			case 6:
				if(v186) {
					bs186 |= 2;
				} else {
					bs186 &= -3;
				}
				break;
			case 7:
				if(v186) {
					bs186 |= 1;
				} else {
					bs186 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs186;
		var this188 = 0;
		var bs187 = this188;
		var l187 = "  ** ".length;
		var _g1187 = 0;
		var _g287 = l187;
		while(_g1187 < _g287) {
			var i187 = _g1187++;
			var no187 = "  ** ".charCodeAt(i187);
			if(no187 == null) {
				break;
			}
			var v187;
			switch(no187) {
			case 32:
				v187 = false;
				break;
			case 42:
				v187 = true;
				break;
			case 48:
				v187 = false;
				break;
			case 49:
				v187 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i187)));
			}
			switch(i187 - (l187 - 8)) {
			case 0:
				if(v187) {
					bs187 |= 128;
				} else {
					bs187 &= -129;
				}
				break;
			case 1:
				if(v187) {
					bs187 |= 64;
				} else {
					bs187 &= -65;
				}
				break;
			case 2:
				if(v187) {
					bs187 |= 32;
				} else {
					bs187 &= -33;
				}
				break;
			case 3:
				if(v187) {
					bs187 |= 16;
				} else {
					bs187 &= -17;
				}
				break;
			case 4:
				if(v187) {
					bs187 |= 8;
				} else {
					bs187 &= -9;
				}
				break;
			case 5:
				if(v187) {
					bs187 |= 4;
				} else {
					bs187 &= -5;
				}
				break;
			case 6:
				if(v187) {
					bs187 |= 2;
				} else {
					bs187 &= -3;
				}
				break;
			case 7:
				if(v187) {
					bs187 |= 1;
				} else {
					bs187 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs187;
		var this189 = 0;
		var bs188 = this189;
		var l188 = "     ".length;
		var _g1188 = 0;
		var _g288 = l188;
		while(_g1188 < _g288) {
			var i188 = _g1188++;
			var no188 = "     ".charCodeAt(i188);
			if(no188 == null) {
				break;
			}
			var v188;
			switch(no188) {
			case 32:
				v188 = false;
				break;
			case 42:
				v188 = true;
				break;
			case 48:
				v188 = false;
				break;
			case 49:
				v188 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i188)));
			}
			switch(i188 - (l188 - 8)) {
			case 0:
				if(v188) {
					bs188 |= 128;
				} else {
					bs188 &= -129;
				}
				break;
			case 1:
				if(v188) {
					bs188 |= 64;
				} else {
					bs188 &= -65;
				}
				break;
			case 2:
				if(v188) {
					bs188 |= 32;
				} else {
					bs188 &= -33;
				}
				break;
			case 3:
				if(v188) {
					bs188 |= 16;
				} else {
					bs188 &= -17;
				}
				break;
			case 4:
				if(v188) {
					bs188 |= 8;
				} else {
					bs188 &= -9;
				}
				break;
			case 5:
				if(v188) {
					bs188 |= 4;
				} else {
					bs188 &= -5;
				}
				break;
			case 6:
				if(v188) {
					bs188 |= 2;
				} else {
					bs188 &= -3;
				}
				break;
			case 7:
				if(v188) {
					bs188 |= 1;
				} else {
					bs188 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs188;
		break;
	case 59:
		var this190 = 0;
		var bs189 = this190;
		var l189 = "     ".length;
		var _g1189 = 0;
		var _g289 = l189;
		while(_g1189 < _g289) {
			var i189 = _g1189++;
			var no189 = "     ".charCodeAt(i189);
			if(no189 == null) {
				break;
			}
			var v189;
			switch(no189) {
			case 32:
				v189 = false;
				break;
			case 42:
				v189 = true;
				break;
			case 48:
				v189 = false;
				break;
			case 49:
				v189 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i189)));
			}
			switch(i189 - (l189 - 8)) {
			case 0:
				if(v189) {
					bs189 |= 128;
				} else {
					bs189 &= -129;
				}
				break;
			case 1:
				if(v189) {
					bs189 |= 64;
				} else {
					bs189 &= -65;
				}
				break;
			case 2:
				if(v189) {
					bs189 |= 32;
				} else {
					bs189 &= -33;
				}
				break;
			case 3:
				if(v189) {
					bs189 |= 16;
				} else {
					bs189 &= -17;
				}
				break;
			case 4:
				if(v189) {
					bs189 |= 8;
				} else {
					bs189 &= -9;
				}
				break;
			case 5:
				if(v189) {
					bs189 |= 4;
				} else {
					bs189 &= -5;
				}
				break;
			case 6:
				if(v189) {
					bs189 |= 2;
				} else {
					bs189 &= -3;
				}
				break;
			case 7:
				if(v189) {
					bs189 |= 1;
				} else {
					bs189 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs189;
		var this191 = 0;
		var bs190 = this191;
		var l190 = "  ** ".length;
		var _g1190 = 0;
		var _g290 = l190;
		while(_g1190 < _g290) {
			var i190 = _g1190++;
			var no190 = "  ** ".charCodeAt(i190);
			if(no190 == null) {
				break;
			}
			var v190;
			switch(no190) {
			case 32:
				v190 = false;
				break;
			case 42:
				v190 = true;
				break;
			case 48:
				v190 = false;
				break;
			case 49:
				v190 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i190)));
			}
			switch(i190 - (l190 - 8)) {
			case 0:
				if(v190) {
					bs190 |= 128;
				} else {
					bs190 &= -129;
				}
				break;
			case 1:
				if(v190) {
					bs190 |= 64;
				} else {
					bs190 &= -65;
				}
				break;
			case 2:
				if(v190) {
					bs190 |= 32;
				} else {
					bs190 &= -33;
				}
				break;
			case 3:
				if(v190) {
					bs190 |= 16;
				} else {
					bs190 &= -17;
				}
				break;
			case 4:
				if(v190) {
					bs190 |= 8;
				} else {
					bs190 &= -9;
				}
				break;
			case 5:
				if(v190) {
					bs190 |= 4;
				} else {
					bs190 &= -5;
				}
				break;
			case 6:
				if(v190) {
					bs190 |= 2;
				} else {
					bs190 &= -3;
				}
				break;
			case 7:
				if(v190) {
					bs190 |= 1;
				} else {
					bs190 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs190;
		var this192 = 0;
		var bs191 = this192;
		var l191 = "  ** ".length;
		var _g1191 = 0;
		var _g291 = l191;
		while(_g1191 < _g291) {
			var i191 = _g1191++;
			var no191 = "  ** ".charCodeAt(i191);
			if(no191 == null) {
				break;
			}
			var v191;
			switch(no191) {
			case 32:
				v191 = false;
				break;
			case 42:
				v191 = true;
				break;
			case 48:
				v191 = false;
				break;
			case 49:
				v191 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i191)));
			}
			switch(i191 - (l191 - 8)) {
			case 0:
				if(v191) {
					bs191 |= 128;
				} else {
					bs191 &= -129;
				}
				break;
			case 1:
				if(v191) {
					bs191 |= 64;
				} else {
					bs191 &= -65;
				}
				break;
			case 2:
				if(v191) {
					bs191 |= 32;
				} else {
					bs191 &= -33;
				}
				break;
			case 3:
				if(v191) {
					bs191 |= 16;
				} else {
					bs191 &= -17;
				}
				break;
			case 4:
				if(v191) {
					bs191 |= 8;
				} else {
					bs191 &= -9;
				}
				break;
			case 5:
				if(v191) {
					bs191 |= 4;
				} else {
					bs191 &= -5;
				}
				break;
			case 6:
				if(v191) {
					bs191 |= 2;
				} else {
					bs191 &= -3;
				}
				break;
			case 7:
				if(v191) {
					bs191 |= 1;
				} else {
					bs191 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs191;
		var this193 = 0;
		var bs192 = this193;
		var l192 = "     ".length;
		var _g1192 = 0;
		var _g292 = l192;
		while(_g1192 < _g292) {
			var i192 = _g1192++;
			var no192 = "     ".charCodeAt(i192);
			if(no192 == null) {
				break;
			}
			var v192;
			switch(no192) {
			case 32:
				v192 = false;
				break;
			case 42:
				v192 = true;
				break;
			case 48:
				v192 = false;
				break;
			case 49:
				v192 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i192)));
			}
			switch(i192 - (l192 - 8)) {
			case 0:
				if(v192) {
					bs192 |= 128;
				} else {
					bs192 &= -129;
				}
				break;
			case 1:
				if(v192) {
					bs192 |= 64;
				} else {
					bs192 &= -65;
				}
				break;
			case 2:
				if(v192) {
					bs192 |= 32;
				} else {
					bs192 &= -33;
				}
				break;
			case 3:
				if(v192) {
					bs192 |= 16;
				} else {
					bs192 &= -17;
				}
				break;
			case 4:
				if(v192) {
					bs192 |= 8;
				} else {
					bs192 &= -9;
				}
				break;
			case 5:
				if(v192) {
					bs192 |= 4;
				} else {
					bs192 &= -5;
				}
				break;
			case 6:
				if(v192) {
					bs192 |= 2;
				} else {
					bs192 &= -3;
				}
				break;
			case 7:
				if(v192) {
					bs192 |= 1;
				} else {
					bs192 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs192;
		var this194 = 0;
		var bs193 = this194;
		var l193 = "  ** ".length;
		var _g1193 = 0;
		var _g293 = l193;
		while(_g1193 < _g293) {
			var i193 = _g1193++;
			var no193 = "  ** ".charCodeAt(i193);
			if(no193 == null) {
				break;
			}
			var v193;
			switch(no193) {
			case 32:
				v193 = false;
				break;
			case 42:
				v193 = true;
				break;
			case 48:
				v193 = false;
				break;
			case 49:
				v193 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i193)));
			}
			switch(i193 - (l193 - 8)) {
			case 0:
				if(v193) {
					bs193 |= 128;
				} else {
					bs193 &= -129;
				}
				break;
			case 1:
				if(v193) {
					bs193 |= 64;
				} else {
					bs193 &= -65;
				}
				break;
			case 2:
				if(v193) {
					bs193 |= 32;
				} else {
					bs193 &= -33;
				}
				break;
			case 3:
				if(v193) {
					bs193 |= 16;
				} else {
					bs193 &= -17;
				}
				break;
			case 4:
				if(v193) {
					bs193 |= 8;
				} else {
					bs193 &= -9;
				}
				break;
			case 5:
				if(v193) {
					bs193 |= 4;
				} else {
					bs193 &= -5;
				}
				break;
			case 6:
				if(v193) {
					bs193 |= 2;
				} else {
					bs193 &= -3;
				}
				break;
			case 7:
				if(v193) {
					bs193 |= 1;
				} else {
					bs193 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs193;
		var this195 = 0;
		var bs194 = this195;
		var l194 = "   * ".length;
		var _g1194 = 0;
		var _g294 = l194;
		while(_g1194 < _g294) {
			var i194 = _g1194++;
			var no194 = "   * ".charCodeAt(i194);
			if(no194 == null) {
				break;
			}
			var v194;
			switch(no194) {
			case 32:
				v194 = false;
				break;
			case 42:
				v194 = true;
				break;
			case 48:
				v194 = false;
				break;
			case 49:
				v194 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i194)));
			}
			switch(i194 - (l194 - 8)) {
			case 0:
				if(v194) {
					bs194 |= 128;
				} else {
					bs194 &= -129;
				}
				break;
			case 1:
				if(v194) {
					bs194 |= 64;
				} else {
					bs194 &= -65;
				}
				break;
			case 2:
				if(v194) {
					bs194 |= 32;
				} else {
					bs194 &= -33;
				}
				break;
			case 3:
				if(v194) {
					bs194 |= 16;
				} else {
					bs194 &= -17;
				}
				break;
			case 4:
				if(v194) {
					bs194 |= 8;
				} else {
					bs194 &= -9;
				}
				break;
			case 5:
				if(v194) {
					bs194 |= 4;
				} else {
					bs194 &= -5;
				}
				break;
			case 6:
				if(v194) {
					bs194 |= 2;
				} else {
					bs194 &= -3;
				}
				break;
			case 7:
				if(v194) {
					bs194 |= 1;
				} else {
					bs194 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs194;
		var this196 = 0;
		var bs195 = this196;
		var l195 = "  *  ".length;
		var _g1195 = 0;
		var _g295 = l195;
		while(_g1195 < _g295) {
			var i195 = _g1195++;
			var no195 = "  *  ".charCodeAt(i195);
			if(no195 == null) {
				break;
			}
			var v195;
			switch(no195) {
			case 32:
				v195 = false;
				break;
			case 42:
				v195 = true;
				break;
			case 48:
				v195 = false;
				break;
			case 49:
				v195 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i195)));
			}
			switch(i195 - (l195 - 8)) {
			case 0:
				if(v195) {
					bs195 |= 128;
				} else {
					bs195 &= -129;
				}
				break;
			case 1:
				if(v195) {
					bs195 |= 64;
				} else {
					bs195 &= -65;
				}
				break;
			case 2:
				if(v195) {
					bs195 |= 32;
				} else {
					bs195 &= -33;
				}
				break;
			case 3:
				if(v195) {
					bs195 |= 16;
				} else {
					bs195 &= -17;
				}
				break;
			case 4:
				if(v195) {
					bs195 |= 8;
				} else {
					bs195 &= -9;
				}
				break;
			case 5:
				if(v195) {
					bs195 |= 4;
				} else {
					bs195 &= -5;
				}
				break;
			case 6:
				if(v195) {
					bs195 |= 2;
				} else {
					bs195 &= -3;
				}
				break;
			case 7:
				if(v195) {
					bs195 |= 1;
				} else {
					bs195 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs195;
		break;
	case 60:
		var this197 = 0;
		var bs196 = this197;
		var l196 = "   * ".length;
		var _g1196 = 0;
		var _g296 = l196;
		while(_g1196 < _g296) {
			var i196 = _g1196++;
			var no196 = "   * ".charCodeAt(i196);
			if(no196 == null) {
				break;
			}
			var v196;
			switch(no196) {
			case 32:
				v196 = false;
				break;
			case 42:
				v196 = true;
				break;
			case 48:
				v196 = false;
				break;
			case 49:
				v196 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i196)));
			}
			switch(i196 - (l196 - 8)) {
			case 0:
				if(v196) {
					bs196 |= 128;
				} else {
					bs196 &= -129;
				}
				break;
			case 1:
				if(v196) {
					bs196 |= 64;
				} else {
					bs196 &= -65;
				}
				break;
			case 2:
				if(v196) {
					bs196 |= 32;
				} else {
					bs196 &= -33;
				}
				break;
			case 3:
				if(v196) {
					bs196 |= 16;
				} else {
					bs196 &= -17;
				}
				break;
			case 4:
				if(v196) {
					bs196 |= 8;
				} else {
					bs196 &= -9;
				}
				break;
			case 5:
				if(v196) {
					bs196 |= 4;
				} else {
					bs196 &= -5;
				}
				break;
			case 6:
				if(v196) {
					bs196 |= 2;
				} else {
					bs196 &= -3;
				}
				break;
			case 7:
				if(v196) {
					bs196 |= 1;
				} else {
					bs196 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs196;
		var this198 = 0;
		var bs197 = this198;
		var l197 = "  *  ".length;
		var _g1197 = 0;
		var _g297 = l197;
		while(_g1197 < _g297) {
			var i197 = _g1197++;
			var no197 = "  *  ".charCodeAt(i197);
			if(no197 == null) {
				break;
			}
			var v197;
			switch(no197) {
			case 32:
				v197 = false;
				break;
			case 42:
				v197 = true;
				break;
			case 48:
				v197 = false;
				break;
			case 49:
				v197 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i197)));
			}
			switch(i197 - (l197 - 8)) {
			case 0:
				if(v197) {
					bs197 |= 128;
				} else {
					bs197 &= -129;
				}
				break;
			case 1:
				if(v197) {
					bs197 |= 64;
				} else {
					bs197 &= -65;
				}
				break;
			case 2:
				if(v197) {
					bs197 |= 32;
				} else {
					bs197 &= -33;
				}
				break;
			case 3:
				if(v197) {
					bs197 |= 16;
				} else {
					bs197 &= -17;
				}
				break;
			case 4:
				if(v197) {
					bs197 |= 8;
				} else {
					bs197 &= -9;
				}
				break;
			case 5:
				if(v197) {
					bs197 |= 4;
				} else {
					bs197 &= -5;
				}
				break;
			case 6:
				if(v197) {
					bs197 |= 2;
				} else {
					bs197 &= -3;
				}
				break;
			case 7:
				if(v197) {
					bs197 |= 1;
				} else {
					bs197 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs197;
		var this199 = 0;
		var bs198 = this199;
		var l198 = " *   ".length;
		var _g1198 = 0;
		var _g298 = l198;
		while(_g1198 < _g298) {
			var i198 = _g1198++;
			var no198 = " *   ".charCodeAt(i198);
			if(no198 == null) {
				break;
			}
			var v198;
			switch(no198) {
			case 32:
				v198 = false;
				break;
			case 42:
				v198 = true;
				break;
			case 48:
				v198 = false;
				break;
			case 49:
				v198 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i198)));
			}
			switch(i198 - (l198 - 8)) {
			case 0:
				if(v198) {
					bs198 |= 128;
				} else {
					bs198 &= -129;
				}
				break;
			case 1:
				if(v198) {
					bs198 |= 64;
				} else {
					bs198 &= -65;
				}
				break;
			case 2:
				if(v198) {
					bs198 |= 32;
				} else {
					bs198 &= -33;
				}
				break;
			case 3:
				if(v198) {
					bs198 |= 16;
				} else {
					bs198 &= -17;
				}
				break;
			case 4:
				if(v198) {
					bs198 |= 8;
				} else {
					bs198 &= -9;
				}
				break;
			case 5:
				if(v198) {
					bs198 |= 4;
				} else {
					bs198 &= -5;
				}
				break;
			case 6:
				if(v198) {
					bs198 |= 2;
				} else {
					bs198 &= -3;
				}
				break;
			case 7:
				if(v198) {
					bs198 |= 1;
				} else {
					bs198 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs198;
		var this200 = 0;
		var bs199 = this200;
		var l199 = "*    ".length;
		var _g1199 = 0;
		var _g299 = l199;
		while(_g1199 < _g299) {
			var i199 = _g1199++;
			var no199 = "*    ".charCodeAt(i199);
			if(no199 == null) {
				break;
			}
			var v199;
			switch(no199) {
			case 32:
				v199 = false;
				break;
			case 42:
				v199 = true;
				break;
			case 48:
				v199 = false;
				break;
			case 49:
				v199 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i199)));
			}
			switch(i199 - (l199 - 8)) {
			case 0:
				if(v199) {
					bs199 |= 128;
				} else {
					bs199 &= -129;
				}
				break;
			case 1:
				if(v199) {
					bs199 |= 64;
				} else {
					bs199 &= -65;
				}
				break;
			case 2:
				if(v199) {
					bs199 |= 32;
				} else {
					bs199 &= -33;
				}
				break;
			case 3:
				if(v199) {
					bs199 |= 16;
				} else {
					bs199 &= -17;
				}
				break;
			case 4:
				if(v199) {
					bs199 |= 8;
				} else {
					bs199 &= -9;
				}
				break;
			case 5:
				if(v199) {
					bs199 |= 4;
				} else {
					bs199 &= -5;
				}
				break;
			case 6:
				if(v199) {
					bs199 |= 2;
				} else {
					bs199 &= -3;
				}
				break;
			case 7:
				if(v199) {
					bs199 |= 1;
				} else {
					bs199 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs199;
		var this201 = 0;
		var bs200 = this201;
		var l200 = " *   ".length;
		var _g1200 = 0;
		var _g300 = l200;
		while(_g1200 < _g300) {
			var i200 = _g1200++;
			var no200 = " *   ".charCodeAt(i200);
			if(no200 == null) {
				break;
			}
			var v200;
			switch(no200) {
			case 32:
				v200 = false;
				break;
			case 42:
				v200 = true;
				break;
			case 48:
				v200 = false;
				break;
			case 49:
				v200 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i200)));
			}
			switch(i200 - (l200 - 8)) {
			case 0:
				if(v200) {
					bs200 |= 128;
				} else {
					bs200 &= -129;
				}
				break;
			case 1:
				if(v200) {
					bs200 |= 64;
				} else {
					bs200 &= -65;
				}
				break;
			case 2:
				if(v200) {
					bs200 |= 32;
				} else {
					bs200 &= -33;
				}
				break;
			case 3:
				if(v200) {
					bs200 |= 16;
				} else {
					bs200 &= -17;
				}
				break;
			case 4:
				if(v200) {
					bs200 |= 8;
				} else {
					bs200 &= -9;
				}
				break;
			case 5:
				if(v200) {
					bs200 |= 4;
				} else {
					bs200 &= -5;
				}
				break;
			case 6:
				if(v200) {
					bs200 |= 2;
				} else {
					bs200 &= -3;
				}
				break;
			case 7:
				if(v200) {
					bs200 |= 1;
				} else {
					bs200 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs200;
		var this202 = 0;
		var bs201 = this202;
		var l201 = "  *  ".length;
		var _g1201 = 0;
		var _g301 = l201;
		while(_g1201 < _g301) {
			var i201 = _g1201++;
			var no201 = "  *  ".charCodeAt(i201);
			if(no201 == null) {
				break;
			}
			var v201;
			switch(no201) {
			case 32:
				v201 = false;
				break;
			case 42:
				v201 = true;
				break;
			case 48:
				v201 = false;
				break;
			case 49:
				v201 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i201)));
			}
			switch(i201 - (l201 - 8)) {
			case 0:
				if(v201) {
					bs201 |= 128;
				} else {
					bs201 &= -129;
				}
				break;
			case 1:
				if(v201) {
					bs201 |= 64;
				} else {
					bs201 &= -65;
				}
				break;
			case 2:
				if(v201) {
					bs201 |= 32;
				} else {
					bs201 &= -33;
				}
				break;
			case 3:
				if(v201) {
					bs201 |= 16;
				} else {
					bs201 &= -17;
				}
				break;
			case 4:
				if(v201) {
					bs201 |= 8;
				} else {
					bs201 &= -9;
				}
				break;
			case 5:
				if(v201) {
					bs201 |= 4;
				} else {
					bs201 &= -5;
				}
				break;
			case 6:
				if(v201) {
					bs201 |= 2;
				} else {
					bs201 &= -3;
				}
				break;
			case 7:
				if(v201) {
					bs201 |= 1;
				} else {
					bs201 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs201;
		var this203 = 0;
		var bs202 = this203;
		var l202 = "   * ".length;
		var _g1202 = 0;
		var _g302 = l202;
		while(_g1202 < _g302) {
			var i202 = _g1202++;
			var no202 = "   * ".charCodeAt(i202);
			if(no202 == null) {
				break;
			}
			var v202;
			switch(no202) {
			case 32:
				v202 = false;
				break;
			case 42:
				v202 = true;
				break;
			case 48:
				v202 = false;
				break;
			case 49:
				v202 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i202)));
			}
			switch(i202 - (l202 - 8)) {
			case 0:
				if(v202) {
					bs202 |= 128;
				} else {
					bs202 &= -129;
				}
				break;
			case 1:
				if(v202) {
					bs202 |= 64;
				} else {
					bs202 &= -65;
				}
				break;
			case 2:
				if(v202) {
					bs202 |= 32;
				} else {
					bs202 &= -33;
				}
				break;
			case 3:
				if(v202) {
					bs202 |= 16;
				} else {
					bs202 &= -17;
				}
				break;
			case 4:
				if(v202) {
					bs202 |= 8;
				} else {
					bs202 &= -9;
				}
				break;
			case 5:
				if(v202) {
					bs202 |= 4;
				} else {
					bs202 &= -5;
				}
				break;
			case 6:
				if(v202) {
					bs202 |= 2;
				} else {
					bs202 &= -3;
				}
				break;
			case 7:
				if(v202) {
					bs202 |= 1;
				} else {
					bs202 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs202;
		break;
	case 61:
		var this204 = 0;
		var bs203 = this204;
		var l203 = "     ".length;
		var _g1203 = 0;
		var _g303 = l203;
		while(_g1203 < _g303) {
			var i203 = _g1203++;
			var no203 = "     ".charCodeAt(i203);
			if(no203 == null) {
				break;
			}
			var v203;
			switch(no203) {
			case 32:
				v203 = false;
				break;
			case 42:
				v203 = true;
				break;
			case 48:
				v203 = false;
				break;
			case 49:
				v203 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i203)));
			}
			switch(i203 - (l203 - 8)) {
			case 0:
				if(v203) {
					bs203 |= 128;
				} else {
					bs203 &= -129;
				}
				break;
			case 1:
				if(v203) {
					bs203 |= 64;
				} else {
					bs203 &= -65;
				}
				break;
			case 2:
				if(v203) {
					bs203 |= 32;
				} else {
					bs203 &= -33;
				}
				break;
			case 3:
				if(v203) {
					bs203 |= 16;
				} else {
					bs203 &= -17;
				}
				break;
			case 4:
				if(v203) {
					bs203 |= 8;
				} else {
					bs203 &= -9;
				}
				break;
			case 5:
				if(v203) {
					bs203 |= 4;
				} else {
					bs203 &= -5;
				}
				break;
			case 6:
				if(v203) {
					bs203 |= 2;
				} else {
					bs203 &= -3;
				}
				break;
			case 7:
				if(v203) {
					bs203 |= 1;
				} else {
					bs203 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs203;
		var this205 = 0;
		var bs204 = this205;
		var l204 = "     ".length;
		var _g1204 = 0;
		var _g304 = l204;
		while(_g1204 < _g304) {
			var i204 = _g1204++;
			var no204 = "     ".charCodeAt(i204);
			if(no204 == null) {
				break;
			}
			var v204;
			switch(no204) {
			case 32:
				v204 = false;
				break;
			case 42:
				v204 = true;
				break;
			case 48:
				v204 = false;
				break;
			case 49:
				v204 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i204)));
			}
			switch(i204 - (l204 - 8)) {
			case 0:
				if(v204) {
					bs204 |= 128;
				} else {
					bs204 &= -129;
				}
				break;
			case 1:
				if(v204) {
					bs204 |= 64;
				} else {
					bs204 &= -65;
				}
				break;
			case 2:
				if(v204) {
					bs204 |= 32;
				} else {
					bs204 &= -33;
				}
				break;
			case 3:
				if(v204) {
					bs204 |= 16;
				} else {
					bs204 &= -17;
				}
				break;
			case 4:
				if(v204) {
					bs204 |= 8;
				} else {
					bs204 &= -9;
				}
				break;
			case 5:
				if(v204) {
					bs204 |= 4;
				} else {
					bs204 &= -5;
				}
				break;
			case 6:
				if(v204) {
					bs204 |= 2;
				} else {
					bs204 &= -3;
				}
				break;
			case 7:
				if(v204) {
					bs204 |= 1;
				} else {
					bs204 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs204;
		var this206 = 0;
		var bs205 = this206;
		var l205 = "*****".length;
		var _g1205 = 0;
		var _g305 = l205;
		while(_g1205 < _g305) {
			var i205 = _g1205++;
			var no205 = "*****".charCodeAt(i205);
			if(no205 == null) {
				break;
			}
			var v205;
			switch(no205) {
			case 32:
				v205 = false;
				break;
			case 42:
				v205 = true;
				break;
			case 48:
				v205 = false;
				break;
			case 49:
				v205 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i205)));
			}
			switch(i205 - (l205 - 8)) {
			case 0:
				if(v205) {
					bs205 |= 128;
				} else {
					bs205 &= -129;
				}
				break;
			case 1:
				if(v205) {
					bs205 |= 64;
				} else {
					bs205 &= -65;
				}
				break;
			case 2:
				if(v205) {
					bs205 |= 32;
				} else {
					bs205 &= -33;
				}
				break;
			case 3:
				if(v205) {
					bs205 |= 16;
				} else {
					bs205 &= -17;
				}
				break;
			case 4:
				if(v205) {
					bs205 |= 8;
				} else {
					bs205 &= -9;
				}
				break;
			case 5:
				if(v205) {
					bs205 |= 4;
				} else {
					bs205 &= -5;
				}
				break;
			case 6:
				if(v205) {
					bs205 |= 2;
				} else {
					bs205 &= -3;
				}
				break;
			case 7:
				if(v205) {
					bs205 |= 1;
				} else {
					bs205 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs205;
		var this207 = 0;
		var bs206 = this207;
		var l206 = "     ".length;
		var _g1206 = 0;
		var _g306 = l206;
		while(_g1206 < _g306) {
			var i206 = _g1206++;
			var no206 = "     ".charCodeAt(i206);
			if(no206 == null) {
				break;
			}
			var v206;
			switch(no206) {
			case 32:
				v206 = false;
				break;
			case 42:
				v206 = true;
				break;
			case 48:
				v206 = false;
				break;
			case 49:
				v206 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i206)));
			}
			switch(i206 - (l206 - 8)) {
			case 0:
				if(v206) {
					bs206 |= 128;
				} else {
					bs206 &= -129;
				}
				break;
			case 1:
				if(v206) {
					bs206 |= 64;
				} else {
					bs206 &= -65;
				}
				break;
			case 2:
				if(v206) {
					bs206 |= 32;
				} else {
					bs206 &= -33;
				}
				break;
			case 3:
				if(v206) {
					bs206 |= 16;
				} else {
					bs206 &= -17;
				}
				break;
			case 4:
				if(v206) {
					bs206 |= 8;
				} else {
					bs206 &= -9;
				}
				break;
			case 5:
				if(v206) {
					bs206 |= 4;
				} else {
					bs206 &= -5;
				}
				break;
			case 6:
				if(v206) {
					bs206 |= 2;
				} else {
					bs206 &= -3;
				}
				break;
			case 7:
				if(v206) {
					bs206 |= 1;
				} else {
					bs206 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs206;
		var this208 = 0;
		var bs207 = this208;
		var l207 = "*****".length;
		var _g1207 = 0;
		var _g307 = l207;
		while(_g1207 < _g307) {
			var i207 = _g1207++;
			var no207 = "*****".charCodeAt(i207);
			if(no207 == null) {
				break;
			}
			var v207;
			switch(no207) {
			case 32:
				v207 = false;
				break;
			case 42:
				v207 = true;
				break;
			case 48:
				v207 = false;
				break;
			case 49:
				v207 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i207)));
			}
			switch(i207 - (l207 - 8)) {
			case 0:
				if(v207) {
					bs207 |= 128;
				} else {
					bs207 &= -129;
				}
				break;
			case 1:
				if(v207) {
					bs207 |= 64;
				} else {
					bs207 &= -65;
				}
				break;
			case 2:
				if(v207) {
					bs207 |= 32;
				} else {
					bs207 &= -33;
				}
				break;
			case 3:
				if(v207) {
					bs207 |= 16;
				} else {
					bs207 &= -17;
				}
				break;
			case 4:
				if(v207) {
					bs207 |= 8;
				} else {
					bs207 &= -9;
				}
				break;
			case 5:
				if(v207) {
					bs207 |= 4;
				} else {
					bs207 &= -5;
				}
				break;
			case 6:
				if(v207) {
					bs207 |= 2;
				} else {
					bs207 &= -3;
				}
				break;
			case 7:
				if(v207) {
					bs207 |= 1;
				} else {
					bs207 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs207;
		var this209 = 0;
		var bs208 = this209;
		var l208 = "     ".length;
		var _g1208 = 0;
		var _g308 = l208;
		while(_g1208 < _g308) {
			var i208 = _g1208++;
			var no208 = "     ".charCodeAt(i208);
			if(no208 == null) {
				break;
			}
			var v208;
			switch(no208) {
			case 32:
				v208 = false;
				break;
			case 42:
				v208 = true;
				break;
			case 48:
				v208 = false;
				break;
			case 49:
				v208 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i208)));
			}
			switch(i208 - (l208 - 8)) {
			case 0:
				if(v208) {
					bs208 |= 128;
				} else {
					bs208 &= -129;
				}
				break;
			case 1:
				if(v208) {
					bs208 |= 64;
				} else {
					bs208 &= -65;
				}
				break;
			case 2:
				if(v208) {
					bs208 |= 32;
				} else {
					bs208 &= -33;
				}
				break;
			case 3:
				if(v208) {
					bs208 |= 16;
				} else {
					bs208 &= -17;
				}
				break;
			case 4:
				if(v208) {
					bs208 |= 8;
				} else {
					bs208 &= -9;
				}
				break;
			case 5:
				if(v208) {
					bs208 |= 4;
				} else {
					bs208 &= -5;
				}
				break;
			case 6:
				if(v208) {
					bs208 |= 2;
				} else {
					bs208 &= -3;
				}
				break;
			case 7:
				if(v208) {
					bs208 |= 1;
				} else {
					bs208 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs208;
		var this210 = 0;
		var bs209 = this210;
		var l209 = "     ".length;
		var _g1209 = 0;
		var _g309 = l209;
		while(_g1209 < _g309) {
			var i209 = _g1209++;
			var no209 = "     ".charCodeAt(i209);
			if(no209 == null) {
				break;
			}
			var v209;
			switch(no209) {
			case 32:
				v209 = false;
				break;
			case 42:
				v209 = true;
				break;
			case 48:
				v209 = false;
				break;
			case 49:
				v209 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i209)));
			}
			switch(i209 - (l209 - 8)) {
			case 0:
				if(v209) {
					bs209 |= 128;
				} else {
					bs209 &= -129;
				}
				break;
			case 1:
				if(v209) {
					bs209 |= 64;
				} else {
					bs209 &= -65;
				}
				break;
			case 2:
				if(v209) {
					bs209 |= 32;
				} else {
					bs209 &= -33;
				}
				break;
			case 3:
				if(v209) {
					bs209 |= 16;
				} else {
					bs209 &= -17;
				}
				break;
			case 4:
				if(v209) {
					bs209 |= 8;
				} else {
					bs209 &= -9;
				}
				break;
			case 5:
				if(v209) {
					bs209 |= 4;
				} else {
					bs209 &= -5;
				}
				break;
			case 6:
				if(v209) {
					bs209 |= 2;
				} else {
					bs209 &= -3;
				}
				break;
			case 7:
				if(v209) {
					bs209 |= 1;
				} else {
					bs209 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs209;
		break;
	case 62:
		var this211 = 0;
		var bs210 = this211;
		var l210 = " *   ".length;
		var _g1210 = 0;
		var _g310 = l210;
		while(_g1210 < _g310) {
			var i210 = _g1210++;
			var no210 = " *   ".charCodeAt(i210);
			if(no210 == null) {
				break;
			}
			var v210;
			switch(no210) {
			case 32:
				v210 = false;
				break;
			case 42:
				v210 = true;
				break;
			case 48:
				v210 = false;
				break;
			case 49:
				v210 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i210)));
			}
			switch(i210 - (l210 - 8)) {
			case 0:
				if(v210) {
					bs210 |= 128;
				} else {
					bs210 &= -129;
				}
				break;
			case 1:
				if(v210) {
					bs210 |= 64;
				} else {
					bs210 &= -65;
				}
				break;
			case 2:
				if(v210) {
					bs210 |= 32;
				} else {
					bs210 &= -33;
				}
				break;
			case 3:
				if(v210) {
					bs210 |= 16;
				} else {
					bs210 &= -17;
				}
				break;
			case 4:
				if(v210) {
					bs210 |= 8;
				} else {
					bs210 &= -9;
				}
				break;
			case 5:
				if(v210) {
					bs210 |= 4;
				} else {
					bs210 &= -5;
				}
				break;
			case 6:
				if(v210) {
					bs210 |= 2;
				} else {
					bs210 &= -3;
				}
				break;
			case 7:
				if(v210) {
					bs210 |= 1;
				} else {
					bs210 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs210;
		var this212 = 0;
		var bs211 = this212;
		var l211 = "  *  ".length;
		var _g1211 = 0;
		var _g311 = l211;
		while(_g1211 < _g311) {
			var i211 = _g1211++;
			var no211 = "  *  ".charCodeAt(i211);
			if(no211 == null) {
				break;
			}
			var v211;
			switch(no211) {
			case 32:
				v211 = false;
				break;
			case 42:
				v211 = true;
				break;
			case 48:
				v211 = false;
				break;
			case 49:
				v211 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i211)));
			}
			switch(i211 - (l211 - 8)) {
			case 0:
				if(v211) {
					bs211 |= 128;
				} else {
					bs211 &= -129;
				}
				break;
			case 1:
				if(v211) {
					bs211 |= 64;
				} else {
					bs211 &= -65;
				}
				break;
			case 2:
				if(v211) {
					bs211 |= 32;
				} else {
					bs211 &= -33;
				}
				break;
			case 3:
				if(v211) {
					bs211 |= 16;
				} else {
					bs211 &= -17;
				}
				break;
			case 4:
				if(v211) {
					bs211 |= 8;
				} else {
					bs211 &= -9;
				}
				break;
			case 5:
				if(v211) {
					bs211 |= 4;
				} else {
					bs211 &= -5;
				}
				break;
			case 6:
				if(v211) {
					bs211 |= 2;
				} else {
					bs211 &= -3;
				}
				break;
			case 7:
				if(v211) {
					bs211 |= 1;
				} else {
					bs211 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs211;
		var this213 = 0;
		var bs212 = this213;
		var l212 = "   * ".length;
		var _g1212 = 0;
		var _g312 = l212;
		while(_g1212 < _g312) {
			var i212 = _g1212++;
			var no212 = "   * ".charCodeAt(i212);
			if(no212 == null) {
				break;
			}
			var v212;
			switch(no212) {
			case 32:
				v212 = false;
				break;
			case 42:
				v212 = true;
				break;
			case 48:
				v212 = false;
				break;
			case 49:
				v212 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i212)));
			}
			switch(i212 - (l212 - 8)) {
			case 0:
				if(v212) {
					bs212 |= 128;
				} else {
					bs212 &= -129;
				}
				break;
			case 1:
				if(v212) {
					bs212 |= 64;
				} else {
					bs212 &= -65;
				}
				break;
			case 2:
				if(v212) {
					bs212 |= 32;
				} else {
					bs212 &= -33;
				}
				break;
			case 3:
				if(v212) {
					bs212 |= 16;
				} else {
					bs212 &= -17;
				}
				break;
			case 4:
				if(v212) {
					bs212 |= 8;
				} else {
					bs212 &= -9;
				}
				break;
			case 5:
				if(v212) {
					bs212 |= 4;
				} else {
					bs212 &= -5;
				}
				break;
			case 6:
				if(v212) {
					bs212 |= 2;
				} else {
					bs212 &= -3;
				}
				break;
			case 7:
				if(v212) {
					bs212 |= 1;
				} else {
					bs212 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs212;
		var this214 = 0;
		var bs213 = this214;
		var l213 = "    *".length;
		var _g1213 = 0;
		var _g313 = l213;
		while(_g1213 < _g313) {
			var i213 = _g1213++;
			var no213 = "    *".charCodeAt(i213);
			if(no213 == null) {
				break;
			}
			var v213;
			switch(no213) {
			case 32:
				v213 = false;
				break;
			case 42:
				v213 = true;
				break;
			case 48:
				v213 = false;
				break;
			case 49:
				v213 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i213)));
			}
			switch(i213 - (l213 - 8)) {
			case 0:
				if(v213) {
					bs213 |= 128;
				} else {
					bs213 &= -129;
				}
				break;
			case 1:
				if(v213) {
					bs213 |= 64;
				} else {
					bs213 &= -65;
				}
				break;
			case 2:
				if(v213) {
					bs213 |= 32;
				} else {
					bs213 &= -33;
				}
				break;
			case 3:
				if(v213) {
					bs213 |= 16;
				} else {
					bs213 &= -17;
				}
				break;
			case 4:
				if(v213) {
					bs213 |= 8;
				} else {
					bs213 &= -9;
				}
				break;
			case 5:
				if(v213) {
					bs213 |= 4;
				} else {
					bs213 &= -5;
				}
				break;
			case 6:
				if(v213) {
					bs213 |= 2;
				} else {
					bs213 &= -3;
				}
				break;
			case 7:
				if(v213) {
					bs213 |= 1;
				} else {
					bs213 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs213;
		var this215 = 0;
		var bs214 = this215;
		var l214 = "   * ".length;
		var _g1214 = 0;
		var _g314 = l214;
		while(_g1214 < _g314) {
			var i214 = _g1214++;
			var no214 = "   * ".charCodeAt(i214);
			if(no214 == null) {
				break;
			}
			var v214;
			switch(no214) {
			case 32:
				v214 = false;
				break;
			case 42:
				v214 = true;
				break;
			case 48:
				v214 = false;
				break;
			case 49:
				v214 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i214)));
			}
			switch(i214 - (l214 - 8)) {
			case 0:
				if(v214) {
					bs214 |= 128;
				} else {
					bs214 &= -129;
				}
				break;
			case 1:
				if(v214) {
					bs214 |= 64;
				} else {
					bs214 &= -65;
				}
				break;
			case 2:
				if(v214) {
					bs214 |= 32;
				} else {
					bs214 &= -33;
				}
				break;
			case 3:
				if(v214) {
					bs214 |= 16;
				} else {
					bs214 &= -17;
				}
				break;
			case 4:
				if(v214) {
					bs214 |= 8;
				} else {
					bs214 &= -9;
				}
				break;
			case 5:
				if(v214) {
					bs214 |= 4;
				} else {
					bs214 &= -5;
				}
				break;
			case 6:
				if(v214) {
					bs214 |= 2;
				} else {
					bs214 &= -3;
				}
				break;
			case 7:
				if(v214) {
					bs214 |= 1;
				} else {
					bs214 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs214;
		var this216 = 0;
		var bs215 = this216;
		var l215 = "  *  ".length;
		var _g1215 = 0;
		var _g315 = l215;
		while(_g1215 < _g315) {
			var i215 = _g1215++;
			var no215 = "  *  ".charCodeAt(i215);
			if(no215 == null) {
				break;
			}
			var v215;
			switch(no215) {
			case 32:
				v215 = false;
				break;
			case 42:
				v215 = true;
				break;
			case 48:
				v215 = false;
				break;
			case 49:
				v215 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i215)));
			}
			switch(i215 - (l215 - 8)) {
			case 0:
				if(v215) {
					bs215 |= 128;
				} else {
					bs215 &= -129;
				}
				break;
			case 1:
				if(v215) {
					bs215 |= 64;
				} else {
					bs215 &= -65;
				}
				break;
			case 2:
				if(v215) {
					bs215 |= 32;
				} else {
					bs215 &= -33;
				}
				break;
			case 3:
				if(v215) {
					bs215 |= 16;
				} else {
					bs215 &= -17;
				}
				break;
			case 4:
				if(v215) {
					bs215 |= 8;
				} else {
					bs215 &= -9;
				}
				break;
			case 5:
				if(v215) {
					bs215 |= 4;
				} else {
					bs215 &= -5;
				}
				break;
			case 6:
				if(v215) {
					bs215 |= 2;
				} else {
					bs215 &= -3;
				}
				break;
			case 7:
				if(v215) {
					bs215 |= 1;
				} else {
					bs215 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs215;
		var this217 = 0;
		var bs216 = this217;
		var l216 = " *   ".length;
		var _g1216 = 0;
		var _g316 = l216;
		while(_g1216 < _g316) {
			var i216 = _g1216++;
			var no216 = " *   ".charCodeAt(i216);
			if(no216 == null) {
				break;
			}
			var v216;
			switch(no216) {
			case 32:
				v216 = false;
				break;
			case 42:
				v216 = true;
				break;
			case 48:
				v216 = false;
				break;
			case 49:
				v216 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i216)));
			}
			switch(i216 - (l216 - 8)) {
			case 0:
				if(v216) {
					bs216 |= 128;
				} else {
					bs216 &= -129;
				}
				break;
			case 1:
				if(v216) {
					bs216 |= 64;
				} else {
					bs216 &= -65;
				}
				break;
			case 2:
				if(v216) {
					bs216 |= 32;
				} else {
					bs216 &= -33;
				}
				break;
			case 3:
				if(v216) {
					bs216 |= 16;
				} else {
					bs216 &= -17;
				}
				break;
			case 4:
				if(v216) {
					bs216 |= 8;
				} else {
					bs216 &= -9;
				}
				break;
			case 5:
				if(v216) {
					bs216 |= 4;
				} else {
					bs216 &= -5;
				}
				break;
			case 6:
				if(v216) {
					bs216 |= 2;
				} else {
					bs216 &= -3;
				}
				break;
			case 7:
				if(v216) {
					bs216 |= 1;
				} else {
					bs216 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs216;
		break;
	case 63:
		var this218 = 0;
		var bs217 = this218;
		var l217 = " *** ".length;
		var _g1217 = 0;
		var _g317 = l217;
		while(_g1217 < _g317) {
			var i217 = _g1217++;
			var no217 = " *** ".charCodeAt(i217);
			if(no217 == null) {
				break;
			}
			var v217;
			switch(no217) {
			case 32:
				v217 = false;
				break;
			case 42:
				v217 = true;
				break;
			case 48:
				v217 = false;
				break;
			case 49:
				v217 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i217)));
			}
			switch(i217 - (l217 - 8)) {
			case 0:
				if(v217) {
					bs217 |= 128;
				} else {
					bs217 &= -129;
				}
				break;
			case 1:
				if(v217) {
					bs217 |= 64;
				} else {
					bs217 &= -65;
				}
				break;
			case 2:
				if(v217) {
					bs217 |= 32;
				} else {
					bs217 &= -33;
				}
				break;
			case 3:
				if(v217) {
					bs217 |= 16;
				} else {
					bs217 &= -17;
				}
				break;
			case 4:
				if(v217) {
					bs217 |= 8;
				} else {
					bs217 &= -9;
				}
				break;
			case 5:
				if(v217) {
					bs217 |= 4;
				} else {
					bs217 &= -5;
				}
				break;
			case 6:
				if(v217) {
					bs217 |= 2;
				} else {
					bs217 &= -3;
				}
				break;
			case 7:
				if(v217) {
					bs217 |= 1;
				} else {
					bs217 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs217;
		var this219 = 0;
		var bs218 = this219;
		var l218 = "*   *".length;
		var _g1218 = 0;
		var _g318 = l218;
		while(_g1218 < _g318) {
			var i218 = _g1218++;
			var no218 = "*   *".charCodeAt(i218);
			if(no218 == null) {
				break;
			}
			var v218;
			switch(no218) {
			case 32:
				v218 = false;
				break;
			case 42:
				v218 = true;
				break;
			case 48:
				v218 = false;
				break;
			case 49:
				v218 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i218)));
			}
			switch(i218 - (l218 - 8)) {
			case 0:
				if(v218) {
					bs218 |= 128;
				} else {
					bs218 &= -129;
				}
				break;
			case 1:
				if(v218) {
					bs218 |= 64;
				} else {
					bs218 &= -65;
				}
				break;
			case 2:
				if(v218) {
					bs218 |= 32;
				} else {
					bs218 &= -33;
				}
				break;
			case 3:
				if(v218) {
					bs218 |= 16;
				} else {
					bs218 &= -17;
				}
				break;
			case 4:
				if(v218) {
					bs218 |= 8;
				} else {
					bs218 &= -9;
				}
				break;
			case 5:
				if(v218) {
					bs218 |= 4;
				} else {
					bs218 &= -5;
				}
				break;
			case 6:
				if(v218) {
					bs218 |= 2;
				} else {
					bs218 &= -3;
				}
				break;
			case 7:
				if(v218) {
					bs218 |= 1;
				} else {
					bs218 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs218;
		var this220 = 0;
		var bs219 = this220;
		var l219 = "    *".length;
		var _g1219 = 0;
		var _g319 = l219;
		while(_g1219 < _g319) {
			var i219 = _g1219++;
			var no219 = "    *".charCodeAt(i219);
			if(no219 == null) {
				break;
			}
			var v219;
			switch(no219) {
			case 32:
				v219 = false;
				break;
			case 42:
				v219 = true;
				break;
			case 48:
				v219 = false;
				break;
			case 49:
				v219 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i219)));
			}
			switch(i219 - (l219 - 8)) {
			case 0:
				if(v219) {
					bs219 |= 128;
				} else {
					bs219 &= -129;
				}
				break;
			case 1:
				if(v219) {
					bs219 |= 64;
				} else {
					bs219 &= -65;
				}
				break;
			case 2:
				if(v219) {
					bs219 |= 32;
				} else {
					bs219 &= -33;
				}
				break;
			case 3:
				if(v219) {
					bs219 |= 16;
				} else {
					bs219 &= -17;
				}
				break;
			case 4:
				if(v219) {
					bs219 |= 8;
				} else {
					bs219 &= -9;
				}
				break;
			case 5:
				if(v219) {
					bs219 |= 4;
				} else {
					bs219 &= -5;
				}
				break;
			case 6:
				if(v219) {
					bs219 |= 2;
				} else {
					bs219 &= -3;
				}
				break;
			case 7:
				if(v219) {
					bs219 |= 1;
				} else {
					bs219 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs219;
		var this221 = 0;
		var bs220 = this221;
		var l220 = "   * ".length;
		var _g1220 = 0;
		var _g320 = l220;
		while(_g1220 < _g320) {
			var i220 = _g1220++;
			var no220 = "   * ".charCodeAt(i220);
			if(no220 == null) {
				break;
			}
			var v220;
			switch(no220) {
			case 32:
				v220 = false;
				break;
			case 42:
				v220 = true;
				break;
			case 48:
				v220 = false;
				break;
			case 49:
				v220 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i220)));
			}
			switch(i220 - (l220 - 8)) {
			case 0:
				if(v220) {
					bs220 |= 128;
				} else {
					bs220 &= -129;
				}
				break;
			case 1:
				if(v220) {
					bs220 |= 64;
				} else {
					bs220 &= -65;
				}
				break;
			case 2:
				if(v220) {
					bs220 |= 32;
				} else {
					bs220 &= -33;
				}
				break;
			case 3:
				if(v220) {
					bs220 |= 16;
				} else {
					bs220 &= -17;
				}
				break;
			case 4:
				if(v220) {
					bs220 |= 8;
				} else {
					bs220 &= -9;
				}
				break;
			case 5:
				if(v220) {
					bs220 |= 4;
				} else {
					bs220 &= -5;
				}
				break;
			case 6:
				if(v220) {
					bs220 |= 2;
				} else {
					bs220 &= -3;
				}
				break;
			case 7:
				if(v220) {
					bs220 |= 1;
				} else {
					bs220 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs220;
		var this222 = 0;
		var bs221 = this222;
		var l221 = "  *  ".length;
		var _g1221 = 0;
		var _g321 = l221;
		while(_g1221 < _g321) {
			var i221 = _g1221++;
			var no221 = "  *  ".charCodeAt(i221);
			if(no221 == null) {
				break;
			}
			var v221;
			switch(no221) {
			case 32:
				v221 = false;
				break;
			case 42:
				v221 = true;
				break;
			case 48:
				v221 = false;
				break;
			case 49:
				v221 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i221)));
			}
			switch(i221 - (l221 - 8)) {
			case 0:
				if(v221) {
					bs221 |= 128;
				} else {
					bs221 &= -129;
				}
				break;
			case 1:
				if(v221) {
					bs221 |= 64;
				} else {
					bs221 &= -65;
				}
				break;
			case 2:
				if(v221) {
					bs221 |= 32;
				} else {
					bs221 &= -33;
				}
				break;
			case 3:
				if(v221) {
					bs221 |= 16;
				} else {
					bs221 &= -17;
				}
				break;
			case 4:
				if(v221) {
					bs221 |= 8;
				} else {
					bs221 &= -9;
				}
				break;
			case 5:
				if(v221) {
					bs221 |= 4;
				} else {
					bs221 &= -5;
				}
				break;
			case 6:
				if(v221) {
					bs221 |= 2;
				} else {
					bs221 &= -3;
				}
				break;
			case 7:
				if(v221) {
					bs221 |= 1;
				} else {
					bs221 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs221;
		var this223 = 0;
		var bs222 = this223;
		var l222 = "     ".length;
		var _g1222 = 0;
		var _g322 = l222;
		while(_g1222 < _g322) {
			var i222 = _g1222++;
			var no222 = "     ".charCodeAt(i222);
			if(no222 == null) {
				break;
			}
			var v222;
			switch(no222) {
			case 32:
				v222 = false;
				break;
			case 42:
				v222 = true;
				break;
			case 48:
				v222 = false;
				break;
			case 49:
				v222 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i222)));
			}
			switch(i222 - (l222 - 8)) {
			case 0:
				if(v222) {
					bs222 |= 128;
				} else {
					bs222 &= -129;
				}
				break;
			case 1:
				if(v222) {
					bs222 |= 64;
				} else {
					bs222 &= -65;
				}
				break;
			case 2:
				if(v222) {
					bs222 |= 32;
				} else {
					bs222 &= -33;
				}
				break;
			case 3:
				if(v222) {
					bs222 |= 16;
				} else {
					bs222 &= -17;
				}
				break;
			case 4:
				if(v222) {
					bs222 |= 8;
				} else {
					bs222 &= -9;
				}
				break;
			case 5:
				if(v222) {
					bs222 |= 4;
				} else {
					bs222 &= -5;
				}
				break;
			case 6:
				if(v222) {
					bs222 |= 2;
				} else {
					bs222 &= -3;
				}
				break;
			case 7:
				if(v222) {
					bs222 |= 1;
				} else {
					bs222 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs222;
		var this224 = 0;
		var bs223 = this224;
		var l223 = "  *  ".length;
		var _g1223 = 0;
		var _g323 = l223;
		while(_g1223 < _g323) {
			var i223 = _g1223++;
			var no223 = "  *  ".charCodeAt(i223);
			if(no223 == null) {
				break;
			}
			var v223;
			switch(no223) {
			case 32:
				v223 = false;
				break;
			case 42:
				v223 = true;
				break;
			case 48:
				v223 = false;
				break;
			case 49:
				v223 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i223)));
			}
			switch(i223 - (l223 - 8)) {
			case 0:
				if(v223) {
					bs223 |= 128;
				} else {
					bs223 &= -129;
				}
				break;
			case 1:
				if(v223) {
					bs223 |= 64;
				} else {
					bs223 &= -65;
				}
				break;
			case 2:
				if(v223) {
					bs223 |= 32;
				} else {
					bs223 &= -33;
				}
				break;
			case 3:
				if(v223) {
					bs223 |= 16;
				} else {
					bs223 &= -17;
				}
				break;
			case 4:
				if(v223) {
					bs223 |= 8;
				} else {
					bs223 &= -9;
				}
				break;
			case 5:
				if(v223) {
					bs223 |= 4;
				} else {
					bs223 &= -5;
				}
				break;
			case 6:
				if(v223) {
					bs223 |= 2;
				} else {
					bs223 &= -3;
				}
				break;
			case 7:
				if(v223) {
					bs223 |= 1;
				} else {
					bs223 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs223;
		break;
	case 64:
		var this225 = 0;
		var bs224 = this225;
		var l224 = " *** ".length;
		var _g1224 = 0;
		var _g324 = l224;
		while(_g1224 < _g324) {
			var i224 = _g1224++;
			var no224 = " *** ".charCodeAt(i224);
			if(no224 == null) {
				break;
			}
			var v224;
			switch(no224) {
			case 32:
				v224 = false;
				break;
			case 42:
				v224 = true;
				break;
			case 48:
				v224 = false;
				break;
			case 49:
				v224 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i224)));
			}
			switch(i224 - (l224 - 8)) {
			case 0:
				if(v224) {
					bs224 |= 128;
				} else {
					bs224 &= -129;
				}
				break;
			case 1:
				if(v224) {
					bs224 |= 64;
				} else {
					bs224 &= -65;
				}
				break;
			case 2:
				if(v224) {
					bs224 |= 32;
				} else {
					bs224 &= -33;
				}
				break;
			case 3:
				if(v224) {
					bs224 |= 16;
				} else {
					bs224 &= -17;
				}
				break;
			case 4:
				if(v224) {
					bs224 |= 8;
				} else {
					bs224 &= -9;
				}
				break;
			case 5:
				if(v224) {
					bs224 |= 4;
				} else {
					bs224 &= -5;
				}
				break;
			case 6:
				if(v224) {
					bs224 |= 2;
				} else {
					bs224 &= -3;
				}
				break;
			case 7:
				if(v224) {
					bs224 |= 1;
				} else {
					bs224 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs224;
		var this226 = 0;
		var bs225 = this226;
		var l225 = "*   *".length;
		var _g1225 = 0;
		var _g325 = l225;
		while(_g1225 < _g325) {
			var i225 = _g1225++;
			var no225 = "*   *".charCodeAt(i225);
			if(no225 == null) {
				break;
			}
			var v225;
			switch(no225) {
			case 32:
				v225 = false;
				break;
			case 42:
				v225 = true;
				break;
			case 48:
				v225 = false;
				break;
			case 49:
				v225 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i225)));
			}
			switch(i225 - (l225 - 8)) {
			case 0:
				if(v225) {
					bs225 |= 128;
				} else {
					bs225 &= -129;
				}
				break;
			case 1:
				if(v225) {
					bs225 |= 64;
				} else {
					bs225 &= -65;
				}
				break;
			case 2:
				if(v225) {
					bs225 |= 32;
				} else {
					bs225 &= -33;
				}
				break;
			case 3:
				if(v225) {
					bs225 |= 16;
				} else {
					bs225 &= -17;
				}
				break;
			case 4:
				if(v225) {
					bs225 |= 8;
				} else {
					bs225 &= -9;
				}
				break;
			case 5:
				if(v225) {
					bs225 |= 4;
				} else {
					bs225 &= -5;
				}
				break;
			case 6:
				if(v225) {
					bs225 |= 2;
				} else {
					bs225 &= -3;
				}
				break;
			case 7:
				if(v225) {
					bs225 |= 1;
				} else {
					bs225 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs225;
		var this227 = 0;
		var bs226 = this227;
		var l226 = "    *".length;
		var _g1226 = 0;
		var _g326 = l226;
		while(_g1226 < _g326) {
			var i226 = _g1226++;
			var no226 = "    *".charCodeAt(i226);
			if(no226 == null) {
				break;
			}
			var v226;
			switch(no226) {
			case 32:
				v226 = false;
				break;
			case 42:
				v226 = true;
				break;
			case 48:
				v226 = false;
				break;
			case 49:
				v226 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i226)));
			}
			switch(i226 - (l226 - 8)) {
			case 0:
				if(v226) {
					bs226 |= 128;
				} else {
					bs226 &= -129;
				}
				break;
			case 1:
				if(v226) {
					bs226 |= 64;
				} else {
					bs226 &= -65;
				}
				break;
			case 2:
				if(v226) {
					bs226 |= 32;
				} else {
					bs226 &= -33;
				}
				break;
			case 3:
				if(v226) {
					bs226 |= 16;
				} else {
					bs226 &= -17;
				}
				break;
			case 4:
				if(v226) {
					bs226 |= 8;
				} else {
					bs226 &= -9;
				}
				break;
			case 5:
				if(v226) {
					bs226 |= 4;
				} else {
					bs226 &= -5;
				}
				break;
			case 6:
				if(v226) {
					bs226 |= 2;
				} else {
					bs226 &= -3;
				}
				break;
			case 7:
				if(v226) {
					bs226 |= 1;
				} else {
					bs226 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs226;
		var this228 = 0;
		var bs227 = this228;
		var l227 = " ** *".length;
		var _g1227 = 0;
		var _g327 = l227;
		while(_g1227 < _g327) {
			var i227 = _g1227++;
			var no227 = " ** *".charCodeAt(i227);
			if(no227 == null) {
				break;
			}
			var v227;
			switch(no227) {
			case 32:
				v227 = false;
				break;
			case 42:
				v227 = true;
				break;
			case 48:
				v227 = false;
				break;
			case 49:
				v227 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i227)));
			}
			switch(i227 - (l227 - 8)) {
			case 0:
				if(v227) {
					bs227 |= 128;
				} else {
					bs227 &= -129;
				}
				break;
			case 1:
				if(v227) {
					bs227 |= 64;
				} else {
					bs227 &= -65;
				}
				break;
			case 2:
				if(v227) {
					bs227 |= 32;
				} else {
					bs227 &= -33;
				}
				break;
			case 3:
				if(v227) {
					bs227 |= 16;
				} else {
					bs227 &= -17;
				}
				break;
			case 4:
				if(v227) {
					bs227 |= 8;
				} else {
					bs227 &= -9;
				}
				break;
			case 5:
				if(v227) {
					bs227 |= 4;
				} else {
					bs227 &= -5;
				}
				break;
			case 6:
				if(v227) {
					bs227 |= 2;
				} else {
					bs227 &= -3;
				}
				break;
			case 7:
				if(v227) {
					bs227 |= 1;
				} else {
					bs227 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs227;
		var this229 = 0;
		var bs228 = this229;
		var l228 = "* * *".length;
		var _g1228 = 0;
		var _g328 = l228;
		while(_g1228 < _g328) {
			var i228 = _g1228++;
			var no228 = "* * *".charCodeAt(i228);
			if(no228 == null) {
				break;
			}
			var v228;
			switch(no228) {
			case 32:
				v228 = false;
				break;
			case 42:
				v228 = true;
				break;
			case 48:
				v228 = false;
				break;
			case 49:
				v228 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i228)));
			}
			switch(i228 - (l228 - 8)) {
			case 0:
				if(v228) {
					bs228 |= 128;
				} else {
					bs228 &= -129;
				}
				break;
			case 1:
				if(v228) {
					bs228 |= 64;
				} else {
					bs228 &= -65;
				}
				break;
			case 2:
				if(v228) {
					bs228 |= 32;
				} else {
					bs228 &= -33;
				}
				break;
			case 3:
				if(v228) {
					bs228 |= 16;
				} else {
					bs228 &= -17;
				}
				break;
			case 4:
				if(v228) {
					bs228 |= 8;
				} else {
					bs228 &= -9;
				}
				break;
			case 5:
				if(v228) {
					bs228 |= 4;
				} else {
					bs228 &= -5;
				}
				break;
			case 6:
				if(v228) {
					bs228 |= 2;
				} else {
					bs228 &= -3;
				}
				break;
			case 7:
				if(v228) {
					bs228 |= 1;
				} else {
					bs228 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs228;
		var this230 = 0;
		var bs229 = this230;
		var l229 = "* * *".length;
		var _g1229 = 0;
		var _g329 = l229;
		while(_g1229 < _g329) {
			var i229 = _g1229++;
			var no229 = "* * *".charCodeAt(i229);
			if(no229 == null) {
				break;
			}
			var v229;
			switch(no229) {
			case 32:
				v229 = false;
				break;
			case 42:
				v229 = true;
				break;
			case 48:
				v229 = false;
				break;
			case 49:
				v229 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i229)));
			}
			switch(i229 - (l229 - 8)) {
			case 0:
				if(v229) {
					bs229 |= 128;
				} else {
					bs229 &= -129;
				}
				break;
			case 1:
				if(v229) {
					bs229 |= 64;
				} else {
					bs229 &= -65;
				}
				break;
			case 2:
				if(v229) {
					bs229 |= 32;
				} else {
					bs229 &= -33;
				}
				break;
			case 3:
				if(v229) {
					bs229 |= 16;
				} else {
					bs229 &= -17;
				}
				break;
			case 4:
				if(v229) {
					bs229 |= 8;
				} else {
					bs229 &= -9;
				}
				break;
			case 5:
				if(v229) {
					bs229 |= 4;
				} else {
					bs229 &= -5;
				}
				break;
			case 6:
				if(v229) {
					bs229 |= 2;
				} else {
					bs229 &= -3;
				}
				break;
			case 7:
				if(v229) {
					bs229 |= 1;
				} else {
					bs229 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs229;
		var this231 = 0;
		var bs230 = this231;
		var l230 = " *** ".length;
		var _g1230 = 0;
		var _g330 = l230;
		while(_g1230 < _g330) {
			var i230 = _g1230++;
			var no230 = " *** ".charCodeAt(i230);
			if(no230 == null) {
				break;
			}
			var v230;
			switch(no230) {
			case 32:
				v230 = false;
				break;
			case 42:
				v230 = true;
				break;
			case 48:
				v230 = false;
				break;
			case 49:
				v230 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i230)));
			}
			switch(i230 - (l230 - 8)) {
			case 0:
				if(v230) {
					bs230 |= 128;
				} else {
					bs230 &= -129;
				}
				break;
			case 1:
				if(v230) {
					bs230 |= 64;
				} else {
					bs230 &= -65;
				}
				break;
			case 2:
				if(v230) {
					bs230 |= 32;
				} else {
					bs230 &= -33;
				}
				break;
			case 3:
				if(v230) {
					bs230 |= 16;
				} else {
					bs230 &= -17;
				}
				break;
			case 4:
				if(v230) {
					bs230 |= 8;
				} else {
					bs230 &= -9;
				}
				break;
			case 5:
				if(v230) {
					bs230 |= 4;
				} else {
					bs230 &= -5;
				}
				break;
			case 6:
				if(v230) {
					bs230 |= 2;
				} else {
					bs230 &= -3;
				}
				break;
			case 7:
				if(v230) {
					bs230 |= 1;
				} else {
					bs230 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs230;
		break;
	case 65:
		var this232 = 0;
		var bs231 = this232;
		var l231 = " *** ".length;
		var _g1231 = 0;
		var _g331 = l231;
		while(_g1231 < _g331) {
			var i231 = _g1231++;
			var no231 = " *** ".charCodeAt(i231);
			if(no231 == null) {
				break;
			}
			var v231;
			switch(no231) {
			case 32:
				v231 = false;
				break;
			case 42:
				v231 = true;
				break;
			case 48:
				v231 = false;
				break;
			case 49:
				v231 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i231)));
			}
			switch(i231 - (l231 - 8)) {
			case 0:
				if(v231) {
					bs231 |= 128;
				} else {
					bs231 &= -129;
				}
				break;
			case 1:
				if(v231) {
					bs231 |= 64;
				} else {
					bs231 &= -65;
				}
				break;
			case 2:
				if(v231) {
					bs231 |= 32;
				} else {
					bs231 &= -33;
				}
				break;
			case 3:
				if(v231) {
					bs231 |= 16;
				} else {
					bs231 &= -17;
				}
				break;
			case 4:
				if(v231) {
					bs231 |= 8;
				} else {
					bs231 &= -9;
				}
				break;
			case 5:
				if(v231) {
					bs231 |= 4;
				} else {
					bs231 &= -5;
				}
				break;
			case 6:
				if(v231) {
					bs231 |= 2;
				} else {
					bs231 &= -3;
				}
				break;
			case 7:
				if(v231) {
					bs231 |= 1;
				} else {
					bs231 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs231;
		var this233 = 0;
		var bs232 = this233;
		var l232 = "*   *".length;
		var _g1232 = 0;
		var _g332 = l232;
		while(_g1232 < _g332) {
			var i232 = _g1232++;
			var no232 = "*   *".charCodeAt(i232);
			if(no232 == null) {
				break;
			}
			var v232;
			switch(no232) {
			case 32:
				v232 = false;
				break;
			case 42:
				v232 = true;
				break;
			case 48:
				v232 = false;
				break;
			case 49:
				v232 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i232)));
			}
			switch(i232 - (l232 - 8)) {
			case 0:
				if(v232) {
					bs232 |= 128;
				} else {
					bs232 &= -129;
				}
				break;
			case 1:
				if(v232) {
					bs232 |= 64;
				} else {
					bs232 &= -65;
				}
				break;
			case 2:
				if(v232) {
					bs232 |= 32;
				} else {
					bs232 &= -33;
				}
				break;
			case 3:
				if(v232) {
					bs232 |= 16;
				} else {
					bs232 &= -17;
				}
				break;
			case 4:
				if(v232) {
					bs232 |= 8;
				} else {
					bs232 &= -9;
				}
				break;
			case 5:
				if(v232) {
					bs232 |= 4;
				} else {
					bs232 &= -5;
				}
				break;
			case 6:
				if(v232) {
					bs232 |= 2;
				} else {
					bs232 &= -3;
				}
				break;
			case 7:
				if(v232) {
					bs232 |= 1;
				} else {
					bs232 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs232;
		var this234 = 0;
		var bs233 = this234;
		var l233 = "*   *".length;
		var _g1233 = 0;
		var _g333 = l233;
		while(_g1233 < _g333) {
			var i233 = _g1233++;
			var no233 = "*   *".charCodeAt(i233);
			if(no233 == null) {
				break;
			}
			var v233;
			switch(no233) {
			case 32:
				v233 = false;
				break;
			case 42:
				v233 = true;
				break;
			case 48:
				v233 = false;
				break;
			case 49:
				v233 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i233)));
			}
			switch(i233 - (l233 - 8)) {
			case 0:
				if(v233) {
					bs233 |= 128;
				} else {
					bs233 &= -129;
				}
				break;
			case 1:
				if(v233) {
					bs233 |= 64;
				} else {
					bs233 &= -65;
				}
				break;
			case 2:
				if(v233) {
					bs233 |= 32;
				} else {
					bs233 &= -33;
				}
				break;
			case 3:
				if(v233) {
					bs233 |= 16;
				} else {
					bs233 &= -17;
				}
				break;
			case 4:
				if(v233) {
					bs233 |= 8;
				} else {
					bs233 &= -9;
				}
				break;
			case 5:
				if(v233) {
					bs233 |= 4;
				} else {
					bs233 &= -5;
				}
				break;
			case 6:
				if(v233) {
					bs233 |= 2;
				} else {
					bs233 &= -3;
				}
				break;
			case 7:
				if(v233) {
					bs233 |= 1;
				} else {
					bs233 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs233;
		var this235 = 0;
		var bs234 = this235;
		var l234 = "*   *".length;
		var _g1234 = 0;
		var _g334 = l234;
		while(_g1234 < _g334) {
			var i234 = _g1234++;
			var no234 = "*   *".charCodeAt(i234);
			if(no234 == null) {
				break;
			}
			var v234;
			switch(no234) {
			case 32:
				v234 = false;
				break;
			case 42:
				v234 = true;
				break;
			case 48:
				v234 = false;
				break;
			case 49:
				v234 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i234)));
			}
			switch(i234 - (l234 - 8)) {
			case 0:
				if(v234) {
					bs234 |= 128;
				} else {
					bs234 &= -129;
				}
				break;
			case 1:
				if(v234) {
					bs234 |= 64;
				} else {
					bs234 &= -65;
				}
				break;
			case 2:
				if(v234) {
					bs234 |= 32;
				} else {
					bs234 &= -33;
				}
				break;
			case 3:
				if(v234) {
					bs234 |= 16;
				} else {
					bs234 &= -17;
				}
				break;
			case 4:
				if(v234) {
					bs234 |= 8;
				} else {
					bs234 &= -9;
				}
				break;
			case 5:
				if(v234) {
					bs234 |= 4;
				} else {
					bs234 &= -5;
				}
				break;
			case 6:
				if(v234) {
					bs234 |= 2;
				} else {
					bs234 &= -3;
				}
				break;
			case 7:
				if(v234) {
					bs234 |= 1;
				} else {
					bs234 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs234;
		var this236 = 0;
		var bs235 = this236;
		var l235 = "*****".length;
		var _g1235 = 0;
		var _g335 = l235;
		while(_g1235 < _g335) {
			var i235 = _g1235++;
			var no235 = "*****".charCodeAt(i235);
			if(no235 == null) {
				break;
			}
			var v235;
			switch(no235) {
			case 32:
				v235 = false;
				break;
			case 42:
				v235 = true;
				break;
			case 48:
				v235 = false;
				break;
			case 49:
				v235 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i235)));
			}
			switch(i235 - (l235 - 8)) {
			case 0:
				if(v235) {
					bs235 |= 128;
				} else {
					bs235 &= -129;
				}
				break;
			case 1:
				if(v235) {
					bs235 |= 64;
				} else {
					bs235 &= -65;
				}
				break;
			case 2:
				if(v235) {
					bs235 |= 32;
				} else {
					bs235 &= -33;
				}
				break;
			case 3:
				if(v235) {
					bs235 |= 16;
				} else {
					bs235 &= -17;
				}
				break;
			case 4:
				if(v235) {
					bs235 |= 8;
				} else {
					bs235 &= -9;
				}
				break;
			case 5:
				if(v235) {
					bs235 |= 4;
				} else {
					bs235 &= -5;
				}
				break;
			case 6:
				if(v235) {
					bs235 |= 2;
				} else {
					bs235 &= -3;
				}
				break;
			case 7:
				if(v235) {
					bs235 |= 1;
				} else {
					bs235 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs235;
		var this237 = 0;
		var bs236 = this237;
		var l236 = "*   *".length;
		var _g1236 = 0;
		var _g336 = l236;
		while(_g1236 < _g336) {
			var i236 = _g1236++;
			var no236 = "*   *".charCodeAt(i236);
			if(no236 == null) {
				break;
			}
			var v236;
			switch(no236) {
			case 32:
				v236 = false;
				break;
			case 42:
				v236 = true;
				break;
			case 48:
				v236 = false;
				break;
			case 49:
				v236 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i236)));
			}
			switch(i236 - (l236 - 8)) {
			case 0:
				if(v236) {
					bs236 |= 128;
				} else {
					bs236 &= -129;
				}
				break;
			case 1:
				if(v236) {
					bs236 |= 64;
				} else {
					bs236 &= -65;
				}
				break;
			case 2:
				if(v236) {
					bs236 |= 32;
				} else {
					bs236 &= -33;
				}
				break;
			case 3:
				if(v236) {
					bs236 |= 16;
				} else {
					bs236 &= -17;
				}
				break;
			case 4:
				if(v236) {
					bs236 |= 8;
				} else {
					bs236 &= -9;
				}
				break;
			case 5:
				if(v236) {
					bs236 |= 4;
				} else {
					bs236 &= -5;
				}
				break;
			case 6:
				if(v236) {
					bs236 |= 2;
				} else {
					bs236 &= -3;
				}
				break;
			case 7:
				if(v236) {
					bs236 |= 1;
				} else {
					bs236 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs236;
		var this238 = 0;
		var bs237 = this238;
		var l237 = "*   *".length;
		var _g1237 = 0;
		var _g337 = l237;
		while(_g1237 < _g337) {
			var i237 = _g1237++;
			var no237 = "*   *".charCodeAt(i237);
			if(no237 == null) {
				break;
			}
			var v237;
			switch(no237) {
			case 32:
				v237 = false;
				break;
			case 42:
				v237 = true;
				break;
			case 48:
				v237 = false;
				break;
			case 49:
				v237 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i237)));
			}
			switch(i237 - (l237 - 8)) {
			case 0:
				if(v237) {
					bs237 |= 128;
				} else {
					bs237 &= -129;
				}
				break;
			case 1:
				if(v237) {
					bs237 |= 64;
				} else {
					bs237 &= -65;
				}
				break;
			case 2:
				if(v237) {
					bs237 |= 32;
				} else {
					bs237 &= -33;
				}
				break;
			case 3:
				if(v237) {
					bs237 |= 16;
				} else {
					bs237 &= -17;
				}
				break;
			case 4:
				if(v237) {
					bs237 |= 8;
				} else {
					bs237 &= -9;
				}
				break;
			case 5:
				if(v237) {
					bs237 |= 4;
				} else {
					bs237 &= -5;
				}
				break;
			case 6:
				if(v237) {
					bs237 |= 2;
				} else {
					bs237 &= -3;
				}
				break;
			case 7:
				if(v237) {
					bs237 |= 1;
				} else {
					bs237 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs237;
		break;
	case 66:
		var this239 = 0;
		var bs238 = this239;
		var l238 = "**** ".length;
		var _g1238 = 0;
		var _g338 = l238;
		while(_g1238 < _g338) {
			var i238 = _g1238++;
			var no238 = "**** ".charCodeAt(i238);
			if(no238 == null) {
				break;
			}
			var v238;
			switch(no238) {
			case 32:
				v238 = false;
				break;
			case 42:
				v238 = true;
				break;
			case 48:
				v238 = false;
				break;
			case 49:
				v238 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i238)));
			}
			switch(i238 - (l238 - 8)) {
			case 0:
				if(v238) {
					bs238 |= 128;
				} else {
					bs238 &= -129;
				}
				break;
			case 1:
				if(v238) {
					bs238 |= 64;
				} else {
					bs238 &= -65;
				}
				break;
			case 2:
				if(v238) {
					bs238 |= 32;
				} else {
					bs238 &= -33;
				}
				break;
			case 3:
				if(v238) {
					bs238 |= 16;
				} else {
					bs238 &= -17;
				}
				break;
			case 4:
				if(v238) {
					bs238 |= 8;
				} else {
					bs238 &= -9;
				}
				break;
			case 5:
				if(v238) {
					bs238 |= 4;
				} else {
					bs238 &= -5;
				}
				break;
			case 6:
				if(v238) {
					bs238 |= 2;
				} else {
					bs238 &= -3;
				}
				break;
			case 7:
				if(v238) {
					bs238 |= 1;
				} else {
					bs238 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs238;
		var this240 = 0;
		var bs239 = this240;
		var l239 = "*   *".length;
		var _g1239 = 0;
		var _g339 = l239;
		while(_g1239 < _g339) {
			var i239 = _g1239++;
			var no239 = "*   *".charCodeAt(i239);
			if(no239 == null) {
				break;
			}
			var v239;
			switch(no239) {
			case 32:
				v239 = false;
				break;
			case 42:
				v239 = true;
				break;
			case 48:
				v239 = false;
				break;
			case 49:
				v239 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i239)));
			}
			switch(i239 - (l239 - 8)) {
			case 0:
				if(v239) {
					bs239 |= 128;
				} else {
					bs239 &= -129;
				}
				break;
			case 1:
				if(v239) {
					bs239 |= 64;
				} else {
					bs239 &= -65;
				}
				break;
			case 2:
				if(v239) {
					bs239 |= 32;
				} else {
					bs239 &= -33;
				}
				break;
			case 3:
				if(v239) {
					bs239 |= 16;
				} else {
					bs239 &= -17;
				}
				break;
			case 4:
				if(v239) {
					bs239 |= 8;
				} else {
					bs239 &= -9;
				}
				break;
			case 5:
				if(v239) {
					bs239 |= 4;
				} else {
					bs239 &= -5;
				}
				break;
			case 6:
				if(v239) {
					bs239 |= 2;
				} else {
					bs239 &= -3;
				}
				break;
			case 7:
				if(v239) {
					bs239 |= 1;
				} else {
					bs239 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs239;
		var this241 = 0;
		var bs240 = this241;
		var l240 = "*   *".length;
		var _g1240 = 0;
		var _g340 = l240;
		while(_g1240 < _g340) {
			var i240 = _g1240++;
			var no240 = "*   *".charCodeAt(i240);
			if(no240 == null) {
				break;
			}
			var v240;
			switch(no240) {
			case 32:
				v240 = false;
				break;
			case 42:
				v240 = true;
				break;
			case 48:
				v240 = false;
				break;
			case 49:
				v240 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i240)));
			}
			switch(i240 - (l240 - 8)) {
			case 0:
				if(v240) {
					bs240 |= 128;
				} else {
					bs240 &= -129;
				}
				break;
			case 1:
				if(v240) {
					bs240 |= 64;
				} else {
					bs240 &= -65;
				}
				break;
			case 2:
				if(v240) {
					bs240 |= 32;
				} else {
					bs240 &= -33;
				}
				break;
			case 3:
				if(v240) {
					bs240 |= 16;
				} else {
					bs240 &= -17;
				}
				break;
			case 4:
				if(v240) {
					bs240 |= 8;
				} else {
					bs240 &= -9;
				}
				break;
			case 5:
				if(v240) {
					bs240 |= 4;
				} else {
					bs240 &= -5;
				}
				break;
			case 6:
				if(v240) {
					bs240 |= 2;
				} else {
					bs240 &= -3;
				}
				break;
			case 7:
				if(v240) {
					bs240 |= 1;
				} else {
					bs240 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs240;
		var this242 = 0;
		var bs241 = this242;
		var l241 = "**** ".length;
		var _g1241 = 0;
		var _g341 = l241;
		while(_g1241 < _g341) {
			var i241 = _g1241++;
			var no241 = "**** ".charCodeAt(i241);
			if(no241 == null) {
				break;
			}
			var v241;
			switch(no241) {
			case 32:
				v241 = false;
				break;
			case 42:
				v241 = true;
				break;
			case 48:
				v241 = false;
				break;
			case 49:
				v241 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i241)));
			}
			switch(i241 - (l241 - 8)) {
			case 0:
				if(v241) {
					bs241 |= 128;
				} else {
					bs241 &= -129;
				}
				break;
			case 1:
				if(v241) {
					bs241 |= 64;
				} else {
					bs241 &= -65;
				}
				break;
			case 2:
				if(v241) {
					bs241 |= 32;
				} else {
					bs241 &= -33;
				}
				break;
			case 3:
				if(v241) {
					bs241 |= 16;
				} else {
					bs241 &= -17;
				}
				break;
			case 4:
				if(v241) {
					bs241 |= 8;
				} else {
					bs241 &= -9;
				}
				break;
			case 5:
				if(v241) {
					bs241 |= 4;
				} else {
					bs241 &= -5;
				}
				break;
			case 6:
				if(v241) {
					bs241 |= 2;
				} else {
					bs241 &= -3;
				}
				break;
			case 7:
				if(v241) {
					bs241 |= 1;
				} else {
					bs241 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs241;
		var this243 = 0;
		var bs242 = this243;
		var l242 = "*   *".length;
		var _g1242 = 0;
		var _g342 = l242;
		while(_g1242 < _g342) {
			var i242 = _g1242++;
			var no242 = "*   *".charCodeAt(i242);
			if(no242 == null) {
				break;
			}
			var v242;
			switch(no242) {
			case 32:
				v242 = false;
				break;
			case 42:
				v242 = true;
				break;
			case 48:
				v242 = false;
				break;
			case 49:
				v242 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i242)));
			}
			switch(i242 - (l242 - 8)) {
			case 0:
				if(v242) {
					bs242 |= 128;
				} else {
					bs242 &= -129;
				}
				break;
			case 1:
				if(v242) {
					bs242 |= 64;
				} else {
					bs242 &= -65;
				}
				break;
			case 2:
				if(v242) {
					bs242 |= 32;
				} else {
					bs242 &= -33;
				}
				break;
			case 3:
				if(v242) {
					bs242 |= 16;
				} else {
					bs242 &= -17;
				}
				break;
			case 4:
				if(v242) {
					bs242 |= 8;
				} else {
					bs242 &= -9;
				}
				break;
			case 5:
				if(v242) {
					bs242 |= 4;
				} else {
					bs242 &= -5;
				}
				break;
			case 6:
				if(v242) {
					bs242 |= 2;
				} else {
					bs242 &= -3;
				}
				break;
			case 7:
				if(v242) {
					bs242 |= 1;
				} else {
					bs242 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs242;
		var this244 = 0;
		var bs243 = this244;
		var l243 = "*   *".length;
		var _g1243 = 0;
		var _g343 = l243;
		while(_g1243 < _g343) {
			var i243 = _g1243++;
			var no243 = "*   *".charCodeAt(i243);
			if(no243 == null) {
				break;
			}
			var v243;
			switch(no243) {
			case 32:
				v243 = false;
				break;
			case 42:
				v243 = true;
				break;
			case 48:
				v243 = false;
				break;
			case 49:
				v243 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i243)));
			}
			switch(i243 - (l243 - 8)) {
			case 0:
				if(v243) {
					bs243 |= 128;
				} else {
					bs243 &= -129;
				}
				break;
			case 1:
				if(v243) {
					bs243 |= 64;
				} else {
					bs243 &= -65;
				}
				break;
			case 2:
				if(v243) {
					bs243 |= 32;
				} else {
					bs243 &= -33;
				}
				break;
			case 3:
				if(v243) {
					bs243 |= 16;
				} else {
					bs243 &= -17;
				}
				break;
			case 4:
				if(v243) {
					bs243 |= 8;
				} else {
					bs243 &= -9;
				}
				break;
			case 5:
				if(v243) {
					bs243 |= 4;
				} else {
					bs243 &= -5;
				}
				break;
			case 6:
				if(v243) {
					bs243 |= 2;
				} else {
					bs243 &= -3;
				}
				break;
			case 7:
				if(v243) {
					bs243 |= 1;
				} else {
					bs243 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs243;
		var this245 = 0;
		var bs244 = this245;
		var l244 = "**** ".length;
		var _g1244 = 0;
		var _g344 = l244;
		while(_g1244 < _g344) {
			var i244 = _g1244++;
			var no244 = "**** ".charCodeAt(i244);
			if(no244 == null) {
				break;
			}
			var v244;
			switch(no244) {
			case 32:
				v244 = false;
				break;
			case 42:
				v244 = true;
				break;
			case 48:
				v244 = false;
				break;
			case 49:
				v244 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i244)));
			}
			switch(i244 - (l244 - 8)) {
			case 0:
				if(v244) {
					bs244 |= 128;
				} else {
					bs244 &= -129;
				}
				break;
			case 1:
				if(v244) {
					bs244 |= 64;
				} else {
					bs244 &= -65;
				}
				break;
			case 2:
				if(v244) {
					bs244 |= 32;
				} else {
					bs244 &= -33;
				}
				break;
			case 3:
				if(v244) {
					bs244 |= 16;
				} else {
					bs244 &= -17;
				}
				break;
			case 4:
				if(v244) {
					bs244 |= 8;
				} else {
					bs244 &= -9;
				}
				break;
			case 5:
				if(v244) {
					bs244 |= 4;
				} else {
					bs244 &= -5;
				}
				break;
			case 6:
				if(v244) {
					bs244 |= 2;
				} else {
					bs244 &= -3;
				}
				break;
			case 7:
				if(v244) {
					bs244 |= 1;
				} else {
					bs244 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs244;
		break;
	case 67:
		var this246 = 0;
		var bs245 = this246;
		var l245 = " *** ".length;
		var _g1245 = 0;
		var _g345 = l245;
		while(_g1245 < _g345) {
			var i245 = _g1245++;
			var no245 = " *** ".charCodeAt(i245);
			if(no245 == null) {
				break;
			}
			var v245;
			switch(no245) {
			case 32:
				v245 = false;
				break;
			case 42:
				v245 = true;
				break;
			case 48:
				v245 = false;
				break;
			case 49:
				v245 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i245)));
			}
			switch(i245 - (l245 - 8)) {
			case 0:
				if(v245) {
					bs245 |= 128;
				} else {
					bs245 &= -129;
				}
				break;
			case 1:
				if(v245) {
					bs245 |= 64;
				} else {
					bs245 &= -65;
				}
				break;
			case 2:
				if(v245) {
					bs245 |= 32;
				} else {
					bs245 &= -33;
				}
				break;
			case 3:
				if(v245) {
					bs245 |= 16;
				} else {
					bs245 &= -17;
				}
				break;
			case 4:
				if(v245) {
					bs245 |= 8;
				} else {
					bs245 &= -9;
				}
				break;
			case 5:
				if(v245) {
					bs245 |= 4;
				} else {
					bs245 &= -5;
				}
				break;
			case 6:
				if(v245) {
					bs245 |= 2;
				} else {
					bs245 &= -3;
				}
				break;
			case 7:
				if(v245) {
					bs245 |= 1;
				} else {
					bs245 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs245;
		var this247 = 0;
		var bs246 = this247;
		var l246 = "*   *".length;
		var _g1246 = 0;
		var _g346 = l246;
		while(_g1246 < _g346) {
			var i246 = _g1246++;
			var no246 = "*   *".charCodeAt(i246);
			if(no246 == null) {
				break;
			}
			var v246;
			switch(no246) {
			case 32:
				v246 = false;
				break;
			case 42:
				v246 = true;
				break;
			case 48:
				v246 = false;
				break;
			case 49:
				v246 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i246)));
			}
			switch(i246 - (l246 - 8)) {
			case 0:
				if(v246) {
					bs246 |= 128;
				} else {
					bs246 &= -129;
				}
				break;
			case 1:
				if(v246) {
					bs246 |= 64;
				} else {
					bs246 &= -65;
				}
				break;
			case 2:
				if(v246) {
					bs246 |= 32;
				} else {
					bs246 &= -33;
				}
				break;
			case 3:
				if(v246) {
					bs246 |= 16;
				} else {
					bs246 &= -17;
				}
				break;
			case 4:
				if(v246) {
					bs246 |= 8;
				} else {
					bs246 &= -9;
				}
				break;
			case 5:
				if(v246) {
					bs246 |= 4;
				} else {
					bs246 &= -5;
				}
				break;
			case 6:
				if(v246) {
					bs246 |= 2;
				} else {
					bs246 &= -3;
				}
				break;
			case 7:
				if(v246) {
					bs246 |= 1;
				} else {
					bs246 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs246;
		var this248 = 0;
		var bs247 = this248;
		var l247 = "*    ".length;
		var _g1247 = 0;
		var _g347 = l247;
		while(_g1247 < _g347) {
			var i247 = _g1247++;
			var no247 = "*    ".charCodeAt(i247);
			if(no247 == null) {
				break;
			}
			var v247;
			switch(no247) {
			case 32:
				v247 = false;
				break;
			case 42:
				v247 = true;
				break;
			case 48:
				v247 = false;
				break;
			case 49:
				v247 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i247)));
			}
			switch(i247 - (l247 - 8)) {
			case 0:
				if(v247) {
					bs247 |= 128;
				} else {
					bs247 &= -129;
				}
				break;
			case 1:
				if(v247) {
					bs247 |= 64;
				} else {
					bs247 &= -65;
				}
				break;
			case 2:
				if(v247) {
					bs247 |= 32;
				} else {
					bs247 &= -33;
				}
				break;
			case 3:
				if(v247) {
					bs247 |= 16;
				} else {
					bs247 &= -17;
				}
				break;
			case 4:
				if(v247) {
					bs247 |= 8;
				} else {
					bs247 &= -9;
				}
				break;
			case 5:
				if(v247) {
					bs247 |= 4;
				} else {
					bs247 &= -5;
				}
				break;
			case 6:
				if(v247) {
					bs247 |= 2;
				} else {
					bs247 &= -3;
				}
				break;
			case 7:
				if(v247) {
					bs247 |= 1;
				} else {
					bs247 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs247;
		var this249 = 0;
		var bs248 = this249;
		var l248 = "*    ".length;
		var _g1248 = 0;
		var _g348 = l248;
		while(_g1248 < _g348) {
			var i248 = _g1248++;
			var no248 = "*    ".charCodeAt(i248);
			if(no248 == null) {
				break;
			}
			var v248;
			switch(no248) {
			case 32:
				v248 = false;
				break;
			case 42:
				v248 = true;
				break;
			case 48:
				v248 = false;
				break;
			case 49:
				v248 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i248)));
			}
			switch(i248 - (l248 - 8)) {
			case 0:
				if(v248) {
					bs248 |= 128;
				} else {
					bs248 &= -129;
				}
				break;
			case 1:
				if(v248) {
					bs248 |= 64;
				} else {
					bs248 &= -65;
				}
				break;
			case 2:
				if(v248) {
					bs248 |= 32;
				} else {
					bs248 &= -33;
				}
				break;
			case 3:
				if(v248) {
					bs248 |= 16;
				} else {
					bs248 &= -17;
				}
				break;
			case 4:
				if(v248) {
					bs248 |= 8;
				} else {
					bs248 &= -9;
				}
				break;
			case 5:
				if(v248) {
					bs248 |= 4;
				} else {
					bs248 &= -5;
				}
				break;
			case 6:
				if(v248) {
					bs248 |= 2;
				} else {
					bs248 &= -3;
				}
				break;
			case 7:
				if(v248) {
					bs248 |= 1;
				} else {
					bs248 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs248;
		var this250 = 0;
		var bs249 = this250;
		var l249 = "*    ".length;
		var _g1249 = 0;
		var _g349 = l249;
		while(_g1249 < _g349) {
			var i249 = _g1249++;
			var no249 = "*    ".charCodeAt(i249);
			if(no249 == null) {
				break;
			}
			var v249;
			switch(no249) {
			case 32:
				v249 = false;
				break;
			case 42:
				v249 = true;
				break;
			case 48:
				v249 = false;
				break;
			case 49:
				v249 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i249)));
			}
			switch(i249 - (l249 - 8)) {
			case 0:
				if(v249) {
					bs249 |= 128;
				} else {
					bs249 &= -129;
				}
				break;
			case 1:
				if(v249) {
					bs249 |= 64;
				} else {
					bs249 &= -65;
				}
				break;
			case 2:
				if(v249) {
					bs249 |= 32;
				} else {
					bs249 &= -33;
				}
				break;
			case 3:
				if(v249) {
					bs249 |= 16;
				} else {
					bs249 &= -17;
				}
				break;
			case 4:
				if(v249) {
					bs249 |= 8;
				} else {
					bs249 &= -9;
				}
				break;
			case 5:
				if(v249) {
					bs249 |= 4;
				} else {
					bs249 &= -5;
				}
				break;
			case 6:
				if(v249) {
					bs249 |= 2;
				} else {
					bs249 &= -3;
				}
				break;
			case 7:
				if(v249) {
					bs249 |= 1;
				} else {
					bs249 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs249;
		var this251 = 0;
		var bs250 = this251;
		var l250 = "*   *".length;
		var _g1250 = 0;
		var _g350 = l250;
		while(_g1250 < _g350) {
			var i250 = _g1250++;
			var no250 = "*   *".charCodeAt(i250);
			if(no250 == null) {
				break;
			}
			var v250;
			switch(no250) {
			case 32:
				v250 = false;
				break;
			case 42:
				v250 = true;
				break;
			case 48:
				v250 = false;
				break;
			case 49:
				v250 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i250)));
			}
			switch(i250 - (l250 - 8)) {
			case 0:
				if(v250) {
					bs250 |= 128;
				} else {
					bs250 &= -129;
				}
				break;
			case 1:
				if(v250) {
					bs250 |= 64;
				} else {
					bs250 &= -65;
				}
				break;
			case 2:
				if(v250) {
					bs250 |= 32;
				} else {
					bs250 &= -33;
				}
				break;
			case 3:
				if(v250) {
					bs250 |= 16;
				} else {
					bs250 &= -17;
				}
				break;
			case 4:
				if(v250) {
					bs250 |= 8;
				} else {
					bs250 &= -9;
				}
				break;
			case 5:
				if(v250) {
					bs250 |= 4;
				} else {
					bs250 &= -5;
				}
				break;
			case 6:
				if(v250) {
					bs250 |= 2;
				} else {
					bs250 &= -3;
				}
				break;
			case 7:
				if(v250) {
					bs250 |= 1;
				} else {
					bs250 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs250;
		var this252 = 0;
		var bs251 = this252;
		var l251 = " *** ".length;
		var _g1251 = 0;
		var _g351 = l251;
		while(_g1251 < _g351) {
			var i251 = _g1251++;
			var no251 = " *** ".charCodeAt(i251);
			if(no251 == null) {
				break;
			}
			var v251;
			switch(no251) {
			case 32:
				v251 = false;
				break;
			case 42:
				v251 = true;
				break;
			case 48:
				v251 = false;
				break;
			case 49:
				v251 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i251)));
			}
			switch(i251 - (l251 - 8)) {
			case 0:
				if(v251) {
					bs251 |= 128;
				} else {
					bs251 &= -129;
				}
				break;
			case 1:
				if(v251) {
					bs251 |= 64;
				} else {
					bs251 &= -65;
				}
				break;
			case 2:
				if(v251) {
					bs251 |= 32;
				} else {
					bs251 &= -33;
				}
				break;
			case 3:
				if(v251) {
					bs251 |= 16;
				} else {
					bs251 &= -17;
				}
				break;
			case 4:
				if(v251) {
					bs251 |= 8;
				} else {
					bs251 &= -9;
				}
				break;
			case 5:
				if(v251) {
					bs251 |= 4;
				} else {
					bs251 &= -5;
				}
				break;
			case 6:
				if(v251) {
					bs251 |= 2;
				} else {
					bs251 &= -3;
				}
				break;
			case 7:
				if(v251) {
					bs251 |= 1;
				} else {
					bs251 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs251;
		break;
	case 68:
		var this253 = 0;
		var bs252 = this253;
		var l252 = "***  ".length;
		var _g1252 = 0;
		var _g352 = l252;
		while(_g1252 < _g352) {
			var i252 = _g1252++;
			var no252 = "***  ".charCodeAt(i252);
			if(no252 == null) {
				break;
			}
			var v252;
			switch(no252) {
			case 32:
				v252 = false;
				break;
			case 42:
				v252 = true;
				break;
			case 48:
				v252 = false;
				break;
			case 49:
				v252 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("***  ".charCodeAt(i252)));
			}
			switch(i252 - (l252 - 8)) {
			case 0:
				if(v252) {
					bs252 |= 128;
				} else {
					bs252 &= -129;
				}
				break;
			case 1:
				if(v252) {
					bs252 |= 64;
				} else {
					bs252 &= -65;
				}
				break;
			case 2:
				if(v252) {
					bs252 |= 32;
				} else {
					bs252 &= -33;
				}
				break;
			case 3:
				if(v252) {
					bs252 |= 16;
				} else {
					bs252 &= -17;
				}
				break;
			case 4:
				if(v252) {
					bs252 |= 8;
				} else {
					bs252 &= -9;
				}
				break;
			case 5:
				if(v252) {
					bs252 |= 4;
				} else {
					bs252 &= -5;
				}
				break;
			case 6:
				if(v252) {
					bs252 |= 2;
				} else {
					bs252 &= -3;
				}
				break;
			case 7:
				if(v252) {
					bs252 |= 1;
				} else {
					bs252 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs252;
		var this254 = 0;
		var bs253 = this254;
		var l253 = "*  * ".length;
		var _g1253 = 0;
		var _g353 = l253;
		while(_g1253 < _g353) {
			var i253 = _g1253++;
			var no253 = "*  * ".charCodeAt(i253);
			if(no253 == null) {
				break;
			}
			var v253;
			switch(no253) {
			case 32:
				v253 = false;
				break;
			case 42:
				v253 = true;
				break;
			case 48:
				v253 = false;
				break;
			case 49:
				v253 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i253)));
			}
			switch(i253 - (l253 - 8)) {
			case 0:
				if(v253) {
					bs253 |= 128;
				} else {
					bs253 &= -129;
				}
				break;
			case 1:
				if(v253) {
					bs253 |= 64;
				} else {
					bs253 &= -65;
				}
				break;
			case 2:
				if(v253) {
					bs253 |= 32;
				} else {
					bs253 &= -33;
				}
				break;
			case 3:
				if(v253) {
					bs253 |= 16;
				} else {
					bs253 &= -17;
				}
				break;
			case 4:
				if(v253) {
					bs253 |= 8;
				} else {
					bs253 &= -9;
				}
				break;
			case 5:
				if(v253) {
					bs253 |= 4;
				} else {
					bs253 &= -5;
				}
				break;
			case 6:
				if(v253) {
					bs253 |= 2;
				} else {
					bs253 &= -3;
				}
				break;
			case 7:
				if(v253) {
					bs253 |= 1;
				} else {
					bs253 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs253;
		var this255 = 0;
		var bs254 = this255;
		var l254 = "*   *".length;
		var _g1254 = 0;
		var _g354 = l254;
		while(_g1254 < _g354) {
			var i254 = _g1254++;
			var no254 = "*   *".charCodeAt(i254);
			if(no254 == null) {
				break;
			}
			var v254;
			switch(no254) {
			case 32:
				v254 = false;
				break;
			case 42:
				v254 = true;
				break;
			case 48:
				v254 = false;
				break;
			case 49:
				v254 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i254)));
			}
			switch(i254 - (l254 - 8)) {
			case 0:
				if(v254) {
					bs254 |= 128;
				} else {
					bs254 &= -129;
				}
				break;
			case 1:
				if(v254) {
					bs254 |= 64;
				} else {
					bs254 &= -65;
				}
				break;
			case 2:
				if(v254) {
					bs254 |= 32;
				} else {
					bs254 &= -33;
				}
				break;
			case 3:
				if(v254) {
					bs254 |= 16;
				} else {
					bs254 &= -17;
				}
				break;
			case 4:
				if(v254) {
					bs254 |= 8;
				} else {
					bs254 &= -9;
				}
				break;
			case 5:
				if(v254) {
					bs254 |= 4;
				} else {
					bs254 &= -5;
				}
				break;
			case 6:
				if(v254) {
					bs254 |= 2;
				} else {
					bs254 &= -3;
				}
				break;
			case 7:
				if(v254) {
					bs254 |= 1;
				} else {
					bs254 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs254;
		var this256 = 0;
		var bs255 = this256;
		var l255 = "*   *".length;
		var _g1255 = 0;
		var _g355 = l255;
		while(_g1255 < _g355) {
			var i255 = _g1255++;
			var no255 = "*   *".charCodeAt(i255);
			if(no255 == null) {
				break;
			}
			var v255;
			switch(no255) {
			case 32:
				v255 = false;
				break;
			case 42:
				v255 = true;
				break;
			case 48:
				v255 = false;
				break;
			case 49:
				v255 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i255)));
			}
			switch(i255 - (l255 - 8)) {
			case 0:
				if(v255) {
					bs255 |= 128;
				} else {
					bs255 &= -129;
				}
				break;
			case 1:
				if(v255) {
					bs255 |= 64;
				} else {
					bs255 &= -65;
				}
				break;
			case 2:
				if(v255) {
					bs255 |= 32;
				} else {
					bs255 &= -33;
				}
				break;
			case 3:
				if(v255) {
					bs255 |= 16;
				} else {
					bs255 &= -17;
				}
				break;
			case 4:
				if(v255) {
					bs255 |= 8;
				} else {
					bs255 &= -9;
				}
				break;
			case 5:
				if(v255) {
					bs255 |= 4;
				} else {
					bs255 &= -5;
				}
				break;
			case 6:
				if(v255) {
					bs255 |= 2;
				} else {
					bs255 &= -3;
				}
				break;
			case 7:
				if(v255) {
					bs255 |= 1;
				} else {
					bs255 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs255;
		var this257 = 0;
		var bs256 = this257;
		var l256 = "*   *".length;
		var _g1256 = 0;
		var _g356 = l256;
		while(_g1256 < _g356) {
			var i256 = _g1256++;
			var no256 = "*   *".charCodeAt(i256);
			if(no256 == null) {
				break;
			}
			var v256;
			switch(no256) {
			case 32:
				v256 = false;
				break;
			case 42:
				v256 = true;
				break;
			case 48:
				v256 = false;
				break;
			case 49:
				v256 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i256)));
			}
			switch(i256 - (l256 - 8)) {
			case 0:
				if(v256) {
					bs256 |= 128;
				} else {
					bs256 &= -129;
				}
				break;
			case 1:
				if(v256) {
					bs256 |= 64;
				} else {
					bs256 &= -65;
				}
				break;
			case 2:
				if(v256) {
					bs256 |= 32;
				} else {
					bs256 &= -33;
				}
				break;
			case 3:
				if(v256) {
					bs256 |= 16;
				} else {
					bs256 &= -17;
				}
				break;
			case 4:
				if(v256) {
					bs256 |= 8;
				} else {
					bs256 &= -9;
				}
				break;
			case 5:
				if(v256) {
					bs256 |= 4;
				} else {
					bs256 &= -5;
				}
				break;
			case 6:
				if(v256) {
					bs256 |= 2;
				} else {
					bs256 &= -3;
				}
				break;
			case 7:
				if(v256) {
					bs256 |= 1;
				} else {
					bs256 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs256;
		var this258 = 0;
		var bs257 = this258;
		var l257 = "*  * ".length;
		var _g1257 = 0;
		var _g357 = l257;
		while(_g1257 < _g357) {
			var i257 = _g1257++;
			var no257 = "*  * ".charCodeAt(i257);
			if(no257 == null) {
				break;
			}
			var v257;
			switch(no257) {
			case 32:
				v257 = false;
				break;
			case 42:
				v257 = true;
				break;
			case 48:
				v257 = false;
				break;
			case 49:
				v257 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i257)));
			}
			switch(i257 - (l257 - 8)) {
			case 0:
				if(v257) {
					bs257 |= 128;
				} else {
					bs257 &= -129;
				}
				break;
			case 1:
				if(v257) {
					bs257 |= 64;
				} else {
					bs257 &= -65;
				}
				break;
			case 2:
				if(v257) {
					bs257 |= 32;
				} else {
					bs257 &= -33;
				}
				break;
			case 3:
				if(v257) {
					bs257 |= 16;
				} else {
					bs257 &= -17;
				}
				break;
			case 4:
				if(v257) {
					bs257 |= 8;
				} else {
					bs257 &= -9;
				}
				break;
			case 5:
				if(v257) {
					bs257 |= 4;
				} else {
					bs257 &= -5;
				}
				break;
			case 6:
				if(v257) {
					bs257 |= 2;
				} else {
					bs257 &= -3;
				}
				break;
			case 7:
				if(v257) {
					bs257 |= 1;
				} else {
					bs257 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs257;
		var this259 = 0;
		var bs258 = this259;
		var l258 = "***  ".length;
		var _g1258 = 0;
		var _g358 = l258;
		while(_g1258 < _g358) {
			var i258 = _g1258++;
			var no258 = "***  ".charCodeAt(i258);
			if(no258 == null) {
				break;
			}
			var v258;
			switch(no258) {
			case 32:
				v258 = false;
				break;
			case 42:
				v258 = true;
				break;
			case 48:
				v258 = false;
				break;
			case 49:
				v258 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("***  ".charCodeAt(i258)));
			}
			switch(i258 - (l258 - 8)) {
			case 0:
				if(v258) {
					bs258 |= 128;
				} else {
					bs258 &= -129;
				}
				break;
			case 1:
				if(v258) {
					bs258 |= 64;
				} else {
					bs258 &= -65;
				}
				break;
			case 2:
				if(v258) {
					bs258 |= 32;
				} else {
					bs258 &= -33;
				}
				break;
			case 3:
				if(v258) {
					bs258 |= 16;
				} else {
					bs258 &= -17;
				}
				break;
			case 4:
				if(v258) {
					bs258 |= 8;
				} else {
					bs258 &= -9;
				}
				break;
			case 5:
				if(v258) {
					bs258 |= 4;
				} else {
					bs258 &= -5;
				}
				break;
			case 6:
				if(v258) {
					bs258 |= 2;
				} else {
					bs258 &= -3;
				}
				break;
			case 7:
				if(v258) {
					bs258 |= 1;
				} else {
					bs258 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs258;
		break;
	case 69:
		var this260 = 0;
		var bs259 = this260;
		var l259 = "*****".length;
		var _g1259 = 0;
		var _g359 = l259;
		while(_g1259 < _g359) {
			var i259 = _g1259++;
			var no259 = "*****".charCodeAt(i259);
			if(no259 == null) {
				break;
			}
			var v259;
			switch(no259) {
			case 32:
				v259 = false;
				break;
			case 42:
				v259 = true;
				break;
			case 48:
				v259 = false;
				break;
			case 49:
				v259 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i259)));
			}
			switch(i259 - (l259 - 8)) {
			case 0:
				if(v259) {
					bs259 |= 128;
				} else {
					bs259 &= -129;
				}
				break;
			case 1:
				if(v259) {
					bs259 |= 64;
				} else {
					bs259 &= -65;
				}
				break;
			case 2:
				if(v259) {
					bs259 |= 32;
				} else {
					bs259 &= -33;
				}
				break;
			case 3:
				if(v259) {
					bs259 |= 16;
				} else {
					bs259 &= -17;
				}
				break;
			case 4:
				if(v259) {
					bs259 |= 8;
				} else {
					bs259 &= -9;
				}
				break;
			case 5:
				if(v259) {
					bs259 |= 4;
				} else {
					bs259 &= -5;
				}
				break;
			case 6:
				if(v259) {
					bs259 |= 2;
				} else {
					bs259 &= -3;
				}
				break;
			case 7:
				if(v259) {
					bs259 |= 1;
				} else {
					bs259 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs259;
		var this261 = 0;
		var bs260 = this261;
		var l260 = "*    ".length;
		var _g1260 = 0;
		var _g360 = l260;
		while(_g1260 < _g360) {
			var i260 = _g1260++;
			var no260 = "*    ".charCodeAt(i260);
			if(no260 == null) {
				break;
			}
			var v260;
			switch(no260) {
			case 32:
				v260 = false;
				break;
			case 42:
				v260 = true;
				break;
			case 48:
				v260 = false;
				break;
			case 49:
				v260 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i260)));
			}
			switch(i260 - (l260 - 8)) {
			case 0:
				if(v260) {
					bs260 |= 128;
				} else {
					bs260 &= -129;
				}
				break;
			case 1:
				if(v260) {
					bs260 |= 64;
				} else {
					bs260 &= -65;
				}
				break;
			case 2:
				if(v260) {
					bs260 |= 32;
				} else {
					bs260 &= -33;
				}
				break;
			case 3:
				if(v260) {
					bs260 |= 16;
				} else {
					bs260 &= -17;
				}
				break;
			case 4:
				if(v260) {
					bs260 |= 8;
				} else {
					bs260 &= -9;
				}
				break;
			case 5:
				if(v260) {
					bs260 |= 4;
				} else {
					bs260 &= -5;
				}
				break;
			case 6:
				if(v260) {
					bs260 |= 2;
				} else {
					bs260 &= -3;
				}
				break;
			case 7:
				if(v260) {
					bs260 |= 1;
				} else {
					bs260 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs260;
		var this262 = 0;
		var bs261 = this262;
		var l261 = "*    ".length;
		var _g1261 = 0;
		var _g361 = l261;
		while(_g1261 < _g361) {
			var i261 = _g1261++;
			var no261 = "*    ".charCodeAt(i261);
			if(no261 == null) {
				break;
			}
			var v261;
			switch(no261) {
			case 32:
				v261 = false;
				break;
			case 42:
				v261 = true;
				break;
			case 48:
				v261 = false;
				break;
			case 49:
				v261 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i261)));
			}
			switch(i261 - (l261 - 8)) {
			case 0:
				if(v261) {
					bs261 |= 128;
				} else {
					bs261 &= -129;
				}
				break;
			case 1:
				if(v261) {
					bs261 |= 64;
				} else {
					bs261 &= -65;
				}
				break;
			case 2:
				if(v261) {
					bs261 |= 32;
				} else {
					bs261 &= -33;
				}
				break;
			case 3:
				if(v261) {
					bs261 |= 16;
				} else {
					bs261 &= -17;
				}
				break;
			case 4:
				if(v261) {
					bs261 |= 8;
				} else {
					bs261 &= -9;
				}
				break;
			case 5:
				if(v261) {
					bs261 |= 4;
				} else {
					bs261 &= -5;
				}
				break;
			case 6:
				if(v261) {
					bs261 |= 2;
				} else {
					bs261 &= -3;
				}
				break;
			case 7:
				if(v261) {
					bs261 |= 1;
				} else {
					bs261 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs261;
		var this263 = 0;
		var bs262 = this263;
		var l262 = "**** ".length;
		var _g1262 = 0;
		var _g362 = l262;
		while(_g1262 < _g362) {
			var i262 = _g1262++;
			var no262 = "**** ".charCodeAt(i262);
			if(no262 == null) {
				break;
			}
			var v262;
			switch(no262) {
			case 32:
				v262 = false;
				break;
			case 42:
				v262 = true;
				break;
			case 48:
				v262 = false;
				break;
			case 49:
				v262 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i262)));
			}
			switch(i262 - (l262 - 8)) {
			case 0:
				if(v262) {
					bs262 |= 128;
				} else {
					bs262 &= -129;
				}
				break;
			case 1:
				if(v262) {
					bs262 |= 64;
				} else {
					bs262 &= -65;
				}
				break;
			case 2:
				if(v262) {
					bs262 |= 32;
				} else {
					bs262 &= -33;
				}
				break;
			case 3:
				if(v262) {
					bs262 |= 16;
				} else {
					bs262 &= -17;
				}
				break;
			case 4:
				if(v262) {
					bs262 |= 8;
				} else {
					bs262 &= -9;
				}
				break;
			case 5:
				if(v262) {
					bs262 |= 4;
				} else {
					bs262 &= -5;
				}
				break;
			case 6:
				if(v262) {
					bs262 |= 2;
				} else {
					bs262 &= -3;
				}
				break;
			case 7:
				if(v262) {
					bs262 |= 1;
				} else {
					bs262 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs262;
		var this264 = 0;
		var bs263 = this264;
		var l263 = "*    ".length;
		var _g1263 = 0;
		var _g363 = l263;
		while(_g1263 < _g363) {
			var i263 = _g1263++;
			var no263 = "*    ".charCodeAt(i263);
			if(no263 == null) {
				break;
			}
			var v263;
			switch(no263) {
			case 32:
				v263 = false;
				break;
			case 42:
				v263 = true;
				break;
			case 48:
				v263 = false;
				break;
			case 49:
				v263 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i263)));
			}
			switch(i263 - (l263 - 8)) {
			case 0:
				if(v263) {
					bs263 |= 128;
				} else {
					bs263 &= -129;
				}
				break;
			case 1:
				if(v263) {
					bs263 |= 64;
				} else {
					bs263 &= -65;
				}
				break;
			case 2:
				if(v263) {
					bs263 |= 32;
				} else {
					bs263 &= -33;
				}
				break;
			case 3:
				if(v263) {
					bs263 |= 16;
				} else {
					bs263 &= -17;
				}
				break;
			case 4:
				if(v263) {
					bs263 |= 8;
				} else {
					bs263 &= -9;
				}
				break;
			case 5:
				if(v263) {
					bs263 |= 4;
				} else {
					bs263 &= -5;
				}
				break;
			case 6:
				if(v263) {
					bs263 |= 2;
				} else {
					bs263 &= -3;
				}
				break;
			case 7:
				if(v263) {
					bs263 |= 1;
				} else {
					bs263 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs263;
		var this265 = 0;
		var bs264 = this265;
		var l264 = "*    ".length;
		var _g1264 = 0;
		var _g364 = l264;
		while(_g1264 < _g364) {
			var i264 = _g1264++;
			var no264 = "*    ".charCodeAt(i264);
			if(no264 == null) {
				break;
			}
			var v264;
			switch(no264) {
			case 32:
				v264 = false;
				break;
			case 42:
				v264 = true;
				break;
			case 48:
				v264 = false;
				break;
			case 49:
				v264 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i264)));
			}
			switch(i264 - (l264 - 8)) {
			case 0:
				if(v264) {
					bs264 |= 128;
				} else {
					bs264 &= -129;
				}
				break;
			case 1:
				if(v264) {
					bs264 |= 64;
				} else {
					bs264 &= -65;
				}
				break;
			case 2:
				if(v264) {
					bs264 |= 32;
				} else {
					bs264 &= -33;
				}
				break;
			case 3:
				if(v264) {
					bs264 |= 16;
				} else {
					bs264 &= -17;
				}
				break;
			case 4:
				if(v264) {
					bs264 |= 8;
				} else {
					bs264 &= -9;
				}
				break;
			case 5:
				if(v264) {
					bs264 |= 4;
				} else {
					bs264 &= -5;
				}
				break;
			case 6:
				if(v264) {
					bs264 |= 2;
				} else {
					bs264 &= -3;
				}
				break;
			case 7:
				if(v264) {
					bs264 |= 1;
				} else {
					bs264 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs264;
		var this266 = 0;
		var bs265 = this266;
		var l265 = "*****".length;
		var _g1265 = 0;
		var _g365 = l265;
		while(_g1265 < _g365) {
			var i265 = _g1265++;
			var no265 = "*****".charCodeAt(i265);
			if(no265 == null) {
				break;
			}
			var v265;
			switch(no265) {
			case 32:
				v265 = false;
				break;
			case 42:
				v265 = true;
				break;
			case 48:
				v265 = false;
				break;
			case 49:
				v265 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i265)));
			}
			switch(i265 - (l265 - 8)) {
			case 0:
				if(v265) {
					bs265 |= 128;
				} else {
					bs265 &= -129;
				}
				break;
			case 1:
				if(v265) {
					bs265 |= 64;
				} else {
					bs265 &= -65;
				}
				break;
			case 2:
				if(v265) {
					bs265 |= 32;
				} else {
					bs265 &= -33;
				}
				break;
			case 3:
				if(v265) {
					bs265 |= 16;
				} else {
					bs265 &= -17;
				}
				break;
			case 4:
				if(v265) {
					bs265 |= 8;
				} else {
					bs265 &= -9;
				}
				break;
			case 5:
				if(v265) {
					bs265 |= 4;
				} else {
					bs265 &= -5;
				}
				break;
			case 6:
				if(v265) {
					bs265 |= 2;
				} else {
					bs265 &= -3;
				}
				break;
			case 7:
				if(v265) {
					bs265 |= 1;
				} else {
					bs265 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs265;
		break;
	case 70:
		var this267 = 0;
		var bs266 = this267;
		var l266 = "*****".length;
		var _g1266 = 0;
		var _g366 = l266;
		while(_g1266 < _g366) {
			var i266 = _g1266++;
			var no266 = "*****".charCodeAt(i266);
			if(no266 == null) {
				break;
			}
			var v266;
			switch(no266) {
			case 32:
				v266 = false;
				break;
			case 42:
				v266 = true;
				break;
			case 48:
				v266 = false;
				break;
			case 49:
				v266 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i266)));
			}
			switch(i266 - (l266 - 8)) {
			case 0:
				if(v266) {
					bs266 |= 128;
				} else {
					bs266 &= -129;
				}
				break;
			case 1:
				if(v266) {
					bs266 |= 64;
				} else {
					bs266 &= -65;
				}
				break;
			case 2:
				if(v266) {
					bs266 |= 32;
				} else {
					bs266 &= -33;
				}
				break;
			case 3:
				if(v266) {
					bs266 |= 16;
				} else {
					bs266 &= -17;
				}
				break;
			case 4:
				if(v266) {
					bs266 |= 8;
				} else {
					bs266 &= -9;
				}
				break;
			case 5:
				if(v266) {
					bs266 |= 4;
				} else {
					bs266 &= -5;
				}
				break;
			case 6:
				if(v266) {
					bs266 |= 2;
				} else {
					bs266 &= -3;
				}
				break;
			case 7:
				if(v266) {
					bs266 |= 1;
				} else {
					bs266 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs266;
		var this268 = 0;
		var bs267 = this268;
		var l267 = "*    ".length;
		var _g1267 = 0;
		var _g367 = l267;
		while(_g1267 < _g367) {
			var i267 = _g1267++;
			var no267 = "*    ".charCodeAt(i267);
			if(no267 == null) {
				break;
			}
			var v267;
			switch(no267) {
			case 32:
				v267 = false;
				break;
			case 42:
				v267 = true;
				break;
			case 48:
				v267 = false;
				break;
			case 49:
				v267 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i267)));
			}
			switch(i267 - (l267 - 8)) {
			case 0:
				if(v267) {
					bs267 |= 128;
				} else {
					bs267 &= -129;
				}
				break;
			case 1:
				if(v267) {
					bs267 |= 64;
				} else {
					bs267 &= -65;
				}
				break;
			case 2:
				if(v267) {
					bs267 |= 32;
				} else {
					bs267 &= -33;
				}
				break;
			case 3:
				if(v267) {
					bs267 |= 16;
				} else {
					bs267 &= -17;
				}
				break;
			case 4:
				if(v267) {
					bs267 |= 8;
				} else {
					bs267 &= -9;
				}
				break;
			case 5:
				if(v267) {
					bs267 |= 4;
				} else {
					bs267 &= -5;
				}
				break;
			case 6:
				if(v267) {
					bs267 |= 2;
				} else {
					bs267 &= -3;
				}
				break;
			case 7:
				if(v267) {
					bs267 |= 1;
				} else {
					bs267 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs267;
		var this269 = 0;
		var bs268 = this269;
		var l268 = "*    ".length;
		var _g1268 = 0;
		var _g368 = l268;
		while(_g1268 < _g368) {
			var i268 = _g1268++;
			var no268 = "*    ".charCodeAt(i268);
			if(no268 == null) {
				break;
			}
			var v268;
			switch(no268) {
			case 32:
				v268 = false;
				break;
			case 42:
				v268 = true;
				break;
			case 48:
				v268 = false;
				break;
			case 49:
				v268 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i268)));
			}
			switch(i268 - (l268 - 8)) {
			case 0:
				if(v268) {
					bs268 |= 128;
				} else {
					bs268 &= -129;
				}
				break;
			case 1:
				if(v268) {
					bs268 |= 64;
				} else {
					bs268 &= -65;
				}
				break;
			case 2:
				if(v268) {
					bs268 |= 32;
				} else {
					bs268 &= -33;
				}
				break;
			case 3:
				if(v268) {
					bs268 |= 16;
				} else {
					bs268 &= -17;
				}
				break;
			case 4:
				if(v268) {
					bs268 |= 8;
				} else {
					bs268 &= -9;
				}
				break;
			case 5:
				if(v268) {
					bs268 |= 4;
				} else {
					bs268 &= -5;
				}
				break;
			case 6:
				if(v268) {
					bs268 |= 2;
				} else {
					bs268 &= -3;
				}
				break;
			case 7:
				if(v268) {
					bs268 |= 1;
				} else {
					bs268 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs268;
		var this270 = 0;
		var bs269 = this270;
		var l269 = "**** ".length;
		var _g1269 = 0;
		var _g369 = l269;
		while(_g1269 < _g369) {
			var i269 = _g1269++;
			var no269 = "**** ".charCodeAt(i269);
			if(no269 == null) {
				break;
			}
			var v269;
			switch(no269) {
			case 32:
				v269 = false;
				break;
			case 42:
				v269 = true;
				break;
			case 48:
				v269 = false;
				break;
			case 49:
				v269 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i269)));
			}
			switch(i269 - (l269 - 8)) {
			case 0:
				if(v269) {
					bs269 |= 128;
				} else {
					bs269 &= -129;
				}
				break;
			case 1:
				if(v269) {
					bs269 |= 64;
				} else {
					bs269 &= -65;
				}
				break;
			case 2:
				if(v269) {
					bs269 |= 32;
				} else {
					bs269 &= -33;
				}
				break;
			case 3:
				if(v269) {
					bs269 |= 16;
				} else {
					bs269 &= -17;
				}
				break;
			case 4:
				if(v269) {
					bs269 |= 8;
				} else {
					bs269 &= -9;
				}
				break;
			case 5:
				if(v269) {
					bs269 |= 4;
				} else {
					bs269 &= -5;
				}
				break;
			case 6:
				if(v269) {
					bs269 |= 2;
				} else {
					bs269 &= -3;
				}
				break;
			case 7:
				if(v269) {
					bs269 |= 1;
				} else {
					bs269 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs269;
		var this271 = 0;
		var bs270 = this271;
		var l270 = "*    ".length;
		var _g1270 = 0;
		var _g370 = l270;
		while(_g1270 < _g370) {
			var i270 = _g1270++;
			var no270 = "*    ".charCodeAt(i270);
			if(no270 == null) {
				break;
			}
			var v270;
			switch(no270) {
			case 32:
				v270 = false;
				break;
			case 42:
				v270 = true;
				break;
			case 48:
				v270 = false;
				break;
			case 49:
				v270 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i270)));
			}
			switch(i270 - (l270 - 8)) {
			case 0:
				if(v270) {
					bs270 |= 128;
				} else {
					bs270 &= -129;
				}
				break;
			case 1:
				if(v270) {
					bs270 |= 64;
				} else {
					bs270 &= -65;
				}
				break;
			case 2:
				if(v270) {
					bs270 |= 32;
				} else {
					bs270 &= -33;
				}
				break;
			case 3:
				if(v270) {
					bs270 |= 16;
				} else {
					bs270 &= -17;
				}
				break;
			case 4:
				if(v270) {
					bs270 |= 8;
				} else {
					bs270 &= -9;
				}
				break;
			case 5:
				if(v270) {
					bs270 |= 4;
				} else {
					bs270 &= -5;
				}
				break;
			case 6:
				if(v270) {
					bs270 |= 2;
				} else {
					bs270 &= -3;
				}
				break;
			case 7:
				if(v270) {
					bs270 |= 1;
				} else {
					bs270 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs270;
		var this272 = 0;
		var bs271 = this272;
		var l271 = "*    ".length;
		var _g1271 = 0;
		var _g371 = l271;
		while(_g1271 < _g371) {
			var i271 = _g1271++;
			var no271 = "*    ".charCodeAt(i271);
			if(no271 == null) {
				break;
			}
			var v271;
			switch(no271) {
			case 32:
				v271 = false;
				break;
			case 42:
				v271 = true;
				break;
			case 48:
				v271 = false;
				break;
			case 49:
				v271 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i271)));
			}
			switch(i271 - (l271 - 8)) {
			case 0:
				if(v271) {
					bs271 |= 128;
				} else {
					bs271 &= -129;
				}
				break;
			case 1:
				if(v271) {
					bs271 |= 64;
				} else {
					bs271 &= -65;
				}
				break;
			case 2:
				if(v271) {
					bs271 |= 32;
				} else {
					bs271 &= -33;
				}
				break;
			case 3:
				if(v271) {
					bs271 |= 16;
				} else {
					bs271 &= -17;
				}
				break;
			case 4:
				if(v271) {
					bs271 |= 8;
				} else {
					bs271 &= -9;
				}
				break;
			case 5:
				if(v271) {
					bs271 |= 4;
				} else {
					bs271 &= -5;
				}
				break;
			case 6:
				if(v271) {
					bs271 |= 2;
				} else {
					bs271 &= -3;
				}
				break;
			case 7:
				if(v271) {
					bs271 |= 1;
				} else {
					bs271 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs271;
		var this273 = 0;
		var bs272 = this273;
		var l272 = "*    ".length;
		var _g1272 = 0;
		var _g372 = l272;
		while(_g1272 < _g372) {
			var i272 = _g1272++;
			var no272 = "*    ".charCodeAt(i272);
			if(no272 == null) {
				break;
			}
			var v272;
			switch(no272) {
			case 32:
				v272 = false;
				break;
			case 42:
				v272 = true;
				break;
			case 48:
				v272 = false;
				break;
			case 49:
				v272 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i272)));
			}
			switch(i272 - (l272 - 8)) {
			case 0:
				if(v272) {
					bs272 |= 128;
				} else {
					bs272 &= -129;
				}
				break;
			case 1:
				if(v272) {
					bs272 |= 64;
				} else {
					bs272 &= -65;
				}
				break;
			case 2:
				if(v272) {
					bs272 |= 32;
				} else {
					bs272 &= -33;
				}
				break;
			case 3:
				if(v272) {
					bs272 |= 16;
				} else {
					bs272 &= -17;
				}
				break;
			case 4:
				if(v272) {
					bs272 |= 8;
				} else {
					bs272 &= -9;
				}
				break;
			case 5:
				if(v272) {
					bs272 |= 4;
				} else {
					bs272 &= -5;
				}
				break;
			case 6:
				if(v272) {
					bs272 |= 2;
				} else {
					bs272 &= -3;
				}
				break;
			case 7:
				if(v272) {
					bs272 |= 1;
				} else {
					bs272 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs272;
		break;
	case 71:
		var this274 = 0;
		var bs273 = this274;
		var l273 = " *** ".length;
		var _g1273 = 0;
		var _g373 = l273;
		while(_g1273 < _g373) {
			var i273 = _g1273++;
			var no273 = " *** ".charCodeAt(i273);
			if(no273 == null) {
				break;
			}
			var v273;
			switch(no273) {
			case 32:
				v273 = false;
				break;
			case 42:
				v273 = true;
				break;
			case 48:
				v273 = false;
				break;
			case 49:
				v273 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i273)));
			}
			switch(i273 - (l273 - 8)) {
			case 0:
				if(v273) {
					bs273 |= 128;
				} else {
					bs273 &= -129;
				}
				break;
			case 1:
				if(v273) {
					bs273 |= 64;
				} else {
					bs273 &= -65;
				}
				break;
			case 2:
				if(v273) {
					bs273 |= 32;
				} else {
					bs273 &= -33;
				}
				break;
			case 3:
				if(v273) {
					bs273 |= 16;
				} else {
					bs273 &= -17;
				}
				break;
			case 4:
				if(v273) {
					bs273 |= 8;
				} else {
					bs273 &= -9;
				}
				break;
			case 5:
				if(v273) {
					bs273 |= 4;
				} else {
					bs273 &= -5;
				}
				break;
			case 6:
				if(v273) {
					bs273 |= 2;
				} else {
					bs273 &= -3;
				}
				break;
			case 7:
				if(v273) {
					bs273 |= 1;
				} else {
					bs273 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs273;
		var this275 = 0;
		var bs274 = this275;
		var l274 = "*   *".length;
		var _g1274 = 0;
		var _g374 = l274;
		while(_g1274 < _g374) {
			var i274 = _g1274++;
			var no274 = "*   *".charCodeAt(i274);
			if(no274 == null) {
				break;
			}
			var v274;
			switch(no274) {
			case 32:
				v274 = false;
				break;
			case 42:
				v274 = true;
				break;
			case 48:
				v274 = false;
				break;
			case 49:
				v274 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i274)));
			}
			switch(i274 - (l274 - 8)) {
			case 0:
				if(v274) {
					bs274 |= 128;
				} else {
					bs274 &= -129;
				}
				break;
			case 1:
				if(v274) {
					bs274 |= 64;
				} else {
					bs274 &= -65;
				}
				break;
			case 2:
				if(v274) {
					bs274 |= 32;
				} else {
					bs274 &= -33;
				}
				break;
			case 3:
				if(v274) {
					bs274 |= 16;
				} else {
					bs274 &= -17;
				}
				break;
			case 4:
				if(v274) {
					bs274 |= 8;
				} else {
					bs274 &= -9;
				}
				break;
			case 5:
				if(v274) {
					bs274 |= 4;
				} else {
					bs274 &= -5;
				}
				break;
			case 6:
				if(v274) {
					bs274 |= 2;
				} else {
					bs274 &= -3;
				}
				break;
			case 7:
				if(v274) {
					bs274 |= 1;
				} else {
					bs274 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs274;
		var this276 = 0;
		var bs275 = this276;
		var l275 = "*    ".length;
		var _g1275 = 0;
		var _g375 = l275;
		while(_g1275 < _g375) {
			var i275 = _g1275++;
			var no275 = "*    ".charCodeAt(i275);
			if(no275 == null) {
				break;
			}
			var v275;
			switch(no275) {
			case 32:
				v275 = false;
				break;
			case 42:
				v275 = true;
				break;
			case 48:
				v275 = false;
				break;
			case 49:
				v275 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i275)));
			}
			switch(i275 - (l275 - 8)) {
			case 0:
				if(v275) {
					bs275 |= 128;
				} else {
					bs275 &= -129;
				}
				break;
			case 1:
				if(v275) {
					bs275 |= 64;
				} else {
					bs275 &= -65;
				}
				break;
			case 2:
				if(v275) {
					bs275 |= 32;
				} else {
					bs275 &= -33;
				}
				break;
			case 3:
				if(v275) {
					bs275 |= 16;
				} else {
					bs275 &= -17;
				}
				break;
			case 4:
				if(v275) {
					bs275 |= 8;
				} else {
					bs275 &= -9;
				}
				break;
			case 5:
				if(v275) {
					bs275 |= 4;
				} else {
					bs275 &= -5;
				}
				break;
			case 6:
				if(v275) {
					bs275 |= 2;
				} else {
					bs275 &= -3;
				}
				break;
			case 7:
				if(v275) {
					bs275 |= 1;
				} else {
					bs275 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs275;
		var this277 = 0;
		var bs276 = this277;
		var l276 = "* ***".length;
		var _g1276 = 0;
		var _g376 = l276;
		while(_g1276 < _g376) {
			var i276 = _g1276++;
			var no276 = "* ***".charCodeAt(i276);
			if(no276 == null) {
				break;
			}
			var v276;
			switch(no276) {
			case 32:
				v276 = false;
				break;
			case 42:
				v276 = true;
				break;
			case 48:
				v276 = false;
				break;
			case 49:
				v276 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* ***".charCodeAt(i276)));
			}
			switch(i276 - (l276 - 8)) {
			case 0:
				if(v276) {
					bs276 |= 128;
				} else {
					bs276 &= -129;
				}
				break;
			case 1:
				if(v276) {
					bs276 |= 64;
				} else {
					bs276 &= -65;
				}
				break;
			case 2:
				if(v276) {
					bs276 |= 32;
				} else {
					bs276 &= -33;
				}
				break;
			case 3:
				if(v276) {
					bs276 |= 16;
				} else {
					bs276 &= -17;
				}
				break;
			case 4:
				if(v276) {
					bs276 |= 8;
				} else {
					bs276 &= -9;
				}
				break;
			case 5:
				if(v276) {
					bs276 |= 4;
				} else {
					bs276 &= -5;
				}
				break;
			case 6:
				if(v276) {
					bs276 |= 2;
				} else {
					bs276 &= -3;
				}
				break;
			case 7:
				if(v276) {
					bs276 |= 1;
				} else {
					bs276 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs276;
		var this278 = 0;
		var bs277 = this278;
		var l277 = "*   *".length;
		var _g1277 = 0;
		var _g377 = l277;
		while(_g1277 < _g377) {
			var i277 = _g1277++;
			var no277 = "*   *".charCodeAt(i277);
			if(no277 == null) {
				break;
			}
			var v277;
			switch(no277) {
			case 32:
				v277 = false;
				break;
			case 42:
				v277 = true;
				break;
			case 48:
				v277 = false;
				break;
			case 49:
				v277 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i277)));
			}
			switch(i277 - (l277 - 8)) {
			case 0:
				if(v277) {
					bs277 |= 128;
				} else {
					bs277 &= -129;
				}
				break;
			case 1:
				if(v277) {
					bs277 |= 64;
				} else {
					bs277 &= -65;
				}
				break;
			case 2:
				if(v277) {
					bs277 |= 32;
				} else {
					bs277 &= -33;
				}
				break;
			case 3:
				if(v277) {
					bs277 |= 16;
				} else {
					bs277 &= -17;
				}
				break;
			case 4:
				if(v277) {
					bs277 |= 8;
				} else {
					bs277 &= -9;
				}
				break;
			case 5:
				if(v277) {
					bs277 |= 4;
				} else {
					bs277 &= -5;
				}
				break;
			case 6:
				if(v277) {
					bs277 |= 2;
				} else {
					bs277 &= -3;
				}
				break;
			case 7:
				if(v277) {
					bs277 |= 1;
				} else {
					bs277 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs277;
		var this279 = 0;
		var bs278 = this279;
		var l278 = "*   *".length;
		var _g1278 = 0;
		var _g378 = l278;
		while(_g1278 < _g378) {
			var i278 = _g1278++;
			var no278 = "*   *".charCodeAt(i278);
			if(no278 == null) {
				break;
			}
			var v278;
			switch(no278) {
			case 32:
				v278 = false;
				break;
			case 42:
				v278 = true;
				break;
			case 48:
				v278 = false;
				break;
			case 49:
				v278 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i278)));
			}
			switch(i278 - (l278 - 8)) {
			case 0:
				if(v278) {
					bs278 |= 128;
				} else {
					bs278 &= -129;
				}
				break;
			case 1:
				if(v278) {
					bs278 |= 64;
				} else {
					bs278 &= -65;
				}
				break;
			case 2:
				if(v278) {
					bs278 |= 32;
				} else {
					bs278 &= -33;
				}
				break;
			case 3:
				if(v278) {
					bs278 |= 16;
				} else {
					bs278 &= -17;
				}
				break;
			case 4:
				if(v278) {
					bs278 |= 8;
				} else {
					bs278 &= -9;
				}
				break;
			case 5:
				if(v278) {
					bs278 |= 4;
				} else {
					bs278 &= -5;
				}
				break;
			case 6:
				if(v278) {
					bs278 |= 2;
				} else {
					bs278 &= -3;
				}
				break;
			case 7:
				if(v278) {
					bs278 |= 1;
				} else {
					bs278 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs278;
		var this280 = 0;
		var bs279 = this280;
		var l279 = " ****".length;
		var _g1279 = 0;
		var _g379 = l279;
		while(_g1279 < _g379) {
			var i279 = _g1279++;
			var no279 = " ****".charCodeAt(i279);
			if(no279 == null) {
				break;
			}
			var v279;
			switch(no279) {
			case 32:
				v279 = false;
				break;
			case 42:
				v279 = true;
				break;
			case 48:
				v279 = false;
				break;
			case 49:
				v279 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i279)));
			}
			switch(i279 - (l279 - 8)) {
			case 0:
				if(v279) {
					bs279 |= 128;
				} else {
					bs279 &= -129;
				}
				break;
			case 1:
				if(v279) {
					bs279 |= 64;
				} else {
					bs279 &= -65;
				}
				break;
			case 2:
				if(v279) {
					bs279 |= 32;
				} else {
					bs279 &= -33;
				}
				break;
			case 3:
				if(v279) {
					bs279 |= 16;
				} else {
					bs279 &= -17;
				}
				break;
			case 4:
				if(v279) {
					bs279 |= 8;
				} else {
					bs279 &= -9;
				}
				break;
			case 5:
				if(v279) {
					bs279 |= 4;
				} else {
					bs279 &= -5;
				}
				break;
			case 6:
				if(v279) {
					bs279 |= 2;
				} else {
					bs279 &= -3;
				}
				break;
			case 7:
				if(v279) {
					bs279 |= 1;
				} else {
					bs279 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs279;
		break;
	case 72:
		var this281 = 0;
		var bs280 = this281;
		var l280 = "*   *".length;
		var _g1280 = 0;
		var _g380 = l280;
		while(_g1280 < _g380) {
			var i280 = _g1280++;
			var no280 = "*   *".charCodeAt(i280);
			if(no280 == null) {
				break;
			}
			var v280;
			switch(no280) {
			case 32:
				v280 = false;
				break;
			case 42:
				v280 = true;
				break;
			case 48:
				v280 = false;
				break;
			case 49:
				v280 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i280)));
			}
			switch(i280 - (l280 - 8)) {
			case 0:
				if(v280) {
					bs280 |= 128;
				} else {
					bs280 &= -129;
				}
				break;
			case 1:
				if(v280) {
					bs280 |= 64;
				} else {
					bs280 &= -65;
				}
				break;
			case 2:
				if(v280) {
					bs280 |= 32;
				} else {
					bs280 &= -33;
				}
				break;
			case 3:
				if(v280) {
					bs280 |= 16;
				} else {
					bs280 &= -17;
				}
				break;
			case 4:
				if(v280) {
					bs280 |= 8;
				} else {
					bs280 &= -9;
				}
				break;
			case 5:
				if(v280) {
					bs280 |= 4;
				} else {
					bs280 &= -5;
				}
				break;
			case 6:
				if(v280) {
					bs280 |= 2;
				} else {
					bs280 &= -3;
				}
				break;
			case 7:
				if(v280) {
					bs280 |= 1;
				} else {
					bs280 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs280;
		var this282 = 0;
		var bs281 = this282;
		var l281 = "*   *".length;
		var _g1281 = 0;
		var _g381 = l281;
		while(_g1281 < _g381) {
			var i281 = _g1281++;
			var no281 = "*   *".charCodeAt(i281);
			if(no281 == null) {
				break;
			}
			var v281;
			switch(no281) {
			case 32:
				v281 = false;
				break;
			case 42:
				v281 = true;
				break;
			case 48:
				v281 = false;
				break;
			case 49:
				v281 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i281)));
			}
			switch(i281 - (l281 - 8)) {
			case 0:
				if(v281) {
					bs281 |= 128;
				} else {
					bs281 &= -129;
				}
				break;
			case 1:
				if(v281) {
					bs281 |= 64;
				} else {
					bs281 &= -65;
				}
				break;
			case 2:
				if(v281) {
					bs281 |= 32;
				} else {
					bs281 &= -33;
				}
				break;
			case 3:
				if(v281) {
					bs281 |= 16;
				} else {
					bs281 &= -17;
				}
				break;
			case 4:
				if(v281) {
					bs281 |= 8;
				} else {
					bs281 &= -9;
				}
				break;
			case 5:
				if(v281) {
					bs281 |= 4;
				} else {
					bs281 &= -5;
				}
				break;
			case 6:
				if(v281) {
					bs281 |= 2;
				} else {
					bs281 &= -3;
				}
				break;
			case 7:
				if(v281) {
					bs281 |= 1;
				} else {
					bs281 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs281;
		var this283 = 0;
		var bs282 = this283;
		var l282 = "*   *".length;
		var _g1282 = 0;
		var _g382 = l282;
		while(_g1282 < _g382) {
			var i282 = _g1282++;
			var no282 = "*   *".charCodeAt(i282);
			if(no282 == null) {
				break;
			}
			var v282;
			switch(no282) {
			case 32:
				v282 = false;
				break;
			case 42:
				v282 = true;
				break;
			case 48:
				v282 = false;
				break;
			case 49:
				v282 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i282)));
			}
			switch(i282 - (l282 - 8)) {
			case 0:
				if(v282) {
					bs282 |= 128;
				} else {
					bs282 &= -129;
				}
				break;
			case 1:
				if(v282) {
					bs282 |= 64;
				} else {
					bs282 &= -65;
				}
				break;
			case 2:
				if(v282) {
					bs282 |= 32;
				} else {
					bs282 &= -33;
				}
				break;
			case 3:
				if(v282) {
					bs282 |= 16;
				} else {
					bs282 &= -17;
				}
				break;
			case 4:
				if(v282) {
					bs282 |= 8;
				} else {
					bs282 &= -9;
				}
				break;
			case 5:
				if(v282) {
					bs282 |= 4;
				} else {
					bs282 &= -5;
				}
				break;
			case 6:
				if(v282) {
					bs282 |= 2;
				} else {
					bs282 &= -3;
				}
				break;
			case 7:
				if(v282) {
					bs282 |= 1;
				} else {
					bs282 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs282;
		var this284 = 0;
		var bs283 = this284;
		var l283 = "*****".length;
		var _g1283 = 0;
		var _g383 = l283;
		while(_g1283 < _g383) {
			var i283 = _g1283++;
			var no283 = "*****".charCodeAt(i283);
			if(no283 == null) {
				break;
			}
			var v283;
			switch(no283) {
			case 32:
				v283 = false;
				break;
			case 42:
				v283 = true;
				break;
			case 48:
				v283 = false;
				break;
			case 49:
				v283 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i283)));
			}
			switch(i283 - (l283 - 8)) {
			case 0:
				if(v283) {
					bs283 |= 128;
				} else {
					bs283 &= -129;
				}
				break;
			case 1:
				if(v283) {
					bs283 |= 64;
				} else {
					bs283 &= -65;
				}
				break;
			case 2:
				if(v283) {
					bs283 |= 32;
				} else {
					bs283 &= -33;
				}
				break;
			case 3:
				if(v283) {
					bs283 |= 16;
				} else {
					bs283 &= -17;
				}
				break;
			case 4:
				if(v283) {
					bs283 |= 8;
				} else {
					bs283 &= -9;
				}
				break;
			case 5:
				if(v283) {
					bs283 |= 4;
				} else {
					bs283 &= -5;
				}
				break;
			case 6:
				if(v283) {
					bs283 |= 2;
				} else {
					bs283 &= -3;
				}
				break;
			case 7:
				if(v283) {
					bs283 |= 1;
				} else {
					bs283 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs283;
		var this285 = 0;
		var bs284 = this285;
		var l284 = "*   *".length;
		var _g1284 = 0;
		var _g384 = l284;
		while(_g1284 < _g384) {
			var i284 = _g1284++;
			var no284 = "*   *".charCodeAt(i284);
			if(no284 == null) {
				break;
			}
			var v284;
			switch(no284) {
			case 32:
				v284 = false;
				break;
			case 42:
				v284 = true;
				break;
			case 48:
				v284 = false;
				break;
			case 49:
				v284 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i284)));
			}
			switch(i284 - (l284 - 8)) {
			case 0:
				if(v284) {
					bs284 |= 128;
				} else {
					bs284 &= -129;
				}
				break;
			case 1:
				if(v284) {
					bs284 |= 64;
				} else {
					bs284 &= -65;
				}
				break;
			case 2:
				if(v284) {
					bs284 |= 32;
				} else {
					bs284 &= -33;
				}
				break;
			case 3:
				if(v284) {
					bs284 |= 16;
				} else {
					bs284 &= -17;
				}
				break;
			case 4:
				if(v284) {
					bs284 |= 8;
				} else {
					bs284 &= -9;
				}
				break;
			case 5:
				if(v284) {
					bs284 |= 4;
				} else {
					bs284 &= -5;
				}
				break;
			case 6:
				if(v284) {
					bs284 |= 2;
				} else {
					bs284 &= -3;
				}
				break;
			case 7:
				if(v284) {
					bs284 |= 1;
				} else {
					bs284 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs284;
		var this286 = 0;
		var bs285 = this286;
		var l285 = "*   *".length;
		var _g1285 = 0;
		var _g385 = l285;
		while(_g1285 < _g385) {
			var i285 = _g1285++;
			var no285 = "*   *".charCodeAt(i285);
			if(no285 == null) {
				break;
			}
			var v285;
			switch(no285) {
			case 32:
				v285 = false;
				break;
			case 42:
				v285 = true;
				break;
			case 48:
				v285 = false;
				break;
			case 49:
				v285 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i285)));
			}
			switch(i285 - (l285 - 8)) {
			case 0:
				if(v285) {
					bs285 |= 128;
				} else {
					bs285 &= -129;
				}
				break;
			case 1:
				if(v285) {
					bs285 |= 64;
				} else {
					bs285 &= -65;
				}
				break;
			case 2:
				if(v285) {
					bs285 |= 32;
				} else {
					bs285 &= -33;
				}
				break;
			case 3:
				if(v285) {
					bs285 |= 16;
				} else {
					bs285 &= -17;
				}
				break;
			case 4:
				if(v285) {
					bs285 |= 8;
				} else {
					bs285 &= -9;
				}
				break;
			case 5:
				if(v285) {
					bs285 |= 4;
				} else {
					bs285 &= -5;
				}
				break;
			case 6:
				if(v285) {
					bs285 |= 2;
				} else {
					bs285 &= -3;
				}
				break;
			case 7:
				if(v285) {
					bs285 |= 1;
				} else {
					bs285 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs285;
		var this287 = 0;
		var bs286 = this287;
		var l286 = "*   *".length;
		var _g1286 = 0;
		var _g386 = l286;
		while(_g1286 < _g386) {
			var i286 = _g1286++;
			var no286 = "*   *".charCodeAt(i286);
			if(no286 == null) {
				break;
			}
			var v286;
			switch(no286) {
			case 32:
				v286 = false;
				break;
			case 42:
				v286 = true;
				break;
			case 48:
				v286 = false;
				break;
			case 49:
				v286 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i286)));
			}
			switch(i286 - (l286 - 8)) {
			case 0:
				if(v286) {
					bs286 |= 128;
				} else {
					bs286 &= -129;
				}
				break;
			case 1:
				if(v286) {
					bs286 |= 64;
				} else {
					bs286 &= -65;
				}
				break;
			case 2:
				if(v286) {
					bs286 |= 32;
				} else {
					bs286 &= -33;
				}
				break;
			case 3:
				if(v286) {
					bs286 |= 16;
				} else {
					bs286 &= -17;
				}
				break;
			case 4:
				if(v286) {
					bs286 |= 8;
				} else {
					bs286 &= -9;
				}
				break;
			case 5:
				if(v286) {
					bs286 |= 4;
				} else {
					bs286 &= -5;
				}
				break;
			case 6:
				if(v286) {
					bs286 |= 2;
				} else {
					bs286 &= -3;
				}
				break;
			case 7:
				if(v286) {
					bs286 |= 1;
				} else {
					bs286 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs286;
		break;
	case 73:
		var this288 = 0;
		var bs287 = this288;
		var l287 = " *** ".length;
		var _g1287 = 0;
		var _g387 = l287;
		while(_g1287 < _g387) {
			var i287 = _g1287++;
			var no287 = " *** ".charCodeAt(i287);
			if(no287 == null) {
				break;
			}
			var v287;
			switch(no287) {
			case 32:
				v287 = false;
				break;
			case 42:
				v287 = true;
				break;
			case 48:
				v287 = false;
				break;
			case 49:
				v287 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i287)));
			}
			switch(i287 - (l287 - 8)) {
			case 0:
				if(v287) {
					bs287 |= 128;
				} else {
					bs287 &= -129;
				}
				break;
			case 1:
				if(v287) {
					bs287 |= 64;
				} else {
					bs287 &= -65;
				}
				break;
			case 2:
				if(v287) {
					bs287 |= 32;
				} else {
					bs287 &= -33;
				}
				break;
			case 3:
				if(v287) {
					bs287 |= 16;
				} else {
					bs287 &= -17;
				}
				break;
			case 4:
				if(v287) {
					bs287 |= 8;
				} else {
					bs287 &= -9;
				}
				break;
			case 5:
				if(v287) {
					bs287 |= 4;
				} else {
					bs287 &= -5;
				}
				break;
			case 6:
				if(v287) {
					bs287 |= 2;
				} else {
					bs287 &= -3;
				}
				break;
			case 7:
				if(v287) {
					bs287 |= 1;
				} else {
					bs287 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs287;
		var this289 = 0;
		var bs288 = this289;
		var l288 = "  *  ".length;
		var _g1288 = 0;
		var _g388 = l288;
		while(_g1288 < _g388) {
			var i288 = _g1288++;
			var no288 = "  *  ".charCodeAt(i288);
			if(no288 == null) {
				break;
			}
			var v288;
			switch(no288) {
			case 32:
				v288 = false;
				break;
			case 42:
				v288 = true;
				break;
			case 48:
				v288 = false;
				break;
			case 49:
				v288 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i288)));
			}
			switch(i288 - (l288 - 8)) {
			case 0:
				if(v288) {
					bs288 |= 128;
				} else {
					bs288 &= -129;
				}
				break;
			case 1:
				if(v288) {
					bs288 |= 64;
				} else {
					bs288 &= -65;
				}
				break;
			case 2:
				if(v288) {
					bs288 |= 32;
				} else {
					bs288 &= -33;
				}
				break;
			case 3:
				if(v288) {
					bs288 |= 16;
				} else {
					bs288 &= -17;
				}
				break;
			case 4:
				if(v288) {
					bs288 |= 8;
				} else {
					bs288 &= -9;
				}
				break;
			case 5:
				if(v288) {
					bs288 |= 4;
				} else {
					bs288 &= -5;
				}
				break;
			case 6:
				if(v288) {
					bs288 |= 2;
				} else {
					bs288 &= -3;
				}
				break;
			case 7:
				if(v288) {
					bs288 |= 1;
				} else {
					bs288 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs288;
		var this290 = 0;
		var bs289 = this290;
		var l289 = "  *  ".length;
		var _g1289 = 0;
		var _g389 = l289;
		while(_g1289 < _g389) {
			var i289 = _g1289++;
			var no289 = "  *  ".charCodeAt(i289);
			if(no289 == null) {
				break;
			}
			var v289;
			switch(no289) {
			case 32:
				v289 = false;
				break;
			case 42:
				v289 = true;
				break;
			case 48:
				v289 = false;
				break;
			case 49:
				v289 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i289)));
			}
			switch(i289 - (l289 - 8)) {
			case 0:
				if(v289) {
					bs289 |= 128;
				} else {
					bs289 &= -129;
				}
				break;
			case 1:
				if(v289) {
					bs289 |= 64;
				} else {
					bs289 &= -65;
				}
				break;
			case 2:
				if(v289) {
					bs289 |= 32;
				} else {
					bs289 &= -33;
				}
				break;
			case 3:
				if(v289) {
					bs289 |= 16;
				} else {
					bs289 &= -17;
				}
				break;
			case 4:
				if(v289) {
					bs289 |= 8;
				} else {
					bs289 &= -9;
				}
				break;
			case 5:
				if(v289) {
					bs289 |= 4;
				} else {
					bs289 &= -5;
				}
				break;
			case 6:
				if(v289) {
					bs289 |= 2;
				} else {
					bs289 &= -3;
				}
				break;
			case 7:
				if(v289) {
					bs289 |= 1;
				} else {
					bs289 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs289;
		var this291 = 0;
		var bs290 = this291;
		var l290 = "  *  ".length;
		var _g1290 = 0;
		var _g390 = l290;
		while(_g1290 < _g390) {
			var i290 = _g1290++;
			var no290 = "  *  ".charCodeAt(i290);
			if(no290 == null) {
				break;
			}
			var v290;
			switch(no290) {
			case 32:
				v290 = false;
				break;
			case 42:
				v290 = true;
				break;
			case 48:
				v290 = false;
				break;
			case 49:
				v290 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i290)));
			}
			switch(i290 - (l290 - 8)) {
			case 0:
				if(v290) {
					bs290 |= 128;
				} else {
					bs290 &= -129;
				}
				break;
			case 1:
				if(v290) {
					bs290 |= 64;
				} else {
					bs290 &= -65;
				}
				break;
			case 2:
				if(v290) {
					bs290 |= 32;
				} else {
					bs290 &= -33;
				}
				break;
			case 3:
				if(v290) {
					bs290 |= 16;
				} else {
					bs290 &= -17;
				}
				break;
			case 4:
				if(v290) {
					bs290 |= 8;
				} else {
					bs290 &= -9;
				}
				break;
			case 5:
				if(v290) {
					bs290 |= 4;
				} else {
					bs290 &= -5;
				}
				break;
			case 6:
				if(v290) {
					bs290 |= 2;
				} else {
					bs290 &= -3;
				}
				break;
			case 7:
				if(v290) {
					bs290 |= 1;
				} else {
					bs290 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs290;
		var this292 = 0;
		var bs291 = this292;
		var l291 = "  *  ".length;
		var _g1291 = 0;
		var _g391 = l291;
		while(_g1291 < _g391) {
			var i291 = _g1291++;
			var no291 = "  *  ".charCodeAt(i291);
			if(no291 == null) {
				break;
			}
			var v291;
			switch(no291) {
			case 32:
				v291 = false;
				break;
			case 42:
				v291 = true;
				break;
			case 48:
				v291 = false;
				break;
			case 49:
				v291 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i291)));
			}
			switch(i291 - (l291 - 8)) {
			case 0:
				if(v291) {
					bs291 |= 128;
				} else {
					bs291 &= -129;
				}
				break;
			case 1:
				if(v291) {
					bs291 |= 64;
				} else {
					bs291 &= -65;
				}
				break;
			case 2:
				if(v291) {
					bs291 |= 32;
				} else {
					bs291 &= -33;
				}
				break;
			case 3:
				if(v291) {
					bs291 |= 16;
				} else {
					bs291 &= -17;
				}
				break;
			case 4:
				if(v291) {
					bs291 |= 8;
				} else {
					bs291 &= -9;
				}
				break;
			case 5:
				if(v291) {
					bs291 |= 4;
				} else {
					bs291 &= -5;
				}
				break;
			case 6:
				if(v291) {
					bs291 |= 2;
				} else {
					bs291 &= -3;
				}
				break;
			case 7:
				if(v291) {
					bs291 |= 1;
				} else {
					bs291 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs291;
		var this293 = 0;
		var bs292 = this293;
		var l292 = "  *  ".length;
		var _g1292 = 0;
		var _g392 = l292;
		while(_g1292 < _g392) {
			var i292 = _g1292++;
			var no292 = "  *  ".charCodeAt(i292);
			if(no292 == null) {
				break;
			}
			var v292;
			switch(no292) {
			case 32:
				v292 = false;
				break;
			case 42:
				v292 = true;
				break;
			case 48:
				v292 = false;
				break;
			case 49:
				v292 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i292)));
			}
			switch(i292 - (l292 - 8)) {
			case 0:
				if(v292) {
					bs292 |= 128;
				} else {
					bs292 &= -129;
				}
				break;
			case 1:
				if(v292) {
					bs292 |= 64;
				} else {
					bs292 &= -65;
				}
				break;
			case 2:
				if(v292) {
					bs292 |= 32;
				} else {
					bs292 &= -33;
				}
				break;
			case 3:
				if(v292) {
					bs292 |= 16;
				} else {
					bs292 &= -17;
				}
				break;
			case 4:
				if(v292) {
					bs292 |= 8;
				} else {
					bs292 &= -9;
				}
				break;
			case 5:
				if(v292) {
					bs292 |= 4;
				} else {
					bs292 &= -5;
				}
				break;
			case 6:
				if(v292) {
					bs292 |= 2;
				} else {
					bs292 &= -3;
				}
				break;
			case 7:
				if(v292) {
					bs292 |= 1;
				} else {
					bs292 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs292;
		var this294 = 0;
		var bs293 = this294;
		var l293 = " *** ".length;
		var _g1293 = 0;
		var _g393 = l293;
		while(_g1293 < _g393) {
			var i293 = _g1293++;
			var no293 = " *** ".charCodeAt(i293);
			if(no293 == null) {
				break;
			}
			var v293;
			switch(no293) {
			case 32:
				v293 = false;
				break;
			case 42:
				v293 = true;
				break;
			case 48:
				v293 = false;
				break;
			case 49:
				v293 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i293)));
			}
			switch(i293 - (l293 - 8)) {
			case 0:
				if(v293) {
					bs293 |= 128;
				} else {
					bs293 &= -129;
				}
				break;
			case 1:
				if(v293) {
					bs293 |= 64;
				} else {
					bs293 &= -65;
				}
				break;
			case 2:
				if(v293) {
					bs293 |= 32;
				} else {
					bs293 &= -33;
				}
				break;
			case 3:
				if(v293) {
					bs293 |= 16;
				} else {
					bs293 &= -17;
				}
				break;
			case 4:
				if(v293) {
					bs293 |= 8;
				} else {
					bs293 &= -9;
				}
				break;
			case 5:
				if(v293) {
					bs293 |= 4;
				} else {
					bs293 &= -5;
				}
				break;
			case 6:
				if(v293) {
					bs293 |= 2;
				} else {
					bs293 &= -3;
				}
				break;
			case 7:
				if(v293) {
					bs293 |= 1;
				} else {
					bs293 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs293;
		break;
	case 74:
		var this295 = 0;
		var bs294 = this295;
		var l294 = " ****".length;
		var _g1294 = 0;
		var _g394 = l294;
		while(_g1294 < _g394) {
			var i294 = _g1294++;
			var no294 = " ****".charCodeAt(i294);
			if(no294 == null) {
				break;
			}
			var v294;
			switch(no294) {
			case 32:
				v294 = false;
				break;
			case 42:
				v294 = true;
				break;
			case 48:
				v294 = false;
				break;
			case 49:
				v294 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i294)));
			}
			switch(i294 - (l294 - 8)) {
			case 0:
				if(v294) {
					bs294 |= 128;
				} else {
					bs294 &= -129;
				}
				break;
			case 1:
				if(v294) {
					bs294 |= 64;
				} else {
					bs294 &= -65;
				}
				break;
			case 2:
				if(v294) {
					bs294 |= 32;
				} else {
					bs294 &= -33;
				}
				break;
			case 3:
				if(v294) {
					bs294 |= 16;
				} else {
					bs294 &= -17;
				}
				break;
			case 4:
				if(v294) {
					bs294 |= 8;
				} else {
					bs294 &= -9;
				}
				break;
			case 5:
				if(v294) {
					bs294 |= 4;
				} else {
					bs294 &= -5;
				}
				break;
			case 6:
				if(v294) {
					bs294 |= 2;
				} else {
					bs294 &= -3;
				}
				break;
			case 7:
				if(v294) {
					bs294 |= 1;
				} else {
					bs294 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs294;
		var this296 = 0;
		var bs295 = this296;
		var l295 = "   * ".length;
		var _g1295 = 0;
		var _g395 = l295;
		while(_g1295 < _g395) {
			var i295 = _g1295++;
			var no295 = "   * ".charCodeAt(i295);
			if(no295 == null) {
				break;
			}
			var v295;
			switch(no295) {
			case 32:
				v295 = false;
				break;
			case 42:
				v295 = true;
				break;
			case 48:
				v295 = false;
				break;
			case 49:
				v295 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i295)));
			}
			switch(i295 - (l295 - 8)) {
			case 0:
				if(v295) {
					bs295 |= 128;
				} else {
					bs295 &= -129;
				}
				break;
			case 1:
				if(v295) {
					bs295 |= 64;
				} else {
					bs295 &= -65;
				}
				break;
			case 2:
				if(v295) {
					bs295 |= 32;
				} else {
					bs295 &= -33;
				}
				break;
			case 3:
				if(v295) {
					bs295 |= 16;
				} else {
					bs295 &= -17;
				}
				break;
			case 4:
				if(v295) {
					bs295 |= 8;
				} else {
					bs295 &= -9;
				}
				break;
			case 5:
				if(v295) {
					bs295 |= 4;
				} else {
					bs295 &= -5;
				}
				break;
			case 6:
				if(v295) {
					bs295 |= 2;
				} else {
					bs295 &= -3;
				}
				break;
			case 7:
				if(v295) {
					bs295 |= 1;
				} else {
					bs295 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs295;
		var this297 = 0;
		var bs296 = this297;
		var l296 = "   * ".length;
		var _g1296 = 0;
		var _g396 = l296;
		while(_g1296 < _g396) {
			var i296 = _g1296++;
			var no296 = "   * ".charCodeAt(i296);
			if(no296 == null) {
				break;
			}
			var v296;
			switch(no296) {
			case 32:
				v296 = false;
				break;
			case 42:
				v296 = true;
				break;
			case 48:
				v296 = false;
				break;
			case 49:
				v296 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i296)));
			}
			switch(i296 - (l296 - 8)) {
			case 0:
				if(v296) {
					bs296 |= 128;
				} else {
					bs296 &= -129;
				}
				break;
			case 1:
				if(v296) {
					bs296 |= 64;
				} else {
					bs296 &= -65;
				}
				break;
			case 2:
				if(v296) {
					bs296 |= 32;
				} else {
					bs296 &= -33;
				}
				break;
			case 3:
				if(v296) {
					bs296 |= 16;
				} else {
					bs296 &= -17;
				}
				break;
			case 4:
				if(v296) {
					bs296 |= 8;
				} else {
					bs296 &= -9;
				}
				break;
			case 5:
				if(v296) {
					bs296 |= 4;
				} else {
					bs296 &= -5;
				}
				break;
			case 6:
				if(v296) {
					bs296 |= 2;
				} else {
					bs296 &= -3;
				}
				break;
			case 7:
				if(v296) {
					bs296 |= 1;
				} else {
					bs296 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs296;
		var this298 = 0;
		var bs297 = this298;
		var l297 = "   * ".length;
		var _g1297 = 0;
		var _g397 = l297;
		while(_g1297 < _g397) {
			var i297 = _g1297++;
			var no297 = "   * ".charCodeAt(i297);
			if(no297 == null) {
				break;
			}
			var v297;
			switch(no297) {
			case 32:
				v297 = false;
				break;
			case 42:
				v297 = true;
				break;
			case 48:
				v297 = false;
				break;
			case 49:
				v297 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i297)));
			}
			switch(i297 - (l297 - 8)) {
			case 0:
				if(v297) {
					bs297 |= 128;
				} else {
					bs297 &= -129;
				}
				break;
			case 1:
				if(v297) {
					bs297 |= 64;
				} else {
					bs297 &= -65;
				}
				break;
			case 2:
				if(v297) {
					bs297 |= 32;
				} else {
					bs297 &= -33;
				}
				break;
			case 3:
				if(v297) {
					bs297 |= 16;
				} else {
					bs297 &= -17;
				}
				break;
			case 4:
				if(v297) {
					bs297 |= 8;
				} else {
					bs297 &= -9;
				}
				break;
			case 5:
				if(v297) {
					bs297 |= 4;
				} else {
					bs297 &= -5;
				}
				break;
			case 6:
				if(v297) {
					bs297 |= 2;
				} else {
					bs297 &= -3;
				}
				break;
			case 7:
				if(v297) {
					bs297 |= 1;
				} else {
					bs297 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs297;
		var this299 = 0;
		var bs298 = this299;
		var l298 = "   * ".length;
		var _g1298 = 0;
		var _g398 = l298;
		while(_g1298 < _g398) {
			var i298 = _g1298++;
			var no298 = "   * ".charCodeAt(i298);
			if(no298 == null) {
				break;
			}
			var v298;
			switch(no298) {
			case 32:
				v298 = false;
				break;
			case 42:
				v298 = true;
				break;
			case 48:
				v298 = false;
				break;
			case 49:
				v298 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i298)));
			}
			switch(i298 - (l298 - 8)) {
			case 0:
				if(v298) {
					bs298 |= 128;
				} else {
					bs298 &= -129;
				}
				break;
			case 1:
				if(v298) {
					bs298 |= 64;
				} else {
					bs298 &= -65;
				}
				break;
			case 2:
				if(v298) {
					bs298 |= 32;
				} else {
					bs298 &= -33;
				}
				break;
			case 3:
				if(v298) {
					bs298 |= 16;
				} else {
					bs298 &= -17;
				}
				break;
			case 4:
				if(v298) {
					bs298 |= 8;
				} else {
					bs298 &= -9;
				}
				break;
			case 5:
				if(v298) {
					bs298 |= 4;
				} else {
					bs298 &= -5;
				}
				break;
			case 6:
				if(v298) {
					bs298 |= 2;
				} else {
					bs298 &= -3;
				}
				break;
			case 7:
				if(v298) {
					bs298 |= 1;
				} else {
					bs298 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs298;
		var this300 = 0;
		var bs299 = this300;
		var l299 = "*  * ".length;
		var _g1299 = 0;
		var _g399 = l299;
		while(_g1299 < _g399) {
			var i299 = _g1299++;
			var no299 = "*  * ".charCodeAt(i299);
			if(no299 == null) {
				break;
			}
			var v299;
			switch(no299) {
			case 32:
				v299 = false;
				break;
			case 42:
				v299 = true;
				break;
			case 48:
				v299 = false;
				break;
			case 49:
				v299 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i299)));
			}
			switch(i299 - (l299 - 8)) {
			case 0:
				if(v299) {
					bs299 |= 128;
				} else {
					bs299 &= -129;
				}
				break;
			case 1:
				if(v299) {
					bs299 |= 64;
				} else {
					bs299 &= -65;
				}
				break;
			case 2:
				if(v299) {
					bs299 |= 32;
				} else {
					bs299 &= -33;
				}
				break;
			case 3:
				if(v299) {
					bs299 |= 16;
				} else {
					bs299 &= -17;
				}
				break;
			case 4:
				if(v299) {
					bs299 |= 8;
				} else {
					bs299 &= -9;
				}
				break;
			case 5:
				if(v299) {
					bs299 |= 4;
				} else {
					bs299 &= -5;
				}
				break;
			case 6:
				if(v299) {
					bs299 |= 2;
				} else {
					bs299 &= -3;
				}
				break;
			case 7:
				if(v299) {
					bs299 |= 1;
				} else {
					bs299 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs299;
		var this301 = 0;
		var bs300 = this301;
		var l300 = " **  ".length;
		var _g1300 = 0;
		var _g400 = l300;
		while(_g1300 < _g400) {
			var i300 = _g1300++;
			var no300 = " **  ".charCodeAt(i300);
			if(no300 == null) {
				break;
			}
			var v300;
			switch(no300) {
			case 32:
				v300 = false;
				break;
			case 42:
				v300 = true;
				break;
			case 48:
				v300 = false;
				break;
			case 49:
				v300 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i300)));
			}
			switch(i300 - (l300 - 8)) {
			case 0:
				if(v300) {
					bs300 |= 128;
				} else {
					bs300 &= -129;
				}
				break;
			case 1:
				if(v300) {
					bs300 |= 64;
				} else {
					bs300 &= -65;
				}
				break;
			case 2:
				if(v300) {
					bs300 |= 32;
				} else {
					bs300 &= -33;
				}
				break;
			case 3:
				if(v300) {
					bs300 |= 16;
				} else {
					bs300 &= -17;
				}
				break;
			case 4:
				if(v300) {
					bs300 |= 8;
				} else {
					bs300 &= -9;
				}
				break;
			case 5:
				if(v300) {
					bs300 |= 4;
				} else {
					bs300 &= -5;
				}
				break;
			case 6:
				if(v300) {
					bs300 |= 2;
				} else {
					bs300 &= -3;
				}
				break;
			case 7:
				if(v300) {
					bs300 |= 1;
				} else {
					bs300 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs300;
		break;
	case 75:
		var this302 = 0;
		var bs301 = this302;
		var l301 = "*   *".length;
		var _g1301 = 0;
		var _g401 = l301;
		while(_g1301 < _g401) {
			var i301 = _g1301++;
			var no301 = "*   *".charCodeAt(i301);
			if(no301 == null) {
				break;
			}
			var v301;
			switch(no301) {
			case 32:
				v301 = false;
				break;
			case 42:
				v301 = true;
				break;
			case 48:
				v301 = false;
				break;
			case 49:
				v301 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i301)));
			}
			switch(i301 - (l301 - 8)) {
			case 0:
				if(v301) {
					bs301 |= 128;
				} else {
					bs301 &= -129;
				}
				break;
			case 1:
				if(v301) {
					bs301 |= 64;
				} else {
					bs301 &= -65;
				}
				break;
			case 2:
				if(v301) {
					bs301 |= 32;
				} else {
					bs301 &= -33;
				}
				break;
			case 3:
				if(v301) {
					bs301 |= 16;
				} else {
					bs301 &= -17;
				}
				break;
			case 4:
				if(v301) {
					bs301 |= 8;
				} else {
					bs301 &= -9;
				}
				break;
			case 5:
				if(v301) {
					bs301 |= 4;
				} else {
					bs301 &= -5;
				}
				break;
			case 6:
				if(v301) {
					bs301 |= 2;
				} else {
					bs301 &= -3;
				}
				break;
			case 7:
				if(v301) {
					bs301 |= 1;
				} else {
					bs301 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs301;
		var this303 = 0;
		var bs302 = this303;
		var l302 = "*  * ".length;
		var _g1302 = 0;
		var _g402 = l302;
		while(_g1302 < _g402) {
			var i302 = _g1302++;
			var no302 = "*  * ".charCodeAt(i302);
			if(no302 == null) {
				break;
			}
			var v302;
			switch(no302) {
			case 32:
				v302 = false;
				break;
			case 42:
				v302 = true;
				break;
			case 48:
				v302 = false;
				break;
			case 49:
				v302 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i302)));
			}
			switch(i302 - (l302 - 8)) {
			case 0:
				if(v302) {
					bs302 |= 128;
				} else {
					bs302 &= -129;
				}
				break;
			case 1:
				if(v302) {
					bs302 |= 64;
				} else {
					bs302 &= -65;
				}
				break;
			case 2:
				if(v302) {
					bs302 |= 32;
				} else {
					bs302 &= -33;
				}
				break;
			case 3:
				if(v302) {
					bs302 |= 16;
				} else {
					bs302 &= -17;
				}
				break;
			case 4:
				if(v302) {
					bs302 |= 8;
				} else {
					bs302 &= -9;
				}
				break;
			case 5:
				if(v302) {
					bs302 |= 4;
				} else {
					bs302 &= -5;
				}
				break;
			case 6:
				if(v302) {
					bs302 |= 2;
				} else {
					bs302 &= -3;
				}
				break;
			case 7:
				if(v302) {
					bs302 |= 1;
				} else {
					bs302 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs302;
		var this304 = 0;
		var bs303 = this304;
		var l303 = "* *  ".length;
		var _g1303 = 0;
		var _g403 = l303;
		while(_g1303 < _g403) {
			var i303 = _g1303++;
			var no303 = "* *  ".charCodeAt(i303);
			if(no303 == null) {
				break;
			}
			var v303;
			switch(no303) {
			case 32:
				v303 = false;
				break;
			case 42:
				v303 = true;
				break;
			case 48:
				v303 = false;
				break;
			case 49:
				v303 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i303)));
			}
			switch(i303 - (l303 - 8)) {
			case 0:
				if(v303) {
					bs303 |= 128;
				} else {
					bs303 &= -129;
				}
				break;
			case 1:
				if(v303) {
					bs303 |= 64;
				} else {
					bs303 &= -65;
				}
				break;
			case 2:
				if(v303) {
					bs303 |= 32;
				} else {
					bs303 &= -33;
				}
				break;
			case 3:
				if(v303) {
					bs303 |= 16;
				} else {
					bs303 &= -17;
				}
				break;
			case 4:
				if(v303) {
					bs303 |= 8;
				} else {
					bs303 &= -9;
				}
				break;
			case 5:
				if(v303) {
					bs303 |= 4;
				} else {
					bs303 &= -5;
				}
				break;
			case 6:
				if(v303) {
					bs303 |= 2;
				} else {
					bs303 &= -3;
				}
				break;
			case 7:
				if(v303) {
					bs303 |= 1;
				} else {
					bs303 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs303;
		var this305 = 0;
		var bs304 = this305;
		var l304 = "**   ".length;
		var _g1304 = 0;
		var _g404 = l304;
		while(_g1304 < _g404) {
			var i304 = _g1304++;
			var no304 = "**   ".charCodeAt(i304);
			if(no304 == null) {
				break;
			}
			var v304;
			switch(no304) {
			case 32:
				v304 = false;
				break;
			case 42:
				v304 = true;
				break;
			case 48:
				v304 = false;
				break;
			case 49:
				v304 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**   ".charCodeAt(i304)));
			}
			switch(i304 - (l304 - 8)) {
			case 0:
				if(v304) {
					bs304 |= 128;
				} else {
					bs304 &= -129;
				}
				break;
			case 1:
				if(v304) {
					bs304 |= 64;
				} else {
					bs304 &= -65;
				}
				break;
			case 2:
				if(v304) {
					bs304 |= 32;
				} else {
					bs304 &= -33;
				}
				break;
			case 3:
				if(v304) {
					bs304 |= 16;
				} else {
					bs304 &= -17;
				}
				break;
			case 4:
				if(v304) {
					bs304 |= 8;
				} else {
					bs304 &= -9;
				}
				break;
			case 5:
				if(v304) {
					bs304 |= 4;
				} else {
					bs304 &= -5;
				}
				break;
			case 6:
				if(v304) {
					bs304 |= 2;
				} else {
					bs304 &= -3;
				}
				break;
			case 7:
				if(v304) {
					bs304 |= 1;
				} else {
					bs304 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs304;
		var this306 = 0;
		var bs305 = this306;
		var l305 = "* *  ".length;
		var _g1305 = 0;
		var _g405 = l305;
		while(_g1305 < _g405) {
			var i305 = _g1305++;
			var no305 = "* *  ".charCodeAt(i305);
			if(no305 == null) {
				break;
			}
			var v305;
			switch(no305) {
			case 32:
				v305 = false;
				break;
			case 42:
				v305 = true;
				break;
			case 48:
				v305 = false;
				break;
			case 49:
				v305 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i305)));
			}
			switch(i305 - (l305 - 8)) {
			case 0:
				if(v305) {
					bs305 |= 128;
				} else {
					bs305 &= -129;
				}
				break;
			case 1:
				if(v305) {
					bs305 |= 64;
				} else {
					bs305 &= -65;
				}
				break;
			case 2:
				if(v305) {
					bs305 |= 32;
				} else {
					bs305 &= -33;
				}
				break;
			case 3:
				if(v305) {
					bs305 |= 16;
				} else {
					bs305 &= -17;
				}
				break;
			case 4:
				if(v305) {
					bs305 |= 8;
				} else {
					bs305 &= -9;
				}
				break;
			case 5:
				if(v305) {
					bs305 |= 4;
				} else {
					bs305 &= -5;
				}
				break;
			case 6:
				if(v305) {
					bs305 |= 2;
				} else {
					bs305 &= -3;
				}
				break;
			case 7:
				if(v305) {
					bs305 |= 1;
				} else {
					bs305 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs305;
		var this307 = 0;
		var bs306 = this307;
		var l306 = "*  * ".length;
		var _g1306 = 0;
		var _g406 = l306;
		while(_g1306 < _g406) {
			var i306 = _g1306++;
			var no306 = "*  * ".charCodeAt(i306);
			if(no306 == null) {
				break;
			}
			var v306;
			switch(no306) {
			case 32:
				v306 = false;
				break;
			case 42:
				v306 = true;
				break;
			case 48:
				v306 = false;
				break;
			case 49:
				v306 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i306)));
			}
			switch(i306 - (l306 - 8)) {
			case 0:
				if(v306) {
					bs306 |= 128;
				} else {
					bs306 &= -129;
				}
				break;
			case 1:
				if(v306) {
					bs306 |= 64;
				} else {
					bs306 &= -65;
				}
				break;
			case 2:
				if(v306) {
					bs306 |= 32;
				} else {
					bs306 &= -33;
				}
				break;
			case 3:
				if(v306) {
					bs306 |= 16;
				} else {
					bs306 &= -17;
				}
				break;
			case 4:
				if(v306) {
					bs306 |= 8;
				} else {
					bs306 &= -9;
				}
				break;
			case 5:
				if(v306) {
					bs306 |= 4;
				} else {
					bs306 &= -5;
				}
				break;
			case 6:
				if(v306) {
					bs306 |= 2;
				} else {
					bs306 &= -3;
				}
				break;
			case 7:
				if(v306) {
					bs306 |= 1;
				} else {
					bs306 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs306;
		var this308 = 0;
		var bs307 = this308;
		var l307 = "*   *".length;
		var _g1307 = 0;
		var _g407 = l307;
		while(_g1307 < _g407) {
			var i307 = _g1307++;
			var no307 = "*   *".charCodeAt(i307);
			if(no307 == null) {
				break;
			}
			var v307;
			switch(no307) {
			case 32:
				v307 = false;
				break;
			case 42:
				v307 = true;
				break;
			case 48:
				v307 = false;
				break;
			case 49:
				v307 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i307)));
			}
			switch(i307 - (l307 - 8)) {
			case 0:
				if(v307) {
					bs307 |= 128;
				} else {
					bs307 &= -129;
				}
				break;
			case 1:
				if(v307) {
					bs307 |= 64;
				} else {
					bs307 &= -65;
				}
				break;
			case 2:
				if(v307) {
					bs307 |= 32;
				} else {
					bs307 &= -33;
				}
				break;
			case 3:
				if(v307) {
					bs307 |= 16;
				} else {
					bs307 &= -17;
				}
				break;
			case 4:
				if(v307) {
					bs307 |= 8;
				} else {
					bs307 &= -9;
				}
				break;
			case 5:
				if(v307) {
					bs307 |= 4;
				} else {
					bs307 &= -5;
				}
				break;
			case 6:
				if(v307) {
					bs307 |= 2;
				} else {
					bs307 &= -3;
				}
				break;
			case 7:
				if(v307) {
					bs307 |= 1;
				} else {
					bs307 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs307;
		break;
	case 76:
		var this309 = 0;
		var bs308 = this309;
		var l308 = "*    ".length;
		var _g1308 = 0;
		var _g408 = l308;
		while(_g1308 < _g408) {
			var i308 = _g1308++;
			var no308 = "*    ".charCodeAt(i308);
			if(no308 == null) {
				break;
			}
			var v308;
			switch(no308) {
			case 32:
				v308 = false;
				break;
			case 42:
				v308 = true;
				break;
			case 48:
				v308 = false;
				break;
			case 49:
				v308 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i308)));
			}
			switch(i308 - (l308 - 8)) {
			case 0:
				if(v308) {
					bs308 |= 128;
				} else {
					bs308 &= -129;
				}
				break;
			case 1:
				if(v308) {
					bs308 |= 64;
				} else {
					bs308 &= -65;
				}
				break;
			case 2:
				if(v308) {
					bs308 |= 32;
				} else {
					bs308 &= -33;
				}
				break;
			case 3:
				if(v308) {
					bs308 |= 16;
				} else {
					bs308 &= -17;
				}
				break;
			case 4:
				if(v308) {
					bs308 |= 8;
				} else {
					bs308 &= -9;
				}
				break;
			case 5:
				if(v308) {
					bs308 |= 4;
				} else {
					bs308 &= -5;
				}
				break;
			case 6:
				if(v308) {
					bs308 |= 2;
				} else {
					bs308 &= -3;
				}
				break;
			case 7:
				if(v308) {
					bs308 |= 1;
				} else {
					bs308 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs308;
		var this310 = 0;
		var bs309 = this310;
		var l309 = "*    ".length;
		var _g1309 = 0;
		var _g409 = l309;
		while(_g1309 < _g409) {
			var i309 = _g1309++;
			var no309 = "*    ".charCodeAt(i309);
			if(no309 == null) {
				break;
			}
			var v309;
			switch(no309) {
			case 32:
				v309 = false;
				break;
			case 42:
				v309 = true;
				break;
			case 48:
				v309 = false;
				break;
			case 49:
				v309 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i309)));
			}
			switch(i309 - (l309 - 8)) {
			case 0:
				if(v309) {
					bs309 |= 128;
				} else {
					bs309 &= -129;
				}
				break;
			case 1:
				if(v309) {
					bs309 |= 64;
				} else {
					bs309 &= -65;
				}
				break;
			case 2:
				if(v309) {
					bs309 |= 32;
				} else {
					bs309 &= -33;
				}
				break;
			case 3:
				if(v309) {
					bs309 |= 16;
				} else {
					bs309 &= -17;
				}
				break;
			case 4:
				if(v309) {
					bs309 |= 8;
				} else {
					bs309 &= -9;
				}
				break;
			case 5:
				if(v309) {
					bs309 |= 4;
				} else {
					bs309 &= -5;
				}
				break;
			case 6:
				if(v309) {
					bs309 |= 2;
				} else {
					bs309 &= -3;
				}
				break;
			case 7:
				if(v309) {
					bs309 |= 1;
				} else {
					bs309 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs309;
		var this311 = 0;
		var bs310 = this311;
		var l310 = "*    ".length;
		var _g1310 = 0;
		var _g410 = l310;
		while(_g1310 < _g410) {
			var i310 = _g1310++;
			var no310 = "*    ".charCodeAt(i310);
			if(no310 == null) {
				break;
			}
			var v310;
			switch(no310) {
			case 32:
				v310 = false;
				break;
			case 42:
				v310 = true;
				break;
			case 48:
				v310 = false;
				break;
			case 49:
				v310 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i310)));
			}
			switch(i310 - (l310 - 8)) {
			case 0:
				if(v310) {
					bs310 |= 128;
				} else {
					bs310 &= -129;
				}
				break;
			case 1:
				if(v310) {
					bs310 |= 64;
				} else {
					bs310 &= -65;
				}
				break;
			case 2:
				if(v310) {
					bs310 |= 32;
				} else {
					bs310 &= -33;
				}
				break;
			case 3:
				if(v310) {
					bs310 |= 16;
				} else {
					bs310 &= -17;
				}
				break;
			case 4:
				if(v310) {
					bs310 |= 8;
				} else {
					bs310 &= -9;
				}
				break;
			case 5:
				if(v310) {
					bs310 |= 4;
				} else {
					bs310 &= -5;
				}
				break;
			case 6:
				if(v310) {
					bs310 |= 2;
				} else {
					bs310 &= -3;
				}
				break;
			case 7:
				if(v310) {
					bs310 |= 1;
				} else {
					bs310 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs310;
		var this312 = 0;
		var bs311 = this312;
		var l311 = "*    ".length;
		var _g1311 = 0;
		var _g411 = l311;
		while(_g1311 < _g411) {
			var i311 = _g1311++;
			var no311 = "*    ".charCodeAt(i311);
			if(no311 == null) {
				break;
			}
			var v311;
			switch(no311) {
			case 32:
				v311 = false;
				break;
			case 42:
				v311 = true;
				break;
			case 48:
				v311 = false;
				break;
			case 49:
				v311 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i311)));
			}
			switch(i311 - (l311 - 8)) {
			case 0:
				if(v311) {
					bs311 |= 128;
				} else {
					bs311 &= -129;
				}
				break;
			case 1:
				if(v311) {
					bs311 |= 64;
				} else {
					bs311 &= -65;
				}
				break;
			case 2:
				if(v311) {
					bs311 |= 32;
				} else {
					bs311 &= -33;
				}
				break;
			case 3:
				if(v311) {
					bs311 |= 16;
				} else {
					bs311 &= -17;
				}
				break;
			case 4:
				if(v311) {
					bs311 |= 8;
				} else {
					bs311 &= -9;
				}
				break;
			case 5:
				if(v311) {
					bs311 |= 4;
				} else {
					bs311 &= -5;
				}
				break;
			case 6:
				if(v311) {
					bs311 |= 2;
				} else {
					bs311 &= -3;
				}
				break;
			case 7:
				if(v311) {
					bs311 |= 1;
				} else {
					bs311 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs311;
		var this313 = 0;
		var bs312 = this313;
		var l312 = "*    ".length;
		var _g1312 = 0;
		var _g412 = l312;
		while(_g1312 < _g412) {
			var i312 = _g1312++;
			var no312 = "*    ".charCodeAt(i312);
			if(no312 == null) {
				break;
			}
			var v312;
			switch(no312) {
			case 32:
				v312 = false;
				break;
			case 42:
				v312 = true;
				break;
			case 48:
				v312 = false;
				break;
			case 49:
				v312 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i312)));
			}
			switch(i312 - (l312 - 8)) {
			case 0:
				if(v312) {
					bs312 |= 128;
				} else {
					bs312 &= -129;
				}
				break;
			case 1:
				if(v312) {
					bs312 |= 64;
				} else {
					bs312 &= -65;
				}
				break;
			case 2:
				if(v312) {
					bs312 |= 32;
				} else {
					bs312 &= -33;
				}
				break;
			case 3:
				if(v312) {
					bs312 |= 16;
				} else {
					bs312 &= -17;
				}
				break;
			case 4:
				if(v312) {
					bs312 |= 8;
				} else {
					bs312 &= -9;
				}
				break;
			case 5:
				if(v312) {
					bs312 |= 4;
				} else {
					bs312 &= -5;
				}
				break;
			case 6:
				if(v312) {
					bs312 |= 2;
				} else {
					bs312 &= -3;
				}
				break;
			case 7:
				if(v312) {
					bs312 |= 1;
				} else {
					bs312 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs312;
		var this314 = 0;
		var bs313 = this314;
		var l313 = "*    ".length;
		var _g1313 = 0;
		var _g413 = l313;
		while(_g1313 < _g413) {
			var i313 = _g1313++;
			var no313 = "*    ".charCodeAt(i313);
			if(no313 == null) {
				break;
			}
			var v313;
			switch(no313) {
			case 32:
				v313 = false;
				break;
			case 42:
				v313 = true;
				break;
			case 48:
				v313 = false;
				break;
			case 49:
				v313 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i313)));
			}
			switch(i313 - (l313 - 8)) {
			case 0:
				if(v313) {
					bs313 |= 128;
				} else {
					bs313 &= -129;
				}
				break;
			case 1:
				if(v313) {
					bs313 |= 64;
				} else {
					bs313 &= -65;
				}
				break;
			case 2:
				if(v313) {
					bs313 |= 32;
				} else {
					bs313 &= -33;
				}
				break;
			case 3:
				if(v313) {
					bs313 |= 16;
				} else {
					bs313 &= -17;
				}
				break;
			case 4:
				if(v313) {
					bs313 |= 8;
				} else {
					bs313 &= -9;
				}
				break;
			case 5:
				if(v313) {
					bs313 |= 4;
				} else {
					bs313 &= -5;
				}
				break;
			case 6:
				if(v313) {
					bs313 |= 2;
				} else {
					bs313 &= -3;
				}
				break;
			case 7:
				if(v313) {
					bs313 |= 1;
				} else {
					bs313 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs313;
		var this315 = 0;
		var bs314 = this315;
		var l314 = "*****".length;
		var _g1314 = 0;
		var _g414 = l314;
		while(_g1314 < _g414) {
			var i314 = _g1314++;
			var no314 = "*****".charCodeAt(i314);
			if(no314 == null) {
				break;
			}
			var v314;
			switch(no314) {
			case 32:
				v314 = false;
				break;
			case 42:
				v314 = true;
				break;
			case 48:
				v314 = false;
				break;
			case 49:
				v314 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i314)));
			}
			switch(i314 - (l314 - 8)) {
			case 0:
				if(v314) {
					bs314 |= 128;
				} else {
					bs314 &= -129;
				}
				break;
			case 1:
				if(v314) {
					bs314 |= 64;
				} else {
					bs314 &= -65;
				}
				break;
			case 2:
				if(v314) {
					bs314 |= 32;
				} else {
					bs314 &= -33;
				}
				break;
			case 3:
				if(v314) {
					bs314 |= 16;
				} else {
					bs314 &= -17;
				}
				break;
			case 4:
				if(v314) {
					bs314 |= 8;
				} else {
					bs314 &= -9;
				}
				break;
			case 5:
				if(v314) {
					bs314 |= 4;
				} else {
					bs314 &= -5;
				}
				break;
			case 6:
				if(v314) {
					bs314 |= 2;
				} else {
					bs314 &= -3;
				}
				break;
			case 7:
				if(v314) {
					bs314 |= 1;
				} else {
					bs314 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs314;
		break;
	case 77:
		var this316 = 0;
		var bs315 = this316;
		var l315 = "*   *".length;
		var _g1315 = 0;
		var _g415 = l315;
		while(_g1315 < _g415) {
			var i315 = _g1315++;
			var no315 = "*   *".charCodeAt(i315);
			if(no315 == null) {
				break;
			}
			var v315;
			switch(no315) {
			case 32:
				v315 = false;
				break;
			case 42:
				v315 = true;
				break;
			case 48:
				v315 = false;
				break;
			case 49:
				v315 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i315)));
			}
			switch(i315 - (l315 - 8)) {
			case 0:
				if(v315) {
					bs315 |= 128;
				} else {
					bs315 &= -129;
				}
				break;
			case 1:
				if(v315) {
					bs315 |= 64;
				} else {
					bs315 &= -65;
				}
				break;
			case 2:
				if(v315) {
					bs315 |= 32;
				} else {
					bs315 &= -33;
				}
				break;
			case 3:
				if(v315) {
					bs315 |= 16;
				} else {
					bs315 &= -17;
				}
				break;
			case 4:
				if(v315) {
					bs315 |= 8;
				} else {
					bs315 &= -9;
				}
				break;
			case 5:
				if(v315) {
					bs315 |= 4;
				} else {
					bs315 &= -5;
				}
				break;
			case 6:
				if(v315) {
					bs315 |= 2;
				} else {
					bs315 &= -3;
				}
				break;
			case 7:
				if(v315) {
					bs315 |= 1;
				} else {
					bs315 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs315;
		var this317 = 0;
		var bs316 = this317;
		var l316 = "** **".length;
		var _g1316 = 0;
		var _g416 = l316;
		while(_g1316 < _g416) {
			var i316 = _g1316++;
			var no316 = "** **".charCodeAt(i316);
			if(no316 == null) {
				break;
			}
			var v316;
			switch(no316) {
			case 32:
				v316 = false;
				break;
			case 42:
				v316 = true;
				break;
			case 48:
				v316 = false;
				break;
			case 49:
				v316 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("** **".charCodeAt(i316)));
			}
			switch(i316 - (l316 - 8)) {
			case 0:
				if(v316) {
					bs316 |= 128;
				} else {
					bs316 &= -129;
				}
				break;
			case 1:
				if(v316) {
					bs316 |= 64;
				} else {
					bs316 &= -65;
				}
				break;
			case 2:
				if(v316) {
					bs316 |= 32;
				} else {
					bs316 &= -33;
				}
				break;
			case 3:
				if(v316) {
					bs316 |= 16;
				} else {
					bs316 &= -17;
				}
				break;
			case 4:
				if(v316) {
					bs316 |= 8;
				} else {
					bs316 &= -9;
				}
				break;
			case 5:
				if(v316) {
					bs316 |= 4;
				} else {
					bs316 &= -5;
				}
				break;
			case 6:
				if(v316) {
					bs316 |= 2;
				} else {
					bs316 &= -3;
				}
				break;
			case 7:
				if(v316) {
					bs316 |= 1;
				} else {
					bs316 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs316;
		var this318 = 0;
		var bs317 = this318;
		var l317 = "* * *".length;
		var _g1317 = 0;
		var _g417 = l317;
		while(_g1317 < _g417) {
			var i317 = _g1317++;
			var no317 = "* * *".charCodeAt(i317);
			if(no317 == null) {
				break;
			}
			var v317;
			switch(no317) {
			case 32:
				v317 = false;
				break;
			case 42:
				v317 = true;
				break;
			case 48:
				v317 = false;
				break;
			case 49:
				v317 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i317)));
			}
			switch(i317 - (l317 - 8)) {
			case 0:
				if(v317) {
					bs317 |= 128;
				} else {
					bs317 &= -129;
				}
				break;
			case 1:
				if(v317) {
					bs317 |= 64;
				} else {
					bs317 &= -65;
				}
				break;
			case 2:
				if(v317) {
					bs317 |= 32;
				} else {
					bs317 &= -33;
				}
				break;
			case 3:
				if(v317) {
					bs317 |= 16;
				} else {
					bs317 &= -17;
				}
				break;
			case 4:
				if(v317) {
					bs317 |= 8;
				} else {
					bs317 &= -9;
				}
				break;
			case 5:
				if(v317) {
					bs317 |= 4;
				} else {
					bs317 &= -5;
				}
				break;
			case 6:
				if(v317) {
					bs317 |= 2;
				} else {
					bs317 &= -3;
				}
				break;
			case 7:
				if(v317) {
					bs317 |= 1;
				} else {
					bs317 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs317;
		var this319 = 0;
		var bs318 = this319;
		var l318 = "* * *".length;
		var _g1318 = 0;
		var _g418 = l318;
		while(_g1318 < _g418) {
			var i318 = _g1318++;
			var no318 = "* * *".charCodeAt(i318);
			if(no318 == null) {
				break;
			}
			var v318;
			switch(no318) {
			case 32:
				v318 = false;
				break;
			case 42:
				v318 = true;
				break;
			case 48:
				v318 = false;
				break;
			case 49:
				v318 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i318)));
			}
			switch(i318 - (l318 - 8)) {
			case 0:
				if(v318) {
					bs318 |= 128;
				} else {
					bs318 &= -129;
				}
				break;
			case 1:
				if(v318) {
					bs318 |= 64;
				} else {
					bs318 &= -65;
				}
				break;
			case 2:
				if(v318) {
					bs318 |= 32;
				} else {
					bs318 &= -33;
				}
				break;
			case 3:
				if(v318) {
					bs318 |= 16;
				} else {
					bs318 &= -17;
				}
				break;
			case 4:
				if(v318) {
					bs318 |= 8;
				} else {
					bs318 &= -9;
				}
				break;
			case 5:
				if(v318) {
					bs318 |= 4;
				} else {
					bs318 &= -5;
				}
				break;
			case 6:
				if(v318) {
					bs318 |= 2;
				} else {
					bs318 &= -3;
				}
				break;
			case 7:
				if(v318) {
					bs318 |= 1;
				} else {
					bs318 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs318;
		var this320 = 0;
		var bs319 = this320;
		var l319 = "*   *".length;
		var _g1319 = 0;
		var _g419 = l319;
		while(_g1319 < _g419) {
			var i319 = _g1319++;
			var no319 = "*   *".charCodeAt(i319);
			if(no319 == null) {
				break;
			}
			var v319;
			switch(no319) {
			case 32:
				v319 = false;
				break;
			case 42:
				v319 = true;
				break;
			case 48:
				v319 = false;
				break;
			case 49:
				v319 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i319)));
			}
			switch(i319 - (l319 - 8)) {
			case 0:
				if(v319) {
					bs319 |= 128;
				} else {
					bs319 &= -129;
				}
				break;
			case 1:
				if(v319) {
					bs319 |= 64;
				} else {
					bs319 &= -65;
				}
				break;
			case 2:
				if(v319) {
					bs319 |= 32;
				} else {
					bs319 &= -33;
				}
				break;
			case 3:
				if(v319) {
					bs319 |= 16;
				} else {
					bs319 &= -17;
				}
				break;
			case 4:
				if(v319) {
					bs319 |= 8;
				} else {
					bs319 &= -9;
				}
				break;
			case 5:
				if(v319) {
					bs319 |= 4;
				} else {
					bs319 &= -5;
				}
				break;
			case 6:
				if(v319) {
					bs319 |= 2;
				} else {
					bs319 &= -3;
				}
				break;
			case 7:
				if(v319) {
					bs319 |= 1;
				} else {
					bs319 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs319;
		var this321 = 0;
		var bs320 = this321;
		var l320 = "*   *".length;
		var _g1320 = 0;
		var _g420 = l320;
		while(_g1320 < _g420) {
			var i320 = _g1320++;
			var no320 = "*   *".charCodeAt(i320);
			if(no320 == null) {
				break;
			}
			var v320;
			switch(no320) {
			case 32:
				v320 = false;
				break;
			case 42:
				v320 = true;
				break;
			case 48:
				v320 = false;
				break;
			case 49:
				v320 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i320)));
			}
			switch(i320 - (l320 - 8)) {
			case 0:
				if(v320) {
					bs320 |= 128;
				} else {
					bs320 &= -129;
				}
				break;
			case 1:
				if(v320) {
					bs320 |= 64;
				} else {
					bs320 &= -65;
				}
				break;
			case 2:
				if(v320) {
					bs320 |= 32;
				} else {
					bs320 &= -33;
				}
				break;
			case 3:
				if(v320) {
					bs320 |= 16;
				} else {
					bs320 &= -17;
				}
				break;
			case 4:
				if(v320) {
					bs320 |= 8;
				} else {
					bs320 &= -9;
				}
				break;
			case 5:
				if(v320) {
					bs320 |= 4;
				} else {
					bs320 &= -5;
				}
				break;
			case 6:
				if(v320) {
					bs320 |= 2;
				} else {
					bs320 &= -3;
				}
				break;
			case 7:
				if(v320) {
					bs320 |= 1;
				} else {
					bs320 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs320;
		var this322 = 0;
		var bs321 = this322;
		var l321 = "*   *".length;
		var _g1321 = 0;
		var _g421 = l321;
		while(_g1321 < _g421) {
			var i321 = _g1321++;
			var no321 = "*   *".charCodeAt(i321);
			if(no321 == null) {
				break;
			}
			var v321;
			switch(no321) {
			case 32:
				v321 = false;
				break;
			case 42:
				v321 = true;
				break;
			case 48:
				v321 = false;
				break;
			case 49:
				v321 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i321)));
			}
			switch(i321 - (l321 - 8)) {
			case 0:
				if(v321) {
					bs321 |= 128;
				} else {
					bs321 &= -129;
				}
				break;
			case 1:
				if(v321) {
					bs321 |= 64;
				} else {
					bs321 &= -65;
				}
				break;
			case 2:
				if(v321) {
					bs321 |= 32;
				} else {
					bs321 &= -33;
				}
				break;
			case 3:
				if(v321) {
					bs321 |= 16;
				} else {
					bs321 &= -17;
				}
				break;
			case 4:
				if(v321) {
					bs321 |= 8;
				} else {
					bs321 &= -9;
				}
				break;
			case 5:
				if(v321) {
					bs321 |= 4;
				} else {
					bs321 &= -5;
				}
				break;
			case 6:
				if(v321) {
					bs321 |= 2;
				} else {
					bs321 &= -3;
				}
				break;
			case 7:
				if(v321) {
					bs321 |= 1;
				} else {
					bs321 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs321;
		break;
	case 78:
		var this323 = 0;
		var bs322 = this323;
		var l322 = "*   *".length;
		var _g1322 = 0;
		var _g422 = l322;
		while(_g1322 < _g422) {
			var i322 = _g1322++;
			var no322 = "*   *".charCodeAt(i322);
			if(no322 == null) {
				break;
			}
			var v322;
			switch(no322) {
			case 32:
				v322 = false;
				break;
			case 42:
				v322 = true;
				break;
			case 48:
				v322 = false;
				break;
			case 49:
				v322 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i322)));
			}
			switch(i322 - (l322 - 8)) {
			case 0:
				if(v322) {
					bs322 |= 128;
				} else {
					bs322 &= -129;
				}
				break;
			case 1:
				if(v322) {
					bs322 |= 64;
				} else {
					bs322 &= -65;
				}
				break;
			case 2:
				if(v322) {
					bs322 |= 32;
				} else {
					bs322 &= -33;
				}
				break;
			case 3:
				if(v322) {
					bs322 |= 16;
				} else {
					bs322 &= -17;
				}
				break;
			case 4:
				if(v322) {
					bs322 |= 8;
				} else {
					bs322 &= -9;
				}
				break;
			case 5:
				if(v322) {
					bs322 |= 4;
				} else {
					bs322 &= -5;
				}
				break;
			case 6:
				if(v322) {
					bs322 |= 2;
				} else {
					bs322 &= -3;
				}
				break;
			case 7:
				if(v322) {
					bs322 |= 1;
				} else {
					bs322 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs322;
		var this324 = 0;
		var bs323 = this324;
		var l323 = "*   *".length;
		var _g1323 = 0;
		var _g423 = l323;
		while(_g1323 < _g423) {
			var i323 = _g1323++;
			var no323 = "*   *".charCodeAt(i323);
			if(no323 == null) {
				break;
			}
			var v323;
			switch(no323) {
			case 32:
				v323 = false;
				break;
			case 42:
				v323 = true;
				break;
			case 48:
				v323 = false;
				break;
			case 49:
				v323 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i323)));
			}
			switch(i323 - (l323 - 8)) {
			case 0:
				if(v323) {
					bs323 |= 128;
				} else {
					bs323 &= -129;
				}
				break;
			case 1:
				if(v323) {
					bs323 |= 64;
				} else {
					bs323 &= -65;
				}
				break;
			case 2:
				if(v323) {
					bs323 |= 32;
				} else {
					bs323 &= -33;
				}
				break;
			case 3:
				if(v323) {
					bs323 |= 16;
				} else {
					bs323 &= -17;
				}
				break;
			case 4:
				if(v323) {
					bs323 |= 8;
				} else {
					bs323 &= -9;
				}
				break;
			case 5:
				if(v323) {
					bs323 |= 4;
				} else {
					bs323 &= -5;
				}
				break;
			case 6:
				if(v323) {
					bs323 |= 2;
				} else {
					bs323 &= -3;
				}
				break;
			case 7:
				if(v323) {
					bs323 |= 1;
				} else {
					bs323 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs323;
		var this325 = 0;
		var bs324 = this325;
		var l324 = "**  *".length;
		var _g1324 = 0;
		var _g424 = l324;
		while(_g1324 < _g424) {
			var i324 = _g1324++;
			var no324 = "**  *".charCodeAt(i324);
			if(no324 == null) {
				break;
			}
			var v324;
			switch(no324) {
			case 32:
				v324 = false;
				break;
			case 42:
				v324 = true;
				break;
			case 48:
				v324 = false;
				break;
			case 49:
				v324 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i324)));
			}
			switch(i324 - (l324 - 8)) {
			case 0:
				if(v324) {
					bs324 |= 128;
				} else {
					bs324 &= -129;
				}
				break;
			case 1:
				if(v324) {
					bs324 |= 64;
				} else {
					bs324 &= -65;
				}
				break;
			case 2:
				if(v324) {
					bs324 |= 32;
				} else {
					bs324 &= -33;
				}
				break;
			case 3:
				if(v324) {
					bs324 |= 16;
				} else {
					bs324 &= -17;
				}
				break;
			case 4:
				if(v324) {
					bs324 |= 8;
				} else {
					bs324 &= -9;
				}
				break;
			case 5:
				if(v324) {
					bs324 |= 4;
				} else {
					bs324 &= -5;
				}
				break;
			case 6:
				if(v324) {
					bs324 |= 2;
				} else {
					bs324 &= -3;
				}
				break;
			case 7:
				if(v324) {
					bs324 |= 1;
				} else {
					bs324 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs324;
		var this326 = 0;
		var bs325 = this326;
		var l325 = "* * *".length;
		var _g1325 = 0;
		var _g425 = l325;
		while(_g1325 < _g425) {
			var i325 = _g1325++;
			var no325 = "* * *".charCodeAt(i325);
			if(no325 == null) {
				break;
			}
			var v325;
			switch(no325) {
			case 32:
				v325 = false;
				break;
			case 42:
				v325 = true;
				break;
			case 48:
				v325 = false;
				break;
			case 49:
				v325 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i325)));
			}
			switch(i325 - (l325 - 8)) {
			case 0:
				if(v325) {
					bs325 |= 128;
				} else {
					bs325 &= -129;
				}
				break;
			case 1:
				if(v325) {
					bs325 |= 64;
				} else {
					bs325 &= -65;
				}
				break;
			case 2:
				if(v325) {
					bs325 |= 32;
				} else {
					bs325 &= -33;
				}
				break;
			case 3:
				if(v325) {
					bs325 |= 16;
				} else {
					bs325 &= -17;
				}
				break;
			case 4:
				if(v325) {
					bs325 |= 8;
				} else {
					bs325 &= -9;
				}
				break;
			case 5:
				if(v325) {
					bs325 |= 4;
				} else {
					bs325 &= -5;
				}
				break;
			case 6:
				if(v325) {
					bs325 |= 2;
				} else {
					bs325 &= -3;
				}
				break;
			case 7:
				if(v325) {
					bs325 |= 1;
				} else {
					bs325 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs325;
		var this327 = 0;
		var bs326 = this327;
		var l326 = "*  **".length;
		var _g1326 = 0;
		var _g426 = l326;
		while(_g1326 < _g426) {
			var i326 = _g1326++;
			var no326 = "*  **".charCodeAt(i326);
			if(no326 == null) {
				break;
			}
			var v326;
			switch(no326) {
			case 32:
				v326 = false;
				break;
			case 42:
				v326 = true;
				break;
			case 48:
				v326 = false;
				break;
			case 49:
				v326 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  **".charCodeAt(i326)));
			}
			switch(i326 - (l326 - 8)) {
			case 0:
				if(v326) {
					bs326 |= 128;
				} else {
					bs326 &= -129;
				}
				break;
			case 1:
				if(v326) {
					bs326 |= 64;
				} else {
					bs326 &= -65;
				}
				break;
			case 2:
				if(v326) {
					bs326 |= 32;
				} else {
					bs326 &= -33;
				}
				break;
			case 3:
				if(v326) {
					bs326 |= 16;
				} else {
					bs326 &= -17;
				}
				break;
			case 4:
				if(v326) {
					bs326 |= 8;
				} else {
					bs326 &= -9;
				}
				break;
			case 5:
				if(v326) {
					bs326 |= 4;
				} else {
					bs326 &= -5;
				}
				break;
			case 6:
				if(v326) {
					bs326 |= 2;
				} else {
					bs326 &= -3;
				}
				break;
			case 7:
				if(v326) {
					bs326 |= 1;
				} else {
					bs326 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs326;
		var this328 = 0;
		var bs327 = this328;
		var l327 = "*   *".length;
		var _g1327 = 0;
		var _g427 = l327;
		while(_g1327 < _g427) {
			var i327 = _g1327++;
			var no327 = "*   *".charCodeAt(i327);
			if(no327 == null) {
				break;
			}
			var v327;
			switch(no327) {
			case 32:
				v327 = false;
				break;
			case 42:
				v327 = true;
				break;
			case 48:
				v327 = false;
				break;
			case 49:
				v327 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i327)));
			}
			switch(i327 - (l327 - 8)) {
			case 0:
				if(v327) {
					bs327 |= 128;
				} else {
					bs327 &= -129;
				}
				break;
			case 1:
				if(v327) {
					bs327 |= 64;
				} else {
					bs327 &= -65;
				}
				break;
			case 2:
				if(v327) {
					bs327 |= 32;
				} else {
					bs327 &= -33;
				}
				break;
			case 3:
				if(v327) {
					bs327 |= 16;
				} else {
					bs327 &= -17;
				}
				break;
			case 4:
				if(v327) {
					bs327 |= 8;
				} else {
					bs327 &= -9;
				}
				break;
			case 5:
				if(v327) {
					bs327 |= 4;
				} else {
					bs327 &= -5;
				}
				break;
			case 6:
				if(v327) {
					bs327 |= 2;
				} else {
					bs327 &= -3;
				}
				break;
			case 7:
				if(v327) {
					bs327 |= 1;
				} else {
					bs327 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs327;
		var this329 = 0;
		var bs328 = this329;
		var l328 = "*   *".length;
		var _g1328 = 0;
		var _g428 = l328;
		while(_g1328 < _g428) {
			var i328 = _g1328++;
			var no328 = "*   *".charCodeAt(i328);
			if(no328 == null) {
				break;
			}
			var v328;
			switch(no328) {
			case 32:
				v328 = false;
				break;
			case 42:
				v328 = true;
				break;
			case 48:
				v328 = false;
				break;
			case 49:
				v328 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i328)));
			}
			switch(i328 - (l328 - 8)) {
			case 0:
				if(v328) {
					bs328 |= 128;
				} else {
					bs328 &= -129;
				}
				break;
			case 1:
				if(v328) {
					bs328 |= 64;
				} else {
					bs328 &= -65;
				}
				break;
			case 2:
				if(v328) {
					bs328 |= 32;
				} else {
					bs328 &= -33;
				}
				break;
			case 3:
				if(v328) {
					bs328 |= 16;
				} else {
					bs328 &= -17;
				}
				break;
			case 4:
				if(v328) {
					bs328 |= 8;
				} else {
					bs328 &= -9;
				}
				break;
			case 5:
				if(v328) {
					bs328 |= 4;
				} else {
					bs328 &= -5;
				}
				break;
			case 6:
				if(v328) {
					bs328 |= 2;
				} else {
					bs328 &= -3;
				}
				break;
			case 7:
				if(v328) {
					bs328 |= 1;
				} else {
					bs328 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs328;
		break;
	case 79:
		var this330 = 0;
		var bs329 = this330;
		var l329 = " *** ".length;
		var _g1329 = 0;
		var _g429 = l329;
		while(_g1329 < _g429) {
			var i329 = _g1329++;
			var no329 = " *** ".charCodeAt(i329);
			if(no329 == null) {
				break;
			}
			var v329;
			switch(no329) {
			case 32:
				v329 = false;
				break;
			case 42:
				v329 = true;
				break;
			case 48:
				v329 = false;
				break;
			case 49:
				v329 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i329)));
			}
			switch(i329 - (l329 - 8)) {
			case 0:
				if(v329) {
					bs329 |= 128;
				} else {
					bs329 &= -129;
				}
				break;
			case 1:
				if(v329) {
					bs329 |= 64;
				} else {
					bs329 &= -65;
				}
				break;
			case 2:
				if(v329) {
					bs329 |= 32;
				} else {
					bs329 &= -33;
				}
				break;
			case 3:
				if(v329) {
					bs329 |= 16;
				} else {
					bs329 &= -17;
				}
				break;
			case 4:
				if(v329) {
					bs329 |= 8;
				} else {
					bs329 &= -9;
				}
				break;
			case 5:
				if(v329) {
					bs329 |= 4;
				} else {
					bs329 &= -5;
				}
				break;
			case 6:
				if(v329) {
					bs329 |= 2;
				} else {
					bs329 &= -3;
				}
				break;
			case 7:
				if(v329) {
					bs329 |= 1;
				} else {
					bs329 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs329;
		var this331 = 0;
		var bs330 = this331;
		var l330 = "*   *".length;
		var _g1330 = 0;
		var _g430 = l330;
		while(_g1330 < _g430) {
			var i330 = _g1330++;
			var no330 = "*   *".charCodeAt(i330);
			if(no330 == null) {
				break;
			}
			var v330;
			switch(no330) {
			case 32:
				v330 = false;
				break;
			case 42:
				v330 = true;
				break;
			case 48:
				v330 = false;
				break;
			case 49:
				v330 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i330)));
			}
			switch(i330 - (l330 - 8)) {
			case 0:
				if(v330) {
					bs330 |= 128;
				} else {
					bs330 &= -129;
				}
				break;
			case 1:
				if(v330) {
					bs330 |= 64;
				} else {
					bs330 &= -65;
				}
				break;
			case 2:
				if(v330) {
					bs330 |= 32;
				} else {
					bs330 &= -33;
				}
				break;
			case 3:
				if(v330) {
					bs330 |= 16;
				} else {
					bs330 &= -17;
				}
				break;
			case 4:
				if(v330) {
					bs330 |= 8;
				} else {
					bs330 &= -9;
				}
				break;
			case 5:
				if(v330) {
					bs330 |= 4;
				} else {
					bs330 &= -5;
				}
				break;
			case 6:
				if(v330) {
					bs330 |= 2;
				} else {
					bs330 &= -3;
				}
				break;
			case 7:
				if(v330) {
					bs330 |= 1;
				} else {
					bs330 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs330;
		var this332 = 0;
		var bs331 = this332;
		var l331 = "*   *".length;
		var _g1331 = 0;
		var _g431 = l331;
		while(_g1331 < _g431) {
			var i331 = _g1331++;
			var no331 = "*   *".charCodeAt(i331);
			if(no331 == null) {
				break;
			}
			var v331;
			switch(no331) {
			case 32:
				v331 = false;
				break;
			case 42:
				v331 = true;
				break;
			case 48:
				v331 = false;
				break;
			case 49:
				v331 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i331)));
			}
			switch(i331 - (l331 - 8)) {
			case 0:
				if(v331) {
					bs331 |= 128;
				} else {
					bs331 &= -129;
				}
				break;
			case 1:
				if(v331) {
					bs331 |= 64;
				} else {
					bs331 &= -65;
				}
				break;
			case 2:
				if(v331) {
					bs331 |= 32;
				} else {
					bs331 &= -33;
				}
				break;
			case 3:
				if(v331) {
					bs331 |= 16;
				} else {
					bs331 &= -17;
				}
				break;
			case 4:
				if(v331) {
					bs331 |= 8;
				} else {
					bs331 &= -9;
				}
				break;
			case 5:
				if(v331) {
					bs331 |= 4;
				} else {
					bs331 &= -5;
				}
				break;
			case 6:
				if(v331) {
					bs331 |= 2;
				} else {
					bs331 &= -3;
				}
				break;
			case 7:
				if(v331) {
					bs331 |= 1;
				} else {
					bs331 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs331;
		var this333 = 0;
		var bs332 = this333;
		var l332 = "*   *".length;
		var _g1332 = 0;
		var _g432 = l332;
		while(_g1332 < _g432) {
			var i332 = _g1332++;
			var no332 = "*   *".charCodeAt(i332);
			if(no332 == null) {
				break;
			}
			var v332;
			switch(no332) {
			case 32:
				v332 = false;
				break;
			case 42:
				v332 = true;
				break;
			case 48:
				v332 = false;
				break;
			case 49:
				v332 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i332)));
			}
			switch(i332 - (l332 - 8)) {
			case 0:
				if(v332) {
					bs332 |= 128;
				} else {
					bs332 &= -129;
				}
				break;
			case 1:
				if(v332) {
					bs332 |= 64;
				} else {
					bs332 &= -65;
				}
				break;
			case 2:
				if(v332) {
					bs332 |= 32;
				} else {
					bs332 &= -33;
				}
				break;
			case 3:
				if(v332) {
					bs332 |= 16;
				} else {
					bs332 &= -17;
				}
				break;
			case 4:
				if(v332) {
					bs332 |= 8;
				} else {
					bs332 &= -9;
				}
				break;
			case 5:
				if(v332) {
					bs332 |= 4;
				} else {
					bs332 &= -5;
				}
				break;
			case 6:
				if(v332) {
					bs332 |= 2;
				} else {
					bs332 &= -3;
				}
				break;
			case 7:
				if(v332) {
					bs332 |= 1;
				} else {
					bs332 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs332;
		var this334 = 0;
		var bs333 = this334;
		var l333 = "*   *".length;
		var _g1333 = 0;
		var _g433 = l333;
		while(_g1333 < _g433) {
			var i333 = _g1333++;
			var no333 = "*   *".charCodeAt(i333);
			if(no333 == null) {
				break;
			}
			var v333;
			switch(no333) {
			case 32:
				v333 = false;
				break;
			case 42:
				v333 = true;
				break;
			case 48:
				v333 = false;
				break;
			case 49:
				v333 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i333)));
			}
			switch(i333 - (l333 - 8)) {
			case 0:
				if(v333) {
					bs333 |= 128;
				} else {
					bs333 &= -129;
				}
				break;
			case 1:
				if(v333) {
					bs333 |= 64;
				} else {
					bs333 &= -65;
				}
				break;
			case 2:
				if(v333) {
					bs333 |= 32;
				} else {
					bs333 &= -33;
				}
				break;
			case 3:
				if(v333) {
					bs333 |= 16;
				} else {
					bs333 &= -17;
				}
				break;
			case 4:
				if(v333) {
					bs333 |= 8;
				} else {
					bs333 &= -9;
				}
				break;
			case 5:
				if(v333) {
					bs333 |= 4;
				} else {
					bs333 &= -5;
				}
				break;
			case 6:
				if(v333) {
					bs333 |= 2;
				} else {
					bs333 &= -3;
				}
				break;
			case 7:
				if(v333) {
					bs333 |= 1;
				} else {
					bs333 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs333;
		var this335 = 0;
		var bs334 = this335;
		var l334 = "*   *".length;
		var _g1334 = 0;
		var _g434 = l334;
		while(_g1334 < _g434) {
			var i334 = _g1334++;
			var no334 = "*   *".charCodeAt(i334);
			if(no334 == null) {
				break;
			}
			var v334;
			switch(no334) {
			case 32:
				v334 = false;
				break;
			case 42:
				v334 = true;
				break;
			case 48:
				v334 = false;
				break;
			case 49:
				v334 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i334)));
			}
			switch(i334 - (l334 - 8)) {
			case 0:
				if(v334) {
					bs334 |= 128;
				} else {
					bs334 &= -129;
				}
				break;
			case 1:
				if(v334) {
					bs334 |= 64;
				} else {
					bs334 &= -65;
				}
				break;
			case 2:
				if(v334) {
					bs334 |= 32;
				} else {
					bs334 &= -33;
				}
				break;
			case 3:
				if(v334) {
					bs334 |= 16;
				} else {
					bs334 &= -17;
				}
				break;
			case 4:
				if(v334) {
					bs334 |= 8;
				} else {
					bs334 &= -9;
				}
				break;
			case 5:
				if(v334) {
					bs334 |= 4;
				} else {
					bs334 &= -5;
				}
				break;
			case 6:
				if(v334) {
					bs334 |= 2;
				} else {
					bs334 &= -3;
				}
				break;
			case 7:
				if(v334) {
					bs334 |= 1;
				} else {
					bs334 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs334;
		var this336 = 0;
		var bs335 = this336;
		var l335 = " *** ".length;
		var _g1335 = 0;
		var _g435 = l335;
		while(_g1335 < _g435) {
			var i335 = _g1335++;
			var no335 = " *** ".charCodeAt(i335);
			if(no335 == null) {
				break;
			}
			var v335;
			switch(no335) {
			case 32:
				v335 = false;
				break;
			case 42:
				v335 = true;
				break;
			case 48:
				v335 = false;
				break;
			case 49:
				v335 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i335)));
			}
			switch(i335 - (l335 - 8)) {
			case 0:
				if(v335) {
					bs335 |= 128;
				} else {
					bs335 &= -129;
				}
				break;
			case 1:
				if(v335) {
					bs335 |= 64;
				} else {
					bs335 &= -65;
				}
				break;
			case 2:
				if(v335) {
					bs335 |= 32;
				} else {
					bs335 &= -33;
				}
				break;
			case 3:
				if(v335) {
					bs335 |= 16;
				} else {
					bs335 &= -17;
				}
				break;
			case 4:
				if(v335) {
					bs335 |= 8;
				} else {
					bs335 &= -9;
				}
				break;
			case 5:
				if(v335) {
					bs335 |= 4;
				} else {
					bs335 &= -5;
				}
				break;
			case 6:
				if(v335) {
					bs335 |= 2;
				} else {
					bs335 &= -3;
				}
				break;
			case 7:
				if(v335) {
					bs335 |= 1;
				} else {
					bs335 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs335;
		break;
	case 80:
		var this337 = 0;
		var bs336 = this337;
		var l336 = "**** ".length;
		var _g1336 = 0;
		var _g436 = l336;
		while(_g1336 < _g436) {
			var i336 = _g1336++;
			var no336 = "**** ".charCodeAt(i336);
			if(no336 == null) {
				break;
			}
			var v336;
			switch(no336) {
			case 32:
				v336 = false;
				break;
			case 42:
				v336 = true;
				break;
			case 48:
				v336 = false;
				break;
			case 49:
				v336 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i336)));
			}
			switch(i336 - (l336 - 8)) {
			case 0:
				if(v336) {
					bs336 |= 128;
				} else {
					bs336 &= -129;
				}
				break;
			case 1:
				if(v336) {
					bs336 |= 64;
				} else {
					bs336 &= -65;
				}
				break;
			case 2:
				if(v336) {
					bs336 |= 32;
				} else {
					bs336 &= -33;
				}
				break;
			case 3:
				if(v336) {
					bs336 |= 16;
				} else {
					bs336 &= -17;
				}
				break;
			case 4:
				if(v336) {
					bs336 |= 8;
				} else {
					bs336 &= -9;
				}
				break;
			case 5:
				if(v336) {
					bs336 |= 4;
				} else {
					bs336 &= -5;
				}
				break;
			case 6:
				if(v336) {
					bs336 |= 2;
				} else {
					bs336 &= -3;
				}
				break;
			case 7:
				if(v336) {
					bs336 |= 1;
				} else {
					bs336 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs336;
		var this338 = 0;
		var bs337 = this338;
		var l337 = "*   *".length;
		var _g1337 = 0;
		var _g437 = l337;
		while(_g1337 < _g437) {
			var i337 = _g1337++;
			var no337 = "*   *".charCodeAt(i337);
			if(no337 == null) {
				break;
			}
			var v337;
			switch(no337) {
			case 32:
				v337 = false;
				break;
			case 42:
				v337 = true;
				break;
			case 48:
				v337 = false;
				break;
			case 49:
				v337 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i337)));
			}
			switch(i337 - (l337 - 8)) {
			case 0:
				if(v337) {
					bs337 |= 128;
				} else {
					bs337 &= -129;
				}
				break;
			case 1:
				if(v337) {
					bs337 |= 64;
				} else {
					bs337 &= -65;
				}
				break;
			case 2:
				if(v337) {
					bs337 |= 32;
				} else {
					bs337 &= -33;
				}
				break;
			case 3:
				if(v337) {
					bs337 |= 16;
				} else {
					bs337 &= -17;
				}
				break;
			case 4:
				if(v337) {
					bs337 |= 8;
				} else {
					bs337 &= -9;
				}
				break;
			case 5:
				if(v337) {
					bs337 |= 4;
				} else {
					bs337 &= -5;
				}
				break;
			case 6:
				if(v337) {
					bs337 |= 2;
				} else {
					bs337 &= -3;
				}
				break;
			case 7:
				if(v337) {
					bs337 |= 1;
				} else {
					bs337 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs337;
		var this339 = 0;
		var bs338 = this339;
		var l338 = "*   *".length;
		var _g1338 = 0;
		var _g438 = l338;
		while(_g1338 < _g438) {
			var i338 = _g1338++;
			var no338 = "*   *".charCodeAt(i338);
			if(no338 == null) {
				break;
			}
			var v338;
			switch(no338) {
			case 32:
				v338 = false;
				break;
			case 42:
				v338 = true;
				break;
			case 48:
				v338 = false;
				break;
			case 49:
				v338 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i338)));
			}
			switch(i338 - (l338 - 8)) {
			case 0:
				if(v338) {
					bs338 |= 128;
				} else {
					bs338 &= -129;
				}
				break;
			case 1:
				if(v338) {
					bs338 |= 64;
				} else {
					bs338 &= -65;
				}
				break;
			case 2:
				if(v338) {
					bs338 |= 32;
				} else {
					bs338 &= -33;
				}
				break;
			case 3:
				if(v338) {
					bs338 |= 16;
				} else {
					bs338 &= -17;
				}
				break;
			case 4:
				if(v338) {
					bs338 |= 8;
				} else {
					bs338 &= -9;
				}
				break;
			case 5:
				if(v338) {
					bs338 |= 4;
				} else {
					bs338 &= -5;
				}
				break;
			case 6:
				if(v338) {
					bs338 |= 2;
				} else {
					bs338 &= -3;
				}
				break;
			case 7:
				if(v338) {
					bs338 |= 1;
				} else {
					bs338 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs338;
		var this340 = 0;
		var bs339 = this340;
		var l339 = "**** ".length;
		var _g1339 = 0;
		var _g439 = l339;
		while(_g1339 < _g439) {
			var i339 = _g1339++;
			var no339 = "**** ".charCodeAt(i339);
			if(no339 == null) {
				break;
			}
			var v339;
			switch(no339) {
			case 32:
				v339 = false;
				break;
			case 42:
				v339 = true;
				break;
			case 48:
				v339 = false;
				break;
			case 49:
				v339 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i339)));
			}
			switch(i339 - (l339 - 8)) {
			case 0:
				if(v339) {
					bs339 |= 128;
				} else {
					bs339 &= -129;
				}
				break;
			case 1:
				if(v339) {
					bs339 |= 64;
				} else {
					bs339 &= -65;
				}
				break;
			case 2:
				if(v339) {
					bs339 |= 32;
				} else {
					bs339 &= -33;
				}
				break;
			case 3:
				if(v339) {
					bs339 |= 16;
				} else {
					bs339 &= -17;
				}
				break;
			case 4:
				if(v339) {
					bs339 |= 8;
				} else {
					bs339 &= -9;
				}
				break;
			case 5:
				if(v339) {
					bs339 |= 4;
				} else {
					bs339 &= -5;
				}
				break;
			case 6:
				if(v339) {
					bs339 |= 2;
				} else {
					bs339 &= -3;
				}
				break;
			case 7:
				if(v339) {
					bs339 |= 1;
				} else {
					bs339 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs339;
		var this341 = 0;
		var bs340 = this341;
		var l340 = "*    ".length;
		var _g1340 = 0;
		var _g440 = l340;
		while(_g1340 < _g440) {
			var i340 = _g1340++;
			var no340 = "*    ".charCodeAt(i340);
			if(no340 == null) {
				break;
			}
			var v340;
			switch(no340) {
			case 32:
				v340 = false;
				break;
			case 42:
				v340 = true;
				break;
			case 48:
				v340 = false;
				break;
			case 49:
				v340 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i340)));
			}
			switch(i340 - (l340 - 8)) {
			case 0:
				if(v340) {
					bs340 |= 128;
				} else {
					bs340 &= -129;
				}
				break;
			case 1:
				if(v340) {
					bs340 |= 64;
				} else {
					bs340 &= -65;
				}
				break;
			case 2:
				if(v340) {
					bs340 |= 32;
				} else {
					bs340 &= -33;
				}
				break;
			case 3:
				if(v340) {
					bs340 |= 16;
				} else {
					bs340 &= -17;
				}
				break;
			case 4:
				if(v340) {
					bs340 |= 8;
				} else {
					bs340 &= -9;
				}
				break;
			case 5:
				if(v340) {
					bs340 |= 4;
				} else {
					bs340 &= -5;
				}
				break;
			case 6:
				if(v340) {
					bs340 |= 2;
				} else {
					bs340 &= -3;
				}
				break;
			case 7:
				if(v340) {
					bs340 |= 1;
				} else {
					bs340 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs340;
		var this342 = 0;
		var bs341 = this342;
		var l341 = "*    ".length;
		var _g1341 = 0;
		var _g441 = l341;
		while(_g1341 < _g441) {
			var i341 = _g1341++;
			var no341 = "*    ".charCodeAt(i341);
			if(no341 == null) {
				break;
			}
			var v341;
			switch(no341) {
			case 32:
				v341 = false;
				break;
			case 42:
				v341 = true;
				break;
			case 48:
				v341 = false;
				break;
			case 49:
				v341 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i341)));
			}
			switch(i341 - (l341 - 8)) {
			case 0:
				if(v341) {
					bs341 |= 128;
				} else {
					bs341 &= -129;
				}
				break;
			case 1:
				if(v341) {
					bs341 |= 64;
				} else {
					bs341 &= -65;
				}
				break;
			case 2:
				if(v341) {
					bs341 |= 32;
				} else {
					bs341 &= -33;
				}
				break;
			case 3:
				if(v341) {
					bs341 |= 16;
				} else {
					bs341 &= -17;
				}
				break;
			case 4:
				if(v341) {
					bs341 |= 8;
				} else {
					bs341 &= -9;
				}
				break;
			case 5:
				if(v341) {
					bs341 |= 4;
				} else {
					bs341 &= -5;
				}
				break;
			case 6:
				if(v341) {
					bs341 |= 2;
				} else {
					bs341 &= -3;
				}
				break;
			case 7:
				if(v341) {
					bs341 |= 1;
				} else {
					bs341 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs341;
		var this343 = 0;
		var bs342 = this343;
		var l342 = "*    ".length;
		var _g1342 = 0;
		var _g442 = l342;
		while(_g1342 < _g442) {
			var i342 = _g1342++;
			var no342 = "*    ".charCodeAt(i342);
			if(no342 == null) {
				break;
			}
			var v342;
			switch(no342) {
			case 32:
				v342 = false;
				break;
			case 42:
				v342 = true;
				break;
			case 48:
				v342 = false;
				break;
			case 49:
				v342 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i342)));
			}
			switch(i342 - (l342 - 8)) {
			case 0:
				if(v342) {
					bs342 |= 128;
				} else {
					bs342 &= -129;
				}
				break;
			case 1:
				if(v342) {
					bs342 |= 64;
				} else {
					bs342 &= -65;
				}
				break;
			case 2:
				if(v342) {
					bs342 |= 32;
				} else {
					bs342 &= -33;
				}
				break;
			case 3:
				if(v342) {
					bs342 |= 16;
				} else {
					bs342 &= -17;
				}
				break;
			case 4:
				if(v342) {
					bs342 |= 8;
				} else {
					bs342 &= -9;
				}
				break;
			case 5:
				if(v342) {
					bs342 |= 4;
				} else {
					bs342 &= -5;
				}
				break;
			case 6:
				if(v342) {
					bs342 |= 2;
				} else {
					bs342 &= -3;
				}
				break;
			case 7:
				if(v342) {
					bs342 |= 1;
				} else {
					bs342 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs342;
		break;
	case 81:
		var this344 = 0;
		var bs343 = this344;
		var l343 = " *** ".length;
		var _g1343 = 0;
		var _g443 = l343;
		while(_g1343 < _g443) {
			var i343 = _g1343++;
			var no343 = " *** ".charCodeAt(i343);
			if(no343 == null) {
				break;
			}
			var v343;
			switch(no343) {
			case 32:
				v343 = false;
				break;
			case 42:
				v343 = true;
				break;
			case 48:
				v343 = false;
				break;
			case 49:
				v343 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i343)));
			}
			switch(i343 - (l343 - 8)) {
			case 0:
				if(v343) {
					bs343 |= 128;
				} else {
					bs343 &= -129;
				}
				break;
			case 1:
				if(v343) {
					bs343 |= 64;
				} else {
					bs343 &= -65;
				}
				break;
			case 2:
				if(v343) {
					bs343 |= 32;
				} else {
					bs343 &= -33;
				}
				break;
			case 3:
				if(v343) {
					bs343 |= 16;
				} else {
					bs343 &= -17;
				}
				break;
			case 4:
				if(v343) {
					bs343 |= 8;
				} else {
					bs343 &= -9;
				}
				break;
			case 5:
				if(v343) {
					bs343 |= 4;
				} else {
					bs343 &= -5;
				}
				break;
			case 6:
				if(v343) {
					bs343 |= 2;
				} else {
					bs343 &= -3;
				}
				break;
			case 7:
				if(v343) {
					bs343 |= 1;
				} else {
					bs343 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs343;
		var this345 = 0;
		var bs344 = this345;
		var l344 = "*   *".length;
		var _g1344 = 0;
		var _g444 = l344;
		while(_g1344 < _g444) {
			var i344 = _g1344++;
			var no344 = "*   *".charCodeAt(i344);
			if(no344 == null) {
				break;
			}
			var v344;
			switch(no344) {
			case 32:
				v344 = false;
				break;
			case 42:
				v344 = true;
				break;
			case 48:
				v344 = false;
				break;
			case 49:
				v344 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i344)));
			}
			switch(i344 - (l344 - 8)) {
			case 0:
				if(v344) {
					bs344 |= 128;
				} else {
					bs344 &= -129;
				}
				break;
			case 1:
				if(v344) {
					bs344 |= 64;
				} else {
					bs344 &= -65;
				}
				break;
			case 2:
				if(v344) {
					bs344 |= 32;
				} else {
					bs344 &= -33;
				}
				break;
			case 3:
				if(v344) {
					bs344 |= 16;
				} else {
					bs344 &= -17;
				}
				break;
			case 4:
				if(v344) {
					bs344 |= 8;
				} else {
					bs344 &= -9;
				}
				break;
			case 5:
				if(v344) {
					bs344 |= 4;
				} else {
					bs344 &= -5;
				}
				break;
			case 6:
				if(v344) {
					bs344 |= 2;
				} else {
					bs344 &= -3;
				}
				break;
			case 7:
				if(v344) {
					bs344 |= 1;
				} else {
					bs344 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs344;
		var this346 = 0;
		var bs345 = this346;
		var l345 = "*   *".length;
		var _g1345 = 0;
		var _g445 = l345;
		while(_g1345 < _g445) {
			var i345 = _g1345++;
			var no345 = "*   *".charCodeAt(i345);
			if(no345 == null) {
				break;
			}
			var v345;
			switch(no345) {
			case 32:
				v345 = false;
				break;
			case 42:
				v345 = true;
				break;
			case 48:
				v345 = false;
				break;
			case 49:
				v345 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i345)));
			}
			switch(i345 - (l345 - 8)) {
			case 0:
				if(v345) {
					bs345 |= 128;
				} else {
					bs345 &= -129;
				}
				break;
			case 1:
				if(v345) {
					bs345 |= 64;
				} else {
					bs345 &= -65;
				}
				break;
			case 2:
				if(v345) {
					bs345 |= 32;
				} else {
					bs345 &= -33;
				}
				break;
			case 3:
				if(v345) {
					bs345 |= 16;
				} else {
					bs345 &= -17;
				}
				break;
			case 4:
				if(v345) {
					bs345 |= 8;
				} else {
					bs345 &= -9;
				}
				break;
			case 5:
				if(v345) {
					bs345 |= 4;
				} else {
					bs345 &= -5;
				}
				break;
			case 6:
				if(v345) {
					bs345 |= 2;
				} else {
					bs345 &= -3;
				}
				break;
			case 7:
				if(v345) {
					bs345 |= 1;
				} else {
					bs345 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs345;
		var this347 = 0;
		var bs346 = this347;
		var l346 = "*   *".length;
		var _g1346 = 0;
		var _g446 = l346;
		while(_g1346 < _g446) {
			var i346 = _g1346++;
			var no346 = "*   *".charCodeAt(i346);
			if(no346 == null) {
				break;
			}
			var v346;
			switch(no346) {
			case 32:
				v346 = false;
				break;
			case 42:
				v346 = true;
				break;
			case 48:
				v346 = false;
				break;
			case 49:
				v346 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i346)));
			}
			switch(i346 - (l346 - 8)) {
			case 0:
				if(v346) {
					bs346 |= 128;
				} else {
					bs346 &= -129;
				}
				break;
			case 1:
				if(v346) {
					bs346 |= 64;
				} else {
					bs346 &= -65;
				}
				break;
			case 2:
				if(v346) {
					bs346 |= 32;
				} else {
					bs346 &= -33;
				}
				break;
			case 3:
				if(v346) {
					bs346 |= 16;
				} else {
					bs346 &= -17;
				}
				break;
			case 4:
				if(v346) {
					bs346 |= 8;
				} else {
					bs346 &= -9;
				}
				break;
			case 5:
				if(v346) {
					bs346 |= 4;
				} else {
					bs346 &= -5;
				}
				break;
			case 6:
				if(v346) {
					bs346 |= 2;
				} else {
					bs346 &= -3;
				}
				break;
			case 7:
				if(v346) {
					bs346 |= 1;
				} else {
					bs346 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs346;
		var this348 = 0;
		var bs347 = this348;
		var l347 = "* * *".length;
		var _g1347 = 0;
		var _g447 = l347;
		while(_g1347 < _g447) {
			var i347 = _g1347++;
			var no347 = "* * *".charCodeAt(i347);
			if(no347 == null) {
				break;
			}
			var v347;
			switch(no347) {
			case 32:
				v347 = false;
				break;
			case 42:
				v347 = true;
				break;
			case 48:
				v347 = false;
				break;
			case 49:
				v347 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i347)));
			}
			switch(i347 - (l347 - 8)) {
			case 0:
				if(v347) {
					bs347 |= 128;
				} else {
					bs347 &= -129;
				}
				break;
			case 1:
				if(v347) {
					bs347 |= 64;
				} else {
					bs347 &= -65;
				}
				break;
			case 2:
				if(v347) {
					bs347 |= 32;
				} else {
					bs347 &= -33;
				}
				break;
			case 3:
				if(v347) {
					bs347 |= 16;
				} else {
					bs347 &= -17;
				}
				break;
			case 4:
				if(v347) {
					bs347 |= 8;
				} else {
					bs347 &= -9;
				}
				break;
			case 5:
				if(v347) {
					bs347 |= 4;
				} else {
					bs347 &= -5;
				}
				break;
			case 6:
				if(v347) {
					bs347 |= 2;
				} else {
					bs347 &= -3;
				}
				break;
			case 7:
				if(v347) {
					bs347 |= 1;
				} else {
					bs347 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs347;
		var this349 = 0;
		var bs348 = this349;
		var l348 = "*  * ".length;
		var _g1348 = 0;
		var _g448 = l348;
		while(_g1348 < _g448) {
			var i348 = _g1348++;
			var no348 = "*  * ".charCodeAt(i348);
			if(no348 == null) {
				break;
			}
			var v348;
			switch(no348) {
			case 32:
				v348 = false;
				break;
			case 42:
				v348 = true;
				break;
			case 48:
				v348 = false;
				break;
			case 49:
				v348 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i348)));
			}
			switch(i348 - (l348 - 8)) {
			case 0:
				if(v348) {
					bs348 |= 128;
				} else {
					bs348 &= -129;
				}
				break;
			case 1:
				if(v348) {
					bs348 |= 64;
				} else {
					bs348 &= -65;
				}
				break;
			case 2:
				if(v348) {
					bs348 |= 32;
				} else {
					bs348 &= -33;
				}
				break;
			case 3:
				if(v348) {
					bs348 |= 16;
				} else {
					bs348 &= -17;
				}
				break;
			case 4:
				if(v348) {
					bs348 |= 8;
				} else {
					bs348 &= -9;
				}
				break;
			case 5:
				if(v348) {
					bs348 |= 4;
				} else {
					bs348 &= -5;
				}
				break;
			case 6:
				if(v348) {
					bs348 |= 2;
				} else {
					bs348 &= -3;
				}
				break;
			case 7:
				if(v348) {
					bs348 |= 1;
				} else {
					bs348 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs348;
		var this350 = 0;
		var bs349 = this350;
		var l349 = " ** *".length;
		var _g1349 = 0;
		var _g449 = l349;
		while(_g1349 < _g449) {
			var i349 = _g1349++;
			var no349 = " ** *".charCodeAt(i349);
			if(no349 == null) {
				break;
			}
			var v349;
			switch(no349) {
			case 32:
				v349 = false;
				break;
			case 42:
				v349 = true;
				break;
			case 48:
				v349 = false;
				break;
			case 49:
				v349 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i349)));
			}
			switch(i349 - (l349 - 8)) {
			case 0:
				if(v349) {
					bs349 |= 128;
				} else {
					bs349 &= -129;
				}
				break;
			case 1:
				if(v349) {
					bs349 |= 64;
				} else {
					bs349 &= -65;
				}
				break;
			case 2:
				if(v349) {
					bs349 |= 32;
				} else {
					bs349 &= -33;
				}
				break;
			case 3:
				if(v349) {
					bs349 |= 16;
				} else {
					bs349 &= -17;
				}
				break;
			case 4:
				if(v349) {
					bs349 |= 8;
				} else {
					bs349 &= -9;
				}
				break;
			case 5:
				if(v349) {
					bs349 |= 4;
				} else {
					bs349 &= -5;
				}
				break;
			case 6:
				if(v349) {
					bs349 |= 2;
				} else {
					bs349 &= -3;
				}
				break;
			case 7:
				if(v349) {
					bs349 |= 1;
				} else {
					bs349 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs349;
		break;
	case 82:
		var this351 = 0;
		var bs350 = this351;
		var l350 = "**** ".length;
		var _g1350 = 0;
		var _g450 = l350;
		while(_g1350 < _g450) {
			var i350 = _g1350++;
			var no350 = "**** ".charCodeAt(i350);
			if(no350 == null) {
				break;
			}
			var v350;
			switch(no350) {
			case 32:
				v350 = false;
				break;
			case 42:
				v350 = true;
				break;
			case 48:
				v350 = false;
				break;
			case 49:
				v350 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i350)));
			}
			switch(i350 - (l350 - 8)) {
			case 0:
				if(v350) {
					bs350 |= 128;
				} else {
					bs350 &= -129;
				}
				break;
			case 1:
				if(v350) {
					bs350 |= 64;
				} else {
					bs350 &= -65;
				}
				break;
			case 2:
				if(v350) {
					bs350 |= 32;
				} else {
					bs350 &= -33;
				}
				break;
			case 3:
				if(v350) {
					bs350 |= 16;
				} else {
					bs350 &= -17;
				}
				break;
			case 4:
				if(v350) {
					bs350 |= 8;
				} else {
					bs350 &= -9;
				}
				break;
			case 5:
				if(v350) {
					bs350 |= 4;
				} else {
					bs350 &= -5;
				}
				break;
			case 6:
				if(v350) {
					bs350 |= 2;
				} else {
					bs350 &= -3;
				}
				break;
			case 7:
				if(v350) {
					bs350 |= 1;
				} else {
					bs350 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs350;
		var this352 = 0;
		var bs351 = this352;
		var l351 = "*   *".length;
		var _g1351 = 0;
		var _g451 = l351;
		while(_g1351 < _g451) {
			var i351 = _g1351++;
			var no351 = "*   *".charCodeAt(i351);
			if(no351 == null) {
				break;
			}
			var v351;
			switch(no351) {
			case 32:
				v351 = false;
				break;
			case 42:
				v351 = true;
				break;
			case 48:
				v351 = false;
				break;
			case 49:
				v351 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i351)));
			}
			switch(i351 - (l351 - 8)) {
			case 0:
				if(v351) {
					bs351 |= 128;
				} else {
					bs351 &= -129;
				}
				break;
			case 1:
				if(v351) {
					bs351 |= 64;
				} else {
					bs351 &= -65;
				}
				break;
			case 2:
				if(v351) {
					bs351 |= 32;
				} else {
					bs351 &= -33;
				}
				break;
			case 3:
				if(v351) {
					bs351 |= 16;
				} else {
					bs351 &= -17;
				}
				break;
			case 4:
				if(v351) {
					bs351 |= 8;
				} else {
					bs351 &= -9;
				}
				break;
			case 5:
				if(v351) {
					bs351 |= 4;
				} else {
					bs351 &= -5;
				}
				break;
			case 6:
				if(v351) {
					bs351 |= 2;
				} else {
					bs351 &= -3;
				}
				break;
			case 7:
				if(v351) {
					bs351 |= 1;
				} else {
					bs351 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs351;
		var this353 = 0;
		var bs352 = this353;
		var l352 = "*   *".length;
		var _g1352 = 0;
		var _g452 = l352;
		while(_g1352 < _g452) {
			var i352 = _g1352++;
			var no352 = "*   *".charCodeAt(i352);
			if(no352 == null) {
				break;
			}
			var v352;
			switch(no352) {
			case 32:
				v352 = false;
				break;
			case 42:
				v352 = true;
				break;
			case 48:
				v352 = false;
				break;
			case 49:
				v352 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i352)));
			}
			switch(i352 - (l352 - 8)) {
			case 0:
				if(v352) {
					bs352 |= 128;
				} else {
					bs352 &= -129;
				}
				break;
			case 1:
				if(v352) {
					bs352 |= 64;
				} else {
					bs352 &= -65;
				}
				break;
			case 2:
				if(v352) {
					bs352 |= 32;
				} else {
					bs352 &= -33;
				}
				break;
			case 3:
				if(v352) {
					bs352 |= 16;
				} else {
					bs352 &= -17;
				}
				break;
			case 4:
				if(v352) {
					bs352 |= 8;
				} else {
					bs352 &= -9;
				}
				break;
			case 5:
				if(v352) {
					bs352 |= 4;
				} else {
					bs352 &= -5;
				}
				break;
			case 6:
				if(v352) {
					bs352 |= 2;
				} else {
					bs352 &= -3;
				}
				break;
			case 7:
				if(v352) {
					bs352 |= 1;
				} else {
					bs352 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs352;
		var this354 = 0;
		var bs353 = this354;
		var l353 = "**** ".length;
		var _g1353 = 0;
		var _g453 = l353;
		while(_g1353 < _g453) {
			var i353 = _g1353++;
			var no353 = "**** ".charCodeAt(i353);
			if(no353 == null) {
				break;
			}
			var v353;
			switch(no353) {
			case 32:
				v353 = false;
				break;
			case 42:
				v353 = true;
				break;
			case 48:
				v353 = false;
				break;
			case 49:
				v353 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i353)));
			}
			switch(i353 - (l353 - 8)) {
			case 0:
				if(v353) {
					bs353 |= 128;
				} else {
					bs353 &= -129;
				}
				break;
			case 1:
				if(v353) {
					bs353 |= 64;
				} else {
					bs353 &= -65;
				}
				break;
			case 2:
				if(v353) {
					bs353 |= 32;
				} else {
					bs353 &= -33;
				}
				break;
			case 3:
				if(v353) {
					bs353 |= 16;
				} else {
					bs353 &= -17;
				}
				break;
			case 4:
				if(v353) {
					bs353 |= 8;
				} else {
					bs353 &= -9;
				}
				break;
			case 5:
				if(v353) {
					bs353 |= 4;
				} else {
					bs353 &= -5;
				}
				break;
			case 6:
				if(v353) {
					bs353 |= 2;
				} else {
					bs353 &= -3;
				}
				break;
			case 7:
				if(v353) {
					bs353 |= 1;
				} else {
					bs353 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs353;
		var this355 = 0;
		var bs354 = this355;
		var l354 = "* *  ".length;
		var _g1354 = 0;
		var _g454 = l354;
		while(_g1354 < _g454) {
			var i354 = _g1354++;
			var no354 = "* *  ".charCodeAt(i354);
			if(no354 == null) {
				break;
			}
			var v354;
			switch(no354) {
			case 32:
				v354 = false;
				break;
			case 42:
				v354 = true;
				break;
			case 48:
				v354 = false;
				break;
			case 49:
				v354 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i354)));
			}
			switch(i354 - (l354 - 8)) {
			case 0:
				if(v354) {
					bs354 |= 128;
				} else {
					bs354 &= -129;
				}
				break;
			case 1:
				if(v354) {
					bs354 |= 64;
				} else {
					bs354 &= -65;
				}
				break;
			case 2:
				if(v354) {
					bs354 |= 32;
				} else {
					bs354 &= -33;
				}
				break;
			case 3:
				if(v354) {
					bs354 |= 16;
				} else {
					bs354 &= -17;
				}
				break;
			case 4:
				if(v354) {
					bs354 |= 8;
				} else {
					bs354 &= -9;
				}
				break;
			case 5:
				if(v354) {
					bs354 |= 4;
				} else {
					bs354 &= -5;
				}
				break;
			case 6:
				if(v354) {
					bs354 |= 2;
				} else {
					bs354 &= -3;
				}
				break;
			case 7:
				if(v354) {
					bs354 |= 1;
				} else {
					bs354 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs354;
		var this356 = 0;
		var bs355 = this356;
		var l355 = "*  * ".length;
		var _g1355 = 0;
		var _g455 = l355;
		while(_g1355 < _g455) {
			var i355 = _g1355++;
			var no355 = "*  * ".charCodeAt(i355);
			if(no355 == null) {
				break;
			}
			var v355;
			switch(no355) {
			case 32:
				v355 = false;
				break;
			case 42:
				v355 = true;
				break;
			case 48:
				v355 = false;
				break;
			case 49:
				v355 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i355)));
			}
			switch(i355 - (l355 - 8)) {
			case 0:
				if(v355) {
					bs355 |= 128;
				} else {
					bs355 &= -129;
				}
				break;
			case 1:
				if(v355) {
					bs355 |= 64;
				} else {
					bs355 &= -65;
				}
				break;
			case 2:
				if(v355) {
					bs355 |= 32;
				} else {
					bs355 &= -33;
				}
				break;
			case 3:
				if(v355) {
					bs355 |= 16;
				} else {
					bs355 &= -17;
				}
				break;
			case 4:
				if(v355) {
					bs355 |= 8;
				} else {
					bs355 &= -9;
				}
				break;
			case 5:
				if(v355) {
					bs355 |= 4;
				} else {
					bs355 &= -5;
				}
				break;
			case 6:
				if(v355) {
					bs355 |= 2;
				} else {
					bs355 &= -3;
				}
				break;
			case 7:
				if(v355) {
					bs355 |= 1;
				} else {
					bs355 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs355;
		var this357 = 0;
		var bs356 = this357;
		var l356 = "*   *".length;
		var _g1356 = 0;
		var _g456 = l356;
		while(_g1356 < _g456) {
			var i356 = _g1356++;
			var no356 = "*   *".charCodeAt(i356);
			if(no356 == null) {
				break;
			}
			var v356;
			switch(no356) {
			case 32:
				v356 = false;
				break;
			case 42:
				v356 = true;
				break;
			case 48:
				v356 = false;
				break;
			case 49:
				v356 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i356)));
			}
			switch(i356 - (l356 - 8)) {
			case 0:
				if(v356) {
					bs356 |= 128;
				} else {
					bs356 &= -129;
				}
				break;
			case 1:
				if(v356) {
					bs356 |= 64;
				} else {
					bs356 &= -65;
				}
				break;
			case 2:
				if(v356) {
					bs356 |= 32;
				} else {
					bs356 &= -33;
				}
				break;
			case 3:
				if(v356) {
					bs356 |= 16;
				} else {
					bs356 &= -17;
				}
				break;
			case 4:
				if(v356) {
					bs356 |= 8;
				} else {
					bs356 &= -9;
				}
				break;
			case 5:
				if(v356) {
					bs356 |= 4;
				} else {
					bs356 &= -5;
				}
				break;
			case 6:
				if(v356) {
					bs356 |= 2;
				} else {
					bs356 &= -3;
				}
				break;
			case 7:
				if(v356) {
					bs356 |= 1;
				} else {
					bs356 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs356;
		break;
	case 83:
		var this358 = 0;
		var bs357 = this358;
		var l357 = " ****".length;
		var _g1357 = 0;
		var _g457 = l357;
		while(_g1357 < _g457) {
			var i357 = _g1357++;
			var no357 = " ****".charCodeAt(i357);
			if(no357 == null) {
				break;
			}
			var v357;
			switch(no357) {
			case 32:
				v357 = false;
				break;
			case 42:
				v357 = true;
				break;
			case 48:
				v357 = false;
				break;
			case 49:
				v357 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i357)));
			}
			switch(i357 - (l357 - 8)) {
			case 0:
				if(v357) {
					bs357 |= 128;
				} else {
					bs357 &= -129;
				}
				break;
			case 1:
				if(v357) {
					bs357 |= 64;
				} else {
					bs357 &= -65;
				}
				break;
			case 2:
				if(v357) {
					bs357 |= 32;
				} else {
					bs357 &= -33;
				}
				break;
			case 3:
				if(v357) {
					bs357 |= 16;
				} else {
					bs357 &= -17;
				}
				break;
			case 4:
				if(v357) {
					bs357 |= 8;
				} else {
					bs357 &= -9;
				}
				break;
			case 5:
				if(v357) {
					bs357 |= 4;
				} else {
					bs357 &= -5;
				}
				break;
			case 6:
				if(v357) {
					bs357 |= 2;
				} else {
					bs357 &= -3;
				}
				break;
			case 7:
				if(v357) {
					bs357 |= 1;
				} else {
					bs357 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs357;
		var this359 = 0;
		var bs358 = this359;
		var l358 = "*    ".length;
		var _g1358 = 0;
		var _g458 = l358;
		while(_g1358 < _g458) {
			var i358 = _g1358++;
			var no358 = "*    ".charCodeAt(i358);
			if(no358 == null) {
				break;
			}
			var v358;
			switch(no358) {
			case 32:
				v358 = false;
				break;
			case 42:
				v358 = true;
				break;
			case 48:
				v358 = false;
				break;
			case 49:
				v358 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i358)));
			}
			switch(i358 - (l358 - 8)) {
			case 0:
				if(v358) {
					bs358 |= 128;
				} else {
					bs358 &= -129;
				}
				break;
			case 1:
				if(v358) {
					bs358 |= 64;
				} else {
					bs358 &= -65;
				}
				break;
			case 2:
				if(v358) {
					bs358 |= 32;
				} else {
					bs358 &= -33;
				}
				break;
			case 3:
				if(v358) {
					bs358 |= 16;
				} else {
					bs358 &= -17;
				}
				break;
			case 4:
				if(v358) {
					bs358 |= 8;
				} else {
					bs358 &= -9;
				}
				break;
			case 5:
				if(v358) {
					bs358 |= 4;
				} else {
					bs358 &= -5;
				}
				break;
			case 6:
				if(v358) {
					bs358 |= 2;
				} else {
					bs358 &= -3;
				}
				break;
			case 7:
				if(v358) {
					bs358 |= 1;
				} else {
					bs358 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs358;
		var this360 = 0;
		var bs359 = this360;
		var l359 = "*    ".length;
		var _g1359 = 0;
		var _g459 = l359;
		while(_g1359 < _g459) {
			var i359 = _g1359++;
			var no359 = "*    ".charCodeAt(i359);
			if(no359 == null) {
				break;
			}
			var v359;
			switch(no359) {
			case 32:
				v359 = false;
				break;
			case 42:
				v359 = true;
				break;
			case 48:
				v359 = false;
				break;
			case 49:
				v359 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i359)));
			}
			switch(i359 - (l359 - 8)) {
			case 0:
				if(v359) {
					bs359 |= 128;
				} else {
					bs359 &= -129;
				}
				break;
			case 1:
				if(v359) {
					bs359 |= 64;
				} else {
					bs359 &= -65;
				}
				break;
			case 2:
				if(v359) {
					bs359 |= 32;
				} else {
					bs359 &= -33;
				}
				break;
			case 3:
				if(v359) {
					bs359 |= 16;
				} else {
					bs359 &= -17;
				}
				break;
			case 4:
				if(v359) {
					bs359 |= 8;
				} else {
					bs359 &= -9;
				}
				break;
			case 5:
				if(v359) {
					bs359 |= 4;
				} else {
					bs359 &= -5;
				}
				break;
			case 6:
				if(v359) {
					bs359 |= 2;
				} else {
					bs359 &= -3;
				}
				break;
			case 7:
				if(v359) {
					bs359 |= 1;
				} else {
					bs359 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs359;
		var this361 = 0;
		var bs360 = this361;
		var l360 = " *** ".length;
		var _g1360 = 0;
		var _g460 = l360;
		while(_g1360 < _g460) {
			var i360 = _g1360++;
			var no360 = " *** ".charCodeAt(i360);
			if(no360 == null) {
				break;
			}
			var v360;
			switch(no360) {
			case 32:
				v360 = false;
				break;
			case 42:
				v360 = true;
				break;
			case 48:
				v360 = false;
				break;
			case 49:
				v360 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i360)));
			}
			switch(i360 - (l360 - 8)) {
			case 0:
				if(v360) {
					bs360 |= 128;
				} else {
					bs360 &= -129;
				}
				break;
			case 1:
				if(v360) {
					bs360 |= 64;
				} else {
					bs360 &= -65;
				}
				break;
			case 2:
				if(v360) {
					bs360 |= 32;
				} else {
					bs360 &= -33;
				}
				break;
			case 3:
				if(v360) {
					bs360 |= 16;
				} else {
					bs360 &= -17;
				}
				break;
			case 4:
				if(v360) {
					bs360 |= 8;
				} else {
					bs360 &= -9;
				}
				break;
			case 5:
				if(v360) {
					bs360 |= 4;
				} else {
					bs360 &= -5;
				}
				break;
			case 6:
				if(v360) {
					bs360 |= 2;
				} else {
					bs360 &= -3;
				}
				break;
			case 7:
				if(v360) {
					bs360 |= 1;
				} else {
					bs360 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs360;
		var this362 = 0;
		var bs361 = this362;
		var l361 = "    *".length;
		var _g1361 = 0;
		var _g461 = l361;
		while(_g1361 < _g461) {
			var i361 = _g1361++;
			var no361 = "    *".charCodeAt(i361);
			if(no361 == null) {
				break;
			}
			var v361;
			switch(no361) {
			case 32:
				v361 = false;
				break;
			case 42:
				v361 = true;
				break;
			case 48:
				v361 = false;
				break;
			case 49:
				v361 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i361)));
			}
			switch(i361 - (l361 - 8)) {
			case 0:
				if(v361) {
					bs361 |= 128;
				} else {
					bs361 &= -129;
				}
				break;
			case 1:
				if(v361) {
					bs361 |= 64;
				} else {
					bs361 &= -65;
				}
				break;
			case 2:
				if(v361) {
					bs361 |= 32;
				} else {
					bs361 &= -33;
				}
				break;
			case 3:
				if(v361) {
					bs361 |= 16;
				} else {
					bs361 &= -17;
				}
				break;
			case 4:
				if(v361) {
					bs361 |= 8;
				} else {
					bs361 &= -9;
				}
				break;
			case 5:
				if(v361) {
					bs361 |= 4;
				} else {
					bs361 &= -5;
				}
				break;
			case 6:
				if(v361) {
					bs361 |= 2;
				} else {
					bs361 &= -3;
				}
				break;
			case 7:
				if(v361) {
					bs361 |= 1;
				} else {
					bs361 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs361;
		var this363 = 0;
		var bs362 = this363;
		var l362 = "    *".length;
		var _g1362 = 0;
		var _g462 = l362;
		while(_g1362 < _g462) {
			var i362 = _g1362++;
			var no362 = "    *".charCodeAt(i362);
			if(no362 == null) {
				break;
			}
			var v362;
			switch(no362) {
			case 32:
				v362 = false;
				break;
			case 42:
				v362 = true;
				break;
			case 48:
				v362 = false;
				break;
			case 49:
				v362 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i362)));
			}
			switch(i362 - (l362 - 8)) {
			case 0:
				if(v362) {
					bs362 |= 128;
				} else {
					bs362 &= -129;
				}
				break;
			case 1:
				if(v362) {
					bs362 |= 64;
				} else {
					bs362 &= -65;
				}
				break;
			case 2:
				if(v362) {
					bs362 |= 32;
				} else {
					bs362 &= -33;
				}
				break;
			case 3:
				if(v362) {
					bs362 |= 16;
				} else {
					bs362 &= -17;
				}
				break;
			case 4:
				if(v362) {
					bs362 |= 8;
				} else {
					bs362 &= -9;
				}
				break;
			case 5:
				if(v362) {
					bs362 |= 4;
				} else {
					bs362 &= -5;
				}
				break;
			case 6:
				if(v362) {
					bs362 |= 2;
				} else {
					bs362 &= -3;
				}
				break;
			case 7:
				if(v362) {
					bs362 |= 1;
				} else {
					bs362 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs362;
		var this364 = 0;
		var bs363 = this364;
		var l363 = "**** ".length;
		var _g1363 = 0;
		var _g463 = l363;
		while(_g1363 < _g463) {
			var i363 = _g1363++;
			var no363 = "**** ".charCodeAt(i363);
			if(no363 == null) {
				break;
			}
			var v363;
			switch(no363) {
			case 32:
				v363 = false;
				break;
			case 42:
				v363 = true;
				break;
			case 48:
				v363 = false;
				break;
			case 49:
				v363 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i363)));
			}
			switch(i363 - (l363 - 8)) {
			case 0:
				if(v363) {
					bs363 |= 128;
				} else {
					bs363 &= -129;
				}
				break;
			case 1:
				if(v363) {
					bs363 |= 64;
				} else {
					bs363 &= -65;
				}
				break;
			case 2:
				if(v363) {
					bs363 |= 32;
				} else {
					bs363 &= -33;
				}
				break;
			case 3:
				if(v363) {
					bs363 |= 16;
				} else {
					bs363 &= -17;
				}
				break;
			case 4:
				if(v363) {
					bs363 |= 8;
				} else {
					bs363 &= -9;
				}
				break;
			case 5:
				if(v363) {
					bs363 |= 4;
				} else {
					bs363 &= -5;
				}
				break;
			case 6:
				if(v363) {
					bs363 |= 2;
				} else {
					bs363 &= -3;
				}
				break;
			case 7:
				if(v363) {
					bs363 |= 1;
				} else {
					bs363 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs363;
		break;
	case 84:
		var this365 = 0;
		var bs364 = this365;
		var l364 = "*****".length;
		var _g1364 = 0;
		var _g464 = l364;
		while(_g1364 < _g464) {
			var i364 = _g1364++;
			var no364 = "*****".charCodeAt(i364);
			if(no364 == null) {
				break;
			}
			var v364;
			switch(no364) {
			case 32:
				v364 = false;
				break;
			case 42:
				v364 = true;
				break;
			case 48:
				v364 = false;
				break;
			case 49:
				v364 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i364)));
			}
			switch(i364 - (l364 - 8)) {
			case 0:
				if(v364) {
					bs364 |= 128;
				} else {
					bs364 &= -129;
				}
				break;
			case 1:
				if(v364) {
					bs364 |= 64;
				} else {
					bs364 &= -65;
				}
				break;
			case 2:
				if(v364) {
					bs364 |= 32;
				} else {
					bs364 &= -33;
				}
				break;
			case 3:
				if(v364) {
					bs364 |= 16;
				} else {
					bs364 &= -17;
				}
				break;
			case 4:
				if(v364) {
					bs364 |= 8;
				} else {
					bs364 &= -9;
				}
				break;
			case 5:
				if(v364) {
					bs364 |= 4;
				} else {
					bs364 &= -5;
				}
				break;
			case 6:
				if(v364) {
					bs364 |= 2;
				} else {
					bs364 &= -3;
				}
				break;
			case 7:
				if(v364) {
					bs364 |= 1;
				} else {
					bs364 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs364;
		var this366 = 0;
		var bs365 = this366;
		var l365 = "  *  ".length;
		var _g1365 = 0;
		var _g465 = l365;
		while(_g1365 < _g465) {
			var i365 = _g1365++;
			var no365 = "  *  ".charCodeAt(i365);
			if(no365 == null) {
				break;
			}
			var v365;
			switch(no365) {
			case 32:
				v365 = false;
				break;
			case 42:
				v365 = true;
				break;
			case 48:
				v365 = false;
				break;
			case 49:
				v365 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i365)));
			}
			switch(i365 - (l365 - 8)) {
			case 0:
				if(v365) {
					bs365 |= 128;
				} else {
					bs365 &= -129;
				}
				break;
			case 1:
				if(v365) {
					bs365 |= 64;
				} else {
					bs365 &= -65;
				}
				break;
			case 2:
				if(v365) {
					bs365 |= 32;
				} else {
					bs365 &= -33;
				}
				break;
			case 3:
				if(v365) {
					bs365 |= 16;
				} else {
					bs365 &= -17;
				}
				break;
			case 4:
				if(v365) {
					bs365 |= 8;
				} else {
					bs365 &= -9;
				}
				break;
			case 5:
				if(v365) {
					bs365 |= 4;
				} else {
					bs365 &= -5;
				}
				break;
			case 6:
				if(v365) {
					bs365 |= 2;
				} else {
					bs365 &= -3;
				}
				break;
			case 7:
				if(v365) {
					bs365 |= 1;
				} else {
					bs365 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs365;
		var this367 = 0;
		var bs366 = this367;
		var l366 = "  *  ".length;
		var _g1366 = 0;
		var _g466 = l366;
		while(_g1366 < _g466) {
			var i366 = _g1366++;
			var no366 = "  *  ".charCodeAt(i366);
			if(no366 == null) {
				break;
			}
			var v366;
			switch(no366) {
			case 32:
				v366 = false;
				break;
			case 42:
				v366 = true;
				break;
			case 48:
				v366 = false;
				break;
			case 49:
				v366 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i366)));
			}
			switch(i366 - (l366 - 8)) {
			case 0:
				if(v366) {
					bs366 |= 128;
				} else {
					bs366 &= -129;
				}
				break;
			case 1:
				if(v366) {
					bs366 |= 64;
				} else {
					bs366 &= -65;
				}
				break;
			case 2:
				if(v366) {
					bs366 |= 32;
				} else {
					bs366 &= -33;
				}
				break;
			case 3:
				if(v366) {
					bs366 |= 16;
				} else {
					bs366 &= -17;
				}
				break;
			case 4:
				if(v366) {
					bs366 |= 8;
				} else {
					bs366 &= -9;
				}
				break;
			case 5:
				if(v366) {
					bs366 |= 4;
				} else {
					bs366 &= -5;
				}
				break;
			case 6:
				if(v366) {
					bs366 |= 2;
				} else {
					bs366 &= -3;
				}
				break;
			case 7:
				if(v366) {
					bs366 |= 1;
				} else {
					bs366 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs366;
		var this368 = 0;
		var bs367 = this368;
		var l367 = "  *  ".length;
		var _g1367 = 0;
		var _g467 = l367;
		while(_g1367 < _g467) {
			var i367 = _g1367++;
			var no367 = "  *  ".charCodeAt(i367);
			if(no367 == null) {
				break;
			}
			var v367;
			switch(no367) {
			case 32:
				v367 = false;
				break;
			case 42:
				v367 = true;
				break;
			case 48:
				v367 = false;
				break;
			case 49:
				v367 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i367)));
			}
			switch(i367 - (l367 - 8)) {
			case 0:
				if(v367) {
					bs367 |= 128;
				} else {
					bs367 &= -129;
				}
				break;
			case 1:
				if(v367) {
					bs367 |= 64;
				} else {
					bs367 &= -65;
				}
				break;
			case 2:
				if(v367) {
					bs367 |= 32;
				} else {
					bs367 &= -33;
				}
				break;
			case 3:
				if(v367) {
					bs367 |= 16;
				} else {
					bs367 &= -17;
				}
				break;
			case 4:
				if(v367) {
					bs367 |= 8;
				} else {
					bs367 &= -9;
				}
				break;
			case 5:
				if(v367) {
					bs367 |= 4;
				} else {
					bs367 &= -5;
				}
				break;
			case 6:
				if(v367) {
					bs367 |= 2;
				} else {
					bs367 &= -3;
				}
				break;
			case 7:
				if(v367) {
					bs367 |= 1;
				} else {
					bs367 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs367;
		var this369 = 0;
		var bs368 = this369;
		var l368 = "  *  ".length;
		var _g1368 = 0;
		var _g468 = l368;
		while(_g1368 < _g468) {
			var i368 = _g1368++;
			var no368 = "  *  ".charCodeAt(i368);
			if(no368 == null) {
				break;
			}
			var v368;
			switch(no368) {
			case 32:
				v368 = false;
				break;
			case 42:
				v368 = true;
				break;
			case 48:
				v368 = false;
				break;
			case 49:
				v368 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i368)));
			}
			switch(i368 - (l368 - 8)) {
			case 0:
				if(v368) {
					bs368 |= 128;
				} else {
					bs368 &= -129;
				}
				break;
			case 1:
				if(v368) {
					bs368 |= 64;
				} else {
					bs368 &= -65;
				}
				break;
			case 2:
				if(v368) {
					bs368 |= 32;
				} else {
					bs368 &= -33;
				}
				break;
			case 3:
				if(v368) {
					bs368 |= 16;
				} else {
					bs368 &= -17;
				}
				break;
			case 4:
				if(v368) {
					bs368 |= 8;
				} else {
					bs368 &= -9;
				}
				break;
			case 5:
				if(v368) {
					bs368 |= 4;
				} else {
					bs368 &= -5;
				}
				break;
			case 6:
				if(v368) {
					bs368 |= 2;
				} else {
					bs368 &= -3;
				}
				break;
			case 7:
				if(v368) {
					bs368 |= 1;
				} else {
					bs368 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs368;
		var this370 = 0;
		var bs369 = this370;
		var l369 = "  *  ".length;
		var _g1369 = 0;
		var _g469 = l369;
		while(_g1369 < _g469) {
			var i369 = _g1369++;
			var no369 = "  *  ".charCodeAt(i369);
			if(no369 == null) {
				break;
			}
			var v369;
			switch(no369) {
			case 32:
				v369 = false;
				break;
			case 42:
				v369 = true;
				break;
			case 48:
				v369 = false;
				break;
			case 49:
				v369 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i369)));
			}
			switch(i369 - (l369 - 8)) {
			case 0:
				if(v369) {
					bs369 |= 128;
				} else {
					bs369 &= -129;
				}
				break;
			case 1:
				if(v369) {
					bs369 |= 64;
				} else {
					bs369 &= -65;
				}
				break;
			case 2:
				if(v369) {
					bs369 |= 32;
				} else {
					bs369 &= -33;
				}
				break;
			case 3:
				if(v369) {
					bs369 |= 16;
				} else {
					bs369 &= -17;
				}
				break;
			case 4:
				if(v369) {
					bs369 |= 8;
				} else {
					bs369 &= -9;
				}
				break;
			case 5:
				if(v369) {
					bs369 |= 4;
				} else {
					bs369 &= -5;
				}
				break;
			case 6:
				if(v369) {
					bs369 |= 2;
				} else {
					bs369 &= -3;
				}
				break;
			case 7:
				if(v369) {
					bs369 |= 1;
				} else {
					bs369 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs369;
		var this371 = 0;
		var bs370 = this371;
		var l370 = "  *  ".length;
		var _g1370 = 0;
		var _g470 = l370;
		while(_g1370 < _g470) {
			var i370 = _g1370++;
			var no370 = "  *  ".charCodeAt(i370);
			if(no370 == null) {
				break;
			}
			var v370;
			switch(no370) {
			case 32:
				v370 = false;
				break;
			case 42:
				v370 = true;
				break;
			case 48:
				v370 = false;
				break;
			case 49:
				v370 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i370)));
			}
			switch(i370 - (l370 - 8)) {
			case 0:
				if(v370) {
					bs370 |= 128;
				} else {
					bs370 &= -129;
				}
				break;
			case 1:
				if(v370) {
					bs370 |= 64;
				} else {
					bs370 &= -65;
				}
				break;
			case 2:
				if(v370) {
					bs370 |= 32;
				} else {
					bs370 &= -33;
				}
				break;
			case 3:
				if(v370) {
					bs370 |= 16;
				} else {
					bs370 &= -17;
				}
				break;
			case 4:
				if(v370) {
					bs370 |= 8;
				} else {
					bs370 &= -9;
				}
				break;
			case 5:
				if(v370) {
					bs370 |= 4;
				} else {
					bs370 &= -5;
				}
				break;
			case 6:
				if(v370) {
					bs370 |= 2;
				} else {
					bs370 &= -3;
				}
				break;
			case 7:
				if(v370) {
					bs370 |= 1;
				} else {
					bs370 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs370;
		break;
	case 85:
		var this372 = 0;
		var bs371 = this372;
		var l371 = "*   *".length;
		var _g1371 = 0;
		var _g471 = l371;
		while(_g1371 < _g471) {
			var i371 = _g1371++;
			var no371 = "*   *".charCodeAt(i371);
			if(no371 == null) {
				break;
			}
			var v371;
			switch(no371) {
			case 32:
				v371 = false;
				break;
			case 42:
				v371 = true;
				break;
			case 48:
				v371 = false;
				break;
			case 49:
				v371 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i371)));
			}
			switch(i371 - (l371 - 8)) {
			case 0:
				if(v371) {
					bs371 |= 128;
				} else {
					bs371 &= -129;
				}
				break;
			case 1:
				if(v371) {
					bs371 |= 64;
				} else {
					bs371 &= -65;
				}
				break;
			case 2:
				if(v371) {
					bs371 |= 32;
				} else {
					bs371 &= -33;
				}
				break;
			case 3:
				if(v371) {
					bs371 |= 16;
				} else {
					bs371 &= -17;
				}
				break;
			case 4:
				if(v371) {
					bs371 |= 8;
				} else {
					bs371 &= -9;
				}
				break;
			case 5:
				if(v371) {
					bs371 |= 4;
				} else {
					bs371 &= -5;
				}
				break;
			case 6:
				if(v371) {
					bs371 |= 2;
				} else {
					bs371 &= -3;
				}
				break;
			case 7:
				if(v371) {
					bs371 |= 1;
				} else {
					bs371 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs371;
		var this373 = 0;
		var bs372 = this373;
		var l372 = "*   *".length;
		var _g1372 = 0;
		var _g472 = l372;
		while(_g1372 < _g472) {
			var i372 = _g1372++;
			var no372 = "*   *".charCodeAt(i372);
			if(no372 == null) {
				break;
			}
			var v372;
			switch(no372) {
			case 32:
				v372 = false;
				break;
			case 42:
				v372 = true;
				break;
			case 48:
				v372 = false;
				break;
			case 49:
				v372 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i372)));
			}
			switch(i372 - (l372 - 8)) {
			case 0:
				if(v372) {
					bs372 |= 128;
				} else {
					bs372 &= -129;
				}
				break;
			case 1:
				if(v372) {
					bs372 |= 64;
				} else {
					bs372 &= -65;
				}
				break;
			case 2:
				if(v372) {
					bs372 |= 32;
				} else {
					bs372 &= -33;
				}
				break;
			case 3:
				if(v372) {
					bs372 |= 16;
				} else {
					bs372 &= -17;
				}
				break;
			case 4:
				if(v372) {
					bs372 |= 8;
				} else {
					bs372 &= -9;
				}
				break;
			case 5:
				if(v372) {
					bs372 |= 4;
				} else {
					bs372 &= -5;
				}
				break;
			case 6:
				if(v372) {
					bs372 |= 2;
				} else {
					bs372 &= -3;
				}
				break;
			case 7:
				if(v372) {
					bs372 |= 1;
				} else {
					bs372 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs372;
		var this374 = 0;
		var bs373 = this374;
		var l373 = "*   *".length;
		var _g1373 = 0;
		var _g473 = l373;
		while(_g1373 < _g473) {
			var i373 = _g1373++;
			var no373 = "*   *".charCodeAt(i373);
			if(no373 == null) {
				break;
			}
			var v373;
			switch(no373) {
			case 32:
				v373 = false;
				break;
			case 42:
				v373 = true;
				break;
			case 48:
				v373 = false;
				break;
			case 49:
				v373 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i373)));
			}
			switch(i373 - (l373 - 8)) {
			case 0:
				if(v373) {
					bs373 |= 128;
				} else {
					bs373 &= -129;
				}
				break;
			case 1:
				if(v373) {
					bs373 |= 64;
				} else {
					bs373 &= -65;
				}
				break;
			case 2:
				if(v373) {
					bs373 |= 32;
				} else {
					bs373 &= -33;
				}
				break;
			case 3:
				if(v373) {
					bs373 |= 16;
				} else {
					bs373 &= -17;
				}
				break;
			case 4:
				if(v373) {
					bs373 |= 8;
				} else {
					bs373 &= -9;
				}
				break;
			case 5:
				if(v373) {
					bs373 |= 4;
				} else {
					bs373 &= -5;
				}
				break;
			case 6:
				if(v373) {
					bs373 |= 2;
				} else {
					bs373 &= -3;
				}
				break;
			case 7:
				if(v373) {
					bs373 |= 1;
				} else {
					bs373 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs373;
		var this375 = 0;
		var bs374 = this375;
		var l374 = "*   *".length;
		var _g1374 = 0;
		var _g474 = l374;
		while(_g1374 < _g474) {
			var i374 = _g1374++;
			var no374 = "*   *".charCodeAt(i374);
			if(no374 == null) {
				break;
			}
			var v374;
			switch(no374) {
			case 32:
				v374 = false;
				break;
			case 42:
				v374 = true;
				break;
			case 48:
				v374 = false;
				break;
			case 49:
				v374 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i374)));
			}
			switch(i374 - (l374 - 8)) {
			case 0:
				if(v374) {
					bs374 |= 128;
				} else {
					bs374 &= -129;
				}
				break;
			case 1:
				if(v374) {
					bs374 |= 64;
				} else {
					bs374 &= -65;
				}
				break;
			case 2:
				if(v374) {
					bs374 |= 32;
				} else {
					bs374 &= -33;
				}
				break;
			case 3:
				if(v374) {
					bs374 |= 16;
				} else {
					bs374 &= -17;
				}
				break;
			case 4:
				if(v374) {
					bs374 |= 8;
				} else {
					bs374 &= -9;
				}
				break;
			case 5:
				if(v374) {
					bs374 |= 4;
				} else {
					bs374 &= -5;
				}
				break;
			case 6:
				if(v374) {
					bs374 |= 2;
				} else {
					bs374 &= -3;
				}
				break;
			case 7:
				if(v374) {
					bs374 |= 1;
				} else {
					bs374 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs374;
		var this376 = 0;
		var bs375 = this376;
		var l375 = "*   *".length;
		var _g1375 = 0;
		var _g475 = l375;
		while(_g1375 < _g475) {
			var i375 = _g1375++;
			var no375 = "*   *".charCodeAt(i375);
			if(no375 == null) {
				break;
			}
			var v375;
			switch(no375) {
			case 32:
				v375 = false;
				break;
			case 42:
				v375 = true;
				break;
			case 48:
				v375 = false;
				break;
			case 49:
				v375 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i375)));
			}
			switch(i375 - (l375 - 8)) {
			case 0:
				if(v375) {
					bs375 |= 128;
				} else {
					bs375 &= -129;
				}
				break;
			case 1:
				if(v375) {
					bs375 |= 64;
				} else {
					bs375 &= -65;
				}
				break;
			case 2:
				if(v375) {
					bs375 |= 32;
				} else {
					bs375 &= -33;
				}
				break;
			case 3:
				if(v375) {
					bs375 |= 16;
				} else {
					bs375 &= -17;
				}
				break;
			case 4:
				if(v375) {
					bs375 |= 8;
				} else {
					bs375 &= -9;
				}
				break;
			case 5:
				if(v375) {
					bs375 |= 4;
				} else {
					bs375 &= -5;
				}
				break;
			case 6:
				if(v375) {
					bs375 |= 2;
				} else {
					bs375 &= -3;
				}
				break;
			case 7:
				if(v375) {
					bs375 |= 1;
				} else {
					bs375 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs375;
		var this377 = 0;
		var bs376 = this377;
		var l376 = "*   *".length;
		var _g1376 = 0;
		var _g476 = l376;
		while(_g1376 < _g476) {
			var i376 = _g1376++;
			var no376 = "*   *".charCodeAt(i376);
			if(no376 == null) {
				break;
			}
			var v376;
			switch(no376) {
			case 32:
				v376 = false;
				break;
			case 42:
				v376 = true;
				break;
			case 48:
				v376 = false;
				break;
			case 49:
				v376 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i376)));
			}
			switch(i376 - (l376 - 8)) {
			case 0:
				if(v376) {
					bs376 |= 128;
				} else {
					bs376 &= -129;
				}
				break;
			case 1:
				if(v376) {
					bs376 |= 64;
				} else {
					bs376 &= -65;
				}
				break;
			case 2:
				if(v376) {
					bs376 |= 32;
				} else {
					bs376 &= -33;
				}
				break;
			case 3:
				if(v376) {
					bs376 |= 16;
				} else {
					bs376 &= -17;
				}
				break;
			case 4:
				if(v376) {
					bs376 |= 8;
				} else {
					bs376 &= -9;
				}
				break;
			case 5:
				if(v376) {
					bs376 |= 4;
				} else {
					bs376 &= -5;
				}
				break;
			case 6:
				if(v376) {
					bs376 |= 2;
				} else {
					bs376 &= -3;
				}
				break;
			case 7:
				if(v376) {
					bs376 |= 1;
				} else {
					bs376 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs376;
		var this378 = 0;
		var bs377 = this378;
		var l377 = " *** ".length;
		var _g1377 = 0;
		var _g477 = l377;
		while(_g1377 < _g477) {
			var i377 = _g1377++;
			var no377 = " *** ".charCodeAt(i377);
			if(no377 == null) {
				break;
			}
			var v377;
			switch(no377) {
			case 32:
				v377 = false;
				break;
			case 42:
				v377 = true;
				break;
			case 48:
				v377 = false;
				break;
			case 49:
				v377 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i377)));
			}
			switch(i377 - (l377 - 8)) {
			case 0:
				if(v377) {
					bs377 |= 128;
				} else {
					bs377 &= -129;
				}
				break;
			case 1:
				if(v377) {
					bs377 |= 64;
				} else {
					bs377 &= -65;
				}
				break;
			case 2:
				if(v377) {
					bs377 |= 32;
				} else {
					bs377 &= -33;
				}
				break;
			case 3:
				if(v377) {
					bs377 |= 16;
				} else {
					bs377 &= -17;
				}
				break;
			case 4:
				if(v377) {
					bs377 |= 8;
				} else {
					bs377 &= -9;
				}
				break;
			case 5:
				if(v377) {
					bs377 |= 4;
				} else {
					bs377 &= -5;
				}
				break;
			case 6:
				if(v377) {
					bs377 |= 2;
				} else {
					bs377 &= -3;
				}
				break;
			case 7:
				if(v377) {
					bs377 |= 1;
				} else {
					bs377 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs377;
		break;
	case 86:
		var this379 = 0;
		var bs378 = this379;
		var l378 = "*   *".length;
		var _g1378 = 0;
		var _g478 = l378;
		while(_g1378 < _g478) {
			var i378 = _g1378++;
			var no378 = "*   *".charCodeAt(i378);
			if(no378 == null) {
				break;
			}
			var v378;
			switch(no378) {
			case 32:
				v378 = false;
				break;
			case 42:
				v378 = true;
				break;
			case 48:
				v378 = false;
				break;
			case 49:
				v378 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i378)));
			}
			switch(i378 - (l378 - 8)) {
			case 0:
				if(v378) {
					bs378 |= 128;
				} else {
					bs378 &= -129;
				}
				break;
			case 1:
				if(v378) {
					bs378 |= 64;
				} else {
					bs378 &= -65;
				}
				break;
			case 2:
				if(v378) {
					bs378 |= 32;
				} else {
					bs378 &= -33;
				}
				break;
			case 3:
				if(v378) {
					bs378 |= 16;
				} else {
					bs378 &= -17;
				}
				break;
			case 4:
				if(v378) {
					bs378 |= 8;
				} else {
					bs378 &= -9;
				}
				break;
			case 5:
				if(v378) {
					bs378 |= 4;
				} else {
					bs378 &= -5;
				}
				break;
			case 6:
				if(v378) {
					bs378 |= 2;
				} else {
					bs378 &= -3;
				}
				break;
			case 7:
				if(v378) {
					bs378 |= 1;
				} else {
					bs378 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs378;
		var this380 = 0;
		var bs379 = this380;
		var l379 = "*   *".length;
		var _g1379 = 0;
		var _g479 = l379;
		while(_g1379 < _g479) {
			var i379 = _g1379++;
			var no379 = "*   *".charCodeAt(i379);
			if(no379 == null) {
				break;
			}
			var v379;
			switch(no379) {
			case 32:
				v379 = false;
				break;
			case 42:
				v379 = true;
				break;
			case 48:
				v379 = false;
				break;
			case 49:
				v379 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i379)));
			}
			switch(i379 - (l379 - 8)) {
			case 0:
				if(v379) {
					bs379 |= 128;
				} else {
					bs379 &= -129;
				}
				break;
			case 1:
				if(v379) {
					bs379 |= 64;
				} else {
					bs379 &= -65;
				}
				break;
			case 2:
				if(v379) {
					bs379 |= 32;
				} else {
					bs379 &= -33;
				}
				break;
			case 3:
				if(v379) {
					bs379 |= 16;
				} else {
					bs379 &= -17;
				}
				break;
			case 4:
				if(v379) {
					bs379 |= 8;
				} else {
					bs379 &= -9;
				}
				break;
			case 5:
				if(v379) {
					bs379 |= 4;
				} else {
					bs379 &= -5;
				}
				break;
			case 6:
				if(v379) {
					bs379 |= 2;
				} else {
					bs379 &= -3;
				}
				break;
			case 7:
				if(v379) {
					bs379 |= 1;
				} else {
					bs379 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs379;
		var this381 = 0;
		var bs380 = this381;
		var l380 = "*   *".length;
		var _g1380 = 0;
		var _g480 = l380;
		while(_g1380 < _g480) {
			var i380 = _g1380++;
			var no380 = "*   *".charCodeAt(i380);
			if(no380 == null) {
				break;
			}
			var v380;
			switch(no380) {
			case 32:
				v380 = false;
				break;
			case 42:
				v380 = true;
				break;
			case 48:
				v380 = false;
				break;
			case 49:
				v380 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i380)));
			}
			switch(i380 - (l380 - 8)) {
			case 0:
				if(v380) {
					bs380 |= 128;
				} else {
					bs380 &= -129;
				}
				break;
			case 1:
				if(v380) {
					bs380 |= 64;
				} else {
					bs380 &= -65;
				}
				break;
			case 2:
				if(v380) {
					bs380 |= 32;
				} else {
					bs380 &= -33;
				}
				break;
			case 3:
				if(v380) {
					bs380 |= 16;
				} else {
					bs380 &= -17;
				}
				break;
			case 4:
				if(v380) {
					bs380 |= 8;
				} else {
					bs380 &= -9;
				}
				break;
			case 5:
				if(v380) {
					bs380 |= 4;
				} else {
					bs380 &= -5;
				}
				break;
			case 6:
				if(v380) {
					bs380 |= 2;
				} else {
					bs380 &= -3;
				}
				break;
			case 7:
				if(v380) {
					bs380 |= 1;
				} else {
					bs380 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs380;
		var this382 = 0;
		var bs381 = this382;
		var l381 = "*   *".length;
		var _g1381 = 0;
		var _g481 = l381;
		while(_g1381 < _g481) {
			var i381 = _g1381++;
			var no381 = "*   *".charCodeAt(i381);
			if(no381 == null) {
				break;
			}
			var v381;
			switch(no381) {
			case 32:
				v381 = false;
				break;
			case 42:
				v381 = true;
				break;
			case 48:
				v381 = false;
				break;
			case 49:
				v381 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i381)));
			}
			switch(i381 - (l381 - 8)) {
			case 0:
				if(v381) {
					bs381 |= 128;
				} else {
					bs381 &= -129;
				}
				break;
			case 1:
				if(v381) {
					bs381 |= 64;
				} else {
					bs381 &= -65;
				}
				break;
			case 2:
				if(v381) {
					bs381 |= 32;
				} else {
					bs381 &= -33;
				}
				break;
			case 3:
				if(v381) {
					bs381 |= 16;
				} else {
					bs381 &= -17;
				}
				break;
			case 4:
				if(v381) {
					bs381 |= 8;
				} else {
					bs381 &= -9;
				}
				break;
			case 5:
				if(v381) {
					bs381 |= 4;
				} else {
					bs381 &= -5;
				}
				break;
			case 6:
				if(v381) {
					bs381 |= 2;
				} else {
					bs381 &= -3;
				}
				break;
			case 7:
				if(v381) {
					bs381 |= 1;
				} else {
					bs381 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs381;
		var this383 = 0;
		var bs382 = this383;
		var l382 = "*   *".length;
		var _g1382 = 0;
		var _g482 = l382;
		while(_g1382 < _g482) {
			var i382 = _g1382++;
			var no382 = "*   *".charCodeAt(i382);
			if(no382 == null) {
				break;
			}
			var v382;
			switch(no382) {
			case 32:
				v382 = false;
				break;
			case 42:
				v382 = true;
				break;
			case 48:
				v382 = false;
				break;
			case 49:
				v382 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i382)));
			}
			switch(i382 - (l382 - 8)) {
			case 0:
				if(v382) {
					bs382 |= 128;
				} else {
					bs382 &= -129;
				}
				break;
			case 1:
				if(v382) {
					bs382 |= 64;
				} else {
					bs382 &= -65;
				}
				break;
			case 2:
				if(v382) {
					bs382 |= 32;
				} else {
					bs382 &= -33;
				}
				break;
			case 3:
				if(v382) {
					bs382 |= 16;
				} else {
					bs382 &= -17;
				}
				break;
			case 4:
				if(v382) {
					bs382 |= 8;
				} else {
					bs382 &= -9;
				}
				break;
			case 5:
				if(v382) {
					bs382 |= 4;
				} else {
					bs382 &= -5;
				}
				break;
			case 6:
				if(v382) {
					bs382 |= 2;
				} else {
					bs382 &= -3;
				}
				break;
			case 7:
				if(v382) {
					bs382 |= 1;
				} else {
					bs382 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs382;
		var this384 = 0;
		var bs383 = this384;
		var l383 = " * * ".length;
		var _g1383 = 0;
		var _g483 = l383;
		while(_g1383 < _g483) {
			var i383 = _g1383++;
			var no383 = " * * ".charCodeAt(i383);
			if(no383 == null) {
				break;
			}
			var v383;
			switch(no383) {
			case 32:
				v383 = false;
				break;
			case 42:
				v383 = true;
				break;
			case 48:
				v383 = false;
				break;
			case 49:
				v383 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i383)));
			}
			switch(i383 - (l383 - 8)) {
			case 0:
				if(v383) {
					bs383 |= 128;
				} else {
					bs383 &= -129;
				}
				break;
			case 1:
				if(v383) {
					bs383 |= 64;
				} else {
					bs383 &= -65;
				}
				break;
			case 2:
				if(v383) {
					bs383 |= 32;
				} else {
					bs383 &= -33;
				}
				break;
			case 3:
				if(v383) {
					bs383 |= 16;
				} else {
					bs383 &= -17;
				}
				break;
			case 4:
				if(v383) {
					bs383 |= 8;
				} else {
					bs383 &= -9;
				}
				break;
			case 5:
				if(v383) {
					bs383 |= 4;
				} else {
					bs383 &= -5;
				}
				break;
			case 6:
				if(v383) {
					bs383 |= 2;
				} else {
					bs383 &= -3;
				}
				break;
			case 7:
				if(v383) {
					bs383 |= 1;
				} else {
					bs383 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs383;
		var this385 = 0;
		var bs384 = this385;
		var l384 = "  *  ".length;
		var _g1384 = 0;
		var _g484 = l384;
		while(_g1384 < _g484) {
			var i384 = _g1384++;
			var no384 = "  *  ".charCodeAt(i384);
			if(no384 == null) {
				break;
			}
			var v384;
			switch(no384) {
			case 32:
				v384 = false;
				break;
			case 42:
				v384 = true;
				break;
			case 48:
				v384 = false;
				break;
			case 49:
				v384 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i384)));
			}
			switch(i384 - (l384 - 8)) {
			case 0:
				if(v384) {
					bs384 |= 128;
				} else {
					bs384 &= -129;
				}
				break;
			case 1:
				if(v384) {
					bs384 |= 64;
				} else {
					bs384 &= -65;
				}
				break;
			case 2:
				if(v384) {
					bs384 |= 32;
				} else {
					bs384 &= -33;
				}
				break;
			case 3:
				if(v384) {
					bs384 |= 16;
				} else {
					bs384 &= -17;
				}
				break;
			case 4:
				if(v384) {
					bs384 |= 8;
				} else {
					bs384 &= -9;
				}
				break;
			case 5:
				if(v384) {
					bs384 |= 4;
				} else {
					bs384 &= -5;
				}
				break;
			case 6:
				if(v384) {
					bs384 |= 2;
				} else {
					bs384 &= -3;
				}
				break;
			case 7:
				if(v384) {
					bs384 |= 1;
				} else {
					bs384 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs384;
		break;
	case 87:
		var this386 = 0;
		var bs385 = this386;
		var l385 = "*   *".length;
		var _g1385 = 0;
		var _g485 = l385;
		while(_g1385 < _g485) {
			var i385 = _g1385++;
			var no385 = "*   *".charCodeAt(i385);
			if(no385 == null) {
				break;
			}
			var v385;
			switch(no385) {
			case 32:
				v385 = false;
				break;
			case 42:
				v385 = true;
				break;
			case 48:
				v385 = false;
				break;
			case 49:
				v385 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i385)));
			}
			switch(i385 - (l385 - 8)) {
			case 0:
				if(v385) {
					bs385 |= 128;
				} else {
					bs385 &= -129;
				}
				break;
			case 1:
				if(v385) {
					bs385 |= 64;
				} else {
					bs385 &= -65;
				}
				break;
			case 2:
				if(v385) {
					bs385 |= 32;
				} else {
					bs385 &= -33;
				}
				break;
			case 3:
				if(v385) {
					bs385 |= 16;
				} else {
					bs385 &= -17;
				}
				break;
			case 4:
				if(v385) {
					bs385 |= 8;
				} else {
					bs385 &= -9;
				}
				break;
			case 5:
				if(v385) {
					bs385 |= 4;
				} else {
					bs385 &= -5;
				}
				break;
			case 6:
				if(v385) {
					bs385 |= 2;
				} else {
					bs385 &= -3;
				}
				break;
			case 7:
				if(v385) {
					bs385 |= 1;
				} else {
					bs385 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs385;
		var this387 = 0;
		var bs386 = this387;
		var l386 = "*   *".length;
		var _g1386 = 0;
		var _g486 = l386;
		while(_g1386 < _g486) {
			var i386 = _g1386++;
			var no386 = "*   *".charCodeAt(i386);
			if(no386 == null) {
				break;
			}
			var v386;
			switch(no386) {
			case 32:
				v386 = false;
				break;
			case 42:
				v386 = true;
				break;
			case 48:
				v386 = false;
				break;
			case 49:
				v386 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i386)));
			}
			switch(i386 - (l386 - 8)) {
			case 0:
				if(v386) {
					bs386 |= 128;
				} else {
					bs386 &= -129;
				}
				break;
			case 1:
				if(v386) {
					bs386 |= 64;
				} else {
					bs386 &= -65;
				}
				break;
			case 2:
				if(v386) {
					bs386 |= 32;
				} else {
					bs386 &= -33;
				}
				break;
			case 3:
				if(v386) {
					bs386 |= 16;
				} else {
					bs386 &= -17;
				}
				break;
			case 4:
				if(v386) {
					bs386 |= 8;
				} else {
					bs386 &= -9;
				}
				break;
			case 5:
				if(v386) {
					bs386 |= 4;
				} else {
					bs386 &= -5;
				}
				break;
			case 6:
				if(v386) {
					bs386 |= 2;
				} else {
					bs386 &= -3;
				}
				break;
			case 7:
				if(v386) {
					bs386 |= 1;
				} else {
					bs386 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs386;
		var this388 = 0;
		var bs387 = this388;
		var l387 = "*   *".length;
		var _g1387 = 0;
		var _g487 = l387;
		while(_g1387 < _g487) {
			var i387 = _g1387++;
			var no387 = "*   *".charCodeAt(i387);
			if(no387 == null) {
				break;
			}
			var v387;
			switch(no387) {
			case 32:
				v387 = false;
				break;
			case 42:
				v387 = true;
				break;
			case 48:
				v387 = false;
				break;
			case 49:
				v387 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i387)));
			}
			switch(i387 - (l387 - 8)) {
			case 0:
				if(v387) {
					bs387 |= 128;
				} else {
					bs387 &= -129;
				}
				break;
			case 1:
				if(v387) {
					bs387 |= 64;
				} else {
					bs387 &= -65;
				}
				break;
			case 2:
				if(v387) {
					bs387 |= 32;
				} else {
					bs387 &= -33;
				}
				break;
			case 3:
				if(v387) {
					bs387 |= 16;
				} else {
					bs387 &= -17;
				}
				break;
			case 4:
				if(v387) {
					bs387 |= 8;
				} else {
					bs387 &= -9;
				}
				break;
			case 5:
				if(v387) {
					bs387 |= 4;
				} else {
					bs387 &= -5;
				}
				break;
			case 6:
				if(v387) {
					bs387 |= 2;
				} else {
					bs387 &= -3;
				}
				break;
			case 7:
				if(v387) {
					bs387 |= 1;
				} else {
					bs387 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs387;
		var this389 = 0;
		var bs388 = this389;
		var l388 = "* * *".length;
		var _g1388 = 0;
		var _g488 = l388;
		while(_g1388 < _g488) {
			var i388 = _g1388++;
			var no388 = "* * *".charCodeAt(i388);
			if(no388 == null) {
				break;
			}
			var v388;
			switch(no388) {
			case 32:
				v388 = false;
				break;
			case 42:
				v388 = true;
				break;
			case 48:
				v388 = false;
				break;
			case 49:
				v388 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i388)));
			}
			switch(i388 - (l388 - 8)) {
			case 0:
				if(v388) {
					bs388 |= 128;
				} else {
					bs388 &= -129;
				}
				break;
			case 1:
				if(v388) {
					bs388 |= 64;
				} else {
					bs388 &= -65;
				}
				break;
			case 2:
				if(v388) {
					bs388 |= 32;
				} else {
					bs388 &= -33;
				}
				break;
			case 3:
				if(v388) {
					bs388 |= 16;
				} else {
					bs388 &= -17;
				}
				break;
			case 4:
				if(v388) {
					bs388 |= 8;
				} else {
					bs388 &= -9;
				}
				break;
			case 5:
				if(v388) {
					bs388 |= 4;
				} else {
					bs388 &= -5;
				}
				break;
			case 6:
				if(v388) {
					bs388 |= 2;
				} else {
					bs388 &= -3;
				}
				break;
			case 7:
				if(v388) {
					bs388 |= 1;
				} else {
					bs388 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs388;
		var this390 = 0;
		var bs389 = this390;
		var l389 = "* * *".length;
		var _g1389 = 0;
		var _g489 = l389;
		while(_g1389 < _g489) {
			var i389 = _g1389++;
			var no389 = "* * *".charCodeAt(i389);
			if(no389 == null) {
				break;
			}
			var v389;
			switch(no389) {
			case 32:
				v389 = false;
				break;
			case 42:
				v389 = true;
				break;
			case 48:
				v389 = false;
				break;
			case 49:
				v389 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i389)));
			}
			switch(i389 - (l389 - 8)) {
			case 0:
				if(v389) {
					bs389 |= 128;
				} else {
					bs389 &= -129;
				}
				break;
			case 1:
				if(v389) {
					bs389 |= 64;
				} else {
					bs389 &= -65;
				}
				break;
			case 2:
				if(v389) {
					bs389 |= 32;
				} else {
					bs389 &= -33;
				}
				break;
			case 3:
				if(v389) {
					bs389 |= 16;
				} else {
					bs389 &= -17;
				}
				break;
			case 4:
				if(v389) {
					bs389 |= 8;
				} else {
					bs389 &= -9;
				}
				break;
			case 5:
				if(v389) {
					bs389 |= 4;
				} else {
					bs389 &= -5;
				}
				break;
			case 6:
				if(v389) {
					bs389 |= 2;
				} else {
					bs389 &= -3;
				}
				break;
			case 7:
				if(v389) {
					bs389 |= 1;
				} else {
					bs389 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs389;
		var this391 = 0;
		var bs390 = this391;
		var l390 = "* * *".length;
		var _g1390 = 0;
		var _g490 = l390;
		while(_g1390 < _g490) {
			var i390 = _g1390++;
			var no390 = "* * *".charCodeAt(i390);
			if(no390 == null) {
				break;
			}
			var v390;
			switch(no390) {
			case 32:
				v390 = false;
				break;
			case 42:
				v390 = true;
				break;
			case 48:
				v390 = false;
				break;
			case 49:
				v390 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i390)));
			}
			switch(i390 - (l390 - 8)) {
			case 0:
				if(v390) {
					bs390 |= 128;
				} else {
					bs390 &= -129;
				}
				break;
			case 1:
				if(v390) {
					bs390 |= 64;
				} else {
					bs390 &= -65;
				}
				break;
			case 2:
				if(v390) {
					bs390 |= 32;
				} else {
					bs390 &= -33;
				}
				break;
			case 3:
				if(v390) {
					bs390 |= 16;
				} else {
					bs390 &= -17;
				}
				break;
			case 4:
				if(v390) {
					bs390 |= 8;
				} else {
					bs390 &= -9;
				}
				break;
			case 5:
				if(v390) {
					bs390 |= 4;
				} else {
					bs390 &= -5;
				}
				break;
			case 6:
				if(v390) {
					bs390 |= 2;
				} else {
					bs390 &= -3;
				}
				break;
			case 7:
				if(v390) {
					bs390 |= 1;
				} else {
					bs390 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs390;
		var this392 = 0;
		var bs391 = this392;
		var l391 = " * * ".length;
		var _g1391 = 0;
		var _g491 = l391;
		while(_g1391 < _g491) {
			var i391 = _g1391++;
			var no391 = " * * ".charCodeAt(i391);
			if(no391 == null) {
				break;
			}
			var v391;
			switch(no391) {
			case 32:
				v391 = false;
				break;
			case 42:
				v391 = true;
				break;
			case 48:
				v391 = false;
				break;
			case 49:
				v391 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i391)));
			}
			switch(i391 - (l391 - 8)) {
			case 0:
				if(v391) {
					bs391 |= 128;
				} else {
					bs391 &= -129;
				}
				break;
			case 1:
				if(v391) {
					bs391 |= 64;
				} else {
					bs391 &= -65;
				}
				break;
			case 2:
				if(v391) {
					bs391 |= 32;
				} else {
					bs391 &= -33;
				}
				break;
			case 3:
				if(v391) {
					bs391 |= 16;
				} else {
					bs391 &= -17;
				}
				break;
			case 4:
				if(v391) {
					bs391 |= 8;
				} else {
					bs391 &= -9;
				}
				break;
			case 5:
				if(v391) {
					bs391 |= 4;
				} else {
					bs391 &= -5;
				}
				break;
			case 6:
				if(v391) {
					bs391 |= 2;
				} else {
					bs391 &= -3;
				}
				break;
			case 7:
				if(v391) {
					bs391 |= 1;
				} else {
					bs391 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs391;
		break;
	case 88:
		var this393 = 0;
		var bs392 = this393;
		var l392 = "*   *".length;
		var _g1392 = 0;
		var _g492 = l392;
		while(_g1392 < _g492) {
			var i392 = _g1392++;
			var no392 = "*   *".charCodeAt(i392);
			if(no392 == null) {
				break;
			}
			var v392;
			switch(no392) {
			case 32:
				v392 = false;
				break;
			case 42:
				v392 = true;
				break;
			case 48:
				v392 = false;
				break;
			case 49:
				v392 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i392)));
			}
			switch(i392 - (l392 - 8)) {
			case 0:
				if(v392) {
					bs392 |= 128;
				} else {
					bs392 &= -129;
				}
				break;
			case 1:
				if(v392) {
					bs392 |= 64;
				} else {
					bs392 &= -65;
				}
				break;
			case 2:
				if(v392) {
					bs392 |= 32;
				} else {
					bs392 &= -33;
				}
				break;
			case 3:
				if(v392) {
					bs392 |= 16;
				} else {
					bs392 &= -17;
				}
				break;
			case 4:
				if(v392) {
					bs392 |= 8;
				} else {
					bs392 &= -9;
				}
				break;
			case 5:
				if(v392) {
					bs392 |= 4;
				} else {
					bs392 &= -5;
				}
				break;
			case 6:
				if(v392) {
					bs392 |= 2;
				} else {
					bs392 &= -3;
				}
				break;
			case 7:
				if(v392) {
					bs392 |= 1;
				} else {
					bs392 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs392;
		var this394 = 0;
		var bs393 = this394;
		var l393 = "*   *".length;
		var _g1393 = 0;
		var _g493 = l393;
		while(_g1393 < _g493) {
			var i393 = _g1393++;
			var no393 = "*   *".charCodeAt(i393);
			if(no393 == null) {
				break;
			}
			var v393;
			switch(no393) {
			case 32:
				v393 = false;
				break;
			case 42:
				v393 = true;
				break;
			case 48:
				v393 = false;
				break;
			case 49:
				v393 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i393)));
			}
			switch(i393 - (l393 - 8)) {
			case 0:
				if(v393) {
					bs393 |= 128;
				} else {
					bs393 &= -129;
				}
				break;
			case 1:
				if(v393) {
					bs393 |= 64;
				} else {
					bs393 &= -65;
				}
				break;
			case 2:
				if(v393) {
					bs393 |= 32;
				} else {
					bs393 &= -33;
				}
				break;
			case 3:
				if(v393) {
					bs393 |= 16;
				} else {
					bs393 &= -17;
				}
				break;
			case 4:
				if(v393) {
					bs393 |= 8;
				} else {
					bs393 &= -9;
				}
				break;
			case 5:
				if(v393) {
					bs393 |= 4;
				} else {
					bs393 &= -5;
				}
				break;
			case 6:
				if(v393) {
					bs393 |= 2;
				} else {
					bs393 &= -3;
				}
				break;
			case 7:
				if(v393) {
					bs393 |= 1;
				} else {
					bs393 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs393;
		var this395 = 0;
		var bs394 = this395;
		var l394 = " * * ".length;
		var _g1394 = 0;
		var _g494 = l394;
		while(_g1394 < _g494) {
			var i394 = _g1394++;
			var no394 = " * * ".charCodeAt(i394);
			if(no394 == null) {
				break;
			}
			var v394;
			switch(no394) {
			case 32:
				v394 = false;
				break;
			case 42:
				v394 = true;
				break;
			case 48:
				v394 = false;
				break;
			case 49:
				v394 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i394)));
			}
			switch(i394 - (l394 - 8)) {
			case 0:
				if(v394) {
					bs394 |= 128;
				} else {
					bs394 &= -129;
				}
				break;
			case 1:
				if(v394) {
					bs394 |= 64;
				} else {
					bs394 &= -65;
				}
				break;
			case 2:
				if(v394) {
					bs394 |= 32;
				} else {
					bs394 &= -33;
				}
				break;
			case 3:
				if(v394) {
					bs394 |= 16;
				} else {
					bs394 &= -17;
				}
				break;
			case 4:
				if(v394) {
					bs394 |= 8;
				} else {
					bs394 &= -9;
				}
				break;
			case 5:
				if(v394) {
					bs394 |= 4;
				} else {
					bs394 &= -5;
				}
				break;
			case 6:
				if(v394) {
					bs394 |= 2;
				} else {
					bs394 &= -3;
				}
				break;
			case 7:
				if(v394) {
					bs394 |= 1;
				} else {
					bs394 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs394;
		var this396 = 0;
		var bs395 = this396;
		var l395 = "  *  ".length;
		var _g1395 = 0;
		var _g495 = l395;
		while(_g1395 < _g495) {
			var i395 = _g1395++;
			var no395 = "  *  ".charCodeAt(i395);
			if(no395 == null) {
				break;
			}
			var v395;
			switch(no395) {
			case 32:
				v395 = false;
				break;
			case 42:
				v395 = true;
				break;
			case 48:
				v395 = false;
				break;
			case 49:
				v395 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i395)));
			}
			switch(i395 - (l395 - 8)) {
			case 0:
				if(v395) {
					bs395 |= 128;
				} else {
					bs395 &= -129;
				}
				break;
			case 1:
				if(v395) {
					bs395 |= 64;
				} else {
					bs395 &= -65;
				}
				break;
			case 2:
				if(v395) {
					bs395 |= 32;
				} else {
					bs395 &= -33;
				}
				break;
			case 3:
				if(v395) {
					bs395 |= 16;
				} else {
					bs395 &= -17;
				}
				break;
			case 4:
				if(v395) {
					bs395 |= 8;
				} else {
					bs395 &= -9;
				}
				break;
			case 5:
				if(v395) {
					bs395 |= 4;
				} else {
					bs395 &= -5;
				}
				break;
			case 6:
				if(v395) {
					bs395 |= 2;
				} else {
					bs395 &= -3;
				}
				break;
			case 7:
				if(v395) {
					bs395 |= 1;
				} else {
					bs395 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs395;
		var this397 = 0;
		var bs396 = this397;
		var l396 = " * * ".length;
		var _g1396 = 0;
		var _g496 = l396;
		while(_g1396 < _g496) {
			var i396 = _g1396++;
			var no396 = " * * ".charCodeAt(i396);
			if(no396 == null) {
				break;
			}
			var v396;
			switch(no396) {
			case 32:
				v396 = false;
				break;
			case 42:
				v396 = true;
				break;
			case 48:
				v396 = false;
				break;
			case 49:
				v396 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i396)));
			}
			switch(i396 - (l396 - 8)) {
			case 0:
				if(v396) {
					bs396 |= 128;
				} else {
					bs396 &= -129;
				}
				break;
			case 1:
				if(v396) {
					bs396 |= 64;
				} else {
					bs396 &= -65;
				}
				break;
			case 2:
				if(v396) {
					bs396 |= 32;
				} else {
					bs396 &= -33;
				}
				break;
			case 3:
				if(v396) {
					bs396 |= 16;
				} else {
					bs396 &= -17;
				}
				break;
			case 4:
				if(v396) {
					bs396 |= 8;
				} else {
					bs396 &= -9;
				}
				break;
			case 5:
				if(v396) {
					bs396 |= 4;
				} else {
					bs396 &= -5;
				}
				break;
			case 6:
				if(v396) {
					bs396 |= 2;
				} else {
					bs396 &= -3;
				}
				break;
			case 7:
				if(v396) {
					bs396 |= 1;
				} else {
					bs396 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs396;
		var this398 = 0;
		var bs397 = this398;
		var l397 = "*   *".length;
		var _g1397 = 0;
		var _g497 = l397;
		while(_g1397 < _g497) {
			var i397 = _g1397++;
			var no397 = "*   *".charCodeAt(i397);
			if(no397 == null) {
				break;
			}
			var v397;
			switch(no397) {
			case 32:
				v397 = false;
				break;
			case 42:
				v397 = true;
				break;
			case 48:
				v397 = false;
				break;
			case 49:
				v397 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i397)));
			}
			switch(i397 - (l397 - 8)) {
			case 0:
				if(v397) {
					bs397 |= 128;
				} else {
					bs397 &= -129;
				}
				break;
			case 1:
				if(v397) {
					bs397 |= 64;
				} else {
					bs397 &= -65;
				}
				break;
			case 2:
				if(v397) {
					bs397 |= 32;
				} else {
					bs397 &= -33;
				}
				break;
			case 3:
				if(v397) {
					bs397 |= 16;
				} else {
					bs397 &= -17;
				}
				break;
			case 4:
				if(v397) {
					bs397 |= 8;
				} else {
					bs397 &= -9;
				}
				break;
			case 5:
				if(v397) {
					bs397 |= 4;
				} else {
					bs397 &= -5;
				}
				break;
			case 6:
				if(v397) {
					bs397 |= 2;
				} else {
					bs397 &= -3;
				}
				break;
			case 7:
				if(v397) {
					bs397 |= 1;
				} else {
					bs397 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs397;
		var this399 = 0;
		var bs398 = this399;
		var l398 = "*   *".length;
		var _g1398 = 0;
		var _g498 = l398;
		while(_g1398 < _g498) {
			var i398 = _g1398++;
			var no398 = "*   *".charCodeAt(i398);
			if(no398 == null) {
				break;
			}
			var v398;
			switch(no398) {
			case 32:
				v398 = false;
				break;
			case 42:
				v398 = true;
				break;
			case 48:
				v398 = false;
				break;
			case 49:
				v398 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i398)));
			}
			switch(i398 - (l398 - 8)) {
			case 0:
				if(v398) {
					bs398 |= 128;
				} else {
					bs398 &= -129;
				}
				break;
			case 1:
				if(v398) {
					bs398 |= 64;
				} else {
					bs398 &= -65;
				}
				break;
			case 2:
				if(v398) {
					bs398 |= 32;
				} else {
					bs398 &= -33;
				}
				break;
			case 3:
				if(v398) {
					bs398 |= 16;
				} else {
					bs398 &= -17;
				}
				break;
			case 4:
				if(v398) {
					bs398 |= 8;
				} else {
					bs398 &= -9;
				}
				break;
			case 5:
				if(v398) {
					bs398 |= 4;
				} else {
					bs398 &= -5;
				}
				break;
			case 6:
				if(v398) {
					bs398 |= 2;
				} else {
					bs398 &= -3;
				}
				break;
			case 7:
				if(v398) {
					bs398 |= 1;
				} else {
					bs398 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs398;
		break;
	case 89:
		var this400 = 0;
		var bs399 = this400;
		var l399 = "*   *".length;
		var _g1399 = 0;
		var _g499 = l399;
		while(_g1399 < _g499) {
			var i399 = _g1399++;
			var no399 = "*   *".charCodeAt(i399);
			if(no399 == null) {
				break;
			}
			var v399;
			switch(no399) {
			case 32:
				v399 = false;
				break;
			case 42:
				v399 = true;
				break;
			case 48:
				v399 = false;
				break;
			case 49:
				v399 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i399)));
			}
			switch(i399 - (l399 - 8)) {
			case 0:
				if(v399) {
					bs399 |= 128;
				} else {
					bs399 &= -129;
				}
				break;
			case 1:
				if(v399) {
					bs399 |= 64;
				} else {
					bs399 &= -65;
				}
				break;
			case 2:
				if(v399) {
					bs399 |= 32;
				} else {
					bs399 &= -33;
				}
				break;
			case 3:
				if(v399) {
					bs399 |= 16;
				} else {
					bs399 &= -17;
				}
				break;
			case 4:
				if(v399) {
					bs399 |= 8;
				} else {
					bs399 &= -9;
				}
				break;
			case 5:
				if(v399) {
					bs399 |= 4;
				} else {
					bs399 &= -5;
				}
				break;
			case 6:
				if(v399) {
					bs399 |= 2;
				} else {
					bs399 &= -3;
				}
				break;
			case 7:
				if(v399) {
					bs399 |= 1;
				} else {
					bs399 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs399;
		var this401 = 0;
		var bs400 = this401;
		var l400 = "*   *".length;
		var _g1400 = 0;
		var _g500 = l400;
		while(_g1400 < _g500) {
			var i400 = _g1400++;
			var no400 = "*   *".charCodeAt(i400);
			if(no400 == null) {
				break;
			}
			var v400;
			switch(no400) {
			case 32:
				v400 = false;
				break;
			case 42:
				v400 = true;
				break;
			case 48:
				v400 = false;
				break;
			case 49:
				v400 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i400)));
			}
			switch(i400 - (l400 - 8)) {
			case 0:
				if(v400) {
					bs400 |= 128;
				} else {
					bs400 &= -129;
				}
				break;
			case 1:
				if(v400) {
					bs400 |= 64;
				} else {
					bs400 &= -65;
				}
				break;
			case 2:
				if(v400) {
					bs400 |= 32;
				} else {
					bs400 &= -33;
				}
				break;
			case 3:
				if(v400) {
					bs400 |= 16;
				} else {
					bs400 &= -17;
				}
				break;
			case 4:
				if(v400) {
					bs400 |= 8;
				} else {
					bs400 &= -9;
				}
				break;
			case 5:
				if(v400) {
					bs400 |= 4;
				} else {
					bs400 &= -5;
				}
				break;
			case 6:
				if(v400) {
					bs400 |= 2;
				} else {
					bs400 &= -3;
				}
				break;
			case 7:
				if(v400) {
					bs400 |= 1;
				} else {
					bs400 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs400;
		var this402 = 0;
		var bs401 = this402;
		var l401 = "*   *".length;
		var _g1401 = 0;
		var _g501 = l401;
		while(_g1401 < _g501) {
			var i401 = _g1401++;
			var no401 = "*   *".charCodeAt(i401);
			if(no401 == null) {
				break;
			}
			var v401;
			switch(no401) {
			case 32:
				v401 = false;
				break;
			case 42:
				v401 = true;
				break;
			case 48:
				v401 = false;
				break;
			case 49:
				v401 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i401)));
			}
			switch(i401 - (l401 - 8)) {
			case 0:
				if(v401) {
					bs401 |= 128;
				} else {
					bs401 &= -129;
				}
				break;
			case 1:
				if(v401) {
					bs401 |= 64;
				} else {
					bs401 &= -65;
				}
				break;
			case 2:
				if(v401) {
					bs401 |= 32;
				} else {
					bs401 &= -33;
				}
				break;
			case 3:
				if(v401) {
					bs401 |= 16;
				} else {
					bs401 &= -17;
				}
				break;
			case 4:
				if(v401) {
					bs401 |= 8;
				} else {
					bs401 &= -9;
				}
				break;
			case 5:
				if(v401) {
					bs401 |= 4;
				} else {
					bs401 &= -5;
				}
				break;
			case 6:
				if(v401) {
					bs401 |= 2;
				} else {
					bs401 &= -3;
				}
				break;
			case 7:
				if(v401) {
					bs401 |= 1;
				} else {
					bs401 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs401;
		var this403 = 0;
		var bs402 = this403;
		var l402 = " * * ".length;
		var _g1402 = 0;
		var _g502 = l402;
		while(_g1402 < _g502) {
			var i402 = _g1402++;
			var no402 = " * * ".charCodeAt(i402);
			if(no402 == null) {
				break;
			}
			var v402;
			switch(no402) {
			case 32:
				v402 = false;
				break;
			case 42:
				v402 = true;
				break;
			case 48:
				v402 = false;
				break;
			case 49:
				v402 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i402)));
			}
			switch(i402 - (l402 - 8)) {
			case 0:
				if(v402) {
					bs402 |= 128;
				} else {
					bs402 &= -129;
				}
				break;
			case 1:
				if(v402) {
					bs402 |= 64;
				} else {
					bs402 &= -65;
				}
				break;
			case 2:
				if(v402) {
					bs402 |= 32;
				} else {
					bs402 &= -33;
				}
				break;
			case 3:
				if(v402) {
					bs402 |= 16;
				} else {
					bs402 &= -17;
				}
				break;
			case 4:
				if(v402) {
					bs402 |= 8;
				} else {
					bs402 &= -9;
				}
				break;
			case 5:
				if(v402) {
					bs402 |= 4;
				} else {
					bs402 &= -5;
				}
				break;
			case 6:
				if(v402) {
					bs402 |= 2;
				} else {
					bs402 &= -3;
				}
				break;
			case 7:
				if(v402) {
					bs402 |= 1;
				} else {
					bs402 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs402;
		var this404 = 0;
		var bs403 = this404;
		var l403 = "  *  ".length;
		var _g1403 = 0;
		var _g503 = l403;
		while(_g1403 < _g503) {
			var i403 = _g1403++;
			var no403 = "  *  ".charCodeAt(i403);
			if(no403 == null) {
				break;
			}
			var v403;
			switch(no403) {
			case 32:
				v403 = false;
				break;
			case 42:
				v403 = true;
				break;
			case 48:
				v403 = false;
				break;
			case 49:
				v403 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i403)));
			}
			switch(i403 - (l403 - 8)) {
			case 0:
				if(v403) {
					bs403 |= 128;
				} else {
					bs403 &= -129;
				}
				break;
			case 1:
				if(v403) {
					bs403 |= 64;
				} else {
					bs403 &= -65;
				}
				break;
			case 2:
				if(v403) {
					bs403 |= 32;
				} else {
					bs403 &= -33;
				}
				break;
			case 3:
				if(v403) {
					bs403 |= 16;
				} else {
					bs403 &= -17;
				}
				break;
			case 4:
				if(v403) {
					bs403 |= 8;
				} else {
					bs403 &= -9;
				}
				break;
			case 5:
				if(v403) {
					bs403 |= 4;
				} else {
					bs403 &= -5;
				}
				break;
			case 6:
				if(v403) {
					bs403 |= 2;
				} else {
					bs403 &= -3;
				}
				break;
			case 7:
				if(v403) {
					bs403 |= 1;
				} else {
					bs403 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs403;
		var this405 = 0;
		var bs404 = this405;
		var l404 = "  *  ".length;
		var _g1404 = 0;
		var _g504 = l404;
		while(_g1404 < _g504) {
			var i404 = _g1404++;
			var no404 = "  *  ".charCodeAt(i404);
			if(no404 == null) {
				break;
			}
			var v404;
			switch(no404) {
			case 32:
				v404 = false;
				break;
			case 42:
				v404 = true;
				break;
			case 48:
				v404 = false;
				break;
			case 49:
				v404 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i404)));
			}
			switch(i404 - (l404 - 8)) {
			case 0:
				if(v404) {
					bs404 |= 128;
				} else {
					bs404 &= -129;
				}
				break;
			case 1:
				if(v404) {
					bs404 |= 64;
				} else {
					bs404 &= -65;
				}
				break;
			case 2:
				if(v404) {
					bs404 |= 32;
				} else {
					bs404 &= -33;
				}
				break;
			case 3:
				if(v404) {
					bs404 |= 16;
				} else {
					bs404 &= -17;
				}
				break;
			case 4:
				if(v404) {
					bs404 |= 8;
				} else {
					bs404 &= -9;
				}
				break;
			case 5:
				if(v404) {
					bs404 |= 4;
				} else {
					bs404 &= -5;
				}
				break;
			case 6:
				if(v404) {
					bs404 |= 2;
				} else {
					bs404 &= -3;
				}
				break;
			case 7:
				if(v404) {
					bs404 |= 1;
				} else {
					bs404 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs404;
		var this406 = 0;
		var bs405 = this406;
		var l405 = "  *  ".length;
		var _g1405 = 0;
		var _g505 = l405;
		while(_g1405 < _g505) {
			var i405 = _g1405++;
			var no405 = "  *  ".charCodeAt(i405);
			if(no405 == null) {
				break;
			}
			var v405;
			switch(no405) {
			case 32:
				v405 = false;
				break;
			case 42:
				v405 = true;
				break;
			case 48:
				v405 = false;
				break;
			case 49:
				v405 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i405)));
			}
			switch(i405 - (l405 - 8)) {
			case 0:
				if(v405) {
					bs405 |= 128;
				} else {
					bs405 &= -129;
				}
				break;
			case 1:
				if(v405) {
					bs405 |= 64;
				} else {
					bs405 &= -65;
				}
				break;
			case 2:
				if(v405) {
					bs405 |= 32;
				} else {
					bs405 &= -33;
				}
				break;
			case 3:
				if(v405) {
					bs405 |= 16;
				} else {
					bs405 &= -17;
				}
				break;
			case 4:
				if(v405) {
					bs405 |= 8;
				} else {
					bs405 &= -9;
				}
				break;
			case 5:
				if(v405) {
					bs405 |= 4;
				} else {
					bs405 &= -5;
				}
				break;
			case 6:
				if(v405) {
					bs405 |= 2;
				} else {
					bs405 &= -3;
				}
				break;
			case 7:
				if(v405) {
					bs405 |= 1;
				} else {
					bs405 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs405;
		break;
	case 90:
		var this407 = 0;
		var bs406 = this407;
		var l406 = "*****".length;
		var _g1406 = 0;
		var _g506 = l406;
		while(_g1406 < _g506) {
			var i406 = _g1406++;
			var no406 = "*****".charCodeAt(i406);
			if(no406 == null) {
				break;
			}
			var v406;
			switch(no406) {
			case 32:
				v406 = false;
				break;
			case 42:
				v406 = true;
				break;
			case 48:
				v406 = false;
				break;
			case 49:
				v406 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i406)));
			}
			switch(i406 - (l406 - 8)) {
			case 0:
				if(v406) {
					bs406 |= 128;
				} else {
					bs406 &= -129;
				}
				break;
			case 1:
				if(v406) {
					bs406 |= 64;
				} else {
					bs406 &= -65;
				}
				break;
			case 2:
				if(v406) {
					bs406 |= 32;
				} else {
					bs406 &= -33;
				}
				break;
			case 3:
				if(v406) {
					bs406 |= 16;
				} else {
					bs406 &= -17;
				}
				break;
			case 4:
				if(v406) {
					bs406 |= 8;
				} else {
					bs406 &= -9;
				}
				break;
			case 5:
				if(v406) {
					bs406 |= 4;
				} else {
					bs406 &= -5;
				}
				break;
			case 6:
				if(v406) {
					bs406 |= 2;
				} else {
					bs406 &= -3;
				}
				break;
			case 7:
				if(v406) {
					bs406 |= 1;
				} else {
					bs406 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs406;
		var this408 = 0;
		var bs407 = this408;
		var l407 = "    *".length;
		var _g1407 = 0;
		var _g507 = l407;
		while(_g1407 < _g507) {
			var i407 = _g1407++;
			var no407 = "    *".charCodeAt(i407);
			if(no407 == null) {
				break;
			}
			var v407;
			switch(no407) {
			case 32:
				v407 = false;
				break;
			case 42:
				v407 = true;
				break;
			case 48:
				v407 = false;
				break;
			case 49:
				v407 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i407)));
			}
			switch(i407 - (l407 - 8)) {
			case 0:
				if(v407) {
					bs407 |= 128;
				} else {
					bs407 &= -129;
				}
				break;
			case 1:
				if(v407) {
					bs407 |= 64;
				} else {
					bs407 &= -65;
				}
				break;
			case 2:
				if(v407) {
					bs407 |= 32;
				} else {
					bs407 &= -33;
				}
				break;
			case 3:
				if(v407) {
					bs407 |= 16;
				} else {
					bs407 &= -17;
				}
				break;
			case 4:
				if(v407) {
					bs407 |= 8;
				} else {
					bs407 &= -9;
				}
				break;
			case 5:
				if(v407) {
					bs407 |= 4;
				} else {
					bs407 &= -5;
				}
				break;
			case 6:
				if(v407) {
					bs407 |= 2;
				} else {
					bs407 &= -3;
				}
				break;
			case 7:
				if(v407) {
					bs407 |= 1;
				} else {
					bs407 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs407;
		var this409 = 0;
		var bs408 = this409;
		var l408 = "   * ".length;
		var _g1408 = 0;
		var _g508 = l408;
		while(_g1408 < _g508) {
			var i408 = _g1408++;
			var no408 = "   * ".charCodeAt(i408);
			if(no408 == null) {
				break;
			}
			var v408;
			switch(no408) {
			case 32:
				v408 = false;
				break;
			case 42:
				v408 = true;
				break;
			case 48:
				v408 = false;
				break;
			case 49:
				v408 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i408)));
			}
			switch(i408 - (l408 - 8)) {
			case 0:
				if(v408) {
					bs408 |= 128;
				} else {
					bs408 &= -129;
				}
				break;
			case 1:
				if(v408) {
					bs408 |= 64;
				} else {
					bs408 &= -65;
				}
				break;
			case 2:
				if(v408) {
					bs408 |= 32;
				} else {
					bs408 &= -33;
				}
				break;
			case 3:
				if(v408) {
					bs408 |= 16;
				} else {
					bs408 &= -17;
				}
				break;
			case 4:
				if(v408) {
					bs408 |= 8;
				} else {
					bs408 &= -9;
				}
				break;
			case 5:
				if(v408) {
					bs408 |= 4;
				} else {
					bs408 &= -5;
				}
				break;
			case 6:
				if(v408) {
					bs408 |= 2;
				} else {
					bs408 &= -3;
				}
				break;
			case 7:
				if(v408) {
					bs408 |= 1;
				} else {
					bs408 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs408;
		var this410 = 0;
		var bs409 = this410;
		var l409 = "  *  ".length;
		var _g1409 = 0;
		var _g509 = l409;
		while(_g1409 < _g509) {
			var i409 = _g1409++;
			var no409 = "  *  ".charCodeAt(i409);
			if(no409 == null) {
				break;
			}
			var v409;
			switch(no409) {
			case 32:
				v409 = false;
				break;
			case 42:
				v409 = true;
				break;
			case 48:
				v409 = false;
				break;
			case 49:
				v409 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i409)));
			}
			switch(i409 - (l409 - 8)) {
			case 0:
				if(v409) {
					bs409 |= 128;
				} else {
					bs409 &= -129;
				}
				break;
			case 1:
				if(v409) {
					bs409 |= 64;
				} else {
					bs409 &= -65;
				}
				break;
			case 2:
				if(v409) {
					bs409 |= 32;
				} else {
					bs409 &= -33;
				}
				break;
			case 3:
				if(v409) {
					bs409 |= 16;
				} else {
					bs409 &= -17;
				}
				break;
			case 4:
				if(v409) {
					bs409 |= 8;
				} else {
					bs409 &= -9;
				}
				break;
			case 5:
				if(v409) {
					bs409 |= 4;
				} else {
					bs409 &= -5;
				}
				break;
			case 6:
				if(v409) {
					bs409 |= 2;
				} else {
					bs409 &= -3;
				}
				break;
			case 7:
				if(v409) {
					bs409 |= 1;
				} else {
					bs409 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs409;
		var this411 = 0;
		var bs410 = this411;
		var l410 = " *   ".length;
		var _g1410 = 0;
		var _g510 = l410;
		while(_g1410 < _g510) {
			var i410 = _g1410++;
			var no410 = " *   ".charCodeAt(i410);
			if(no410 == null) {
				break;
			}
			var v410;
			switch(no410) {
			case 32:
				v410 = false;
				break;
			case 42:
				v410 = true;
				break;
			case 48:
				v410 = false;
				break;
			case 49:
				v410 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i410)));
			}
			switch(i410 - (l410 - 8)) {
			case 0:
				if(v410) {
					bs410 |= 128;
				} else {
					bs410 &= -129;
				}
				break;
			case 1:
				if(v410) {
					bs410 |= 64;
				} else {
					bs410 &= -65;
				}
				break;
			case 2:
				if(v410) {
					bs410 |= 32;
				} else {
					bs410 &= -33;
				}
				break;
			case 3:
				if(v410) {
					bs410 |= 16;
				} else {
					bs410 &= -17;
				}
				break;
			case 4:
				if(v410) {
					bs410 |= 8;
				} else {
					bs410 &= -9;
				}
				break;
			case 5:
				if(v410) {
					bs410 |= 4;
				} else {
					bs410 &= -5;
				}
				break;
			case 6:
				if(v410) {
					bs410 |= 2;
				} else {
					bs410 &= -3;
				}
				break;
			case 7:
				if(v410) {
					bs410 |= 1;
				} else {
					bs410 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs410;
		var this412 = 0;
		var bs411 = this412;
		var l411 = "*    ".length;
		var _g1411 = 0;
		var _g511 = l411;
		while(_g1411 < _g511) {
			var i411 = _g1411++;
			var no411 = "*    ".charCodeAt(i411);
			if(no411 == null) {
				break;
			}
			var v411;
			switch(no411) {
			case 32:
				v411 = false;
				break;
			case 42:
				v411 = true;
				break;
			case 48:
				v411 = false;
				break;
			case 49:
				v411 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i411)));
			}
			switch(i411 - (l411 - 8)) {
			case 0:
				if(v411) {
					bs411 |= 128;
				} else {
					bs411 &= -129;
				}
				break;
			case 1:
				if(v411) {
					bs411 |= 64;
				} else {
					bs411 &= -65;
				}
				break;
			case 2:
				if(v411) {
					bs411 |= 32;
				} else {
					bs411 &= -33;
				}
				break;
			case 3:
				if(v411) {
					bs411 |= 16;
				} else {
					bs411 &= -17;
				}
				break;
			case 4:
				if(v411) {
					bs411 |= 8;
				} else {
					bs411 &= -9;
				}
				break;
			case 5:
				if(v411) {
					bs411 |= 4;
				} else {
					bs411 &= -5;
				}
				break;
			case 6:
				if(v411) {
					bs411 |= 2;
				} else {
					bs411 &= -3;
				}
				break;
			case 7:
				if(v411) {
					bs411 |= 1;
				} else {
					bs411 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs411;
		var this413 = 0;
		var bs412 = this413;
		var l412 = "*****".length;
		var _g1412 = 0;
		var _g512 = l412;
		while(_g1412 < _g512) {
			var i412 = _g1412++;
			var no412 = "*****".charCodeAt(i412);
			if(no412 == null) {
				break;
			}
			var v412;
			switch(no412) {
			case 32:
				v412 = false;
				break;
			case 42:
				v412 = true;
				break;
			case 48:
				v412 = false;
				break;
			case 49:
				v412 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i412)));
			}
			switch(i412 - (l412 - 8)) {
			case 0:
				if(v412) {
					bs412 |= 128;
				} else {
					bs412 &= -129;
				}
				break;
			case 1:
				if(v412) {
					bs412 |= 64;
				} else {
					bs412 &= -65;
				}
				break;
			case 2:
				if(v412) {
					bs412 |= 32;
				} else {
					bs412 &= -33;
				}
				break;
			case 3:
				if(v412) {
					bs412 |= 16;
				} else {
					bs412 &= -17;
				}
				break;
			case 4:
				if(v412) {
					bs412 |= 8;
				} else {
					bs412 &= -9;
				}
				break;
			case 5:
				if(v412) {
					bs412 |= 4;
				} else {
					bs412 &= -5;
				}
				break;
			case 6:
				if(v412) {
					bs412 |= 2;
				} else {
					bs412 &= -3;
				}
				break;
			case 7:
				if(v412) {
					bs412 |= 1;
				} else {
					bs412 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs412;
		break;
	case 91:
		var this414 = 0;
		var bs413 = this414;
		var l413 = " *** ".length;
		var _g1413 = 0;
		var _g513 = l413;
		while(_g1413 < _g513) {
			var i413 = _g1413++;
			var no413 = " *** ".charCodeAt(i413);
			if(no413 == null) {
				break;
			}
			var v413;
			switch(no413) {
			case 32:
				v413 = false;
				break;
			case 42:
				v413 = true;
				break;
			case 48:
				v413 = false;
				break;
			case 49:
				v413 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i413)));
			}
			switch(i413 - (l413 - 8)) {
			case 0:
				if(v413) {
					bs413 |= 128;
				} else {
					bs413 &= -129;
				}
				break;
			case 1:
				if(v413) {
					bs413 |= 64;
				} else {
					bs413 &= -65;
				}
				break;
			case 2:
				if(v413) {
					bs413 |= 32;
				} else {
					bs413 &= -33;
				}
				break;
			case 3:
				if(v413) {
					bs413 |= 16;
				} else {
					bs413 &= -17;
				}
				break;
			case 4:
				if(v413) {
					bs413 |= 8;
				} else {
					bs413 &= -9;
				}
				break;
			case 5:
				if(v413) {
					bs413 |= 4;
				} else {
					bs413 &= -5;
				}
				break;
			case 6:
				if(v413) {
					bs413 |= 2;
				} else {
					bs413 &= -3;
				}
				break;
			case 7:
				if(v413) {
					bs413 |= 1;
				} else {
					bs413 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs413;
		var this415 = 0;
		var bs414 = this415;
		var l414 = " *   ".length;
		var _g1414 = 0;
		var _g514 = l414;
		while(_g1414 < _g514) {
			var i414 = _g1414++;
			var no414 = " *   ".charCodeAt(i414);
			if(no414 == null) {
				break;
			}
			var v414;
			switch(no414) {
			case 32:
				v414 = false;
				break;
			case 42:
				v414 = true;
				break;
			case 48:
				v414 = false;
				break;
			case 49:
				v414 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i414)));
			}
			switch(i414 - (l414 - 8)) {
			case 0:
				if(v414) {
					bs414 |= 128;
				} else {
					bs414 &= -129;
				}
				break;
			case 1:
				if(v414) {
					bs414 |= 64;
				} else {
					bs414 &= -65;
				}
				break;
			case 2:
				if(v414) {
					bs414 |= 32;
				} else {
					bs414 &= -33;
				}
				break;
			case 3:
				if(v414) {
					bs414 |= 16;
				} else {
					bs414 &= -17;
				}
				break;
			case 4:
				if(v414) {
					bs414 |= 8;
				} else {
					bs414 &= -9;
				}
				break;
			case 5:
				if(v414) {
					bs414 |= 4;
				} else {
					bs414 &= -5;
				}
				break;
			case 6:
				if(v414) {
					bs414 |= 2;
				} else {
					bs414 &= -3;
				}
				break;
			case 7:
				if(v414) {
					bs414 |= 1;
				} else {
					bs414 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs414;
		var this416 = 0;
		var bs415 = this416;
		var l415 = " *   ".length;
		var _g1415 = 0;
		var _g515 = l415;
		while(_g1415 < _g515) {
			var i415 = _g1415++;
			var no415 = " *   ".charCodeAt(i415);
			if(no415 == null) {
				break;
			}
			var v415;
			switch(no415) {
			case 32:
				v415 = false;
				break;
			case 42:
				v415 = true;
				break;
			case 48:
				v415 = false;
				break;
			case 49:
				v415 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i415)));
			}
			switch(i415 - (l415 - 8)) {
			case 0:
				if(v415) {
					bs415 |= 128;
				} else {
					bs415 &= -129;
				}
				break;
			case 1:
				if(v415) {
					bs415 |= 64;
				} else {
					bs415 &= -65;
				}
				break;
			case 2:
				if(v415) {
					bs415 |= 32;
				} else {
					bs415 &= -33;
				}
				break;
			case 3:
				if(v415) {
					bs415 |= 16;
				} else {
					bs415 &= -17;
				}
				break;
			case 4:
				if(v415) {
					bs415 |= 8;
				} else {
					bs415 &= -9;
				}
				break;
			case 5:
				if(v415) {
					bs415 |= 4;
				} else {
					bs415 &= -5;
				}
				break;
			case 6:
				if(v415) {
					bs415 |= 2;
				} else {
					bs415 &= -3;
				}
				break;
			case 7:
				if(v415) {
					bs415 |= 1;
				} else {
					bs415 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs415;
		var this417 = 0;
		var bs416 = this417;
		var l416 = " *   ".length;
		var _g1416 = 0;
		var _g516 = l416;
		while(_g1416 < _g516) {
			var i416 = _g1416++;
			var no416 = " *   ".charCodeAt(i416);
			if(no416 == null) {
				break;
			}
			var v416;
			switch(no416) {
			case 32:
				v416 = false;
				break;
			case 42:
				v416 = true;
				break;
			case 48:
				v416 = false;
				break;
			case 49:
				v416 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i416)));
			}
			switch(i416 - (l416 - 8)) {
			case 0:
				if(v416) {
					bs416 |= 128;
				} else {
					bs416 &= -129;
				}
				break;
			case 1:
				if(v416) {
					bs416 |= 64;
				} else {
					bs416 &= -65;
				}
				break;
			case 2:
				if(v416) {
					bs416 |= 32;
				} else {
					bs416 &= -33;
				}
				break;
			case 3:
				if(v416) {
					bs416 |= 16;
				} else {
					bs416 &= -17;
				}
				break;
			case 4:
				if(v416) {
					bs416 |= 8;
				} else {
					bs416 &= -9;
				}
				break;
			case 5:
				if(v416) {
					bs416 |= 4;
				} else {
					bs416 &= -5;
				}
				break;
			case 6:
				if(v416) {
					bs416 |= 2;
				} else {
					bs416 &= -3;
				}
				break;
			case 7:
				if(v416) {
					bs416 |= 1;
				} else {
					bs416 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs416;
		var this418 = 0;
		var bs417 = this418;
		var l417 = " *   ".length;
		var _g1417 = 0;
		var _g517 = l417;
		while(_g1417 < _g517) {
			var i417 = _g1417++;
			var no417 = " *   ".charCodeAt(i417);
			if(no417 == null) {
				break;
			}
			var v417;
			switch(no417) {
			case 32:
				v417 = false;
				break;
			case 42:
				v417 = true;
				break;
			case 48:
				v417 = false;
				break;
			case 49:
				v417 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i417)));
			}
			switch(i417 - (l417 - 8)) {
			case 0:
				if(v417) {
					bs417 |= 128;
				} else {
					bs417 &= -129;
				}
				break;
			case 1:
				if(v417) {
					bs417 |= 64;
				} else {
					bs417 &= -65;
				}
				break;
			case 2:
				if(v417) {
					bs417 |= 32;
				} else {
					bs417 &= -33;
				}
				break;
			case 3:
				if(v417) {
					bs417 |= 16;
				} else {
					bs417 &= -17;
				}
				break;
			case 4:
				if(v417) {
					bs417 |= 8;
				} else {
					bs417 &= -9;
				}
				break;
			case 5:
				if(v417) {
					bs417 |= 4;
				} else {
					bs417 &= -5;
				}
				break;
			case 6:
				if(v417) {
					bs417 |= 2;
				} else {
					bs417 &= -3;
				}
				break;
			case 7:
				if(v417) {
					bs417 |= 1;
				} else {
					bs417 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs417;
		var this419 = 0;
		var bs418 = this419;
		var l418 = " *   ".length;
		var _g1418 = 0;
		var _g518 = l418;
		while(_g1418 < _g518) {
			var i418 = _g1418++;
			var no418 = " *   ".charCodeAt(i418);
			if(no418 == null) {
				break;
			}
			var v418;
			switch(no418) {
			case 32:
				v418 = false;
				break;
			case 42:
				v418 = true;
				break;
			case 48:
				v418 = false;
				break;
			case 49:
				v418 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i418)));
			}
			switch(i418 - (l418 - 8)) {
			case 0:
				if(v418) {
					bs418 |= 128;
				} else {
					bs418 &= -129;
				}
				break;
			case 1:
				if(v418) {
					bs418 |= 64;
				} else {
					bs418 &= -65;
				}
				break;
			case 2:
				if(v418) {
					bs418 |= 32;
				} else {
					bs418 &= -33;
				}
				break;
			case 3:
				if(v418) {
					bs418 |= 16;
				} else {
					bs418 &= -17;
				}
				break;
			case 4:
				if(v418) {
					bs418 |= 8;
				} else {
					bs418 &= -9;
				}
				break;
			case 5:
				if(v418) {
					bs418 |= 4;
				} else {
					bs418 &= -5;
				}
				break;
			case 6:
				if(v418) {
					bs418 |= 2;
				} else {
					bs418 &= -3;
				}
				break;
			case 7:
				if(v418) {
					bs418 |= 1;
				} else {
					bs418 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs418;
		var this420 = 0;
		var bs419 = this420;
		var l419 = " *** ".length;
		var _g1419 = 0;
		var _g519 = l419;
		while(_g1419 < _g519) {
			var i419 = _g1419++;
			var no419 = " *** ".charCodeAt(i419);
			if(no419 == null) {
				break;
			}
			var v419;
			switch(no419) {
			case 32:
				v419 = false;
				break;
			case 42:
				v419 = true;
				break;
			case 48:
				v419 = false;
				break;
			case 49:
				v419 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i419)));
			}
			switch(i419 - (l419 - 8)) {
			case 0:
				if(v419) {
					bs419 |= 128;
				} else {
					bs419 &= -129;
				}
				break;
			case 1:
				if(v419) {
					bs419 |= 64;
				} else {
					bs419 &= -65;
				}
				break;
			case 2:
				if(v419) {
					bs419 |= 32;
				} else {
					bs419 &= -33;
				}
				break;
			case 3:
				if(v419) {
					bs419 |= 16;
				} else {
					bs419 &= -17;
				}
				break;
			case 4:
				if(v419) {
					bs419 |= 8;
				} else {
					bs419 &= -9;
				}
				break;
			case 5:
				if(v419) {
					bs419 |= 4;
				} else {
					bs419 &= -5;
				}
				break;
			case 6:
				if(v419) {
					bs419 |= 2;
				} else {
					bs419 &= -3;
				}
				break;
			case 7:
				if(v419) {
					bs419 |= 1;
				} else {
					bs419 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs419;
		break;
	case 92:
		var this421 = 0;
		var bs420 = this421;
		var l420 = "*    ".length;
		var _g1420 = 0;
		var _g520 = l420;
		while(_g1420 < _g520) {
			var i420 = _g1420++;
			var no420 = "*    ".charCodeAt(i420);
			if(no420 == null) {
				break;
			}
			var v420;
			switch(no420) {
			case 32:
				v420 = false;
				break;
			case 42:
				v420 = true;
				break;
			case 48:
				v420 = false;
				break;
			case 49:
				v420 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i420)));
			}
			switch(i420 - (l420 - 8)) {
			case 0:
				if(v420) {
					bs420 |= 128;
				} else {
					bs420 &= -129;
				}
				break;
			case 1:
				if(v420) {
					bs420 |= 64;
				} else {
					bs420 &= -65;
				}
				break;
			case 2:
				if(v420) {
					bs420 |= 32;
				} else {
					bs420 &= -33;
				}
				break;
			case 3:
				if(v420) {
					bs420 |= 16;
				} else {
					bs420 &= -17;
				}
				break;
			case 4:
				if(v420) {
					bs420 |= 8;
				} else {
					bs420 &= -9;
				}
				break;
			case 5:
				if(v420) {
					bs420 |= 4;
				} else {
					bs420 &= -5;
				}
				break;
			case 6:
				if(v420) {
					bs420 |= 2;
				} else {
					bs420 &= -3;
				}
				break;
			case 7:
				if(v420) {
					bs420 |= 1;
				} else {
					bs420 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs420;
		var this422 = 0;
		var bs421 = this422;
		var l421 = " *   ".length;
		var _g1421 = 0;
		var _g521 = l421;
		while(_g1421 < _g521) {
			var i421 = _g1421++;
			var no421 = " *   ".charCodeAt(i421);
			if(no421 == null) {
				break;
			}
			var v421;
			switch(no421) {
			case 32:
				v421 = false;
				break;
			case 42:
				v421 = true;
				break;
			case 48:
				v421 = false;
				break;
			case 49:
				v421 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i421)));
			}
			switch(i421 - (l421 - 8)) {
			case 0:
				if(v421) {
					bs421 |= 128;
				} else {
					bs421 &= -129;
				}
				break;
			case 1:
				if(v421) {
					bs421 |= 64;
				} else {
					bs421 &= -65;
				}
				break;
			case 2:
				if(v421) {
					bs421 |= 32;
				} else {
					bs421 &= -33;
				}
				break;
			case 3:
				if(v421) {
					bs421 |= 16;
				} else {
					bs421 &= -17;
				}
				break;
			case 4:
				if(v421) {
					bs421 |= 8;
				} else {
					bs421 &= -9;
				}
				break;
			case 5:
				if(v421) {
					bs421 |= 4;
				} else {
					bs421 &= -5;
				}
				break;
			case 6:
				if(v421) {
					bs421 |= 2;
				} else {
					bs421 &= -3;
				}
				break;
			case 7:
				if(v421) {
					bs421 |= 1;
				} else {
					bs421 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs421;
		var this423 = 0;
		var bs422 = this423;
		var l422 = "  *  ".length;
		var _g1422 = 0;
		var _g522 = l422;
		while(_g1422 < _g522) {
			var i422 = _g1422++;
			var no422 = "  *  ".charCodeAt(i422);
			if(no422 == null) {
				break;
			}
			var v422;
			switch(no422) {
			case 32:
				v422 = false;
				break;
			case 42:
				v422 = true;
				break;
			case 48:
				v422 = false;
				break;
			case 49:
				v422 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i422)));
			}
			switch(i422 - (l422 - 8)) {
			case 0:
				if(v422) {
					bs422 |= 128;
				} else {
					bs422 &= -129;
				}
				break;
			case 1:
				if(v422) {
					bs422 |= 64;
				} else {
					bs422 &= -65;
				}
				break;
			case 2:
				if(v422) {
					bs422 |= 32;
				} else {
					bs422 &= -33;
				}
				break;
			case 3:
				if(v422) {
					bs422 |= 16;
				} else {
					bs422 &= -17;
				}
				break;
			case 4:
				if(v422) {
					bs422 |= 8;
				} else {
					bs422 &= -9;
				}
				break;
			case 5:
				if(v422) {
					bs422 |= 4;
				} else {
					bs422 &= -5;
				}
				break;
			case 6:
				if(v422) {
					bs422 |= 2;
				} else {
					bs422 &= -3;
				}
				break;
			case 7:
				if(v422) {
					bs422 |= 1;
				} else {
					bs422 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs422;
		var this424 = 0;
		var bs423 = this424;
		var l423 = "  *  ".length;
		var _g1423 = 0;
		var _g523 = l423;
		while(_g1423 < _g523) {
			var i423 = _g1423++;
			var no423 = "  *  ".charCodeAt(i423);
			if(no423 == null) {
				break;
			}
			var v423;
			switch(no423) {
			case 32:
				v423 = false;
				break;
			case 42:
				v423 = true;
				break;
			case 48:
				v423 = false;
				break;
			case 49:
				v423 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i423)));
			}
			switch(i423 - (l423 - 8)) {
			case 0:
				if(v423) {
					bs423 |= 128;
				} else {
					bs423 &= -129;
				}
				break;
			case 1:
				if(v423) {
					bs423 |= 64;
				} else {
					bs423 &= -65;
				}
				break;
			case 2:
				if(v423) {
					bs423 |= 32;
				} else {
					bs423 &= -33;
				}
				break;
			case 3:
				if(v423) {
					bs423 |= 16;
				} else {
					bs423 &= -17;
				}
				break;
			case 4:
				if(v423) {
					bs423 |= 8;
				} else {
					bs423 &= -9;
				}
				break;
			case 5:
				if(v423) {
					bs423 |= 4;
				} else {
					bs423 &= -5;
				}
				break;
			case 6:
				if(v423) {
					bs423 |= 2;
				} else {
					bs423 &= -3;
				}
				break;
			case 7:
				if(v423) {
					bs423 |= 1;
				} else {
					bs423 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs423;
		var this425 = 0;
		var bs424 = this425;
		var l424 = "   * ".length;
		var _g1424 = 0;
		var _g524 = l424;
		while(_g1424 < _g524) {
			var i424 = _g1424++;
			var no424 = "   * ".charCodeAt(i424);
			if(no424 == null) {
				break;
			}
			var v424;
			switch(no424) {
			case 32:
				v424 = false;
				break;
			case 42:
				v424 = true;
				break;
			case 48:
				v424 = false;
				break;
			case 49:
				v424 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i424)));
			}
			switch(i424 - (l424 - 8)) {
			case 0:
				if(v424) {
					bs424 |= 128;
				} else {
					bs424 &= -129;
				}
				break;
			case 1:
				if(v424) {
					bs424 |= 64;
				} else {
					bs424 &= -65;
				}
				break;
			case 2:
				if(v424) {
					bs424 |= 32;
				} else {
					bs424 &= -33;
				}
				break;
			case 3:
				if(v424) {
					bs424 |= 16;
				} else {
					bs424 &= -17;
				}
				break;
			case 4:
				if(v424) {
					bs424 |= 8;
				} else {
					bs424 &= -9;
				}
				break;
			case 5:
				if(v424) {
					bs424 |= 4;
				} else {
					bs424 &= -5;
				}
				break;
			case 6:
				if(v424) {
					bs424 |= 2;
				} else {
					bs424 &= -3;
				}
				break;
			case 7:
				if(v424) {
					bs424 |= 1;
				} else {
					bs424 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs424;
		var this426 = 0;
		var bs425 = this426;
		var l425 = "   * ".length;
		var _g1425 = 0;
		var _g525 = l425;
		while(_g1425 < _g525) {
			var i425 = _g1425++;
			var no425 = "   * ".charCodeAt(i425);
			if(no425 == null) {
				break;
			}
			var v425;
			switch(no425) {
			case 32:
				v425 = false;
				break;
			case 42:
				v425 = true;
				break;
			case 48:
				v425 = false;
				break;
			case 49:
				v425 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i425)));
			}
			switch(i425 - (l425 - 8)) {
			case 0:
				if(v425) {
					bs425 |= 128;
				} else {
					bs425 &= -129;
				}
				break;
			case 1:
				if(v425) {
					bs425 |= 64;
				} else {
					bs425 &= -65;
				}
				break;
			case 2:
				if(v425) {
					bs425 |= 32;
				} else {
					bs425 &= -33;
				}
				break;
			case 3:
				if(v425) {
					bs425 |= 16;
				} else {
					bs425 &= -17;
				}
				break;
			case 4:
				if(v425) {
					bs425 |= 8;
				} else {
					bs425 &= -9;
				}
				break;
			case 5:
				if(v425) {
					bs425 |= 4;
				} else {
					bs425 &= -5;
				}
				break;
			case 6:
				if(v425) {
					bs425 |= 2;
				} else {
					bs425 &= -3;
				}
				break;
			case 7:
				if(v425) {
					bs425 |= 1;
				} else {
					bs425 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs425;
		var this427 = 0;
		var bs426 = this427;
		var l426 = "    *".length;
		var _g1426 = 0;
		var _g526 = l426;
		while(_g1426 < _g526) {
			var i426 = _g1426++;
			var no426 = "    *".charCodeAt(i426);
			if(no426 == null) {
				break;
			}
			var v426;
			switch(no426) {
			case 32:
				v426 = false;
				break;
			case 42:
				v426 = true;
				break;
			case 48:
				v426 = false;
				break;
			case 49:
				v426 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i426)));
			}
			switch(i426 - (l426 - 8)) {
			case 0:
				if(v426) {
					bs426 |= 128;
				} else {
					bs426 &= -129;
				}
				break;
			case 1:
				if(v426) {
					bs426 |= 64;
				} else {
					bs426 &= -65;
				}
				break;
			case 2:
				if(v426) {
					bs426 |= 32;
				} else {
					bs426 &= -33;
				}
				break;
			case 3:
				if(v426) {
					bs426 |= 16;
				} else {
					bs426 &= -17;
				}
				break;
			case 4:
				if(v426) {
					bs426 |= 8;
				} else {
					bs426 &= -9;
				}
				break;
			case 5:
				if(v426) {
					bs426 |= 4;
				} else {
					bs426 &= -5;
				}
				break;
			case 6:
				if(v426) {
					bs426 |= 2;
				} else {
					bs426 &= -3;
				}
				break;
			case 7:
				if(v426) {
					bs426 |= 1;
				} else {
					bs426 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs426;
		break;
	case 93:
		var this428 = 0;
		var bs427 = this428;
		var l427 = " *** ".length;
		var _g1427 = 0;
		var _g527 = l427;
		while(_g1427 < _g527) {
			var i427 = _g1427++;
			var no427 = " *** ".charCodeAt(i427);
			if(no427 == null) {
				break;
			}
			var v427;
			switch(no427) {
			case 32:
				v427 = false;
				break;
			case 42:
				v427 = true;
				break;
			case 48:
				v427 = false;
				break;
			case 49:
				v427 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i427)));
			}
			switch(i427 - (l427 - 8)) {
			case 0:
				if(v427) {
					bs427 |= 128;
				} else {
					bs427 &= -129;
				}
				break;
			case 1:
				if(v427) {
					bs427 |= 64;
				} else {
					bs427 &= -65;
				}
				break;
			case 2:
				if(v427) {
					bs427 |= 32;
				} else {
					bs427 &= -33;
				}
				break;
			case 3:
				if(v427) {
					bs427 |= 16;
				} else {
					bs427 &= -17;
				}
				break;
			case 4:
				if(v427) {
					bs427 |= 8;
				} else {
					bs427 &= -9;
				}
				break;
			case 5:
				if(v427) {
					bs427 |= 4;
				} else {
					bs427 &= -5;
				}
				break;
			case 6:
				if(v427) {
					bs427 |= 2;
				} else {
					bs427 &= -3;
				}
				break;
			case 7:
				if(v427) {
					bs427 |= 1;
				} else {
					bs427 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs427;
		var this429 = 0;
		var bs428 = this429;
		var l428 = "   * ".length;
		var _g1428 = 0;
		var _g528 = l428;
		while(_g1428 < _g528) {
			var i428 = _g1428++;
			var no428 = "   * ".charCodeAt(i428);
			if(no428 == null) {
				break;
			}
			var v428;
			switch(no428) {
			case 32:
				v428 = false;
				break;
			case 42:
				v428 = true;
				break;
			case 48:
				v428 = false;
				break;
			case 49:
				v428 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i428)));
			}
			switch(i428 - (l428 - 8)) {
			case 0:
				if(v428) {
					bs428 |= 128;
				} else {
					bs428 &= -129;
				}
				break;
			case 1:
				if(v428) {
					bs428 |= 64;
				} else {
					bs428 &= -65;
				}
				break;
			case 2:
				if(v428) {
					bs428 |= 32;
				} else {
					bs428 &= -33;
				}
				break;
			case 3:
				if(v428) {
					bs428 |= 16;
				} else {
					bs428 &= -17;
				}
				break;
			case 4:
				if(v428) {
					bs428 |= 8;
				} else {
					bs428 &= -9;
				}
				break;
			case 5:
				if(v428) {
					bs428 |= 4;
				} else {
					bs428 &= -5;
				}
				break;
			case 6:
				if(v428) {
					bs428 |= 2;
				} else {
					bs428 &= -3;
				}
				break;
			case 7:
				if(v428) {
					bs428 |= 1;
				} else {
					bs428 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs428;
		var this430 = 0;
		var bs429 = this430;
		var l429 = "   * ".length;
		var _g1429 = 0;
		var _g529 = l429;
		while(_g1429 < _g529) {
			var i429 = _g1429++;
			var no429 = "   * ".charCodeAt(i429);
			if(no429 == null) {
				break;
			}
			var v429;
			switch(no429) {
			case 32:
				v429 = false;
				break;
			case 42:
				v429 = true;
				break;
			case 48:
				v429 = false;
				break;
			case 49:
				v429 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i429)));
			}
			switch(i429 - (l429 - 8)) {
			case 0:
				if(v429) {
					bs429 |= 128;
				} else {
					bs429 &= -129;
				}
				break;
			case 1:
				if(v429) {
					bs429 |= 64;
				} else {
					bs429 &= -65;
				}
				break;
			case 2:
				if(v429) {
					bs429 |= 32;
				} else {
					bs429 &= -33;
				}
				break;
			case 3:
				if(v429) {
					bs429 |= 16;
				} else {
					bs429 &= -17;
				}
				break;
			case 4:
				if(v429) {
					bs429 |= 8;
				} else {
					bs429 &= -9;
				}
				break;
			case 5:
				if(v429) {
					bs429 |= 4;
				} else {
					bs429 &= -5;
				}
				break;
			case 6:
				if(v429) {
					bs429 |= 2;
				} else {
					bs429 &= -3;
				}
				break;
			case 7:
				if(v429) {
					bs429 |= 1;
				} else {
					bs429 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs429;
		var this431 = 0;
		var bs430 = this431;
		var l430 = "   * ".length;
		var _g1430 = 0;
		var _g530 = l430;
		while(_g1430 < _g530) {
			var i430 = _g1430++;
			var no430 = "   * ".charCodeAt(i430);
			if(no430 == null) {
				break;
			}
			var v430;
			switch(no430) {
			case 32:
				v430 = false;
				break;
			case 42:
				v430 = true;
				break;
			case 48:
				v430 = false;
				break;
			case 49:
				v430 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i430)));
			}
			switch(i430 - (l430 - 8)) {
			case 0:
				if(v430) {
					bs430 |= 128;
				} else {
					bs430 &= -129;
				}
				break;
			case 1:
				if(v430) {
					bs430 |= 64;
				} else {
					bs430 &= -65;
				}
				break;
			case 2:
				if(v430) {
					bs430 |= 32;
				} else {
					bs430 &= -33;
				}
				break;
			case 3:
				if(v430) {
					bs430 |= 16;
				} else {
					bs430 &= -17;
				}
				break;
			case 4:
				if(v430) {
					bs430 |= 8;
				} else {
					bs430 &= -9;
				}
				break;
			case 5:
				if(v430) {
					bs430 |= 4;
				} else {
					bs430 &= -5;
				}
				break;
			case 6:
				if(v430) {
					bs430 |= 2;
				} else {
					bs430 &= -3;
				}
				break;
			case 7:
				if(v430) {
					bs430 |= 1;
				} else {
					bs430 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs430;
		var this432 = 0;
		var bs431 = this432;
		var l431 = "   * ".length;
		var _g1431 = 0;
		var _g531 = l431;
		while(_g1431 < _g531) {
			var i431 = _g1431++;
			var no431 = "   * ".charCodeAt(i431);
			if(no431 == null) {
				break;
			}
			var v431;
			switch(no431) {
			case 32:
				v431 = false;
				break;
			case 42:
				v431 = true;
				break;
			case 48:
				v431 = false;
				break;
			case 49:
				v431 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i431)));
			}
			switch(i431 - (l431 - 8)) {
			case 0:
				if(v431) {
					bs431 |= 128;
				} else {
					bs431 &= -129;
				}
				break;
			case 1:
				if(v431) {
					bs431 |= 64;
				} else {
					bs431 &= -65;
				}
				break;
			case 2:
				if(v431) {
					bs431 |= 32;
				} else {
					bs431 &= -33;
				}
				break;
			case 3:
				if(v431) {
					bs431 |= 16;
				} else {
					bs431 &= -17;
				}
				break;
			case 4:
				if(v431) {
					bs431 |= 8;
				} else {
					bs431 &= -9;
				}
				break;
			case 5:
				if(v431) {
					bs431 |= 4;
				} else {
					bs431 &= -5;
				}
				break;
			case 6:
				if(v431) {
					bs431 |= 2;
				} else {
					bs431 &= -3;
				}
				break;
			case 7:
				if(v431) {
					bs431 |= 1;
				} else {
					bs431 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs431;
		var this433 = 0;
		var bs432 = this433;
		var l432 = "   * ".length;
		var _g1432 = 0;
		var _g532 = l432;
		while(_g1432 < _g532) {
			var i432 = _g1432++;
			var no432 = "   * ".charCodeAt(i432);
			if(no432 == null) {
				break;
			}
			var v432;
			switch(no432) {
			case 32:
				v432 = false;
				break;
			case 42:
				v432 = true;
				break;
			case 48:
				v432 = false;
				break;
			case 49:
				v432 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i432)));
			}
			switch(i432 - (l432 - 8)) {
			case 0:
				if(v432) {
					bs432 |= 128;
				} else {
					bs432 &= -129;
				}
				break;
			case 1:
				if(v432) {
					bs432 |= 64;
				} else {
					bs432 &= -65;
				}
				break;
			case 2:
				if(v432) {
					bs432 |= 32;
				} else {
					bs432 &= -33;
				}
				break;
			case 3:
				if(v432) {
					bs432 |= 16;
				} else {
					bs432 &= -17;
				}
				break;
			case 4:
				if(v432) {
					bs432 |= 8;
				} else {
					bs432 &= -9;
				}
				break;
			case 5:
				if(v432) {
					bs432 |= 4;
				} else {
					bs432 &= -5;
				}
				break;
			case 6:
				if(v432) {
					bs432 |= 2;
				} else {
					bs432 &= -3;
				}
				break;
			case 7:
				if(v432) {
					bs432 |= 1;
				} else {
					bs432 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs432;
		var this434 = 0;
		var bs433 = this434;
		var l433 = " *** ".length;
		var _g1433 = 0;
		var _g533 = l433;
		while(_g1433 < _g533) {
			var i433 = _g1433++;
			var no433 = " *** ".charCodeAt(i433);
			if(no433 == null) {
				break;
			}
			var v433;
			switch(no433) {
			case 32:
				v433 = false;
				break;
			case 42:
				v433 = true;
				break;
			case 48:
				v433 = false;
				break;
			case 49:
				v433 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i433)));
			}
			switch(i433 - (l433 - 8)) {
			case 0:
				if(v433) {
					bs433 |= 128;
				} else {
					bs433 &= -129;
				}
				break;
			case 1:
				if(v433) {
					bs433 |= 64;
				} else {
					bs433 &= -65;
				}
				break;
			case 2:
				if(v433) {
					bs433 |= 32;
				} else {
					bs433 &= -33;
				}
				break;
			case 3:
				if(v433) {
					bs433 |= 16;
				} else {
					bs433 &= -17;
				}
				break;
			case 4:
				if(v433) {
					bs433 |= 8;
				} else {
					bs433 &= -9;
				}
				break;
			case 5:
				if(v433) {
					bs433 |= 4;
				} else {
					bs433 &= -5;
				}
				break;
			case 6:
				if(v433) {
					bs433 |= 2;
				} else {
					bs433 &= -3;
				}
				break;
			case 7:
				if(v433) {
					bs433 |= 1;
				} else {
					bs433 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs433;
		break;
	case 94:
		var this435 = 0;
		var bs434 = this435;
		var l434 = "  *  ".length;
		var _g1434 = 0;
		var _g534 = l434;
		while(_g1434 < _g534) {
			var i434 = _g1434++;
			var no434 = "  *  ".charCodeAt(i434);
			if(no434 == null) {
				break;
			}
			var v434;
			switch(no434) {
			case 32:
				v434 = false;
				break;
			case 42:
				v434 = true;
				break;
			case 48:
				v434 = false;
				break;
			case 49:
				v434 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i434)));
			}
			switch(i434 - (l434 - 8)) {
			case 0:
				if(v434) {
					bs434 |= 128;
				} else {
					bs434 &= -129;
				}
				break;
			case 1:
				if(v434) {
					bs434 |= 64;
				} else {
					bs434 &= -65;
				}
				break;
			case 2:
				if(v434) {
					bs434 |= 32;
				} else {
					bs434 &= -33;
				}
				break;
			case 3:
				if(v434) {
					bs434 |= 16;
				} else {
					bs434 &= -17;
				}
				break;
			case 4:
				if(v434) {
					bs434 |= 8;
				} else {
					bs434 &= -9;
				}
				break;
			case 5:
				if(v434) {
					bs434 |= 4;
				} else {
					bs434 &= -5;
				}
				break;
			case 6:
				if(v434) {
					bs434 |= 2;
				} else {
					bs434 &= -3;
				}
				break;
			case 7:
				if(v434) {
					bs434 |= 1;
				} else {
					bs434 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs434;
		var this436 = 0;
		var bs435 = this436;
		var l435 = " * * ".length;
		var _g1435 = 0;
		var _g535 = l435;
		while(_g1435 < _g535) {
			var i435 = _g1435++;
			var no435 = " * * ".charCodeAt(i435);
			if(no435 == null) {
				break;
			}
			var v435;
			switch(no435) {
			case 32:
				v435 = false;
				break;
			case 42:
				v435 = true;
				break;
			case 48:
				v435 = false;
				break;
			case 49:
				v435 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i435)));
			}
			switch(i435 - (l435 - 8)) {
			case 0:
				if(v435) {
					bs435 |= 128;
				} else {
					bs435 &= -129;
				}
				break;
			case 1:
				if(v435) {
					bs435 |= 64;
				} else {
					bs435 &= -65;
				}
				break;
			case 2:
				if(v435) {
					bs435 |= 32;
				} else {
					bs435 &= -33;
				}
				break;
			case 3:
				if(v435) {
					bs435 |= 16;
				} else {
					bs435 &= -17;
				}
				break;
			case 4:
				if(v435) {
					bs435 |= 8;
				} else {
					bs435 &= -9;
				}
				break;
			case 5:
				if(v435) {
					bs435 |= 4;
				} else {
					bs435 &= -5;
				}
				break;
			case 6:
				if(v435) {
					bs435 |= 2;
				} else {
					bs435 &= -3;
				}
				break;
			case 7:
				if(v435) {
					bs435 |= 1;
				} else {
					bs435 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs435;
		var this437 = 0;
		var bs436 = this437;
		var l436 = "*   *".length;
		var _g1436 = 0;
		var _g536 = l436;
		while(_g1436 < _g536) {
			var i436 = _g1436++;
			var no436 = "*   *".charCodeAt(i436);
			if(no436 == null) {
				break;
			}
			var v436;
			switch(no436) {
			case 32:
				v436 = false;
				break;
			case 42:
				v436 = true;
				break;
			case 48:
				v436 = false;
				break;
			case 49:
				v436 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i436)));
			}
			switch(i436 - (l436 - 8)) {
			case 0:
				if(v436) {
					bs436 |= 128;
				} else {
					bs436 &= -129;
				}
				break;
			case 1:
				if(v436) {
					bs436 |= 64;
				} else {
					bs436 &= -65;
				}
				break;
			case 2:
				if(v436) {
					bs436 |= 32;
				} else {
					bs436 &= -33;
				}
				break;
			case 3:
				if(v436) {
					bs436 |= 16;
				} else {
					bs436 &= -17;
				}
				break;
			case 4:
				if(v436) {
					bs436 |= 8;
				} else {
					bs436 &= -9;
				}
				break;
			case 5:
				if(v436) {
					bs436 |= 4;
				} else {
					bs436 &= -5;
				}
				break;
			case 6:
				if(v436) {
					bs436 |= 2;
				} else {
					bs436 &= -3;
				}
				break;
			case 7:
				if(v436) {
					bs436 |= 1;
				} else {
					bs436 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs436;
		var this438 = 0;
		var bs437 = this438;
		var l437 = "     ".length;
		var _g1437 = 0;
		var _g537 = l437;
		while(_g1437 < _g537) {
			var i437 = _g1437++;
			var no437 = "     ".charCodeAt(i437);
			if(no437 == null) {
				break;
			}
			var v437;
			switch(no437) {
			case 32:
				v437 = false;
				break;
			case 42:
				v437 = true;
				break;
			case 48:
				v437 = false;
				break;
			case 49:
				v437 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i437)));
			}
			switch(i437 - (l437 - 8)) {
			case 0:
				if(v437) {
					bs437 |= 128;
				} else {
					bs437 &= -129;
				}
				break;
			case 1:
				if(v437) {
					bs437 |= 64;
				} else {
					bs437 &= -65;
				}
				break;
			case 2:
				if(v437) {
					bs437 |= 32;
				} else {
					bs437 &= -33;
				}
				break;
			case 3:
				if(v437) {
					bs437 |= 16;
				} else {
					bs437 &= -17;
				}
				break;
			case 4:
				if(v437) {
					bs437 |= 8;
				} else {
					bs437 &= -9;
				}
				break;
			case 5:
				if(v437) {
					bs437 |= 4;
				} else {
					bs437 &= -5;
				}
				break;
			case 6:
				if(v437) {
					bs437 |= 2;
				} else {
					bs437 &= -3;
				}
				break;
			case 7:
				if(v437) {
					bs437 |= 1;
				} else {
					bs437 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs437;
		var this439 = 0;
		var bs438 = this439;
		var l438 = "     ".length;
		var _g1438 = 0;
		var _g538 = l438;
		while(_g1438 < _g538) {
			var i438 = _g1438++;
			var no438 = "     ".charCodeAt(i438);
			if(no438 == null) {
				break;
			}
			var v438;
			switch(no438) {
			case 32:
				v438 = false;
				break;
			case 42:
				v438 = true;
				break;
			case 48:
				v438 = false;
				break;
			case 49:
				v438 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i438)));
			}
			switch(i438 - (l438 - 8)) {
			case 0:
				if(v438) {
					bs438 |= 128;
				} else {
					bs438 &= -129;
				}
				break;
			case 1:
				if(v438) {
					bs438 |= 64;
				} else {
					bs438 &= -65;
				}
				break;
			case 2:
				if(v438) {
					bs438 |= 32;
				} else {
					bs438 &= -33;
				}
				break;
			case 3:
				if(v438) {
					bs438 |= 16;
				} else {
					bs438 &= -17;
				}
				break;
			case 4:
				if(v438) {
					bs438 |= 8;
				} else {
					bs438 &= -9;
				}
				break;
			case 5:
				if(v438) {
					bs438 |= 4;
				} else {
					bs438 &= -5;
				}
				break;
			case 6:
				if(v438) {
					bs438 |= 2;
				} else {
					bs438 &= -3;
				}
				break;
			case 7:
				if(v438) {
					bs438 |= 1;
				} else {
					bs438 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs438;
		var this440 = 0;
		var bs439 = this440;
		var l439 = "     ".length;
		var _g1439 = 0;
		var _g539 = l439;
		while(_g1439 < _g539) {
			var i439 = _g1439++;
			var no439 = "     ".charCodeAt(i439);
			if(no439 == null) {
				break;
			}
			var v439;
			switch(no439) {
			case 32:
				v439 = false;
				break;
			case 42:
				v439 = true;
				break;
			case 48:
				v439 = false;
				break;
			case 49:
				v439 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i439)));
			}
			switch(i439 - (l439 - 8)) {
			case 0:
				if(v439) {
					bs439 |= 128;
				} else {
					bs439 &= -129;
				}
				break;
			case 1:
				if(v439) {
					bs439 |= 64;
				} else {
					bs439 &= -65;
				}
				break;
			case 2:
				if(v439) {
					bs439 |= 32;
				} else {
					bs439 &= -33;
				}
				break;
			case 3:
				if(v439) {
					bs439 |= 16;
				} else {
					bs439 &= -17;
				}
				break;
			case 4:
				if(v439) {
					bs439 |= 8;
				} else {
					bs439 &= -9;
				}
				break;
			case 5:
				if(v439) {
					bs439 |= 4;
				} else {
					bs439 &= -5;
				}
				break;
			case 6:
				if(v439) {
					bs439 |= 2;
				} else {
					bs439 &= -3;
				}
				break;
			case 7:
				if(v439) {
					bs439 |= 1;
				} else {
					bs439 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs439;
		var this441 = 0;
		var bs440 = this441;
		var l440 = "     ".length;
		var _g1440 = 0;
		var _g540 = l440;
		while(_g1440 < _g540) {
			var i440 = _g1440++;
			var no440 = "     ".charCodeAt(i440);
			if(no440 == null) {
				break;
			}
			var v440;
			switch(no440) {
			case 32:
				v440 = false;
				break;
			case 42:
				v440 = true;
				break;
			case 48:
				v440 = false;
				break;
			case 49:
				v440 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i440)));
			}
			switch(i440 - (l440 - 8)) {
			case 0:
				if(v440) {
					bs440 |= 128;
				} else {
					bs440 &= -129;
				}
				break;
			case 1:
				if(v440) {
					bs440 |= 64;
				} else {
					bs440 &= -65;
				}
				break;
			case 2:
				if(v440) {
					bs440 |= 32;
				} else {
					bs440 &= -33;
				}
				break;
			case 3:
				if(v440) {
					bs440 |= 16;
				} else {
					bs440 &= -17;
				}
				break;
			case 4:
				if(v440) {
					bs440 |= 8;
				} else {
					bs440 &= -9;
				}
				break;
			case 5:
				if(v440) {
					bs440 |= 4;
				} else {
					bs440 &= -5;
				}
				break;
			case 6:
				if(v440) {
					bs440 |= 2;
				} else {
					bs440 &= -3;
				}
				break;
			case 7:
				if(v440) {
					bs440 |= 1;
				} else {
					bs440 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs440;
		break;
	case 95:
		var this442 = 0;
		var bs441 = this442;
		var l441 = "     ".length;
		var _g1441 = 0;
		var _g541 = l441;
		while(_g1441 < _g541) {
			var i441 = _g1441++;
			var no441 = "     ".charCodeAt(i441);
			if(no441 == null) {
				break;
			}
			var v441;
			switch(no441) {
			case 32:
				v441 = false;
				break;
			case 42:
				v441 = true;
				break;
			case 48:
				v441 = false;
				break;
			case 49:
				v441 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i441)));
			}
			switch(i441 - (l441 - 8)) {
			case 0:
				if(v441) {
					bs441 |= 128;
				} else {
					bs441 &= -129;
				}
				break;
			case 1:
				if(v441) {
					bs441 |= 64;
				} else {
					bs441 &= -65;
				}
				break;
			case 2:
				if(v441) {
					bs441 |= 32;
				} else {
					bs441 &= -33;
				}
				break;
			case 3:
				if(v441) {
					bs441 |= 16;
				} else {
					bs441 &= -17;
				}
				break;
			case 4:
				if(v441) {
					bs441 |= 8;
				} else {
					bs441 &= -9;
				}
				break;
			case 5:
				if(v441) {
					bs441 |= 4;
				} else {
					bs441 &= -5;
				}
				break;
			case 6:
				if(v441) {
					bs441 |= 2;
				} else {
					bs441 &= -3;
				}
				break;
			case 7:
				if(v441) {
					bs441 |= 1;
				} else {
					bs441 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs441;
		var this443 = 0;
		var bs442 = this443;
		var l442 = "     ".length;
		var _g1442 = 0;
		var _g542 = l442;
		while(_g1442 < _g542) {
			var i442 = _g1442++;
			var no442 = "     ".charCodeAt(i442);
			if(no442 == null) {
				break;
			}
			var v442;
			switch(no442) {
			case 32:
				v442 = false;
				break;
			case 42:
				v442 = true;
				break;
			case 48:
				v442 = false;
				break;
			case 49:
				v442 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i442)));
			}
			switch(i442 - (l442 - 8)) {
			case 0:
				if(v442) {
					bs442 |= 128;
				} else {
					bs442 &= -129;
				}
				break;
			case 1:
				if(v442) {
					bs442 |= 64;
				} else {
					bs442 &= -65;
				}
				break;
			case 2:
				if(v442) {
					bs442 |= 32;
				} else {
					bs442 &= -33;
				}
				break;
			case 3:
				if(v442) {
					bs442 |= 16;
				} else {
					bs442 &= -17;
				}
				break;
			case 4:
				if(v442) {
					bs442 |= 8;
				} else {
					bs442 &= -9;
				}
				break;
			case 5:
				if(v442) {
					bs442 |= 4;
				} else {
					bs442 &= -5;
				}
				break;
			case 6:
				if(v442) {
					bs442 |= 2;
				} else {
					bs442 &= -3;
				}
				break;
			case 7:
				if(v442) {
					bs442 |= 1;
				} else {
					bs442 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs442;
		var this444 = 0;
		var bs443 = this444;
		var l443 = "     ".length;
		var _g1443 = 0;
		var _g543 = l443;
		while(_g1443 < _g543) {
			var i443 = _g1443++;
			var no443 = "     ".charCodeAt(i443);
			if(no443 == null) {
				break;
			}
			var v443;
			switch(no443) {
			case 32:
				v443 = false;
				break;
			case 42:
				v443 = true;
				break;
			case 48:
				v443 = false;
				break;
			case 49:
				v443 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i443)));
			}
			switch(i443 - (l443 - 8)) {
			case 0:
				if(v443) {
					bs443 |= 128;
				} else {
					bs443 &= -129;
				}
				break;
			case 1:
				if(v443) {
					bs443 |= 64;
				} else {
					bs443 &= -65;
				}
				break;
			case 2:
				if(v443) {
					bs443 |= 32;
				} else {
					bs443 &= -33;
				}
				break;
			case 3:
				if(v443) {
					bs443 |= 16;
				} else {
					bs443 &= -17;
				}
				break;
			case 4:
				if(v443) {
					bs443 |= 8;
				} else {
					bs443 &= -9;
				}
				break;
			case 5:
				if(v443) {
					bs443 |= 4;
				} else {
					bs443 &= -5;
				}
				break;
			case 6:
				if(v443) {
					bs443 |= 2;
				} else {
					bs443 &= -3;
				}
				break;
			case 7:
				if(v443) {
					bs443 |= 1;
				} else {
					bs443 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs443;
		var this445 = 0;
		var bs444 = this445;
		var l444 = "     ".length;
		var _g1444 = 0;
		var _g544 = l444;
		while(_g1444 < _g544) {
			var i444 = _g1444++;
			var no444 = "     ".charCodeAt(i444);
			if(no444 == null) {
				break;
			}
			var v444;
			switch(no444) {
			case 32:
				v444 = false;
				break;
			case 42:
				v444 = true;
				break;
			case 48:
				v444 = false;
				break;
			case 49:
				v444 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i444)));
			}
			switch(i444 - (l444 - 8)) {
			case 0:
				if(v444) {
					bs444 |= 128;
				} else {
					bs444 &= -129;
				}
				break;
			case 1:
				if(v444) {
					bs444 |= 64;
				} else {
					bs444 &= -65;
				}
				break;
			case 2:
				if(v444) {
					bs444 |= 32;
				} else {
					bs444 &= -33;
				}
				break;
			case 3:
				if(v444) {
					bs444 |= 16;
				} else {
					bs444 &= -17;
				}
				break;
			case 4:
				if(v444) {
					bs444 |= 8;
				} else {
					bs444 &= -9;
				}
				break;
			case 5:
				if(v444) {
					bs444 |= 4;
				} else {
					bs444 &= -5;
				}
				break;
			case 6:
				if(v444) {
					bs444 |= 2;
				} else {
					bs444 &= -3;
				}
				break;
			case 7:
				if(v444) {
					bs444 |= 1;
				} else {
					bs444 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs444;
		var this446 = 0;
		var bs445 = this446;
		var l445 = "     ".length;
		var _g1445 = 0;
		var _g545 = l445;
		while(_g1445 < _g545) {
			var i445 = _g1445++;
			var no445 = "     ".charCodeAt(i445);
			if(no445 == null) {
				break;
			}
			var v445;
			switch(no445) {
			case 32:
				v445 = false;
				break;
			case 42:
				v445 = true;
				break;
			case 48:
				v445 = false;
				break;
			case 49:
				v445 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i445)));
			}
			switch(i445 - (l445 - 8)) {
			case 0:
				if(v445) {
					bs445 |= 128;
				} else {
					bs445 &= -129;
				}
				break;
			case 1:
				if(v445) {
					bs445 |= 64;
				} else {
					bs445 &= -65;
				}
				break;
			case 2:
				if(v445) {
					bs445 |= 32;
				} else {
					bs445 &= -33;
				}
				break;
			case 3:
				if(v445) {
					bs445 |= 16;
				} else {
					bs445 &= -17;
				}
				break;
			case 4:
				if(v445) {
					bs445 |= 8;
				} else {
					bs445 &= -9;
				}
				break;
			case 5:
				if(v445) {
					bs445 |= 4;
				} else {
					bs445 &= -5;
				}
				break;
			case 6:
				if(v445) {
					bs445 |= 2;
				} else {
					bs445 &= -3;
				}
				break;
			case 7:
				if(v445) {
					bs445 |= 1;
				} else {
					bs445 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs445;
		var this447 = 0;
		var bs446 = this447;
		var l446 = "     ".length;
		var _g1446 = 0;
		var _g546 = l446;
		while(_g1446 < _g546) {
			var i446 = _g1446++;
			var no446 = "     ".charCodeAt(i446);
			if(no446 == null) {
				break;
			}
			var v446;
			switch(no446) {
			case 32:
				v446 = false;
				break;
			case 42:
				v446 = true;
				break;
			case 48:
				v446 = false;
				break;
			case 49:
				v446 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i446)));
			}
			switch(i446 - (l446 - 8)) {
			case 0:
				if(v446) {
					bs446 |= 128;
				} else {
					bs446 &= -129;
				}
				break;
			case 1:
				if(v446) {
					bs446 |= 64;
				} else {
					bs446 &= -65;
				}
				break;
			case 2:
				if(v446) {
					bs446 |= 32;
				} else {
					bs446 &= -33;
				}
				break;
			case 3:
				if(v446) {
					bs446 |= 16;
				} else {
					bs446 &= -17;
				}
				break;
			case 4:
				if(v446) {
					bs446 |= 8;
				} else {
					bs446 &= -9;
				}
				break;
			case 5:
				if(v446) {
					bs446 |= 4;
				} else {
					bs446 &= -5;
				}
				break;
			case 6:
				if(v446) {
					bs446 |= 2;
				} else {
					bs446 &= -3;
				}
				break;
			case 7:
				if(v446) {
					bs446 |= 1;
				} else {
					bs446 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs446;
		var this448 = 0;
		var bs447 = this448;
		var l447 = "*****".length;
		var _g1447 = 0;
		var _g547 = l447;
		while(_g1447 < _g547) {
			var i447 = _g1447++;
			var no447 = "*****".charCodeAt(i447);
			if(no447 == null) {
				break;
			}
			var v447;
			switch(no447) {
			case 32:
				v447 = false;
				break;
			case 42:
				v447 = true;
				break;
			case 48:
				v447 = false;
				break;
			case 49:
				v447 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i447)));
			}
			switch(i447 - (l447 - 8)) {
			case 0:
				if(v447) {
					bs447 |= 128;
				} else {
					bs447 &= -129;
				}
				break;
			case 1:
				if(v447) {
					bs447 |= 64;
				} else {
					bs447 &= -65;
				}
				break;
			case 2:
				if(v447) {
					bs447 |= 32;
				} else {
					bs447 &= -33;
				}
				break;
			case 3:
				if(v447) {
					bs447 |= 16;
				} else {
					bs447 &= -17;
				}
				break;
			case 4:
				if(v447) {
					bs447 |= 8;
				} else {
					bs447 &= -9;
				}
				break;
			case 5:
				if(v447) {
					bs447 |= 4;
				} else {
					bs447 &= -5;
				}
				break;
			case 6:
				if(v447) {
					bs447 |= 2;
				} else {
					bs447 &= -3;
				}
				break;
			case 7:
				if(v447) {
					bs447 |= 1;
				} else {
					bs447 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs447;
		break;
	case 96:
		var this449 = 0;
		var bs448 = this449;
		var l448 = "*    ".length;
		var _g1448 = 0;
		var _g548 = l448;
		while(_g1448 < _g548) {
			var i448 = _g1448++;
			var no448 = "*    ".charCodeAt(i448);
			if(no448 == null) {
				break;
			}
			var v448;
			switch(no448) {
			case 32:
				v448 = false;
				break;
			case 42:
				v448 = true;
				break;
			case 48:
				v448 = false;
				break;
			case 49:
				v448 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i448)));
			}
			switch(i448 - (l448 - 8)) {
			case 0:
				if(v448) {
					bs448 |= 128;
				} else {
					bs448 &= -129;
				}
				break;
			case 1:
				if(v448) {
					bs448 |= 64;
				} else {
					bs448 &= -65;
				}
				break;
			case 2:
				if(v448) {
					bs448 |= 32;
				} else {
					bs448 &= -33;
				}
				break;
			case 3:
				if(v448) {
					bs448 |= 16;
				} else {
					bs448 &= -17;
				}
				break;
			case 4:
				if(v448) {
					bs448 |= 8;
				} else {
					bs448 &= -9;
				}
				break;
			case 5:
				if(v448) {
					bs448 |= 4;
				} else {
					bs448 &= -5;
				}
				break;
			case 6:
				if(v448) {
					bs448 |= 2;
				} else {
					bs448 &= -3;
				}
				break;
			case 7:
				if(v448) {
					bs448 |= 1;
				} else {
					bs448 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs448;
		var this450 = 0;
		var bs449 = this450;
		var l449 = " *   ".length;
		var _g1449 = 0;
		var _g549 = l449;
		while(_g1449 < _g549) {
			var i449 = _g1449++;
			var no449 = " *   ".charCodeAt(i449);
			if(no449 == null) {
				break;
			}
			var v449;
			switch(no449) {
			case 32:
				v449 = false;
				break;
			case 42:
				v449 = true;
				break;
			case 48:
				v449 = false;
				break;
			case 49:
				v449 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i449)));
			}
			switch(i449 - (l449 - 8)) {
			case 0:
				if(v449) {
					bs449 |= 128;
				} else {
					bs449 &= -129;
				}
				break;
			case 1:
				if(v449) {
					bs449 |= 64;
				} else {
					bs449 &= -65;
				}
				break;
			case 2:
				if(v449) {
					bs449 |= 32;
				} else {
					bs449 &= -33;
				}
				break;
			case 3:
				if(v449) {
					bs449 |= 16;
				} else {
					bs449 &= -17;
				}
				break;
			case 4:
				if(v449) {
					bs449 |= 8;
				} else {
					bs449 &= -9;
				}
				break;
			case 5:
				if(v449) {
					bs449 |= 4;
				} else {
					bs449 &= -5;
				}
				break;
			case 6:
				if(v449) {
					bs449 |= 2;
				} else {
					bs449 &= -3;
				}
				break;
			case 7:
				if(v449) {
					bs449 |= 1;
				} else {
					bs449 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs449;
		var this451 = 0;
		var bs450 = this451;
		var l450 = "     ".length;
		var _g1450 = 0;
		var _g550 = l450;
		while(_g1450 < _g550) {
			var i450 = _g1450++;
			var no450 = "     ".charCodeAt(i450);
			if(no450 == null) {
				break;
			}
			var v450;
			switch(no450) {
			case 32:
				v450 = false;
				break;
			case 42:
				v450 = true;
				break;
			case 48:
				v450 = false;
				break;
			case 49:
				v450 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i450)));
			}
			switch(i450 - (l450 - 8)) {
			case 0:
				if(v450) {
					bs450 |= 128;
				} else {
					bs450 &= -129;
				}
				break;
			case 1:
				if(v450) {
					bs450 |= 64;
				} else {
					bs450 &= -65;
				}
				break;
			case 2:
				if(v450) {
					bs450 |= 32;
				} else {
					bs450 &= -33;
				}
				break;
			case 3:
				if(v450) {
					bs450 |= 16;
				} else {
					bs450 &= -17;
				}
				break;
			case 4:
				if(v450) {
					bs450 |= 8;
				} else {
					bs450 &= -9;
				}
				break;
			case 5:
				if(v450) {
					bs450 |= 4;
				} else {
					bs450 &= -5;
				}
				break;
			case 6:
				if(v450) {
					bs450 |= 2;
				} else {
					bs450 &= -3;
				}
				break;
			case 7:
				if(v450) {
					bs450 |= 1;
				} else {
					bs450 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs450;
		var this452 = 0;
		var bs451 = this452;
		var l451 = "     ".length;
		var _g1451 = 0;
		var _g551 = l451;
		while(_g1451 < _g551) {
			var i451 = _g1451++;
			var no451 = "     ".charCodeAt(i451);
			if(no451 == null) {
				break;
			}
			var v451;
			switch(no451) {
			case 32:
				v451 = false;
				break;
			case 42:
				v451 = true;
				break;
			case 48:
				v451 = false;
				break;
			case 49:
				v451 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i451)));
			}
			switch(i451 - (l451 - 8)) {
			case 0:
				if(v451) {
					bs451 |= 128;
				} else {
					bs451 &= -129;
				}
				break;
			case 1:
				if(v451) {
					bs451 |= 64;
				} else {
					bs451 &= -65;
				}
				break;
			case 2:
				if(v451) {
					bs451 |= 32;
				} else {
					bs451 &= -33;
				}
				break;
			case 3:
				if(v451) {
					bs451 |= 16;
				} else {
					bs451 &= -17;
				}
				break;
			case 4:
				if(v451) {
					bs451 |= 8;
				} else {
					bs451 &= -9;
				}
				break;
			case 5:
				if(v451) {
					bs451 |= 4;
				} else {
					bs451 &= -5;
				}
				break;
			case 6:
				if(v451) {
					bs451 |= 2;
				} else {
					bs451 &= -3;
				}
				break;
			case 7:
				if(v451) {
					bs451 |= 1;
				} else {
					bs451 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs451;
		var this453 = 0;
		var bs452 = this453;
		var l452 = "     ".length;
		var _g1452 = 0;
		var _g552 = l452;
		while(_g1452 < _g552) {
			var i452 = _g1452++;
			var no452 = "     ".charCodeAt(i452);
			if(no452 == null) {
				break;
			}
			var v452;
			switch(no452) {
			case 32:
				v452 = false;
				break;
			case 42:
				v452 = true;
				break;
			case 48:
				v452 = false;
				break;
			case 49:
				v452 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i452)));
			}
			switch(i452 - (l452 - 8)) {
			case 0:
				if(v452) {
					bs452 |= 128;
				} else {
					bs452 &= -129;
				}
				break;
			case 1:
				if(v452) {
					bs452 |= 64;
				} else {
					bs452 &= -65;
				}
				break;
			case 2:
				if(v452) {
					bs452 |= 32;
				} else {
					bs452 &= -33;
				}
				break;
			case 3:
				if(v452) {
					bs452 |= 16;
				} else {
					bs452 &= -17;
				}
				break;
			case 4:
				if(v452) {
					bs452 |= 8;
				} else {
					bs452 &= -9;
				}
				break;
			case 5:
				if(v452) {
					bs452 |= 4;
				} else {
					bs452 &= -5;
				}
				break;
			case 6:
				if(v452) {
					bs452 |= 2;
				} else {
					bs452 &= -3;
				}
				break;
			case 7:
				if(v452) {
					bs452 |= 1;
				} else {
					bs452 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs452;
		var this454 = 0;
		var bs453 = this454;
		var l453 = "     ".length;
		var _g1453 = 0;
		var _g553 = l453;
		while(_g1453 < _g553) {
			var i453 = _g1453++;
			var no453 = "     ".charCodeAt(i453);
			if(no453 == null) {
				break;
			}
			var v453;
			switch(no453) {
			case 32:
				v453 = false;
				break;
			case 42:
				v453 = true;
				break;
			case 48:
				v453 = false;
				break;
			case 49:
				v453 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i453)));
			}
			switch(i453 - (l453 - 8)) {
			case 0:
				if(v453) {
					bs453 |= 128;
				} else {
					bs453 &= -129;
				}
				break;
			case 1:
				if(v453) {
					bs453 |= 64;
				} else {
					bs453 &= -65;
				}
				break;
			case 2:
				if(v453) {
					bs453 |= 32;
				} else {
					bs453 &= -33;
				}
				break;
			case 3:
				if(v453) {
					bs453 |= 16;
				} else {
					bs453 &= -17;
				}
				break;
			case 4:
				if(v453) {
					bs453 |= 8;
				} else {
					bs453 &= -9;
				}
				break;
			case 5:
				if(v453) {
					bs453 |= 4;
				} else {
					bs453 &= -5;
				}
				break;
			case 6:
				if(v453) {
					bs453 |= 2;
				} else {
					bs453 &= -3;
				}
				break;
			case 7:
				if(v453) {
					bs453 |= 1;
				} else {
					bs453 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs453;
		var this455 = 0;
		var bs454 = this455;
		var l454 = "     ".length;
		var _g1454 = 0;
		var _g554 = l454;
		while(_g1454 < _g554) {
			var i454 = _g1454++;
			var no454 = "     ".charCodeAt(i454);
			if(no454 == null) {
				break;
			}
			var v454;
			switch(no454) {
			case 32:
				v454 = false;
				break;
			case 42:
				v454 = true;
				break;
			case 48:
				v454 = false;
				break;
			case 49:
				v454 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i454)));
			}
			switch(i454 - (l454 - 8)) {
			case 0:
				if(v454) {
					bs454 |= 128;
				} else {
					bs454 &= -129;
				}
				break;
			case 1:
				if(v454) {
					bs454 |= 64;
				} else {
					bs454 &= -65;
				}
				break;
			case 2:
				if(v454) {
					bs454 |= 32;
				} else {
					bs454 &= -33;
				}
				break;
			case 3:
				if(v454) {
					bs454 |= 16;
				} else {
					bs454 &= -17;
				}
				break;
			case 4:
				if(v454) {
					bs454 |= 8;
				} else {
					bs454 &= -9;
				}
				break;
			case 5:
				if(v454) {
					bs454 |= 4;
				} else {
					bs454 &= -5;
				}
				break;
			case 6:
				if(v454) {
					bs454 |= 2;
				} else {
					bs454 &= -3;
				}
				break;
			case 7:
				if(v454) {
					bs454 |= 1;
				} else {
					bs454 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs454;
		break;
	case 97:
		var this456 = 0;
		var bs455 = this456;
		var l455 = "     ".length;
		var _g1455 = 0;
		var _g555 = l455;
		while(_g1455 < _g555) {
			var i455 = _g1455++;
			var no455 = "     ".charCodeAt(i455);
			if(no455 == null) {
				break;
			}
			var v455;
			switch(no455) {
			case 32:
				v455 = false;
				break;
			case 42:
				v455 = true;
				break;
			case 48:
				v455 = false;
				break;
			case 49:
				v455 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i455)));
			}
			switch(i455 - (l455 - 8)) {
			case 0:
				if(v455) {
					bs455 |= 128;
				} else {
					bs455 &= -129;
				}
				break;
			case 1:
				if(v455) {
					bs455 |= 64;
				} else {
					bs455 &= -65;
				}
				break;
			case 2:
				if(v455) {
					bs455 |= 32;
				} else {
					bs455 &= -33;
				}
				break;
			case 3:
				if(v455) {
					bs455 |= 16;
				} else {
					bs455 &= -17;
				}
				break;
			case 4:
				if(v455) {
					bs455 |= 8;
				} else {
					bs455 &= -9;
				}
				break;
			case 5:
				if(v455) {
					bs455 |= 4;
				} else {
					bs455 &= -5;
				}
				break;
			case 6:
				if(v455) {
					bs455 |= 2;
				} else {
					bs455 &= -3;
				}
				break;
			case 7:
				if(v455) {
					bs455 |= 1;
				} else {
					bs455 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs455;
		var this457 = 0;
		var bs456 = this457;
		var l456 = "     ".length;
		var _g1456 = 0;
		var _g556 = l456;
		while(_g1456 < _g556) {
			var i456 = _g1456++;
			var no456 = "     ".charCodeAt(i456);
			if(no456 == null) {
				break;
			}
			var v456;
			switch(no456) {
			case 32:
				v456 = false;
				break;
			case 42:
				v456 = true;
				break;
			case 48:
				v456 = false;
				break;
			case 49:
				v456 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i456)));
			}
			switch(i456 - (l456 - 8)) {
			case 0:
				if(v456) {
					bs456 |= 128;
				} else {
					bs456 &= -129;
				}
				break;
			case 1:
				if(v456) {
					bs456 |= 64;
				} else {
					bs456 &= -65;
				}
				break;
			case 2:
				if(v456) {
					bs456 |= 32;
				} else {
					bs456 &= -33;
				}
				break;
			case 3:
				if(v456) {
					bs456 |= 16;
				} else {
					bs456 &= -17;
				}
				break;
			case 4:
				if(v456) {
					bs456 |= 8;
				} else {
					bs456 &= -9;
				}
				break;
			case 5:
				if(v456) {
					bs456 |= 4;
				} else {
					bs456 &= -5;
				}
				break;
			case 6:
				if(v456) {
					bs456 |= 2;
				} else {
					bs456 &= -3;
				}
				break;
			case 7:
				if(v456) {
					bs456 |= 1;
				} else {
					bs456 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs456;
		var this458 = 0;
		var bs457 = this458;
		var l457 = " *** ".length;
		var _g1457 = 0;
		var _g557 = l457;
		while(_g1457 < _g557) {
			var i457 = _g1457++;
			var no457 = " *** ".charCodeAt(i457);
			if(no457 == null) {
				break;
			}
			var v457;
			switch(no457) {
			case 32:
				v457 = false;
				break;
			case 42:
				v457 = true;
				break;
			case 48:
				v457 = false;
				break;
			case 49:
				v457 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i457)));
			}
			switch(i457 - (l457 - 8)) {
			case 0:
				if(v457) {
					bs457 |= 128;
				} else {
					bs457 &= -129;
				}
				break;
			case 1:
				if(v457) {
					bs457 |= 64;
				} else {
					bs457 &= -65;
				}
				break;
			case 2:
				if(v457) {
					bs457 |= 32;
				} else {
					bs457 &= -33;
				}
				break;
			case 3:
				if(v457) {
					bs457 |= 16;
				} else {
					bs457 &= -17;
				}
				break;
			case 4:
				if(v457) {
					bs457 |= 8;
				} else {
					bs457 &= -9;
				}
				break;
			case 5:
				if(v457) {
					bs457 |= 4;
				} else {
					bs457 &= -5;
				}
				break;
			case 6:
				if(v457) {
					bs457 |= 2;
				} else {
					bs457 &= -3;
				}
				break;
			case 7:
				if(v457) {
					bs457 |= 1;
				} else {
					bs457 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs457;
		var this459 = 0;
		var bs458 = this459;
		var l458 = "    *".length;
		var _g1458 = 0;
		var _g558 = l458;
		while(_g1458 < _g558) {
			var i458 = _g1458++;
			var no458 = "    *".charCodeAt(i458);
			if(no458 == null) {
				break;
			}
			var v458;
			switch(no458) {
			case 32:
				v458 = false;
				break;
			case 42:
				v458 = true;
				break;
			case 48:
				v458 = false;
				break;
			case 49:
				v458 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i458)));
			}
			switch(i458 - (l458 - 8)) {
			case 0:
				if(v458) {
					bs458 |= 128;
				} else {
					bs458 &= -129;
				}
				break;
			case 1:
				if(v458) {
					bs458 |= 64;
				} else {
					bs458 &= -65;
				}
				break;
			case 2:
				if(v458) {
					bs458 |= 32;
				} else {
					bs458 &= -33;
				}
				break;
			case 3:
				if(v458) {
					bs458 |= 16;
				} else {
					bs458 &= -17;
				}
				break;
			case 4:
				if(v458) {
					bs458 |= 8;
				} else {
					bs458 &= -9;
				}
				break;
			case 5:
				if(v458) {
					bs458 |= 4;
				} else {
					bs458 &= -5;
				}
				break;
			case 6:
				if(v458) {
					bs458 |= 2;
				} else {
					bs458 &= -3;
				}
				break;
			case 7:
				if(v458) {
					bs458 |= 1;
				} else {
					bs458 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs458;
		var this460 = 0;
		var bs459 = this460;
		var l459 = " ****".length;
		var _g1459 = 0;
		var _g559 = l459;
		while(_g1459 < _g559) {
			var i459 = _g1459++;
			var no459 = " ****".charCodeAt(i459);
			if(no459 == null) {
				break;
			}
			var v459;
			switch(no459) {
			case 32:
				v459 = false;
				break;
			case 42:
				v459 = true;
				break;
			case 48:
				v459 = false;
				break;
			case 49:
				v459 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i459)));
			}
			switch(i459 - (l459 - 8)) {
			case 0:
				if(v459) {
					bs459 |= 128;
				} else {
					bs459 &= -129;
				}
				break;
			case 1:
				if(v459) {
					bs459 |= 64;
				} else {
					bs459 &= -65;
				}
				break;
			case 2:
				if(v459) {
					bs459 |= 32;
				} else {
					bs459 &= -33;
				}
				break;
			case 3:
				if(v459) {
					bs459 |= 16;
				} else {
					bs459 &= -17;
				}
				break;
			case 4:
				if(v459) {
					bs459 |= 8;
				} else {
					bs459 &= -9;
				}
				break;
			case 5:
				if(v459) {
					bs459 |= 4;
				} else {
					bs459 &= -5;
				}
				break;
			case 6:
				if(v459) {
					bs459 |= 2;
				} else {
					bs459 &= -3;
				}
				break;
			case 7:
				if(v459) {
					bs459 |= 1;
				} else {
					bs459 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs459;
		var this461 = 0;
		var bs460 = this461;
		var l460 = "*   *".length;
		var _g1460 = 0;
		var _g560 = l460;
		while(_g1460 < _g560) {
			var i460 = _g1460++;
			var no460 = "*   *".charCodeAt(i460);
			if(no460 == null) {
				break;
			}
			var v460;
			switch(no460) {
			case 32:
				v460 = false;
				break;
			case 42:
				v460 = true;
				break;
			case 48:
				v460 = false;
				break;
			case 49:
				v460 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i460)));
			}
			switch(i460 - (l460 - 8)) {
			case 0:
				if(v460) {
					bs460 |= 128;
				} else {
					bs460 &= -129;
				}
				break;
			case 1:
				if(v460) {
					bs460 |= 64;
				} else {
					bs460 &= -65;
				}
				break;
			case 2:
				if(v460) {
					bs460 |= 32;
				} else {
					bs460 &= -33;
				}
				break;
			case 3:
				if(v460) {
					bs460 |= 16;
				} else {
					bs460 &= -17;
				}
				break;
			case 4:
				if(v460) {
					bs460 |= 8;
				} else {
					bs460 &= -9;
				}
				break;
			case 5:
				if(v460) {
					bs460 |= 4;
				} else {
					bs460 &= -5;
				}
				break;
			case 6:
				if(v460) {
					bs460 |= 2;
				} else {
					bs460 &= -3;
				}
				break;
			case 7:
				if(v460) {
					bs460 |= 1;
				} else {
					bs460 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs460;
		var this462 = 0;
		var bs461 = this462;
		var l461 = " ****".length;
		var _g1461 = 0;
		var _g561 = l461;
		while(_g1461 < _g561) {
			var i461 = _g1461++;
			var no461 = " ****".charCodeAt(i461);
			if(no461 == null) {
				break;
			}
			var v461;
			switch(no461) {
			case 32:
				v461 = false;
				break;
			case 42:
				v461 = true;
				break;
			case 48:
				v461 = false;
				break;
			case 49:
				v461 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i461)));
			}
			switch(i461 - (l461 - 8)) {
			case 0:
				if(v461) {
					bs461 |= 128;
				} else {
					bs461 &= -129;
				}
				break;
			case 1:
				if(v461) {
					bs461 |= 64;
				} else {
					bs461 &= -65;
				}
				break;
			case 2:
				if(v461) {
					bs461 |= 32;
				} else {
					bs461 &= -33;
				}
				break;
			case 3:
				if(v461) {
					bs461 |= 16;
				} else {
					bs461 &= -17;
				}
				break;
			case 4:
				if(v461) {
					bs461 |= 8;
				} else {
					bs461 &= -9;
				}
				break;
			case 5:
				if(v461) {
					bs461 |= 4;
				} else {
					bs461 &= -5;
				}
				break;
			case 6:
				if(v461) {
					bs461 |= 2;
				} else {
					bs461 &= -3;
				}
				break;
			case 7:
				if(v461) {
					bs461 |= 1;
				} else {
					bs461 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs461;
		break;
	case 98:
		var this463 = 0;
		var bs462 = this463;
		var l462 = "*    ".length;
		var _g1462 = 0;
		var _g562 = l462;
		while(_g1462 < _g562) {
			var i462 = _g1462++;
			var no462 = "*    ".charCodeAt(i462);
			if(no462 == null) {
				break;
			}
			var v462;
			switch(no462) {
			case 32:
				v462 = false;
				break;
			case 42:
				v462 = true;
				break;
			case 48:
				v462 = false;
				break;
			case 49:
				v462 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i462)));
			}
			switch(i462 - (l462 - 8)) {
			case 0:
				if(v462) {
					bs462 |= 128;
				} else {
					bs462 &= -129;
				}
				break;
			case 1:
				if(v462) {
					bs462 |= 64;
				} else {
					bs462 &= -65;
				}
				break;
			case 2:
				if(v462) {
					bs462 |= 32;
				} else {
					bs462 &= -33;
				}
				break;
			case 3:
				if(v462) {
					bs462 |= 16;
				} else {
					bs462 &= -17;
				}
				break;
			case 4:
				if(v462) {
					bs462 |= 8;
				} else {
					bs462 &= -9;
				}
				break;
			case 5:
				if(v462) {
					bs462 |= 4;
				} else {
					bs462 &= -5;
				}
				break;
			case 6:
				if(v462) {
					bs462 |= 2;
				} else {
					bs462 &= -3;
				}
				break;
			case 7:
				if(v462) {
					bs462 |= 1;
				} else {
					bs462 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs462;
		var this464 = 0;
		var bs463 = this464;
		var l463 = "*    ".length;
		var _g1463 = 0;
		var _g563 = l463;
		while(_g1463 < _g563) {
			var i463 = _g1463++;
			var no463 = "*    ".charCodeAt(i463);
			if(no463 == null) {
				break;
			}
			var v463;
			switch(no463) {
			case 32:
				v463 = false;
				break;
			case 42:
				v463 = true;
				break;
			case 48:
				v463 = false;
				break;
			case 49:
				v463 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i463)));
			}
			switch(i463 - (l463 - 8)) {
			case 0:
				if(v463) {
					bs463 |= 128;
				} else {
					bs463 &= -129;
				}
				break;
			case 1:
				if(v463) {
					bs463 |= 64;
				} else {
					bs463 &= -65;
				}
				break;
			case 2:
				if(v463) {
					bs463 |= 32;
				} else {
					bs463 &= -33;
				}
				break;
			case 3:
				if(v463) {
					bs463 |= 16;
				} else {
					bs463 &= -17;
				}
				break;
			case 4:
				if(v463) {
					bs463 |= 8;
				} else {
					bs463 &= -9;
				}
				break;
			case 5:
				if(v463) {
					bs463 |= 4;
				} else {
					bs463 &= -5;
				}
				break;
			case 6:
				if(v463) {
					bs463 |= 2;
				} else {
					bs463 &= -3;
				}
				break;
			case 7:
				if(v463) {
					bs463 |= 1;
				} else {
					bs463 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs463;
		var this465 = 0;
		var bs464 = this465;
		var l464 = "* ** ".length;
		var _g1464 = 0;
		var _g564 = l464;
		while(_g1464 < _g564) {
			var i464 = _g1464++;
			var no464 = "* ** ".charCodeAt(i464);
			if(no464 == null) {
				break;
			}
			var v464;
			switch(no464) {
			case 32:
				v464 = false;
				break;
			case 42:
				v464 = true;
				break;
			case 48:
				v464 = false;
				break;
			case 49:
				v464 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* ** ".charCodeAt(i464)));
			}
			switch(i464 - (l464 - 8)) {
			case 0:
				if(v464) {
					bs464 |= 128;
				} else {
					bs464 &= -129;
				}
				break;
			case 1:
				if(v464) {
					bs464 |= 64;
				} else {
					bs464 &= -65;
				}
				break;
			case 2:
				if(v464) {
					bs464 |= 32;
				} else {
					bs464 &= -33;
				}
				break;
			case 3:
				if(v464) {
					bs464 |= 16;
				} else {
					bs464 &= -17;
				}
				break;
			case 4:
				if(v464) {
					bs464 |= 8;
				} else {
					bs464 &= -9;
				}
				break;
			case 5:
				if(v464) {
					bs464 |= 4;
				} else {
					bs464 &= -5;
				}
				break;
			case 6:
				if(v464) {
					bs464 |= 2;
				} else {
					bs464 &= -3;
				}
				break;
			case 7:
				if(v464) {
					bs464 |= 1;
				} else {
					bs464 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs464;
		var this466 = 0;
		var bs465 = this466;
		var l465 = "**  *".length;
		var _g1465 = 0;
		var _g565 = l465;
		while(_g1465 < _g565) {
			var i465 = _g1465++;
			var no465 = "**  *".charCodeAt(i465);
			if(no465 == null) {
				break;
			}
			var v465;
			switch(no465) {
			case 32:
				v465 = false;
				break;
			case 42:
				v465 = true;
				break;
			case 48:
				v465 = false;
				break;
			case 49:
				v465 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i465)));
			}
			switch(i465 - (l465 - 8)) {
			case 0:
				if(v465) {
					bs465 |= 128;
				} else {
					bs465 &= -129;
				}
				break;
			case 1:
				if(v465) {
					bs465 |= 64;
				} else {
					bs465 &= -65;
				}
				break;
			case 2:
				if(v465) {
					bs465 |= 32;
				} else {
					bs465 &= -33;
				}
				break;
			case 3:
				if(v465) {
					bs465 |= 16;
				} else {
					bs465 &= -17;
				}
				break;
			case 4:
				if(v465) {
					bs465 |= 8;
				} else {
					bs465 &= -9;
				}
				break;
			case 5:
				if(v465) {
					bs465 |= 4;
				} else {
					bs465 &= -5;
				}
				break;
			case 6:
				if(v465) {
					bs465 |= 2;
				} else {
					bs465 &= -3;
				}
				break;
			case 7:
				if(v465) {
					bs465 |= 1;
				} else {
					bs465 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs465;
		var this467 = 0;
		var bs466 = this467;
		var l466 = "*   *".length;
		var _g1466 = 0;
		var _g566 = l466;
		while(_g1466 < _g566) {
			var i466 = _g1466++;
			var no466 = "*   *".charCodeAt(i466);
			if(no466 == null) {
				break;
			}
			var v466;
			switch(no466) {
			case 32:
				v466 = false;
				break;
			case 42:
				v466 = true;
				break;
			case 48:
				v466 = false;
				break;
			case 49:
				v466 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i466)));
			}
			switch(i466 - (l466 - 8)) {
			case 0:
				if(v466) {
					bs466 |= 128;
				} else {
					bs466 &= -129;
				}
				break;
			case 1:
				if(v466) {
					bs466 |= 64;
				} else {
					bs466 &= -65;
				}
				break;
			case 2:
				if(v466) {
					bs466 |= 32;
				} else {
					bs466 &= -33;
				}
				break;
			case 3:
				if(v466) {
					bs466 |= 16;
				} else {
					bs466 &= -17;
				}
				break;
			case 4:
				if(v466) {
					bs466 |= 8;
				} else {
					bs466 &= -9;
				}
				break;
			case 5:
				if(v466) {
					bs466 |= 4;
				} else {
					bs466 &= -5;
				}
				break;
			case 6:
				if(v466) {
					bs466 |= 2;
				} else {
					bs466 &= -3;
				}
				break;
			case 7:
				if(v466) {
					bs466 |= 1;
				} else {
					bs466 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs466;
		var this468 = 0;
		var bs467 = this468;
		var l467 = "*   *".length;
		var _g1467 = 0;
		var _g567 = l467;
		while(_g1467 < _g567) {
			var i467 = _g1467++;
			var no467 = "*   *".charCodeAt(i467);
			if(no467 == null) {
				break;
			}
			var v467;
			switch(no467) {
			case 32:
				v467 = false;
				break;
			case 42:
				v467 = true;
				break;
			case 48:
				v467 = false;
				break;
			case 49:
				v467 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i467)));
			}
			switch(i467 - (l467 - 8)) {
			case 0:
				if(v467) {
					bs467 |= 128;
				} else {
					bs467 &= -129;
				}
				break;
			case 1:
				if(v467) {
					bs467 |= 64;
				} else {
					bs467 &= -65;
				}
				break;
			case 2:
				if(v467) {
					bs467 |= 32;
				} else {
					bs467 &= -33;
				}
				break;
			case 3:
				if(v467) {
					bs467 |= 16;
				} else {
					bs467 &= -17;
				}
				break;
			case 4:
				if(v467) {
					bs467 |= 8;
				} else {
					bs467 &= -9;
				}
				break;
			case 5:
				if(v467) {
					bs467 |= 4;
				} else {
					bs467 &= -5;
				}
				break;
			case 6:
				if(v467) {
					bs467 |= 2;
				} else {
					bs467 &= -3;
				}
				break;
			case 7:
				if(v467) {
					bs467 |= 1;
				} else {
					bs467 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs467;
		var this469 = 0;
		var bs468 = this469;
		var l468 = "**** ".length;
		var _g1468 = 0;
		var _g568 = l468;
		while(_g1468 < _g568) {
			var i468 = _g1468++;
			var no468 = "**** ".charCodeAt(i468);
			if(no468 == null) {
				break;
			}
			var v468;
			switch(no468) {
			case 32:
				v468 = false;
				break;
			case 42:
				v468 = true;
				break;
			case 48:
				v468 = false;
				break;
			case 49:
				v468 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i468)));
			}
			switch(i468 - (l468 - 8)) {
			case 0:
				if(v468) {
					bs468 |= 128;
				} else {
					bs468 &= -129;
				}
				break;
			case 1:
				if(v468) {
					bs468 |= 64;
				} else {
					bs468 &= -65;
				}
				break;
			case 2:
				if(v468) {
					bs468 |= 32;
				} else {
					bs468 &= -33;
				}
				break;
			case 3:
				if(v468) {
					bs468 |= 16;
				} else {
					bs468 &= -17;
				}
				break;
			case 4:
				if(v468) {
					bs468 |= 8;
				} else {
					bs468 &= -9;
				}
				break;
			case 5:
				if(v468) {
					bs468 |= 4;
				} else {
					bs468 &= -5;
				}
				break;
			case 6:
				if(v468) {
					bs468 |= 2;
				} else {
					bs468 &= -3;
				}
				break;
			case 7:
				if(v468) {
					bs468 |= 1;
				} else {
					bs468 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs468;
		break;
	case 99:
		var this470 = 0;
		var bs469 = this470;
		var l469 = "     ".length;
		var _g1469 = 0;
		var _g569 = l469;
		while(_g1469 < _g569) {
			var i469 = _g1469++;
			var no469 = "     ".charCodeAt(i469);
			if(no469 == null) {
				break;
			}
			var v469;
			switch(no469) {
			case 32:
				v469 = false;
				break;
			case 42:
				v469 = true;
				break;
			case 48:
				v469 = false;
				break;
			case 49:
				v469 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i469)));
			}
			switch(i469 - (l469 - 8)) {
			case 0:
				if(v469) {
					bs469 |= 128;
				} else {
					bs469 &= -129;
				}
				break;
			case 1:
				if(v469) {
					bs469 |= 64;
				} else {
					bs469 &= -65;
				}
				break;
			case 2:
				if(v469) {
					bs469 |= 32;
				} else {
					bs469 &= -33;
				}
				break;
			case 3:
				if(v469) {
					bs469 |= 16;
				} else {
					bs469 &= -17;
				}
				break;
			case 4:
				if(v469) {
					bs469 |= 8;
				} else {
					bs469 &= -9;
				}
				break;
			case 5:
				if(v469) {
					bs469 |= 4;
				} else {
					bs469 &= -5;
				}
				break;
			case 6:
				if(v469) {
					bs469 |= 2;
				} else {
					bs469 &= -3;
				}
				break;
			case 7:
				if(v469) {
					bs469 |= 1;
				} else {
					bs469 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs469;
		var this471 = 0;
		var bs470 = this471;
		var l470 = "     ".length;
		var _g1470 = 0;
		var _g570 = l470;
		while(_g1470 < _g570) {
			var i470 = _g1470++;
			var no470 = "     ".charCodeAt(i470);
			if(no470 == null) {
				break;
			}
			var v470;
			switch(no470) {
			case 32:
				v470 = false;
				break;
			case 42:
				v470 = true;
				break;
			case 48:
				v470 = false;
				break;
			case 49:
				v470 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i470)));
			}
			switch(i470 - (l470 - 8)) {
			case 0:
				if(v470) {
					bs470 |= 128;
				} else {
					bs470 &= -129;
				}
				break;
			case 1:
				if(v470) {
					bs470 |= 64;
				} else {
					bs470 &= -65;
				}
				break;
			case 2:
				if(v470) {
					bs470 |= 32;
				} else {
					bs470 &= -33;
				}
				break;
			case 3:
				if(v470) {
					bs470 |= 16;
				} else {
					bs470 &= -17;
				}
				break;
			case 4:
				if(v470) {
					bs470 |= 8;
				} else {
					bs470 &= -9;
				}
				break;
			case 5:
				if(v470) {
					bs470 |= 4;
				} else {
					bs470 &= -5;
				}
				break;
			case 6:
				if(v470) {
					bs470 |= 2;
				} else {
					bs470 &= -3;
				}
				break;
			case 7:
				if(v470) {
					bs470 |= 1;
				} else {
					bs470 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs470;
		var this472 = 0;
		var bs471 = this472;
		var l471 = " *** ".length;
		var _g1471 = 0;
		var _g571 = l471;
		while(_g1471 < _g571) {
			var i471 = _g1471++;
			var no471 = " *** ".charCodeAt(i471);
			if(no471 == null) {
				break;
			}
			var v471;
			switch(no471) {
			case 32:
				v471 = false;
				break;
			case 42:
				v471 = true;
				break;
			case 48:
				v471 = false;
				break;
			case 49:
				v471 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i471)));
			}
			switch(i471 - (l471 - 8)) {
			case 0:
				if(v471) {
					bs471 |= 128;
				} else {
					bs471 &= -129;
				}
				break;
			case 1:
				if(v471) {
					bs471 |= 64;
				} else {
					bs471 &= -65;
				}
				break;
			case 2:
				if(v471) {
					bs471 |= 32;
				} else {
					bs471 &= -33;
				}
				break;
			case 3:
				if(v471) {
					bs471 |= 16;
				} else {
					bs471 &= -17;
				}
				break;
			case 4:
				if(v471) {
					bs471 |= 8;
				} else {
					bs471 &= -9;
				}
				break;
			case 5:
				if(v471) {
					bs471 |= 4;
				} else {
					bs471 &= -5;
				}
				break;
			case 6:
				if(v471) {
					bs471 |= 2;
				} else {
					bs471 &= -3;
				}
				break;
			case 7:
				if(v471) {
					bs471 |= 1;
				} else {
					bs471 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs471;
		var this473 = 0;
		var bs472 = this473;
		var l472 = "*    ".length;
		var _g1472 = 0;
		var _g572 = l472;
		while(_g1472 < _g572) {
			var i472 = _g1472++;
			var no472 = "*    ".charCodeAt(i472);
			if(no472 == null) {
				break;
			}
			var v472;
			switch(no472) {
			case 32:
				v472 = false;
				break;
			case 42:
				v472 = true;
				break;
			case 48:
				v472 = false;
				break;
			case 49:
				v472 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i472)));
			}
			switch(i472 - (l472 - 8)) {
			case 0:
				if(v472) {
					bs472 |= 128;
				} else {
					bs472 &= -129;
				}
				break;
			case 1:
				if(v472) {
					bs472 |= 64;
				} else {
					bs472 &= -65;
				}
				break;
			case 2:
				if(v472) {
					bs472 |= 32;
				} else {
					bs472 &= -33;
				}
				break;
			case 3:
				if(v472) {
					bs472 |= 16;
				} else {
					bs472 &= -17;
				}
				break;
			case 4:
				if(v472) {
					bs472 |= 8;
				} else {
					bs472 &= -9;
				}
				break;
			case 5:
				if(v472) {
					bs472 |= 4;
				} else {
					bs472 &= -5;
				}
				break;
			case 6:
				if(v472) {
					bs472 |= 2;
				} else {
					bs472 &= -3;
				}
				break;
			case 7:
				if(v472) {
					bs472 |= 1;
				} else {
					bs472 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs472;
		var this474 = 0;
		var bs473 = this474;
		var l473 = "*    ".length;
		var _g1473 = 0;
		var _g573 = l473;
		while(_g1473 < _g573) {
			var i473 = _g1473++;
			var no473 = "*    ".charCodeAt(i473);
			if(no473 == null) {
				break;
			}
			var v473;
			switch(no473) {
			case 32:
				v473 = false;
				break;
			case 42:
				v473 = true;
				break;
			case 48:
				v473 = false;
				break;
			case 49:
				v473 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i473)));
			}
			switch(i473 - (l473 - 8)) {
			case 0:
				if(v473) {
					bs473 |= 128;
				} else {
					bs473 &= -129;
				}
				break;
			case 1:
				if(v473) {
					bs473 |= 64;
				} else {
					bs473 &= -65;
				}
				break;
			case 2:
				if(v473) {
					bs473 |= 32;
				} else {
					bs473 &= -33;
				}
				break;
			case 3:
				if(v473) {
					bs473 |= 16;
				} else {
					bs473 &= -17;
				}
				break;
			case 4:
				if(v473) {
					bs473 |= 8;
				} else {
					bs473 &= -9;
				}
				break;
			case 5:
				if(v473) {
					bs473 |= 4;
				} else {
					bs473 &= -5;
				}
				break;
			case 6:
				if(v473) {
					bs473 |= 2;
				} else {
					bs473 &= -3;
				}
				break;
			case 7:
				if(v473) {
					bs473 |= 1;
				} else {
					bs473 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs473;
		var this475 = 0;
		var bs474 = this475;
		var l474 = "*   *".length;
		var _g1474 = 0;
		var _g574 = l474;
		while(_g1474 < _g574) {
			var i474 = _g1474++;
			var no474 = "*   *".charCodeAt(i474);
			if(no474 == null) {
				break;
			}
			var v474;
			switch(no474) {
			case 32:
				v474 = false;
				break;
			case 42:
				v474 = true;
				break;
			case 48:
				v474 = false;
				break;
			case 49:
				v474 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i474)));
			}
			switch(i474 - (l474 - 8)) {
			case 0:
				if(v474) {
					bs474 |= 128;
				} else {
					bs474 &= -129;
				}
				break;
			case 1:
				if(v474) {
					bs474 |= 64;
				} else {
					bs474 &= -65;
				}
				break;
			case 2:
				if(v474) {
					bs474 |= 32;
				} else {
					bs474 &= -33;
				}
				break;
			case 3:
				if(v474) {
					bs474 |= 16;
				} else {
					bs474 &= -17;
				}
				break;
			case 4:
				if(v474) {
					bs474 |= 8;
				} else {
					bs474 &= -9;
				}
				break;
			case 5:
				if(v474) {
					bs474 |= 4;
				} else {
					bs474 &= -5;
				}
				break;
			case 6:
				if(v474) {
					bs474 |= 2;
				} else {
					bs474 &= -3;
				}
				break;
			case 7:
				if(v474) {
					bs474 |= 1;
				} else {
					bs474 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs474;
		var this476 = 0;
		var bs475 = this476;
		var l475 = " *** ".length;
		var _g1475 = 0;
		var _g575 = l475;
		while(_g1475 < _g575) {
			var i475 = _g1475++;
			var no475 = " *** ".charCodeAt(i475);
			if(no475 == null) {
				break;
			}
			var v475;
			switch(no475) {
			case 32:
				v475 = false;
				break;
			case 42:
				v475 = true;
				break;
			case 48:
				v475 = false;
				break;
			case 49:
				v475 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i475)));
			}
			switch(i475 - (l475 - 8)) {
			case 0:
				if(v475) {
					bs475 |= 128;
				} else {
					bs475 &= -129;
				}
				break;
			case 1:
				if(v475) {
					bs475 |= 64;
				} else {
					bs475 &= -65;
				}
				break;
			case 2:
				if(v475) {
					bs475 |= 32;
				} else {
					bs475 &= -33;
				}
				break;
			case 3:
				if(v475) {
					bs475 |= 16;
				} else {
					bs475 &= -17;
				}
				break;
			case 4:
				if(v475) {
					bs475 |= 8;
				} else {
					bs475 &= -9;
				}
				break;
			case 5:
				if(v475) {
					bs475 |= 4;
				} else {
					bs475 &= -5;
				}
				break;
			case 6:
				if(v475) {
					bs475 |= 2;
				} else {
					bs475 &= -3;
				}
				break;
			case 7:
				if(v475) {
					bs475 |= 1;
				} else {
					bs475 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs475;
		break;
	case 100:
		var this477 = 0;
		var bs476 = this477;
		var l476 = "    *".length;
		var _g1476 = 0;
		var _g576 = l476;
		while(_g1476 < _g576) {
			var i476 = _g1476++;
			var no476 = "    *".charCodeAt(i476);
			if(no476 == null) {
				break;
			}
			var v476;
			switch(no476) {
			case 32:
				v476 = false;
				break;
			case 42:
				v476 = true;
				break;
			case 48:
				v476 = false;
				break;
			case 49:
				v476 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i476)));
			}
			switch(i476 - (l476 - 8)) {
			case 0:
				if(v476) {
					bs476 |= 128;
				} else {
					bs476 &= -129;
				}
				break;
			case 1:
				if(v476) {
					bs476 |= 64;
				} else {
					bs476 &= -65;
				}
				break;
			case 2:
				if(v476) {
					bs476 |= 32;
				} else {
					bs476 &= -33;
				}
				break;
			case 3:
				if(v476) {
					bs476 |= 16;
				} else {
					bs476 &= -17;
				}
				break;
			case 4:
				if(v476) {
					bs476 |= 8;
				} else {
					bs476 &= -9;
				}
				break;
			case 5:
				if(v476) {
					bs476 |= 4;
				} else {
					bs476 &= -5;
				}
				break;
			case 6:
				if(v476) {
					bs476 |= 2;
				} else {
					bs476 &= -3;
				}
				break;
			case 7:
				if(v476) {
					bs476 |= 1;
				} else {
					bs476 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs476;
		var this478 = 0;
		var bs477 = this478;
		var l477 = "    *".length;
		var _g1477 = 0;
		var _g577 = l477;
		while(_g1477 < _g577) {
			var i477 = _g1477++;
			var no477 = "    *".charCodeAt(i477);
			if(no477 == null) {
				break;
			}
			var v477;
			switch(no477) {
			case 32:
				v477 = false;
				break;
			case 42:
				v477 = true;
				break;
			case 48:
				v477 = false;
				break;
			case 49:
				v477 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i477)));
			}
			switch(i477 - (l477 - 8)) {
			case 0:
				if(v477) {
					bs477 |= 128;
				} else {
					bs477 &= -129;
				}
				break;
			case 1:
				if(v477) {
					bs477 |= 64;
				} else {
					bs477 &= -65;
				}
				break;
			case 2:
				if(v477) {
					bs477 |= 32;
				} else {
					bs477 &= -33;
				}
				break;
			case 3:
				if(v477) {
					bs477 |= 16;
				} else {
					bs477 &= -17;
				}
				break;
			case 4:
				if(v477) {
					bs477 |= 8;
				} else {
					bs477 &= -9;
				}
				break;
			case 5:
				if(v477) {
					bs477 |= 4;
				} else {
					bs477 &= -5;
				}
				break;
			case 6:
				if(v477) {
					bs477 |= 2;
				} else {
					bs477 &= -3;
				}
				break;
			case 7:
				if(v477) {
					bs477 |= 1;
				} else {
					bs477 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs477;
		var this479 = 0;
		var bs478 = this479;
		var l478 = " ** *".length;
		var _g1478 = 0;
		var _g578 = l478;
		while(_g1478 < _g578) {
			var i478 = _g1478++;
			var no478 = " ** *".charCodeAt(i478);
			if(no478 == null) {
				break;
			}
			var v478;
			switch(no478) {
			case 32:
				v478 = false;
				break;
			case 42:
				v478 = true;
				break;
			case 48:
				v478 = false;
				break;
			case 49:
				v478 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i478)));
			}
			switch(i478 - (l478 - 8)) {
			case 0:
				if(v478) {
					bs478 |= 128;
				} else {
					bs478 &= -129;
				}
				break;
			case 1:
				if(v478) {
					bs478 |= 64;
				} else {
					bs478 &= -65;
				}
				break;
			case 2:
				if(v478) {
					bs478 |= 32;
				} else {
					bs478 &= -33;
				}
				break;
			case 3:
				if(v478) {
					bs478 |= 16;
				} else {
					bs478 &= -17;
				}
				break;
			case 4:
				if(v478) {
					bs478 |= 8;
				} else {
					bs478 &= -9;
				}
				break;
			case 5:
				if(v478) {
					bs478 |= 4;
				} else {
					bs478 &= -5;
				}
				break;
			case 6:
				if(v478) {
					bs478 |= 2;
				} else {
					bs478 &= -3;
				}
				break;
			case 7:
				if(v478) {
					bs478 |= 1;
				} else {
					bs478 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs478;
		var this480 = 0;
		var bs479 = this480;
		var l479 = "*  **".length;
		var _g1479 = 0;
		var _g579 = l479;
		while(_g1479 < _g579) {
			var i479 = _g1479++;
			var no479 = "*  **".charCodeAt(i479);
			if(no479 == null) {
				break;
			}
			var v479;
			switch(no479) {
			case 32:
				v479 = false;
				break;
			case 42:
				v479 = true;
				break;
			case 48:
				v479 = false;
				break;
			case 49:
				v479 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  **".charCodeAt(i479)));
			}
			switch(i479 - (l479 - 8)) {
			case 0:
				if(v479) {
					bs479 |= 128;
				} else {
					bs479 &= -129;
				}
				break;
			case 1:
				if(v479) {
					bs479 |= 64;
				} else {
					bs479 &= -65;
				}
				break;
			case 2:
				if(v479) {
					bs479 |= 32;
				} else {
					bs479 &= -33;
				}
				break;
			case 3:
				if(v479) {
					bs479 |= 16;
				} else {
					bs479 &= -17;
				}
				break;
			case 4:
				if(v479) {
					bs479 |= 8;
				} else {
					bs479 &= -9;
				}
				break;
			case 5:
				if(v479) {
					bs479 |= 4;
				} else {
					bs479 &= -5;
				}
				break;
			case 6:
				if(v479) {
					bs479 |= 2;
				} else {
					bs479 &= -3;
				}
				break;
			case 7:
				if(v479) {
					bs479 |= 1;
				} else {
					bs479 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs479;
		var this481 = 0;
		var bs480 = this481;
		var l480 = "*   *".length;
		var _g1480 = 0;
		var _g580 = l480;
		while(_g1480 < _g580) {
			var i480 = _g1480++;
			var no480 = "*   *".charCodeAt(i480);
			if(no480 == null) {
				break;
			}
			var v480;
			switch(no480) {
			case 32:
				v480 = false;
				break;
			case 42:
				v480 = true;
				break;
			case 48:
				v480 = false;
				break;
			case 49:
				v480 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i480)));
			}
			switch(i480 - (l480 - 8)) {
			case 0:
				if(v480) {
					bs480 |= 128;
				} else {
					bs480 &= -129;
				}
				break;
			case 1:
				if(v480) {
					bs480 |= 64;
				} else {
					bs480 &= -65;
				}
				break;
			case 2:
				if(v480) {
					bs480 |= 32;
				} else {
					bs480 &= -33;
				}
				break;
			case 3:
				if(v480) {
					bs480 |= 16;
				} else {
					bs480 &= -17;
				}
				break;
			case 4:
				if(v480) {
					bs480 |= 8;
				} else {
					bs480 &= -9;
				}
				break;
			case 5:
				if(v480) {
					bs480 |= 4;
				} else {
					bs480 &= -5;
				}
				break;
			case 6:
				if(v480) {
					bs480 |= 2;
				} else {
					bs480 &= -3;
				}
				break;
			case 7:
				if(v480) {
					bs480 |= 1;
				} else {
					bs480 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs480;
		var this482 = 0;
		var bs481 = this482;
		var l481 = "*   *".length;
		var _g1481 = 0;
		var _g581 = l481;
		while(_g1481 < _g581) {
			var i481 = _g1481++;
			var no481 = "*   *".charCodeAt(i481);
			if(no481 == null) {
				break;
			}
			var v481;
			switch(no481) {
			case 32:
				v481 = false;
				break;
			case 42:
				v481 = true;
				break;
			case 48:
				v481 = false;
				break;
			case 49:
				v481 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i481)));
			}
			switch(i481 - (l481 - 8)) {
			case 0:
				if(v481) {
					bs481 |= 128;
				} else {
					bs481 &= -129;
				}
				break;
			case 1:
				if(v481) {
					bs481 |= 64;
				} else {
					bs481 &= -65;
				}
				break;
			case 2:
				if(v481) {
					bs481 |= 32;
				} else {
					bs481 &= -33;
				}
				break;
			case 3:
				if(v481) {
					bs481 |= 16;
				} else {
					bs481 &= -17;
				}
				break;
			case 4:
				if(v481) {
					bs481 |= 8;
				} else {
					bs481 &= -9;
				}
				break;
			case 5:
				if(v481) {
					bs481 |= 4;
				} else {
					bs481 &= -5;
				}
				break;
			case 6:
				if(v481) {
					bs481 |= 2;
				} else {
					bs481 &= -3;
				}
				break;
			case 7:
				if(v481) {
					bs481 |= 1;
				} else {
					bs481 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs481;
		var this483 = 0;
		var bs482 = this483;
		var l482 = " ****".length;
		var _g1482 = 0;
		var _g582 = l482;
		while(_g1482 < _g582) {
			var i482 = _g1482++;
			var no482 = " ****".charCodeAt(i482);
			if(no482 == null) {
				break;
			}
			var v482;
			switch(no482) {
			case 32:
				v482 = false;
				break;
			case 42:
				v482 = true;
				break;
			case 48:
				v482 = false;
				break;
			case 49:
				v482 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i482)));
			}
			switch(i482 - (l482 - 8)) {
			case 0:
				if(v482) {
					bs482 |= 128;
				} else {
					bs482 &= -129;
				}
				break;
			case 1:
				if(v482) {
					bs482 |= 64;
				} else {
					bs482 &= -65;
				}
				break;
			case 2:
				if(v482) {
					bs482 |= 32;
				} else {
					bs482 &= -33;
				}
				break;
			case 3:
				if(v482) {
					bs482 |= 16;
				} else {
					bs482 &= -17;
				}
				break;
			case 4:
				if(v482) {
					bs482 |= 8;
				} else {
					bs482 &= -9;
				}
				break;
			case 5:
				if(v482) {
					bs482 |= 4;
				} else {
					bs482 &= -5;
				}
				break;
			case 6:
				if(v482) {
					bs482 |= 2;
				} else {
					bs482 &= -3;
				}
				break;
			case 7:
				if(v482) {
					bs482 |= 1;
				} else {
					bs482 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs482;
		break;
	case 101:
		var this484 = 0;
		var bs483 = this484;
		var l483 = "     ".length;
		var _g1483 = 0;
		var _g583 = l483;
		while(_g1483 < _g583) {
			var i483 = _g1483++;
			var no483 = "     ".charCodeAt(i483);
			if(no483 == null) {
				break;
			}
			var v483;
			switch(no483) {
			case 32:
				v483 = false;
				break;
			case 42:
				v483 = true;
				break;
			case 48:
				v483 = false;
				break;
			case 49:
				v483 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i483)));
			}
			switch(i483 - (l483 - 8)) {
			case 0:
				if(v483) {
					bs483 |= 128;
				} else {
					bs483 &= -129;
				}
				break;
			case 1:
				if(v483) {
					bs483 |= 64;
				} else {
					bs483 &= -65;
				}
				break;
			case 2:
				if(v483) {
					bs483 |= 32;
				} else {
					bs483 &= -33;
				}
				break;
			case 3:
				if(v483) {
					bs483 |= 16;
				} else {
					bs483 &= -17;
				}
				break;
			case 4:
				if(v483) {
					bs483 |= 8;
				} else {
					bs483 &= -9;
				}
				break;
			case 5:
				if(v483) {
					bs483 |= 4;
				} else {
					bs483 &= -5;
				}
				break;
			case 6:
				if(v483) {
					bs483 |= 2;
				} else {
					bs483 &= -3;
				}
				break;
			case 7:
				if(v483) {
					bs483 |= 1;
				} else {
					bs483 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs483;
		var this485 = 0;
		var bs484 = this485;
		var l484 = "     ".length;
		var _g1484 = 0;
		var _g584 = l484;
		while(_g1484 < _g584) {
			var i484 = _g1484++;
			var no484 = "     ".charCodeAt(i484);
			if(no484 == null) {
				break;
			}
			var v484;
			switch(no484) {
			case 32:
				v484 = false;
				break;
			case 42:
				v484 = true;
				break;
			case 48:
				v484 = false;
				break;
			case 49:
				v484 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i484)));
			}
			switch(i484 - (l484 - 8)) {
			case 0:
				if(v484) {
					bs484 |= 128;
				} else {
					bs484 &= -129;
				}
				break;
			case 1:
				if(v484) {
					bs484 |= 64;
				} else {
					bs484 &= -65;
				}
				break;
			case 2:
				if(v484) {
					bs484 |= 32;
				} else {
					bs484 &= -33;
				}
				break;
			case 3:
				if(v484) {
					bs484 |= 16;
				} else {
					bs484 &= -17;
				}
				break;
			case 4:
				if(v484) {
					bs484 |= 8;
				} else {
					bs484 &= -9;
				}
				break;
			case 5:
				if(v484) {
					bs484 |= 4;
				} else {
					bs484 &= -5;
				}
				break;
			case 6:
				if(v484) {
					bs484 |= 2;
				} else {
					bs484 &= -3;
				}
				break;
			case 7:
				if(v484) {
					bs484 |= 1;
				} else {
					bs484 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs484;
		var this486 = 0;
		var bs485 = this486;
		var l485 = " *** ".length;
		var _g1485 = 0;
		var _g585 = l485;
		while(_g1485 < _g585) {
			var i485 = _g1485++;
			var no485 = " *** ".charCodeAt(i485);
			if(no485 == null) {
				break;
			}
			var v485;
			switch(no485) {
			case 32:
				v485 = false;
				break;
			case 42:
				v485 = true;
				break;
			case 48:
				v485 = false;
				break;
			case 49:
				v485 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i485)));
			}
			switch(i485 - (l485 - 8)) {
			case 0:
				if(v485) {
					bs485 |= 128;
				} else {
					bs485 &= -129;
				}
				break;
			case 1:
				if(v485) {
					bs485 |= 64;
				} else {
					bs485 &= -65;
				}
				break;
			case 2:
				if(v485) {
					bs485 |= 32;
				} else {
					bs485 &= -33;
				}
				break;
			case 3:
				if(v485) {
					bs485 |= 16;
				} else {
					bs485 &= -17;
				}
				break;
			case 4:
				if(v485) {
					bs485 |= 8;
				} else {
					bs485 &= -9;
				}
				break;
			case 5:
				if(v485) {
					bs485 |= 4;
				} else {
					bs485 &= -5;
				}
				break;
			case 6:
				if(v485) {
					bs485 |= 2;
				} else {
					bs485 &= -3;
				}
				break;
			case 7:
				if(v485) {
					bs485 |= 1;
				} else {
					bs485 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs485;
		var this487 = 0;
		var bs486 = this487;
		var l486 = "*   *".length;
		var _g1486 = 0;
		var _g586 = l486;
		while(_g1486 < _g586) {
			var i486 = _g1486++;
			var no486 = "*   *".charCodeAt(i486);
			if(no486 == null) {
				break;
			}
			var v486;
			switch(no486) {
			case 32:
				v486 = false;
				break;
			case 42:
				v486 = true;
				break;
			case 48:
				v486 = false;
				break;
			case 49:
				v486 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i486)));
			}
			switch(i486 - (l486 - 8)) {
			case 0:
				if(v486) {
					bs486 |= 128;
				} else {
					bs486 &= -129;
				}
				break;
			case 1:
				if(v486) {
					bs486 |= 64;
				} else {
					bs486 &= -65;
				}
				break;
			case 2:
				if(v486) {
					bs486 |= 32;
				} else {
					bs486 &= -33;
				}
				break;
			case 3:
				if(v486) {
					bs486 |= 16;
				} else {
					bs486 &= -17;
				}
				break;
			case 4:
				if(v486) {
					bs486 |= 8;
				} else {
					bs486 &= -9;
				}
				break;
			case 5:
				if(v486) {
					bs486 |= 4;
				} else {
					bs486 &= -5;
				}
				break;
			case 6:
				if(v486) {
					bs486 |= 2;
				} else {
					bs486 &= -3;
				}
				break;
			case 7:
				if(v486) {
					bs486 |= 1;
				} else {
					bs486 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs486;
		var this488 = 0;
		var bs487 = this488;
		var l487 = "*****".length;
		var _g1487 = 0;
		var _g587 = l487;
		while(_g1487 < _g587) {
			var i487 = _g1487++;
			var no487 = "*****".charCodeAt(i487);
			if(no487 == null) {
				break;
			}
			var v487;
			switch(no487) {
			case 32:
				v487 = false;
				break;
			case 42:
				v487 = true;
				break;
			case 48:
				v487 = false;
				break;
			case 49:
				v487 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i487)));
			}
			switch(i487 - (l487 - 8)) {
			case 0:
				if(v487) {
					bs487 |= 128;
				} else {
					bs487 &= -129;
				}
				break;
			case 1:
				if(v487) {
					bs487 |= 64;
				} else {
					bs487 &= -65;
				}
				break;
			case 2:
				if(v487) {
					bs487 |= 32;
				} else {
					bs487 &= -33;
				}
				break;
			case 3:
				if(v487) {
					bs487 |= 16;
				} else {
					bs487 &= -17;
				}
				break;
			case 4:
				if(v487) {
					bs487 |= 8;
				} else {
					bs487 &= -9;
				}
				break;
			case 5:
				if(v487) {
					bs487 |= 4;
				} else {
					bs487 &= -5;
				}
				break;
			case 6:
				if(v487) {
					bs487 |= 2;
				} else {
					bs487 &= -3;
				}
				break;
			case 7:
				if(v487) {
					bs487 |= 1;
				} else {
					bs487 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs487;
		var this489 = 0;
		var bs488 = this489;
		var l488 = "*    ".length;
		var _g1488 = 0;
		var _g588 = l488;
		while(_g1488 < _g588) {
			var i488 = _g1488++;
			var no488 = "*    ".charCodeAt(i488);
			if(no488 == null) {
				break;
			}
			var v488;
			switch(no488) {
			case 32:
				v488 = false;
				break;
			case 42:
				v488 = true;
				break;
			case 48:
				v488 = false;
				break;
			case 49:
				v488 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i488)));
			}
			switch(i488 - (l488 - 8)) {
			case 0:
				if(v488) {
					bs488 |= 128;
				} else {
					bs488 &= -129;
				}
				break;
			case 1:
				if(v488) {
					bs488 |= 64;
				} else {
					bs488 &= -65;
				}
				break;
			case 2:
				if(v488) {
					bs488 |= 32;
				} else {
					bs488 &= -33;
				}
				break;
			case 3:
				if(v488) {
					bs488 |= 16;
				} else {
					bs488 &= -17;
				}
				break;
			case 4:
				if(v488) {
					bs488 |= 8;
				} else {
					bs488 &= -9;
				}
				break;
			case 5:
				if(v488) {
					bs488 |= 4;
				} else {
					bs488 &= -5;
				}
				break;
			case 6:
				if(v488) {
					bs488 |= 2;
				} else {
					bs488 &= -3;
				}
				break;
			case 7:
				if(v488) {
					bs488 |= 1;
				} else {
					bs488 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs488;
		var this490 = 0;
		var bs489 = this490;
		var l489 = " *** ".length;
		var _g1489 = 0;
		var _g589 = l489;
		while(_g1489 < _g589) {
			var i489 = _g1489++;
			var no489 = " *** ".charCodeAt(i489);
			if(no489 == null) {
				break;
			}
			var v489;
			switch(no489) {
			case 32:
				v489 = false;
				break;
			case 42:
				v489 = true;
				break;
			case 48:
				v489 = false;
				break;
			case 49:
				v489 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i489)));
			}
			switch(i489 - (l489 - 8)) {
			case 0:
				if(v489) {
					bs489 |= 128;
				} else {
					bs489 &= -129;
				}
				break;
			case 1:
				if(v489) {
					bs489 |= 64;
				} else {
					bs489 &= -65;
				}
				break;
			case 2:
				if(v489) {
					bs489 |= 32;
				} else {
					bs489 &= -33;
				}
				break;
			case 3:
				if(v489) {
					bs489 |= 16;
				} else {
					bs489 &= -17;
				}
				break;
			case 4:
				if(v489) {
					bs489 |= 8;
				} else {
					bs489 &= -9;
				}
				break;
			case 5:
				if(v489) {
					bs489 |= 4;
				} else {
					bs489 &= -5;
				}
				break;
			case 6:
				if(v489) {
					bs489 |= 2;
				} else {
					bs489 &= -3;
				}
				break;
			case 7:
				if(v489) {
					bs489 |= 1;
				} else {
					bs489 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs489;
		break;
	case 102:
		var this491 = 0;
		var bs490 = this491;
		var l490 = "  ** ".length;
		var _g1490 = 0;
		var _g590 = l490;
		while(_g1490 < _g590) {
			var i490 = _g1490++;
			var no490 = "  ** ".charCodeAt(i490);
			if(no490 == null) {
				break;
			}
			var v490;
			switch(no490) {
			case 32:
				v490 = false;
				break;
			case 42:
				v490 = true;
				break;
			case 48:
				v490 = false;
				break;
			case 49:
				v490 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i490)));
			}
			switch(i490 - (l490 - 8)) {
			case 0:
				if(v490) {
					bs490 |= 128;
				} else {
					bs490 &= -129;
				}
				break;
			case 1:
				if(v490) {
					bs490 |= 64;
				} else {
					bs490 &= -65;
				}
				break;
			case 2:
				if(v490) {
					bs490 |= 32;
				} else {
					bs490 &= -33;
				}
				break;
			case 3:
				if(v490) {
					bs490 |= 16;
				} else {
					bs490 &= -17;
				}
				break;
			case 4:
				if(v490) {
					bs490 |= 8;
				} else {
					bs490 &= -9;
				}
				break;
			case 5:
				if(v490) {
					bs490 |= 4;
				} else {
					bs490 &= -5;
				}
				break;
			case 6:
				if(v490) {
					bs490 |= 2;
				} else {
					bs490 &= -3;
				}
				break;
			case 7:
				if(v490) {
					bs490 |= 1;
				} else {
					bs490 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs490;
		var this492 = 0;
		var bs491 = this492;
		var l491 = " *  *".length;
		var _g1491 = 0;
		var _g591 = l491;
		while(_g1491 < _g591) {
			var i491 = _g1491++;
			var no491 = " *  *".charCodeAt(i491);
			if(no491 == null) {
				break;
			}
			var v491;
			switch(no491) {
			case 32:
				v491 = false;
				break;
			case 42:
				v491 = true;
				break;
			case 48:
				v491 = false;
				break;
			case 49:
				v491 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *  *".charCodeAt(i491)));
			}
			switch(i491 - (l491 - 8)) {
			case 0:
				if(v491) {
					bs491 |= 128;
				} else {
					bs491 &= -129;
				}
				break;
			case 1:
				if(v491) {
					bs491 |= 64;
				} else {
					bs491 &= -65;
				}
				break;
			case 2:
				if(v491) {
					bs491 |= 32;
				} else {
					bs491 &= -33;
				}
				break;
			case 3:
				if(v491) {
					bs491 |= 16;
				} else {
					bs491 &= -17;
				}
				break;
			case 4:
				if(v491) {
					bs491 |= 8;
				} else {
					bs491 &= -9;
				}
				break;
			case 5:
				if(v491) {
					bs491 |= 4;
				} else {
					bs491 &= -5;
				}
				break;
			case 6:
				if(v491) {
					bs491 |= 2;
				} else {
					bs491 &= -3;
				}
				break;
			case 7:
				if(v491) {
					bs491 |= 1;
				} else {
					bs491 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs491;
		var this493 = 0;
		var bs492 = this493;
		var l492 = " *   ".length;
		var _g1492 = 0;
		var _g592 = l492;
		while(_g1492 < _g592) {
			var i492 = _g1492++;
			var no492 = " *   ".charCodeAt(i492);
			if(no492 == null) {
				break;
			}
			var v492;
			switch(no492) {
			case 32:
				v492 = false;
				break;
			case 42:
				v492 = true;
				break;
			case 48:
				v492 = false;
				break;
			case 49:
				v492 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i492)));
			}
			switch(i492 - (l492 - 8)) {
			case 0:
				if(v492) {
					bs492 |= 128;
				} else {
					bs492 &= -129;
				}
				break;
			case 1:
				if(v492) {
					bs492 |= 64;
				} else {
					bs492 &= -65;
				}
				break;
			case 2:
				if(v492) {
					bs492 |= 32;
				} else {
					bs492 &= -33;
				}
				break;
			case 3:
				if(v492) {
					bs492 |= 16;
				} else {
					bs492 &= -17;
				}
				break;
			case 4:
				if(v492) {
					bs492 |= 8;
				} else {
					bs492 &= -9;
				}
				break;
			case 5:
				if(v492) {
					bs492 |= 4;
				} else {
					bs492 &= -5;
				}
				break;
			case 6:
				if(v492) {
					bs492 |= 2;
				} else {
					bs492 &= -3;
				}
				break;
			case 7:
				if(v492) {
					bs492 |= 1;
				} else {
					bs492 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs492;
		var this494 = 0;
		var bs493 = this494;
		var l493 = "***  ".length;
		var _g1493 = 0;
		var _g593 = l493;
		while(_g1493 < _g593) {
			var i493 = _g1493++;
			var no493 = "***  ".charCodeAt(i493);
			if(no493 == null) {
				break;
			}
			var v493;
			switch(no493) {
			case 32:
				v493 = false;
				break;
			case 42:
				v493 = true;
				break;
			case 48:
				v493 = false;
				break;
			case 49:
				v493 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("***  ".charCodeAt(i493)));
			}
			switch(i493 - (l493 - 8)) {
			case 0:
				if(v493) {
					bs493 |= 128;
				} else {
					bs493 &= -129;
				}
				break;
			case 1:
				if(v493) {
					bs493 |= 64;
				} else {
					bs493 &= -65;
				}
				break;
			case 2:
				if(v493) {
					bs493 |= 32;
				} else {
					bs493 &= -33;
				}
				break;
			case 3:
				if(v493) {
					bs493 |= 16;
				} else {
					bs493 &= -17;
				}
				break;
			case 4:
				if(v493) {
					bs493 |= 8;
				} else {
					bs493 &= -9;
				}
				break;
			case 5:
				if(v493) {
					bs493 |= 4;
				} else {
					bs493 &= -5;
				}
				break;
			case 6:
				if(v493) {
					bs493 |= 2;
				} else {
					bs493 &= -3;
				}
				break;
			case 7:
				if(v493) {
					bs493 |= 1;
				} else {
					bs493 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs493;
		var this495 = 0;
		var bs494 = this495;
		var l494 = " *   ".length;
		var _g1494 = 0;
		var _g594 = l494;
		while(_g1494 < _g594) {
			var i494 = _g1494++;
			var no494 = " *   ".charCodeAt(i494);
			if(no494 == null) {
				break;
			}
			var v494;
			switch(no494) {
			case 32:
				v494 = false;
				break;
			case 42:
				v494 = true;
				break;
			case 48:
				v494 = false;
				break;
			case 49:
				v494 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i494)));
			}
			switch(i494 - (l494 - 8)) {
			case 0:
				if(v494) {
					bs494 |= 128;
				} else {
					bs494 &= -129;
				}
				break;
			case 1:
				if(v494) {
					bs494 |= 64;
				} else {
					bs494 &= -65;
				}
				break;
			case 2:
				if(v494) {
					bs494 |= 32;
				} else {
					bs494 &= -33;
				}
				break;
			case 3:
				if(v494) {
					bs494 |= 16;
				} else {
					bs494 &= -17;
				}
				break;
			case 4:
				if(v494) {
					bs494 |= 8;
				} else {
					bs494 &= -9;
				}
				break;
			case 5:
				if(v494) {
					bs494 |= 4;
				} else {
					bs494 &= -5;
				}
				break;
			case 6:
				if(v494) {
					bs494 |= 2;
				} else {
					bs494 &= -3;
				}
				break;
			case 7:
				if(v494) {
					bs494 |= 1;
				} else {
					bs494 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs494;
		var this496 = 0;
		var bs495 = this496;
		var l495 = " *   ".length;
		var _g1495 = 0;
		var _g595 = l495;
		while(_g1495 < _g595) {
			var i495 = _g1495++;
			var no495 = " *   ".charCodeAt(i495);
			if(no495 == null) {
				break;
			}
			var v495;
			switch(no495) {
			case 32:
				v495 = false;
				break;
			case 42:
				v495 = true;
				break;
			case 48:
				v495 = false;
				break;
			case 49:
				v495 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i495)));
			}
			switch(i495 - (l495 - 8)) {
			case 0:
				if(v495) {
					bs495 |= 128;
				} else {
					bs495 &= -129;
				}
				break;
			case 1:
				if(v495) {
					bs495 |= 64;
				} else {
					bs495 &= -65;
				}
				break;
			case 2:
				if(v495) {
					bs495 |= 32;
				} else {
					bs495 &= -33;
				}
				break;
			case 3:
				if(v495) {
					bs495 |= 16;
				} else {
					bs495 &= -17;
				}
				break;
			case 4:
				if(v495) {
					bs495 |= 8;
				} else {
					bs495 &= -9;
				}
				break;
			case 5:
				if(v495) {
					bs495 |= 4;
				} else {
					bs495 &= -5;
				}
				break;
			case 6:
				if(v495) {
					bs495 |= 2;
				} else {
					bs495 &= -3;
				}
				break;
			case 7:
				if(v495) {
					bs495 |= 1;
				} else {
					bs495 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs495;
		var this497 = 0;
		var bs496 = this497;
		var l496 = " *   ".length;
		var _g1496 = 0;
		var _g596 = l496;
		while(_g1496 < _g596) {
			var i496 = _g1496++;
			var no496 = " *   ".charCodeAt(i496);
			if(no496 == null) {
				break;
			}
			var v496;
			switch(no496) {
			case 32:
				v496 = false;
				break;
			case 42:
				v496 = true;
				break;
			case 48:
				v496 = false;
				break;
			case 49:
				v496 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i496)));
			}
			switch(i496 - (l496 - 8)) {
			case 0:
				if(v496) {
					bs496 |= 128;
				} else {
					bs496 &= -129;
				}
				break;
			case 1:
				if(v496) {
					bs496 |= 64;
				} else {
					bs496 &= -65;
				}
				break;
			case 2:
				if(v496) {
					bs496 |= 32;
				} else {
					bs496 &= -33;
				}
				break;
			case 3:
				if(v496) {
					bs496 |= 16;
				} else {
					bs496 &= -17;
				}
				break;
			case 4:
				if(v496) {
					bs496 |= 8;
				} else {
					bs496 &= -9;
				}
				break;
			case 5:
				if(v496) {
					bs496 |= 4;
				} else {
					bs496 &= -5;
				}
				break;
			case 6:
				if(v496) {
					bs496 |= 2;
				} else {
					bs496 &= -3;
				}
				break;
			case 7:
				if(v496) {
					bs496 |= 1;
				} else {
					bs496 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs496;
		break;
	case 103:
		var this498 = 0;
		var bs497 = this498;
		var l497 = "     ".length;
		var _g1497 = 0;
		var _g597 = l497;
		while(_g1497 < _g597) {
			var i497 = _g1497++;
			var no497 = "     ".charCodeAt(i497);
			if(no497 == null) {
				break;
			}
			var v497;
			switch(no497) {
			case 32:
				v497 = false;
				break;
			case 42:
				v497 = true;
				break;
			case 48:
				v497 = false;
				break;
			case 49:
				v497 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i497)));
			}
			switch(i497 - (l497 - 8)) {
			case 0:
				if(v497) {
					bs497 |= 128;
				} else {
					bs497 &= -129;
				}
				break;
			case 1:
				if(v497) {
					bs497 |= 64;
				} else {
					bs497 &= -65;
				}
				break;
			case 2:
				if(v497) {
					bs497 |= 32;
				} else {
					bs497 &= -33;
				}
				break;
			case 3:
				if(v497) {
					bs497 |= 16;
				} else {
					bs497 &= -17;
				}
				break;
			case 4:
				if(v497) {
					bs497 |= 8;
				} else {
					bs497 &= -9;
				}
				break;
			case 5:
				if(v497) {
					bs497 |= 4;
				} else {
					bs497 &= -5;
				}
				break;
			case 6:
				if(v497) {
					bs497 |= 2;
				} else {
					bs497 &= -3;
				}
				break;
			case 7:
				if(v497) {
					bs497 |= 1;
				} else {
					bs497 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs497;
		var this499 = 0;
		var bs498 = this499;
		var l498 = " ****".length;
		var _g1498 = 0;
		var _g598 = l498;
		while(_g1498 < _g598) {
			var i498 = _g1498++;
			var no498 = " ****".charCodeAt(i498);
			if(no498 == null) {
				break;
			}
			var v498;
			switch(no498) {
			case 32:
				v498 = false;
				break;
			case 42:
				v498 = true;
				break;
			case 48:
				v498 = false;
				break;
			case 49:
				v498 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i498)));
			}
			switch(i498 - (l498 - 8)) {
			case 0:
				if(v498) {
					bs498 |= 128;
				} else {
					bs498 &= -129;
				}
				break;
			case 1:
				if(v498) {
					bs498 |= 64;
				} else {
					bs498 &= -65;
				}
				break;
			case 2:
				if(v498) {
					bs498 |= 32;
				} else {
					bs498 &= -33;
				}
				break;
			case 3:
				if(v498) {
					bs498 |= 16;
				} else {
					bs498 &= -17;
				}
				break;
			case 4:
				if(v498) {
					bs498 |= 8;
				} else {
					bs498 &= -9;
				}
				break;
			case 5:
				if(v498) {
					bs498 |= 4;
				} else {
					bs498 &= -5;
				}
				break;
			case 6:
				if(v498) {
					bs498 |= 2;
				} else {
					bs498 &= -3;
				}
				break;
			case 7:
				if(v498) {
					bs498 |= 1;
				} else {
					bs498 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs498;
		var this500 = 0;
		var bs499 = this500;
		var l499 = "*   *".length;
		var _g1499 = 0;
		var _g599 = l499;
		while(_g1499 < _g599) {
			var i499 = _g1499++;
			var no499 = "*   *".charCodeAt(i499);
			if(no499 == null) {
				break;
			}
			var v499;
			switch(no499) {
			case 32:
				v499 = false;
				break;
			case 42:
				v499 = true;
				break;
			case 48:
				v499 = false;
				break;
			case 49:
				v499 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i499)));
			}
			switch(i499 - (l499 - 8)) {
			case 0:
				if(v499) {
					bs499 |= 128;
				} else {
					bs499 &= -129;
				}
				break;
			case 1:
				if(v499) {
					bs499 |= 64;
				} else {
					bs499 &= -65;
				}
				break;
			case 2:
				if(v499) {
					bs499 |= 32;
				} else {
					bs499 &= -33;
				}
				break;
			case 3:
				if(v499) {
					bs499 |= 16;
				} else {
					bs499 &= -17;
				}
				break;
			case 4:
				if(v499) {
					bs499 |= 8;
				} else {
					bs499 &= -9;
				}
				break;
			case 5:
				if(v499) {
					bs499 |= 4;
				} else {
					bs499 &= -5;
				}
				break;
			case 6:
				if(v499) {
					bs499 |= 2;
				} else {
					bs499 &= -3;
				}
				break;
			case 7:
				if(v499) {
					bs499 |= 1;
				} else {
					bs499 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs499;
		var this501 = 0;
		var bs500 = this501;
		var l500 = "*   *".length;
		var _g1500 = 0;
		var _g600 = l500;
		while(_g1500 < _g600) {
			var i500 = _g1500++;
			var no500 = "*   *".charCodeAt(i500);
			if(no500 == null) {
				break;
			}
			var v500;
			switch(no500) {
			case 32:
				v500 = false;
				break;
			case 42:
				v500 = true;
				break;
			case 48:
				v500 = false;
				break;
			case 49:
				v500 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i500)));
			}
			switch(i500 - (l500 - 8)) {
			case 0:
				if(v500) {
					bs500 |= 128;
				} else {
					bs500 &= -129;
				}
				break;
			case 1:
				if(v500) {
					bs500 |= 64;
				} else {
					bs500 &= -65;
				}
				break;
			case 2:
				if(v500) {
					bs500 |= 32;
				} else {
					bs500 &= -33;
				}
				break;
			case 3:
				if(v500) {
					bs500 |= 16;
				} else {
					bs500 &= -17;
				}
				break;
			case 4:
				if(v500) {
					bs500 |= 8;
				} else {
					bs500 &= -9;
				}
				break;
			case 5:
				if(v500) {
					bs500 |= 4;
				} else {
					bs500 &= -5;
				}
				break;
			case 6:
				if(v500) {
					bs500 |= 2;
				} else {
					bs500 &= -3;
				}
				break;
			case 7:
				if(v500) {
					bs500 |= 1;
				} else {
					bs500 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs500;
		var this502 = 0;
		var bs501 = this502;
		var l501 = " ****".length;
		var _g1501 = 0;
		var _g601 = l501;
		while(_g1501 < _g601) {
			var i501 = _g1501++;
			var no501 = " ****".charCodeAt(i501);
			if(no501 == null) {
				break;
			}
			var v501;
			switch(no501) {
			case 32:
				v501 = false;
				break;
			case 42:
				v501 = true;
				break;
			case 48:
				v501 = false;
				break;
			case 49:
				v501 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i501)));
			}
			switch(i501 - (l501 - 8)) {
			case 0:
				if(v501) {
					bs501 |= 128;
				} else {
					bs501 &= -129;
				}
				break;
			case 1:
				if(v501) {
					bs501 |= 64;
				} else {
					bs501 &= -65;
				}
				break;
			case 2:
				if(v501) {
					bs501 |= 32;
				} else {
					bs501 &= -33;
				}
				break;
			case 3:
				if(v501) {
					bs501 |= 16;
				} else {
					bs501 &= -17;
				}
				break;
			case 4:
				if(v501) {
					bs501 |= 8;
				} else {
					bs501 &= -9;
				}
				break;
			case 5:
				if(v501) {
					bs501 |= 4;
				} else {
					bs501 &= -5;
				}
				break;
			case 6:
				if(v501) {
					bs501 |= 2;
				} else {
					bs501 &= -3;
				}
				break;
			case 7:
				if(v501) {
					bs501 |= 1;
				} else {
					bs501 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs501;
		var this503 = 0;
		var bs502 = this503;
		var l502 = "    *".length;
		var _g1502 = 0;
		var _g602 = l502;
		while(_g1502 < _g602) {
			var i502 = _g1502++;
			var no502 = "    *".charCodeAt(i502);
			if(no502 == null) {
				break;
			}
			var v502;
			switch(no502) {
			case 32:
				v502 = false;
				break;
			case 42:
				v502 = true;
				break;
			case 48:
				v502 = false;
				break;
			case 49:
				v502 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i502)));
			}
			switch(i502 - (l502 - 8)) {
			case 0:
				if(v502) {
					bs502 |= 128;
				} else {
					bs502 &= -129;
				}
				break;
			case 1:
				if(v502) {
					bs502 |= 64;
				} else {
					bs502 &= -65;
				}
				break;
			case 2:
				if(v502) {
					bs502 |= 32;
				} else {
					bs502 &= -33;
				}
				break;
			case 3:
				if(v502) {
					bs502 |= 16;
				} else {
					bs502 &= -17;
				}
				break;
			case 4:
				if(v502) {
					bs502 |= 8;
				} else {
					bs502 &= -9;
				}
				break;
			case 5:
				if(v502) {
					bs502 |= 4;
				} else {
					bs502 &= -5;
				}
				break;
			case 6:
				if(v502) {
					bs502 |= 2;
				} else {
					bs502 &= -3;
				}
				break;
			case 7:
				if(v502) {
					bs502 |= 1;
				} else {
					bs502 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs502;
		var this504 = 0;
		var bs503 = this504;
		var l503 = " *** ".length;
		var _g1503 = 0;
		var _g603 = l503;
		while(_g1503 < _g603) {
			var i503 = _g1503++;
			var no503 = " *** ".charCodeAt(i503);
			if(no503 == null) {
				break;
			}
			var v503;
			switch(no503) {
			case 32:
				v503 = false;
				break;
			case 42:
				v503 = true;
				break;
			case 48:
				v503 = false;
				break;
			case 49:
				v503 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i503)));
			}
			switch(i503 - (l503 - 8)) {
			case 0:
				if(v503) {
					bs503 |= 128;
				} else {
					bs503 &= -129;
				}
				break;
			case 1:
				if(v503) {
					bs503 |= 64;
				} else {
					bs503 &= -65;
				}
				break;
			case 2:
				if(v503) {
					bs503 |= 32;
				} else {
					bs503 &= -33;
				}
				break;
			case 3:
				if(v503) {
					bs503 |= 16;
				} else {
					bs503 &= -17;
				}
				break;
			case 4:
				if(v503) {
					bs503 |= 8;
				} else {
					bs503 &= -9;
				}
				break;
			case 5:
				if(v503) {
					bs503 |= 4;
				} else {
					bs503 &= -5;
				}
				break;
			case 6:
				if(v503) {
					bs503 |= 2;
				} else {
					bs503 &= -3;
				}
				break;
			case 7:
				if(v503) {
					bs503 |= 1;
				} else {
					bs503 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs503;
		break;
	case 104:
		var this505 = 0;
		var bs504 = this505;
		var l504 = "*    ".length;
		var _g1504 = 0;
		var _g604 = l504;
		while(_g1504 < _g604) {
			var i504 = _g1504++;
			var no504 = "*    ".charCodeAt(i504);
			if(no504 == null) {
				break;
			}
			var v504;
			switch(no504) {
			case 32:
				v504 = false;
				break;
			case 42:
				v504 = true;
				break;
			case 48:
				v504 = false;
				break;
			case 49:
				v504 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i504)));
			}
			switch(i504 - (l504 - 8)) {
			case 0:
				if(v504) {
					bs504 |= 128;
				} else {
					bs504 &= -129;
				}
				break;
			case 1:
				if(v504) {
					bs504 |= 64;
				} else {
					bs504 &= -65;
				}
				break;
			case 2:
				if(v504) {
					bs504 |= 32;
				} else {
					bs504 &= -33;
				}
				break;
			case 3:
				if(v504) {
					bs504 |= 16;
				} else {
					bs504 &= -17;
				}
				break;
			case 4:
				if(v504) {
					bs504 |= 8;
				} else {
					bs504 &= -9;
				}
				break;
			case 5:
				if(v504) {
					bs504 |= 4;
				} else {
					bs504 &= -5;
				}
				break;
			case 6:
				if(v504) {
					bs504 |= 2;
				} else {
					bs504 &= -3;
				}
				break;
			case 7:
				if(v504) {
					bs504 |= 1;
				} else {
					bs504 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs504;
		var this506 = 0;
		var bs505 = this506;
		var l505 = "*    ".length;
		var _g1505 = 0;
		var _g605 = l505;
		while(_g1505 < _g605) {
			var i505 = _g1505++;
			var no505 = "*    ".charCodeAt(i505);
			if(no505 == null) {
				break;
			}
			var v505;
			switch(no505) {
			case 32:
				v505 = false;
				break;
			case 42:
				v505 = true;
				break;
			case 48:
				v505 = false;
				break;
			case 49:
				v505 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i505)));
			}
			switch(i505 - (l505 - 8)) {
			case 0:
				if(v505) {
					bs505 |= 128;
				} else {
					bs505 &= -129;
				}
				break;
			case 1:
				if(v505) {
					bs505 |= 64;
				} else {
					bs505 &= -65;
				}
				break;
			case 2:
				if(v505) {
					bs505 |= 32;
				} else {
					bs505 &= -33;
				}
				break;
			case 3:
				if(v505) {
					bs505 |= 16;
				} else {
					bs505 &= -17;
				}
				break;
			case 4:
				if(v505) {
					bs505 |= 8;
				} else {
					bs505 &= -9;
				}
				break;
			case 5:
				if(v505) {
					bs505 |= 4;
				} else {
					bs505 &= -5;
				}
				break;
			case 6:
				if(v505) {
					bs505 |= 2;
				} else {
					bs505 &= -3;
				}
				break;
			case 7:
				if(v505) {
					bs505 |= 1;
				} else {
					bs505 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs505;
		var this507 = 0;
		var bs506 = this507;
		var l506 = "* ** ".length;
		var _g1506 = 0;
		var _g606 = l506;
		while(_g1506 < _g606) {
			var i506 = _g1506++;
			var no506 = "* ** ".charCodeAt(i506);
			if(no506 == null) {
				break;
			}
			var v506;
			switch(no506) {
			case 32:
				v506 = false;
				break;
			case 42:
				v506 = true;
				break;
			case 48:
				v506 = false;
				break;
			case 49:
				v506 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* ** ".charCodeAt(i506)));
			}
			switch(i506 - (l506 - 8)) {
			case 0:
				if(v506) {
					bs506 |= 128;
				} else {
					bs506 &= -129;
				}
				break;
			case 1:
				if(v506) {
					bs506 |= 64;
				} else {
					bs506 &= -65;
				}
				break;
			case 2:
				if(v506) {
					bs506 |= 32;
				} else {
					bs506 &= -33;
				}
				break;
			case 3:
				if(v506) {
					bs506 |= 16;
				} else {
					bs506 &= -17;
				}
				break;
			case 4:
				if(v506) {
					bs506 |= 8;
				} else {
					bs506 &= -9;
				}
				break;
			case 5:
				if(v506) {
					bs506 |= 4;
				} else {
					bs506 &= -5;
				}
				break;
			case 6:
				if(v506) {
					bs506 |= 2;
				} else {
					bs506 &= -3;
				}
				break;
			case 7:
				if(v506) {
					bs506 |= 1;
				} else {
					bs506 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs506;
		var this508 = 0;
		var bs507 = this508;
		var l507 = "**  *".length;
		var _g1507 = 0;
		var _g607 = l507;
		while(_g1507 < _g607) {
			var i507 = _g1507++;
			var no507 = "**  *".charCodeAt(i507);
			if(no507 == null) {
				break;
			}
			var v507;
			switch(no507) {
			case 32:
				v507 = false;
				break;
			case 42:
				v507 = true;
				break;
			case 48:
				v507 = false;
				break;
			case 49:
				v507 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i507)));
			}
			switch(i507 - (l507 - 8)) {
			case 0:
				if(v507) {
					bs507 |= 128;
				} else {
					bs507 &= -129;
				}
				break;
			case 1:
				if(v507) {
					bs507 |= 64;
				} else {
					bs507 &= -65;
				}
				break;
			case 2:
				if(v507) {
					bs507 |= 32;
				} else {
					bs507 &= -33;
				}
				break;
			case 3:
				if(v507) {
					bs507 |= 16;
				} else {
					bs507 &= -17;
				}
				break;
			case 4:
				if(v507) {
					bs507 |= 8;
				} else {
					bs507 &= -9;
				}
				break;
			case 5:
				if(v507) {
					bs507 |= 4;
				} else {
					bs507 &= -5;
				}
				break;
			case 6:
				if(v507) {
					bs507 |= 2;
				} else {
					bs507 &= -3;
				}
				break;
			case 7:
				if(v507) {
					bs507 |= 1;
				} else {
					bs507 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs507;
		var this509 = 0;
		var bs508 = this509;
		var l508 = "*   *".length;
		var _g1508 = 0;
		var _g608 = l508;
		while(_g1508 < _g608) {
			var i508 = _g1508++;
			var no508 = "*   *".charCodeAt(i508);
			if(no508 == null) {
				break;
			}
			var v508;
			switch(no508) {
			case 32:
				v508 = false;
				break;
			case 42:
				v508 = true;
				break;
			case 48:
				v508 = false;
				break;
			case 49:
				v508 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i508)));
			}
			switch(i508 - (l508 - 8)) {
			case 0:
				if(v508) {
					bs508 |= 128;
				} else {
					bs508 &= -129;
				}
				break;
			case 1:
				if(v508) {
					bs508 |= 64;
				} else {
					bs508 &= -65;
				}
				break;
			case 2:
				if(v508) {
					bs508 |= 32;
				} else {
					bs508 &= -33;
				}
				break;
			case 3:
				if(v508) {
					bs508 |= 16;
				} else {
					bs508 &= -17;
				}
				break;
			case 4:
				if(v508) {
					bs508 |= 8;
				} else {
					bs508 &= -9;
				}
				break;
			case 5:
				if(v508) {
					bs508 |= 4;
				} else {
					bs508 &= -5;
				}
				break;
			case 6:
				if(v508) {
					bs508 |= 2;
				} else {
					bs508 &= -3;
				}
				break;
			case 7:
				if(v508) {
					bs508 |= 1;
				} else {
					bs508 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs508;
		var this510 = 0;
		var bs509 = this510;
		var l509 = "*   *".length;
		var _g1509 = 0;
		var _g609 = l509;
		while(_g1509 < _g609) {
			var i509 = _g1509++;
			var no509 = "*   *".charCodeAt(i509);
			if(no509 == null) {
				break;
			}
			var v509;
			switch(no509) {
			case 32:
				v509 = false;
				break;
			case 42:
				v509 = true;
				break;
			case 48:
				v509 = false;
				break;
			case 49:
				v509 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i509)));
			}
			switch(i509 - (l509 - 8)) {
			case 0:
				if(v509) {
					bs509 |= 128;
				} else {
					bs509 &= -129;
				}
				break;
			case 1:
				if(v509) {
					bs509 |= 64;
				} else {
					bs509 &= -65;
				}
				break;
			case 2:
				if(v509) {
					bs509 |= 32;
				} else {
					bs509 &= -33;
				}
				break;
			case 3:
				if(v509) {
					bs509 |= 16;
				} else {
					bs509 &= -17;
				}
				break;
			case 4:
				if(v509) {
					bs509 |= 8;
				} else {
					bs509 &= -9;
				}
				break;
			case 5:
				if(v509) {
					bs509 |= 4;
				} else {
					bs509 &= -5;
				}
				break;
			case 6:
				if(v509) {
					bs509 |= 2;
				} else {
					bs509 &= -3;
				}
				break;
			case 7:
				if(v509) {
					bs509 |= 1;
				} else {
					bs509 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs509;
		var this511 = 0;
		var bs510 = this511;
		var l510 = "*   *".length;
		var _g1510 = 0;
		var _g610 = l510;
		while(_g1510 < _g610) {
			var i510 = _g1510++;
			var no510 = "*   *".charCodeAt(i510);
			if(no510 == null) {
				break;
			}
			var v510;
			switch(no510) {
			case 32:
				v510 = false;
				break;
			case 42:
				v510 = true;
				break;
			case 48:
				v510 = false;
				break;
			case 49:
				v510 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i510)));
			}
			switch(i510 - (l510 - 8)) {
			case 0:
				if(v510) {
					bs510 |= 128;
				} else {
					bs510 &= -129;
				}
				break;
			case 1:
				if(v510) {
					bs510 |= 64;
				} else {
					bs510 &= -65;
				}
				break;
			case 2:
				if(v510) {
					bs510 |= 32;
				} else {
					bs510 &= -33;
				}
				break;
			case 3:
				if(v510) {
					bs510 |= 16;
				} else {
					bs510 &= -17;
				}
				break;
			case 4:
				if(v510) {
					bs510 |= 8;
				} else {
					bs510 &= -9;
				}
				break;
			case 5:
				if(v510) {
					bs510 |= 4;
				} else {
					bs510 &= -5;
				}
				break;
			case 6:
				if(v510) {
					bs510 |= 2;
				} else {
					bs510 &= -3;
				}
				break;
			case 7:
				if(v510) {
					bs510 |= 1;
				} else {
					bs510 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs510;
		break;
	case 105:
		var this512 = 0;
		var bs511 = this512;
		var l511 = "  *  ".length;
		var _g1511 = 0;
		var _g611 = l511;
		while(_g1511 < _g611) {
			var i511 = _g1511++;
			var no511 = "  *  ".charCodeAt(i511);
			if(no511 == null) {
				break;
			}
			var v511;
			switch(no511) {
			case 32:
				v511 = false;
				break;
			case 42:
				v511 = true;
				break;
			case 48:
				v511 = false;
				break;
			case 49:
				v511 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i511)));
			}
			switch(i511 - (l511 - 8)) {
			case 0:
				if(v511) {
					bs511 |= 128;
				} else {
					bs511 &= -129;
				}
				break;
			case 1:
				if(v511) {
					bs511 |= 64;
				} else {
					bs511 &= -65;
				}
				break;
			case 2:
				if(v511) {
					bs511 |= 32;
				} else {
					bs511 &= -33;
				}
				break;
			case 3:
				if(v511) {
					bs511 |= 16;
				} else {
					bs511 &= -17;
				}
				break;
			case 4:
				if(v511) {
					bs511 |= 8;
				} else {
					bs511 &= -9;
				}
				break;
			case 5:
				if(v511) {
					bs511 |= 4;
				} else {
					bs511 &= -5;
				}
				break;
			case 6:
				if(v511) {
					bs511 |= 2;
				} else {
					bs511 &= -3;
				}
				break;
			case 7:
				if(v511) {
					bs511 |= 1;
				} else {
					bs511 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs511;
		var this513 = 0;
		var bs512 = this513;
		var l512 = "     ".length;
		var _g1512 = 0;
		var _g612 = l512;
		while(_g1512 < _g612) {
			var i512 = _g1512++;
			var no512 = "     ".charCodeAt(i512);
			if(no512 == null) {
				break;
			}
			var v512;
			switch(no512) {
			case 32:
				v512 = false;
				break;
			case 42:
				v512 = true;
				break;
			case 48:
				v512 = false;
				break;
			case 49:
				v512 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i512)));
			}
			switch(i512 - (l512 - 8)) {
			case 0:
				if(v512) {
					bs512 |= 128;
				} else {
					bs512 &= -129;
				}
				break;
			case 1:
				if(v512) {
					bs512 |= 64;
				} else {
					bs512 &= -65;
				}
				break;
			case 2:
				if(v512) {
					bs512 |= 32;
				} else {
					bs512 &= -33;
				}
				break;
			case 3:
				if(v512) {
					bs512 |= 16;
				} else {
					bs512 &= -17;
				}
				break;
			case 4:
				if(v512) {
					bs512 |= 8;
				} else {
					bs512 &= -9;
				}
				break;
			case 5:
				if(v512) {
					bs512 |= 4;
				} else {
					bs512 &= -5;
				}
				break;
			case 6:
				if(v512) {
					bs512 |= 2;
				} else {
					bs512 &= -3;
				}
				break;
			case 7:
				if(v512) {
					bs512 |= 1;
				} else {
					bs512 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs512;
		var this514 = 0;
		var bs513 = this514;
		var l513 = " **  ".length;
		var _g1513 = 0;
		var _g613 = l513;
		while(_g1513 < _g613) {
			var i513 = _g1513++;
			var no513 = " **  ".charCodeAt(i513);
			if(no513 == null) {
				break;
			}
			var v513;
			switch(no513) {
			case 32:
				v513 = false;
				break;
			case 42:
				v513 = true;
				break;
			case 48:
				v513 = false;
				break;
			case 49:
				v513 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i513)));
			}
			switch(i513 - (l513 - 8)) {
			case 0:
				if(v513) {
					bs513 |= 128;
				} else {
					bs513 &= -129;
				}
				break;
			case 1:
				if(v513) {
					bs513 |= 64;
				} else {
					bs513 &= -65;
				}
				break;
			case 2:
				if(v513) {
					bs513 |= 32;
				} else {
					bs513 &= -33;
				}
				break;
			case 3:
				if(v513) {
					bs513 |= 16;
				} else {
					bs513 &= -17;
				}
				break;
			case 4:
				if(v513) {
					bs513 |= 8;
				} else {
					bs513 &= -9;
				}
				break;
			case 5:
				if(v513) {
					bs513 |= 4;
				} else {
					bs513 &= -5;
				}
				break;
			case 6:
				if(v513) {
					bs513 |= 2;
				} else {
					bs513 &= -3;
				}
				break;
			case 7:
				if(v513) {
					bs513 |= 1;
				} else {
					bs513 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs513;
		var this515 = 0;
		var bs514 = this515;
		var l514 = "  *  ".length;
		var _g1514 = 0;
		var _g614 = l514;
		while(_g1514 < _g614) {
			var i514 = _g1514++;
			var no514 = "  *  ".charCodeAt(i514);
			if(no514 == null) {
				break;
			}
			var v514;
			switch(no514) {
			case 32:
				v514 = false;
				break;
			case 42:
				v514 = true;
				break;
			case 48:
				v514 = false;
				break;
			case 49:
				v514 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i514)));
			}
			switch(i514 - (l514 - 8)) {
			case 0:
				if(v514) {
					bs514 |= 128;
				} else {
					bs514 &= -129;
				}
				break;
			case 1:
				if(v514) {
					bs514 |= 64;
				} else {
					bs514 &= -65;
				}
				break;
			case 2:
				if(v514) {
					bs514 |= 32;
				} else {
					bs514 &= -33;
				}
				break;
			case 3:
				if(v514) {
					bs514 |= 16;
				} else {
					bs514 &= -17;
				}
				break;
			case 4:
				if(v514) {
					bs514 |= 8;
				} else {
					bs514 &= -9;
				}
				break;
			case 5:
				if(v514) {
					bs514 |= 4;
				} else {
					bs514 &= -5;
				}
				break;
			case 6:
				if(v514) {
					bs514 |= 2;
				} else {
					bs514 &= -3;
				}
				break;
			case 7:
				if(v514) {
					bs514 |= 1;
				} else {
					bs514 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs514;
		var this516 = 0;
		var bs515 = this516;
		var l515 = "  *  ".length;
		var _g1515 = 0;
		var _g615 = l515;
		while(_g1515 < _g615) {
			var i515 = _g1515++;
			var no515 = "  *  ".charCodeAt(i515);
			if(no515 == null) {
				break;
			}
			var v515;
			switch(no515) {
			case 32:
				v515 = false;
				break;
			case 42:
				v515 = true;
				break;
			case 48:
				v515 = false;
				break;
			case 49:
				v515 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i515)));
			}
			switch(i515 - (l515 - 8)) {
			case 0:
				if(v515) {
					bs515 |= 128;
				} else {
					bs515 &= -129;
				}
				break;
			case 1:
				if(v515) {
					bs515 |= 64;
				} else {
					bs515 &= -65;
				}
				break;
			case 2:
				if(v515) {
					bs515 |= 32;
				} else {
					bs515 &= -33;
				}
				break;
			case 3:
				if(v515) {
					bs515 |= 16;
				} else {
					bs515 &= -17;
				}
				break;
			case 4:
				if(v515) {
					bs515 |= 8;
				} else {
					bs515 &= -9;
				}
				break;
			case 5:
				if(v515) {
					bs515 |= 4;
				} else {
					bs515 &= -5;
				}
				break;
			case 6:
				if(v515) {
					bs515 |= 2;
				} else {
					bs515 &= -3;
				}
				break;
			case 7:
				if(v515) {
					bs515 |= 1;
				} else {
					bs515 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs515;
		var this517 = 0;
		var bs516 = this517;
		var l516 = "  *  ".length;
		var _g1516 = 0;
		var _g616 = l516;
		while(_g1516 < _g616) {
			var i516 = _g1516++;
			var no516 = "  *  ".charCodeAt(i516);
			if(no516 == null) {
				break;
			}
			var v516;
			switch(no516) {
			case 32:
				v516 = false;
				break;
			case 42:
				v516 = true;
				break;
			case 48:
				v516 = false;
				break;
			case 49:
				v516 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i516)));
			}
			switch(i516 - (l516 - 8)) {
			case 0:
				if(v516) {
					bs516 |= 128;
				} else {
					bs516 &= -129;
				}
				break;
			case 1:
				if(v516) {
					bs516 |= 64;
				} else {
					bs516 &= -65;
				}
				break;
			case 2:
				if(v516) {
					bs516 |= 32;
				} else {
					bs516 &= -33;
				}
				break;
			case 3:
				if(v516) {
					bs516 |= 16;
				} else {
					bs516 &= -17;
				}
				break;
			case 4:
				if(v516) {
					bs516 |= 8;
				} else {
					bs516 &= -9;
				}
				break;
			case 5:
				if(v516) {
					bs516 |= 4;
				} else {
					bs516 &= -5;
				}
				break;
			case 6:
				if(v516) {
					bs516 |= 2;
				} else {
					bs516 &= -3;
				}
				break;
			case 7:
				if(v516) {
					bs516 |= 1;
				} else {
					bs516 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs516;
		var this518 = 0;
		var bs517 = this518;
		var l517 = " *** ".length;
		var _g1517 = 0;
		var _g617 = l517;
		while(_g1517 < _g617) {
			var i517 = _g1517++;
			var no517 = " *** ".charCodeAt(i517);
			if(no517 == null) {
				break;
			}
			var v517;
			switch(no517) {
			case 32:
				v517 = false;
				break;
			case 42:
				v517 = true;
				break;
			case 48:
				v517 = false;
				break;
			case 49:
				v517 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i517)));
			}
			switch(i517 - (l517 - 8)) {
			case 0:
				if(v517) {
					bs517 |= 128;
				} else {
					bs517 &= -129;
				}
				break;
			case 1:
				if(v517) {
					bs517 |= 64;
				} else {
					bs517 &= -65;
				}
				break;
			case 2:
				if(v517) {
					bs517 |= 32;
				} else {
					bs517 &= -33;
				}
				break;
			case 3:
				if(v517) {
					bs517 |= 16;
				} else {
					bs517 &= -17;
				}
				break;
			case 4:
				if(v517) {
					bs517 |= 8;
				} else {
					bs517 &= -9;
				}
				break;
			case 5:
				if(v517) {
					bs517 |= 4;
				} else {
					bs517 &= -5;
				}
				break;
			case 6:
				if(v517) {
					bs517 |= 2;
				} else {
					bs517 &= -3;
				}
				break;
			case 7:
				if(v517) {
					bs517 |= 1;
				} else {
					bs517 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs517;
		break;
	case 106:
		var this519 = 0;
		var bs518 = this519;
		var l518 = "   * ".length;
		var _g1518 = 0;
		var _g618 = l518;
		while(_g1518 < _g618) {
			var i518 = _g1518++;
			var no518 = "   * ".charCodeAt(i518);
			if(no518 == null) {
				break;
			}
			var v518;
			switch(no518) {
			case 32:
				v518 = false;
				break;
			case 42:
				v518 = true;
				break;
			case 48:
				v518 = false;
				break;
			case 49:
				v518 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i518)));
			}
			switch(i518 - (l518 - 8)) {
			case 0:
				if(v518) {
					bs518 |= 128;
				} else {
					bs518 &= -129;
				}
				break;
			case 1:
				if(v518) {
					bs518 |= 64;
				} else {
					bs518 &= -65;
				}
				break;
			case 2:
				if(v518) {
					bs518 |= 32;
				} else {
					bs518 &= -33;
				}
				break;
			case 3:
				if(v518) {
					bs518 |= 16;
				} else {
					bs518 &= -17;
				}
				break;
			case 4:
				if(v518) {
					bs518 |= 8;
				} else {
					bs518 &= -9;
				}
				break;
			case 5:
				if(v518) {
					bs518 |= 4;
				} else {
					bs518 &= -5;
				}
				break;
			case 6:
				if(v518) {
					bs518 |= 2;
				} else {
					bs518 &= -3;
				}
				break;
			case 7:
				if(v518) {
					bs518 |= 1;
				} else {
					bs518 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs518;
		var this520 = 0;
		var bs519 = this520;
		var l519 = "     ".length;
		var _g1519 = 0;
		var _g619 = l519;
		while(_g1519 < _g619) {
			var i519 = _g1519++;
			var no519 = "     ".charCodeAt(i519);
			if(no519 == null) {
				break;
			}
			var v519;
			switch(no519) {
			case 32:
				v519 = false;
				break;
			case 42:
				v519 = true;
				break;
			case 48:
				v519 = false;
				break;
			case 49:
				v519 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i519)));
			}
			switch(i519 - (l519 - 8)) {
			case 0:
				if(v519) {
					bs519 |= 128;
				} else {
					bs519 &= -129;
				}
				break;
			case 1:
				if(v519) {
					bs519 |= 64;
				} else {
					bs519 &= -65;
				}
				break;
			case 2:
				if(v519) {
					bs519 |= 32;
				} else {
					bs519 &= -33;
				}
				break;
			case 3:
				if(v519) {
					bs519 |= 16;
				} else {
					bs519 &= -17;
				}
				break;
			case 4:
				if(v519) {
					bs519 |= 8;
				} else {
					bs519 &= -9;
				}
				break;
			case 5:
				if(v519) {
					bs519 |= 4;
				} else {
					bs519 &= -5;
				}
				break;
			case 6:
				if(v519) {
					bs519 |= 2;
				} else {
					bs519 &= -3;
				}
				break;
			case 7:
				if(v519) {
					bs519 |= 1;
				} else {
					bs519 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs519;
		var this521 = 0;
		var bs520 = this521;
		var l520 = "  ** ".length;
		var _g1520 = 0;
		var _g620 = l520;
		while(_g1520 < _g620) {
			var i520 = _g1520++;
			var no520 = "  ** ".charCodeAt(i520);
			if(no520 == null) {
				break;
			}
			var v520;
			switch(no520) {
			case 32:
				v520 = false;
				break;
			case 42:
				v520 = true;
				break;
			case 48:
				v520 = false;
				break;
			case 49:
				v520 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i520)));
			}
			switch(i520 - (l520 - 8)) {
			case 0:
				if(v520) {
					bs520 |= 128;
				} else {
					bs520 &= -129;
				}
				break;
			case 1:
				if(v520) {
					bs520 |= 64;
				} else {
					bs520 &= -65;
				}
				break;
			case 2:
				if(v520) {
					bs520 |= 32;
				} else {
					bs520 &= -33;
				}
				break;
			case 3:
				if(v520) {
					bs520 |= 16;
				} else {
					bs520 &= -17;
				}
				break;
			case 4:
				if(v520) {
					bs520 |= 8;
				} else {
					bs520 &= -9;
				}
				break;
			case 5:
				if(v520) {
					bs520 |= 4;
				} else {
					bs520 &= -5;
				}
				break;
			case 6:
				if(v520) {
					bs520 |= 2;
				} else {
					bs520 &= -3;
				}
				break;
			case 7:
				if(v520) {
					bs520 |= 1;
				} else {
					bs520 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs520;
		var this522 = 0;
		var bs521 = this522;
		var l521 = "   * ".length;
		var _g1521 = 0;
		var _g621 = l521;
		while(_g1521 < _g621) {
			var i521 = _g1521++;
			var no521 = "   * ".charCodeAt(i521);
			if(no521 == null) {
				break;
			}
			var v521;
			switch(no521) {
			case 32:
				v521 = false;
				break;
			case 42:
				v521 = true;
				break;
			case 48:
				v521 = false;
				break;
			case 49:
				v521 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i521)));
			}
			switch(i521 - (l521 - 8)) {
			case 0:
				if(v521) {
					bs521 |= 128;
				} else {
					bs521 &= -129;
				}
				break;
			case 1:
				if(v521) {
					bs521 |= 64;
				} else {
					bs521 &= -65;
				}
				break;
			case 2:
				if(v521) {
					bs521 |= 32;
				} else {
					bs521 &= -33;
				}
				break;
			case 3:
				if(v521) {
					bs521 |= 16;
				} else {
					bs521 &= -17;
				}
				break;
			case 4:
				if(v521) {
					bs521 |= 8;
				} else {
					bs521 &= -9;
				}
				break;
			case 5:
				if(v521) {
					bs521 |= 4;
				} else {
					bs521 &= -5;
				}
				break;
			case 6:
				if(v521) {
					bs521 |= 2;
				} else {
					bs521 &= -3;
				}
				break;
			case 7:
				if(v521) {
					bs521 |= 1;
				} else {
					bs521 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs521;
		var this523 = 0;
		var bs522 = this523;
		var l522 = "   * ".length;
		var _g1522 = 0;
		var _g622 = l522;
		while(_g1522 < _g622) {
			var i522 = _g1522++;
			var no522 = "   * ".charCodeAt(i522);
			if(no522 == null) {
				break;
			}
			var v522;
			switch(no522) {
			case 32:
				v522 = false;
				break;
			case 42:
				v522 = true;
				break;
			case 48:
				v522 = false;
				break;
			case 49:
				v522 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i522)));
			}
			switch(i522 - (l522 - 8)) {
			case 0:
				if(v522) {
					bs522 |= 128;
				} else {
					bs522 &= -129;
				}
				break;
			case 1:
				if(v522) {
					bs522 |= 64;
				} else {
					bs522 &= -65;
				}
				break;
			case 2:
				if(v522) {
					bs522 |= 32;
				} else {
					bs522 &= -33;
				}
				break;
			case 3:
				if(v522) {
					bs522 |= 16;
				} else {
					bs522 &= -17;
				}
				break;
			case 4:
				if(v522) {
					bs522 |= 8;
				} else {
					bs522 &= -9;
				}
				break;
			case 5:
				if(v522) {
					bs522 |= 4;
				} else {
					bs522 &= -5;
				}
				break;
			case 6:
				if(v522) {
					bs522 |= 2;
				} else {
					bs522 &= -3;
				}
				break;
			case 7:
				if(v522) {
					bs522 |= 1;
				} else {
					bs522 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs522;
		var this524 = 0;
		var bs523 = this524;
		var l523 = "*  * ".length;
		var _g1523 = 0;
		var _g623 = l523;
		while(_g1523 < _g623) {
			var i523 = _g1523++;
			var no523 = "*  * ".charCodeAt(i523);
			if(no523 == null) {
				break;
			}
			var v523;
			switch(no523) {
			case 32:
				v523 = false;
				break;
			case 42:
				v523 = true;
				break;
			case 48:
				v523 = false;
				break;
			case 49:
				v523 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i523)));
			}
			switch(i523 - (l523 - 8)) {
			case 0:
				if(v523) {
					bs523 |= 128;
				} else {
					bs523 &= -129;
				}
				break;
			case 1:
				if(v523) {
					bs523 |= 64;
				} else {
					bs523 &= -65;
				}
				break;
			case 2:
				if(v523) {
					bs523 |= 32;
				} else {
					bs523 &= -33;
				}
				break;
			case 3:
				if(v523) {
					bs523 |= 16;
				} else {
					bs523 &= -17;
				}
				break;
			case 4:
				if(v523) {
					bs523 |= 8;
				} else {
					bs523 &= -9;
				}
				break;
			case 5:
				if(v523) {
					bs523 |= 4;
				} else {
					bs523 &= -5;
				}
				break;
			case 6:
				if(v523) {
					bs523 |= 2;
				} else {
					bs523 &= -3;
				}
				break;
			case 7:
				if(v523) {
					bs523 |= 1;
				} else {
					bs523 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs523;
		var this525 = 0;
		var bs524 = this525;
		var l524 = " **  ".length;
		var _g1524 = 0;
		var _g624 = l524;
		while(_g1524 < _g624) {
			var i524 = _g1524++;
			var no524 = " **  ".charCodeAt(i524);
			if(no524 == null) {
				break;
			}
			var v524;
			switch(no524) {
			case 32:
				v524 = false;
				break;
			case 42:
				v524 = true;
				break;
			case 48:
				v524 = false;
				break;
			case 49:
				v524 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i524)));
			}
			switch(i524 - (l524 - 8)) {
			case 0:
				if(v524) {
					bs524 |= 128;
				} else {
					bs524 &= -129;
				}
				break;
			case 1:
				if(v524) {
					bs524 |= 64;
				} else {
					bs524 &= -65;
				}
				break;
			case 2:
				if(v524) {
					bs524 |= 32;
				} else {
					bs524 &= -33;
				}
				break;
			case 3:
				if(v524) {
					bs524 |= 16;
				} else {
					bs524 &= -17;
				}
				break;
			case 4:
				if(v524) {
					bs524 |= 8;
				} else {
					bs524 &= -9;
				}
				break;
			case 5:
				if(v524) {
					bs524 |= 4;
				} else {
					bs524 &= -5;
				}
				break;
			case 6:
				if(v524) {
					bs524 |= 2;
				} else {
					bs524 &= -3;
				}
				break;
			case 7:
				if(v524) {
					bs524 |= 1;
				} else {
					bs524 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs524;
		break;
	case 107:
		var this526 = 0;
		var bs525 = this526;
		var l525 = "*    ".length;
		var _g1525 = 0;
		var _g625 = l525;
		while(_g1525 < _g625) {
			var i525 = _g1525++;
			var no525 = "*    ".charCodeAt(i525);
			if(no525 == null) {
				break;
			}
			var v525;
			switch(no525) {
			case 32:
				v525 = false;
				break;
			case 42:
				v525 = true;
				break;
			case 48:
				v525 = false;
				break;
			case 49:
				v525 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i525)));
			}
			switch(i525 - (l525 - 8)) {
			case 0:
				if(v525) {
					bs525 |= 128;
				} else {
					bs525 &= -129;
				}
				break;
			case 1:
				if(v525) {
					bs525 |= 64;
				} else {
					bs525 &= -65;
				}
				break;
			case 2:
				if(v525) {
					bs525 |= 32;
				} else {
					bs525 &= -33;
				}
				break;
			case 3:
				if(v525) {
					bs525 |= 16;
				} else {
					bs525 &= -17;
				}
				break;
			case 4:
				if(v525) {
					bs525 |= 8;
				} else {
					bs525 &= -9;
				}
				break;
			case 5:
				if(v525) {
					bs525 |= 4;
				} else {
					bs525 &= -5;
				}
				break;
			case 6:
				if(v525) {
					bs525 |= 2;
				} else {
					bs525 &= -3;
				}
				break;
			case 7:
				if(v525) {
					bs525 |= 1;
				} else {
					bs525 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs525;
		var this527 = 0;
		var bs526 = this527;
		var l526 = "*    ".length;
		var _g1526 = 0;
		var _g626 = l526;
		while(_g1526 < _g626) {
			var i526 = _g1526++;
			var no526 = "*    ".charCodeAt(i526);
			if(no526 == null) {
				break;
			}
			var v526;
			switch(no526) {
			case 32:
				v526 = false;
				break;
			case 42:
				v526 = true;
				break;
			case 48:
				v526 = false;
				break;
			case 49:
				v526 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i526)));
			}
			switch(i526 - (l526 - 8)) {
			case 0:
				if(v526) {
					bs526 |= 128;
				} else {
					bs526 &= -129;
				}
				break;
			case 1:
				if(v526) {
					bs526 |= 64;
				} else {
					bs526 &= -65;
				}
				break;
			case 2:
				if(v526) {
					bs526 |= 32;
				} else {
					bs526 &= -33;
				}
				break;
			case 3:
				if(v526) {
					bs526 |= 16;
				} else {
					bs526 &= -17;
				}
				break;
			case 4:
				if(v526) {
					bs526 |= 8;
				} else {
					bs526 &= -9;
				}
				break;
			case 5:
				if(v526) {
					bs526 |= 4;
				} else {
					bs526 &= -5;
				}
				break;
			case 6:
				if(v526) {
					bs526 |= 2;
				} else {
					bs526 &= -3;
				}
				break;
			case 7:
				if(v526) {
					bs526 |= 1;
				} else {
					bs526 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs526;
		var this528 = 0;
		var bs527 = this528;
		var l527 = "*  * ".length;
		var _g1527 = 0;
		var _g627 = l527;
		while(_g1527 < _g627) {
			var i527 = _g1527++;
			var no527 = "*  * ".charCodeAt(i527);
			if(no527 == null) {
				break;
			}
			var v527;
			switch(no527) {
			case 32:
				v527 = false;
				break;
			case 42:
				v527 = true;
				break;
			case 48:
				v527 = false;
				break;
			case 49:
				v527 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i527)));
			}
			switch(i527 - (l527 - 8)) {
			case 0:
				if(v527) {
					bs527 |= 128;
				} else {
					bs527 &= -129;
				}
				break;
			case 1:
				if(v527) {
					bs527 |= 64;
				} else {
					bs527 &= -65;
				}
				break;
			case 2:
				if(v527) {
					bs527 |= 32;
				} else {
					bs527 &= -33;
				}
				break;
			case 3:
				if(v527) {
					bs527 |= 16;
				} else {
					bs527 &= -17;
				}
				break;
			case 4:
				if(v527) {
					bs527 |= 8;
				} else {
					bs527 &= -9;
				}
				break;
			case 5:
				if(v527) {
					bs527 |= 4;
				} else {
					bs527 &= -5;
				}
				break;
			case 6:
				if(v527) {
					bs527 |= 2;
				} else {
					bs527 &= -3;
				}
				break;
			case 7:
				if(v527) {
					bs527 |= 1;
				} else {
					bs527 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs527;
		var this529 = 0;
		var bs528 = this529;
		var l528 = "* *  ".length;
		var _g1528 = 0;
		var _g628 = l528;
		while(_g1528 < _g628) {
			var i528 = _g1528++;
			var no528 = "* *  ".charCodeAt(i528);
			if(no528 == null) {
				break;
			}
			var v528;
			switch(no528) {
			case 32:
				v528 = false;
				break;
			case 42:
				v528 = true;
				break;
			case 48:
				v528 = false;
				break;
			case 49:
				v528 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i528)));
			}
			switch(i528 - (l528 - 8)) {
			case 0:
				if(v528) {
					bs528 |= 128;
				} else {
					bs528 &= -129;
				}
				break;
			case 1:
				if(v528) {
					bs528 |= 64;
				} else {
					bs528 &= -65;
				}
				break;
			case 2:
				if(v528) {
					bs528 |= 32;
				} else {
					bs528 &= -33;
				}
				break;
			case 3:
				if(v528) {
					bs528 |= 16;
				} else {
					bs528 &= -17;
				}
				break;
			case 4:
				if(v528) {
					bs528 |= 8;
				} else {
					bs528 &= -9;
				}
				break;
			case 5:
				if(v528) {
					bs528 |= 4;
				} else {
					bs528 &= -5;
				}
				break;
			case 6:
				if(v528) {
					bs528 |= 2;
				} else {
					bs528 &= -3;
				}
				break;
			case 7:
				if(v528) {
					bs528 |= 1;
				} else {
					bs528 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs528;
		var this530 = 0;
		var bs529 = this530;
		var l529 = "**   ".length;
		var _g1529 = 0;
		var _g629 = l529;
		while(_g1529 < _g629) {
			var i529 = _g1529++;
			var no529 = "**   ".charCodeAt(i529);
			if(no529 == null) {
				break;
			}
			var v529;
			switch(no529) {
			case 32:
				v529 = false;
				break;
			case 42:
				v529 = true;
				break;
			case 48:
				v529 = false;
				break;
			case 49:
				v529 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**   ".charCodeAt(i529)));
			}
			switch(i529 - (l529 - 8)) {
			case 0:
				if(v529) {
					bs529 |= 128;
				} else {
					bs529 &= -129;
				}
				break;
			case 1:
				if(v529) {
					bs529 |= 64;
				} else {
					bs529 &= -65;
				}
				break;
			case 2:
				if(v529) {
					bs529 |= 32;
				} else {
					bs529 &= -33;
				}
				break;
			case 3:
				if(v529) {
					bs529 |= 16;
				} else {
					bs529 &= -17;
				}
				break;
			case 4:
				if(v529) {
					bs529 |= 8;
				} else {
					bs529 &= -9;
				}
				break;
			case 5:
				if(v529) {
					bs529 |= 4;
				} else {
					bs529 &= -5;
				}
				break;
			case 6:
				if(v529) {
					bs529 |= 2;
				} else {
					bs529 &= -3;
				}
				break;
			case 7:
				if(v529) {
					bs529 |= 1;
				} else {
					bs529 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs529;
		var this531 = 0;
		var bs530 = this531;
		var l530 = "* *  ".length;
		var _g1530 = 0;
		var _g630 = l530;
		while(_g1530 < _g630) {
			var i530 = _g1530++;
			var no530 = "* *  ".charCodeAt(i530);
			if(no530 == null) {
				break;
			}
			var v530;
			switch(no530) {
			case 32:
				v530 = false;
				break;
			case 42:
				v530 = true;
				break;
			case 48:
				v530 = false;
				break;
			case 49:
				v530 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* *  ".charCodeAt(i530)));
			}
			switch(i530 - (l530 - 8)) {
			case 0:
				if(v530) {
					bs530 |= 128;
				} else {
					bs530 &= -129;
				}
				break;
			case 1:
				if(v530) {
					bs530 |= 64;
				} else {
					bs530 &= -65;
				}
				break;
			case 2:
				if(v530) {
					bs530 |= 32;
				} else {
					bs530 &= -33;
				}
				break;
			case 3:
				if(v530) {
					bs530 |= 16;
				} else {
					bs530 &= -17;
				}
				break;
			case 4:
				if(v530) {
					bs530 |= 8;
				} else {
					bs530 &= -9;
				}
				break;
			case 5:
				if(v530) {
					bs530 |= 4;
				} else {
					bs530 &= -5;
				}
				break;
			case 6:
				if(v530) {
					bs530 |= 2;
				} else {
					bs530 &= -3;
				}
				break;
			case 7:
				if(v530) {
					bs530 |= 1;
				} else {
					bs530 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs530;
		var this532 = 0;
		var bs531 = this532;
		var l531 = "*   *".length;
		var _g1531 = 0;
		var _g631 = l531;
		while(_g1531 < _g631) {
			var i531 = _g1531++;
			var no531 = "*   *".charCodeAt(i531);
			if(no531 == null) {
				break;
			}
			var v531;
			switch(no531) {
			case 32:
				v531 = false;
				break;
			case 42:
				v531 = true;
				break;
			case 48:
				v531 = false;
				break;
			case 49:
				v531 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i531)));
			}
			switch(i531 - (l531 - 8)) {
			case 0:
				if(v531) {
					bs531 |= 128;
				} else {
					bs531 &= -129;
				}
				break;
			case 1:
				if(v531) {
					bs531 |= 64;
				} else {
					bs531 &= -65;
				}
				break;
			case 2:
				if(v531) {
					bs531 |= 32;
				} else {
					bs531 &= -33;
				}
				break;
			case 3:
				if(v531) {
					bs531 |= 16;
				} else {
					bs531 &= -17;
				}
				break;
			case 4:
				if(v531) {
					bs531 |= 8;
				} else {
					bs531 &= -9;
				}
				break;
			case 5:
				if(v531) {
					bs531 |= 4;
				} else {
					bs531 &= -5;
				}
				break;
			case 6:
				if(v531) {
					bs531 |= 2;
				} else {
					bs531 &= -3;
				}
				break;
			case 7:
				if(v531) {
					bs531 |= 1;
				} else {
					bs531 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs531;
		break;
	case 108:
		var this533 = 0;
		var bs532 = this533;
		var l532 = " **  ".length;
		var _g1532 = 0;
		var _g632 = l532;
		while(_g1532 < _g632) {
			var i532 = _g1532++;
			var no532 = " **  ".charCodeAt(i532);
			if(no532 == null) {
				break;
			}
			var v532;
			switch(no532) {
			case 32:
				v532 = false;
				break;
			case 42:
				v532 = true;
				break;
			case 48:
				v532 = false;
				break;
			case 49:
				v532 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" **  ".charCodeAt(i532)));
			}
			switch(i532 - (l532 - 8)) {
			case 0:
				if(v532) {
					bs532 |= 128;
				} else {
					bs532 &= -129;
				}
				break;
			case 1:
				if(v532) {
					bs532 |= 64;
				} else {
					bs532 &= -65;
				}
				break;
			case 2:
				if(v532) {
					bs532 |= 32;
				} else {
					bs532 &= -33;
				}
				break;
			case 3:
				if(v532) {
					bs532 |= 16;
				} else {
					bs532 &= -17;
				}
				break;
			case 4:
				if(v532) {
					bs532 |= 8;
				} else {
					bs532 &= -9;
				}
				break;
			case 5:
				if(v532) {
					bs532 |= 4;
				} else {
					bs532 &= -5;
				}
				break;
			case 6:
				if(v532) {
					bs532 |= 2;
				} else {
					bs532 &= -3;
				}
				break;
			case 7:
				if(v532) {
					bs532 |= 1;
				} else {
					bs532 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs532;
		var this534 = 0;
		var bs533 = this534;
		var l533 = "  *  ".length;
		var _g1533 = 0;
		var _g633 = l533;
		while(_g1533 < _g633) {
			var i533 = _g1533++;
			var no533 = "  *  ".charCodeAt(i533);
			if(no533 == null) {
				break;
			}
			var v533;
			switch(no533) {
			case 32:
				v533 = false;
				break;
			case 42:
				v533 = true;
				break;
			case 48:
				v533 = false;
				break;
			case 49:
				v533 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i533)));
			}
			switch(i533 - (l533 - 8)) {
			case 0:
				if(v533) {
					bs533 |= 128;
				} else {
					bs533 &= -129;
				}
				break;
			case 1:
				if(v533) {
					bs533 |= 64;
				} else {
					bs533 &= -65;
				}
				break;
			case 2:
				if(v533) {
					bs533 |= 32;
				} else {
					bs533 &= -33;
				}
				break;
			case 3:
				if(v533) {
					bs533 |= 16;
				} else {
					bs533 &= -17;
				}
				break;
			case 4:
				if(v533) {
					bs533 |= 8;
				} else {
					bs533 &= -9;
				}
				break;
			case 5:
				if(v533) {
					bs533 |= 4;
				} else {
					bs533 &= -5;
				}
				break;
			case 6:
				if(v533) {
					bs533 |= 2;
				} else {
					bs533 &= -3;
				}
				break;
			case 7:
				if(v533) {
					bs533 |= 1;
				} else {
					bs533 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs533;
		var this535 = 0;
		var bs534 = this535;
		var l534 = "  *  ".length;
		var _g1534 = 0;
		var _g634 = l534;
		while(_g1534 < _g634) {
			var i534 = _g1534++;
			var no534 = "  *  ".charCodeAt(i534);
			if(no534 == null) {
				break;
			}
			var v534;
			switch(no534) {
			case 32:
				v534 = false;
				break;
			case 42:
				v534 = true;
				break;
			case 48:
				v534 = false;
				break;
			case 49:
				v534 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i534)));
			}
			switch(i534 - (l534 - 8)) {
			case 0:
				if(v534) {
					bs534 |= 128;
				} else {
					bs534 &= -129;
				}
				break;
			case 1:
				if(v534) {
					bs534 |= 64;
				} else {
					bs534 &= -65;
				}
				break;
			case 2:
				if(v534) {
					bs534 |= 32;
				} else {
					bs534 &= -33;
				}
				break;
			case 3:
				if(v534) {
					bs534 |= 16;
				} else {
					bs534 &= -17;
				}
				break;
			case 4:
				if(v534) {
					bs534 |= 8;
				} else {
					bs534 &= -9;
				}
				break;
			case 5:
				if(v534) {
					bs534 |= 4;
				} else {
					bs534 &= -5;
				}
				break;
			case 6:
				if(v534) {
					bs534 |= 2;
				} else {
					bs534 &= -3;
				}
				break;
			case 7:
				if(v534) {
					bs534 |= 1;
				} else {
					bs534 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs534;
		var this536 = 0;
		var bs535 = this536;
		var l535 = "  *  ".length;
		var _g1535 = 0;
		var _g635 = l535;
		while(_g1535 < _g635) {
			var i535 = _g1535++;
			var no535 = "  *  ".charCodeAt(i535);
			if(no535 == null) {
				break;
			}
			var v535;
			switch(no535) {
			case 32:
				v535 = false;
				break;
			case 42:
				v535 = true;
				break;
			case 48:
				v535 = false;
				break;
			case 49:
				v535 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i535)));
			}
			switch(i535 - (l535 - 8)) {
			case 0:
				if(v535) {
					bs535 |= 128;
				} else {
					bs535 &= -129;
				}
				break;
			case 1:
				if(v535) {
					bs535 |= 64;
				} else {
					bs535 &= -65;
				}
				break;
			case 2:
				if(v535) {
					bs535 |= 32;
				} else {
					bs535 &= -33;
				}
				break;
			case 3:
				if(v535) {
					bs535 |= 16;
				} else {
					bs535 &= -17;
				}
				break;
			case 4:
				if(v535) {
					bs535 |= 8;
				} else {
					bs535 &= -9;
				}
				break;
			case 5:
				if(v535) {
					bs535 |= 4;
				} else {
					bs535 &= -5;
				}
				break;
			case 6:
				if(v535) {
					bs535 |= 2;
				} else {
					bs535 &= -3;
				}
				break;
			case 7:
				if(v535) {
					bs535 |= 1;
				} else {
					bs535 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs535;
		var this537 = 0;
		var bs536 = this537;
		var l536 = "  *  ".length;
		var _g1536 = 0;
		var _g636 = l536;
		while(_g1536 < _g636) {
			var i536 = _g1536++;
			var no536 = "  *  ".charCodeAt(i536);
			if(no536 == null) {
				break;
			}
			var v536;
			switch(no536) {
			case 32:
				v536 = false;
				break;
			case 42:
				v536 = true;
				break;
			case 48:
				v536 = false;
				break;
			case 49:
				v536 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i536)));
			}
			switch(i536 - (l536 - 8)) {
			case 0:
				if(v536) {
					bs536 |= 128;
				} else {
					bs536 &= -129;
				}
				break;
			case 1:
				if(v536) {
					bs536 |= 64;
				} else {
					bs536 &= -65;
				}
				break;
			case 2:
				if(v536) {
					bs536 |= 32;
				} else {
					bs536 &= -33;
				}
				break;
			case 3:
				if(v536) {
					bs536 |= 16;
				} else {
					bs536 &= -17;
				}
				break;
			case 4:
				if(v536) {
					bs536 |= 8;
				} else {
					bs536 &= -9;
				}
				break;
			case 5:
				if(v536) {
					bs536 |= 4;
				} else {
					bs536 &= -5;
				}
				break;
			case 6:
				if(v536) {
					bs536 |= 2;
				} else {
					bs536 &= -3;
				}
				break;
			case 7:
				if(v536) {
					bs536 |= 1;
				} else {
					bs536 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs536;
		var this538 = 0;
		var bs537 = this538;
		var l537 = "  *  ".length;
		var _g1537 = 0;
		var _g637 = l537;
		while(_g1537 < _g637) {
			var i537 = _g1537++;
			var no537 = "  *  ".charCodeAt(i537);
			if(no537 == null) {
				break;
			}
			var v537;
			switch(no537) {
			case 32:
				v537 = false;
				break;
			case 42:
				v537 = true;
				break;
			case 48:
				v537 = false;
				break;
			case 49:
				v537 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i537)));
			}
			switch(i537 - (l537 - 8)) {
			case 0:
				if(v537) {
					bs537 |= 128;
				} else {
					bs537 &= -129;
				}
				break;
			case 1:
				if(v537) {
					bs537 |= 64;
				} else {
					bs537 &= -65;
				}
				break;
			case 2:
				if(v537) {
					bs537 |= 32;
				} else {
					bs537 &= -33;
				}
				break;
			case 3:
				if(v537) {
					bs537 |= 16;
				} else {
					bs537 &= -17;
				}
				break;
			case 4:
				if(v537) {
					bs537 |= 8;
				} else {
					bs537 &= -9;
				}
				break;
			case 5:
				if(v537) {
					bs537 |= 4;
				} else {
					bs537 &= -5;
				}
				break;
			case 6:
				if(v537) {
					bs537 |= 2;
				} else {
					bs537 &= -3;
				}
				break;
			case 7:
				if(v537) {
					bs537 |= 1;
				} else {
					bs537 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs537;
		var this539 = 0;
		var bs538 = this539;
		var l538 = " ***".length;
		var _g1538 = 0;
		var _g638 = l538;
		while(_g1538 < _g638) {
			var i538 = _g1538++;
			var no538 = " ***".charCodeAt(i538);
			if(no538 == null) {
				break;
			}
			var v538;
			switch(no538) {
			case 32:
				v538 = false;
				break;
			case 42:
				v538 = true;
				break;
			case 48:
				v538 = false;
				break;
			case 49:
				v538 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ***".charCodeAt(i538)));
			}
			switch(i538 - (l538 - 8)) {
			case 0:
				if(v538) {
					bs538 |= 128;
				} else {
					bs538 &= -129;
				}
				break;
			case 1:
				if(v538) {
					bs538 |= 64;
				} else {
					bs538 &= -65;
				}
				break;
			case 2:
				if(v538) {
					bs538 |= 32;
				} else {
					bs538 &= -33;
				}
				break;
			case 3:
				if(v538) {
					bs538 |= 16;
				} else {
					bs538 &= -17;
				}
				break;
			case 4:
				if(v538) {
					bs538 |= 8;
				} else {
					bs538 &= -9;
				}
				break;
			case 5:
				if(v538) {
					bs538 |= 4;
				} else {
					bs538 &= -5;
				}
				break;
			case 6:
				if(v538) {
					bs538 |= 2;
				} else {
					bs538 &= -3;
				}
				break;
			case 7:
				if(v538) {
					bs538 |= 1;
				} else {
					bs538 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs538;
		break;
	case 109:
		var this540 = 0;
		var bs539 = this540;
		var l539 = "     ".length;
		var _g1539 = 0;
		var _g639 = l539;
		while(_g1539 < _g639) {
			var i539 = _g1539++;
			var no539 = "     ".charCodeAt(i539);
			if(no539 == null) {
				break;
			}
			var v539;
			switch(no539) {
			case 32:
				v539 = false;
				break;
			case 42:
				v539 = true;
				break;
			case 48:
				v539 = false;
				break;
			case 49:
				v539 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i539)));
			}
			switch(i539 - (l539 - 8)) {
			case 0:
				if(v539) {
					bs539 |= 128;
				} else {
					bs539 &= -129;
				}
				break;
			case 1:
				if(v539) {
					bs539 |= 64;
				} else {
					bs539 &= -65;
				}
				break;
			case 2:
				if(v539) {
					bs539 |= 32;
				} else {
					bs539 &= -33;
				}
				break;
			case 3:
				if(v539) {
					bs539 |= 16;
				} else {
					bs539 &= -17;
				}
				break;
			case 4:
				if(v539) {
					bs539 |= 8;
				} else {
					bs539 &= -9;
				}
				break;
			case 5:
				if(v539) {
					bs539 |= 4;
				} else {
					bs539 &= -5;
				}
				break;
			case 6:
				if(v539) {
					bs539 |= 2;
				} else {
					bs539 &= -3;
				}
				break;
			case 7:
				if(v539) {
					bs539 |= 1;
				} else {
					bs539 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs539;
		var this541 = 0;
		var bs540 = this541;
		var l540 = "     ".length;
		var _g1540 = 0;
		var _g640 = l540;
		while(_g1540 < _g640) {
			var i540 = _g1540++;
			var no540 = "     ".charCodeAt(i540);
			if(no540 == null) {
				break;
			}
			var v540;
			switch(no540) {
			case 32:
				v540 = false;
				break;
			case 42:
				v540 = true;
				break;
			case 48:
				v540 = false;
				break;
			case 49:
				v540 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i540)));
			}
			switch(i540 - (l540 - 8)) {
			case 0:
				if(v540) {
					bs540 |= 128;
				} else {
					bs540 &= -129;
				}
				break;
			case 1:
				if(v540) {
					bs540 |= 64;
				} else {
					bs540 &= -65;
				}
				break;
			case 2:
				if(v540) {
					bs540 |= 32;
				} else {
					bs540 &= -33;
				}
				break;
			case 3:
				if(v540) {
					bs540 |= 16;
				} else {
					bs540 &= -17;
				}
				break;
			case 4:
				if(v540) {
					bs540 |= 8;
				} else {
					bs540 &= -9;
				}
				break;
			case 5:
				if(v540) {
					bs540 |= 4;
				} else {
					bs540 &= -5;
				}
				break;
			case 6:
				if(v540) {
					bs540 |= 2;
				} else {
					bs540 &= -3;
				}
				break;
			case 7:
				if(v540) {
					bs540 |= 1;
				} else {
					bs540 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs540;
		var this542 = 0;
		var bs541 = this542;
		var l541 = "** * ".length;
		var _g1541 = 0;
		var _g641 = l541;
		while(_g1541 < _g641) {
			var i541 = _g1541++;
			var no541 = "** * ".charCodeAt(i541);
			if(no541 == null) {
				break;
			}
			var v541;
			switch(no541) {
			case 32:
				v541 = false;
				break;
			case 42:
				v541 = true;
				break;
			case 48:
				v541 = false;
				break;
			case 49:
				v541 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("** * ".charCodeAt(i541)));
			}
			switch(i541 - (l541 - 8)) {
			case 0:
				if(v541) {
					bs541 |= 128;
				} else {
					bs541 &= -129;
				}
				break;
			case 1:
				if(v541) {
					bs541 |= 64;
				} else {
					bs541 &= -65;
				}
				break;
			case 2:
				if(v541) {
					bs541 |= 32;
				} else {
					bs541 &= -33;
				}
				break;
			case 3:
				if(v541) {
					bs541 |= 16;
				} else {
					bs541 &= -17;
				}
				break;
			case 4:
				if(v541) {
					bs541 |= 8;
				} else {
					bs541 &= -9;
				}
				break;
			case 5:
				if(v541) {
					bs541 |= 4;
				} else {
					bs541 &= -5;
				}
				break;
			case 6:
				if(v541) {
					bs541 |= 2;
				} else {
					bs541 &= -3;
				}
				break;
			case 7:
				if(v541) {
					bs541 |= 1;
				} else {
					bs541 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs541;
		var this543 = 0;
		var bs542 = this543;
		var l542 = "* * *".length;
		var _g1542 = 0;
		var _g642 = l542;
		while(_g1542 < _g642) {
			var i542 = _g1542++;
			var no542 = "* * *".charCodeAt(i542);
			if(no542 == null) {
				break;
			}
			var v542;
			switch(no542) {
			case 32:
				v542 = false;
				break;
			case 42:
				v542 = true;
				break;
			case 48:
				v542 = false;
				break;
			case 49:
				v542 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i542)));
			}
			switch(i542 - (l542 - 8)) {
			case 0:
				if(v542) {
					bs542 |= 128;
				} else {
					bs542 &= -129;
				}
				break;
			case 1:
				if(v542) {
					bs542 |= 64;
				} else {
					bs542 &= -65;
				}
				break;
			case 2:
				if(v542) {
					bs542 |= 32;
				} else {
					bs542 &= -33;
				}
				break;
			case 3:
				if(v542) {
					bs542 |= 16;
				} else {
					bs542 &= -17;
				}
				break;
			case 4:
				if(v542) {
					bs542 |= 8;
				} else {
					bs542 &= -9;
				}
				break;
			case 5:
				if(v542) {
					bs542 |= 4;
				} else {
					bs542 &= -5;
				}
				break;
			case 6:
				if(v542) {
					bs542 |= 2;
				} else {
					bs542 &= -3;
				}
				break;
			case 7:
				if(v542) {
					bs542 |= 1;
				} else {
					bs542 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs542;
		var this544 = 0;
		var bs543 = this544;
		var l543 = "* * *".length;
		var _g1543 = 0;
		var _g643 = l543;
		while(_g1543 < _g643) {
			var i543 = _g1543++;
			var no543 = "* * *".charCodeAt(i543);
			if(no543 == null) {
				break;
			}
			var v543;
			switch(no543) {
			case 32:
				v543 = false;
				break;
			case 42:
				v543 = true;
				break;
			case 48:
				v543 = false;
				break;
			case 49:
				v543 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i543)));
			}
			switch(i543 - (l543 - 8)) {
			case 0:
				if(v543) {
					bs543 |= 128;
				} else {
					bs543 &= -129;
				}
				break;
			case 1:
				if(v543) {
					bs543 |= 64;
				} else {
					bs543 &= -65;
				}
				break;
			case 2:
				if(v543) {
					bs543 |= 32;
				} else {
					bs543 &= -33;
				}
				break;
			case 3:
				if(v543) {
					bs543 |= 16;
				} else {
					bs543 &= -17;
				}
				break;
			case 4:
				if(v543) {
					bs543 |= 8;
				} else {
					bs543 &= -9;
				}
				break;
			case 5:
				if(v543) {
					bs543 |= 4;
				} else {
					bs543 &= -5;
				}
				break;
			case 6:
				if(v543) {
					bs543 |= 2;
				} else {
					bs543 &= -3;
				}
				break;
			case 7:
				if(v543) {
					bs543 |= 1;
				} else {
					bs543 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs543;
		var this545 = 0;
		var bs544 = this545;
		var l544 = "*   *".length;
		var _g1544 = 0;
		var _g644 = l544;
		while(_g1544 < _g644) {
			var i544 = _g1544++;
			var no544 = "*   *".charCodeAt(i544);
			if(no544 == null) {
				break;
			}
			var v544;
			switch(no544) {
			case 32:
				v544 = false;
				break;
			case 42:
				v544 = true;
				break;
			case 48:
				v544 = false;
				break;
			case 49:
				v544 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i544)));
			}
			switch(i544 - (l544 - 8)) {
			case 0:
				if(v544) {
					bs544 |= 128;
				} else {
					bs544 &= -129;
				}
				break;
			case 1:
				if(v544) {
					bs544 |= 64;
				} else {
					bs544 &= -65;
				}
				break;
			case 2:
				if(v544) {
					bs544 |= 32;
				} else {
					bs544 &= -33;
				}
				break;
			case 3:
				if(v544) {
					bs544 |= 16;
				} else {
					bs544 &= -17;
				}
				break;
			case 4:
				if(v544) {
					bs544 |= 8;
				} else {
					bs544 &= -9;
				}
				break;
			case 5:
				if(v544) {
					bs544 |= 4;
				} else {
					bs544 &= -5;
				}
				break;
			case 6:
				if(v544) {
					bs544 |= 2;
				} else {
					bs544 &= -3;
				}
				break;
			case 7:
				if(v544) {
					bs544 |= 1;
				} else {
					bs544 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs544;
		var this546 = 0;
		var bs545 = this546;
		var l545 = "*   *".length;
		var _g1545 = 0;
		var _g645 = l545;
		while(_g1545 < _g645) {
			var i545 = _g1545++;
			var no545 = "*   *".charCodeAt(i545);
			if(no545 == null) {
				break;
			}
			var v545;
			switch(no545) {
			case 32:
				v545 = false;
				break;
			case 42:
				v545 = true;
				break;
			case 48:
				v545 = false;
				break;
			case 49:
				v545 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i545)));
			}
			switch(i545 - (l545 - 8)) {
			case 0:
				if(v545) {
					bs545 |= 128;
				} else {
					bs545 &= -129;
				}
				break;
			case 1:
				if(v545) {
					bs545 |= 64;
				} else {
					bs545 &= -65;
				}
				break;
			case 2:
				if(v545) {
					bs545 |= 32;
				} else {
					bs545 &= -33;
				}
				break;
			case 3:
				if(v545) {
					bs545 |= 16;
				} else {
					bs545 &= -17;
				}
				break;
			case 4:
				if(v545) {
					bs545 |= 8;
				} else {
					bs545 &= -9;
				}
				break;
			case 5:
				if(v545) {
					bs545 |= 4;
				} else {
					bs545 &= -5;
				}
				break;
			case 6:
				if(v545) {
					bs545 |= 2;
				} else {
					bs545 &= -3;
				}
				break;
			case 7:
				if(v545) {
					bs545 |= 1;
				} else {
					bs545 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs545;
		break;
	case 110:
		var this547 = 0;
		var bs546 = this547;
		var l546 = "     ".length;
		var _g1546 = 0;
		var _g646 = l546;
		while(_g1546 < _g646) {
			var i546 = _g1546++;
			var no546 = "     ".charCodeAt(i546);
			if(no546 == null) {
				break;
			}
			var v546;
			switch(no546) {
			case 32:
				v546 = false;
				break;
			case 42:
				v546 = true;
				break;
			case 48:
				v546 = false;
				break;
			case 49:
				v546 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i546)));
			}
			switch(i546 - (l546 - 8)) {
			case 0:
				if(v546) {
					bs546 |= 128;
				} else {
					bs546 &= -129;
				}
				break;
			case 1:
				if(v546) {
					bs546 |= 64;
				} else {
					bs546 &= -65;
				}
				break;
			case 2:
				if(v546) {
					bs546 |= 32;
				} else {
					bs546 &= -33;
				}
				break;
			case 3:
				if(v546) {
					bs546 |= 16;
				} else {
					bs546 &= -17;
				}
				break;
			case 4:
				if(v546) {
					bs546 |= 8;
				} else {
					bs546 &= -9;
				}
				break;
			case 5:
				if(v546) {
					bs546 |= 4;
				} else {
					bs546 &= -5;
				}
				break;
			case 6:
				if(v546) {
					bs546 |= 2;
				} else {
					bs546 &= -3;
				}
				break;
			case 7:
				if(v546) {
					bs546 |= 1;
				} else {
					bs546 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs546;
		var this548 = 0;
		var bs547 = this548;
		var l547 = "     ".length;
		var _g1547 = 0;
		var _g647 = l547;
		while(_g1547 < _g647) {
			var i547 = _g1547++;
			var no547 = "     ".charCodeAt(i547);
			if(no547 == null) {
				break;
			}
			var v547;
			switch(no547) {
			case 32:
				v547 = false;
				break;
			case 42:
				v547 = true;
				break;
			case 48:
				v547 = false;
				break;
			case 49:
				v547 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i547)));
			}
			switch(i547 - (l547 - 8)) {
			case 0:
				if(v547) {
					bs547 |= 128;
				} else {
					bs547 &= -129;
				}
				break;
			case 1:
				if(v547) {
					bs547 |= 64;
				} else {
					bs547 &= -65;
				}
				break;
			case 2:
				if(v547) {
					bs547 |= 32;
				} else {
					bs547 &= -33;
				}
				break;
			case 3:
				if(v547) {
					bs547 |= 16;
				} else {
					bs547 &= -17;
				}
				break;
			case 4:
				if(v547) {
					bs547 |= 8;
				} else {
					bs547 &= -9;
				}
				break;
			case 5:
				if(v547) {
					bs547 |= 4;
				} else {
					bs547 &= -5;
				}
				break;
			case 6:
				if(v547) {
					bs547 |= 2;
				} else {
					bs547 &= -3;
				}
				break;
			case 7:
				if(v547) {
					bs547 |= 1;
				} else {
					bs547 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs547;
		var this549 = 0;
		var bs548 = this549;
		var l548 = "* ** ".length;
		var _g1548 = 0;
		var _g648 = l548;
		while(_g1548 < _g648) {
			var i548 = _g1548++;
			var no548 = "* ** ".charCodeAt(i548);
			if(no548 == null) {
				break;
			}
			var v548;
			switch(no548) {
			case 32:
				v548 = false;
				break;
			case 42:
				v548 = true;
				break;
			case 48:
				v548 = false;
				break;
			case 49:
				v548 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* ** ".charCodeAt(i548)));
			}
			switch(i548 - (l548 - 8)) {
			case 0:
				if(v548) {
					bs548 |= 128;
				} else {
					bs548 &= -129;
				}
				break;
			case 1:
				if(v548) {
					bs548 |= 64;
				} else {
					bs548 &= -65;
				}
				break;
			case 2:
				if(v548) {
					bs548 |= 32;
				} else {
					bs548 &= -33;
				}
				break;
			case 3:
				if(v548) {
					bs548 |= 16;
				} else {
					bs548 &= -17;
				}
				break;
			case 4:
				if(v548) {
					bs548 |= 8;
				} else {
					bs548 &= -9;
				}
				break;
			case 5:
				if(v548) {
					bs548 |= 4;
				} else {
					bs548 &= -5;
				}
				break;
			case 6:
				if(v548) {
					bs548 |= 2;
				} else {
					bs548 &= -3;
				}
				break;
			case 7:
				if(v548) {
					bs548 |= 1;
				} else {
					bs548 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs548;
		var this550 = 0;
		var bs549 = this550;
		var l549 = "**  *".length;
		var _g1549 = 0;
		var _g649 = l549;
		while(_g1549 < _g649) {
			var i549 = _g1549++;
			var no549 = "**  *".charCodeAt(i549);
			if(no549 == null) {
				break;
			}
			var v549;
			switch(no549) {
			case 32:
				v549 = false;
				break;
			case 42:
				v549 = true;
				break;
			case 48:
				v549 = false;
				break;
			case 49:
				v549 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i549)));
			}
			switch(i549 - (l549 - 8)) {
			case 0:
				if(v549) {
					bs549 |= 128;
				} else {
					bs549 &= -129;
				}
				break;
			case 1:
				if(v549) {
					bs549 |= 64;
				} else {
					bs549 &= -65;
				}
				break;
			case 2:
				if(v549) {
					bs549 |= 32;
				} else {
					bs549 &= -33;
				}
				break;
			case 3:
				if(v549) {
					bs549 |= 16;
				} else {
					bs549 &= -17;
				}
				break;
			case 4:
				if(v549) {
					bs549 |= 8;
				} else {
					bs549 &= -9;
				}
				break;
			case 5:
				if(v549) {
					bs549 |= 4;
				} else {
					bs549 &= -5;
				}
				break;
			case 6:
				if(v549) {
					bs549 |= 2;
				} else {
					bs549 &= -3;
				}
				break;
			case 7:
				if(v549) {
					bs549 |= 1;
				} else {
					bs549 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs549;
		var this551 = 0;
		var bs550 = this551;
		var l550 = "*   *".length;
		var _g1550 = 0;
		var _g650 = l550;
		while(_g1550 < _g650) {
			var i550 = _g1550++;
			var no550 = "*   *".charCodeAt(i550);
			if(no550 == null) {
				break;
			}
			var v550;
			switch(no550) {
			case 32:
				v550 = false;
				break;
			case 42:
				v550 = true;
				break;
			case 48:
				v550 = false;
				break;
			case 49:
				v550 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i550)));
			}
			switch(i550 - (l550 - 8)) {
			case 0:
				if(v550) {
					bs550 |= 128;
				} else {
					bs550 &= -129;
				}
				break;
			case 1:
				if(v550) {
					bs550 |= 64;
				} else {
					bs550 &= -65;
				}
				break;
			case 2:
				if(v550) {
					bs550 |= 32;
				} else {
					bs550 &= -33;
				}
				break;
			case 3:
				if(v550) {
					bs550 |= 16;
				} else {
					bs550 &= -17;
				}
				break;
			case 4:
				if(v550) {
					bs550 |= 8;
				} else {
					bs550 &= -9;
				}
				break;
			case 5:
				if(v550) {
					bs550 |= 4;
				} else {
					bs550 &= -5;
				}
				break;
			case 6:
				if(v550) {
					bs550 |= 2;
				} else {
					bs550 &= -3;
				}
				break;
			case 7:
				if(v550) {
					bs550 |= 1;
				} else {
					bs550 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs550;
		var this552 = 0;
		var bs551 = this552;
		var l551 = "*   *".length;
		var _g1551 = 0;
		var _g651 = l551;
		while(_g1551 < _g651) {
			var i551 = _g1551++;
			var no551 = "*   *".charCodeAt(i551);
			if(no551 == null) {
				break;
			}
			var v551;
			switch(no551) {
			case 32:
				v551 = false;
				break;
			case 42:
				v551 = true;
				break;
			case 48:
				v551 = false;
				break;
			case 49:
				v551 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i551)));
			}
			switch(i551 - (l551 - 8)) {
			case 0:
				if(v551) {
					bs551 |= 128;
				} else {
					bs551 &= -129;
				}
				break;
			case 1:
				if(v551) {
					bs551 |= 64;
				} else {
					bs551 &= -65;
				}
				break;
			case 2:
				if(v551) {
					bs551 |= 32;
				} else {
					bs551 &= -33;
				}
				break;
			case 3:
				if(v551) {
					bs551 |= 16;
				} else {
					bs551 &= -17;
				}
				break;
			case 4:
				if(v551) {
					bs551 |= 8;
				} else {
					bs551 &= -9;
				}
				break;
			case 5:
				if(v551) {
					bs551 |= 4;
				} else {
					bs551 &= -5;
				}
				break;
			case 6:
				if(v551) {
					bs551 |= 2;
				} else {
					bs551 &= -3;
				}
				break;
			case 7:
				if(v551) {
					bs551 |= 1;
				} else {
					bs551 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs551;
		var this553 = 0;
		var bs552 = this553;
		var l552 = "*   *".length;
		var _g1552 = 0;
		var _g652 = l552;
		while(_g1552 < _g652) {
			var i552 = _g1552++;
			var no552 = "*   *".charCodeAt(i552);
			if(no552 == null) {
				break;
			}
			var v552;
			switch(no552) {
			case 32:
				v552 = false;
				break;
			case 42:
				v552 = true;
				break;
			case 48:
				v552 = false;
				break;
			case 49:
				v552 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i552)));
			}
			switch(i552 - (l552 - 8)) {
			case 0:
				if(v552) {
					bs552 |= 128;
				} else {
					bs552 &= -129;
				}
				break;
			case 1:
				if(v552) {
					bs552 |= 64;
				} else {
					bs552 &= -65;
				}
				break;
			case 2:
				if(v552) {
					bs552 |= 32;
				} else {
					bs552 &= -33;
				}
				break;
			case 3:
				if(v552) {
					bs552 |= 16;
				} else {
					bs552 &= -17;
				}
				break;
			case 4:
				if(v552) {
					bs552 |= 8;
				} else {
					bs552 &= -9;
				}
				break;
			case 5:
				if(v552) {
					bs552 |= 4;
				} else {
					bs552 &= -5;
				}
				break;
			case 6:
				if(v552) {
					bs552 |= 2;
				} else {
					bs552 &= -3;
				}
				break;
			case 7:
				if(v552) {
					bs552 |= 1;
				} else {
					bs552 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs552;
		break;
	case 111:
		var this554 = 0;
		var bs553 = this554;
		var l553 = "     ".length;
		var _g1553 = 0;
		var _g653 = l553;
		while(_g1553 < _g653) {
			var i553 = _g1553++;
			var no553 = "     ".charCodeAt(i553);
			if(no553 == null) {
				break;
			}
			var v553;
			switch(no553) {
			case 32:
				v553 = false;
				break;
			case 42:
				v553 = true;
				break;
			case 48:
				v553 = false;
				break;
			case 49:
				v553 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i553)));
			}
			switch(i553 - (l553 - 8)) {
			case 0:
				if(v553) {
					bs553 |= 128;
				} else {
					bs553 &= -129;
				}
				break;
			case 1:
				if(v553) {
					bs553 |= 64;
				} else {
					bs553 &= -65;
				}
				break;
			case 2:
				if(v553) {
					bs553 |= 32;
				} else {
					bs553 &= -33;
				}
				break;
			case 3:
				if(v553) {
					bs553 |= 16;
				} else {
					bs553 &= -17;
				}
				break;
			case 4:
				if(v553) {
					bs553 |= 8;
				} else {
					bs553 &= -9;
				}
				break;
			case 5:
				if(v553) {
					bs553 |= 4;
				} else {
					bs553 &= -5;
				}
				break;
			case 6:
				if(v553) {
					bs553 |= 2;
				} else {
					bs553 &= -3;
				}
				break;
			case 7:
				if(v553) {
					bs553 |= 1;
				} else {
					bs553 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs553;
		var this555 = 0;
		var bs554 = this555;
		var l554 = "     ".length;
		var _g1554 = 0;
		var _g654 = l554;
		while(_g1554 < _g654) {
			var i554 = _g1554++;
			var no554 = "     ".charCodeAt(i554);
			if(no554 == null) {
				break;
			}
			var v554;
			switch(no554) {
			case 32:
				v554 = false;
				break;
			case 42:
				v554 = true;
				break;
			case 48:
				v554 = false;
				break;
			case 49:
				v554 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i554)));
			}
			switch(i554 - (l554 - 8)) {
			case 0:
				if(v554) {
					bs554 |= 128;
				} else {
					bs554 &= -129;
				}
				break;
			case 1:
				if(v554) {
					bs554 |= 64;
				} else {
					bs554 &= -65;
				}
				break;
			case 2:
				if(v554) {
					bs554 |= 32;
				} else {
					bs554 &= -33;
				}
				break;
			case 3:
				if(v554) {
					bs554 |= 16;
				} else {
					bs554 &= -17;
				}
				break;
			case 4:
				if(v554) {
					bs554 |= 8;
				} else {
					bs554 &= -9;
				}
				break;
			case 5:
				if(v554) {
					bs554 |= 4;
				} else {
					bs554 &= -5;
				}
				break;
			case 6:
				if(v554) {
					bs554 |= 2;
				} else {
					bs554 &= -3;
				}
				break;
			case 7:
				if(v554) {
					bs554 |= 1;
				} else {
					bs554 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs554;
		var this556 = 0;
		var bs555 = this556;
		var l555 = " *** ".length;
		var _g1555 = 0;
		var _g655 = l555;
		while(_g1555 < _g655) {
			var i555 = _g1555++;
			var no555 = " *** ".charCodeAt(i555);
			if(no555 == null) {
				break;
			}
			var v555;
			switch(no555) {
			case 32:
				v555 = false;
				break;
			case 42:
				v555 = true;
				break;
			case 48:
				v555 = false;
				break;
			case 49:
				v555 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i555)));
			}
			switch(i555 - (l555 - 8)) {
			case 0:
				if(v555) {
					bs555 |= 128;
				} else {
					bs555 &= -129;
				}
				break;
			case 1:
				if(v555) {
					bs555 |= 64;
				} else {
					bs555 &= -65;
				}
				break;
			case 2:
				if(v555) {
					bs555 |= 32;
				} else {
					bs555 &= -33;
				}
				break;
			case 3:
				if(v555) {
					bs555 |= 16;
				} else {
					bs555 &= -17;
				}
				break;
			case 4:
				if(v555) {
					bs555 |= 8;
				} else {
					bs555 &= -9;
				}
				break;
			case 5:
				if(v555) {
					bs555 |= 4;
				} else {
					bs555 &= -5;
				}
				break;
			case 6:
				if(v555) {
					bs555 |= 2;
				} else {
					bs555 &= -3;
				}
				break;
			case 7:
				if(v555) {
					bs555 |= 1;
				} else {
					bs555 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs555;
		var this557 = 0;
		var bs556 = this557;
		var l556 = "*   *".length;
		var _g1556 = 0;
		var _g656 = l556;
		while(_g1556 < _g656) {
			var i556 = _g1556++;
			var no556 = "*   *".charCodeAt(i556);
			if(no556 == null) {
				break;
			}
			var v556;
			switch(no556) {
			case 32:
				v556 = false;
				break;
			case 42:
				v556 = true;
				break;
			case 48:
				v556 = false;
				break;
			case 49:
				v556 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i556)));
			}
			switch(i556 - (l556 - 8)) {
			case 0:
				if(v556) {
					bs556 |= 128;
				} else {
					bs556 &= -129;
				}
				break;
			case 1:
				if(v556) {
					bs556 |= 64;
				} else {
					bs556 &= -65;
				}
				break;
			case 2:
				if(v556) {
					bs556 |= 32;
				} else {
					bs556 &= -33;
				}
				break;
			case 3:
				if(v556) {
					bs556 |= 16;
				} else {
					bs556 &= -17;
				}
				break;
			case 4:
				if(v556) {
					bs556 |= 8;
				} else {
					bs556 &= -9;
				}
				break;
			case 5:
				if(v556) {
					bs556 |= 4;
				} else {
					bs556 &= -5;
				}
				break;
			case 6:
				if(v556) {
					bs556 |= 2;
				} else {
					bs556 &= -3;
				}
				break;
			case 7:
				if(v556) {
					bs556 |= 1;
				} else {
					bs556 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs556;
		var this558 = 0;
		var bs557 = this558;
		var l557 = "*   *".length;
		var _g1557 = 0;
		var _g657 = l557;
		while(_g1557 < _g657) {
			var i557 = _g1557++;
			var no557 = "*   *".charCodeAt(i557);
			if(no557 == null) {
				break;
			}
			var v557;
			switch(no557) {
			case 32:
				v557 = false;
				break;
			case 42:
				v557 = true;
				break;
			case 48:
				v557 = false;
				break;
			case 49:
				v557 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i557)));
			}
			switch(i557 - (l557 - 8)) {
			case 0:
				if(v557) {
					bs557 |= 128;
				} else {
					bs557 &= -129;
				}
				break;
			case 1:
				if(v557) {
					bs557 |= 64;
				} else {
					bs557 &= -65;
				}
				break;
			case 2:
				if(v557) {
					bs557 |= 32;
				} else {
					bs557 &= -33;
				}
				break;
			case 3:
				if(v557) {
					bs557 |= 16;
				} else {
					bs557 &= -17;
				}
				break;
			case 4:
				if(v557) {
					bs557 |= 8;
				} else {
					bs557 &= -9;
				}
				break;
			case 5:
				if(v557) {
					bs557 |= 4;
				} else {
					bs557 &= -5;
				}
				break;
			case 6:
				if(v557) {
					bs557 |= 2;
				} else {
					bs557 &= -3;
				}
				break;
			case 7:
				if(v557) {
					bs557 |= 1;
				} else {
					bs557 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs557;
		var this559 = 0;
		var bs558 = this559;
		var l558 = "*   *".length;
		var _g1558 = 0;
		var _g658 = l558;
		while(_g1558 < _g658) {
			var i558 = _g1558++;
			var no558 = "*   *".charCodeAt(i558);
			if(no558 == null) {
				break;
			}
			var v558;
			switch(no558) {
			case 32:
				v558 = false;
				break;
			case 42:
				v558 = true;
				break;
			case 48:
				v558 = false;
				break;
			case 49:
				v558 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i558)));
			}
			switch(i558 - (l558 - 8)) {
			case 0:
				if(v558) {
					bs558 |= 128;
				} else {
					bs558 &= -129;
				}
				break;
			case 1:
				if(v558) {
					bs558 |= 64;
				} else {
					bs558 &= -65;
				}
				break;
			case 2:
				if(v558) {
					bs558 |= 32;
				} else {
					bs558 &= -33;
				}
				break;
			case 3:
				if(v558) {
					bs558 |= 16;
				} else {
					bs558 &= -17;
				}
				break;
			case 4:
				if(v558) {
					bs558 |= 8;
				} else {
					bs558 &= -9;
				}
				break;
			case 5:
				if(v558) {
					bs558 |= 4;
				} else {
					bs558 &= -5;
				}
				break;
			case 6:
				if(v558) {
					bs558 |= 2;
				} else {
					bs558 &= -3;
				}
				break;
			case 7:
				if(v558) {
					bs558 |= 1;
				} else {
					bs558 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs558;
		var this560 = 0;
		var bs559 = this560;
		var l559 = " *** ".length;
		var _g1559 = 0;
		var _g659 = l559;
		while(_g1559 < _g659) {
			var i559 = _g1559++;
			var no559 = " *** ".charCodeAt(i559);
			if(no559 == null) {
				break;
			}
			var v559;
			switch(no559) {
			case 32:
				v559 = false;
				break;
			case 42:
				v559 = true;
				break;
			case 48:
				v559 = false;
				break;
			case 49:
				v559 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i559)));
			}
			switch(i559 - (l559 - 8)) {
			case 0:
				if(v559) {
					bs559 |= 128;
				} else {
					bs559 &= -129;
				}
				break;
			case 1:
				if(v559) {
					bs559 |= 64;
				} else {
					bs559 &= -65;
				}
				break;
			case 2:
				if(v559) {
					bs559 |= 32;
				} else {
					bs559 &= -33;
				}
				break;
			case 3:
				if(v559) {
					bs559 |= 16;
				} else {
					bs559 &= -17;
				}
				break;
			case 4:
				if(v559) {
					bs559 |= 8;
				} else {
					bs559 &= -9;
				}
				break;
			case 5:
				if(v559) {
					bs559 |= 4;
				} else {
					bs559 &= -5;
				}
				break;
			case 6:
				if(v559) {
					bs559 |= 2;
				} else {
					bs559 &= -3;
				}
				break;
			case 7:
				if(v559) {
					bs559 |= 1;
				} else {
					bs559 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs559;
		break;
	case 112:
		var this561 = 0;
		var bs560 = this561;
		var l560 = "     ".length;
		var _g1560 = 0;
		var _g660 = l560;
		while(_g1560 < _g660) {
			var i560 = _g1560++;
			var no560 = "     ".charCodeAt(i560);
			if(no560 == null) {
				break;
			}
			var v560;
			switch(no560) {
			case 32:
				v560 = false;
				break;
			case 42:
				v560 = true;
				break;
			case 48:
				v560 = false;
				break;
			case 49:
				v560 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i560)));
			}
			switch(i560 - (l560 - 8)) {
			case 0:
				if(v560) {
					bs560 |= 128;
				} else {
					bs560 &= -129;
				}
				break;
			case 1:
				if(v560) {
					bs560 |= 64;
				} else {
					bs560 &= -65;
				}
				break;
			case 2:
				if(v560) {
					bs560 |= 32;
				} else {
					bs560 &= -33;
				}
				break;
			case 3:
				if(v560) {
					bs560 |= 16;
				} else {
					bs560 &= -17;
				}
				break;
			case 4:
				if(v560) {
					bs560 |= 8;
				} else {
					bs560 &= -9;
				}
				break;
			case 5:
				if(v560) {
					bs560 |= 4;
				} else {
					bs560 &= -5;
				}
				break;
			case 6:
				if(v560) {
					bs560 |= 2;
				} else {
					bs560 &= -3;
				}
				break;
			case 7:
				if(v560) {
					bs560 |= 1;
				} else {
					bs560 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs560;
		var this562 = 0;
		var bs561 = this562;
		var l561 = "     ".length;
		var _g1561 = 0;
		var _g661 = l561;
		while(_g1561 < _g661) {
			var i561 = _g1561++;
			var no561 = "     ".charCodeAt(i561);
			if(no561 == null) {
				break;
			}
			var v561;
			switch(no561) {
			case 32:
				v561 = false;
				break;
			case 42:
				v561 = true;
				break;
			case 48:
				v561 = false;
				break;
			case 49:
				v561 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i561)));
			}
			switch(i561 - (l561 - 8)) {
			case 0:
				if(v561) {
					bs561 |= 128;
				} else {
					bs561 &= -129;
				}
				break;
			case 1:
				if(v561) {
					bs561 |= 64;
				} else {
					bs561 &= -65;
				}
				break;
			case 2:
				if(v561) {
					bs561 |= 32;
				} else {
					bs561 &= -33;
				}
				break;
			case 3:
				if(v561) {
					bs561 |= 16;
				} else {
					bs561 &= -17;
				}
				break;
			case 4:
				if(v561) {
					bs561 |= 8;
				} else {
					bs561 &= -9;
				}
				break;
			case 5:
				if(v561) {
					bs561 |= 4;
				} else {
					bs561 &= -5;
				}
				break;
			case 6:
				if(v561) {
					bs561 |= 2;
				} else {
					bs561 &= -3;
				}
				break;
			case 7:
				if(v561) {
					bs561 |= 1;
				} else {
					bs561 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs561;
		var this563 = 0;
		var bs562 = this563;
		var l562 = "**** ".length;
		var _g1562 = 0;
		var _g662 = l562;
		while(_g1562 < _g662) {
			var i562 = _g1562++;
			var no562 = "**** ".charCodeAt(i562);
			if(no562 == null) {
				break;
			}
			var v562;
			switch(no562) {
			case 32:
				v562 = false;
				break;
			case 42:
				v562 = true;
				break;
			case 48:
				v562 = false;
				break;
			case 49:
				v562 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i562)));
			}
			switch(i562 - (l562 - 8)) {
			case 0:
				if(v562) {
					bs562 |= 128;
				} else {
					bs562 &= -129;
				}
				break;
			case 1:
				if(v562) {
					bs562 |= 64;
				} else {
					bs562 &= -65;
				}
				break;
			case 2:
				if(v562) {
					bs562 |= 32;
				} else {
					bs562 &= -33;
				}
				break;
			case 3:
				if(v562) {
					bs562 |= 16;
				} else {
					bs562 &= -17;
				}
				break;
			case 4:
				if(v562) {
					bs562 |= 8;
				} else {
					bs562 &= -9;
				}
				break;
			case 5:
				if(v562) {
					bs562 |= 4;
				} else {
					bs562 &= -5;
				}
				break;
			case 6:
				if(v562) {
					bs562 |= 2;
				} else {
					bs562 &= -3;
				}
				break;
			case 7:
				if(v562) {
					bs562 |= 1;
				} else {
					bs562 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs562;
		var this564 = 0;
		var bs563 = this564;
		var l563 = "*   *".length;
		var _g1563 = 0;
		var _g663 = l563;
		while(_g1563 < _g663) {
			var i563 = _g1563++;
			var no563 = "*   *".charCodeAt(i563);
			if(no563 == null) {
				break;
			}
			var v563;
			switch(no563) {
			case 32:
				v563 = false;
				break;
			case 42:
				v563 = true;
				break;
			case 48:
				v563 = false;
				break;
			case 49:
				v563 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i563)));
			}
			switch(i563 - (l563 - 8)) {
			case 0:
				if(v563) {
					bs563 |= 128;
				} else {
					bs563 &= -129;
				}
				break;
			case 1:
				if(v563) {
					bs563 |= 64;
				} else {
					bs563 &= -65;
				}
				break;
			case 2:
				if(v563) {
					bs563 |= 32;
				} else {
					bs563 &= -33;
				}
				break;
			case 3:
				if(v563) {
					bs563 |= 16;
				} else {
					bs563 &= -17;
				}
				break;
			case 4:
				if(v563) {
					bs563 |= 8;
				} else {
					bs563 &= -9;
				}
				break;
			case 5:
				if(v563) {
					bs563 |= 4;
				} else {
					bs563 &= -5;
				}
				break;
			case 6:
				if(v563) {
					bs563 |= 2;
				} else {
					bs563 &= -3;
				}
				break;
			case 7:
				if(v563) {
					bs563 |= 1;
				} else {
					bs563 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs563;
		var this565 = 0;
		var bs564 = this565;
		var l564 = "**** ".length;
		var _g1564 = 0;
		var _g664 = l564;
		while(_g1564 < _g664) {
			var i564 = _g1564++;
			var no564 = "**** ".charCodeAt(i564);
			if(no564 == null) {
				break;
			}
			var v564;
			switch(no564) {
			case 32:
				v564 = false;
				break;
			case 42:
				v564 = true;
				break;
			case 48:
				v564 = false;
				break;
			case 49:
				v564 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i564)));
			}
			switch(i564 - (l564 - 8)) {
			case 0:
				if(v564) {
					bs564 |= 128;
				} else {
					bs564 &= -129;
				}
				break;
			case 1:
				if(v564) {
					bs564 |= 64;
				} else {
					bs564 &= -65;
				}
				break;
			case 2:
				if(v564) {
					bs564 |= 32;
				} else {
					bs564 &= -33;
				}
				break;
			case 3:
				if(v564) {
					bs564 |= 16;
				} else {
					bs564 &= -17;
				}
				break;
			case 4:
				if(v564) {
					bs564 |= 8;
				} else {
					bs564 &= -9;
				}
				break;
			case 5:
				if(v564) {
					bs564 |= 4;
				} else {
					bs564 &= -5;
				}
				break;
			case 6:
				if(v564) {
					bs564 |= 2;
				} else {
					bs564 &= -3;
				}
				break;
			case 7:
				if(v564) {
					bs564 |= 1;
				} else {
					bs564 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs564;
		var this566 = 0;
		var bs565 = this566;
		var l565 = "*    ".length;
		var _g1565 = 0;
		var _g665 = l565;
		while(_g1565 < _g665) {
			var i565 = _g1565++;
			var no565 = "*    ".charCodeAt(i565);
			if(no565 == null) {
				break;
			}
			var v565;
			switch(no565) {
			case 32:
				v565 = false;
				break;
			case 42:
				v565 = true;
				break;
			case 48:
				v565 = false;
				break;
			case 49:
				v565 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i565)));
			}
			switch(i565 - (l565 - 8)) {
			case 0:
				if(v565) {
					bs565 |= 128;
				} else {
					bs565 &= -129;
				}
				break;
			case 1:
				if(v565) {
					bs565 |= 64;
				} else {
					bs565 &= -65;
				}
				break;
			case 2:
				if(v565) {
					bs565 |= 32;
				} else {
					bs565 &= -33;
				}
				break;
			case 3:
				if(v565) {
					bs565 |= 16;
				} else {
					bs565 &= -17;
				}
				break;
			case 4:
				if(v565) {
					bs565 |= 8;
				} else {
					bs565 &= -9;
				}
				break;
			case 5:
				if(v565) {
					bs565 |= 4;
				} else {
					bs565 &= -5;
				}
				break;
			case 6:
				if(v565) {
					bs565 |= 2;
				} else {
					bs565 &= -3;
				}
				break;
			case 7:
				if(v565) {
					bs565 |= 1;
				} else {
					bs565 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs565;
		var this567 = 0;
		var bs566 = this567;
		var l566 = "*    ".length;
		var _g1566 = 0;
		var _g666 = l566;
		while(_g1566 < _g666) {
			var i566 = _g1566++;
			var no566 = "*    ".charCodeAt(i566);
			if(no566 == null) {
				break;
			}
			var v566;
			switch(no566) {
			case 32:
				v566 = false;
				break;
			case 42:
				v566 = true;
				break;
			case 48:
				v566 = false;
				break;
			case 49:
				v566 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i566)));
			}
			switch(i566 - (l566 - 8)) {
			case 0:
				if(v566) {
					bs566 |= 128;
				} else {
					bs566 &= -129;
				}
				break;
			case 1:
				if(v566) {
					bs566 |= 64;
				} else {
					bs566 &= -65;
				}
				break;
			case 2:
				if(v566) {
					bs566 |= 32;
				} else {
					bs566 &= -33;
				}
				break;
			case 3:
				if(v566) {
					bs566 |= 16;
				} else {
					bs566 &= -17;
				}
				break;
			case 4:
				if(v566) {
					bs566 |= 8;
				} else {
					bs566 &= -9;
				}
				break;
			case 5:
				if(v566) {
					bs566 |= 4;
				} else {
					bs566 &= -5;
				}
				break;
			case 6:
				if(v566) {
					bs566 |= 2;
				} else {
					bs566 &= -3;
				}
				break;
			case 7:
				if(v566) {
					bs566 |= 1;
				} else {
					bs566 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs566;
		break;
	case 113:
		var this568 = 0;
		var bs567 = this568;
		var l567 = "     ".length;
		var _g1567 = 0;
		var _g667 = l567;
		while(_g1567 < _g667) {
			var i567 = _g1567++;
			var no567 = "     ".charCodeAt(i567);
			if(no567 == null) {
				break;
			}
			var v567;
			switch(no567) {
			case 32:
				v567 = false;
				break;
			case 42:
				v567 = true;
				break;
			case 48:
				v567 = false;
				break;
			case 49:
				v567 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i567)));
			}
			switch(i567 - (l567 - 8)) {
			case 0:
				if(v567) {
					bs567 |= 128;
				} else {
					bs567 &= -129;
				}
				break;
			case 1:
				if(v567) {
					bs567 |= 64;
				} else {
					bs567 &= -65;
				}
				break;
			case 2:
				if(v567) {
					bs567 |= 32;
				} else {
					bs567 &= -33;
				}
				break;
			case 3:
				if(v567) {
					bs567 |= 16;
				} else {
					bs567 &= -17;
				}
				break;
			case 4:
				if(v567) {
					bs567 |= 8;
				} else {
					bs567 &= -9;
				}
				break;
			case 5:
				if(v567) {
					bs567 |= 4;
				} else {
					bs567 &= -5;
				}
				break;
			case 6:
				if(v567) {
					bs567 |= 2;
				} else {
					bs567 &= -3;
				}
				break;
			case 7:
				if(v567) {
					bs567 |= 1;
				} else {
					bs567 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs567;
		var this569 = 0;
		var bs568 = this569;
		var l568 = "     ".length;
		var _g1568 = 0;
		var _g668 = l568;
		while(_g1568 < _g668) {
			var i568 = _g1568++;
			var no568 = "     ".charCodeAt(i568);
			if(no568 == null) {
				break;
			}
			var v568;
			switch(no568) {
			case 32:
				v568 = false;
				break;
			case 42:
				v568 = true;
				break;
			case 48:
				v568 = false;
				break;
			case 49:
				v568 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i568)));
			}
			switch(i568 - (l568 - 8)) {
			case 0:
				if(v568) {
					bs568 |= 128;
				} else {
					bs568 &= -129;
				}
				break;
			case 1:
				if(v568) {
					bs568 |= 64;
				} else {
					bs568 &= -65;
				}
				break;
			case 2:
				if(v568) {
					bs568 |= 32;
				} else {
					bs568 &= -33;
				}
				break;
			case 3:
				if(v568) {
					bs568 |= 16;
				} else {
					bs568 &= -17;
				}
				break;
			case 4:
				if(v568) {
					bs568 |= 8;
				} else {
					bs568 &= -9;
				}
				break;
			case 5:
				if(v568) {
					bs568 |= 4;
				} else {
					bs568 &= -5;
				}
				break;
			case 6:
				if(v568) {
					bs568 |= 2;
				} else {
					bs568 &= -3;
				}
				break;
			case 7:
				if(v568) {
					bs568 |= 1;
				} else {
					bs568 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs568;
		var this570 = 0;
		var bs569 = this570;
		var l569 = " ** *".length;
		var _g1569 = 0;
		var _g669 = l569;
		while(_g1569 < _g669) {
			var i569 = _g1569++;
			var no569 = " ** *".charCodeAt(i569);
			if(no569 == null) {
				break;
			}
			var v569;
			switch(no569) {
			case 32:
				v569 = false;
				break;
			case 42:
				v569 = true;
				break;
			case 48:
				v569 = false;
				break;
			case 49:
				v569 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i569)));
			}
			switch(i569 - (l569 - 8)) {
			case 0:
				if(v569) {
					bs569 |= 128;
				} else {
					bs569 &= -129;
				}
				break;
			case 1:
				if(v569) {
					bs569 |= 64;
				} else {
					bs569 &= -65;
				}
				break;
			case 2:
				if(v569) {
					bs569 |= 32;
				} else {
					bs569 &= -33;
				}
				break;
			case 3:
				if(v569) {
					bs569 |= 16;
				} else {
					bs569 &= -17;
				}
				break;
			case 4:
				if(v569) {
					bs569 |= 8;
				} else {
					bs569 &= -9;
				}
				break;
			case 5:
				if(v569) {
					bs569 |= 4;
				} else {
					bs569 &= -5;
				}
				break;
			case 6:
				if(v569) {
					bs569 |= 2;
				} else {
					bs569 &= -3;
				}
				break;
			case 7:
				if(v569) {
					bs569 |= 1;
				} else {
					bs569 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs569;
		var this571 = 0;
		var bs570 = this571;
		var l570 = "*  **".length;
		var _g1570 = 0;
		var _g670 = l570;
		while(_g1570 < _g670) {
			var i570 = _g1570++;
			var no570 = "*  **".charCodeAt(i570);
			if(no570 == null) {
				break;
			}
			var v570;
			switch(no570) {
			case 32:
				v570 = false;
				break;
			case 42:
				v570 = true;
				break;
			case 48:
				v570 = false;
				break;
			case 49:
				v570 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  **".charCodeAt(i570)));
			}
			switch(i570 - (l570 - 8)) {
			case 0:
				if(v570) {
					bs570 |= 128;
				} else {
					bs570 &= -129;
				}
				break;
			case 1:
				if(v570) {
					bs570 |= 64;
				} else {
					bs570 &= -65;
				}
				break;
			case 2:
				if(v570) {
					bs570 |= 32;
				} else {
					bs570 &= -33;
				}
				break;
			case 3:
				if(v570) {
					bs570 |= 16;
				} else {
					bs570 &= -17;
				}
				break;
			case 4:
				if(v570) {
					bs570 |= 8;
				} else {
					bs570 &= -9;
				}
				break;
			case 5:
				if(v570) {
					bs570 |= 4;
				} else {
					bs570 &= -5;
				}
				break;
			case 6:
				if(v570) {
					bs570 |= 2;
				} else {
					bs570 &= -3;
				}
				break;
			case 7:
				if(v570) {
					bs570 |= 1;
				} else {
					bs570 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs570;
		var this572 = 0;
		var bs571 = this572;
		var l571 = " ****".length;
		var _g1571 = 0;
		var _g671 = l571;
		while(_g1571 < _g671) {
			var i571 = _g1571++;
			var no571 = " ****".charCodeAt(i571);
			if(no571 == null) {
				break;
			}
			var v571;
			switch(no571) {
			case 32:
				v571 = false;
				break;
			case 42:
				v571 = true;
				break;
			case 48:
				v571 = false;
				break;
			case 49:
				v571 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i571)));
			}
			switch(i571 - (l571 - 8)) {
			case 0:
				if(v571) {
					bs571 |= 128;
				} else {
					bs571 &= -129;
				}
				break;
			case 1:
				if(v571) {
					bs571 |= 64;
				} else {
					bs571 &= -65;
				}
				break;
			case 2:
				if(v571) {
					bs571 |= 32;
				} else {
					bs571 &= -33;
				}
				break;
			case 3:
				if(v571) {
					bs571 |= 16;
				} else {
					bs571 &= -17;
				}
				break;
			case 4:
				if(v571) {
					bs571 |= 8;
				} else {
					bs571 &= -9;
				}
				break;
			case 5:
				if(v571) {
					bs571 |= 4;
				} else {
					bs571 &= -5;
				}
				break;
			case 6:
				if(v571) {
					bs571 |= 2;
				} else {
					bs571 &= -3;
				}
				break;
			case 7:
				if(v571) {
					bs571 |= 1;
				} else {
					bs571 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs571;
		var this573 = 0;
		var bs572 = this573;
		var l572 = "    *".length;
		var _g1572 = 0;
		var _g672 = l572;
		while(_g1572 < _g672) {
			var i572 = _g1572++;
			var no572 = "    *".charCodeAt(i572);
			if(no572 == null) {
				break;
			}
			var v572;
			switch(no572) {
			case 32:
				v572 = false;
				break;
			case 42:
				v572 = true;
				break;
			case 48:
				v572 = false;
				break;
			case 49:
				v572 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i572)));
			}
			switch(i572 - (l572 - 8)) {
			case 0:
				if(v572) {
					bs572 |= 128;
				} else {
					bs572 &= -129;
				}
				break;
			case 1:
				if(v572) {
					bs572 |= 64;
				} else {
					bs572 &= -65;
				}
				break;
			case 2:
				if(v572) {
					bs572 |= 32;
				} else {
					bs572 &= -33;
				}
				break;
			case 3:
				if(v572) {
					bs572 |= 16;
				} else {
					bs572 &= -17;
				}
				break;
			case 4:
				if(v572) {
					bs572 |= 8;
				} else {
					bs572 &= -9;
				}
				break;
			case 5:
				if(v572) {
					bs572 |= 4;
				} else {
					bs572 &= -5;
				}
				break;
			case 6:
				if(v572) {
					bs572 |= 2;
				} else {
					bs572 &= -3;
				}
				break;
			case 7:
				if(v572) {
					bs572 |= 1;
				} else {
					bs572 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs572;
		var this574 = 0;
		var bs573 = this574;
		var l573 = "    *".length;
		var _g1573 = 0;
		var _g673 = l573;
		while(_g1573 < _g673) {
			var i573 = _g1573++;
			var no573 = "    *".charCodeAt(i573);
			if(no573 == null) {
				break;
			}
			var v573;
			switch(no573) {
			case 32:
				v573 = false;
				break;
			case 42:
				v573 = true;
				break;
			case 48:
				v573 = false;
				break;
			case 49:
				v573 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i573)));
			}
			switch(i573 - (l573 - 8)) {
			case 0:
				if(v573) {
					bs573 |= 128;
				} else {
					bs573 &= -129;
				}
				break;
			case 1:
				if(v573) {
					bs573 |= 64;
				} else {
					bs573 &= -65;
				}
				break;
			case 2:
				if(v573) {
					bs573 |= 32;
				} else {
					bs573 &= -33;
				}
				break;
			case 3:
				if(v573) {
					bs573 |= 16;
				} else {
					bs573 &= -17;
				}
				break;
			case 4:
				if(v573) {
					bs573 |= 8;
				} else {
					bs573 &= -9;
				}
				break;
			case 5:
				if(v573) {
					bs573 |= 4;
				} else {
					bs573 &= -5;
				}
				break;
			case 6:
				if(v573) {
					bs573 |= 2;
				} else {
					bs573 &= -3;
				}
				break;
			case 7:
				if(v573) {
					bs573 |= 1;
				} else {
					bs573 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs573;
		break;
	case 114:
		var this575 = 0;
		var bs574 = this575;
		var l574 = "     ".length;
		var _g1574 = 0;
		var _g674 = l574;
		while(_g1574 < _g674) {
			var i574 = _g1574++;
			var no574 = "     ".charCodeAt(i574);
			if(no574 == null) {
				break;
			}
			var v574;
			switch(no574) {
			case 32:
				v574 = false;
				break;
			case 42:
				v574 = true;
				break;
			case 48:
				v574 = false;
				break;
			case 49:
				v574 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i574)));
			}
			switch(i574 - (l574 - 8)) {
			case 0:
				if(v574) {
					bs574 |= 128;
				} else {
					bs574 &= -129;
				}
				break;
			case 1:
				if(v574) {
					bs574 |= 64;
				} else {
					bs574 &= -65;
				}
				break;
			case 2:
				if(v574) {
					bs574 |= 32;
				} else {
					bs574 &= -33;
				}
				break;
			case 3:
				if(v574) {
					bs574 |= 16;
				} else {
					bs574 &= -17;
				}
				break;
			case 4:
				if(v574) {
					bs574 |= 8;
				} else {
					bs574 &= -9;
				}
				break;
			case 5:
				if(v574) {
					bs574 |= 4;
				} else {
					bs574 &= -5;
				}
				break;
			case 6:
				if(v574) {
					bs574 |= 2;
				} else {
					bs574 &= -3;
				}
				break;
			case 7:
				if(v574) {
					bs574 |= 1;
				} else {
					bs574 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs574;
		var this576 = 0;
		var bs575 = this576;
		var l575 = "     ".length;
		var _g1575 = 0;
		var _g675 = l575;
		while(_g1575 < _g675) {
			var i575 = _g1575++;
			var no575 = "     ".charCodeAt(i575);
			if(no575 == null) {
				break;
			}
			var v575;
			switch(no575) {
			case 32:
				v575 = false;
				break;
			case 42:
				v575 = true;
				break;
			case 48:
				v575 = false;
				break;
			case 49:
				v575 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i575)));
			}
			switch(i575 - (l575 - 8)) {
			case 0:
				if(v575) {
					bs575 |= 128;
				} else {
					bs575 &= -129;
				}
				break;
			case 1:
				if(v575) {
					bs575 |= 64;
				} else {
					bs575 &= -65;
				}
				break;
			case 2:
				if(v575) {
					bs575 |= 32;
				} else {
					bs575 &= -33;
				}
				break;
			case 3:
				if(v575) {
					bs575 |= 16;
				} else {
					bs575 &= -17;
				}
				break;
			case 4:
				if(v575) {
					bs575 |= 8;
				} else {
					bs575 &= -9;
				}
				break;
			case 5:
				if(v575) {
					bs575 |= 4;
				} else {
					bs575 &= -5;
				}
				break;
			case 6:
				if(v575) {
					bs575 |= 2;
				} else {
					bs575 &= -3;
				}
				break;
			case 7:
				if(v575) {
					bs575 |= 1;
				} else {
					bs575 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs575;
		var this577 = 0;
		var bs576 = this577;
		var l576 = "* ** ".length;
		var _g1576 = 0;
		var _g676 = l576;
		while(_g1576 < _g676) {
			var i576 = _g1576++;
			var no576 = "* ** ".charCodeAt(i576);
			if(no576 == null) {
				break;
			}
			var v576;
			switch(no576) {
			case 32:
				v576 = false;
				break;
			case 42:
				v576 = true;
				break;
			case 48:
				v576 = false;
				break;
			case 49:
				v576 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* ** ".charCodeAt(i576)));
			}
			switch(i576 - (l576 - 8)) {
			case 0:
				if(v576) {
					bs576 |= 128;
				} else {
					bs576 &= -129;
				}
				break;
			case 1:
				if(v576) {
					bs576 |= 64;
				} else {
					bs576 &= -65;
				}
				break;
			case 2:
				if(v576) {
					bs576 |= 32;
				} else {
					bs576 &= -33;
				}
				break;
			case 3:
				if(v576) {
					bs576 |= 16;
				} else {
					bs576 &= -17;
				}
				break;
			case 4:
				if(v576) {
					bs576 |= 8;
				} else {
					bs576 &= -9;
				}
				break;
			case 5:
				if(v576) {
					bs576 |= 4;
				} else {
					bs576 &= -5;
				}
				break;
			case 6:
				if(v576) {
					bs576 |= 2;
				} else {
					bs576 &= -3;
				}
				break;
			case 7:
				if(v576) {
					bs576 |= 1;
				} else {
					bs576 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs576;
		var this578 = 0;
		var bs577 = this578;
		var l577 = "**  *".length;
		var _g1577 = 0;
		var _g677 = l577;
		while(_g1577 < _g677) {
			var i577 = _g1577++;
			var no577 = "**  *".charCodeAt(i577);
			if(no577 == null) {
				break;
			}
			var v577;
			switch(no577) {
			case 32:
				v577 = false;
				break;
			case 42:
				v577 = true;
				break;
			case 48:
				v577 = false;
				break;
			case 49:
				v577 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**  *".charCodeAt(i577)));
			}
			switch(i577 - (l577 - 8)) {
			case 0:
				if(v577) {
					bs577 |= 128;
				} else {
					bs577 &= -129;
				}
				break;
			case 1:
				if(v577) {
					bs577 |= 64;
				} else {
					bs577 &= -65;
				}
				break;
			case 2:
				if(v577) {
					bs577 |= 32;
				} else {
					bs577 &= -33;
				}
				break;
			case 3:
				if(v577) {
					bs577 |= 16;
				} else {
					bs577 &= -17;
				}
				break;
			case 4:
				if(v577) {
					bs577 |= 8;
				} else {
					bs577 &= -9;
				}
				break;
			case 5:
				if(v577) {
					bs577 |= 4;
				} else {
					bs577 &= -5;
				}
				break;
			case 6:
				if(v577) {
					bs577 |= 2;
				} else {
					bs577 &= -3;
				}
				break;
			case 7:
				if(v577) {
					bs577 |= 1;
				} else {
					bs577 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs577;
		var this579 = 0;
		var bs578 = this579;
		var l578 = "*    ".length;
		var _g1578 = 0;
		var _g678 = l578;
		while(_g1578 < _g678) {
			var i578 = _g1578++;
			var no578 = "*    ".charCodeAt(i578);
			if(no578 == null) {
				break;
			}
			var v578;
			switch(no578) {
			case 32:
				v578 = false;
				break;
			case 42:
				v578 = true;
				break;
			case 48:
				v578 = false;
				break;
			case 49:
				v578 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i578)));
			}
			switch(i578 - (l578 - 8)) {
			case 0:
				if(v578) {
					bs578 |= 128;
				} else {
					bs578 &= -129;
				}
				break;
			case 1:
				if(v578) {
					bs578 |= 64;
				} else {
					bs578 &= -65;
				}
				break;
			case 2:
				if(v578) {
					bs578 |= 32;
				} else {
					bs578 &= -33;
				}
				break;
			case 3:
				if(v578) {
					bs578 |= 16;
				} else {
					bs578 &= -17;
				}
				break;
			case 4:
				if(v578) {
					bs578 |= 8;
				} else {
					bs578 &= -9;
				}
				break;
			case 5:
				if(v578) {
					bs578 |= 4;
				} else {
					bs578 &= -5;
				}
				break;
			case 6:
				if(v578) {
					bs578 |= 2;
				} else {
					bs578 &= -3;
				}
				break;
			case 7:
				if(v578) {
					bs578 |= 1;
				} else {
					bs578 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs578;
		var this580 = 0;
		var bs579 = this580;
		var l579 = "*    ".length;
		var _g1579 = 0;
		var _g679 = l579;
		while(_g1579 < _g679) {
			var i579 = _g1579++;
			var no579 = "*    ".charCodeAt(i579);
			if(no579 == null) {
				break;
			}
			var v579;
			switch(no579) {
			case 32:
				v579 = false;
				break;
			case 42:
				v579 = true;
				break;
			case 48:
				v579 = false;
				break;
			case 49:
				v579 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i579)));
			}
			switch(i579 - (l579 - 8)) {
			case 0:
				if(v579) {
					bs579 |= 128;
				} else {
					bs579 &= -129;
				}
				break;
			case 1:
				if(v579) {
					bs579 |= 64;
				} else {
					bs579 &= -65;
				}
				break;
			case 2:
				if(v579) {
					bs579 |= 32;
				} else {
					bs579 &= -33;
				}
				break;
			case 3:
				if(v579) {
					bs579 |= 16;
				} else {
					bs579 &= -17;
				}
				break;
			case 4:
				if(v579) {
					bs579 |= 8;
				} else {
					bs579 &= -9;
				}
				break;
			case 5:
				if(v579) {
					bs579 |= 4;
				} else {
					bs579 &= -5;
				}
				break;
			case 6:
				if(v579) {
					bs579 |= 2;
				} else {
					bs579 &= -3;
				}
				break;
			case 7:
				if(v579) {
					bs579 |= 1;
				} else {
					bs579 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs579;
		var this581 = 0;
		var bs580 = this581;
		var l580 = "*    ".length;
		var _g1580 = 0;
		var _g680 = l580;
		while(_g1580 < _g680) {
			var i580 = _g1580++;
			var no580 = "*    ".charCodeAt(i580);
			if(no580 == null) {
				break;
			}
			var v580;
			switch(no580) {
			case 32:
				v580 = false;
				break;
			case 42:
				v580 = true;
				break;
			case 48:
				v580 = false;
				break;
			case 49:
				v580 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i580)));
			}
			switch(i580 - (l580 - 8)) {
			case 0:
				if(v580) {
					bs580 |= 128;
				} else {
					bs580 &= -129;
				}
				break;
			case 1:
				if(v580) {
					bs580 |= 64;
				} else {
					bs580 &= -65;
				}
				break;
			case 2:
				if(v580) {
					bs580 |= 32;
				} else {
					bs580 &= -33;
				}
				break;
			case 3:
				if(v580) {
					bs580 |= 16;
				} else {
					bs580 &= -17;
				}
				break;
			case 4:
				if(v580) {
					bs580 |= 8;
				} else {
					bs580 &= -9;
				}
				break;
			case 5:
				if(v580) {
					bs580 |= 4;
				} else {
					bs580 &= -5;
				}
				break;
			case 6:
				if(v580) {
					bs580 |= 2;
				} else {
					bs580 &= -3;
				}
				break;
			case 7:
				if(v580) {
					bs580 |= 1;
				} else {
					bs580 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs580;
		break;
	case 115:
		var this582 = 0;
		var bs581 = this582;
		var l581 = "     ".length;
		var _g1581 = 0;
		var _g681 = l581;
		while(_g1581 < _g681) {
			var i581 = _g1581++;
			var no581 = "     ".charCodeAt(i581);
			if(no581 == null) {
				break;
			}
			var v581;
			switch(no581) {
			case 32:
				v581 = false;
				break;
			case 42:
				v581 = true;
				break;
			case 48:
				v581 = false;
				break;
			case 49:
				v581 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i581)));
			}
			switch(i581 - (l581 - 8)) {
			case 0:
				if(v581) {
					bs581 |= 128;
				} else {
					bs581 &= -129;
				}
				break;
			case 1:
				if(v581) {
					bs581 |= 64;
				} else {
					bs581 &= -65;
				}
				break;
			case 2:
				if(v581) {
					bs581 |= 32;
				} else {
					bs581 &= -33;
				}
				break;
			case 3:
				if(v581) {
					bs581 |= 16;
				} else {
					bs581 &= -17;
				}
				break;
			case 4:
				if(v581) {
					bs581 |= 8;
				} else {
					bs581 &= -9;
				}
				break;
			case 5:
				if(v581) {
					bs581 |= 4;
				} else {
					bs581 &= -5;
				}
				break;
			case 6:
				if(v581) {
					bs581 |= 2;
				} else {
					bs581 &= -3;
				}
				break;
			case 7:
				if(v581) {
					bs581 |= 1;
				} else {
					bs581 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs581;
		var this583 = 0;
		var bs582 = this583;
		var l582 = "     ".length;
		var _g1582 = 0;
		var _g682 = l582;
		while(_g1582 < _g682) {
			var i582 = _g1582++;
			var no582 = "     ".charCodeAt(i582);
			if(no582 == null) {
				break;
			}
			var v582;
			switch(no582) {
			case 32:
				v582 = false;
				break;
			case 42:
				v582 = true;
				break;
			case 48:
				v582 = false;
				break;
			case 49:
				v582 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i582)));
			}
			switch(i582 - (l582 - 8)) {
			case 0:
				if(v582) {
					bs582 |= 128;
				} else {
					bs582 &= -129;
				}
				break;
			case 1:
				if(v582) {
					bs582 |= 64;
				} else {
					bs582 &= -65;
				}
				break;
			case 2:
				if(v582) {
					bs582 |= 32;
				} else {
					bs582 &= -33;
				}
				break;
			case 3:
				if(v582) {
					bs582 |= 16;
				} else {
					bs582 &= -17;
				}
				break;
			case 4:
				if(v582) {
					bs582 |= 8;
				} else {
					bs582 &= -9;
				}
				break;
			case 5:
				if(v582) {
					bs582 |= 4;
				} else {
					bs582 &= -5;
				}
				break;
			case 6:
				if(v582) {
					bs582 |= 2;
				} else {
					bs582 &= -3;
				}
				break;
			case 7:
				if(v582) {
					bs582 |= 1;
				} else {
					bs582 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs582;
		var this584 = 0;
		var bs583 = this584;
		var l583 = " *** ".length;
		var _g1583 = 0;
		var _g683 = l583;
		while(_g1583 < _g683) {
			var i583 = _g1583++;
			var no583 = " *** ".charCodeAt(i583);
			if(no583 == null) {
				break;
			}
			var v583;
			switch(no583) {
			case 32:
				v583 = false;
				break;
			case 42:
				v583 = true;
				break;
			case 48:
				v583 = false;
				break;
			case 49:
				v583 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i583)));
			}
			switch(i583 - (l583 - 8)) {
			case 0:
				if(v583) {
					bs583 |= 128;
				} else {
					bs583 &= -129;
				}
				break;
			case 1:
				if(v583) {
					bs583 |= 64;
				} else {
					bs583 &= -65;
				}
				break;
			case 2:
				if(v583) {
					bs583 |= 32;
				} else {
					bs583 &= -33;
				}
				break;
			case 3:
				if(v583) {
					bs583 |= 16;
				} else {
					bs583 &= -17;
				}
				break;
			case 4:
				if(v583) {
					bs583 |= 8;
				} else {
					bs583 &= -9;
				}
				break;
			case 5:
				if(v583) {
					bs583 |= 4;
				} else {
					bs583 &= -5;
				}
				break;
			case 6:
				if(v583) {
					bs583 |= 2;
				} else {
					bs583 &= -3;
				}
				break;
			case 7:
				if(v583) {
					bs583 |= 1;
				} else {
					bs583 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs583;
		var this585 = 0;
		var bs584 = this585;
		var l584 = "*    ".length;
		var _g1584 = 0;
		var _g684 = l584;
		while(_g1584 < _g684) {
			var i584 = _g1584++;
			var no584 = "*    ".charCodeAt(i584);
			if(no584 == null) {
				break;
			}
			var v584;
			switch(no584) {
			case 32:
				v584 = false;
				break;
			case 42:
				v584 = true;
				break;
			case 48:
				v584 = false;
				break;
			case 49:
				v584 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*    ".charCodeAt(i584)));
			}
			switch(i584 - (l584 - 8)) {
			case 0:
				if(v584) {
					bs584 |= 128;
				} else {
					bs584 &= -129;
				}
				break;
			case 1:
				if(v584) {
					bs584 |= 64;
				} else {
					bs584 &= -65;
				}
				break;
			case 2:
				if(v584) {
					bs584 |= 32;
				} else {
					bs584 &= -33;
				}
				break;
			case 3:
				if(v584) {
					bs584 |= 16;
				} else {
					bs584 &= -17;
				}
				break;
			case 4:
				if(v584) {
					bs584 |= 8;
				} else {
					bs584 &= -9;
				}
				break;
			case 5:
				if(v584) {
					bs584 |= 4;
				} else {
					bs584 &= -5;
				}
				break;
			case 6:
				if(v584) {
					bs584 |= 2;
				} else {
					bs584 &= -3;
				}
				break;
			case 7:
				if(v584) {
					bs584 |= 1;
				} else {
					bs584 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs584;
		var this586 = 0;
		var bs585 = this586;
		var l585 = " *** ".length;
		var _g1585 = 0;
		var _g685 = l585;
		while(_g1585 < _g685) {
			var i585 = _g1585++;
			var no585 = " *** ".charCodeAt(i585);
			if(no585 == null) {
				break;
			}
			var v585;
			switch(no585) {
			case 32:
				v585 = false;
				break;
			case 42:
				v585 = true;
				break;
			case 48:
				v585 = false;
				break;
			case 49:
				v585 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i585)));
			}
			switch(i585 - (l585 - 8)) {
			case 0:
				if(v585) {
					bs585 |= 128;
				} else {
					bs585 &= -129;
				}
				break;
			case 1:
				if(v585) {
					bs585 |= 64;
				} else {
					bs585 &= -65;
				}
				break;
			case 2:
				if(v585) {
					bs585 |= 32;
				} else {
					bs585 &= -33;
				}
				break;
			case 3:
				if(v585) {
					bs585 |= 16;
				} else {
					bs585 &= -17;
				}
				break;
			case 4:
				if(v585) {
					bs585 |= 8;
				} else {
					bs585 &= -9;
				}
				break;
			case 5:
				if(v585) {
					bs585 |= 4;
				} else {
					bs585 &= -5;
				}
				break;
			case 6:
				if(v585) {
					bs585 |= 2;
				} else {
					bs585 &= -3;
				}
				break;
			case 7:
				if(v585) {
					bs585 |= 1;
				} else {
					bs585 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs585;
		var this587 = 0;
		var bs586 = this587;
		var l586 = "    *".length;
		var _g1586 = 0;
		var _g686 = l586;
		while(_g1586 < _g686) {
			var i586 = _g1586++;
			var no586 = "    *".charCodeAt(i586);
			if(no586 == null) {
				break;
			}
			var v586;
			switch(no586) {
			case 32:
				v586 = false;
				break;
			case 42:
				v586 = true;
				break;
			case 48:
				v586 = false;
				break;
			case 49:
				v586 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i586)));
			}
			switch(i586 - (l586 - 8)) {
			case 0:
				if(v586) {
					bs586 |= 128;
				} else {
					bs586 &= -129;
				}
				break;
			case 1:
				if(v586) {
					bs586 |= 64;
				} else {
					bs586 &= -65;
				}
				break;
			case 2:
				if(v586) {
					bs586 |= 32;
				} else {
					bs586 &= -33;
				}
				break;
			case 3:
				if(v586) {
					bs586 |= 16;
				} else {
					bs586 &= -17;
				}
				break;
			case 4:
				if(v586) {
					bs586 |= 8;
				} else {
					bs586 &= -9;
				}
				break;
			case 5:
				if(v586) {
					bs586 |= 4;
				} else {
					bs586 &= -5;
				}
				break;
			case 6:
				if(v586) {
					bs586 |= 2;
				} else {
					bs586 &= -3;
				}
				break;
			case 7:
				if(v586) {
					bs586 |= 1;
				} else {
					bs586 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs586;
		var this588 = 0;
		var bs587 = this588;
		var l587 = "**** ".length;
		var _g1587 = 0;
		var _g687 = l587;
		while(_g1587 < _g687) {
			var i587 = _g1587++;
			var no587 = "**** ".charCodeAt(i587);
			if(no587 == null) {
				break;
			}
			var v587;
			switch(no587) {
			case 32:
				v587 = false;
				break;
			case 42:
				v587 = true;
				break;
			case 48:
				v587 = false;
				break;
			case 49:
				v587 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("**** ".charCodeAt(i587)));
			}
			switch(i587 - (l587 - 8)) {
			case 0:
				if(v587) {
					bs587 |= 128;
				} else {
					bs587 &= -129;
				}
				break;
			case 1:
				if(v587) {
					bs587 |= 64;
				} else {
					bs587 &= -65;
				}
				break;
			case 2:
				if(v587) {
					bs587 |= 32;
				} else {
					bs587 &= -33;
				}
				break;
			case 3:
				if(v587) {
					bs587 |= 16;
				} else {
					bs587 &= -17;
				}
				break;
			case 4:
				if(v587) {
					bs587 |= 8;
				} else {
					bs587 &= -9;
				}
				break;
			case 5:
				if(v587) {
					bs587 |= 4;
				} else {
					bs587 &= -5;
				}
				break;
			case 6:
				if(v587) {
					bs587 |= 2;
				} else {
					bs587 &= -3;
				}
				break;
			case 7:
				if(v587) {
					bs587 |= 1;
				} else {
					bs587 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs587;
		break;
	case 116:
		var this589 = 0;
		var bs588 = this589;
		var l588 = "     ".length;
		var _g1588 = 0;
		var _g688 = l588;
		while(_g1588 < _g688) {
			var i588 = _g1588++;
			var no588 = "     ".charCodeAt(i588);
			if(no588 == null) {
				break;
			}
			var v588;
			switch(no588) {
			case 32:
				v588 = false;
				break;
			case 42:
				v588 = true;
				break;
			case 48:
				v588 = false;
				break;
			case 49:
				v588 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i588)));
			}
			switch(i588 - (l588 - 8)) {
			case 0:
				if(v588) {
					bs588 |= 128;
				} else {
					bs588 &= -129;
				}
				break;
			case 1:
				if(v588) {
					bs588 |= 64;
				} else {
					bs588 &= -65;
				}
				break;
			case 2:
				if(v588) {
					bs588 |= 32;
				} else {
					bs588 &= -33;
				}
				break;
			case 3:
				if(v588) {
					bs588 |= 16;
				} else {
					bs588 &= -17;
				}
				break;
			case 4:
				if(v588) {
					bs588 |= 8;
				} else {
					bs588 &= -9;
				}
				break;
			case 5:
				if(v588) {
					bs588 |= 4;
				} else {
					bs588 &= -5;
				}
				break;
			case 6:
				if(v588) {
					bs588 |= 2;
				} else {
					bs588 &= -3;
				}
				break;
			case 7:
				if(v588) {
					bs588 |= 1;
				} else {
					bs588 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs588;
		var this590 = 0;
		var bs589 = this590;
		var l589 = " *   ".length;
		var _g1589 = 0;
		var _g689 = l589;
		while(_g1589 < _g689) {
			var i589 = _g1589++;
			var no589 = " *   ".charCodeAt(i589);
			if(no589 == null) {
				break;
			}
			var v589;
			switch(no589) {
			case 32:
				v589 = false;
				break;
			case 42:
				v589 = true;
				break;
			case 48:
				v589 = false;
				break;
			case 49:
				v589 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i589)));
			}
			switch(i589 - (l589 - 8)) {
			case 0:
				if(v589) {
					bs589 |= 128;
				} else {
					bs589 &= -129;
				}
				break;
			case 1:
				if(v589) {
					bs589 |= 64;
				} else {
					bs589 &= -65;
				}
				break;
			case 2:
				if(v589) {
					bs589 |= 32;
				} else {
					bs589 &= -33;
				}
				break;
			case 3:
				if(v589) {
					bs589 |= 16;
				} else {
					bs589 &= -17;
				}
				break;
			case 4:
				if(v589) {
					bs589 |= 8;
				} else {
					bs589 &= -9;
				}
				break;
			case 5:
				if(v589) {
					bs589 |= 4;
				} else {
					bs589 &= -5;
				}
				break;
			case 6:
				if(v589) {
					bs589 |= 2;
				} else {
					bs589 &= -3;
				}
				break;
			case 7:
				if(v589) {
					bs589 |= 1;
				} else {
					bs589 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs589;
		var this591 = 0;
		var bs590 = this591;
		var l590 = "***  ".length;
		var _g1590 = 0;
		var _g690 = l590;
		while(_g1590 < _g690) {
			var i590 = _g1590++;
			var no590 = "***  ".charCodeAt(i590);
			if(no590 == null) {
				break;
			}
			var v590;
			switch(no590) {
			case 32:
				v590 = false;
				break;
			case 42:
				v590 = true;
				break;
			case 48:
				v590 = false;
				break;
			case 49:
				v590 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("***  ".charCodeAt(i590)));
			}
			switch(i590 - (l590 - 8)) {
			case 0:
				if(v590) {
					bs590 |= 128;
				} else {
					bs590 &= -129;
				}
				break;
			case 1:
				if(v590) {
					bs590 |= 64;
				} else {
					bs590 &= -65;
				}
				break;
			case 2:
				if(v590) {
					bs590 |= 32;
				} else {
					bs590 &= -33;
				}
				break;
			case 3:
				if(v590) {
					bs590 |= 16;
				} else {
					bs590 &= -17;
				}
				break;
			case 4:
				if(v590) {
					bs590 |= 8;
				} else {
					bs590 &= -9;
				}
				break;
			case 5:
				if(v590) {
					bs590 |= 4;
				} else {
					bs590 &= -5;
				}
				break;
			case 6:
				if(v590) {
					bs590 |= 2;
				} else {
					bs590 &= -3;
				}
				break;
			case 7:
				if(v590) {
					bs590 |= 1;
				} else {
					bs590 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs590;
		var this592 = 0;
		var bs591 = this592;
		var l591 = " *   ".length;
		var _g1591 = 0;
		var _g691 = l591;
		while(_g1591 < _g691) {
			var i591 = _g1591++;
			var no591 = " *   ".charCodeAt(i591);
			if(no591 == null) {
				break;
			}
			var v591;
			switch(no591) {
			case 32:
				v591 = false;
				break;
			case 42:
				v591 = true;
				break;
			case 48:
				v591 = false;
				break;
			case 49:
				v591 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i591)));
			}
			switch(i591 - (l591 - 8)) {
			case 0:
				if(v591) {
					bs591 |= 128;
				} else {
					bs591 &= -129;
				}
				break;
			case 1:
				if(v591) {
					bs591 |= 64;
				} else {
					bs591 &= -65;
				}
				break;
			case 2:
				if(v591) {
					bs591 |= 32;
				} else {
					bs591 &= -33;
				}
				break;
			case 3:
				if(v591) {
					bs591 |= 16;
				} else {
					bs591 &= -17;
				}
				break;
			case 4:
				if(v591) {
					bs591 |= 8;
				} else {
					bs591 &= -9;
				}
				break;
			case 5:
				if(v591) {
					bs591 |= 4;
				} else {
					bs591 &= -5;
				}
				break;
			case 6:
				if(v591) {
					bs591 |= 2;
				} else {
					bs591 &= -3;
				}
				break;
			case 7:
				if(v591) {
					bs591 |= 1;
				} else {
					bs591 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs591;
		var this593 = 0;
		var bs592 = this593;
		var l592 = " *   ".length;
		var _g1592 = 0;
		var _g692 = l592;
		while(_g1592 < _g692) {
			var i592 = _g1592++;
			var no592 = " *   ".charCodeAt(i592);
			if(no592 == null) {
				break;
			}
			var v592;
			switch(no592) {
			case 32:
				v592 = false;
				break;
			case 42:
				v592 = true;
				break;
			case 48:
				v592 = false;
				break;
			case 49:
				v592 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i592)));
			}
			switch(i592 - (l592 - 8)) {
			case 0:
				if(v592) {
					bs592 |= 128;
				} else {
					bs592 &= -129;
				}
				break;
			case 1:
				if(v592) {
					bs592 |= 64;
				} else {
					bs592 &= -65;
				}
				break;
			case 2:
				if(v592) {
					bs592 |= 32;
				} else {
					bs592 &= -33;
				}
				break;
			case 3:
				if(v592) {
					bs592 |= 16;
				} else {
					bs592 &= -17;
				}
				break;
			case 4:
				if(v592) {
					bs592 |= 8;
				} else {
					bs592 &= -9;
				}
				break;
			case 5:
				if(v592) {
					bs592 |= 4;
				} else {
					bs592 &= -5;
				}
				break;
			case 6:
				if(v592) {
					bs592 |= 2;
				} else {
					bs592 &= -3;
				}
				break;
			case 7:
				if(v592) {
					bs592 |= 1;
				} else {
					bs592 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs592;
		var this594 = 0;
		var bs593 = this594;
		var l593 = " *  *".length;
		var _g1593 = 0;
		var _g693 = l593;
		while(_g1593 < _g693) {
			var i593 = _g1593++;
			var no593 = " *  *".charCodeAt(i593);
			if(no593 == null) {
				break;
			}
			var v593;
			switch(no593) {
			case 32:
				v593 = false;
				break;
			case 42:
				v593 = true;
				break;
			case 48:
				v593 = false;
				break;
			case 49:
				v593 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *  *".charCodeAt(i593)));
			}
			switch(i593 - (l593 - 8)) {
			case 0:
				if(v593) {
					bs593 |= 128;
				} else {
					bs593 &= -129;
				}
				break;
			case 1:
				if(v593) {
					bs593 |= 64;
				} else {
					bs593 &= -65;
				}
				break;
			case 2:
				if(v593) {
					bs593 |= 32;
				} else {
					bs593 &= -33;
				}
				break;
			case 3:
				if(v593) {
					bs593 |= 16;
				} else {
					bs593 &= -17;
				}
				break;
			case 4:
				if(v593) {
					bs593 |= 8;
				} else {
					bs593 &= -9;
				}
				break;
			case 5:
				if(v593) {
					bs593 |= 4;
				} else {
					bs593 &= -5;
				}
				break;
			case 6:
				if(v593) {
					bs593 |= 2;
				} else {
					bs593 &= -3;
				}
				break;
			case 7:
				if(v593) {
					bs593 |= 1;
				} else {
					bs593 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs593;
		var this595 = 0;
		var bs594 = this595;
		var l594 = "  ** ".length;
		var _g1594 = 0;
		var _g694 = l594;
		while(_g1594 < _g694) {
			var i594 = _g1594++;
			var no594 = "  ** ".charCodeAt(i594);
			if(no594 == null) {
				break;
			}
			var v594;
			switch(no594) {
			case 32:
				v594 = false;
				break;
			case 42:
				v594 = true;
				break;
			case 48:
				v594 = false;
				break;
			case 49:
				v594 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  ** ".charCodeAt(i594)));
			}
			switch(i594 - (l594 - 8)) {
			case 0:
				if(v594) {
					bs594 |= 128;
				} else {
					bs594 &= -129;
				}
				break;
			case 1:
				if(v594) {
					bs594 |= 64;
				} else {
					bs594 &= -65;
				}
				break;
			case 2:
				if(v594) {
					bs594 |= 32;
				} else {
					bs594 &= -33;
				}
				break;
			case 3:
				if(v594) {
					bs594 |= 16;
				} else {
					bs594 &= -17;
				}
				break;
			case 4:
				if(v594) {
					bs594 |= 8;
				} else {
					bs594 &= -9;
				}
				break;
			case 5:
				if(v594) {
					bs594 |= 4;
				} else {
					bs594 &= -5;
				}
				break;
			case 6:
				if(v594) {
					bs594 |= 2;
				} else {
					bs594 &= -3;
				}
				break;
			case 7:
				if(v594) {
					bs594 |= 1;
				} else {
					bs594 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs594;
		break;
	case 117:
		var this596 = 0;
		var bs595 = this596;
		var l595 = "     ".length;
		var _g1595 = 0;
		var _g695 = l595;
		while(_g1595 < _g695) {
			var i595 = _g1595++;
			var no595 = "     ".charCodeAt(i595);
			if(no595 == null) {
				break;
			}
			var v595;
			switch(no595) {
			case 32:
				v595 = false;
				break;
			case 42:
				v595 = true;
				break;
			case 48:
				v595 = false;
				break;
			case 49:
				v595 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i595)));
			}
			switch(i595 - (l595 - 8)) {
			case 0:
				if(v595) {
					bs595 |= 128;
				} else {
					bs595 &= -129;
				}
				break;
			case 1:
				if(v595) {
					bs595 |= 64;
				} else {
					bs595 &= -65;
				}
				break;
			case 2:
				if(v595) {
					bs595 |= 32;
				} else {
					bs595 &= -33;
				}
				break;
			case 3:
				if(v595) {
					bs595 |= 16;
				} else {
					bs595 &= -17;
				}
				break;
			case 4:
				if(v595) {
					bs595 |= 8;
				} else {
					bs595 &= -9;
				}
				break;
			case 5:
				if(v595) {
					bs595 |= 4;
				} else {
					bs595 &= -5;
				}
				break;
			case 6:
				if(v595) {
					bs595 |= 2;
				} else {
					bs595 &= -3;
				}
				break;
			case 7:
				if(v595) {
					bs595 |= 1;
				} else {
					bs595 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs595;
		var this597 = 0;
		var bs596 = this597;
		var l596 = "     ".length;
		var _g1596 = 0;
		var _g696 = l596;
		while(_g1596 < _g696) {
			var i596 = _g1596++;
			var no596 = "     ".charCodeAt(i596);
			if(no596 == null) {
				break;
			}
			var v596;
			switch(no596) {
			case 32:
				v596 = false;
				break;
			case 42:
				v596 = true;
				break;
			case 48:
				v596 = false;
				break;
			case 49:
				v596 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i596)));
			}
			switch(i596 - (l596 - 8)) {
			case 0:
				if(v596) {
					bs596 |= 128;
				} else {
					bs596 &= -129;
				}
				break;
			case 1:
				if(v596) {
					bs596 |= 64;
				} else {
					bs596 &= -65;
				}
				break;
			case 2:
				if(v596) {
					bs596 |= 32;
				} else {
					bs596 &= -33;
				}
				break;
			case 3:
				if(v596) {
					bs596 |= 16;
				} else {
					bs596 &= -17;
				}
				break;
			case 4:
				if(v596) {
					bs596 |= 8;
				} else {
					bs596 &= -9;
				}
				break;
			case 5:
				if(v596) {
					bs596 |= 4;
				} else {
					bs596 &= -5;
				}
				break;
			case 6:
				if(v596) {
					bs596 |= 2;
				} else {
					bs596 &= -3;
				}
				break;
			case 7:
				if(v596) {
					bs596 |= 1;
				} else {
					bs596 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs596;
		var this598 = 0;
		var bs597 = this598;
		var l597 = "*   *".length;
		var _g1597 = 0;
		var _g697 = l597;
		while(_g1597 < _g697) {
			var i597 = _g1597++;
			var no597 = "*   *".charCodeAt(i597);
			if(no597 == null) {
				break;
			}
			var v597;
			switch(no597) {
			case 32:
				v597 = false;
				break;
			case 42:
				v597 = true;
				break;
			case 48:
				v597 = false;
				break;
			case 49:
				v597 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i597)));
			}
			switch(i597 - (l597 - 8)) {
			case 0:
				if(v597) {
					bs597 |= 128;
				} else {
					bs597 &= -129;
				}
				break;
			case 1:
				if(v597) {
					bs597 |= 64;
				} else {
					bs597 &= -65;
				}
				break;
			case 2:
				if(v597) {
					bs597 |= 32;
				} else {
					bs597 &= -33;
				}
				break;
			case 3:
				if(v597) {
					bs597 |= 16;
				} else {
					bs597 &= -17;
				}
				break;
			case 4:
				if(v597) {
					bs597 |= 8;
				} else {
					bs597 &= -9;
				}
				break;
			case 5:
				if(v597) {
					bs597 |= 4;
				} else {
					bs597 &= -5;
				}
				break;
			case 6:
				if(v597) {
					bs597 |= 2;
				} else {
					bs597 &= -3;
				}
				break;
			case 7:
				if(v597) {
					bs597 |= 1;
				} else {
					bs597 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs597;
		var this599 = 0;
		var bs598 = this599;
		var l598 = "*   *".length;
		var _g1598 = 0;
		var _g698 = l598;
		while(_g1598 < _g698) {
			var i598 = _g1598++;
			var no598 = "*   *".charCodeAt(i598);
			if(no598 == null) {
				break;
			}
			var v598;
			switch(no598) {
			case 32:
				v598 = false;
				break;
			case 42:
				v598 = true;
				break;
			case 48:
				v598 = false;
				break;
			case 49:
				v598 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i598)));
			}
			switch(i598 - (l598 - 8)) {
			case 0:
				if(v598) {
					bs598 |= 128;
				} else {
					bs598 &= -129;
				}
				break;
			case 1:
				if(v598) {
					bs598 |= 64;
				} else {
					bs598 &= -65;
				}
				break;
			case 2:
				if(v598) {
					bs598 |= 32;
				} else {
					bs598 &= -33;
				}
				break;
			case 3:
				if(v598) {
					bs598 |= 16;
				} else {
					bs598 &= -17;
				}
				break;
			case 4:
				if(v598) {
					bs598 |= 8;
				} else {
					bs598 &= -9;
				}
				break;
			case 5:
				if(v598) {
					bs598 |= 4;
				} else {
					bs598 &= -5;
				}
				break;
			case 6:
				if(v598) {
					bs598 |= 2;
				} else {
					bs598 &= -3;
				}
				break;
			case 7:
				if(v598) {
					bs598 |= 1;
				} else {
					bs598 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs598;
		var this600 = 0;
		var bs599 = this600;
		var l599 = "*   *".length;
		var _g1599 = 0;
		var _g699 = l599;
		while(_g1599 < _g699) {
			var i599 = _g1599++;
			var no599 = "*   *".charCodeAt(i599);
			if(no599 == null) {
				break;
			}
			var v599;
			switch(no599) {
			case 32:
				v599 = false;
				break;
			case 42:
				v599 = true;
				break;
			case 48:
				v599 = false;
				break;
			case 49:
				v599 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i599)));
			}
			switch(i599 - (l599 - 8)) {
			case 0:
				if(v599) {
					bs599 |= 128;
				} else {
					bs599 &= -129;
				}
				break;
			case 1:
				if(v599) {
					bs599 |= 64;
				} else {
					bs599 &= -65;
				}
				break;
			case 2:
				if(v599) {
					bs599 |= 32;
				} else {
					bs599 &= -33;
				}
				break;
			case 3:
				if(v599) {
					bs599 |= 16;
				} else {
					bs599 &= -17;
				}
				break;
			case 4:
				if(v599) {
					bs599 |= 8;
				} else {
					bs599 &= -9;
				}
				break;
			case 5:
				if(v599) {
					bs599 |= 4;
				} else {
					bs599 &= -5;
				}
				break;
			case 6:
				if(v599) {
					bs599 |= 2;
				} else {
					bs599 &= -3;
				}
				break;
			case 7:
				if(v599) {
					bs599 |= 1;
				} else {
					bs599 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs599;
		var this601 = 0;
		var bs600 = this601;
		var l600 = "*  **".length;
		var _g1600 = 0;
		var _g700 = l600;
		while(_g1600 < _g700) {
			var i600 = _g1600++;
			var no600 = "*  **".charCodeAt(i600);
			if(no600 == null) {
				break;
			}
			var v600;
			switch(no600) {
			case 32:
				v600 = false;
				break;
			case 42:
				v600 = true;
				break;
			case 48:
				v600 = false;
				break;
			case 49:
				v600 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  **".charCodeAt(i600)));
			}
			switch(i600 - (l600 - 8)) {
			case 0:
				if(v600) {
					bs600 |= 128;
				} else {
					bs600 &= -129;
				}
				break;
			case 1:
				if(v600) {
					bs600 |= 64;
				} else {
					bs600 &= -65;
				}
				break;
			case 2:
				if(v600) {
					bs600 |= 32;
				} else {
					bs600 &= -33;
				}
				break;
			case 3:
				if(v600) {
					bs600 |= 16;
				} else {
					bs600 &= -17;
				}
				break;
			case 4:
				if(v600) {
					bs600 |= 8;
				} else {
					bs600 &= -9;
				}
				break;
			case 5:
				if(v600) {
					bs600 |= 4;
				} else {
					bs600 &= -5;
				}
				break;
			case 6:
				if(v600) {
					bs600 |= 2;
				} else {
					bs600 &= -3;
				}
				break;
			case 7:
				if(v600) {
					bs600 |= 1;
				} else {
					bs600 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs600;
		var this602 = 0;
		var bs601 = this602;
		var l601 = " ** *".length;
		var _g1601 = 0;
		var _g701 = l601;
		while(_g1601 < _g701) {
			var i601 = _g1601++;
			var no601 = " ** *".charCodeAt(i601);
			if(no601 == null) {
				break;
			}
			var v601;
			switch(no601) {
			case 32:
				v601 = false;
				break;
			case 42:
				v601 = true;
				break;
			case 48:
				v601 = false;
				break;
			case 49:
				v601 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i601)));
			}
			switch(i601 - (l601 - 8)) {
			case 0:
				if(v601) {
					bs601 |= 128;
				} else {
					bs601 &= -129;
				}
				break;
			case 1:
				if(v601) {
					bs601 |= 64;
				} else {
					bs601 &= -65;
				}
				break;
			case 2:
				if(v601) {
					bs601 |= 32;
				} else {
					bs601 &= -33;
				}
				break;
			case 3:
				if(v601) {
					bs601 |= 16;
				} else {
					bs601 &= -17;
				}
				break;
			case 4:
				if(v601) {
					bs601 |= 8;
				} else {
					bs601 &= -9;
				}
				break;
			case 5:
				if(v601) {
					bs601 |= 4;
				} else {
					bs601 &= -5;
				}
				break;
			case 6:
				if(v601) {
					bs601 |= 2;
				} else {
					bs601 &= -3;
				}
				break;
			case 7:
				if(v601) {
					bs601 |= 1;
				} else {
					bs601 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs601;
		break;
	case 118:
		var this603 = 0;
		var bs602 = this603;
		var l602 = "     ".length;
		var _g1602 = 0;
		var _g702 = l602;
		while(_g1602 < _g702) {
			var i602 = _g1602++;
			var no602 = "     ".charCodeAt(i602);
			if(no602 == null) {
				break;
			}
			var v602;
			switch(no602) {
			case 32:
				v602 = false;
				break;
			case 42:
				v602 = true;
				break;
			case 48:
				v602 = false;
				break;
			case 49:
				v602 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i602)));
			}
			switch(i602 - (l602 - 8)) {
			case 0:
				if(v602) {
					bs602 |= 128;
				} else {
					bs602 &= -129;
				}
				break;
			case 1:
				if(v602) {
					bs602 |= 64;
				} else {
					bs602 &= -65;
				}
				break;
			case 2:
				if(v602) {
					bs602 |= 32;
				} else {
					bs602 &= -33;
				}
				break;
			case 3:
				if(v602) {
					bs602 |= 16;
				} else {
					bs602 &= -17;
				}
				break;
			case 4:
				if(v602) {
					bs602 |= 8;
				} else {
					bs602 &= -9;
				}
				break;
			case 5:
				if(v602) {
					bs602 |= 4;
				} else {
					bs602 &= -5;
				}
				break;
			case 6:
				if(v602) {
					bs602 |= 2;
				} else {
					bs602 &= -3;
				}
				break;
			case 7:
				if(v602) {
					bs602 |= 1;
				} else {
					bs602 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs602;
		var this604 = 0;
		var bs603 = this604;
		var l603 = "     ".length;
		var _g1603 = 0;
		var _g703 = l603;
		while(_g1603 < _g703) {
			var i603 = _g1603++;
			var no603 = "     ".charCodeAt(i603);
			if(no603 == null) {
				break;
			}
			var v603;
			switch(no603) {
			case 32:
				v603 = false;
				break;
			case 42:
				v603 = true;
				break;
			case 48:
				v603 = false;
				break;
			case 49:
				v603 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i603)));
			}
			switch(i603 - (l603 - 8)) {
			case 0:
				if(v603) {
					bs603 |= 128;
				} else {
					bs603 &= -129;
				}
				break;
			case 1:
				if(v603) {
					bs603 |= 64;
				} else {
					bs603 &= -65;
				}
				break;
			case 2:
				if(v603) {
					bs603 |= 32;
				} else {
					bs603 &= -33;
				}
				break;
			case 3:
				if(v603) {
					bs603 |= 16;
				} else {
					bs603 &= -17;
				}
				break;
			case 4:
				if(v603) {
					bs603 |= 8;
				} else {
					bs603 &= -9;
				}
				break;
			case 5:
				if(v603) {
					bs603 |= 4;
				} else {
					bs603 &= -5;
				}
				break;
			case 6:
				if(v603) {
					bs603 |= 2;
				} else {
					bs603 &= -3;
				}
				break;
			case 7:
				if(v603) {
					bs603 |= 1;
				} else {
					bs603 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs603;
		var this605 = 0;
		var bs604 = this605;
		var l604 = "*   *".length;
		var _g1604 = 0;
		var _g704 = l604;
		while(_g1604 < _g704) {
			var i604 = _g1604++;
			var no604 = "*   *".charCodeAt(i604);
			if(no604 == null) {
				break;
			}
			var v604;
			switch(no604) {
			case 32:
				v604 = false;
				break;
			case 42:
				v604 = true;
				break;
			case 48:
				v604 = false;
				break;
			case 49:
				v604 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i604)));
			}
			switch(i604 - (l604 - 8)) {
			case 0:
				if(v604) {
					bs604 |= 128;
				} else {
					bs604 &= -129;
				}
				break;
			case 1:
				if(v604) {
					bs604 |= 64;
				} else {
					bs604 &= -65;
				}
				break;
			case 2:
				if(v604) {
					bs604 |= 32;
				} else {
					bs604 &= -33;
				}
				break;
			case 3:
				if(v604) {
					bs604 |= 16;
				} else {
					bs604 &= -17;
				}
				break;
			case 4:
				if(v604) {
					bs604 |= 8;
				} else {
					bs604 &= -9;
				}
				break;
			case 5:
				if(v604) {
					bs604 |= 4;
				} else {
					bs604 &= -5;
				}
				break;
			case 6:
				if(v604) {
					bs604 |= 2;
				} else {
					bs604 &= -3;
				}
				break;
			case 7:
				if(v604) {
					bs604 |= 1;
				} else {
					bs604 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs604;
		var this606 = 0;
		var bs605 = this606;
		var l605 = "*   *".length;
		var _g1605 = 0;
		var _g705 = l605;
		while(_g1605 < _g705) {
			var i605 = _g1605++;
			var no605 = "*   *".charCodeAt(i605);
			if(no605 == null) {
				break;
			}
			var v605;
			switch(no605) {
			case 32:
				v605 = false;
				break;
			case 42:
				v605 = true;
				break;
			case 48:
				v605 = false;
				break;
			case 49:
				v605 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i605)));
			}
			switch(i605 - (l605 - 8)) {
			case 0:
				if(v605) {
					bs605 |= 128;
				} else {
					bs605 &= -129;
				}
				break;
			case 1:
				if(v605) {
					bs605 |= 64;
				} else {
					bs605 &= -65;
				}
				break;
			case 2:
				if(v605) {
					bs605 |= 32;
				} else {
					bs605 &= -33;
				}
				break;
			case 3:
				if(v605) {
					bs605 |= 16;
				} else {
					bs605 &= -17;
				}
				break;
			case 4:
				if(v605) {
					bs605 |= 8;
				} else {
					bs605 &= -9;
				}
				break;
			case 5:
				if(v605) {
					bs605 |= 4;
				} else {
					bs605 &= -5;
				}
				break;
			case 6:
				if(v605) {
					bs605 |= 2;
				} else {
					bs605 &= -3;
				}
				break;
			case 7:
				if(v605) {
					bs605 |= 1;
				} else {
					bs605 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs605;
		var this607 = 0;
		var bs606 = this607;
		var l606 = "*   *".length;
		var _g1606 = 0;
		var _g706 = l606;
		while(_g1606 < _g706) {
			var i606 = _g1606++;
			var no606 = "*   *".charCodeAt(i606);
			if(no606 == null) {
				break;
			}
			var v606;
			switch(no606) {
			case 32:
				v606 = false;
				break;
			case 42:
				v606 = true;
				break;
			case 48:
				v606 = false;
				break;
			case 49:
				v606 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i606)));
			}
			switch(i606 - (l606 - 8)) {
			case 0:
				if(v606) {
					bs606 |= 128;
				} else {
					bs606 &= -129;
				}
				break;
			case 1:
				if(v606) {
					bs606 |= 64;
				} else {
					bs606 &= -65;
				}
				break;
			case 2:
				if(v606) {
					bs606 |= 32;
				} else {
					bs606 &= -33;
				}
				break;
			case 3:
				if(v606) {
					bs606 |= 16;
				} else {
					bs606 &= -17;
				}
				break;
			case 4:
				if(v606) {
					bs606 |= 8;
				} else {
					bs606 &= -9;
				}
				break;
			case 5:
				if(v606) {
					bs606 |= 4;
				} else {
					bs606 &= -5;
				}
				break;
			case 6:
				if(v606) {
					bs606 |= 2;
				} else {
					bs606 &= -3;
				}
				break;
			case 7:
				if(v606) {
					bs606 |= 1;
				} else {
					bs606 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs606;
		var this608 = 0;
		var bs607 = this608;
		var l607 = " * * ".length;
		var _g1607 = 0;
		var _g707 = l607;
		while(_g1607 < _g707) {
			var i607 = _g1607++;
			var no607 = " * * ".charCodeAt(i607);
			if(no607 == null) {
				break;
			}
			var v607;
			switch(no607) {
			case 32:
				v607 = false;
				break;
			case 42:
				v607 = true;
				break;
			case 48:
				v607 = false;
				break;
			case 49:
				v607 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i607)));
			}
			switch(i607 - (l607 - 8)) {
			case 0:
				if(v607) {
					bs607 |= 128;
				} else {
					bs607 &= -129;
				}
				break;
			case 1:
				if(v607) {
					bs607 |= 64;
				} else {
					bs607 &= -65;
				}
				break;
			case 2:
				if(v607) {
					bs607 |= 32;
				} else {
					bs607 &= -33;
				}
				break;
			case 3:
				if(v607) {
					bs607 |= 16;
				} else {
					bs607 &= -17;
				}
				break;
			case 4:
				if(v607) {
					bs607 |= 8;
				} else {
					bs607 &= -9;
				}
				break;
			case 5:
				if(v607) {
					bs607 |= 4;
				} else {
					bs607 &= -5;
				}
				break;
			case 6:
				if(v607) {
					bs607 |= 2;
				} else {
					bs607 &= -3;
				}
				break;
			case 7:
				if(v607) {
					bs607 |= 1;
				} else {
					bs607 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs607;
		var this609 = 0;
		var bs608 = this609;
		var l608 = "  *  ".length;
		var _g1608 = 0;
		var _g708 = l608;
		while(_g1608 < _g708) {
			var i608 = _g1608++;
			var no608 = "  *  ".charCodeAt(i608);
			if(no608 == null) {
				break;
			}
			var v608;
			switch(no608) {
			case 32:
				v608 = false;
				break;
			case 42:
				v608 = true;
				break;
			case 48:
				v608 = false;
				break;
			case 49:
				v608 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i608)));
			}
			switch(i608 - (l608 - 8)) {
			case 0:
				if(v608) {
					bs608 |= 128;
				} else {
					bs608 &= -129;
				}
				break;
			case 1:
				if(v608) {
					bs608 |= 64;
				} else {
					bs608 &= -65;
				}
				break;
			case 2:
				if(v608) {
					bs608 |= 32;
				} else {
					bs608 &= -33;
				}
				break;
			case 3:
				if(v608) {
					bs608 |= 16;
				} else {
					bs608 &= -17;
				}
				break;
			case 4:
				if(v608) {
					bs608 |= 8;
				} else {
					bs608 &= -9;
				}
				break;
			case 5:
				if(v608) {
					bs608 |= 4;
				} else {
					bs608 &= -5;
				}
				break;
			case 6:
				if(v608) {
					bs608 |= 2;
				} else {
					bs608 &= -3;
				}
				break;
			case 7:
				if(v608) {
					bs608 |= 1;
				} else {
					bs608 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs608;
		break;
	case 119:
		var this610 = 0;
		var bs609 = this610;
		var l609 = "     ".length;
		var _g1609 = 0;
		var _g709 = l609;
		while(_g1609 < _g709) {
			var i609 = _g1609++;
			var no609 = "     ".charCodeAt(i609);
			if(no609 == null) {
				break;
			}
			var v609;
			switch(no609) {
			case 32:
				v609 = false;
				break;
			case 42:
				v609 = true;
				break;
			case 48:
				v609 = false;
				break;
			case 49:
				v609 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i609)));
			}
			switch(i609 - (l609 - 8)) {
			case 0:
				if(v609) {
					bs609 |= 128;
				} else {
					bs609 &= -129;
				}
				break;
			case 1:
				if(v609) {
					bs609 |= 64;
				} else {
					bs609 &= -65;
				}
				break;
			case 2:
				if(v609) {
					bs609 |= 32;
				} else {
					bs609 &= -33;
				}
				break;
			case 3:
				if(v609) {
					bs609 |= 16;
				} else {
					bs609 &= -17;
				}
				break;
			case 4:
				if(v609) {
					bs609 |= 8;
				} else {
					bs609 &= -9;
				}
				break;
			case 5:
				if(v609) {
					bs609 |= 4;
				} else {
					bs609 &= -5;
				}
				break;
			case 6:
				if(v609) {
					bs609 |= 2;
				} else {
					bs609 &= -3;
				}
				break;
			case 7:
				if(v609) {
					bs609 |= 1;
				} else {
					bs609 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs609;
		var this611 = 0;
		var bs610 = this611;
		var l610 = "     ".length;
		var _g1610 = 0;
		var _g710 = l610;
		while(_g1610 < _g710) {
			var i610 = _g1610++;
			var no610 = "     ".charCodeAt(i610);
			if(no610 == null) {
				break;
			}
			var v610;
			switch(no610) {
			case 32:
				v610 = false;
				break;
			case 42:
				v610 = true;
				break;
			case 48:
				v610 = false;
				break;
			case 49:
				v610 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i610)));
			}
			switch(i610 - (l610 - 8)) {
			case 0:
				if(v610) {
					bs610 |= 128;
				} else {
					bs610 &= -129;
				}
				break;
			case 1:
				if(v610) {
					bs610 |= 64;
				} else {
					bs610 &= -65;
				}
				break;
			case 2:
				if(v610) {
					bs610 |= 32;
				} else {
					bs610 &= -33;
				}
				break;
			case 3:
				if(v610) {
					bs610 |= 16;
				} else {
					bs610 &= -17;
				}
				break;
			case 4:
				if(v610) {
					bs610 |= 8;
				} else {
					bs610 &= -9;
				}
				break;
			case 5:
				if(v610) {
					bs610 |= 4;
				} else {
					bs610 &= -5;
				}
				break;
			case 6:
				if(v610) {
					bs610 |= 2;
				} else {
					bs610 &= -3;
				}
				break;
			case 7:
				if(v610) {
					bs610 |= 1;
				} else {
					bs610 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs610;
		var this612 = 0;
		var bs611 = this612;
		var l611 = "*   *".length;
		var _g1611 = 0;
		var _g711 = l611;
		while(_g1611 < _g711) {
			var i611 = _g1611++;
			var no611 = "*   *".charCodeAt(i611);
			if(no611 == null) {
				break;
			}
			var v611;
			switch(no611) {
			case 32:
				v611 = false;
				break;
			case 42:
				v611 = true;
				break;
			case 48:
				v611 = false;
				break;
			case 49:
				v611 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i611)));
			}
			switch(i611 - (l611 - 8)) {
			case 0:
				if(v611) {
					bs611 |= 128;
				} else {
					bs611 &= -129;
				}
				break;
			case 1:
				if(v611) {
					bs611 |= 64;
				} else {
					bs611 &= -65;
				}
				break;
			case 2:
				if(v611) {
					bs611 |= 32;
				} else {
					bs611 &= -33;
				}
				break;
			case 3:
				if(v611) {
					bs611 |= 16;
				} else {
					bs611 &= -17;
				}
				break;
			case 4:
				if(v611) {
					bs611 |= 8;
				} else {
					bs611 &= -9;
				}
				break;
			case 5:
				if(v611) {
					bs611 |= 4;
				} else {
					bs611 &= -5;
				}
				break;
			case 6:
				if(v611) {
					bs611 |= 2;
				} else {
					bs611 &= -3;
				}
				break;
			case 7:
				if(v611) {
					bs611 |= 1;
				} else {
					bs611 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs611;
		var this613 = 0;
		var bs612 = this613;
		var l612 = "*   *".length;
		var _g1612 = 0;
		var _g712 = l612;
		while(_g1612 < _g712) {
			var i612 = _g1612++;
			var no612 = "*   *".charCodeAt(i612);
			if(no612 == null) {
				break;
			}
			var v612;
			switch(no612) {
			case 32:
				v612 = false;
				break;
			case 42:
				v612 = true;
				break;
			case 48:
				v612 = false;
				break;
			case 49:
				v612 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i612)));
			}
			switch(i612 - (l612 - 8)) {
			case 0:
				if(v612) {
					bs612 |= 128;
				} else {
					bs612 &= -129;
				}
				break;
			case 1:
				if(v612) {
					bs612 |= 64;
				} else {
					bs612 &= -65;
				}
				break;
			case 2:
				if(v612) {
					bs612 |= 32;
				} else {
					bs612 &= -33;
				}
				break;
			case 3:
				if(v612) {
					bs612 |= 16;
				} else {
					bs612 &= -17;
				}
				break;
			case 4:
				if(v612) {
					bs612 |= 8;
				} else {
					bs612 &= -9;
				}
				break;
			case 5:
				if(v612) {
					bs612 |= 4;
				} else {
					bs612 &= -5;
				}
				break;
			case 6:
				if(v612) {
					bs612 |= 2;
				} else {
					bs612 &= -3;
				}
				break;
			case 7:
				if(v612) {
					bs612 |= 1;
				} else {
					bs612 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs612;
		var this614 = 0;
		var bs613 = this614;
		var l613 = "* * *".length;
		var _g1613 = 0;
		var _g713 = l613;
		while(_g1613 < _g713) {
			var i613 = _g1613++;
			var no613 = "* * *".charCodeAt(i613);
			if(no613 == null) {
				break;
			}
			var v613;
			switch(no613) {
			case 32:
				v613 = false;
				break;
			case 42:
				v613 = true;
				break;
			case 48:
				v613 = false;
				break;
			case 49:
				v613 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i613)));
			}
			switch(i613 - (l613 - 8)) {
			case 0:
				if(v613) {
					bs613 |= 128;
				} else {
					bs613 &= -129;
				}
				break;
			case 1:
				if(v613) {
					bs613 |= 64;
				} else {
					bs613 &= -65;
				}
				break;
			case 2:
				if(v613) {
					bs613 |= 32;
				} else {
					bs613 &= -33;
				}
				break;
			case 3:
				if(v613) {
					bs613 |= 16;
				} else {
					bs613 &= -17;
				}
				break;
			case 4:
				if(v613) {
					bs613 |= 8;
				} else {
					bs613 &= -9;
				}
				break;
			case 5:
				if(v613) {
					bs613 |= 4;
				} else {
					bs613 &= -5;
				}
				break;
			case 6:
				if(v613) {
					bs613 |= 2;
				} else {
					bs613 &= -3;
				}
				break;
			case 7:
				if(v613) {
					bs613 |= 1;
				} else {
					bs613 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs613;
		var this615 = 0;
		var bs614 = this615;
		var l614 = "* * *".length;
		var _g1614 = 0;
		var _g714 = l614;
		while(_g1614 < _g714) {
			var i614 = _g1614++;
			var no614 = "* * *".charCodeAt(i614);
			if(no614 == null) {
				break;
			}
			var v614;
			switch(no614) {
			case 32:
				v614 = false;
				break;
			case 42:
				v614 = true;
				break;
			case 48:
				v614 = false;
				break;
			case 49:
				v614 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("* * *".charCodeAt(i614)));
			}
			switch(i614 - (l614 - 8)) {
			case 0:
				if(v614) {
					bs614 |= 128;
				} else {
					bs614 &= -129;
				}
				break;
			case 1:
				if(v614) {
					bs614 |= 64;
				} else {
					bs614 &= -65;
				}
				break;
			case 2:
				if(v614) {
					bs614 |= 32;
				} else {
					bs614 &= -33;
				}
				break;
			case 3:
				if(v614) {
					bs614 |= 16;
				} else {
					bs614 &= -17;
				}
				break;
			case 4:
				if(v614) {
					bs614 |= 8;
				} else {
					bs614 &= -9;
				}
				break;
			case 5:
				if(v614) {
					bs614 |= 4;
				} else {
					bs614 &= -5;
				}
				break;
			case 6:
				if(v614) {
					bs614 |= 2;
				} else {
					bs614 &= -3;
				}
				break;
			case 7:
				if(v614) {
					bs614 |= 1;
				} else {
					bs614 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs614;
		var this616 = 0;
		var bs615 = this616;
		var l615 = " * * ".length;
		var _g1615 = 0;
		var _g715 = l615;
		while(_g1615 < _g715) {
			var i615 = _g1615++;
			var no615 = " * * ".charCodeAt(i615);
			if(no615 == null) {
				break;
			}
			var v615;
			switch(no615) {
			case 32:
				v615 = false;
				break;
			case 42:
				v615 = true;
				break;
			case 48:
				v615 = false;
				break;
			case 49:
				v615 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i615)));
			}
			switch(i615 - (l615 - 8)) {
			case 0:
				if(v615) {
					bs615 |= 128;
				} else {
					bs615 &= -129;
				}
				break;
			case 1:
				if(v615) {
					bs615 |= 64;
				} else {
					bs615 &= -65;
				}
				break;
			case 2:
				if(v615) {
					bs615 |= 32;
				} else {
					bs615 &= -33;
				}
				break;
			case 3:
				if(v615) {
					bs615 |= 16;
				} else {
					bs615 &= -17;
				}
				break;
			case 4:
				if(v615) {
					bs615 |= 8;
				} else {
					bs615 &= -9;
				}
				break;
			case 5:
				if(v615) {
					bs615 |= 4;
				} else {
					bs615 &= -5;
				}
				break;
			case 6:
				if(v615) {
					bs615 |= 2;
				} else {
					bs615 &= -3;
				}
				break;
			case 7:
				if(v615) {
					bs615 |= 1;
				} else {
					bs615 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs615;
		break;
	case 120:
		var this617 = 0;
		var bs616 = this617;
		var l616 = "     ".length;
		var _g1616 = 0;
		var _g716 = l616;
		while(_g1616 < _g716) {
			var i616 = _g1616++;
			var no616 = "     ".charCodeAt(i616);
			if(no616 == null) {
				break;
			}
			var v616;
			switch(no616) {
			case 32:
				v616 = false;
				break;
			case 42:
				v616 = true;
				break;
			case 48:
				v616 = false;
				break;
			case 49:
				v616 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i616)));
			}
			switch(i616 - (l616 - 8)) {
			case 0:
				if(v616) {
					bs616 |= 128;
				} else {
					bs616 &= -129;
				}
				break;
			case 1:
				if(v616) {
					bs616 |= 64;
				} else {
					bs616 &= -65;
				}
				break;
			case 2:
				if(v616) {
					bs616 |= 32;
				} else {
					bs616 &= -33;
				}
				break;
			case 3:
				if(v616) {
					bs616 |= 16;
				} else {
					bs616 &= -17;
				}
				break;
			case 4:
				if(v616) {
					bs616 |= 8;
				} else {
					bs616 &= -9;
				}
				break;
			case 5:
				if(v616) {
					bs616 |= 4;
				} else {
					bs616 &= -5;
				}
				break;
			case 6:
				if(v616) {
					bs616 |= 2;
				} else {
					bs616 &= -3;
				}
				break;
			case 7:
				if(v616) {
					bs616 |= 1;
				} else {
					bs616 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs616;
		var this618 = 0;
		var bs617 = this618;
		var l617 = "     ".length;
		var _g1617 = 0;
		var _g717 = l617;
		while(_g1617 < _g717) {
			var i617 = _g1617++;
			var no617 = "     ".charCodeAt(i617);
			if(no617 == null) {
				break;
			}
			var v617;
			switch(no617) {
			case 32:
				v617 = false;
				break;
			case 42:
				v617 = true;
				break;
			case 48:
				v617 = false;
				break;
			case 49:
				v617 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i617)));
			}
			switch(i617 - (l617 - 8)) {
			case 0:
				if(v617) {
					bs617 |= 128;
				} else {
					bs617 &= -129;
				}
				break;
			case 1:
				if(v617) {
					bs617 |= 64;
				} else {
					bs617 &= -65;
				}
				break;
			case 2:
				if(v617) {
					bs617 |= 32;
				} else {
					bs617 &= -33;
				}
				break;
			case 3:
				if(v617) {
					bs617 |= 16;
				} else {
					bs617 &= -17;
				}
				break;
			case 4:
				if(v617) {
					bs617 |= 8;
				} else {
					bs617 &= -9;
				}
				break;
			case 5:
				if(v617) {
					bs617 |= 4;
				} else {
					bs617 &= -5;
				}
				break;
			case 6:
				if(v617) {
					bs617 |= 2;
				} else {
					bs617 &= -3;
				}
				break;
			case 7:
				if(v617) {
					bs617 |= 1;
				} else {
					bs617 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs617;
		var this619 = 0;
		var bs618 = this619;
		var l618 = "*   *".length;
		var _g1618 = 0;
		var _g718 = l618;
		while(_g1618 < _g718) {
			var i618 = _g1618++;
			var no618 = "*   *".charCodeAt(i618);
			if(no618 == null) {
				break;
			}
			var v618;
			switch(no618) {
			case 32:
				v618 = false;
				break;
			case 42:
				v618 = true;
				break;
			case 48:
				v618 = false;
				break;
			case 49:
				v618 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i618)));
			}
			switch(i618 - (l618 - 8)) {
			case 0:
				if(v618) {
					bs618 |= 128;
				} else {
					bs618 &= -129;
				}
				break;
			case 1:
				if(v618) {
					bs618 |= 64;
				} else {
					bs618 &= -65;
				}
				break;
			case 2:
				if(v618) {
					bs618 |= 32;
				} else {
					bs618 &= -33;
				}
				break;
			case 3:
				if(v618) {
					bs618 |= 16;
				} else {
					bs618 &= -17;
				}
				break;
			case 4:
				if(v618) {
					bs618 |= 8;
				} else {
					bs618 &= -9;
				}
				break;
			case 5:
				if(v618) {
					bs618 |= 4;
				} else {
					bs618 &= -5;
				}
				break;
			case 6:
				if(v618) {
					bs618 |= 2;
				} else {
					bs618 &= -3;
				}
				break;
			case 7:
				if(v618) {
					bs618 |= 1;
				} else {
					bs618 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs618;
		var this620 = 0;
		var bs619 = this620;
		var l619 = " * * ".length;
		var _g1619 = 0;
		var _g719 = l619;
		while(_g1619 < _g719) {
			var i619 = _g1619++;
			var no619 = " * * ".charCodeAt(i619);
			if(no619 == null) {
				break;
			}
			var v619;
			switch(no619) {
			case 32:
				v619 = false;
				break;
			case 42:
				v619 = true;
				break;
			case 48:
				v619 = false;
				break;
			case 49:
				v619 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i619)));
			}
			switch(i619 - (l619 - 8)) {
			case 0:
				if(v619) {
					bs619 |= 128;
				} else {
					bs619 &= -129;
				}
				break;
			case 1:
				if(v619) {
					bs619 |= 64;
				} else {
					bs619 &= -65;
				}
				break;
			case 2:
				if(v619) {
					bs619 |= 32;
				} else {
					bs619 &= -33;
				}
				break;
			case 3:
				if(v619) {
					bs619 |= 16;
				} else {
					bs619 &= -17;
				}
				break;
			case 4:
				if(v619) {
					bs619 |= 8;
				} else {
					bs619 &= -9;
				}
				break;
			case 5:
				if(v619) {
					bs619 |= 4;
				} else {
					bs619 &= -5;
				}
				break;
			case 6:
				if(v619) {
					bs619 |= 2;
				} else {
					bs619 &= -3;
				}
				break;
			case 7:
				if(v619) {
					bs619 |= 1;
				} else {
					bs619 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs619;
		var this621 = 0;
		var bs620 = this621;
		var l620 = "  *  ".length;
		var _g1620 = 0;
		var _g720 = l620;
		while(_g1620 < _g720) {
			var i620 = _g1620++;
			var no620 = "  *  ".charCodeAt(i620);
			if(no620 == null) {
				break;
			}
			var v620;
			switch(no620) {
			case 32:
				v620 = false;
				break;
			case 42:
				v620 = true;
				break;
			case 48:
				v620 = false;
				break;
			case 49:
				v620 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i620)));
			}
			switch(i620 - (l620 - 8)) {
			case 0:
				if(v620) {
					bs620 |= 128;
				} else {
					bs620 &= -129;
				}
				break;
			case 1:
				if(v620) {
					bs620 |= 64;
				} else {
					bs620 &= -65;
				}
				break;
			case 2:
				if(v620) {
					bs620 |= 32;
				} else {
					bs620 &= -33;
				}
				break;
			case 3:
				if(v620) {
					bs620 |= 16;
				} else {
					bs620 &= -17;
				}
				break;
			case 4:
				if(v620) {
					bs620 |= 8;
				} else {
					bs620 &= -9;
				}
				break;
			case 5:
				if(v620) {
					bs620 |= 4;
				} else {
					bs620 &= -5;
				}
				break;
			case 6:
				if(v620) {
					bs620 |= 2;
				} else {
					bs620 &= -3;
				}
				break;
			case 7:
				if(v620) {
					bs620 |= 1;
				} else {
					bs620 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs620;
		var this622 = 0;
		var bs621 = this622;
		var l621 = " * * ".length;
		var _g1621 = 0;
		var _g721 = l621;
		while(_g1621 < _g721) {
			var i621 = _g1621++;
			var no621 = " * * ".charCodeAt(i621);
			if(no621 == null) {
				break;
			}
			var v621;
			switch(no621) {
			case 32:
				v621 = false;
				break;
			case 42:
				v621 = true;
				break;
			case 48:
				v621 = false;
				break;
			case 49:
				v621 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" * * ".charCodeAt(i621)));
			}
			switch(i621 - (l621 - 8)) {
			case 0:
				if(v621) {
					bs621 |= 128;
				} else {
					bs621 &= -129;
				}
				break;
			case 1:
				if(v621) {
					bs621 |= 64;
				} else {
					bs621 &= -65;
				}
				break;
			case 2:
				if(v621) {
					bs621 |= 32;
				} else {
					bs621 &= -33;
				}
				break;
			case 3:
				if(v621) {
					bs621 |= 16;
				} else {
					bs621 &= -17;
				}
				break;
			case 4:
				if(v621) {
					bs621 |= 8;
				} else {
					bs621 &= -9;
				}
				break;
			case 5:
				if(v621) {
					bs621 |= 4;
				} else {
					bs621 &= -5;
				}
				break;
			case 6:
				if(v621) {
					bs621 |= 2;
				} else {
					bs621 &= -3;
				}
				break;
			case 7:
				if(v621) {
					bs621 |= 1;
				} else {
					bs621 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs621;
		var this623 = 0;
		var bs622 = this623;
		var l622 = "*   *".length;
		var _g1622 = 0;
		var _g722 = l622;
		while(_g1622 < _g722) {
			var i622 = _g1622++;
			var no622 = "*   *".charCodeAt(i622);
			if(no622 == null) {
				break;
			}
			var v622;
			switch(no622) {
			case 32:
				v622 = false;
				break;
			case 42:
				v622 = true;
				break;
			case 48:
				v622 = false;
				break;
			case 49:
				v622 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i622)));
			}
			switch(i622 - (l622 - 8)) {
			case 0:
				if(v622) {
					bs622 |= 128;
				} else {
					bs622 &= -129;
				}
				break;
			case 1:
				if(v622) {
					bs622 |= 64;
				} else {
					bs622 &= -65;
				}
				break;
			case 2:
				if(v622) {
					bs622 |= 32;
				} else {
					bs622 &= -33;
				}
				break;
			case 3:
				if(v622) {
					bs622 |= 16;
				} else {
					bs622 &= -17;
				}
				break;
			case 4:
				if(v622) {
					bs622 |= 8;
				} else {
					bs622 &= -9;
				}
				break;
			case 5:
				if(v622) {
					bs622 |= 4;
				} else {
					bs622 &= -5;
				}
				break;
			case 6:
				if(v622) {
					bs622 |= 2;
				} else {
					bs622 &= -3;
				}
				break;
			case 7:
				if(v622) {
					bs622 |= 1;
				} else {
					bs622 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs622;
		break;
	case 121:
		var this624 = 0;
		var bs623 = this624;
		var l623 = "     ".length;
		var _g1623 = 0;
		var _g723 = l623;
		while(_g1623 < _g723) {
			var i623 = _g1623++;
			var no623 = "     ".charCodeAt(i623);
			if(no623 == null) {
				break;
			}
			var v623;
			switch(no623) {
			case 32:
				v623 = false;
				break;
			case 42:
				v623 = true;
				break;
			case 48:
				v623 = false;
				break;
			case 49:
				v623 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i623)));
			}
			switch(i623 - (l623 - 8)) {
			case 0:
				if(v623) {
					bs623 |= 128;
				} else {
					bs623 &= -129;
				}
				break;
			case 1:
				if(v623) {
					bs623 |= 64;
				} else {
					bs623 &= -65;
				}
				break;
			case 2:
				if(v623) {
					bs623 |= 32;
				} else {
					bs623 &= -33;
				}
				break;
			case 3:
				if(v623) {
					bs623 |= 16;
				} else {
					bs623 &= -17;
				}
				break;
			case 4:
				if(v623) {
					bs623 |= 8;
				} else {
					bs623 &= -9;
				}
				break;
			case 5:
				if(v623) {
					bs623 |= 4;
				} else {
					bs623 &= -5;
				}
				break;
			case 6:
				if(v623) {
					bs623 |= 2;
				} else {
					bs623 &= -3;
				}
				break;
			case 7:
				if(v623) {
					bs623 |= 1;
				} else {
					bs623 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs623;
		var this625 = 0;
		var bs624 = this625;
		var l624 = "     ".length;
		var _g1624 = 0;
		var _g724 = l624;
		while(_g1624 < _g724) {
			var i624 = _g1624++;
			var no624 = "     ".charCodeAt(i624);
			if(no624 == null) {
				break;
			}
			var v624;
			switch(no624) {
			case 32:
				v624 = false;
				break;
			case 42:
				v624 = true;
				break;
			case 48:
				v624 = false;
				break;
			case 49:
				v624 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i624)));
			}
			switch(i624 - (l624 - 8)) {
			case 0:
				if(v624) {
					bs624 |= 128;
				} else {
					bs624 &= -129;
				}
				break;
			case 1:
				if(v624) {
					bs624 |= 64;
				} else {
					bs624 &= -65;
				}
				break;
			case 2:
				if(v624) {
					bs624 |= 32;
				} else {
					bs624 &= -33;
				}
				break;
			case 3:
				if(v624) {
					bs624 |= 16;
				} else {
					bs624 &= -17;
				}
				break;
			case 4:
				if(v624) {
					bs624 |= 8;
				} else {
					bs624 &= -9;
				}
				break;
			case 5:
				if(v624) {
					bs624 |= 4;
				} else {
					bs624 &= -5;
				}
				break;
			case 6:
				if(v624) {
					bs624 |= 2;
				} else {
					bs624 &= -3;
				}
				break;
			case 7:
				if(v624) {
					bs624 |= 1;
				} else {
					bs624 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs624;
		var this626 = 0;
		var bs625 = this626;
		var l625 = "*   *".length;
		var _g1625 = 0;
		var _g725 = l625;
		while(_g1625 < _g725) {
			var i625 = _g1625++;
			var no625 = "*   *".charCodeAt(i625);
			if(no625 == null) {
				break;
			}
			var v625;
			switch(no625) {
			case 32:
				v625 = false;
				break;
			case 42:
				v625 = true;
				break;
			case 48:
				v625 = false;
				break;
			case 49:
				v625 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i625)));
			}
			switch(i625 - (l625 - 8)) {
			case 0:
				if(v625) {
					bs625 |= 128;
				} else {
					bs625 &= -129;
				}
				break;
			case 1:
				if(v625) {
					bs625 |= 64;
				} else {
					bs625 &= -65;
				}
				break;
			case 2:
				if(v625) {
					bs625 |= 32;
				} else {
					bs625 &= -33;
				}
				break;
			case 3:
				if(v625) {
					bs625 |= 16;
				} else {
					bs625 &= -17;
				}
				break;
			case 4:
				if(v625) {
					bs625 |= 8;
				} else {
					bs625 &= -9;
				}
				break;
			case 5:
				if(v625) {
					bs625 |= 4;
				} else {
					bs625 &= -5;
				}
				break;
			case 6:
				if(v625) {
					bs625 |= 2;
				} else {
					bs625 &= -3;
				}
				break;
			case 7:
				if(v625) {
					bs625 |= 1;
				} else {
					bs625 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs625;
		var this627 = 0;
		var bs626 = this627;
		var l626 = "*   *".length;
		var _g1626 = 0;
		var _g726 = l626;
		while(_g1626 < _g726) {
			var i626 = _g1626++;
			var no626 = "*   *".charCodeAt(i626);
			if(no626 == null) {
				break;
			}
			var v626;
			switch(no626) {
			case 32:
				v626 = false;
				break;
			case 42:
				v626 = true;
				break;
			case 48:
				v626 = false;
				break;
			case 49:
				v626 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*   *".charCodeAt(i626)));
			}
			switch(i626 - (l626 - 8)) {
			case 0:
				if(v626) {
					bs626 |= 128;
				} else {
					bs626 &= -129;
				}
				break;
			case 1:
				if(v626) {
					bs626 |= 64;
				} else {
					bs626 &= -65;
				}
				break;
			case 2:
				if(v626) {
					bs626 |= 32;
				} else {
					bs626 &= -33;
				}
				break;
			case 3:
				if(v626) {
					bs626 |= 16;
				} else {
					bs626 &= -17;
				}
				break;
			case 4:
				if(v626) {
					bs626 |= 8;
				} else {
					bs626 &= -9;
				}
				break;
			case 5:
				if(v626) {
					bs626 |= 4;
				} else {
					bs626 &= -5;
				}
				break;
			case 6:
				if(v626) {
					bs626 |= 2;
				} else {
					bs626 &= -3;
				}
				break;
			case 7:
				if(v626) {
					bs626 |= 1;
				} else {
					bs626 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs626;
		var this628 = 0;
		var bs627 = this628;
		var l627 = " ****".length;
		var _g1627 = 0;
		var _g727 = l627;
		while(_g1627 < _g727) {
			var i627 = _g1627++;
			var no627 = " ****".charCodeAt(i627);
			if(no627 == null) {
				break;
			}
			var v627;
			switch(no627) {
			case 32:
				v627 = false;
				break;
			case 42:
				v627 = true;
				break;
			case 48:
				v627 = false;
				break;
			case 49:
				v627 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ****".charCodeAt(i627)));
			}
			switch(i627 - (l627 - 8)) {
			case 0:
				if(v627) {
					bs627 |= 128;
				} else {
					bs627 &= -129;
				}
				break;
			case 1:
				if(v627) {
					bs627 |= 64;
				} else {
					bs627 &= -65;
				}
				break;
			case 2:
				if(v627) {
					bs627 |= 32;
				} else {
					bs627 &= -33;
				}
				break;
			case 3:
				if(v627) {
					bs627 |= 16;
				} else {
					bs627 &= -17;
				}
				break;
			case 4:
				if(v627) {
					bs627 |= 8;
				} else {
					bs627 &= -9;
				}
				break;
			case 5:
				if(v627) {
					bs627 |= 4;
				} else {
					bs627 &= -5;
				}
				break;
			case 6:
				if(v627) {
					bs627 |= 2;
				} else {
					bs627 &= -3;
				}
				break;
			case 7:
				if(v627) {
					bs627 |= 1;
				} else {
					bs627 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs627;
		var this629 = 0;
		var bs628 = this629;
		var l628 = "    *".length;
		var _g1628 = 0;
		var _g728 = l628;
		while(_g1628 < _g728) {
			var i628 = _g1628++;
			var no628 = "    *".charCodeAt(i628);
			if(no628 == null) {
				break;
			}
			var v628;
			switch(no628) {
			case 32:
				v628 = false;
				break;
			case 42:
				v628 = true;
				break;
			case 48:
				v628 = false;
				break;
			case 49:
				v628 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("    *".charCodeAt(i628)));
			}
			switch(i628 - (l628 - 8)) {
			case 0:
				if(v628) {
					bs628 |= 128;
				} else {
					bs628 &= -129;
				}
				break;
			case 1:
				if(v628) {
					bs628 |= 64;
				} else {
					bs628 &= -65;
				}
				break;
			case 2:
				if(v628) {
					bs628 |= 32;
				} else {
					bs628 &= -33;
				}
				break;
			case 3:
				if(v628) {
					bs628 |= 16;
				} else {
					bs628 &= -17;
				}
				break;
			case 4:
				if(v628) {
					bs628 |= 8;
				} else {
					bs628 &= -9;
				}
				break;
			case 5:
				if(v628) {
					bs628 |= 4;
				} else {
					bs628 &= -5;
				}
				break;
			case 6:
				if(v628) {
					bs628 |= 2;
				} else {
					bs628 &= -3;
				}
				break;
			case 7:
				if(v628) {
					bs628 |= 1;
				} else {
					bs628 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs628;
		var this630 = 0;
		var bs629 = this630;
		var l629 = " *** ".length;
		var _g1629 = 0;
		var _g729 = l629;
		while(_g1629 < _g729) {
			var i629 = _g1629++;
			var no629 = " *** ".charCodeAt(i629);
			if(no629 == null) {
				break;
			}
			var v629;
			switch(no629) {
			case 32:
				v629 = false;
				break;
			case 42:
				v629 = true;
				break;
			case 48:
				v629 = false;
				break;
			case 49:
				v629 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *** ".charCodeAt(i629)));
			}
			switch(i629 - (l629 - 8)) {
			case 0:
				if(v629) {
					bs629 |= 128;
				} else {
					bs629 &= -129;
				}
				break;
			case 1:
				if(v629) {
					bs629 |= 64;
				} else {
					bs629 &= -65;
				}
				break;
			case 2:
				if(v629) {
					bs629 |= 32;
				} else {
					bs629 &= -33;
				}
				break;
			case 3:
				if(v629) {
					bs629 |= 16;
				} else {
					bs629 &= -17;
				}
				break;
			case 4:
				if(v629) {
					bs629 |= 8;
				} else {
					bs629 &= -9;
				}
				break;
			case 5:
				if(v629) {
					bs629 |= 4;
				} else {
					bs629 &= -5;
				}
				break;
			case 6:
				if(v629) {
					bs629 |= 2;
				} else {
					bs629 &= -3;
				}
				break;
			case 7:
				if(v629) {
					bs629 |= 1;
				} else {
					bs629 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs629;
		break;
	case 122:
		var this631 = 0;
		var bs630 = this631;
		var l630 = "     ".length;
		var _g1630 = 0;
		var _g730 = l630;
		while(_g1630 < _g730) {
			var i630 = _g1630++;
			var no630 = "     ".charCodeAt(i630);
			if(no630 == null) {
				break;
			}
			var v630;
			switch(no630) {
			case 32:
				v630 = false;
				break;
			case 42:
				v630 = true;
				break;
			case 48:
				v630 = false;
				break;
			case 49:
				v630 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i630)));
			}
			switch(i630 - (l630 - 8)) {
			case 0:
				if(v630) {
					bs630 |= 128;
				} else {
					bs630 &= -129;
				}
				break;
			case 1:
				if(v630) {
					bs630 |= 64;
				} else {
					bs630 &= -65;
				}
				break;
			case 2:
				if(v630) {
					bs630 |= 32;
				} else {
					bs630 &= -33;
				}
				break;
			case 3:
				if(v630) {
					bs630 |= 16;
				} else {
					bs630 &= -17;
				}
				break;
			case 4:
				if(v630) {
					bs630 |= 8;
				} else {
					bs630 &= -9;
				}
				break;
			case 5:
				if(v630) {
					bs630 |= 4;
				} else {
					bs630 &= -5;
				}
				break;
			case 6:
				if(v630) {
					bs630 |= 2;
				} else {
					bs630 &= -3;
				}
				break;
			case 7:
				if(v630) {
					bs630 |= 1;
				} else {
					bs630 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs630;
		var this632 = 0;
		var bs631 = this632;
		var l631 = "     ".length;
		var _g1631 = 0;
		var _g731 = l631;
		while(_g1631 < _g731) {
			var i631 = _g1631++;
			var no631 = "     ".charCodeAt(i631);
			if(no631 == null) {
				break;
			}
			var v631;
			switch(no631) {
			case 32:
				v631 = false;
				break;
			case 42:
				v631 = true;
				break;
			case 48:
				v631 = false;
				break;
			case 49:
				v631 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i631)));
			}
			switch(i631 - (l631 - 8)) {
			case 0:
				if(v631) {
					bs631 |= 128;
				} else {
					bs631 &= -129;
				}
				break;
			case 1:
				if(v631) {
					bs631 |= 64;
				} else {
					bs631 &= -65;
				}
				break;
			case 2:
				if(v631) {
					bs631 |= 32;
				} else {
					bs631 &= -33;
				}
				break;
			case 3:
				if(v631) {
					bs631 |= 16;
				} else {
					bs631 &= -17;
				}
				break;
			case 4:
				if(v631) {
					bs631 |= 8;
				} else {
					bs631 &= -9;
				}
				break;
			case 5:
				if(v631) {
					bs631 |= 4;
				} else {
					bs631 &= -5;
				}
				break;
			case 6:
				if(v631) {
					bs631 |= 2;
				} else {
					bs631 &= -3;
				}
				break;
			case 7:
				if(v631) {
					bs631 |= 1;
				} else {
					bs631 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs631;
		var this633 = 0;
		var bs632 = this633;
		var l632 = "*****".length;
		var _g1632 = 0;
		var _g732 = l632;
		while(_g1632 < _g732) {
			var i632 = _g1632++;
			var no632 = "*****".charCodeAt(i632);
			if(no632 == null) {
				break;
			}
			var v632;
			switch(no632) {
			case 32:
				v632 = false;
				break;
			case 42:
				v632 = true;
				break;
			case 48:
				v632 = false;
				break;
			case 49:
				v632 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i632)));
			}
			switch(i632 - (l632 - 8)) {
			case 0:
				if(v632) {
					bs632 |= 128;
				} else {
					bs632 &= -129;
				}
				break;
			case 1:
				if(v632) {
					bs632 |= 64;
				} else {
					bs632 &= -65;
				}
				break;
			case 2:
				if(v632) {
					bs632 |= 32;
				} else {
					bs632 &= -33;
				}
				break;
			case 3:
				if(v632) {
					bs632 |= 16;
				} else {
					bs632 &= -17;
				}
				break;
			case 4:
				if(v632) {
					bs632 |= 8;
				} else {
					bs632 &= -9;
				}
				break;
			case 5:
				if(v632) {
					bs632 |= 4;
				} else {
					bs632 &= -5;
				}
				break;
			case 6:
				if(v632) {
					bs632 |= 2;
				} else {
					bs632 &= -3;
				}
				break;
			case 7:
				if(v632) {
					bs632 |= 1;
				} else {
					bs632 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs632;
		var this634 = 0;
		var bs633 = this634;
		var l633 = "   * ".length;
		var _g1633 = 0;
		var _g733 = l633;
		while(_g1633 < _g733) {
			var i633 = _g1633++;
			var no633 = "   * ".charCodeAt(i633);
			if(no633 == null) {
				break;
			}
			var v633;
			switch(no633) {
			case 32:
				v633 = false;
				break;
			case 42:
				v633 = true;
				break;
			case 48:
				v633 = false;
				break;
			case 49:
				v633 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i633)));
			}
			switch(i633 - (l633 - 8)) {
			case 0:
				if(v633) {
					bs633 |= 128;
				} else {
					bs633 &= -129;
				}
				break;
			case 1:
				if(v633) {
					bs633 |= 64;
				} else {
					bs633 &= -65;
				}
				break;
			case 2:
				if(v633) {
					bs633 |= 32;
				} else {
					bs633 &= -33;
				}
				break;
			case 3:
				if(v633) {
					bs633 |= 16;
				} else {
					bs633 &= -17;
				}
				break;
			case 4:
				if(v633) {
					bs633 |= 8;
				} else {
					bs633 &= -9;
				}
				break;
			case 5:
				if(v633) {
					bs633 |= 4;
				} else {
					bs633 &= -5;
				}
				break;
			case 6:
				if(v633) {
					bs633 |= 2;
				} else {
					bs633 &= -3;
				}
				break;
			case 7:
				if(v633) {
					bs633 |= 1;
				} else {
					bs633 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs633;
		var this635 = 0;
		var bs634 = this635;
		var l634 = "  *  ".length;
		var _g1634 = 0;
		var _g734 = l634;
		while(_g1634 < _g734) {
			var i634 = _g1634++;
			var no634 = "  *  ".charCodeAt(i634);
			if(no634 == null) {
				break;
			}
			var v634;
			switch(no634) {
			case 32:
				v634 = false;
				break;
			case 42:
				v634 = true;
				break;
			case 48:
				v634 = false;
				break;
			case 49:
				v634 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i634)));
			}
			switch(i634 - (l634 - 8)) {
			case 0:
				if(v634) {
					bs634 |= 128;
				} else {
					bs634 &= -129;
				}
				break;
			case 1:
				if(v634) {
					bs634 |= 64;
				} else {
					bs634 &= -65;
				}
				break;
			case 2:
				if(v634) {
					bs634 |= 32;
				} else {
					bs634 &= -33;
				}
				break;
			case 3:
				if(v634) {
					bs634 |= 16;
				} else {
					bs634 &= -17;
				}
				break;
			case 4:
				if(v634) {
					bs634 |= 8;
				} else {
					bs634 &= -9;
				}
				break;
			case 5:
				if(v634) {
					bs634 |= 4;
				} else {
					bs634 &= -5;
				}
				break;
			case 6:
				if(v634) {
					bs634 |= 2;
				} else {
					bs634 &= -3;
				}
				break;
			case 7:
				if(v634) {
					bs634 |= 1;
				} else {
					bs634 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs634;
		var this636 = 0;
		var bs635 = this636;
		var l635 = " *   ".length;
		var _g1635 = 0;
		var _g735 = l635;
		while(_g1635 < _g735) {
			var i635 = _g1635++;
			var no635 = " *   ".charCodeAt(i635);
			if(no635 == null) {
				break;
			}
			var v635;
			switch(no635) {
			case 32:
				v635 = false;
				break;
			case 42:
				v635 = true;
				break;
			case 48:
				v635 = false;
				break;
			case 49:
				v635 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i635)));
			}
			switch(i635 - (l635 - 8)) {
			case 0:
				if(v635) {
					bs635 |= 128;
				} else {
					bs635 &= -129;
				}
				break;
			case 1:
				if(v635) {
					bs635 |= 64;
				} else {
					bs635 &= -65;
				}
				break;
			case 2:
				if(v635) {
					bs635 |= 32;
				} else {
					bs635 &= -33;
				}
				break;
			case 3:
				if(v635) {
					bs635 |= 16;
				} else {
					bs635 &= -17;
				}
				break;
			case 4:
				if(v635) {
					bs635 |= 8;
				} else {
					bs635 &= -9;
				}
				break;
			case 5:
				if(v635) {
					bs635 |= 4;
				} else {
					bs635 &= -5;
				}
				break;
			case 6:
				if(v635) {
					bs635 |= 2;
				} else {
					bs635 &= -3;
				}
				break;
			case 7:
				if(v635) {
					bs635 |= 1;
				} else {
					bs635 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs635;
		var this637 = 0;
		var bs636 = this637;
		var l636 = "*****".length;
		var _g1636 = 0;
		var _g736 = l636;
		while(_g1636 < _g736) {
			var i636 = _g1636++;
			var no636 = "*****".charCodeAt(i636);
			if(no636 == null) {
				break;
			}
			var v636;
			switch(no636) {
			case 32:
				v636 = false;
				break;
			case 42:
				v636 = true;
				break;
			case 48:
				v636 = false;
				break;
			case 49:
				v636 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*****".charCodeAt(i636)));
			}
			switch(i636 - (l636 - 8)) {
			case 0:
				if(v636) {
					bs636 |= 128;
				} else {
					bs636 &= -129;
				}
				break;
			case 1:
				if(v636) {
					bs636 |= 64;
				} else {
					bs636 &= -65;
				}
				break;
			case 2:
				if(v636) {
					bs636 |= 32;
				} else {
					bs636 &= -33;
				}
				break;
			case 3:
				if(v636) {
					bs636 |= 16;
				} else {
					bs636 &= -17;
				}
				break;
			case 4:
				if(v636) {
					bs636 |= 8;
				} else {
					bs636 &= -9;
				}
				break;
			case 5:
				if(v636) {
					bs636 |= 4;
				} else {
					bs636 &= -5;
				}
				break;
			case 6:
				if(v636) {
					bs636 |= 2;
				} else {
					bs636 &= -3;
				}
				break;
			case 7:
				if(v636) {
					bs636 |= 1;
				} else {
					bs636 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs636;
		break;
	case 123:
		var this638 = 0;
		var bs637 = this638;
		var l637 = "   * ".length;
		var _g1637 = 0;
		var _g737 = l637;
		while(_g1637 < _g737) {
			var i637 = _g1637++;
			var no637 = "   * ".charCodeAt(i637);
			if(no637 == null) {
				break;
			}
			var v637;
			switch(no637) {
			case 32:
				v637 = false;
				break;
			case 42:
				v637 = true;
				break;
			case 48:
				v637 = false;
				break;
			case 49:
				v637 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i637)));
			}
			switch(i637 - (l637 - 8)) {
			case 0:
				if(v637) {
					bs637 |= 128;
				} else {
					bs637 &= -129;
				}
				break;
			case 1:
				if(v637) {
					bs637 |= 64;
				} else {
					bs637 &= -65;
				}
				break;
			case 2:
				if(v637) {
					bs637 |= 32;
				} else {
					bs637 &= -33;
				}
				break;
			case 3:
				if(v637) {
					bs637 |= 16;
				} else {
					bs637 &= -17;
				}
				break;
			case 4:
				if(v637) {
					bs637 |= 8;
				} else {
					bs637 &= -9;
				}
				break;
			case 5:
				if(v637) {
					bs637 |= 4;
				} else {
					bs637 &= -5;
				}
				break;
			case 6:
				if(v637) {
					bs637 |= 2;
				} else {
					bs637 &= -3;
				}
				break;
			case 7:
				if(v637) {
					bs637 |= 1;
				} else {
					bs637 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs637;
		var this639 = 0;
		var bs638 = this639;
		var l638 = "  *  ".length;
		var _g1638 = 0;
		var _g738 = l638;
		while(_g1638 < _g738) {
			var i638 = _g1638++;
			var no638 = "  *  ".charCodeAt(i638);
			if(no638 == null) {
				break;
			}
			var v638;
			switch(no638) {
			case 32:
				v638 = false;
				break;
			case 42:
				v638 = true;
				break;
			case 48:
				v638 = false;
				break;
			case 49:
				v638 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i638)));
			}
			switch(i638 - (l638 - 8)) {
			case 0:
				if(v638) {
					bs638 |= 128;
				} else {
					bs638 &= -129;
				}
				break;
			case 1:
				if(v638) {
					bs638 |= 64;
				} else {
					bs638 &= -65;
				}
				break;
			case 2:
				if(v638) {
					bs638 |= 32;
				} else {
					bs638 &= -33;
				}
				break;
			case 3:
				if(v638) {
					bs638 |= 16;
				} else {
					bs638 &= -17;
				}
				break;
			case 4:
				if(v638) {
					bs638 |= 8;
				} else {
					bs638 &= -9;
				}
				break;
			case 5:
				if(v638) {
					bs638 |= 4;
				} else {
					bs638 &= -5;
				}
				break;
			case 6:
				if(v638) {
					bs638 |= 2;
				} else {
					bs638 &= -3;
				}
				break;
			case 7:
				if(v638) {
					bs638 |= 1;
				} else {
					bs638 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs638;
		var this640 = 0;
		var bs639 = this640;
		var l639 = "  *  ".length;
		var _g1639 = 0;
		var _g739 = l639;
		while(_g1639 < _g739) {
			var i639 = _g1639++;
			var no639 = "  *  ".charCodeAt(i639);
			if(no639 == null) {
				break;
			}
			var v639;
			switch(no639) {
			case 32:
				v639 = false;
				break;
			case 42:
				v639 = true;
				break;
			case 48:
				v639 = false;
				break;
			case 49:
				v639 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i639)));
			}
			switch(i639 - (l639 - 8)) {
			case 0:
				if(v639) {
					bs639 |= 128;
				} else {
					bs639 &= -129;
				}
				break;
			case 1:
				if(v639) {
					bs639 |= 64;
				} else {
					bs639 &= -65;
				}
				break;
			case 2:
				if(v639) {
					bs639 |= 32;
				} else {
					bs639 &= -33;
				}
				break;
			case 3:
				if(v639) {
					bs639 |= 16;
				} else {
					bs639 &= -17;
				}
				break;
			case 4:
				if(v639) {
					bs639 |= 8;
				} else {
					bs639 &= -9;
				}
				break;
			case 5:
				if(v639) {
					bs639 |= 4;
				} else {
					bs639 &= -5;
				}
				break;
			case 6:
				if(v639) {
					bs639 |= 2;
				} else {
					bs639 &= -3;
				}
				break;
			case 7:
				if(v639) {
					bs639 |= 1;
				} else {
					bs639 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs639;
		var this641 = 0;
		var bs640 = this641;
		var l640 = " *   ".length;
		var _g1640 = 0;
		var _g740 = l640;
		while(_g1640 < _g740) {
			var i640 = _g1640++;
			var no640 = " *   ".charCodeAt(i640);
			if(no640 == null) {
				break;
			}
			var v640;
			switch(no640) {
			case 32:
				v640 = false;
				break;
			case 42:
				v640 = true;
				break;
			case 48:
				v640 = false;
				break;
			case 49:
				v640 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i640)));
			}
			switch(i640 - (l640 - 8)) {
			case 0:
				if(v640) {
					bs640 |= 128;
				} else {
					bs640 &= -129;
				}
				break;
			case 1:
				if(v640) {
					bs640 |= 64;
				} else {
					bs640 &= -65;
				}
				break;
			case 2:
				if(v640) {
					bs640 |= 32;
				} else {
					bs640 &= -33;
				}
				break;
			case 3:
				if(v640) {
					bs640 |= 16;
				} else {
					bs640 &= -17;
				}
				break;
			case 4:
				if(v640) {
					bs640 |= 8;
				} else {
					bs640 &= -9;
				}
				break;
			case 5:
				if(v640) {
					bs640 |= 4;
				} else {
					bs640 &= -5;
				}
				break;
			case 6:
				if(v640) {
					bs640 |= 2;
				} else {
					bs640 &= -3;
				}
				break;
			case 7:
				if(v640) {
					bs640 |= 1;
				} else {
					bs640 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs640;
		var this642 = 0;
		var bs641 = this642;
		var l641 = "  *  ".length;
		var _g1641 = 0;
		var _g741 = l641;
		while(_g1641 < _g741) {
			var i641 = _g1641++;
			var no641 = "  *  ".charCodeAt(i641);
			if(no641 == null) {
				break;
			}
			var v641;
			switch(no641) {
			case 32:
				v641 = false;
				break;
			case 42:
				v641 = true;
				break;
			case 48:
				v641 = false;
				break;
			case 49:
				v641 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i641)));
			}
			switch(i641 - (l641 - 8)) {
			case 0:
				if(v641) {
					bs641 |= 128;
				} else {
					bs641 &= -129;
				}
				break;
			case 1:
				if(v641) {
					bs641 |= 64;
				} else {
					bs641 &= -65;
				}
				break;
			case 2:
				if(v641) {
					bs641 |= 32;
				} else {
					bs641 &= -33;
				}
				break;
			case 3:
				if(v641) {
					bs641 |= 16;
				} else {
					bs641 &= -17;
				}
				break;
			case 4:
				if(v641) {
					bs641 |= 8;
				} else {
					bs641 &= -9;
				}
				break;
			case 5:
				if(v641) {
					bs641 |= 4;
				} else {
					bs641 &= -5;
				}
				break;
			case 6:
				if(v641) {
					bs641 |= 2;
				} else {
					bs641 &= -3;
				}
				break;
			case 7:
				if(v641) {
					bs641 |= 1;
				} else {
					bs641 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs641;
		var this643 = 0;
		var bs642 = this643;
		var l642 = "  *  ".length;
		var _g1642 = 0;
		var _g742 = l642;
		while(_g1642 < _g742) {
			var i642 = _g1642++;
			var no642 = "  *  ".charCodeAt(i642);
			if(no642 == null) {
				break;
			}
			var v642;
			switch(no642) {
			case 32:
				v642 = false;
				break;
			case 42:
				v642 = true;
				break;
			case 48:
				v642 = false;
				break;
			case 49:
				v642 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i642)));
			}
			switch(i642 - (l642 - 8)) {
			case 0:
				if(v642) {
					bs642 |= 128;
				} else {
					bs642 &= -129;
				}
				break;
			case 1:
				if(v642) {
					bs642 |= 64;
				} else {
					bs642 &= -65;
				}
				break;
			case 2:
				if(v642) {
					bs642 |= 32;
				} else {
					bs642 &= -33;
				}
				break;
			case 3:
				if(v642) {
					bs642 |= 16;
				} else {
					bs642 &= -17;
				}
				break;
			case 4:
				if(v642) {
					bs642 |= 8;
				} else {
					bs642 &= -9;
				}
				break;
			case 5:
				if(v642) {
					bs642 |= 4;
				} else {
					bs642 &= -5;
				}
				break;
			case 6:
				if(v642) {
					bs642 |= 2;
				} else {
					bs642 &= -3;
				}
				break;
			case 7:
				if(v642) {
					bs642 |= 1;
				} else {
					bs642 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs642;
		var this644 = 0;
		var bs643 = this644;
		var l643 = "   * ".length;
		var _g1643 = 0;
		var _g743 = l643;
		while(_g1643 < _g743) {
			var i643 = _g1643++;
			var no643 = "   * ".charCodeAt(i643);
			if(no643 == null) {
				break;
			}
			var v643;
			switch(no643) {
			case 32:
				v643 = false;
				break;
			case 42:
				v643 = true;
				break;
			case 48:
				v643 = false;
				break;
			case 49:
				v643 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i643)));
			}
			switch(i643 - (l643 - 8)) {
			case 0:
				if(v643) {
					bs643 |= 128;
				} else {
					bs643 &= -129;
				}
				break;
			case 1:
				if(v643) {
					bs643 |= 64;
				} else {
					bs643 &= -65;
				}
				break;
			case 2:
				if(v643) {
					bs643 |= 32;
				} else {
					bs643 &= -33;
				}
				break;
			case 3:
				if(v643) {
					bs643 |= 16;
				} else {
					bs643 &= -17;
				}
				break;
			case 4:
				if(v643) {
					bs643 |= 8;
				} else {
					bs643 &= -9;
				}
				break;
			case 5:
				if(v643) {
					bs643 |= 4;
				} else {
					bs643 &= -5;
				}
				break;
			case 6:
				if(v643) {
					bs643 |= 2;
				} else {
					bs643 &= -3;
				}
				break;
			case 7:
				if(v643) {
					bs643 |= 1;
				} else {
					bs643 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs643;
		break;
	case 124:
		var this645 = 0;
		var bs644 = this645;
		var l644 = "  *  ".length;
		var _g1644 = 0;
		var _g744 = l644;
		while(_g1644 < _g744) {
			var i644 = _g1644++;
			var no644 = "  *  ".charCodeAt(i644);
			if(no644 == null) {
				break;
			}
			var v644;
			switch(no644) {
			case 32:
				v644 = false;
				break;
			case 42:
				v644 = true;
				break;
			case 48:
				v644 = false;
				break;
			case 49:
				v644 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i644)));
			}
			switch(i644 - (l644 - 8)) {
			case 0:
				if(v644) {
					bs644 |= 128;
				} else {
					bs644 &= -129;
				}
				break;
			case 1:
				if(v644) {
					bs644 |= 64;
				} else {
					bs644 &= -65;
				}
				break;
			case 2:
				if(v644) {
					bs644 |= 32;
				} else {
					bs644 &= -33;
				}
				break;
			case 3:
				if(v644) {
					bs644 |= 16;
				} else {
					bs644 &= -17;
				}
				break;
			case 4:
				if(v644) {
					bs644 |= 8;
				} else {
					bs644 &= -9;
				}
				break;
			case 5:
				if(v644) {
					bs644 |= 4;
				} else {
					bs644 &= -5;
				}
				break;
			case 6:
				if(v644) {
					bs644 |= 2;
				} else {
					bs644 &= -3;
				}
				break;
			case 7:
				if(v644) {
					bs644 |= 1;
				} else {
					bs644 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs644;
		var this646 = 0;
		var bs645 = this646;
		var l645 = "  *  ".length;
		var _g1645 = 0;
		var _g745 = l645;
		while(_g1645 < _g745) {
			var i645 = _g1645++;
			var no645 = "  *  ".charCodeAt(i645);
			if(no645 == null) {
				break;
			}
			var v645;
			switch(no645) {
			case 32:
				v645 = false;
				break;
			case 42:
				v645 = true;
				break;
			case 48:
				v645 = false;
				break;
			case 49:
				v645 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i645)));
			}
			switch(i645 - (l645 - 8)) {
			case 0:
				if(v645) {
					bs645 |= 128;
				} else {
					bs645 &= -129;
				}
				break;
			case 1:
				if(v645) {
					bs645 |= 64;
				} else {
					bs645 &= -65;
				}
				break;
			case 2:
				if(v645) {
					bs645 |= 32;
				} else {
					bs645 &= -33;
				}
				break;
			case 3:
				if(v645) {
					bs645 |= 16;
				} else {
					bs645 &= -17;
				}
				break;
			case 4:
				if(v645) {
					bs645 |= 8;
				} else {
					bs645 &= -9;
				}
				break;
			case 5:
				if(v645) {
					bs645 |= 4;
				} else {
					bs645 &= -5;
				}
				break;
			case 6:
				if(v645) {
					bs645 |= 2;
				} else {
					bs645 &= -3;
				}
				break;
			case 7:
				if(v645) {
					bs645 |= 1;
				} else {
					bs645 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs645;
		var this647 = 0;
		var bs646 = this647;
		var l646 = "  *  ".length;
		var _g1646 = 0;
		var _g746 = l646;
		while(_g1646 < _g746) {
			var i646 = _g1646++;
			var no646 = "  *  ".charCodeAt(i646);
			if(no646 == null) {
				break;
			}
			var v646;
			switch(no646) {
			case 32:
				v646 = false;
				break;
			case 42:
				v646 = true;
				break;
			case 48:
				v646 = false;
				break;
			case 49:
				v646 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i646)));
			}
			switch(i646 - (l646 - 8)) {
			case 0:
				if(v646) {
					bs646 |= 128;
				} else {
					bs646 &= -129;
				}
				break;
			case 1:
				if(v646) {
					bs646 |= 64;
				} else {
					bs646 &= -65;
				}
				break;
			case 2:
				if(v646) {
					bs646 |= 32;
				} else {
					bs646 &= -33;
				}
				break;
			case 3:
				if(v646) {
					bs646 |= 16;
				} else {
					bs646 &= -17;
				}
				break;
			case 4:
				if(v646) {
					bs646 |= 8;
				} else {
					bs646 &= -9;
				}
				break;
			case 5:
				if(v646) {
					bs646 |= 4;
				} else {
					bs646 &= -5;
				}
				break;
			case 6:
				if(v646) {
					bs646 |= 2;
				} else {
					bs646 &= -3;
				}
				break;
			case 7:
				if(v646) {
					bs646 |= 1;
				} else {
					bs646 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs646;
		var this648 = 0;
		var bs647 = this648;
		var l647 = "  *  ".length;
		var _g1647 = 0;
		var _g747 = l647;
		while(_g1647 < _g747) {
			var i647 = _g1647++;
			var no647 = "  *  ".charCodeAt(i647);
			if(no647 == null) {
				break;
			}
			var v647;
			switch(no647) {
			case 32:
				v647 = false;
				break;
			case 42:
				v647 = true;
				break;
			case 48:
				v647 = false;
				break;
			case 49:
				v647 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i647)));
			}
			switch(i647 - (l647 - 8)) {
			case 0:
				if(v647) {
					bs647 |= 128;
				} else {
					bs647 &= -129;
				}
				break;
			case 1:
				if(v647) {
					bs647 |= 64;
				} else {
					bs647 &= -65;
				}
				break;
			case 2:
				if(v647) {
					bs647 |= 32;
				} else {
					bs647 &= -33;
				}
				break;
			case 3:
				if(v647) {
					bs647 |= 16;
				} else {
					bs647 &= -17;
				}
				break;
			case 4:
				if(v647) {
					bs647 |= 8;
				} else {
					bs647 &= -9;
				}
				break;
			case 5:
				if(v647) {
					bs647 |= 4;
				} else {
					bs647 &= -5;
				}
				break;
			case 6:
				if(v647) {
					bs647 |= 2;
				} else {
					bs647 &= -3;
				}
				break;
			case 7:
				if(v647) {
					bs647 |= 1;
				} else {
					bs647 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs647;
		var this649 = 0;
		var bs648 = this649;
		var l648 = "  *  ".length;
		var _g1648 = 0;
		var _g748 = l648;
		while(_g1648 < _g748) {
			var i648 = _g1648++;
			var no648 = "  *  ".charCodeAt(i648);
			if(no648 == null) {
				break;
			}
			var v648;
			switch(no648) {
			case 32:
				v648 = false;
				break;
			case 42:
				v648 = true;
				break;
			case 48:
				v648 = false;
				break;
			case 49:
				v648 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i648)));
			}
			switch(i648 - (l648 - 8)) {
			case 0:
				if(v648) {
					bs648 |= 128;
				} else {
					bs648 &= -129;
				}
				break;
			case 1:
				if(v648) {
					bs648 |= 64;
				} else {
					bs648 &= -65;
				}
				break;
			case 2:
				if(v648) {
					bs648 |= 32;
				} else {
					bs648 &= -33;
				}
				break;
			case 3:
				if(v648) {
					bs648 |= 16;
				} else {
					bs648 &= -17;
				}
				break;
			case 4:
				if(v648) {
					bs648 |= 8;
				} else {
					bs648 &= -9;
				}
				break;
			case 5:
				if(v648) {
					bs648 |= 4;
				} else {
					bs648 &= -5;
				}
				break;
			case 6:
				if(v648) {
					bs648 |= 2;
				} else {
					bs648 &= -3;
				}
				break;
			case 7:
				if(v648) {
					bs648 |= 1;
				} else {
					bs648 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs648;
		var this650 = 0;
		var bs649 = this650;
		var l649 = "  *  ".length;
		var _g1649 = 0;
		var _g749 = l649;
		while(_g1649 < _g749) {
			var i649 = _g1649++;
			var no649 = "  *  ".charCodeAt(i649);
			if(no649 == null) {
				break;
			}
			var v649;
			switch(no649) {
			case 32:
				v649 = false;
				break;
			case 42:
				v649 = true;
				break;
			case 48:
				v649 = false;
				break;
			case 49:
				v649 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i649)));
			}
			switch(i649 - (l649 - 8)) {
			case 0:
				if(v649) {
					bs649 |= 128;
				} else {
					bs649 &= -129;
				}
				break;
			case 1:
				if(v649) {
					bs649 |= 64;
				} else {
					bs649 &= -65;
				}
				break;
			case 2:
				if(v649) {
					bs649 |= 32;
				} else {
					bs649 &= -33;
				}
				break;
			case 3:
				if(v649) {
					bs649 |= 16;
				} else {
					bs649 &= -17;
				}
				break;
			case 4:
				if(v649) {
					bs649 |= 8;
				} else {
					bs649 &= -9;
				}
				break;
			case 5:
				if(v649) {
					bs649 |= 4;
				} else {
					bs649 &= -5;
				}
				break;
			case 6:
				if(v649) {
					bs649 |= 2;
				} else {
					bs649 &= -3;
				}
				break;
			case 7:
				if(v649) {
					bs649 |= 1;
				} else {
					bs649 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs649;
		var this651 = 0;
		var bs650 = this651;
		var l650 = "  *  ".length;
		var _g1650 = 0;
		var _g750 = l650;
		while(_g1650 < _g750) {
			var i650 = _g1650++;
			var no650 = "  *  ".charCodeAt(i650);
			if(no650 == null) {
				break;
			}
			var v650;
			switch(no650) {
			case 32:
				v650 = false;
				break;
			case 42:
				v650 = true;
				break;
			case 48:
				v650 = false;
				break;
			case 49:
				v650 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i650)));
			}
			switch(i650 - (l650 - 8)) {
			case 0:
				if(v650) {
					bs650 |= 128;
				} else {
					bs650 &= -129;
				}
				break;
			case 1:
				if(v650) {
					bs650 |= 64;
				} else {
					bs650 &= -65;
				}
				break;
			case 2:
				if(v650) {
					bs650 |= 32;
				} else {
					bs650 &= -33;
				}
				break;
			case 3:
				if(v650) {
					bs650 |= 16;
				} else {
					bs650 &= -17;
				}
				break;
			case 4:
				if(v650) {
					bs650 |= 8;
				} else {
					bs650 &= -9;
				}
				break;
			case 5:
				if(v650) {
					bs650 |= 4;
				} else {
					bs650 &= -5;
				}
				break;
			case 6:
				if(v650) {
					bs650 |= 2;
				} else {
					bs650 &= -3;
				}
				break;
			case 7:
				if(v650) {
					bs650 |= 1;
				} else {
					bs650 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs650;
		break;
	case 125:
		var this652 = 0;
		var bs651 = this652;
		var l651 = "   * ".length;
		var _g1651 = 0;
		var _g751 = l651;
		while(_g1651 < _g751) {
			var i651 = _g1651++;
			var no651 = "   * ".charCodeAt(i651);
			if(no651 == null) {
				break;
			}
			var v651;
			switch(no651) {
			case 32:
				v651 = false;
				break;
			case 42:
				v651 = true;
				break;
			case 48:
				v651 = false;
				break;
			case 49:
				v651 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i651)));
			}
			switch(i651 - (l651 - 8)) {
			case 0:
				if(v651) {
					bs651 |= 128;
				} else {
					bs651 &= -129;
				}
				break;
			case 1:
				if(v651) {
					bs651 |= 64;
				} else {
					bs651 &= -65;
				}
				break;
			case 2:
				if(v651) {
					bs651 |= 32;
				} else {
					bs651 &= -33;
				}
				break;
			case 3:
				if(v651) {
					bs651 |= 16;
				} else {
					bs651 &= -17;
				}
				break;
			case 4:
				if(v651) {
					bs651 |= 8;
				} else {
					bs651 &= -9;
				}
				break;
			case 5:
				if(v651) {
					bs651 |= 4;
				} else {
					bs651 &= -5;
				}
				break;
			case 6:
				if(v651) {
					bs651 |= 2;
				} else {
					bs651 &= -3;
				}
				break;
			case 7:
				if(v651) {
					bs651 |= 1;
				} else {
					bs651 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs651;
		var this653 = 0;
		var bs652 = this653;
		var l652 = "  *  ".length;
		var _g1652 = 0;
		var _g752 = l652;
		while(_g1652 < _g752) {
			var i652 = _g1652++;
			var no652 = "  *  ".charCodeAt(i652);
			if(no652 == null) {
				break;
			}
			var v652;
			switch(no652) {
			case 32:
				v652 = false;
				break;
			case 42:
				v652 = true;
				break;
			case 48:
				v652 = false;
				break;
			case 49:
				v652 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i652)));
			}
			switch(i652 - (l652 - 8)) {
			case 0:
				if(v652) {
					bs652 |= 128;
				} else {
					bs652 &= -129;
				}
				break;
			case 1:
				if(v652) {
					bs652 |= 64;
				} else {
					bs652 &= -65;
				}
				break;
			case 2:
				if(v652) {
					bs652 |= 32;
				} else {
					bs652 &= -33;
				}
				break;
			case 3:
				if(v652) {
					bs652 |= 16;
				} else {
					bs652 &= -17;
				}
				break;
			case 4:
				if(v652) {
					bs652 |= 8;
				} else {
					bs652 &= -9;
				}
				break;
			case 5:
				if(v652) {
					bs652 |= 4;
				} else {
					bs652 &= -5;
				}
				break;
			case 6:
				if(v652) {
					bs652 |= 2;
				} else {
					bs652 &= -3;
				}
				break;
			case 7:
				if(v652) {
					bs652 |= 1;
				} else {
					bs652 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs652;
		var this654 = 0;
		var bs653 = this654;
		var l653 = "  *  ".length;
		var _g1653 = 0;
		var _g753 = l653;
		while(_g1653 < _g753) {
			var i653 = _g1653++;
			var no653 = "  *  ".charCodeAt(i653);
			if(no653 == null) {
				break;
			}
			var v653;
			switch(no653) {
			case 32:
				v653 = false;
				break;
			case 42:
				v653 = true;
				break;
			case 48:
				v653 = false;
				break;
			case 49:
				v653 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i653)));
			}
			switch(i653 - (l653 - 8)) {
			case 0:
				if(v653) {
					bs653 |= 128;
				} else {
					bs653 &= -129;
				}
				break;
			case 1:
				if(v653) {
					bs653 |= 64;
				} else {
					bs653 &= -65;
				}
				break;
			case 2:
				if(v653) {
					bs653 |= 32;
				} else {
					bs653 &= -33;
				}
				break;
			case 3:
				if(v653) {
					bs653 |= 16;
				} else {
					bs653 &= -17;
				}
				break;
			case 4:
				if(v653) {
					bs653 |= 8;
				} else {
					bs653 &= -9;
				}
				break;
			case 5:
				if(v653) {
					bs653 |= 4;
				} else {
					bs653 &= -5;
				}
				break;
			case 6:
				if(v653) {
					bs653 |= 2;
				} else {
					bs653 &= -3;
				}
				break;
			case 7:
				if(v653) {
					bs653 |= 1;
				} else {
					bs653 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs653;
		var this655 = 0;
		var bs654 = this655;
		var l654 = " *   ".length;
		var _g1654 = 0;
		var _g754 = l654;
		while(_g1654 < _g754) {
			var i654 = _g1654++;
			var no654 = " *   ".charCodeAt(i654);
			if(no654 == null) {
				break;
			}
			var v654;
			switch(no654) {
			case 32:
				v654 = false;
				break;
			case 42:
				v654 = true;
				break;
			case 48:
				v654 = false;
				break;
			case 49:
				v654 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" *   ".charCodeAt(i654)));
			}
			switch(i654 - (l654 - 8)) {
			case 0:
				if(v654) {
					bs654 |= 128;
				} else {
					bs654 &= -129;
				}
				break;
			case 1:
				if(v654) {
					bs654 |= 64;
				} else {
					bs654 &= -65;
				}
				break;
			case 2:
				if(v654) {
					bs654 |= 32;
				} else {
					bs654 &= -33;
				}
				break;
			case 3:
				if(v654) {
					bs654 |= 16;
				} else {
					bs654 &= -17;
				}
				break;
			case 4:
				if(v654) {
					bs654 |= 8;
				} else {
					bs654 &= -9;
				}
				break;
			case 5:
				if(v654) {
					bs654 |= 4;
				} else {
					bs654 &= -5;
				}
				break;
			case 6:
				if(v654) {
					bs654 |= 2;
				} else {
					bs654 &= -3;
				}
				break;
			case 7:
				if(v654) {
					bs654 |= 1;
				} else {
					bs654 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs654;
		var this656 = 0;
		var bs655 = this656;
		var l655 = "  *  ".length;
		var _g1655 = 0;
		var _g755 = l655;
		while(_g1655 < _g755) {
			var i655 = _g1655++;
			var no655 = "  *  ".charCodeAt(i655);
			if(no655 == null) {
				break;
			}
			var v655;
			switch(no655) {
			case 32:
				v655 = false;
				break;
			case 42:
				v655 = true;
				break;
			case 48:
				v655 = false;
				break;
			case 49:
				v655 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i655)));
			}
			switch(i655 - (l655 - 8)) {
			case 0:
				if(v655) {
					bs655 |= 128;
				} else {
					bs655 &= -129;
				}
				break;
			case 1:
				if(v655) {
					bs655 |= 64;
				} else {
					bs655 &= -65;
				}
				break;
			case 2:
				if(v655) {
					bs655 |= 32;
				} else {
					bs655 &= -33;
				}
				break;
			case 3:
				if(v655) {
					bs655 |= 16;
				} else {
					bs655 &= -17;
				}
				break;
			case 4:
				if(v655) {
					bs655 |= 8;
				} else {
					bs655 &= -9;
				}
				break;
			case 5:
				if(v655) {
					bs655 |= 4;
				} else {
					bs655 &= -5;
				}
				break;
			case 6:
				if(v655) {
					bs655 |= 2;
				} else {
					bs655 &= -3;
				}
				break;
			case 7:
				if(v655) {
					bs655 |= 1;
				} else {
					bs655 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs655;
		var this657 = 0;
		var bs656 = this657;
		var l656 = "  *  ".length;
		var _g1656 = 0;
		var _g756 = l656;
		while(_g1656 < _g756) {
			var i656 = _g1656++;
			var no656 = "  *  ".charCodeAt(i656);
			if(no656 == null) {
				break;
			}
			var v656;
			switch(no656) {
			case 32:
				v656 = false;
				break;
			case 42:
				v656 = true;
				break;
			case 48:
				v656 = false;
				break;
			case 49:
				v656 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("  *  ".charCodeAt(i656)));
			}
			switch(i656 - (l656 - 8)) {
			case 0:
				if(v656) {
					bs656 |= 128;
				} else {
					bs656 &= -129;
				}
				break;
			case 1:
				if(v656) {
					bs656 |= 64;
				} else {
					bs656 &= -65;
				}
				break;
			case 2:
				if(v656) {
					bs656 |= 32;
				} else {
					bs656 &= -33;
				}
				break;
			case 3:
				if(v656) {
					bs656 |= 16;
				} else {
					bs656 &= -17;
				}
				break;
			case 4:
				if(v656) {
					bs656 |= 8;
				} else {
					bs656 &= -9;
				}
				break;
			case 5:
				if(v656) {
					bs656 |= 4;
				} else {
					bs656 &= -5;
				}
				break;
			case 6:
				if(v656) {
					bs656 |= 2;
				} else {
					bs656 &= -3;
				}
				break;
			case 7:
				if(v656) {
					bs656 |= 1;
				} else {
					bs656 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs656;
		var this658 = 0;
		var bs657 = this658;
		var l657 = "   * ".length;
		var _g1657 = 0;
		var _g757 = l657;
		while(_g1657 < _g757) {
			var i657 = _g1657++;
			var no657 = "   * ".charCodeAt(i657);
			if(no657 == null) {
				break;
			}
			var v657;
			switch(no657) {
			case 32:
				v657 = false;
				break;
			case 42:
				v657 = true;
				break;
			case 48:
				v657 = false;
				break;
			case 49:
				v657 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("   * ".charCodeAt(i657)));
			}
			switch(i657 - (l657 - 8)) {
			case 0:
				if(v657) {
					bs657 |= 128;
				} else {
					bs657 &= -129;
				}
				break;
			case 1:
				if(v657) {
					bs657 |= 64;
				} else {
					bs657 &= -65;
				}
				break;
			case 2:
				if(v657) {
					bs657 |= 32;
				} else {
					bs657 &= -33;
				}
				break;
			case 3:
				if(v657) {
					bs657 |= 16;
				} else {
					bs657 &= -17;
				}
				break;
			case 4:
				if(v657) {
					bs657 |= 8;
				} else {
					bs657 &= -9;
				}
				break;
			case 5:
				if(v657) {
					bs657 |= 4;
				} else {
					bs657 &= -5;
				}
				break;
			case 6:
				if(v657) {
					bs657 |= 2;
				} else {
					bs657 &= -3;
				}
				break;
			case 7:
				if(v657) {
					bs657 |= 1;
				} else {
					bs657 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs657;
		break;
	case 126:
		var this659 = 0;
		var bs658 = this659;
		var l658 = " ** *".length;
		var _g1658 = 0;
		var _g758 = l658;
		while(_g1658 < _g758) {
			var i658 = _g1658++;
			var no658 = " ** *".charCodeAt(i658);
			if(no658 == null) {
				break;
			}
			var v658;
			switch(no658) {
			case 32:
				v658 = false;
				break;
			case 42:
				v658 = true;
				break;
			case 48:
				v658 = false;
				break;
			case 49:
				v658 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string(" ** *".charCodeAt(i658)));
			}
			switch(i658 - (l658 - 8)) {
			case 0:
				if(v658) {
					bs658 |= 128;
				} else {
					bs658 &= -129;
				}
				break;
			case 1:
				if(v658) {
					bs658 |= 64;
				} else {
					bs658 &= -65;
				}
				break;
			case 2:
				if(v658) {
					bs658 |= 32;
				} else {
					bs658 &= -33;
				}
				break;
			case 3:
				if(v658) {
					bs658 |= 16;
				} else {
					bs658 &= -17;
				}
				break;
			case 4:
				if(v658) {
					bs658 |= 8;
				} else {
					bs658 &= -9;
				}
				break;
			case 5:
				if(v658) {
					bs658 |= 4;
				} else {
					bs658 &= -5;
				}
				break;
			case 6:
				if(v658) {
					bs658 |= 2;
				} else {
					bs658 &= -3;
				}
				break;
			case 7:
				if(v658) {
					bs658 |= 1;
				} else {
					bs658 &= -2;
				}
				break;
			default:
			}
		}
		arr[0] = bs658;
		var this660 = 0;
		var bs659 = this660;
		var l659 = "*  * ".length;
		var _g1659 = 0;
		var _g759 = l659;
		while(_g1659 < _g759) {
			var i659 = _g1659++;
			var no659 = "*  * ".charCodeAt(i659);
			if(no659 == null) {
				break;
			}
			var v659;
			switch(no659) {
			case 32:
				v659 = false;
				break;
			case 42:
				v659 = true;
				break;
			case 48:
				v659 = false;
				break;
			case 49:
				v659 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("*  * ".charCodeAt(i659)));
			}
			switch(i659 - (l659 - 8)) {
			case 0:
				if(v659) {
					bs659 |= 128;
				} else {
					bs659 &= -129;
				}
				break;
			case 1:
				if(v659) {
					bs659 |= 64;
				} else {
					bs659 &= -65;
				}
				break;
			case 2:
				if(v659) {
					bs659 |= 32;
				} else {
					bs659 &= -33;
				}
				break;
			case 3:
				if(v659) {
					bs659 |= 16;
				} else {
					bs659 &= -17;
				}
				break;
			case 4:
				if(v659) {
					bs659 |= 8;
				} else {
					bs659 &= -9;
				}
				break;
			case 5:
				if(v659) {
					bs659 |= 4;
				} else {
					bs659 &= -5;
				}
				break;
			case 6:
				if(v659) {
					bs659 |= 2;
				} else {
					bs659 &= -3;
				}
				break;
			case 7:
				if(v659) {
					bs659 |= 1;
				} else {
					bs659 &= -2;
				}
				break;
			default:
			}
		}
		arr[1] = bs659;
		var this661 = 0;
		var bs660 = this661;
		var l660 = "     ".length;
		var _g1660 = 0;
		var _g760 = l660;
		while(_g1660 < _g760) {
			var i660 = _g1660++;
			var no660 = "     ".charCodeAt(i660);
			if(no660 == null) {
				break;
			}
			var v660;
			switch(no660) {
			case 32:
				v660 = false;
				break;
			case 42:
				v660 = true;
				break;
			case 48:
				v660 = false;
				break;
			case 49:
				v660 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i660)));
			}
			switch(i660 - (l660 - 8)) {
			case 0:
				if(v660) {
					bs660 |= 128;
				} else {
					bs660 &= -129;
				}
				break;
			case 1:
				if(v660) {
					bs660 |= 64;
				} else {
					bs660 &= -65;
				}
				break;
			case 2:
				if(v660) {
					bs660 |= 32;
				} else {
					bs660 &= -33;
				}
				break;
			case 3:
				if(v660) {
					bs660 |= 16;
				} else {
					bs660 &= -17;
				}
				break;
			case 4:
				if(v660) {
					bs660 |= 8;
				} else {
					bs660 &= -9;
				}
				break;
			case 5:
				if(v660) {
					bs660 |= 4;
				} else {
					bs660 &= -5;
				}
				break;
			case 6:
				if(v660) {
					bs660 |= 2;
				} else {
					bs660 &= -3;
				}
				break;
			case 7:
				if(v660) {
					bs660 |= 1;
				} else {
					bs660 &= -2;
				}
				break;
			default:
			}
		}
		arr[2] = bs660;
		var this662 = 0;
		var bs661 = this662;
		var l661 = "     ".length;
		var _g1661 = 0;
		var _g761 = l661;
		while(_g1661 < _g761) {
			var i661 = _g1661++;
			var no661 = "     ".charCodeAt(i661);
			if(no661 == null) {
				break;
			}
			var v661;
			switch(no661) {
			case 32:
				v661 = false;
				break;
			case 42:
				v661 = true;
				break;
			case 48:
				v661 = false;
				break;
			case 49:
				v661 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i661)));
			}
			switch(i661 - (l661 - 8)) {
			case 0:
				if(v661) {
					bs661 |= 128;
				} else {
					bs661 &= -129;
				}
				break;
			case 1:
				if(v661) {
					bs661 |= 64;
				} else {
					bs661 &= -65;
				}
				break;
			case 2:
				if(v661) {
					bs661 |= 32;
				} else {
					bs661 &= -33;
				}
				break;
			case 3:
				if(v661) {
					bs661 |= 16;
				} else {
					bs661 &= -17;
				}
				break;
			case 4:
				if(v661) {
					bs661 |= 8;
				} else {
					bs661 &= -9;
				}
				break;
			case 5:
				if(v661) {
					bs661 |= 4;
				} else {
					bs661 &= -5;
				}
				break;
			case 6:
				if(v661) {
					bs661 |= 2;
				} else {
					bs661 &= -3;
				}
				break;
			case 7:
				if(v661) {
					bs661 |= 1;
				} else {
					bs661 &= -2;
				}
				break;
			default:
			}
		}
		arr[3] = bs661;
		var this663 = 0;
		var bs662 = this663;
		var l662 = "     ".length;
		var _g1662 = 0;
		var _g762 = l662;
		while(_g1662 < _g762) {
			var i662 = _g1662++;
			var no662 = "     ".charCodeAt(i662);
			if(no662 == null) {
				break;
			}
			var v662;
			switch(no662) {
			case 32:
				v662 = false;
				break;
			case 42:
				v662 = true;
				break;
			case 48:
				v662 = false;
				break;
			case 49:
				v662 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i662)));
			}
			switch(i662 - (l662 - 8)) {
			case 0:
				if(v662) {
					bs662 |= 128;
				} else {
					bs662 &= -129;
				}
				break;
			case 1:
				if(v662) {
					bs662 |= 64;
				} else {
					bs662 &= -65;
				}
				break;
			case 2:
				if(v662) {
					bs662 |= 32;
				} else {
					bs662 &= -33;
				}
				break;
			case 3:
				if(v662) {
					bs662 |= 16;
				} else {
					bs662 &= -17;
				}
				break;
			case 4:
				if(v662) {
					bs662 |= 8;
				} else {
					bs662 &= -9;
				}
				break;
			case 5:
				if(v662) {
					bs662 |= 4;
				} else {
					bs662 &= -5;
				}
				break;
			case 6:
				if(v662) {
					bs662 |= 2;
				} else {
					bs662 &= -3;
				}
				break;
			case 7:
				if(v662) {
					bs662 |= 1;
				} else {
					bs662 &= -2;
				}
				break;
			default:
			}
		}
		arr[4] = bs662;
		var this664 = 0;
		var bs663 = this664;
		var l663 = "     ".length;
		var _g1663 = 0;
		var _g763 = l663;
		while(_g1663 < _g763) {
			var i663 = _g1663++;
			var no663 = "     ".charCodeAt(i663);
			if(no663 == null) {
				break;
			}
			var v663;
			switch(no663) {
			case 32:
				v663 = false;
				break;
			case 42:
				v663 = true;
				break;
			case 48:
				v663 = false;
				break;
			case 49:
				v663 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i663)));
			}
			switch(i663 - (l663 - 8)) {
			case 0:
				if(v663) {
					bs663 |= 128;
				} else {
					bs663 &= -129;
				}
				break;
			case 1:
				if(v663) {
					bs663 |= 64;
				} else {
					bs663 &= -65;
				}
				break;
			case 2:
				if(v663) {
					bs663 |= 32;
				} else {
					bs663 &= -33;
				}
				break;
			case 3:
				if(v663) {
					bs663 |= 16;
				} else {
					bs663 &= -17;
				}
				break;
			case 4:
				if(v663) {
					bs663 |= 8;
				} else {
					bs663 &= -9;
				}
				break;
			case 5:
				if(v663) {
					bs663 |= 4;
				} else {
					bs663 &= -5;
				}
				break;
			case 6:
				if(v663) {
					bs663 |= 2;
				} else {
					bs663 &= -3;
				}
				break;
			case 7:
				if(v663) {
					bs663 |= 1;
				} else {
					bs663 &= -2;
				}
				break;
			default:
			}
		}
		arr[5] = bs663;
		var this665 = 0;
		var bs664 = this665;
		var l664 = "     ".length;
		var _g1664 = 0;
		var _g764 = l664;
		while(_g1664 < _g764) {
			var i664 = _g1664++;
			var no664 = "     ".charCodeAt(i664);
			if(no664 == null) {
				break;
			}
			var v664;
			switch(no664) {
			case 32:
				v664 = false;
				break;
			case 42:
				v664 = true;
				break;
			case 48:
				v664 = false;
				break;
			case 49:
				v664 = true;
				break;
			default:
				throw new js__$Boot_HaxeError("Bits digits must be 0 or 1 " + Std.string("     ".charCodeAt(i664)));
			}
			switch(i664 - (l664 - 8)) {
			case 0:
				if(v664) {
					bs664 |= 128;
				} else {
					bs664 &= -129;
				}
				break;
			case 1:
				if(v664) {
					bs664 |= 64;
				} else {
					bs664 &= -65;
				}
				break;
			case 2:
				if(v664) {
					bs664 |= 32;
				} else {
					bs664 &= -33;
				}
				break;
			case 3:
				if(v664) {
					bs664 |= 16;
				} else {
					bs664 &= -17;
				}
				break;
			case 4:
				if(v664) {
					bs664 |= 8;
				} else {
					bs664 &= -9;
				}
				break;
			case 5:
				if(v664) {
					bs664 |= 4;
				} else {
					bs664 &= -5;
				}
				break;
			case 6:
				if(v664) {
					bs664 |= 2;
				} else {
					bs664 &= -3;
				}
				break;
			case 7:
				if(v664) {
					bs664 |= 1;
				} else {
					bs664 &= -2;
				}
				break;
			default:
			}
		}
		arr[6] = bs664;
		break;
	}
	return trilateralXtra_segment__$DotMatrix_DotMatrix_$Impl_$._new(arr);
};
function $iterator(o) { if( o instanceof Array ) return function() { return HxOverrides.iter(o); }; return typeof(o.iterator) == 'function' ? $bind(o,o.iterator) : o.iterator; }
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
$hxClasses["Math"] = Math;
String.prototype.__class__ = $hxClasses["String"] = String;
String.__name__ = true;
$hxClasses["Array"] = Array;
Array.__name__ = true;
Date.prototype.__class__ = $hxClasses["Date"] = Date;
Date.__name__ = ["Date"];
var Int = $hxClasses["Int"] = { __name__ : ["Int"]};
var Dynamic = $hxClasses["Dynamic"] = { __name__ : ["Dynamic"]};
var Float = $hxClasses["Float"] = Number;
Float.__name__ = ["Float"];
var Bool = $hxClasses["Bool"] = Boolean;
Bool.__ename__ = ["Bool"];
var Class = $hxClasses["Class"] = { __name__ : ["Class"]};
var Enum = { };
var __map_reserved = {};
var ArrayBuffer = $global.ArrayBuffer || js_html_compat_ArrayBuffer;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_html_compat_ArrayBuffer.sliceImpl;
}
var DataView = $global.DataView || js_html_compat_DataView;
var Float32Array = $global.Float32Array || js_html_compat_Float32Array._new;
var Uint8Array = $global.Uint8Array || js_html_compat_Uint8Array._new;
haxe_Unserializer.DEFAULT_RESOLVER = new haxe__$Unserializer_DefaultResolver();
haxe_Unserializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS);
haxe_ds_ObjectMap.count = 0;
haxe_io_FPHelper.i64tmp = (function($this) {
	var $r;
	var this1 = new haxe__$Int64__$_$_$Int64(0,0);
	$r = this1;
	return $r;
}(this));
js_Boot.__toStr = ({ }).toString;
js_html_compat_Float32Array.BYTES_PER_ELEMENT = 4;
js_html_compat_Uint8Array.BYTES_PER_ELEMENT = 1;
kha_Assets.images = new kha__$Assets_ImageList();
kha_Assets.sounds = new kha__$Assets_SoundList();
kha_Assets.blobs = new kha__$Assets_BlobList();
kha_Assets.fonts = new kha__$Assets_FontList();
kha_Assets.videos = new kha__$Assets_VideoList();
kha__$Color_Color_$Impl_$.Black = -16777216;
kha__$Color_Color_$Impl_$.White = -1;
kha__$Color_Color_$Impl_$.Red = -65536;
kha__$Color_Color_$Impl_$.Blue = -16776961;
kha__$Color_Color_$Impl_$.Green = -16711936;
kha__$Color_Color_$Impl_$.Magenta = -65281;
kha__$Color_Color_$Impl_$.Yellow = -256;
kha__$Color_Color_$Impl_$.Cyan = -16711681;
kha__$Color_Color_$Impl_$.Purple = -8388480;
kha__$Color_Color_$Impl_$.Pink = -16181;
kha__$Color_Color_$Impl_$.Orange = -23296;
kha__$Color_Color_$Impl_$.Transparent = 0;
kha__$Color_Color_$Impl_$.invMaxChannelValue = 0.00392156862745098;
kha_CompilerDefines.js = "1";
kha_CompilerDefines.kha_a1 = "1";
kha_CompilerDefines.kha_g3 = "1";
kha_CompilerDefines.kha_html5_js = "1";
kha_CompilerDefines["source-header"] = "Generated by Haxe 3.4.4";
kha_CompilerDefines.jquery_ver = "11204";
kha_CompilerDefines.kha_js = "1";
kha_CompilerDefines.sys_html5 = "1";
kha_CompilerDefines.sys_g4 = "1";
kha_CompilerDefines.sys_g2 = "1";
kha_CompilerDefines.kha_webgl = "1";
kha_CompilerDefines.kha = "1";
kha_CompilerDefines.kha_g2 = "1";
kha_CompilerDefines.trilateral = "1";
kha_CompilerDefines.kha_g4 = "1";
kha_CompilerDefines.sys_g3 = "1";
kha_CompilerDefines.kha_g1 = "1";
kha_CompilerDefines.sys_a1 = "1";
kha_CompilerDefines.trilateralXtra = "1";
kha_CompilerDefines.haxe_ver = "3.404";
kha_CompilerDefines.canvas_id = "khanvas";
kha_CompilerDefines.kha_version = "1611";
kha_CompilerDefines.js_es = "5";
kha_CompilerDefines.kha_html5 = "1";
kha_CompilerDefines["js-es5"] = "1";
kha_CompilerDefines.js_es5 = "1";
kha_CompilerDefines.sys_a2 = "1";
kha_CompilerDefines.dce = "std";
kha_CompilerDefines.sys_g1 = "1";
kha_CompilerDefines["true"] = "1";
kha_CompilerDefines.haxe3 = "1";
kha_CompilerDefines.kha_a2 = "1";
kha_CompilerDefines.script_name = "kha";
kha_FontStyle.Default = new kha_FontStyle(false,false,false);
kha_Kravur.glyphs = (function($this) {
	var $r;
	var _g = [];
	{
		var _g1 = 32;
		while(_g1 < 256) {
			var i = _g1++;
			_g.push(i);
		}
	}
	$r = _g;
	return $r;
}(this));
kha_Scheduler.timeWarpSaveTime = 10.0;
kha_Scheduler.DIF_COUNT = 3;
kha_Scheduler.maxframetime = 0.5;
kha_Scheduler.startTime = 0;
kha_Shaders.painter_colored_fragData0 = "s198:I3ZlcnNpb24gMTAwCnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwpwcmVjaXNpb24gaGlnaHAgaW50OwoKdmFyeWluZyBoaWdocCB2ZWM0IGZyYWdtZW50Q29sb3I7Cgp2b2lkIG1haW4oKQp7CiAgICBnbF9GcmFnRGF0YVswXSA9IGZyYWdtZW50Q29sb3I7Cn0KCg";
kha_Shaders.painter_colored_fragData1 = "s192:I3ZlcnNpb24gMTAwCnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwpwcmVjaXNpb24gbWVkaXVtcCBpbnQ7Cgp2YXJ5aW5nIHZlYzQgZnJhZ21lbnRDb2xvcjsKCnZvaWQgbWFpbigpCnsKICAgIGdsX0ZyYWdEYXRhWzBdID0gZnJhZ21lbnRDb2xvcjsKfQoK";
kha_Shaders.painter_colored_fragData2 = "s210:I3ZlcnNpb24gMzAwIGVzCnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwpwcmVjaXNpb24gbWVkaXVtcCBpbnQ7CgpvdXQgdmVjNCBGcmFnQ29sb3I7CmluIHZlYzQgZnJhZ21lbnRDb2xvcjsKCnZvaWQgbWFpbigpCnsKICAgIEZyYWdDb2xvciA9IGZyYWdtZW50Q29sb3I7Cn0KCg";
kha_Shaders.painter_colored_vertData0 = "s331:I3ZlcnNpb24gMTAwCgp1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsKCmF0dHJpYnV0ZSB2ZWMzIHZlcnRleFBvc2l0aW9uOwp2YXJ5aW5nIHZlYzQgZnJhZ21lbnRDb2xvcjsKYXR0cmlidXRlIHZlYzQgdmVydGV4Q29sb3I7Cgp2b2lkIG1haW4oKQp7CiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2ZWM0KHZlcnRleFBvc2l0aW9uLCAxLjApOwogICAgZnJhZ21lbnRDb2xvciA9IHZlcnRleENvbG9yOwp9Cgo";
kha_Shaders.painter_colored_vertData1 = "s374:I3ZlcnNpb24gMTAwCgp1bmlmb3JtIG1lZGl1bXAgbWF0NCBwcm9qZWN0aW9uTWF0cml4OwoKYXR0cmlidXRlIG1lZGl1bXAgdmVjMyB2ZXJ0ZXhQb3NpdGlvbjsKdmFyeWluZyBtZWRpdW1wIHZlYzQgZnJhZ21lbnRDb2xvcjsKYXR0cmlidXRlIG1lZGl1bXAgdmVjNCB2ZXJ0ZXhDb2xvcjsKCnZvaWQgbWFpbigpCnsKICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZlYzQodmVydGV4UG9zaXRpb24sIDEuMCk7CiAgICBmcmFnbWVudENvbG9yID0gdmVydGV4Q29sb3I7Cn0KCg";
kha_Shaders.painter_colored_vertData2 = "s354:I3ZlcnNpb24gMzAwIGVzCgp1bmlmb3JtIG1lZGl1bXAgbWF0NCBwcm9qZWN0aW9uTWF0cml4OwoKaW4gbWVkaXVtcCB2ZWMzIHZlcnRleFBvc2l0aW9uOwpvdXQgbWVkaXVtcCB2ZWM0IGZyYWdtZW50Q29sb3I7CmluIG1lZGl1bXAgdmVjNCB2ZXJ0ZXhDb2xvcjsKCnZvaWQgbWFpbigpCnsKICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZlYzQodmVydGV4UG9zaXRpb24sIDEuMCk7CiAgICBmcmFnbWVudENvbG9yID0gdmVydGV4Q29sb3I7Cn0KCg";
kha_Shaders.painter_image_fragData0 = "s471:I3ZlcnNpb24gMTAwCnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwpwcmVjaXNpb24gaGlnaHAgaW50OwoKdW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgdGV4OwoKdmFyeWluZyBoaWdocCB2ZWMyIHRleENvb3JkOwp2YXJ5aW5nIGhpZ2hwIHZlYzQgY29sb3I7Cgp2b2lkIG1haW4oKQp7CiAgICBoaWdocCB2ZWM0IHRleGNvbG9yID0gdGV4dHVyZTJEKHRleCwgdGV4Q29vcmQpICogY29sb3I7CiAgICBoaWdocCB2ZWMzIF8zMiA9IHRleGNvbG9yLnh5eiAqIGNvbG9yLnc7CiAgICB0ZXhjb2xvciA9IHZlYzQoXzMyLngsIF8zMi55LCBfMzIueiwgdGV4Y29sb3Iudyk7CiAgICBnbF9GcmFnRGF0YVswXSA9IHRleGNvbG9yOwp9Cgo";
kha_Shaders.painter_image_fragData1 = "s444:I3ZlcnNpb24gMTAwCnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwpwcmVjaXNpb24gbWVkaXVtcCBpbnQ7Cgp1bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIHRleDsKCnZhcnlpbmcgdmVjMiB0ZXhDb29yZDsKdmFyeWluZyB2ZWM0IGNvbG9yOwoKdm9pZCBtYWluKCkKewogICAgdmVjNCB0ZXhjb2xvciA9IHRleHR1cmUyRCh0ZXgsIHRleENvb3JkKSAqIGNvbG9yOwogICAgdmVjMyBfMzIgPSB0ZXhjb2xvci54eXogKiBjb2xvci53OwogICAgdGV4Y29sb3IgPSB2ZWM0KF8zMi54LCBfMzIueSwgXzMyLnosIHRleGNvbG9yLncpOwogICAgZ2xfRnJhZ0RhdGFbMF0gPSB0ZXhjb2xvcjsKfQoK";
kha_Shaders.painter_image_fragData2 = "s452:I3ZlcnNpb24gMzAwIGVzCnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwpwcmVjaXNpb24gbWVkaXVtcCBpbnQ7Cgp1bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIHRleDsKCmluIHZlYzIgdGV4Q29vcmQ7CmluIHZlYzQgY29sb3I7Cm91dCB2ZWM0IEZyYWdDb2xvcjsKCnZvaWQgbWFpbigpCnsKICAgIHZlYzQgdGV4Y29sb3IgPSB0ZXh0dXJlKHRleCwgdGV4Q29vcmQpICogY29sb3I7CiAgICB2ZWMzIF8zMiA9IHRleGNvbG9yLnh5eiAqIGNvbG9yLnc7CiAgICB0ZXhjb2xvciA9IHZlYzQoXzMyLngsIF8zMi55LCBfMzIueiwgdGV4Y29sb3Iudyk7CiAgICBGcmFnQ29sb3IgPSB0ZXhjb2xvcjsKfQoK";
kha_Shaders.painter_image_vertData0 = "s415:I3ZlcnNpb24gMTAwCgp1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsKCmF0dHJpYnV0ZSB2ZWMzIHZlcnRleFBvc2l0aW9uOwp2YXJ5aW5nIHZlYzIgdGV4Q29vcmQ7CmF0dHJpYnV0ZSB2ZWMyIHRleFBvc2l0aW9uOwp2YXJ5aW5nIHZlYzQgY29sb3I7CmF0dHJpYnV0ZSB2ZWM0IHZlcnRleENvbG9yOwoKdm9pZCBtYWluKCkKewogICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmVjNCh2ZXJ0ZXhQb3NpdGlvbiwgMS4wKTsKICAgIHRleENvb3JkID0gdGV4UG9zaXRpb247CiAgICBjb2xvciA9IHZlcnRleENvbG9yOwp9Cgo";
kha_Shaders.painter_image_vertData1 = "s479:I3ZlcnNpb24gMTAwCgp1bmlmb3JtIG1lZGl1bXAgbWF0NCBwcm9qZWN0aW9uTWF0cml4OwoKYXR0cmlidXRlIG1lZGl1bXAgdmVjMyB2ZXJ0ZXhQb3NpdGlvbjsKdmFyeWluZyBtZWRpdW1wIHZlYzIgdGV4Q29vcmQ7CmF0dHJpYnV0ZSBtZWRpdW1wIHZlYzIgdGV4UG9zaXRpb247CnZhcnlpbmcgbWVkaXVtcCB2ZWM0IGNvbG9yOwphdHRyaWJ1dGUgbWVkaXVtcCB2ZWM0IHZlcnRleENvbG9yOwoKdm9pZCBtYWluKCkKewogICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmVjNCh2ZXJ0ZXhQb3NpdGlvbiwgMS4wKTsKICAgIHRleENvb3JkID0gdGV4UG9zaXRpb247CiAgICBjb2xvciA9IHZlcnRleENvbG9yOwp9Cgo";
kha_Shaders.painter_image_vertData2 = "s444:I3ZlcnNpb24gMzAwIGVzCgp1bmlmb3JtIG1lZGl1bXAgbWF0NCBwcm9qZWN0aW9uTWF0cml4OwoKaW4gbWVkaXVtcCB2ZWMzIHZlcnRleFBvc2l0aW9uOwpvdXQgbWVkaXVtcCB2ZWMyIHRleENvb3JkOwppbiBtZWRpdW1wIHZlYzIgdGV4UG9zaXRpb247Cm91dCBtZWRpdW1wIHZlYzQgY29sb3I7CmluIG1lZGl1bXAgdmVjNCB2ZXJ0ZXhDb2xvcjsKCnZvaWQgbWFpbigpCnsKICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZlYzQodmVydGV4UG9zaXRpb24sIDEuMCk7CiAgICB0ZXhDb29yZCA9IHRleFBvc2l0aW9uOwogICAgY29sb3IgPSB2ZXJ0ZXhDb2xvcjsKfQoK";
kha_Shaders.painter_text_fragData0 = "s351:I3ZlcnNpb24gMTAwCnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwpwcmVjaXNpb24gaGlnaHAgaW50OwoKdW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgdGV4OwoKdmFyeWluZyBoaWdocCB2ZWM0IGZyYWdtZW50Q29sb3I7CnZhcnlpbmcgaGlnaHAgdmVjMiB0ZXhDb29yZDsKCnZvaWQgbWFpbigpCnsKICAgIGdsX0ZyYWdEYXRhWzBdID0gdmVjNChmcmFnbWVudENvbG9yLnh5eiwgdGV4dHVyZTJEKHRleCwgdGV4Q29vcmQpLnggKiBmcmFnbWVudENvbG9yLncpOwp9Cgo";
kha_Shaders.painter_text_fragData1 = "s340:I3ZlcnNpb24gMTAwCnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwpwcmVjaXNpb24gbWVkaXVtcCBpbnQ7Cgp1bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIHRleDsKCnZhcnlpbmcgdmVjNCBmcmFnbWVudENvbG9yOwp2YXJ5aW5nIHZlYzIgdGV4Q29vcmQ7Cgp2b2lkIG1haW4oKQp7CiAgICBnbF9GcmFnRGF0YVswXSA9IHZlYzQoZnJhZ21lbnRDb2xvci54eXosIHRleHR1cmUyRCh0ZXgsIHRleENvb3JkKS54ICogZnJhZ21lbnRDb2xvci53KTsKfQoK";
kha_Shaders.painter_text_fragData2 = "s348:I3ZlcnNpb24gMzAwIGVzCnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwpwcmVjaXNpb24gbWVkaXVtcCBpbnQ7Cgp1bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIHRleDsKCm91dCB2ZWM0IEZyYWdDb2xvcjsKaW4gdmVjNCBmcmFnbWVudENvbG9yOwppbiB2ZWMyIHRleENvb3JkOwoKdm9pZCBtYWluKCkKewogICAgRnJhZ0NvbG9yID0gdmVjNChmcmFnbWVudENvbG9yLnh5eiwgdGV4dHVyZSh0ZXgsIHRleENvb3JkKS54ICogZnJhZ21lbnRDb2xvci53KTsKfQoK";
kha_Shaders.painter_text_vertData0 = "s436:I3ZlcnNpb24gMTAwCgp1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsKCmF0dHJpYnV0ZSB2ZWMzIHZlcnRleFBvc2l0aW9uOwp2YXJ5aW5nIHZlYzIgdGV4Q29vcmQ7CmF0dHJpYnV0ZSB2ZWMyIHRleFBvc2l0aW9uOwp2YXJ5aW5nIHZlYzQgZnJhZ21lbnRDb2xvcjsKYXR0cmlidXRlIHZlYzQgdmVydGV4Q29sb3I7Cgp2b2lkIG1haW4oKQp7CiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2ZWM0KHZlcnRleFBvc2l0aW9uLCAxLjApOwogICAgdGV4Q29vcmQgPSB0ZXhQb3NpdGlvbjsKICAgIGZyYWdtZW50Q29sb3IgPSB2ZXJ0ZXhDb2xvcjsKfQoK";
kha_Shaders.painter_text_vertData1 = "s500:I3ZlcnNpb24gMTAwCgp1bmlmb3JtIG1lZGl1bXAgbWF0NCBwcm9qZWN0aW9uTWF0cml4OwoKYXR0cmlidXRlIG1lZGl1bXAgdmVjMyB2ZXJ0ZXhQb3NpdGlvbjsKdmFyeWluZyBtZWRpdW1wIHZlYzIgdGV4Q29vcmQ7CmF0dHJpYnV0ZSBtZWRpdW1wIHZlYzIgdGV4UG9zaXRpb247CnZhcnlpbmcgbWVkaXVtcCB2ZWM0IGZyYWdtZW50Q29sb3I7CmF0dHJpYnV0ZSBtZWRpdW1wIHZlYzQgdmVydGV4Q29sb3I7Cgp2b2lkIG1haW4oKQp7CiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2ZWM0KHZlcnRleFBvc2l0aW9uLCAxLjApOwogICAgdGV4Q29vcmQgPSB0ZXhQb3NpdGlvbjsKICAgIGZyYWdtZW50Q29sb3IgPSB2ZXJ0ZXhDb2xvcjsKfQoK";
kha_Shaders.painter_text_vertData2 = "s466:I3ZlcnNpb24gMzAwIGVzCgp1bmlmb3JtIG1lZGl1bXAgbWF0NCBwcm9qZWN0aW9uTWF0cml4OwoKaW4gbWVkaXVtcCB2ZWMzIHZlcnRleFBvc2l0aW9uOwpvdXQgbWVkaXVtcCB2ZWMyIHRleENvb3JkOwppbiBtZWRpdW1wIHZlYzIgdGV4UG9zaXRpb247Cm91dCBtZWRpdW1wIHZlYzQgZnJhZ21lbnRDb2xvcjsKaW4gbWVkaXVtcCB2ZWM0IHZlcnRleENvbG9yOwoKdm9pZCBtYWluKCkKewogICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmVjNCh2ZXJ0ZXhQb3NpdGlvbiwgMS4wKTsKICAgIHRleENvb3JkID0gdGV4UG9zaXRpb247CiAgICBmcmFnbWVudENvbG9yID0gdmVydGV4Q29sb3I7Cn0KCg";
kha_Shaders.painter_video_fragData0 = "s471:I3ZlcnNpb24gMTAwCnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwpwcmVjaXNpb24gaGlnaHAgaW50OwoKdW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgdGV4OwoKdmFyeWluZyBoaWdocCB2ZWMyIHRleENvb3JkOwp2YXJ5aW5nIGhpZ2hwIHZlYzQgY29sb3I7Cgp2b2lkIG1haW4oKQp7CiAgICBoaWdocCB2ZWM0IHRleGNvbG9yID0gdGV4dHVyZTJEKHRleCwgdGV4Q29vcmQpICogY29sb3I7CiAgICBoaWdocCB2ZWMzIF8zMiA9IHRleGNvbG9yLnh5eiAqIGNvbG9yLnc7CiAgICB0ZXhjb2xvciA9IHZlYzQoXzMyLngsIF8zMi55LCBfMzIueiwgdGV4Y29sb3Iudyk7CiAgICBnbF9GcmFnRGF0YVswXSA9IHRleGNvbG9yOwp9Cgo";
kha_Shaders.painter_video_fragData1 = "s444:I3ZlcnNpb24gMTAwCnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwpwcmVjaXNpb24gbWVkaXVtcCBpbnQ7Cgp1bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIHRleDsKCnZhcnlpbmcgdmVjMiB0ZXhDb29yZDsKdmFyeWluZyB2ZWM0IGNvbG9yOwoKdm9pZCBtYWluKCkKewogICAgdmVjNCB0ZXhjb2xvciA9IHRleHR1cmUyRCh0ZXgsIHRleENvb3JkKSAqIGNvbG9yOwogICAgdmVjMyBfMzIgPSB0ZXhjb2xvci54eXogKiBjb2xvci53OwogICAgdGV4Y29sb3IgPSB2ZWM0KF8zMi54LCBfMzIueSwgXzMyLnosIHRleGNvbG9yLncpOwogICAgZ2xfRnJhZ0RhdGFbMF0gPSB0ZXhjb2xvcjsKfQoK";
kha_Shaders.painter_video_fragData2 = "s452:I3ZlcnNpb24gMzAwIGVzCnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwpwcmVjaXNpb24gbWVkaXVtcCBpbnQ7Cgp1bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIHRleDsKCmluIHZlYzIgdGV4Q29vcmQ7CmluIHZlYzQgY29sb3I7Cm91dCB2ZWM0IEZyYWdDb2xvcjsKCnZvaWQgbWFpbigpCnsKICAgIHZlYzQgdGV4Y29sb3IgPSB0ZXh0dXJlKHRleCwgdGV4Q29vcmQpICogY29sb3I7CiAgICB2ZWMzIF8zMiA9IHRleGNvbG9yLnh5eiAqIGNvbG9yLnc7CiAgICB0ZXhjb2xvciA9IHZlYzQoXzMyLngsIF8zMi55LCBfMzIueiwgdGV4Y29sb3Iudyk7CiAgICBGcmFnQ29sb3IgPSB0ZXhjb2xvcjsKfQoK";
kha_Shaders.painter_video_vertData0 = "s415:I3ZlcnNpb24gMTAwCgp1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsKCmF0dHJpYnV0ZSB2ZWMzIHZlcnRleFBvc2l0aW9uOwp2YXJ5aW5nIHZlYzIgdGV4Q29vcmQ7CmF0dHJpYnV0ZSB2ZWMyIHRleFBvc2l0aW9uOwp2YXJ5aW5nIHZlYzQgY29sb3I7CmF0dHJpYnV0ZSB2ZWM0IHZlcnRleENvbG9yOwoKdm9pZCBtYWluKCkKewogICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmVjNCh2ZXJ0ZXhQb3NpdGlvbiwgMS4wKTsKICAgIHRleENvb3JkID0gdGV4UG9zaXRpb247CiAgICBjb2xvciA9IHZlcnRleENvbG9yOwp9Cgo";
kha_Shaders.painter_video_vertData1 = "s479:I3ZlcnNpb24gMTAwCgp1bmlmb3JtIG1lZGl1bXAgbWF0NCBwcm9qZWN0aW9uTWF0cml4OwoKYXR0cmlidXRlIG1lZGl1bXAgdmVjMyB2ZXJ0ZXhQb3NpdGlvbjsKdmFyeWluZyBtZWRpdW1wIHZlYzIgdGV4Q29vcmQ7CmF0dHJpYnV0ZSBtZWRpdW1wIHZlYzIgdGV4UG9zaXRpb247CnZhcnlpbmcgbWVkaXVtcCB2ZWM0IGNvbG9yOwphdHRyaWJ1dGUgbWVkaXVtcCB2ZWM0IHZlcnRleENvbG9yOwoKdm9pZCBtYWluKCkKewogICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmVjNCh2ZXJ0ZXhQb3NpdGlvbiwgMS4wKTsKICAgIHRleENvb3JkID0gdGV4UG9zaXRpb247CiAgICBjb2xvciA9IHZlcnRleENvbG9yOwp9Cgo";
kha_Shaders.painter_video_vertData2 = "s444:I3ZlcnNpb24gMzAwIGVzCgp1bmlmb3JtIG1lZGl1bXAgbWF0NCBwcm9qZWN0aW9uTWF0cml4OwoKaW4gbWVkaXVtcCB2ZWMzIHZlcnRleFBvc2l0aW9uOwpvdXQgbWVkaXVtcCB2ZWMyIHRleENvb3JkOwppbiBtZWRpdW1wIHZlYzIgdGV4UG9zaXRpb247Cm91dCBtZWRpdW1wIHZlYzQgY29sb3I7CmluIG1lZGl1bXAgdmVjNCB2ZXJ0ZXhDb2xvcjsKCnZvaWQgbWFpbigpCnsKICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZlYzQodmVydGV4UG9zaXRpb24sIDEuMCk7CiAgICB0ZXhDb29yZCA9IHRleFBvc2l0aW9uOwogICAgY29sb3IgPSB2ZXJ0ZXhDb2xvcjsKfQoK";
kha_System.renderListeners = [];
kha_System.foregroundListeners = [];
kha_System.resumeListeners = [];
kha_System.pauseListeners = [];
kha_System.backgroundListeners = [];
kha_System.shutdownListeners = [];
kha_System.dropFilesListeners = [];
kha_SystemImpl.mobile = false;
kha_SystemImpl.ios = false;
kha_SystemImpl.mobileAudioPlaying = false;
kha_SystemImpl.chrome = false;
kha_SystemImpl.firefox = false;
kha_SystemImpl.insideInputEvent = false;
kha_SystemImpl.maxGamepads = 4;
kha_SystemImpl.leftMouseCtrlDown = false;
kha_SystemImpl.minimumScroll = 999;
kha_SystemImpl.lastFirstTouchX = 0;
kha_SystemImpl.lastFirstTouchY = 0;
kha_SystemImpl.iosSoundEnabled = false;
kha_SystemImpl.iosTouchs = [];
kha_WebGLImage.GL_RGBA16F = 34842;
kha_WebGLImage.GL_RGBA32F = 34836;
kha_WebGLImage.GL_R16F = 33325;
kha_WebGLImage.GL_R32F = 33326;
kha_WebGLImage.GL_RED = 6403;
kha_WebGLImage.GL_DEPTH_COMPONENT24 = 33190;
kha_WebGLImage.GL_DEPTH24_STENCIL8 = 35056;
kha_WebGLImage.GL_DEPTH32F_STENCIL8 = 36013;
kha_audio2_Audio1.channelCount = 16;
kha_audio2_ogg_tools_Crc32.POLY = 79764919;
kha_audio2_ogg_vorbis_VorbisDecodeState.INVALID_BITS = -1;
kha_audio2_ogg_vorbis_VorbisTools.EOP = -1;
kha_audio2_ogg_vorbis_VorbisTools.M__PI = 3.14159265358979323846264;
kha_audio2_ogg_vorbis_VorbisTools.DIVTAB_NUMER = 32;
kha_audio2_ogg_vorbis_VorbisTools.DIVTAB_DENOM = 64;
kha_audio2_ogg_vorbis_VorbisTools.INVERSE_DB_TABLE = [1.0649863e-07,1.1341951e-07,1.2079015e-07,1.2863978e-07,1.3699951e-07,1.4590251e-07,1.5538408e-07,1.6548181e-07,1.7623575e-07,1.8768855e-07,1.9988561e-07,2.1287530e-07,2.2670913e-07,2.4144197e-07,2.5713223e-07,2.7384213e-07,2.9163793e-07,3.1059021e-07,3.3077411e-07,3.5226968e-07,3.7516214e-07,3.9954229e-07,4.2550680e-07,4.5315863e-07,4.8260743e-07,5.1396998e-07,5.4737065e-07,5.8294187e-07,6.2082472e-07,6.6116941e-07,7.0413592e-07,7.4989464e-07,7.9862701e-07,8.5052630e-07,9.0579828e-07,9.6466216e-07,1.0273513e-06,1.0941144e-06,1.1652161e-06,1.2409384e-06,1.3215816e-06,1.4074654e-06,1.4989305e-06,1.5963394e-06,1.7000785e-06,1.8105592e-06,1.9282195e-06,2.0535261e-06,2.1869758e-06,2.3290978e-06,2.4804557e-06,2.6416497e-06,2.8133190e-06,2.9961443e-06,3.1908506e-06,3.3982101e-06,3.6190449e-06,3.8542308e-06,4.1047004e-06,4.3714470e-06,4.6555282e-06,4.9580707e-06,5.2802740e-06,5.6234160e-06,5.9888572e-06,6.3780469e-06,6.7925283e-06,7.2339451e-06,7.7040476e-06,8.2047000e-06,8.7378876e-06,9.3057248e-06,9.9104632e-06,1.0554501e-05,1.1240392e-05,1.1970856e-05,1.2748789e-05,1.3577278e-05,1.4459606e-05,1.5399272e-05,1.6400004e-05,1.7465768e-05,1.8600792e-05,1.9809576e-05,2.1096914e-05,2.2467911e-05,2.3928002e-05,2.5482978e-05,2.7139006e-05,2.8902651e-05,3.0780908e-05,3.2781225e-05,3.4911534e-05,3.7180282e-05,3.9596466e-05,4.2169667e-05,4.4910090e-05,4.7828601e-05,5.0936773e-05,5.4246931e-05,5.7772202e-05,6.1526565e-05,6.5524908e-05,6.9783085e-05,7.4317983e-05,7.9147585e-05,8.4291040e-05,8.9768747e-05,9.5602426e-05,0.00010181521,0.00010843174,0.00011547824,0.00012298267,0.00013097477,0.00013948625,0.00014855085,0.00015820453,0.00016848555,0.00017943469,0.00019109536,0.00020351382,0.00021673929,0.00023082423,0.00024582449,0.00026179955,0.00027881276,0.00029693158,0.00031622787,0.00033677814,0.00035866388,0.00038197188,0.00040679456,0.00043323036,0.00046138411,0.00049136745,0.00052329927,0.00055730621,0.00059352311,0.00063209358,0.00067317058,0.00071691700,0.00076350630,0.00081312324,0.00086596457,0.00092223983,0.00098217216,0.0010459992,0.0011139742,0.0011863665,0.0012634633,0.0013455702,0.0014330129,0.0015261382,0.0016253153,0.0017309374,0.0018434235,0.0019632195,0.0020908006,0.0022266726,0.0023713743,0.0025254795,0.0026895994,0.0028643847,0.0030505286,0.0032487691,0.0034598925,0.0036847358,0.0039241906,0.0041792066,0.0044507950,0.0047400328,0.0050480668,0.0053761186,0.0057254891,0.0060975636,0.0064938176,0.0069158225,0.0073652516,0.0078438871,0.0083536271,0.0088964928,0.009474637,0.010090352,0.010746080,0.011444421,0.012188144,0.012980198,0.013823725,0.014722068,0.015678791,0.016697687,0.017782797,0.018938423,0.020169149,0.021479854,0.022875735,0.024362330,0.025945531,0.027631618,0.029427276,0.031339626,0.033376252,0.035545228,0.037855157,0.040315199,0.042935108,0.045725273,0.048696758,0.051861348,0.055231591,0.058820850,0.062643361,0.066714279,0.071049749,0.075666962,0.080584227,0.085821044,0.091398179,0.097337747,0.10366330,0.11039993,0.11757434,0.12521498,0.13335215,0.14201813,0.15124727,0.16107617,0.17154380,0.18269168,0.19456402,0.20720788,0.22067342,0.23501402,0.25028656,0.26655159,0.28387361,0.30232132,0.32196786,0.34289114,0.36517414,0.38890521,0.41417847,0.44109412,0.46975890,0.50028648,0.53279791,0.56742212,0.60429640,0.64356699,0.68538959,0.72993007,0.77736504,0.82788260,0.88168307,0.9389798,1.0];
kha_audio2_ogg_vorbis_data_Codebook.NO_CODE = 255;
kha_audio2_ogg_vorbis_data_Codebook.delay = 0;
kha_audio2_ogg_vorbis_data_Header.PACKET_ID = 1;
kha_audio2_ogg_vorbis_data_Header.PACKET_COMMENT = 3;
kha_audio2_ogg_vorbis_data_Header.PACKET_SETUP = 5;
kha_audio2_ogg_vorbis_data_PageFlag.CONTINUED_PACKET = 1;
kha_audio2_ogg_vorbis_data_PageFlag.FIRST_PAGE = 2;
kha_audio2_ogg_vorbis_data_PageFlag.LAST_PAGE = 4;
kha_audio2_ogg_vorbis_data_Setting.MAX_CHANNELS = 16;
kha_audio2_ogg_vorbis_data_Setting.PUSHDATA_CRC_COUNT = 4;
kha_audio2_ogg_vorbis_data_Setting.FAST_HUFFMAN_LENGTH = 10;
kha_audio2_ogg_vorbis_data_Setting.FAST_HUFFMAN_TABLE_SIZE = 1024;
kha_audio2_ogg_vorbis_data_Setting.FAST_HUFFMAN_TABLE_MASK = 1023;
kha_graphics2_truetype_StbTruetype.STBTT_vmove = 1;
kha_graphics2_truetype_StbTruetype.STBTT_vline = 2;
kha_graphics2_truetype_StbTruetype.STBTT_vcurve = 3;
kha_graphics2_truetype_StbTruetype.STBTT_MACSTYLE_DONTCARE = 0;
kha_graphics2_truetype_StbTruetype.STBTT_MACSTYLE_BOLD = 1;
kha_graphics2_truetype_StbTruetype.STBTT_MACSTYLE_ITALIC = 2;
kha_graphics2_truetype_StbTruetype.STBTT_MACSTYLE_UNDERSCORE = 4;
kha_graphics2_truetype_StbTruetype.STBTT_MACSTYLE_NONE = 8;
kha_graphics2_truetype_StbTruetype.STBTT_PLATFORM_ID_UNICODE = 0;
kha_graphics2_truetype_StbTruetype.STBTT_PLATFORM_ID_MAC = 1;
kha_graphics2_truetype_StbTruetype.STBTT_PLATFORM_ID_ISO = 2;
kha_graphics2_truetype_StbTruetype.STBTT_PLATFORM_ID_MICROSOFT = 3;
kha_graphics2_truetype_StbTruetype.STBTT_UNICODE_EID_UNICODE_1_0 = 0;
kha_graphics2_truetype_StbTruetype.STBTT_UNICODE_EID_UNICODE_1_1 = 1;
kha_graphics2_truetype_StbTruetype.STBTT_UNICODE_EID_ISO_10646 = 2;
kha_graphics2_truetype_StbTruetype.STBTT_UNICODE_EID_UNICODE_2_0_BMP = 3;
kha_graphics2_truetype_StbTruetype.STBTT_UNICODE_EID_UNICODE_2_0_FULL = 4;
kha_graphics2_truetype_StbTruetype.STBTT_MS_EID_SYMBOL = 0;
kha_graphics2_truetype_StbTruetype.STBTT_MS_EID_UNICODE_BMP = 1;
kha_graphics2_truetype_StbTruetype.STBTT_MS_EID_SHIFTJIS = 2;
kha_graphics2_truetype_StbTruetype.STBTT_MS_EID_UNICODE_FULL = 10;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_EID_ROMAN = 0;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_EID_ARABIC = 4;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_EID_JAPANESE = 1;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_EID_HEBREW = 5;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_EID_CHINESE_TRAD = 2;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_EID_GREEK = 6;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_EID_KOREAN = 3;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_EID_RUSSIAN = 7;
kha_graphics2_truetype_StbTruetype.STBTT_MS_LANG_ENGLISH = 1033;
kha_graphics2_truetype_StbTruetype.STBTT_MS_LANG_ITALIAN = 1040;
kha_graphics2_truetype_StbTruetype.STBTT_MS_LANG_CHINESE = 2052;
kha_graphics2_truetype_StbTruetype.STBTT_MS_LANG_JAPANESE = 1041;
kha_graphics2_truetype_StbTruetype.STBTT_MS_LANG_DUTCH = 1043;
kha_graphics2_truetype_StbTruetype.STBTT_MS_LANG_KOREAN = 1042;
kha_graphics2_truetype_StbTruetype.STBTT_MS_LANG_FRENCH = 1036;
kha_graphics2_truetype_StbTruetype.STBTT_MS_LANG_RUSSIAN = 1049;
kha_graphics2_truetype_StbTruetype.STBTT_MS_LANG_GERMAN = 1031;
kha_graphics2_truetype_StbTruetype.STBTT_MS_LANG_SPANISH = 1033;
kha_graphics2_truetype_StbTruetype.STBTT_MS_LANG_HEBREW = 1037;
kha_graphics2_truetype_StbTruetype.STBTT_MS_LANG_SWEDISH = 1053;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_LANG_ENGLISH = 0;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_LANG_JAPANESE = 11;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_LANG_ARABIC = 12;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_LANG_KOREAN = 23;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_LANG_DUTCH = 4;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_LANG_RUSSIAN = 32;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_LANG_FRENCH = 1;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_LANG_SPANISH = 6;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_LANG_GERMAN = 2;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_LANG_SWEDISH = 5;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_LANG_HEBREW = 10;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_LANG_CHINESE_SIMPLIFIED = 33;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_LANG_ITALIAN = 3;
kha_graphics2_truetype_StbTruetype.STBTT_MAC_LANG_CHINESE_TRAD = 19;
kha_graphics2_truetype_StbTruetype.STBTT_MAX_OVERSAMPLE = 8;
kha_graphics2_truetype_StbTruetype.STBTT_RASTERIZER_VERSION = 2;
kha_graphics4_CubeMap.GL_RGBA16F = 34842;
kha_graphics4_CubeMap.GL_RGBA32F = 34836;
kha_graphics4_CubeMap.GL_R16F = 33325;
kha_graphics4_CubeMap.GL_R32F = 33326;
kha_graphics4_CubeMap.GL_DEPTH_COMPONENT24 = 33190;
kha_graphics4_CubeMap.GL_DEPTH24_STENCIL8 = 35056;
kha_graphics4_CubeMap.GL_DEPTH32F_STENCIL8 = 36013;
kha_graphics4_ImageShaderPainter.bufferSize = 1500;
kha_graphics4_ImageShaderPainter.vertexSize = 9;
kha_graphics4_ColoredShaderPainter.bufferSize = 100;
kha_graphics4_ColoredShaderPainter.triangleBufferSize = 100;
kha_graphics4_TextShaderPainter.bufferSize = 100;
kha_input_Gamepad.__meta__ = { statics : { sendConnectEvent : { input : null}, sendDisconnectEvent : { input : null}}, fields : { sendAxisEvent : { input : null}, sendButtonEvent : { input : null}}};
kha_input_Gamepad.instances = [];
kha_input_Gamepad.connectListeners = [];
kha_input_Gamepad.disconnectListeners = [];
kha_input_Keyboard.__meta__ = { fields : { sendDownEvent : { input : null}, sendUpEvent : { input : null}, sendPressEvent : { input : null}}};
kha_input_Mouse.__meta__ = { fields : { sendLeaveEvent : { input : null}, sendDownEvent : { input : null}, sendUpEvent : { input : null}, sendMoveEvent : { input : null}, sendWheelEvent : { input : null}}};
kha_internal_BytesBlob.bufferSize = 2000;
kha_internal_HdrFormat.radiancePattern = new EReg("#\\?RADIANCE","i");
kha_internal_HdrFormat.commentPattern = new EReg("#.*","i");
kha_internal_HdrFormat.gammaPattern = new EReg("GAMMA=","i");
kha_internal_HdrFormat.exposurePattern = new EReg("EXPOSURE=\\s*([0-9]*[.][0-9]*)","i");
kha_internal_HdrFormat.formatPattern = new EReg("FORMAT=32-bit_rle_rgbe","i");
kha_internal_HdrFormat.widthHeightPattern = new EReg("-Y ([0-9]+) \\+X ([0-9]+)","i");
kha_js_AEAudioChannel.todo = [];
kha_js_Sound.loading = [];
kha_math_FastMatrix3.width = 3;
kha_math_FastMatrix3.height = 3;
kha_math_FastMatrix4.width = 4;
kha_math_FastMatrix4.height = 4;
kha_math_Matrix3.width = 3;
kha_math_Matrix3.height = 3;
kha_math_Matrix4.width = 4;
kha_math_Matrix4.height = 4;
kha_math_Quaternion.AXIS_X = 0;
kha_math_Quaternion.AXIS_Y = 1;
kha_math_Quaternion.AXIS_Z = 2;
kha_network_ControllerBuilder.nextId = 0;
kha_network_Session.START = 0;
kha_network_Session.ENTITY_UPDATES = 1;
kha_network_Session.CONTROLLER_UPDATES = 2;
kha_network_Session.REMOTE_CALL = 3;
kha_network_Session.PING = 4;
kha_network_Session.ERROR = 5;
kha_network_Session.PLAYER_UPDATES = 6;
kha_network_Session.RPC_SERVER = 0;
kha_network_Session.RPC_ALL = 1;
kha_network_SyncBuilder.nextId = 0;
kha_network_SyncBuilder.objects = [];
trilateral_geom_Algebra.quadStep = 0.03;
trilateral_geom_Algebra.cubicStep = 0.03;
trilateralXtra_segment_Character5x7.GOLDEN_RATIO = 1.61803398874989484820;
trilateralXtra_segment_Character5x7.FIVESEVEN_RATIO = 1.4;
Main.main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
